; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\mathlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vec3_origin
PUBLIC	_boxpnt
PUBLIC	_m_bytenormals
_BSS	SEGMENT
_vec3_origin DD	03H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_m_bytenormals DD 0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	03f06964fr			; 0.525731
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	03f59c444r			; 0.850651
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	0bf59c444r			; -0.850651
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	0bf06964fr			; -0.525731
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	0bf06964fr			; -0.525731
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	0be9729f6r			; -0.295242
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	03e9729f6r			; 0.295242
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	03f59c444r			; 0.850651
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f06964fr			; 0.525731
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	03f74969ar			; 0.955423
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	03f59c444r			; 0.850651
	DD	0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	0bf59c444r			; -0.850651
	DD	0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	0bf06964fr			; -0.525731
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	0bf59c444r			; -0.850651
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	03e9729f6r			; 0.295242
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f06964fr			; 0.525731
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	0bf59c444r			; -0.850651
	DD	0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf06964fr			; -0.525731
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	03f59c444r			; 0.850651
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf74969ar			; -0.955423
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	0bf74969ar			; -0.955423
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
CONST	ENDS
_DATA	SEGMENT
_boxpnt	DD	00H
	DD	04H
	DD	06H
	DD	02H
	DD	00H
	DD	01H
	DD	05H
	DD	04H
	DD	00H
	DD	02H
	DD	03H
	DD	01H
	DD	07H
	DD	05H
	DD	01H
	DD	03H
	DD	07H
	DD	03H
	DD	02H
	DD	06H
	DD	07H
	DD	06H
	DD	04H
	DD	05H
_DATA	ENDS
PUBLIC	_rsqrt
PUBLIC	_anglemod
PUBLIC	_FloatToHalf
PUBLIC	_HalfToFloat
PUBLIC	_SimpleSpline
PUBLIC	_RoundUpHullSize
PUBLIC	_SignbitsForPlane
PUBLIC	_PlaneTypeForNormal
PUBLIC	_NearestPOW
PUBLIC	_SinCos
PUBLIC	_VectorNormalizeLength2
PUBLIC	_VectorCompareEpsilon
PUBLIC	_VectorVectors
PUBLIC	_VectorAngles
PUBLIC	_AngleVectors
PUBLIC	_VectorsAngles
PUBLIC	_PlanesGetIntersectionPoint
PUBLIC	_PlaneIntersect
PUBLIC	_ClearBounds
PUBLIC	_AddPointToBounds
PUBLIC	_BoundsIntersect
PUBLIC	_BoundsAndSphereIntersect
PUBLIC	_SphereIntersect
PUBLIC	_RadiusFromBounds
PUBLIC	_ExpandBounds
PUBLIC	_AngleQuaternion
PUBLIC	_QuaternionAngle
PUBLIC	_QuaternionSlerp
PUBLIC	_RemapVal
PUBLIC	_ApproachVal
PUBLIC	_QuaternionAlign
PUBLIC	_QuaternionSlerpNoAlign
PUBLIC	__real@00000000
PUBLIC	__real@358637bd
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f50624de0000000
PUBLIC	__real@3f76800000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@400921fb60000000
PUBLIC	__real@40400000
PUBLIC	__real@4066800000000000
PUBLIC	__real@4066c16c16c16c17
PUBLIC	__real@40800000
PUBLIC	__real@42652ee0
PUBLIC	__real@42b40000
PUBLIC	__real@43340000
PUBLIC	__real@43870000
PUBLIC	__real@43b40000
PUBLIC	__real@497423f0
PUBLIC	__real@bf800000
PUBLIC	__real@c2b40000
PUBLIC	__real@c97423f0
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_acos:PROC
EXTRN	_asin:PROC
EXTRN	_atan2:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_Matrix3x4_FromOriginQuat:PROC
EXTRN	_Matrix3x4_AnglesFromMatrix:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c97423f0
CONST	SEGMENT
__real@c97423f0 DD 0c97423f0r			; -999999
CONST	ENDS
;	COMDAT __real@c2b40000
CONST	SEGMENT
__real@c2b40000 DD 0c2b40000r			; -90
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@497423f0
CONST	SEGMENT
__real@497423f0 DD 0497423f0r			; 999999
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43870000
CONST	SEGMENT
__real@43870000 DD 043870000r			; 270
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42652ee0
CONST	SEGMENT
__real@42652ee0 DD 042652ee0r			; 57.2958
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4066c16c16c16c17
CONST	SEGMENT
__real@4066c16c16c16c17 DQ 04066c16c16c16c17r	; 182.044
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb60000000
CONST	SEGMENT
__real@400921fb60000000 DQ 0400921fb60000000r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f76800000000000
CONST	SEGMENT
__real@3f76800000000000 DQ 03f76800000000000r	; 0.00549316
CONST	ENDS
;	COMDAT __real@3f50624de0000000
CONST	SEGMENT
__real@3f50624de0000000 DQ 03f50624de0000000r	; 0.001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-06
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
_hull_table DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0cH
	DW	010H
	DW	012H
	DW	018H
	DW	01cH
	DW	020H
	DW	024H
	DW	028H
	DW	030H
	DW	036H
	DW	038H
	DW	03cH
	DW	040H
	DW	048H
	DW	050H
	DW	070H
	DW	078H
	DW	080H
	DW	08cH
	DW	0b0H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv244 = -40						; size = 8
tv238 = -32						; size = 8
_sinom$ = -24						; size = 4
_omega$ = -20						; size = 4
_cosom$ = -16						; size = 4
_sclq$ = -12						; size = 4
_sclp$ = -8						; size = 4
_i$ = -4						; size = 4
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_t$ = 16						; size = 4
_qt$ = 20						; size = 4
_QuaternionSlerpNoAlign PROC

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 700  : 	float	omega, cosom, sinom, sclp, sclq;
; 701  : 	int	i;
; 702  : 
; 703  : 	// 0.0 returns p, 1.0 return q.
; 704  : 	cosom = p[0] * q[0] + p[1] * q[1] + p[2] * q[2] + p[3] * q[3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _cosom$[ebp], xmm0

; 705  : 
; 706  : 	if(( 1.0f + cosom ) > 0.000001f )

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _cosom$[ebp]
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	$LN8@Quaternion

; 707  : 	{
; 708  : 		if(( 1.0f - cosom ) > 0.000001f )

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _cosom$[ebp]
	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	$LN10@Quaternion

; 709  : 		{
; 710  : 			omega = acos( cosom );

	cvtss2sd xmm0, DWORD PTR _cosom$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	DWORD PTR _omega$[ebp]

; 711  : 			sinom = sin( omega );

	cvtss2sd xmm0, DWORD PTR _omega$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	DWORD PTR _sinom$[ebp]

; 712  : 			sclp = sin( (1.0f - t) * omega) / sinom;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _t$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv238[ebp]
	movsd	xmm0, QWORD PTR tv238[ebp]
	cvtss2sd xmm1, DWORD PTR _sinom$[ebp]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sclp$[ebp], xmm0

; 713  : 			sclq = sin( t * omega ) / sinom;

	movss	xmm0, DWORD PTR _t$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv244[ebp]
	movsd	xmm0, QWORD PTR tv244[ebp]
	cvtss2sd xmm1, DWORD PTR _sinom$[ebp]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sclq$[ebp], xmm0

; 714  : 		}

	jmp	SHORT $LN11@Quaternion
$LN10@Quaternion:

; 715  : 		else
; 716  : 		{
; 717  : 			sclp = 1.0f - t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _sclp$[ebp], xmm0

; 718  : 			sclq = t;

	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _sclq$[ebp], xmm0
$LN11@Quaternion:

; 719  : 		}
; 720  : 
; 721  : 		for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Quaternion
$LN2@Quaternion:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Quaternion:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@Quaternion

; 722  : 		{
; 723  : 			qt[i] = sclp * p[i] + sclq * q[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR _sclp$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	movss	xmm1, DWORD PTR _sclq$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax*4]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _qt$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0

; 724  : 		}

	jmp	SHORT $LN2@Quaternion
$LN3@Quaternion:

; 725  : 	}

	jmp	$LN6@Quaternion
$LN8@Quaternion:

; 726  : 	else
; 727  : 	{
; 728  : 		qt[0] = -q[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _q$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _qt$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 729  : 		qt[1] = q[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _qt$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 730  : 		qt[2] = -q[3];

	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _q$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _qt$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 731  : 		qt[3] = q[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _qt$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 732  : 		sclp = sin(( 1.0f - t ) * ( 0.5f * M_PI ));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _t$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc90fdb
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	DWORD PTR _sclp$[ebp]

; 733  : 		sclq = sin( t * ( 0.5f * M_PI ));

	movss	xmm0, DWORD PTR _t$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc90fdb
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	DWORD PTR _sclq$[ebp]

; 734  : 
; 735  : 		for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Quaternion
$LN5@Quaternion:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Quaternion:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@Quaternion

; 736  : 		{
; 737  : 			qt[i] = sclp * p[i] + sclq * qt[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR _sclp$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _qt$[ebp]
	movss	xmm1, DWORD PTR _sclq$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx*4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _qt$[ebp]
	movss	DWORD PTR [edx+ecx*4], xmm0

; 738  : 		}

	jmp	SHORT $LN5@Quaternion
$LN6@Quaternion:

; 739  : 	}
; 740  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_QuaternionSlerpNoAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_b$ = -12						; size = 4
_a$ = -8						; size = 4
_i$ = -4						; size = 4
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_qt$ = 16						; size = 4
_QuaternionAlign PROC

; 669  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 670  : 	// decide if one of the quaternions is backwards
; 671  : 	float	a = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _a$[ebp], xmm0

; 672  : 	float	b = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _b$[ebp], xmm0

; 673  : 	int	i;
; 674  : 
; 675  : 	for( i = 0; i < 4; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Quaternion
$LN2@Quaternion:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Quaternion:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@Quaternion

; 676  : 	{
; 677  : 		a += (p[i] - q[i]) * (p[i] - q[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx*4]
	subss	xmm1, DWORD PTR [esi+eax*4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR _a$[ebp], xmm0

; 678  : 		b += (p[i] + q[i]) * (p[i] + q[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	addss	xmm0, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx*4]
	addss	xmm1, DWORD PTR [esi+eax*4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 679  : 	}

	jmp	$LN2@Quaternion
$LN3@Quaternion:

; 680  : 
; 681  : 	if( a > b ) 

	movss	xmm0, DWORD PTR _a$[ebp]
	comiss	xmm0, DWORD PTR _b$[ebp]
	jbe	SHORT $LN11@Quaternion

; 682  : 	{
; 683  : 		for( i = 0; i < 4; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Quaternion
$LN5@Quaternion:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@Quaternion:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN6@Quaternion

; 684  : 			qt[i] = -q[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _q$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _qt$[ebp]
	movss	DWORD PTR [edx+ecx*4], xmm0
	jmp	SHORT $LN5@Quaternion
$LN6@Quaternion:

; 685  : 	}

	jmp	SHORT $LN9@Quaternion
$LN11@Quaternion:

; 686  : 	else
; 687  : 	{
; 688  : 		for( i = 0; i < 4; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Quaternion
$LN8@Quaternion:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Quaternion:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN9@Quaternion

; 689  : 			qt[i] = q[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _qt$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN8@Quaternion
$LN9@Quaternion:

; 690  : 	}
; 691  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_QuaternionAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_delta$ = -4						; size = 4
_target$ = 8						; size = 4
_value$ = 12						; size = 4
_speed$ = 16						; size = 4
_ApproachVal PROC

; 271  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 272  : 	float	delta = target - value;

	movss	xmm0, DWORD PTR _target$[ebp]
	subss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR _delta$[ebp], xmm0

; 273  : 
; 274  : 	if( delta > speed )

	movss	xmm0, DWORD PTR _delta$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN2@ApproachVa

; 275  : 		value += speed;

	movss	xmm0, DWORD PTR _value$[ebp]
	addss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0
	jmp	SHORT $LN5@ApproachVa
$LN2@ApproachVa:

; 276  : 	else if( delta < -speed )

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _delta$[ebp]
	jbe	SHORT $LN4@ApproachVa

; 277  : 		value -= speed;

	movss	xmm0, DWORD PTR _value$[ebp]
	subss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0
	jmp	SHORT $LN5@ApproachVa
$LN4@ApproachVa:

; 278  : 	else value = target;

	movss	xmm0, DWORD PTR _target$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0
$LN5@ApproachVa:

; 279  : 
; 280  : 	return value;

	fld	DWORD PTR _value$[ebp]

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ApproachVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv78 = -4						; size = 4
_val$ = 8						; size = 4
_A$ = 12						; size = 4
_B$ = 16						; size = 4
_C$ = 20						; size = 4
_D$ = 24						; size = 4
_RemapVal PROC

; 266  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 267  : 	return C + (D - C) * (val - A) / (B - A);

	movss	xmm0, DWORD PTR _D$[ebp]
	subss	xmm0, DWORD PTR _C$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _A$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _B$[ebp]
	subss	xmm1, DWORD PTR _A$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _C$[ebp]
	movss	DWORD PTR tv78[ebp], xmm0
	fld	DWORD PTR tv78[ebp]

; 268  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RemapVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_q2$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_t$ = 16						; size = 4
_qt$ = 20						; size = 4
_QuaternionSlerp PROC

; 750  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 751  : 	vec4_t	q2;
; 752  : 
; 753  : 	// 0.0 returns p, 1.0 return q.
; 754  : 	// decide if one of the quaternions is backwards
; 755  : 	QuaternionAlign( p, q, q2 );

	lea	eax, DWORD PTR _q2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_QuaternionAlign
	add	esp, 12					; 0000000cH

; 756  : 
; 757  : 	QuaternionSlerpNoAlign( p, q2, t, qt );

	mov	eax, DWORD PTR _qt$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_QuaternionSlerpNoAlign
	add	esp, 16					; 00000010H

; 758  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_QuaternionSlerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_mat$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_angles$ = 12						; size = 4
_QuaternionAngle PROC

; 654  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 655  : 	matrix3x4	mat;
; 656  : 	Matrix3x4_FromOriginQuat( mat, q, vec3_origin );

	push	OFFSET _vec3_origin
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	_Matrix3x4_FromOriginQuat
	add	esp, 12					; 0000000cH

; 657  : 	Matrix3x4_AnglesFromMatrix( mat, angles );

	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	call	_Matrix3x4_AnglesFromMatrix
	add	esp, 8

; 658  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_QuaternionAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_sy$ = -24						; size = 4
_sp$ = -20						; size = 4
_sr$ = -16						; size = 4
_cy$ = -12						; size = 4
_cp$ = -8						; size = 4
_cr$ = -4						; size = 4
_angles$ = 8						; size = 4
_q$ = 12						; size = 4
_studio$ = 16						; size = 4
_AngleQuaternion PROC

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 626  : 	float	sr, sp, sy, cr, cp, cy;
; 627  : 
; 628  : 	if( studio )

	cmp	DWORD PTR _studio$[ebp], 0
	je	$LN2@AngleQuate

; 629  : 	{
; 630  : 		SinCos( angles[ROLL] * 0.5f, &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 631  : 		SinCos( angles[YAW] * 0.5f, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 632  : 		SinCos( angles[PITCH] * 0.5f, &sr, &cr );

	lea	edx, DWORD PTR _cr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sr$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 633  : 	}

	jmp	$LN3@AngleQuate
$LN2@AngleQuate:

; 634  : 	else
; 635  : 	{
; 636  : 		SinCos( DEG2RAD( angles[YAW] ) * 0.5f, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 637  : 		SinCos( DEG2RAD( angles[PITCH] ) * 0.5f, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 638  : 		SinCos( DEG2RAD( angles[ROLL] ) * 0.5f, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH
$LN3@AngleQuate:

; 639  : 	}
; 640  : 
; 641  : 	q[0] = sr * cp * cy - cr * sp * sy; // X

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _cr$[ebp]
	mulss	xmm1, DWORD PTR _sp$[ebp]
	mulss	xmm1, DWORD PTR _sy$[ebp]
	subss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _q$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 642  : 	q[1] = cr * sp * cy + sr * cp * sy; // Y

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	mulss	xmm1, DWORD PTR _cp$[ebp]
	mulss	xmm1, DWORD PTR _sy$[ebp]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _q$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 643  : 	q[2] = cr * cp * sy - sr * sp * cy; // Z

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	mulss	xmm1, DWORD PTR _sp$[ebp]
	mulss	xmm1, DWORD PTR _cy$[ebp]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _q$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 644  : 	q[3] = cr * cp * cy + sr * sp * sy; // W

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	mulss	xmm1, DWORD PTR _sp$[ebp]
	mulss	xmm1, DWORD PTR _sy$[ebp]
	addss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _q$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 645  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_AngleQuaternion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_offset$ = 16						; size = 4
_ExpandBounds PROC

; 521  : {

	push	ebp
	mov	ebp, esp

; 522  : 	mins[0] -= offset;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mins$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 523  : 	mins[1] -= offset;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 524  : 	mins[2] -= offset;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 525  : 	maxs[0] += offset;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _offset$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 526  : 	maxs[1] += offset;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _offset$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 527  : 	maxs[2] += offset;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _offset$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _maxs$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 528  : }

	pop	ebp
	ret	0
_ExpandBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv190 = -64						; size = 8
tv164 = -56						; size = 8
tv195 = -48						; size = 8
tv157 = -40						; size = 8
tv89 = -32						; size = 8
tv192 = -24						; size = 4
_i$ = -20						; size = 4
_corner$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_RadiusFromBounds PROC

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 605  : 	vec3_t	corner;
; 606  : 	int	i;
; 607  : 
; 608  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@RadiusFrom
$LN2@RadiusFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@RadiusFrom:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@RadiusFrom

; 609  : 	{
; 610  : 		corner[i] = fabs( mins[i] ) > fabs( maxs[i] ) ? fabs( mins[i] ) : fabs( maxs[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _mins$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR tv157[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _maxs$[ebp]
	cvtss2sd xmm1, DWORD PTR [ecx+eax*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv195[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv164[ebp]
	movsd	xmm0, QWORD PTR tv195[ebp]
	comisd	xmm0, QWORD PTR tv164[ebp]
	jbe	SHORT $LN6@RadiusFrom
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _mins$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv89[ebp]
	jmp	SHORT $LN7@RadiusFrom
$LN6@RadiusFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _maxs$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv89[ebp]
$LN7@RadiusFrom:
	cvtsd2ss xmm0, QWORD PTR tv89[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _corner$[ebp+eax*4], xmm0

; 611  : 	}

	jmp	$LN2@RadiusFrom
$LN3@RadiusFrom:

; 612  : 	return VectorLength( corner );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _corner$[ebp+edx]
	mulss	xmm0, DWORD PTR _corner$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _corner$[ebp+edx]
	mulss	xmm1, DWORD PTR _corner$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _corner$[ebp+ecx]
	mulss	xmm1, DWORD PTR _corner$[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv190[ebp]
	movsd	xmm0, QWORD PTR tv190[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv192[ebp], xmm0
	fld	DWORD PTR tv192[ebp]

; 613  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_RadiusFromBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_insideSqr$ = -36					; size = 4
_c$ = -32						; size = 4
_a$ = -28						; size = 4
tv84 = -24						; size = 4
_b$ = -20						; size = 4
_p$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_vSphereCenter$ = 8					; size = 4
_fSphereRadiusSquared$ = 12				; size = 4
_vLinePt$ = 16						; size = 4
_vLineDir$ = 20						; size = 4
_SphereIntersect PROC

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 565  : 	float	a, b, c, insideSqr;
; 566  : 	vec3_t	p;
; 567  : 
; 568  : 	// translate sphere to origin.
; 569  : 	VectorSubtract( vLinePt, vSphereCenter, p );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vLinePt$[ebp]
	mov	esi, DWORD PTR _vSphereCenter$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _p$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vLinePt$[ebp]
	mov	esi, DWORD PTR _vSphereCenter$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _p$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vLinePt$[ebp]
	mov	esi, DWORD PTR _vSphereCenter$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv84[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv84[ebp]
	movss	DWORD PTR _p$[ebp+eax], xmm0

; 570  : 
; 571  : 	a = DotProduct( vLineDir, vLineDir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _vLineDir$[ebp]
	mov	esi, DWORD PTR _vLineDir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _vLineDir$[ebp]
	mov	esi, DWORD PTR _vLineDir$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _vLineDir$[ebp]
	mov	esi, DWORD PTR _vLineDir$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR _a$[ebp], xmm0

; 572  : 	b = 2.0f * DotProduct( p, vLineDir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _vLineDir$[ebp]
	movss	xmm0, DWORD PTR _p$[ebp+edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _vLineDir$[ebp]
	movss	xmm1, DWORD PTR _p$[ebp+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _vLineDir$[ebp]
	movss	xmm1, DWORD PTR _p$[ebp+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _b$[ebp], xmm0

; 573  : 	c = DotProduct( p, p ) - fSphereRadiusSquared;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _p$[ebp+edx]
	mulss	xmm0, DWORD PTR _p$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _p$[ebp+edx]
	mulss	xmm1, DWORD PTR _p$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _p$[ebp+ecx]
	mulss	xmm1, DWORD PTR _p$[ebp+edx]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _fSphereRadiusSquared$[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 574  : 
; 575  : 	insideSqr = b * b - 4.0f * a * c;

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR __real@40800000
	mulss	xmm1, DWORD PTR _a$[ebp]
	mulss	xmm1, DWORD PTR _c$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _insideSqr$[ebp], xmm0

; 576  : 	if( insideSqr <= 0.000001f )

	movss	xmm0, DWORD PTR __real@358637bd
	comiss	xmm0, DWORD PTR _insideSqr$[ebp]
	jb	SHORT $LN2@SphereInte

; 577  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SphereInte
$LN2@SphereInte:

; 578  : 	return true;

	mov	eax, 1
$LN1@SphereInte:

; 579  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SphereIntersect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_origin$ = 16						; size = 4
_radius$ = 20						; size = 4
_BoundsAndSphereIntersect PROC

; 550  : {

	push	ebp
	mov	ebp, esp

; 551  : 	if( mins[0] > origin[0] + radius || mins[1] > origin[1] + radius || mins[2] > origin[2] + radius )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	comiss	xmm1, xmm0
	ja	SHORT $LN3@BoundsAndS
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	comiss	xmm1, xmm0
	ja	SHORT $LN3@BoundsAndS
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _radius$[ebp]
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@BoundsAndS
$LN3@BoundsAndS:

; 552  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@BoundsAndS
$LN2@BoundsAndS:

; 553  : 	if( maxs[0] < origin[0] - radius || maxs[1] < origin[1] - radius || maxs[2] < origin[2] - radius )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _maxs$[ebp]
	comiss	xmm0, DWORD PTR [edx+eax]
	ja	SHORT $LN5@BoundsAndS
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _radius$[ebp]
	mov	ecx, DWORD PTR _maxs$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax]
	ja	SHORT $LN5@BoundsAndS
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _maxs$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN4@BoundsAndS
$LN5@BoundsAndS:

; 554  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@BoundsAndS
$LN4@BoundsAndS:

; 555  : 	return true;

	mov	eax, 1
$LN1@BoundsAndS:

; 556  : }

	pop	ebp
	ret	0
_BoundsAndSphereIntersect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_mins1$ = 8						; size = 4
_maxs1$ = 12						; size = 4
_mins2$ = 16						; size = 4
_maxs2$ = 20						; size = 4
_BoundsIntersect PROC

; 536  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 537  : 	if( mins1[0] > maxs2[0] || mins1[1] > maxs2[1] || mins1[2] > maxs2[2] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins1$[ebp]
	mov	esi, DWORD PTR _maxs2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	comiss	xmm0, DWORD PTR [esi+eax]
	ja	SHORT $LN3@BoundsInte
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mins1$[ebp]
	mov	esi, DWORD PTR _maxs2$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	comiss	xmm0, DWORD PTR [esi+ecx]
	ja	SHORT $LN3@BoundsInte
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins1$[ebp]
	mov	esi, DWORD PTR _maxs2$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	comiss	xmm0, DWORD PTR [esi+ecx]
	jbe	SHORT $LN2@BoundsInte
$LN3@BoundsInte:

; 538  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@BoundsInte
$LN2@BoundsInte:

; 539  : 	if( maxs1[0] < mins2[0] || maxs1[1] < mins2[1] || maxs1[2] < mins2[2] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins2$[ebp]
	mov	esi, DWORD PTR _maxs1$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	comiss	xmm0, DWORD PTR [esi+ecx]
	ja	SHORT $LN5@BoundsInte
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mins2$[ebp]
	mov	esi, DWORD PTR _maxs1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	comiss	xmm0, DWORD PTR [esi+eax]
	ja	SHORT $LN5@BoundsInte
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins2$[ebp]
	mov	esi, DWORD PTR _maxs1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	comiss	xmm0, DWORD PTR [esi+eax]
	jbe	SHORT $LN4@BoundsInte
$LN5@BoundsInte:

; 540  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@BoundsInte
$LN4@BoundsInte:

; 541  : 	return true;

	mov	eax, 1
$LN1@BoundsInte:

; 542  : }

	pop	esi
	pop	ebp
	ret	0
_BoundsIntersect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_val$ = -8						; size = 4
_i$ = -4						; size = 4
_v$ = 8							; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_AddPointToBounds PROC

; 503  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 504  : 	float	val;
; 505  : 	int	i;
; 506  : 
; 507  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@AddPointTo
$LN2@AddPointTo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@AddPointTo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@AddPointTo

; 508  : 	{
; 509  : 		val = v[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _val$[ebp], xmm0

; 510  : 		if( val < mins[i] ) mins[i] = val;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN5@AddPointTo
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
$LN5@AddPointTo:

; 511  : 		if( val > maxs[i] ) maxs[i] = val;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jbe	SHORT $LN6@AddPointTo
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN6@AddPointTo:

; 512  : 	}

	jmp	SHORT $LN2@AddPointTo
$LN3@AddPointTo:

; 513  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_AddPointToBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_ClearBounds PROC

; 491  : {

	push	ebp
	mov	ebp, esp

; 492  : 	// make bogus range
; 493  : 	mins[0] = mins[1] = mins[2] =  999999.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR [eax+edx], xmm0

; 494  : 	maxs[0] = maxs[1] = maxs[2] = -999999.0f;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR [ecx+eax], xmm0

; 495  : }

	pop	ebp
	ret	0
_ClearBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv174 = -20						; size = 4
_planeDotRay$ = -16					; size = 4
_distToPlane$ = -12					; size = 4
tv92 = -8						; size = 4
_sect$ = -4						; size = 4
_plane$ = 8						; size = 4
_p0$ = 12						; size = 4
_p1$ = 16						; size = 4
_out$ = 20						; size = 4
_PlaneIntersect PROC

; 590  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 591  : 	float distToPlane = PlaneDiff( p0, plane );

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN3@PlaneInter
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p0$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN4@PlaneInter
$LN3@PlaneInter:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p0$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p0$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p0$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv92[ebp], xmm0
$LN4@PlaneInter:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv92[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _distToPlane$[ebp], xmm0

; 592  : 	float planeDotRay = DotProduct( plane->normal, p1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _planeDotRay$[ebp], xmm0

; 593  : 	float sect = -(distToPlane) / planeDotRay;

	movss	xmm0, DWORD PTR _distToPlane$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _planeDotRay$[ebp]
	movss	DWORD PTR _sect$[ebp], xmm0

; 594  : 
; 595  : 	VectorMA( p0, sect, p1, out );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR _sect$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _p0$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR _sect$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _p0$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR _sect$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _p0$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv174[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 596  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_PlaneIntersect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv495 = -120						; size = 4
tv471 = -116						; size = 4
tv441 = -112						; size = 4
tv411 = -108						; size = 4
tv356 = -104						; size = 4
tv317 = -100						; size = 4
tv278 = -96						; size = 4
_denom$ = -92						; size = 4
_ilength$1 = -88					; size = 4
_ilength$2 = -84					; size = 4
_ilength$3 = -80					; size = 4
_n1n2$ = -76						; size = 12
_n3n1$ = -64						; size = 12
_n2n3$ = -52						; size = 12
_n3$ = -40						; size = 12
_n2$ = -28						; size = 12
_n1$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_plane1$ = 8						; size = 4
_plane2$ = 12						; size = 4
_plane3$ = 16						; size = 4
_out$ = 20						; size = 4
_PlanesGetIntersectionPoint PROC

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 210  : 	vec3_t	n1, n2, n3;
; 211  : 	vec3_t	n1n2, n2n3, n3n1;
; 212  : 	float	denom;
; 213  : 
; 214  : 	VectorNormalize2( plane1->normal, n1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _plane1$[ebp]
	mov	esi, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane1$[ebp]
	mov	esi, DWORD PTR _plane1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plane1$[ebp]
	mov	esi, DWORD PTR _plane1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PlanesGetI
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN2@PlanesGetI:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _n1$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _n1$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _n1$[ebp+ecx], xmm0

; 215  : 	VectorNormalize2( plane2->normal, n2 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _plane2$[ebp]
	mov	esi, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plane2$[ebp]
	mov	esi, DWORD PTR _plane2$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _plane2$[ebp]
	mov	esi, DWORD PTR _plane2$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@PlanesGetI
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN3@PlanesGetI:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _n2$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _n2$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _n2$[ebp+eax], xmm0

; 216  : 	VectorNormalize2( plane3->normal, n3 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _plane3$[ebp]
	mov	esi, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _plane3$[ebp]
	mov	esi, DWORD PTR _plane3$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane3$[ebp]
	mov	esi, DWORD PTR _plane3$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@PlanesGetI
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN4@PlanesGetI:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _n3$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _n3$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _n3$[ebp+edx], xmm0

; 217  : 
; 218  : 	CrossProduct( n1, n2, n1n2 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _n1$[ebp+eax]
	mulss	xmm0, DWORD PTR _n2$[ebp+ecx]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _n1$[ebp+edx]
	mulss	xmm1, DWORD PTR _n2$[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _n1n2$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _n1$[ebp+eax]
	mulss	xmm0, DWORD PTR _n2$[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _n1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _n2$[ebp+edx]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _n1n2$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _n1$[ebp+edx]
	mulss	xmm0, DWORD PTR _n2$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _n1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _n2$[ebp+eax]
	subss	xmm0, xmm1
	movss	DWORD PTR tv278[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv278[ebp]
	movss	DWORD PTR _n1n2$[ebp+ecx], xmm0

; 219  : 	CrossProduct( n2, n3, n2n3 );

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _n2$[ebp+edx]
	mulss	xmm0, DWORD PTR _n3$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _n2$[ebp+ecx]
	mulss	xmm1, DWORD PTR _n3$[ebp+edx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _n2n3$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _n2$[ebp+edx]
	mulss	xmm0, DWORD PTR _n3$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _n2$[ebp+eax]
	mulss	xmm1, DWORD PTR _n3$[ebp+ecx]
	subss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _n2n3$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _n2$[ebp+ecx]
	mulss	xmm0, DWORD PTR _n3$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR _n2$[ebp+eax]
	mulss	xmm1, DWORD PTR _n3$[ebp+edx]
	subss	xmm0, xmm1
	movss	DWORD PTR tv317[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv317[ebp]
	movss	DWORD PTR _n2n3$[ebp+eax], xmm0

; 220  : 	CrossProduct( n3, n1, n3n1 );

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _n3$[ebp+ecx]
	mulss	xmm0, DWORD PTR _n1$[ebp+edx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _n3$[ebp+eax]
	mulss	xmm1, DWORD PTR _n1$[ebp+ecx]
	subss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _n3n1$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _n3$[ebp+ecx]
	mulss	xmm0, DWORD PTR _n1$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _n3$[ebp+edx]
	mulss	xmm1, DWORD PTR _n1$[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _n3n1$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _n3$[ebp+eax]
	mulss	xmm0, DWORD PTR _n1$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm1, DWORD PTR _n3$[ebp+edx]
	mulss	xmm1, DWORD PTR _n1$[ebp+ecx]
	subss	xmm0, xmm1
	movss	DWORD PTR tv356[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR _n3n1$[ebp+edx], xmm0

; 221  : 
; 222  : 	denom = DotProduct( n1, n2n3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _n1$[ebp+ecx]
	mulss	xmm0, DWORD PTR _n2n3$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _n1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _n2n3$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _n1$[ebp+eax]
	mulss	xmm1, DWORD PTR _n2n3$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _denom$[ebp], xmm0

; 223  : 	VectorClear( out );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0

; 224  : 
; 225  : 	// check if the denominator is zero (which would mean that no intersection is to be found
; 226  : 	if( denom == 0.0f )

	movss	xmm0, DWORD PTR _denom$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PlanesGetI

; 227  : 	{
; 228  : 		// no intersection could be found, return <0,0,0>
; 229  : 		return false;

	xor	eax, eax
	jmp	$LN1@PlanesGetI
$LN5@PlanesGetI:

; 230  : 	}
; 231  : 
; 232  : 	// compute intersection point
; 233  : #if 0
; 234  : 	VectorMAMAM( plane1->dist, n2n3, plane2->dist, n3n1, plane3->dist, n1n2, out );
; 235  : #else
; 236  : 	VectorMA( out, plane1->dist, n2n3, out );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mov	eax, 4
	imul	edx, eax, 0
	mulss	xmm0, DWORD PTR _n2n3$[ebp+edx]
	mov	eax, DWORD PTR _out$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _n2n3$[ebp+eax]
	mov	edx, DWORD PTR _out$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane1$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm0, DWORD PTR _n2n3$[ebp+ecx]
	mov	eax, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv411[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv411[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 237  : 	VectorMA( out, plane2->dist, n3n1, out );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mov	eax, 4
	imul	edx, eax, 0
	mulss	xmm0, DWORD PTR _n3n1$[ebp+edx]
	mov	eax, DWORD PTR _out$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _n3n1$[ebp+eax]
	mov	edx, DWORD PTR _out$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane2$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm0, DWORD PTR _n3n1$[ebp+ecx]
	mov	eax, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv441[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv441[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 238  : 	VectorMA( out, plane3->dist, n1n2, out );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mov	eax, 4
	imul	edx, eax, 0
	mulss	xmm0, DWORD PTR _n1n2$[ebp+edx]
	mov	eax, DWORD PTR _out$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _n1n2$[ebp+eax]
	mov	edx, DWORD PTR _out$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane3$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm0, DWORD PTR _n1n2$[ebp+ecx]
	mov	eax, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv471[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv471[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 239  : #endif
; 240  : 	VectorScale( out, ( 1.0f / denom ), out );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _denom$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _denom$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _denom$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv495[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv495[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 241  : 
; 242  : 	return true;

	mov	eax, 1
$LN1@PlanesGetI:

; 243  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PlanesGetIntersectionPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv235 = -60						; size = 8
tv217 = -52						; size = 8
tv204 = -44						; size = 8
tv189 = -36						; size = 8
tv180 = -28						; size = 8
_roll$ = -20						; size = 4
_yaw$ = -16						; size = 4
tv148 = -12						; size = 4
_pitch$ = -8						; size = 4
_cpitch$ = -4						; size = 4
_forward$ = 8						; size = 4
_right$ = 12						; size = 4
_up$ = 16						; size = 4
_angles$ = 20						; size = 4
_VectorsAngles PROC

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 458  : 	float	pitch, cpitch, yaw, roll;
; 459  : 
; 460  : 	pitch = -asin( forward[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _forward$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_asin
	add	esp, 8
	fstp	QWORD PTR tv180[ebp]
	movsd	xmm0, QWORD PTR tv180[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _pitch$[ebp], xmm0

; 461  : 	cpitch = cos( pitch );

	cvtss2sd xmm0, DWORD PTR _pitch$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	DWORD PTR _cpitch$[ebp]

; 462  : 
; 463  : 	if( fabs( cpitch ) > EQUAL_EPSILON )	// gimball lock?

	cvtss2sd xmm0, DWORD PTR _cpitch$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv189[ebp]
	movsd	xmm0, QWORD PTR tv189[ebp]
	comisd	xmm0, QWORD PTR __real@3f50624de0000000
	jbe	$LN2@VectorsAng

; 464  : 	{
; 465  : 		cpitch = 1.0f / cpitch;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _cpitch$[ebp]
	movss	DWORD PTR _cpitch$[ebp], xmm0

; 466  : 		pitch = RAD2DEG( pitch );

	movss	xmm0, DWORD PTR _pitch$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee0
	movss	DWORD PTR _pitch$[ebp], xmm0

; 467  : 		yaw = RAD2DEG( atan2( forward[1] * cpitch, forward[0] * cpitch ));

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _cpitch$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _cpitch$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv204[ebp]
	movsd	xmm0, QWORD PTR tv204[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee0
	movss	DWORD PTR _yaw$[ebp], xmm0

; 468  : 		roll = RAD2DEG( atan2( -right[2] * cpitch, up[2] * cpitch ));

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _up$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _cpitch$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _cpitch$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv217[ebp]
	movsd	xmm0, QWORD PTR tv217[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee0
	movss	DWORD PTR _roll$[ebp], xmm0

; 469  : 	}

	jmp	$LN3@VectorsAng
$LN2@VectorsAng:

; 470  : 	else
; 471  : 	{
; 472  : 		pitch = forward[2] > 0 ? -90.0f : 90.0f;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@VectorsAng
	movss	xmm0, DWORD PTR __real@c2b40000
	movss	DWORD PTR tv148[ebp], xmm0
	jmp	SHORT $LN6@VectorsAng
$LN5@VectorsAng:
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR tv148[ebp], xmm0
$LN6@VectorsAng:
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _pitch$[ebp], xmm0

; 473  : 		yaw = RAD2DEG( atan2( right[0], -right[1] ));

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _right$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv235[ebp]
	movsd	xmm0, QWORD PTR tv235[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee0
	movss	DWORD PTR _yaw$[ebp], xmm0

; 474  : 		roll = 180.0f;

	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR _roll$[ebp], xmm0
$LN3@VectorsAng:

; 475  : 	}
; 476  : 
; 477  : 	angles[PITCH] = pitch;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 478  : 	angles[YAW] = yaw;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 479  : 	angles[ROLL] = roll;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 480  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_VectorsAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_cp$ = -24						; size = 4
_cr$ = -20						; size = 4
_cy$ = -16						; size = 4
_sr$ = -12						; size = 4
_sy$ = -8						; size = 4
_sp$ = -4						; size = 4
_angles$ = 8						; size = 4
_forward$ = 12						; size = 4
_right$ = 16						; size = 4
_up$ = 20						; size = 4
_AngleVectors PROC

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 385  : 	float	sr, sp, sy, cr, cp, cy;
; 386  : 
; 387  : 	SinCos( DEG2RAD( angles[YAW] ), &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 388  : 	SinCos( DEG2RAD( angles[PITCH] ), &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 389  : 	SinCos( DEG2RAD( angles[ROLL] ), &sr, &cr );

	lea	eax, DWORD PTR _cr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sr$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 390  : 
; 391  : 	if( forward )

	cmp	DWORD PTR _forward$[ebp], 0
	je	SHORT $LN2@AngleVecto

; 392  : 	{
; 393  : 		forward[0] = cp * cy;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _forward$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 394  : 		forward[1] = cp * sy;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _forward$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 395  : 		forward[2] = -sp;

	movss	xmm0, DWORD PTR _sp$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _forward$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN2@AngleVecto:

; 396  : 	}
; 397  : 
; 398  : 	if( right )

	cmp	DWORD PTR _right$[ebp], 0
	je	$LN3@AngleVecto

; 399  : 	{
; 400  : 		right[0] = (-1.0f * sr * sp * cy + -1.0f * cr * -sy );

	movss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR __real@bf800000
	mulss	xmm1, DWORD PTR _cr$[ebp]
	movss	xmm2, DWORD PTR _sy$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 401  : 		right[1] = (-1.0f * sr * sp * sy + -1.0f * cr * cy );

	movss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR __real@bf800000
	mulss	xmm1, DWORD PTR _cr$[ebp]
	mulss	xmm1, DWORD PTR _cy$[ebp]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _right$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 402  : 		right[2] = (-1.0f * sr * cp);

	movss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
$LN3@AngleVecto:

; 403  : 	}
; 404  : 
; 405  : 	if( up )

	cmp	DWORD PTR _up$[ebp], 0
	je	$LN4@AngleVecto

; 406  : 	{
; 407  : 		up[0] = (cr * sp * cy + -sr * -sy );

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm2, DWORD PTR _sy$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _up$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 408  : 		up[1] = (cr * sp * sy + -sr * cy );

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR _cy$[ebp]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _up$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 409  : 		up[2] = (cr * cp);

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _up$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN4@AngleVecto:

; 410  : 	}
; 411  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_AngleVectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv222 = -28						; size = 8
tv198 = -20						; size = 8
_tmp$ = -12						; size = 4
_yaw$ = -8						; size = 4
_pitch$ = -4						; size = 4
_forward$ = 8						; size = 4
_angles$ = 12						; size = 4
_VectorAngles PROC

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 421  : 	float	tmp, yaw, pitch;
; 422  : 
; 423  : 	if( !forward || !angles )

	cmp	DWORD PTR _forward$[ebp], 0
	je	SHORT $LN3@VectorAngl
	cmp	DWORD PTR _angles$[ebp], 0
	jne	SHORT $LN2@VectorAngl
$LN3@VectorAngl:

; 424  : 	{
; 425  : 		if( angles ) VectorClear( angles );

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN4@VectorAngl
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN4@VectorAngl:

; 426  : 		return;

	jmp	$LN1@VectorAngl
$LN2@VectorAngl:

; 427  : 	}
; 428  : 
; 429  : 	if( forward[1] == 0 && forward[0] == 0 )

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@VectorAngl
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@VectorAngl

; 430  : 	{
; 431  : 		// fast case
; 432  : 		yaw = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _yaw$[ebp], xmm0

; 433  : 		if( forward[2] > 0 )

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@VectorAngl

; 434  : 			pitch = 90.0f;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _pitch$[ebp], xmm0
	jmp	SHORT $LN8@VectorAngl
$LN7@VectorAngl:

; 435  : 		else pitch = 270.0f;

	movss	xmm0, DWORD PTR __real@43870000
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN8@VectorAngl:

; 436  : 	}

	jmp	$LN10@VectorAngl
$LN5@VectorAngl:

; 437  : 	else
; 438  : 	{
; 439  : 		yaw = ( atan2( forward[1], forward[0] ) * 180 / M_PI );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _forward$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _forward$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv198[ebp]
	movsd	xmm0, QWORD PTR tv198[ebp]
	mulsd	xmm0, QWORD PTR __real@4066800000000000
	divsd	xmm0, QWORD PTR __real@400921fb60000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _yaw$[ebp], xmm0

; 440  : 		if( yaw < 0 ) yaw += 360;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _yaw$[ebp]
	jbe	SHORT $LN9@VectorAngl
	movss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0
$LN9@VectorAngl:

; 441  : 
; 442  : 		tmp = sqrt( forward[0] * forward[0] + forward[1] * forward[1] );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _forward$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _forward$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _tmp$[ebp]

; 443  : 		pitch = ( atan2( forward[2], tmp ) * 180 / M_PI );

	cvtss2sd xmm0, DWORD PTR _tmp$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _forward$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv222[ebp]
	movsd	xmm0, QWORD PTR tv222[ebp]
	mulsd	xmm0, QWORD PTR __real@4066800000000000
	divsd	xmm0, QWORD PTR __real@400921fb60000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _pitch$[ebp], xmm0

; 444  : 		if( pitch < 0 ) pitch += 360;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _pitch$[ebp]
	jbe	SHORT $LN10@VectorAngl
	movss	xmm0, DWORD PTR _pitch$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN10@VectorAngl:

; 445  : 	}
; 446  : 
; 447  : 	VectorSet( angles, pitch, yaw, 0 ); 

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _angles$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN1@VectorAngl:

; 448  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_VectorAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv234 = -20						; size = 4
tv156 = -16						; size = 4
_d$ = -12						; size = 4
_ilength$1 = -8						; size = 4
_ilength$2 = -4						; size = 4
_forward$ = 8						; size = 4
_right$ = 12						; size = 4
_up$ = 16						; size = 4
_VectorVectors PROC

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 364  : 	float	d;
; 365  : 
; 366  : 	right[0] = forward[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 367  : 	right[1] = -forward[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 368  : 	right[2] = forward[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 369  : 
; 370  : 	d = DotProduct( forward, right );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _forward$[ebp]
	mov	esi, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _forward$[ebp]
	mov	esi, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _forward$[ebp]
	mov	esi, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR _d$[ebp], xmm0

; 371  : 	VectorMA( right, -d, forward, right );

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _forward$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _right$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _forward$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _right$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _d$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _forward$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv156[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR tv156[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 372  : 	VectorNormalize( right );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@VectorVect
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN2@VectorVect:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _right$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _right$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 373  : 	CrossProduct( right, forward, up );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _up$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _up$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _right$[ebp]
	mov	esi, DWORD PTR _forward$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	mulss	xmm1, DWORD PTR [esi+edx]
	subss	xmm0, xmm1
	movss	DWORD PTR tv234[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm0, DWORD PTR tv234[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 374  : 	VectorNormalize( up );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _up$[ebp]
	mov	esi, DWORD PTR _up$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _up$[ebp]
	mov	esi, DWORD PTR _up$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _up$[ebp]
	mov	esi, DWORD PTR _up$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@VectorVect
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN3@VectorVect:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _up$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _up$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _up$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _up$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 375  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_VectorVectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_az$ = -12						; size = 4
_ay$ = -8						; size = 4
_ax$ = -4						; size = 4
_vec1$ = 8						; size = 4
_vec2$ = 12						; size = 4
_epsilon$ = 16						; size = 4
_VectorCompareEpsilon PROC

; 332  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 333  : 	vec_t	ax, ay, az;
; 334  : 
; 335  : 	ax = fabs( vec1[0] - vec2[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vec1$[ebp]
	mov	esi, DWORD PTR _vec2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _ax$[ebp]

; 336  : 	ay = fabs( vec1[1] - vec2[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _vec1$[ebp]
	mov	esi, DWORD PTR _vec2$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _ay$[ebp]

; 337  : 	az = fabs( vec1[2] - vec2[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vec1$[ebp]
	mov	esi, DWORD PTR _vec2$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _az$[ebp]

; 338  : 
; 339  : 	if(( ax <= epsilon ) && ( ay <= epsilon ) && ( az <= epsilon ))

	movss	xmm0, DWORD PTR _epsilon$[ebp]
	comiss	xmm0, DWORD PTR _ax$[ebp]
	jb	SHORT $LN2@VectorComp
	movss	xmm0, DWORD PTR _epsilon$[ebp]
	comiss	xmm0, DWORD PTR _ay$[ebp]
	jb	SHORT $LN2@VectorComp
	movss	xmm0, DWORD PTR _epsilon$[ebp]
	comiss	xmm0, DWORD PTR _az$[ebp]
	jb	SHORT $LN2@VectorComp

; 340  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@VectorComp
$LN2@VectorComp:

; 341  : 	return false;

	xor	eax, eax
$LN1@VectorComp:

; 342  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_VectorCompareEpsilon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_ilength$ = -8						; size = 4
_length$ = -4						; size = 4
_v$ = 8							; size = 4
_out$ = 12						; size = 4
_VectorNormalizeLength2 PROC

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 346  : 	float	length, ilength;
; 347  : 
; 348  : 	length = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _length$[ebp], xmm0

; 349  : 	length = sqrt( length );

	cvtss2sd xmm0, DWORD PTR _length$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _length$[ebp]

; 350  : 
; 351  : 	if( length )

	movss	xmm0, DWORD PTR _length$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@VectorNorm

; 352  : 	{
; 353  : 		ilength = 1.0f / length;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _length$[ebp]
	movss	DWORD PTR _ilength$[ebp], xmm0

; 354  : 		out[0] = v[0] * ilength;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 355  : 		out[1] = v[1] * ilength;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 356  : 		out[2] = v[2] * ilength;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN2@VectorNorm:

; 357  : 	}
; 358  : 
; 359  : 	return length;

	fld	DWORD PTR _length$[ebp]

; 360  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_VectorNormalizeLength2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_radians$ = 8						; size = 4
_sine$ = 12						; size = 4
_cosine$ = 16						; size = 4
_SinCos	PROC

; 311  : {

	push	ebp
	mov	ebp, esp

; 312  : 	_asm
; 313  : 	{
; 314  : 		fld	dword ptr [radians]

	fld	DWORD PTR _radians$[ebp]

; 315  : 		fsincos

	fsincos

; 316  : 
; 317  : 		mov edx, dword ptr [cosine]

	mov	edx, DWORD PTR _cosine$[ebp]

; 318  : 		mov eax, dword ptr [sine]

	mov	eax, DWORD PTR _sine$[ebp]

; 319  : 
; 320  : 		fstp dword ptr [edx]

	fstp	DWORD PTR [edx]

; 321  : 		fstp dword ptr [eax]

	fstp	DWORD PTR [eax]

; 322  : 	}
; 323  : }

	pop	ebp
	ret	0
_SinCos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_n$ = -4						; size = 4
_value$ = 8						; size = 4
_roundDown$ = 12					; size = 4
_NearestPOW PROC

; 251  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 252  : 	int	n = 1;

	mov	DWORD PTR _n$[ebp], 1

; 253  : 
; 254  : 	if( value <= 0 ) return 1;

	cmp	DWORD PTR _value$[ebp], 0
	jg	SHORT $LN2@NearestPOW
	mov	eax, 1
	jmp	SHORT $LN1@NearestPOW
$LN2@NearestPOW:

; 255  : 	while( n < value ) n <<= 1;

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _value$[ebp]
	jge	SHORT $LN3@NearestPOW
	mov	ecx, DWORD PTR _n$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	jmp	SHORT $LN2@NearestPOW
$LN3@NearestPOW:

; 256  : 
; 257  : 	if( roundDown )

	cmp	DWORD PTR _roundDown$[ebp], 0
	je	SHORT $LN5@NearestPOW

; 258  : 	{
; 259  : 		if( n > value ) n >>= 1;

	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR _value$[ebp]
	jle	SHORT $LN5@NearestPOW
	mov	eax, DWORD PTR _n$[ebp]
	sar	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN5@NearestPOW:

; 260  : 	}
; 261  : 	return n;

	mov	eax, DWORD PTR _n$[ebp]
$LN1@NearestPOW:

; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NearestPOW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_PlaneTypeForNormal PROC

; 192  : {

	push	ebp
	mov	ebp, esp

; 193  : 	if( normal[0] == 1.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@PlaneTypeF

; 194  : 		return PLANE_X;

	xor	eax, eax
	jmp	SHORT $LN1@PlaneTypeF
$LN2@PlaneTypeF:

; 195  : 	if( normal[1] == 1.0f )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@PlaneTypeF

; 196  : 		return PLANE_Y;

	mov	eax, 1
	jmp	SHORT $LN1@PlaneTypeF
$LN3@PlaneTypeF:

; 197  : 	if( normal[2] == 1.0f )

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@PlaneTypeF

; 198  : 		return PLANE_Z;

	mov	eax, 2
	jmp	SHORT $LN1@PlaneTypeF
$LN4@PlaneTypeF:

; 199  : 	return PLANE_NONAXIAL;

	mov	eax, 3
$LN1@PlaneTypeF:

; 200  : }

	pop	ebp
	ret	0
_PlaneTypeForNormal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_bits$ = -8						; size = 4
_i$ = -4						; size = 4
_normal$ = 8						; size = 4
_SignbitsForPlane PROC

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 179  : 	int	bits, i;
; 180  : 
; 181  : 	for( bits = i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bits$[ebp], eax
	jmp	SHORT $LN4@SignbitsFo
$LN2@SignbitsFo:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SignbitsFo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SignbitsFo

; 182  : 		if( normal[i] < 0.0f ) bits |= 1<<i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+edx*4]
	jbe	SHORT $LN5@SignbitsFo
	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _bits$[ebp]
	mov	DWORD PTR _bits$[ebp], edx
$LN5@SignbitsFo:
	jmp	SHORT $LN2@SignbitsFo
$LN3@SignbitsFo:

; 183  : 	return bits;

	mov	eax, DWORD PTR _bits$[ebp]

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SignbitsForPlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv161 = -28						; size = 8
_negative$1 = -20					; size = 4
_i$ = -16						; size = 4
_value$2 = -12						; size = 4
_result$3 = -8						; size = 4
_j$ = -4						; size = 4
_size$ = 8						; size = 4
_RoundUpHullSize PROC

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 128  : 	int	i, j;
; 129  : 	
; 130  : 	for( i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@RoundUpHul
$LN2@RoundUpHul:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@RoundUpHul:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@RoundUpHul

; 131  : 	{
; 132  : 		qboolean	negative = false;

	mov	DWORD PTR _negative$1[ebp], 0

; 133  :                     float	result, value;
; 134  : 
; 135  : 		value = size[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _value$2[ebp], xmm0

; 136  : 		if( value < 0.0f ) negative = true;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _value$2[ebp]
	jbe	SHORT $LN8@RoundUpHul
	mov	DWORD PTR _negative$1[ebp], 1
$LN8@RoundUpHul:

; 137  : 		value = Q_ceil( fabs( value ));

	cvtss2sd xmm0, DWORD PTR _value$2[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv161[ebp]
	movsd	xmm0, QWORD PTR tv161[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvttsd2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _value$2[ebp], xmm0

; 138  : 		result = Q_ceil( size[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	addss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _result$3[ebp], xmm0

; 139  : 
; 140  : 		// lookup hull table to find nearest supposed value
; 141  : 		for( j = 0; j < NUM_HULL_ROUNDS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@RoundUpHul
$LN5@RoundUpHul:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@RoundUpHul:
	cmp	DWORD PTR _j$[ebp], 24			; 00000018H
	jae	$LN6@RoundUpHul

; 142  :           	{
; 143  : 			if( value > hull_table[j] )

	mov	edx, DWORD PTR _j$[ebp]
	movzx	eax, WORD PTR _hull_table[edx*2]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _value$2[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN9@RoundUpHul

; 144  : 				continue;	// ceil only

	jmp	SHORT $LN5@RoundUpHul
$LN9@RoundUpHul:

; 145  : 
; 146  : 			if( negative )

	cmp	DWORD PTR _negative$1[ebp], 0
	je	SHORT $LN10@RoundUpHul

; 147  : 			{
; 148  : 				result = ( value - hull_table[j] );

	mov	ecx, DWORD PTR _j$[ebp]
	movzx	edx, WORD PTR _hull_table[ecx*2]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _value$2[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _result$3[ebp], xmm1

; 149  : 				if( result <= HULL_PRECISION )

	movss	xmm0, DWORD PTR __real@40800000
	comiss	xmm0, DWORD PTR _result$3[ebp]
	jb	SHORT $LN12@RoundUpHul

; 150  : 				{ 
; 151  : 					result = -hull_table[j];

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, WORD PTR _hull_table[eax*2]
	neg	ecx
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _result$3[ebp], xmm0

; 152  : 					break;

	jmp	SHORT $LN6@RoundUpHul
$LN12@RoundUpHul:

; 153  : 				}
; 154  : 			}

	jmp	SHORT $LN13@RoundUpHul
$LN10@RoundUpHul:

; 155  : 			else
; 156  : 			{
; 157  : 				result = ( value - hull_table[j] );

	mov	edx, DWORD PTR _j$[ebp]
	movzx	eax, WORD PTR _hull_table[edx*2]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _value$2[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _result$3[ebp], xmm1

; 158  : 				if( result <= HULL_PRECISION )

	movss	xmm0, DWORD PTR __real@40800000
	comiss	xmm0, DWORD PTR _result$3[ebp]
	jb	SHORT $LN13@RoundUpHul

; 159  : 				{ 
; 160  : 					result = hull_table[j];

	mov	ecx, DWORD PTR _j$[ebp]
	movzx	edx, WORD PTR _hull_table[ecx*2]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _result$3[ebp], xmm0

; 161  : 					break;

	jmp	SHORT $LN6@RoundUpHul
$LN13@RoundUpHul:

; 162  : 				}
; 163  : 			}
; 164  : 		}

	jmp	$LN5@RoundUpHul
$LN6@RoundUpHul:

; 165  : 
; 166  : 		size[i] = result;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR _result$3[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 167  : 	}

	jmp	$LN2@RoundUpHul
$LN3@RoundUpHul:

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RoundUpHullSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
tv74 = -8						; size = 4
_valueSquared$ = -4					; size = 4
_value$ = 8						; size = 4
_SimpleSpline PROC

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 66   : 	float	valueSquared = value * value;

	movss	xmm0, DWORD PTR _value$[ebp]
	mulss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR _valueSquared$[ebp], xmm0

; 67   : 
; 68   : 	// nice little ease-in, ease-out spline-like curve
; 69   : 	return (3.0f * valueSquared - 2.0f * valueSquared * value);

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _valueSquared$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _valueSquared$[ebp]
	mulss	xmm1, DWORD PTR _value$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SimpleSpline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_e$1 = -16						; size = 4
_em$ = -12						; size = 4
_f$ = -8						; size = 4
_m$2 = -4						; size = 4
_h$ = 8							; size = 2
_HalfToFloat PROC

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 90   : 	unsigned int	f = (h << 16) & 0x80000000;

	movzx	eax, WORD PTR _h$[ebp]
	shl	eax, 16					; 00000010H
	and	eax, -2147483648			; 80000000H
	mov	DWORD PTR _f$[ebp], eax

; 91   : 	unsigned int	em = h & 0x7fff;

	movzx	ecx, WORD PTR _h$[ebp]
	and	ecx, 32767				; 00007fffH
	mov	DWORD PTR _em$[ebp], ecx

; 92   : 
; 93   : 	if( em > 0x03ff )

	cmp	DWORD PTR _em$[ebp], 1023		; 000003ffH
	jbe	SHORT $LN4@HalfToFloa

; 94   : 	{
; 95   : 		f |= (em << 13) + ((127 - 15) << 23);

	mov	edx, DWORD PTR _em$[ebp]
	shl	edx, 13					; 0000000dH
	add	edx, 939524096				; 38000000H
	or	edx, DWORD PTR _f$[ebp]
	mov	DWORD PTR _f$[ebp], edx

; 96   : 	}

	jmp	SHORT $LN6@HalfToFloa
$LN4@HalfToFloa:

; 97   : 	else
; 98   : 	{
; 99   : 		unsigned int m = em & 0x03ff;

	mov	eax, DWORD PTR _em$[ebp]
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _m$2[ebp], eax

; 100  : 
; 101  : 		if( m != 0 )

	je	SHORT $LN6@HalfToFloa

; 102  : 		{
; 103  : 			unsigned int e = (em >> 10) & 0x1f;

	mov	ecx, DWORD PTR _em$[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _e$1[ebp], ecx
$LN2@HalfToFloa:

; 104  : 
; 105  : 			while(( m & 0x0400 ) == 0 )

	mov	edx, DWORD PTR _m$2[ebp]
	and	edx, 1024				; 00000400H
	jne	SHORT $LN3@HalfToFloa

; 106  : 			{
; 107  : 				m <<= 1;

	mov	eax, DWORD PTR _m$2[ebp]
	shl	eax, 1
	mov	DWORD PTR _m$2[ebp], eax

; 108  : 				e--;

	mov	ecx, DWORD PTR _e$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _e$1[ebp], ecx

; 109  : 			}

	jmp	SHORT $LN2@HalfToFloa
$LN3@HalfToFloa:

; 110  : 
; 111  : 			m &= 0x3ff;

	mov	edx, DWORD PTR _m$2[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _m$2[ebp], edx

; 112  : 			f |= ((e + (127 - 14)) << 23) | (m << 13);

	mov	eax, DWORD PTR _e$1[ebp]
	add	eax, 113				; 00000071H
	shl	eax, 23					; 00000017H
	mov	ecx, DWORD PTR _m$2[ebp]
	shl	ecx, 13					; 0000000dH
	or	eax, ecx
	or	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _f$[ebp], eax
$LN6@HalfToFloa:

; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	return *((float *)&f);

	fld	DWORD PTR _f$[ebp]

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_HalfToFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_m$ = -16						; size = 4
_e$ = -12						; size = 4
_i$ = -8						; size = 4
_h$ = -4						; size = 2
_v$ = 8							; size = 4
_FloatToHalf PROC

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	unsigned int	i = *((unsigned int *)&v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 75   : 	unsigned int	e = (i >> 23) & 0x00ff;

	mov	ecx, DWORD PTR _i$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _e$[ebp], ecx

; 76   : 	unsigned int	m = i & 0x007fffff;

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 8388607				; 007fffffH
	mov	DWORD PTR _m$[ebp], edx

; 77   : 	unsigned short	h;
; 78   : 
; 79   : 	if( e <= 127 - 15 )

	cmp	DWORD PTR _e$[ebp], 112			; 00000070H
	ja	SHORT $LN2@FloatToHal

; 80   : 		h = ((m | 0x00800000) >> (127 - 14 - e)) >> 13;

	mov	eax, DWORD PTR _m$[ebp]
	or	eax, 8388608				; 00800000H
	mov	ecx, 113				; 00000071H
	sub	ecx, DWORD PTR _e$[ebp]
	shr	eax, cl
	shr	eax, 13					; 0000000dH
	mov	WORD PTR _h$[ebp], ax
	jmp	SHORT $LN3@FloatToHal
$LN2@FloatToHal:

; 81   : 	else h = (i >> 13) & 0x3fff;

	mov	ecx, DWORD PTR _i$[ebp]
	shr	ecx, 13					; 0000000dH
	and	ecx, 16383				; 00003fffH
	mov	WORD PTR _h$[ebp], cx
$LN3@FloatToHal:

; 82   : 
; 83   : 	h |= (i >> 16) & 0xc000;

	mov	edx, DWORD PTR _i$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 49152				; 0000c000H
	movzx	eax, WORD PTR _h$[ebp]
	or	eax, edx
	mov	WORD PTR _h$[ebp], ax

; 84   : 
; 85   : 	return h;

	mov	ax, WORD PTR _h$[ebp]

; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FloatToHalf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
_anglemod PROC

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	a = (360.0 / 65536) * ((int)(a*(65536/360.0)) & 65535);

	cvtss2sd xmm0, DWORD PTR _a$[ebp]
	mulsd	xmm0, QWORD PTR __real@4066c16c16c16c17
	cvttsd2si eax, xmm0
	and	eax, 65535				; 0000ffffH
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3f76800000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _a$[ebp], xmm0

; 51   : 	return a;

	fld	DWORD PTR _a$[ebp]

; 52   : }

	pop	ebp
	ret	0
_anglemod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mathlib.c
_TEXT	SEGMENT
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_y$ = -4						; size = 4
_number$ = 8						; size = 4
_rsqrt	PROC

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 290  : 	int	i;
; 291  : 	float	x, y;
; 292  : 
; 293  : 	if( number == 0.0f )

	movss	xmm0, DWORD PTR _number$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@rsqrt

; 294  : 		return 0.0f;

	fldz
	jmp	SHORT $LN1@rsqrt
$LN2@rsqrt:

; 295  : 
; 296  : 	x = number * 0.5f;

	movss	xmm0, DWORD PTR _number$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _x$[ebp], xmm0

; 297  : 	i = *(int *)&number;	// evil floating point bit level hacking

	mov	eax, DWORD PTR _number$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 298  : 	i = 0x5f3759df - (i >> 1);	// what the fuck?

	mov	ecx, DWORD PTR _i$[ebp]
	sar	ecx, 1
	mov	edx, 1597463007				; 5f3759dfH
	sub	edx, ecx
	mov	DWORD PTR _i$[ebp], edx

; 299  : 	y = *(float *)&i;

	movss	xmm0, DWORD PTR _i$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 300  : 	y = y * (1.5f - (x * y * y));	// first iteration

	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR __real@3fc00000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR _y$[ebp]
	movss	DWORD PTR _y$[ebp], xmm1

; 301  : 
; 302  : 	return y;

	fld	DWORD PTR _y$[ebp]
$LN1@rsqrt:

; 303  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_rsqrt	ENDP
_TEXT	ENDS
END
