; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\server\sv_custom.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SV_SendResource
PUBLIC	_SV_AddToResourceList
PUBLIC	_SV_MoveToOnHandList
PUBLIC	_SV_RemoveFromResourceList
PUBLIC	_SV_ParseConsistencyResponse
PUBLIC	_SV_EstimateNeededResources
PUBLIC	_SV_ClearResourceList
PUBLIC	_SV_BatchUploadRequest
PUBLIC	_SV_SendResources
PUBLIC	_SV_ClearResourceLists
PUBLIC	_SV_TransferConsistencyInfo
PUBLIC	_SV_RequestMissingResources
PUBLIC	_SV_CreateCustomizationList
PUBLIC	_SV_FileInConsistencyList
PUBLIC	_SV_SendConsistencyList
PUBLIC	_SV_CheckFile
PUBLIC	_SV_SendCustomization
PUBLIC	_SV_Customization
PUBLIC	_SV_PropagateCustomizations
PUBLIC	_SV_RegisterResources
PUBLIC	_SV_UploadComplete
PUBLIC	__real@00000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_HexConvert:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_MD5_HashFile:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_CreateCustomization:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_HPAK_ResourceForHash:PROC
EXTRN	_Mod_GetStudioBounds:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteSBitLong:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteShort:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadOneBit:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_SV_DropClient:PROC
EXTRN	_SV_ClientPrintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_downloadurl:BYTE
EXTRN	_sv_allow_upload:BYTE
EXTRN	_sv_consistency:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?nullrguc@?1??SV_SendResource@@9@9 DB 024H DUP (?)	; `SV_SendResource'::`2'::nullrguc
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG136101 DB	'Ignoring invalid custom decal from %s', 0aH, 00H
	ORG $+1
$SG136102 DB	'Ignoring custom decal from %s', 0aH, 00H
	ORG $+1
$SG136103 DB	'^3Warning:^7 SV_CreateCustomization list, ignoring dup. '
	DB	'resource for player %s', 0aH, 00H
$SG136168 DB	'^3Warning:^7 %s:%s sent bad file data', 0aH, 00H
	ORG $+1
$SG136192 DB	'sound/', 00H
	ORG $+1
$SG136193 DB	'%s%s', 00H
	ORG $+3
$SG136198 DB	'Mod_GetStudioBounds: couldn''t get bounds for %s', 0aH, 00H
	ORG $+3
$SG136229 DB	'!MD5', 00H
	ORG $+3
$SG136231 DB	'custom.hpk', 00H
	ORG $+1
$SG136233 DB	'upload "!MD5%s"', 0aH, 00H
	ORG $+3
$SG136240 DB	'Null resource passed to SV_MoveToOnHandList', 0aH, 00H
	ORG $+3
$SG136250 DB	'^1Error:^7 Resource already linked', 0aH, 00H
$SG136274 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_custom.c', 00H
	ORG $+3
$SG136290 DB	'custom.hpk', 00H
	ORG $+1
$SG136309 DB	'Couldn''t find player index for customization.', 0aH, 00H
	ORG $+1
$SG136345 DB	'Custom resource propagation complete.', 0aH, 00H
	ORG $+1
$SG136368 DB	'!MD5%s', 00H
	ORG $+1
$SG136370 DB	'^1Error:^7 Non customization in upload queue!', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_UploadComplete PROC

; 472  : {

	push	ebp
	mov	ebp, esp

; 473  : 	if( &cl->resourcesneeded != cl->resourcesneeded.pNext )

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264752				; 00040a30H
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	eax, DWORD PTR [ecx+264880]
	je	SHORT $LN2@SV_UploadC

; 474  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_UploadC
$LN2@SV_UploadC:

; 475  : 
; 476  : 	SV_RegisterResources( cl );

	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_RegisterResources
	add	esp, 4

; 477  : 	SV_PropagateCustomizations( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_PropagateCustomizations
	add	esp, 4

; 478  : 
; 479  : 	if( sv_allow_upload.value )

	movss	xmm0, DWORD PTR _sv_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@SV_UploadC

; 480  : 		Con_Printf( "Custom resource propagation complete.\n" );

	push	OFFSET $SG136345
	call	_Con_Printf
	add	esp, 4
$LN3@SV_UploadC:

; 481  : 	cl->upstate = us_complete;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+4], 2

; 482  : 
; 483  : 	return true;

	mov	eax, 1
$LN1@SV_UploadC:

; 484  : }

	pop	ebp
	ret	0
_SV_UploadComplete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pResource$ = -4					; size = 4
_pHost$ = 8						; size = 4
_SV_RegisterResources PROC

; 461  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 462  : 	resource_t	*pResource;
; 463  : 
; 464  : 	for( pResource = pHost->resourcesonhand.pNext; pResource != &pHost->resourcesonhand; pResource = pResource->pNext )

	mov	eax, DWORD PTR _pHost$[ebp]
	mov	ecx, DWORD PTR [eax+264744]
	mov	DWORD PTR _pResource$[ebp], ecx
	jmp	SHORT $LN4@SV_Registe
$LN2@SV_Registe:
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR _pResource$[ebp], eax
$LN4@SV_Registe:
	mov	ecx, DWORD PTR _pHost$[ebp]
	add	ecx, 264616				; 000409a8H
	cmp	DWORD PTR _pResource$[ebp], ecx
	je	SHORT $LN1@SV_Registe

; 465  : 	{
; 466  : 		SV_CreateCustomizationList( pHost );

	mov	edx, DWORD PTR _pHost$[ebp]
	push	edx
	call	_SV_CreateCustomizationList
	add	esp, 4

; 467  : 		SV_Customization( pHost, pResource, true );

	push	1
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pHost$[ebp]
	push	ecx
	call	_SV_Customization
	add	esp, 12					; 0000000cH

; 468  : 	}

	jmp	SHORT $LN2@SV_Registe
$LN1@SV_Registe:

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RegisterResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pResource$ = -16					; size = 4
_i$ = -12						; size = 4
_pCust$ = -8						; size = 4
_cl$ = -4						; size = 4
_pHost$ = 8						; size = 4
_SV_PropagateCustomizations PROC

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 438  : 	customization_t	*pCust;
; 439  : 	resource_t	*pResource;
; 440  : 	sv_client_t	*cl;
; 441  : 	int		i;
; 442  : 
; 443  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Propaga
$LN2@SV_Propaga:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_Propaga:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_Propaga

; 444  : 	{
; 445  : 		if( cl->state != cs_spawned )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN8@SV_Propaga

; 446  : 			continue;

	jmp	SHORT $LN2@SV_Propaga
$LN8@SV_Propaga:

; 447  : 
; 448  : 		if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN9@SV_Propaga

; 449  : 			continue;

	jmp	SHORT $LN2@SV_Propaga
$LN9@SV_Propaga:

; 450  : 
; 451  : 		for( pCust = cl->customdata.pNext; pCust != NULL; pCust = pCust->pNext )

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264612]
	mov	DWORD PTR _pCust$[ebp], edx
	jmp	SHORT $LN7@SV_Propaga
$LN5@SV_Propaga:
	mov	eax, DWORD PTR _pCust$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pCust$[ebp], ecx
$LN7@SV_Propaga:
	cmp	DWORD PTR _pCust$[ebp], 0
	je	SHORT $LN6@SV_Propaga

; 452  : 		{
; 453  : 			if( !pCust->bInUse ) continue;

	mov	edx, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN10@SV_Propaga
	jmp	SHORT $LN5@SV_Propaga
$LN10@SV_Propaga:

; 454  : 			pResource = &pCust->resource;

	mov	eax, DWORD PTR _pCust$[ebp]
	add	eax, 4
	mov	DWORD PTR _pResource$[ebp], eax

; 455  : 			SV_SendCustomization( pHost, i, pResource );

	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _pHost$[ebp]
	push	eax
	call	_SV_SendCustomization
	add	esp, 12					; 0000000cH

; 456  : 		}

	jmp	SHORT $LN5@SV_Propaga
$LN6@SV_Propaga:

; 457  : 	}

	jmp	$LN2@SV_Propaga
$LN1@SV_Propaga:

; 458  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PropagateCustomizations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_nPlayerNumber$ = -12					; size = 4
_cl$ = -8						; size = 4
_i$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pResource$ = 12					; size = 4
_bSkipPlayer$ = 16					; size = 4
_SV_Customization PROC

; 412  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 413  : 	int		i, nPlayerNumber = -1;

	mov	DWORD PTR _nPlayerNumber$[ebp], -1

; 414  : 	sv_client_t	*cl;
; 415  : 
; 416  : 	i = pClient - svs.clients;

	mov	eax, DWORD PTR _pClient$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	mov	DWORD PTR _i$[ebp], eax

; 417  : 	if( i >= 0 && i < svs.maxclients )

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN5@SV_Customi
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jge	SHORT $LN5@SV_Customi

; 418  : 		nPlayerNumber = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _nPlayerNumber$[ebp], eax
	jmp	SHORT $LN6@SV_Customi
$LN5@SV_Customi:

; 419  : 	else Host_Error( "Couldn't find player index for customization.\n" );

	push	OFFSET $SG136309
	call	_Host_Error
	add	esp, 4
$LN6@SV_Customi:

; 420  : 
; 421  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], ecx
	jmp	SHORT $LN4@SV_Customi
$LN2@SV_Customi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], eax
$LN4@SV_Customi:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_Customi

; 422  : 	{
; 423  : 		if( cl->state != cs_spawned )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	je	SHORT $LN7@SV_Customi

; 424  : 			continue;

	jmp	SHORT $LN2@SV_Customi
$LN7@SV_Customi:

; 425  : 
; 426  : 		if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN8@SV_Customi

; 427  : 			continue;

	jmp	SHORT $LN2@SV_Customi
$LN8@SV_Customi:

; 428  : 
; 429  : 		if( cl == pClient && bSkipPlayer )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	edx, DWORD PTR _pClient$[ebp]
	jne	SHORT $LN9@SV_Customi
	cmp	DWORD PTR _bSkipPlayer$[ebp], 0
	je	SHORT $LN9@SV_Customi

; 430  : 			continue;

	jmp	SHORT $LN2@SV_Customi
$LN9@SV_Customi:

; 431  : 
; 432  : 		SV_SendCustomization( cl, nPlayerNumber, pResource );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nPlayerNumber$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_SendCustomization
	add	esp, 12					; 0000000cH

; 433  : 	}

	jmp	SHORT $LN2@SV_Customi
$LN1@SV_Customi:

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Customization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_playernum$ = 12					; size = 4
_pResource$ = 16					; size = 4
_SV_SendCustomization PROC

; 339  : {

	push	ebp
	mov	ebp, esp

; 340  : 	MSG_BeginServerCmd( &cl->netchan.message, svc_customization );

	push	0
	push	1
	push	46					; 0000002eH
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 341  : 	MSG_WriteByte( &cl->netchan.message, playernum );	// playernum

	mov	ecx, DWORD PTR _playernum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 342  : 	MSG_WriteByte( &cl->netchan.message, pResource->type );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 343  : 	MSG_WriteString( &cl->netchan.message, pResource->szFileName );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 344  : 	MSG_WriteShort( &cl->netchan.message, pResource->nIndex );

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteShort
	add	esp, 8

; 345  : 	MSG_WriteLong( &cl->netchan.message, pResource->nDownloadSize );

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 346  : 	MSG_WriteByte( &cl->netchan.message, pResource->ucFlags );

	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 347  : 
; 348  : 	if( FBitSet( pResource->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	je	SHORT $LN1@SV_SendCus

; 349  : 		MSG_WriteBytes( &cl->netchan.message, pResource->rgucMD5_hash, 16 );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH
$LN1@SV_SendCus:

; 350  : }

	pop	ebp
	ret	0
_SV_SendCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_p$ = -140						; size = 136
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_filename$ = 12						; size = 4
_SV_CheckFile PROC

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 291  : 	resource_t	p;
; 292  : 
; 293  : 	memset( &p, 0, sizeof( resource_t ));

	push	136					; 00000088H
	push	0
	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 294  : 
; 295  : 	if( Q_strlen( filename ) == 36 && !Q_strnicmp( filename, "!MD5", 4 ))

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN3@SV_CheckFi
	push	4
	push	OFFSET $SG136229
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SV_CheckFi

; 296  : 	{
; 297  : 		COM_HexConvert( filename + 4, 32, p.rgucMD5_hash );

	lea	eax, DWORD PTR _p$[ebp+77]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _filename$[ebp]
	add	ecx, 4
	push	ecx
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 298  : 
; 299  : 		if( HPAK_GetDataPointer( CUSTOM_RES_PATH, &p, NULL, NULL ))

	push	0
	push	0
	lea	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET $SG136231
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN3@SV_CheckFi

; 300  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_CheckFi
$LN3@SV_CheckFi:

; 301  : 	}
; 302  : 
; 303  : 	if( !sv_allow_upload.value )

	movss	xmm0, DWORD PTR _sv_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_CheckFi

; 304  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_CheckFi
$LN4@SV_CheckFi:

; 305  : 
; 306  : 	MSG_BeginServerCmd( msg, svc_stufftext );

	push	0
	push	1
	push	9
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 307  : 	MSG_WriteString( msg, va( "upload \"!MD5%s\"\n", MD5_Print( p.rgucMD5_hash )));

	lea	ecx, DWORD PTR _p$[ebp+77]
	push	ecx
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET $SG136233
	call	_va
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 308  : 
; 309  : 	return false;

	xor	eax, eax
$LN1@SV_CheckFi:

; 310  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_lastcheck$ = -12					; size = 4
_delta$ = -8						; size = 4
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_SendConsistencyList PROC

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 249  : 	int	i, lastcheck;
; 250  : 	int	delta;
; 251  : 
; 252  : 	if( svs.maxclients == 1 || !sv_consistency.value || !sv.num_consistency || FBitSet( cl->flags, FCL_HLTV_PROXY ))

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN6@SV_SendCon
	movss	xmm0, DWORD PTR _sv_consistency+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@SV_SendCon
	cmp	DWORD PTR _sv+1157320, 0
	je	SHORT $LN6@SV_SendCon
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	je	SHORT $LN5@SV_SendCon
$LN6@SV_SendCon:

; 253  : 	{
; 254  : 		ClearBits( cl->flags, FCL_FORCE_UNMODIFIED );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, -1025				; fffffbffH
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 255  : 		MSG_WriteOneBit( msg, 0 );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8

; 256  : 		return;

	jmp	$LN1@SV_SendCon
$LN5@SV_SendCon:

; 257  : 	}
; 258  : 
; 259  : 	SetBits( cl->flags, FCL_FORCE_UNMODIFIED );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 260  : 	MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 261  : 	lastcheck = 0;

	mov	DWORD PTR _lastcheck$[ebp], 0

; 262  : 
; 263  : 	for( i = 0; i < sv.num_resources; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SendCon
$LN2@SV_SendCon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_SendCon:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _sv+1157324
	jge	$LN3@SV_SendCon

; 264  : 	{
; 265  : 		if( !FBitSet( sv.resources[i].ucFlags, RES_CHECKFILE ))

	imul	eax, DWORD PTR _i$[ebp], 136
	movzx	ecx, BYTE PTR _sv[eax+461076]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN7@SV_SendCon

; 266  : 			continue;

	jmp	SHORT $LN2@SV_SendCon
$LN7@SV_SendCon:

; 267  : 
; 268  : 		delta = i - lastcheck;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, DWORD PTR _lastcheck$[ebp]
	mov	DWORD PTR _delta$[ebp], edx

; 269  : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 270  : 
; 271  : 		if( delta > 31 )

	cmp	DWORD PTR _delta$[ebp], 31		; 0000001fH
	jle	SHORT $LN8@SV_SendCon

; 272  : 		{
; 273  : 			MSG_WriteOneBit( msg, 0 );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 274  : 			MSG_WriteUBitLong( msg, i, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 275  : 		}

	jmp	SHORT $LN9@SV_SendCon
$LN8@SV_SendCon:

; 276  : 		else
; 277  : 		{
; 278  : 			MSG_WriteOneBit( msg, 1 );

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 279  : 			MSG_WriteUBitLong( msg, delta, 5 );

	push	5
	mov	edx, DWORD PTR _delta$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN9@SV_SendCon:

; 280  : 		}
; 281  : 
; 282  : 		lastcheck = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _lastcheck$[ebp], ecx

; 283  : 	}

	jmp	$LN2@SV_SendCon
$LN3@SV_SendCon:

; 284  : 
; 285  : 	// write end of the list
; 286  : 	MSG_WriteOneBit( msg, 0 );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_SendCon:

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendConsistencyList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pc$1 = -8						; size = 4
_i$ = -4						; size = 4
_filename$ = 8						; size = 4
_ppout$ = 12						; size = 4
_SV_FileInConsistencyList PROC

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 66   : 	int	i;
; 67   : 
; 68   : 	if( ppout != NULL )

	cmp	DWORD PTR _ppout$[ebp], 0
	je	SHORT $LN5@SV_FileInC

; 69   : 		*ppout = NULL;

	mov	eax, DWORD PTR _ppout$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SV_FileInC:

; 70   : 
; 71   : 	for( i = 0; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_FileInC
$LN2@SV_FileInC:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_FileInC:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_FileInC

; 72   : 	{
; 73   : 		consistency_t	*pc = &sv.consistency_list[i];

	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _sv+415944
	mov	DWORD PTR _pc$1[ebp], edx

; 74   : 
; 75   : 		if( !pc->filename )

	mov	eax, DWORD PTR _pc$1[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@SV_FileInC

; 76   : 			break;

	jmp	SHORT $LN3@SV_FileInC
$LN6@SV_FileInC:

; 77   : 
; 78   : 		if( !Q_stricmp( pc->filename, filename ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pc$1[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@SV_FileInC

; 79   : 		{
; 80   : 			if( ppout != NULL )

	cmp	DWORD PTR _ppout$[ebp], 0
	je	SHORT $LN8@SV_FileInC

; 81   : 				*ppout = pc;

	mov	ecx, DWORD PTR _ppout$[ebp]
	mov	edx, DWORD PTR _pc$1[ebp]
	mov	DWORD PTR [ecx], edx
$LN8@SV_FileInC:

; 82   : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_FileInC
$LN7@SV_FileInC:

; 83   : 		}
; 84   : 	}

	jmp	SHORT $LN2@SV_FileInC
$LN3@SV_FileInC:

; 85   : 
; 86   : 	return false;

	xor	eax, eax
$LN1@SV_FileInC:

; 87   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FileInConsistencyList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pCust$ = -20						; size = 4
_nLumps$ = -16						; size = 4
_bFound$ = -12						; size = 4
_pList$ = -8						; size = 4
_pResource$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_CreateCustomizationList PROC

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 21   : 	resource_t	*pResource;
; 22   : 	customization_t	*pList, *pCust;
; 23   : 	qboolean		bFound;
; 24   : 	int		nLumps;
; 25   : 
; 26   : 	cl->customdata.pNext = NULL;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264612], 0

; 27   : 
; 28   : 	for( pResource = cl->resourcesonhand.pNext; pResource != &cl->resourcesonhand; pResource = pResource->pNext )

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264744]
	mov	DWORD PTR _pResource$[ebp], edx
	jmp	SHORT $LN4@SV_CreateC
$LN2@SV_CreateC:
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pResource$[ebp], ecx
$LN4@SV_CreateC:
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264616				; 000409a8H
	cmp	DWORD PTR _pResource$[ebp], edx
	je	$LN3@SV_CreateC

; 29   : 	{
; 30   : 		bFound = false;

	mov	DWORD PTR _bFound$[ebp], 0

; 31   : 
; 32   : 		for( pList = cl->customdata.pNext; pList != NULL; pList = pList->pNext )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264612]
	mov	DWORD PTR _pList$[ebp], ecx
	jmp	SHORT $LN7@SV_CreateC
$LN5@SV_CreateC:
	mov	edx, DWORD PTR _pList$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	DWORD PTR _pList$[ebp], eax
$LN7@SV_CreateC:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN6@SV_CreateC

; 33   : 		{
; 34   : 			if( !memcmp( pList->resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	mov	edx, DWORD PTR _pList$[ebp]
	add	edx, 81					; 00000051H
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_CreateC

; 35   : 			{
; 36   : 				bFound = true;

	mov	DWORD PTR _bFound$[ebp], 1

; 37   : 				break;

	jmp	SHORT $LN6@SV_CreateC
$LN8@SV_CreateC:

; 38   : 			}
; 39   : 		}

	jmp	SHORT $LN5@SV_CreateC
$LN6@SV_CreateC:

; 40   : 
; 41   : 		if( !bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	jne	$LN9@SV_CreateC

; 42   : 		{
; 43   : 			nLumps = 0;

	mov	DWORD PTR _nLumps$[ebp], 0

; 44   : 
; 45   : 			if( COM_CreateCustomization( &cl->customdata, pResource, -1, FCUST_FROMHPAK|FCUST_WIPEDATA, &pCust, &nLumps ))

	lea	eax, DWORD PTR _nLumps$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pCust$[ebp]
	push	ecx
	push	3
	push	-1
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264452				; 00040904H
	push	eax
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN11@SV_CreateC

; 46   : 			{
; 47   : 				pCust->nUserData2 = nLumps;

	mov	ecx, DWORD PTR _pCust$[ebp]
	mov	edx, DWORD PTR _nLumps$[ebp]
	mov	DWORD PTR [ecx+148], edx

; 48   : 				svgame.dllFuncs.pfnPlayerCustomization( cl->edict, pCust );

	mov	eax, DWORD PTR _pCust$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	DWORD PTR _svgame+19356
	add	esp, 8

; 49   : 			}

	jmp	SHORT $LN14@SV_CreateC
$LN11@SV_CreateC:

; 50   : 			else
; 51   : 			{
; 52   : 				if( sv_allow_upload.value )

	movss	xmm0, DWORD PTR _sv_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@SV_CreateC

; 53   : 					Con_Printf( "Ignoring invalid custom decal from %s\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG136101
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN14@SV_CreateC
$LN13@SV_CreateC:

; 54   : 				else Con_Printf( "Ignoring custom decal from %s\n", cl->name );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG136102
	call	_Con_Printf
	add	esp, 8
$LN14@SV_CreateC:

; 55   : 			}
; 56   : 		}

	jmp	SHORT $LN10@SV_CreateC
$LN9@SV_CreateC:

; 57   : 		else
; 58   : 		{
; 59   : 			Con_Printf( S_WARN "SV_CreateCustomization list, ignoring dup. resource for player %s\n", cl->name );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG136103
	call	_Con_Printf
	add	esp, 8
$LN10@SV_CreateC:

; 60   : 		}
; 61   : 	}

	jmp	$LN2@SV_CreateC
$LN3@SV_CreateC:

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateCustomizationList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_RequestMissingResources PROC

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 488  : 	sv_client_t	*cl;
; 489  : 	int		i;
; 490  : 
; 491  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Request
$LN2@SV_Request:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_Request:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_Request

; 492  : 	{
; 493  : 		if( cl->state != cs_spawned )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN5@SV_Request

; 494  : 			continue;

	jmp	SHORT $LN2@SV_Request
$LN5@SV_Request:

; 495  : 
; 496  : 		if( cl->upstate == us_processing )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN6@SV_Request

; 497  : 			SV_UploadComplete( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_UploadComplete
	add	esp, 4
$LN6@SV_Request:

; 498  : 	}

	jmp	SHORT $LN2@SV_Request
$LN1@SV_Request:

; 499  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RequestMissingResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
tv133 = -304						; size = 4
_total$ = -300						; size = 4
_i$ = -296						; size = 4
_pc$ = -292						; size = 4
_pResource$ = -288					; size = 4
_maxs$ = -284						; size = 12
_mins$ = -272						; size = 12
_filepath$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_SV_TransferConsistencyInfo PROC

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 196  : 	vec3_t		mins, maxs;
; 197  : 	int		i, total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 198  : 	resource_t	*pResource;
; 199  : 	string		filepath;
; 200  : 	consistency_t	*pc;
; 201  : 
; 202  : 	for( i = 0; i < sv.num_resources; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Transfe
$LN2@SV_Transfe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Transfe:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _sv+1157324
	jge	$LN3@SV_Transfe

; 203  : 	{
; 204  : 		pResource = &sv.resources[i];

	imul	edx, DWORD PTR _i$[ebp], 136
	add	edx, OFFSET _sv+461000
	mov	DWORD PTR _pResource$[ebp], edx

; 205  : 
; 206  : 		if( FBitSet( pResource->ucFlags, RES_CHECKFILE ))

	mov	eax, DWORD PTR _pResource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 128				; 00000080H
	je	SHORT $LN7@SV_Transfe

; 207  : 			continue;	// already checked?

	jmp	SHORT $LN2@SV_Transfe
$LN7@SV_Transfe:

; 208  : 
; 209  : 		if( !SV_FileInConsistencyList( pResource->szFileName, &pc ))

	lea	edx, DWORD PTR _pc$[ebp]
	push	edx
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_SV_FileInConsistencyList
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@SV_Transfe

; 210  : 			continue;

	jmp	SHORT $LN2@SV_Transfe
$LN8@SV_Transfe:

; 211  : 
; 212  : 		SetBits( pResource->ucFlags, RES_CHECKFILE );

	mov	ecx, DWORD PTR _pResource$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [eax+76], dl

; 213  : 
; 214  : 		if( pResource->type == t_sound )

	mov	ecx, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	jne	SHORT $LN9@SV_Transfe

; 215  : 			Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, pResource->szFileName );

	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	push	OFFSET $SG136192
	push	OFFSET $SG136193
	push	256					; 00000100H
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN10@SV_Transfe
$LN9@SV_Transfe:

; 216  : 		else Q_strncpy( filepath, pResource->szFileName, sizeof( filepath ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN10@SV_Transfe:

; 217  : 
; 218  : 		MD5_HashFile( pResource->rgucMD5_hash, filepath, NULL );

	push	0
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	call	_MD5_HashFile
	add	esp, 12					; 0000000cH

; 219  : 
; 220  : 		if( pResource->type == t_model )

	mov	edx, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [edx+64], 2
	jne	$LN11@SV_Transfe

; 221  : 		{
; 222  : 			switch( pc->check_type )

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv133[ebp], ecx
	cmp	DWORD PTR tv133[ebp], 1
	je	SHORT $LN13@SV_Transfe
	cmp	DWORD PTR tv133[ebp], 2
	je	$LN15@SV_Transfe
	jmp	$LN11@SV_Transfe

; 223  : 			{
; 224  : 			case force_exactfile:
; 225  : 				// only MD5 hash compare
; 226  : 				break;

	jmp	$LN11@SV_Transfe
$LN13@SV_Transfe:

; 227  : 			case force_model_samebounds:
; 228  : 				if( !Mod_GetStudioBounds( filepath, mins, maxs ))

	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	call	_Mod_GetStudioBounds
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_Transfe

; 229  : 					Host_Error( "Mod_GetStudioBounds: couldn't get bounds for %s\n", filepath );

	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	push	OFFSET $SG136198
	call	_Host_Error
	add	esp, 8
$LN14@SV_Transfe:

; 230  : 				memcpy( &pResource->rguc_reserved[0x01], mins, sizeof( mins ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pResource$[ebp]
	lea	eax, DWORD PTR [edx+ecx+94]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 231  : 				memcpy( &pResource->rguc_reserved[0x0D], maxs, sizeof( maxs ));

	push	12					; 0000000cH
	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _pResource$[ebp]
	lea	edx, DWORD PTR [ecx+eax+94]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 232  : 				pResource->rguc_reserved[0] = pc->check_type;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR _pc$[ebp]
	mov	al, BYTE PTR [eax+8]
	mov	BYTE PTR [edx+ecx+94], al

; 233  : 				break;

	jmp	SHORT $LN11@SV_Transfe
$LN15@SV_Transfe:

; 234  : 			case force_model_specifybounds:
; 235  : 				memcpy( &pResource->rguc_reserved[0x01], pc->mins, sizeof( pc->mins ));

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _pc$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pResource$[ebp]
	lea	ecx, DWORD PTR [eax+edx+94]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 236  : 				memcpy( &pResource->rguc_reserved[0x0D], pc->maxs, sizeof( pc->maxs ));

	push	12					; 0000000cH
	mov	edx, DWORD PTR _pc$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, 1
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _pResource$[ebp]
	lea	eax, DWORD PTR [edx+ecx+94]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 237  : 				pResource->rguc_reserved[0] = pc->check_type;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	cl, BYTE PTR [ecx+8]
	mov	BYTE PTR [eax+edx+94], cl
$LN11@SV_Transfe:

; 238  : 				break;
; 239  : 			}
; 240  : 		}
; 241  : 		total++;

	mov	edx, DWORD PTR _total$[ebp]
	add	edx, 1
	mov	DWORD PTR _total$[ebp], edx

; 242  : 	}

	jmp	$LN2@SV_Transfe
$LN3@SV_Transfe:

; 243  : 
; 244  : 	sv.num_consistency = total;

	mov	eax, DWORD PTR _total$[ebp]
	mov	DWORD PTR _sv+1157320, eax

; 245  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TransferConsistencyInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_ClearResourceLists PROC

; 378  : {

	push	ebp
	mov	ebp, esp

; 379  : 	SV_ClearResourceList( &cl->resourcesneeded );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264752				; 00040a30H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 380  : 	SV_ClearResourceList( &cl->resourcesonhand );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264616				; 000409a8H
	push	ecx
	call	_SV_ClearResourceList
	add	esp, 4

; 381  : }

	pop	ebp
	ret	0
_SV_ClearResourceLists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_SendResources PROC

; 556  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 557  : 	int	i;
; 558  : 
; 559  : 	MSG_BeginServerCmd( msg, svc_resourcerequest );

	push	0
	push	1
	push	45					; 0000002dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 560  : 	MSG_WriteLong( msg, svs.spawncount );

	mov	ecx, DWORD PTR _svs+33340
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 561  : 	MSG_WriteLong( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 562  : 
; 563  : 	if( COM_CheckString( sv_downloadurl.string ) && Q_strlen( sv_downloadurl.string ) < 256 )

	mov	ecx, DWORD PTR _sv_downloadurl+4
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@SV_SendRes
	mov	edx, DWORD PTR _sv_downloadurl+4
	push	edx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 256				; 00000100H
	jge	SHORT $LN5@SV_SendRes

; 564  : 	{
; 565  : 		MSG_BeginServerCmd( msg, svc_resourcelocation );

	push	0
	push	1
	push	56					; 00000038H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 566  : 		MSG_WriteString( msg, sv_downloadurl.string );

	mov	ecx, DWORD PTR _sv_downloadurl+4
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8
$LN5@SV_SendRes:

; 567  : 	}
; 568  : 
; 569  : 	MSG_BeginServerCmd( msg, svc_resourcelist );

	push	0
	push	1
	push	43					; 0000002bH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 570  : 	MSG_WriteUBitLong( msg, sv.num_resources, MAX_RESOURCE_BITS );

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _sv+1157324
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 571  : 
; 572  : 	for( i = 0; i < sv.num_resources; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SendRes
$LN2@SV_SendRes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_SendRes:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _sv+1157324
	jge	SHORT $LN3@SV_SendRes

; 573  : 	{
; 574  : 		SV_SendResource( &sv.resources[i], msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, OFFSET _sv+461000
	push	eax
	call	_SV_SendResource
	add	esp, 8

; 575  : 	}

	jmp	SHORT $LN2@SV_SendRes
$LN3@SV_SendRes:

; 576  : 
; 577  : 	SV_SendConsistencyList( cl, msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_SendConsistencyList
	add	esp, 8

; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_n$ = -268						; size = 4
_p$ = -264						; size = 4
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_BatchUploadRequest PROC

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 503  : 	string		filename;
; 504  : 	resource_t	*p, *n;
; 505  : 
; 506  : 	for( p = cl->resourcesneeded.pNext; p != &cl->resourcesneeded; p = n )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264880]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@SV_BatchUp
$LN2@SV_BatchUp:
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], edx
$LN4@SV_BatchUp:
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264752				; 00040a30H
	cmp	DWORD PTR _p$[ebp], eax
	je	$LN1@SV_BatchUp

; 507  : 	{
; 508  : 		n = p->pNext;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _n$[ebp], edx

; 509  : 
; 510  : 		if( !FBitSet( p->ucFlags, RES_WASMISSING ))

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 2
	jne	SHORT $LN5@SV_BatchUp

; 511  : 		{
; 512  : 			SV_MoveToOnHandList( cl, p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_MoveToOnHandList
	add	esp, 8

; 513  : 			continue;

	jmp	SHORT $LN2@SV_BatchUp
$LN5@SV_BatchUp:

; 514  : 		}
; 515  : 
; 516  : 		if( p->type == t_decal )

	mov	ecx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [ecx+64], 3
	jne	$LN6@SV_BatchUp

; 517  : 		{
; 518  : 			if( FBitSet( p->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	je	SHORT $LN7@SV_BatchUp

; 519  : 			{
; 520  : 				Q_snprintf( filename, sizeof( filename ), "!MD5%s", MD5_Print( p->rgucMD5_hash ));

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET $SG136368
	push	256					; 00000100H
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 521  : 
; 522  : 				if( SV_CheckFile( &cl->netchan.message, filename ))

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_SV_CheckFile
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@SV_BatchUp

; 523  : 					SV_MoveToOnHandList( cl, p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_MoveToOnHandList
	add	esp, 8
$LN9@SV_BatchUp:

; 524  : 			}

	jmp	SHORT $LN6@SV_BatchUp
$LN7@SV_BatchUp:

; 525  : 			else
; 526  : 			{
; 527  : 				Con_Reportf( S_ERROR "Non customization in upload queue!\n" );

	push	OFFSET $SG136370
	call	_Con_Reportf
	add	esp, 4

; 528  : 				SV_MoveToOnHandList( cl, p );

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_MoveToOnHandList
	add	esp, 8
$LN6@SV_BatchUp:

; 529  : 			}
; 530  : 		}
; 531  : 	}

	jmp	$LN2@SV_BatchUp
$LN1@SV_BatchUp:

; 532  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BatchUploadRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_n$ = -8						; size = 4
_p$ = -4						; size = 4
_pList$ = 8						; size = 4
_SV_ClearResourceList PROC

; 361  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 362  : 	resource_t *p;
; 363  : 	resource_t *n;
; 364  : 
; 365  : 	for( p = pList->pNext; pList != p && p; p = n )

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@SV_ClearRe
$LN2@SV_ClearRe:
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], edx
$LN4@SV_ClearRe:
	mov	eax, DWORD PTR _pList$[ebp]
	cmp	eax, DWORD PTR _p$[ebp]
	je	SHORT $LN3@SV_ClearRe
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@SV_ClearRe

; 366  : 	{
; 367  : 		n = p->pNext;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _n$[ebp], edx

; 368  : 
; 369  : 		SV_RemoveFromResourceList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_SV_RemoveFromResourceList
	add	esp, 4

; 370  : 		Mem_Free( p );

	push	370					; 00000172H
	push	OFFSET $SG136274
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 371  : 	}

	jmp	SHORT $LN2@SV_ClearRe
$LN3@SV_ClearRe:

; 372  : 
; 373  : 	pList->pPrev = pList;

	mov	edx, DWORD PTR _pList$[ebp]
	mov	eax, DWORD PTR _pList$[ebp]
	mov	DWORD PTR [edx+132], eax

; 374  : 	pList->pNext = pList;

	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR _pList$[ebp]
	mov	DWORD PTR [ecx+128], edx

; 375  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClearResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_missing$ = -12						; size = 4
_size$ = -8						; size = 4
_p$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_EstimateNeededResources PROC

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 385  : 	int		missing = 0;

	mov	DWORD PTR _missing$[ebp], 0

; 386  : 	int		size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 387  : 	resource_t	*p;
; 388  : 
; 389  : 	for( p = cl->resourcesneeded.pNext; p != &cl->resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264880]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@SV_Estimat
$LN2@SV_Estimat:
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR _p$[ebp], eax
$LN4@SV_Estimat:
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264752				; 00040a30H
	cmp	DWORD PTR _p$[ebp], ecx
	je	SHORT $LN3@SV_Estimat

; 390  : 	{
; 391  : 		if( p->type != t_decal )

	mov	edx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [edx+64], 3
	je	SHORT $LN5@SV_Estimat

; 392  : 			continue;

	jmp	SHORT $LN2@SV_Estimat
$LN5@SV_Estimat:

; 393  : 
; 394  : 		if( !HPAK_ResourceForHash( CUSTOM_RES_PATH, p->rgucMD5_hash, NULL ))

	push	0
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	push	OFFSET $SG136290
	call	_HPAK_ResourceForHash
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_Estimat

; 395  : 		{
; 396  : 			if( p->nDownloadSize != 0 )

	mov	ecx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $LN7@SV_Estimat

; 397  : 			{
; 398  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	or	eax, 2
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+76], al

; 399  : 				size += p->nDownloadSize;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _size$[ebp], eax

; 400  : 			}

	jmp	SHORT $LN6@SV_Estimat
$LN7@SV_Estimat:

; 401  : 			else
; 402  : 			{
; 403  : 				missing++;

	mov	ecx, DWORD PTR _missing$[ebp]
	add	ecx, 1
	mov	DWORD PTR _missing$[ebp], ecx
$LN6@SV_Estimat:

; 404  : 			}
; 405  : 		}
; 406  : 	}

	jmp	SHORT $LN2@SV_Estimat
$LN3@SV_Estimat:

; 407  : 
; 408  : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 409  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EstimateNeededResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_ft$ = -444						; size = 4
_value$ = -440						; size = 4
$T1 = -436						; size = 4
_invalid_type$ = -432					; size = 4
tv141 = -428						; size = 4
_c$ = -424						; size = 4
_r$ = -420						; size = 4
_badresindex$ = -416					; size = 4
_idx$ = -412						; size = 4
_i$ = -408						; size = 4
_cmaxs$ = -404						; size = 12
_cmins$ = -392						; size = 12
_maxs$ = -380						; size = 12
_mins$ = -368						; size = 12
_dropmessage$2 = -356					; size = 256
_readbuffer$ = -100					; size = 32
_nullbuffer$ = -68					; size = 32
_resbuffer$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseConsistencyResponse PROC

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 91   : 	int		i, c, idx, value;
; 92   : 	byte		readbuffer[32];
; 93   : 	byte		nullbuffer[32];
; 94   : 	byte		resbuffer[32];
; 95   : 	qboolean		invalid_type;
; 96   : 	vec3_t		cmins, cmaxs;
; 97   : 	int		badresindex;
; 98   : 	vec3_t		mins, maxs;
; 99   : 	FORCE_TYPE	ft;
; 100  : 	resource_t	*r;
; 101  : 
; 102  : 	memset( nullbuffer, 0, sizeof( nullbuffer ));

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _nullbuffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 103  : 	invalid_type = false;

	mov	DWORD PTR _invalid_type$[ebp], 0

; 104  : 	badresindex = 0;

	mov	DWORD PTR _badresindex$[ebp], 0

; 105  : 	c = 0;

	mov	DWORD PTR _c$[ebp], 0
$LN2@SV_ParseCo:

; 106  : 
; 107  : 	while( MSG_ReadOneBit( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	$LN3@SV_ParseCo

; 108  : 	{
; 109  : 		idx = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _idx$[ebp], eax

; 110  : 		if( idx < 0 || idx >= sv.num_resources )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN10@SV_ParseCo
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _sv+1157324
	jl	SHORT $LN9@SV_ParseCo
$LN10@SV_ParseCo:

; 111  : 			break;

	jmp	$LN3@SV_ParseCo
$LN9@SV_ParseCo:

; 112  : 
; 113  : 		r = &sv.resources[idx];

	imul	ecx, DWORD PTR _idx$[ebp], 136
	add	ecx, OFFSET _sv+461000
	mov	DWORD PTR _r$[ebp], ecx

; 114  : 
; 115  : 		if( !FBitSet( r->ucFlags, RES_CHECKFILE ))

	mov	edx, DWORD PTR _r$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 128				; 00000080H
	jne	SHORT $LN11@SV_ParseCo

; 116  : 			break;

	jmp	$LN3@SV_ParseCo
$LN11@SV_ParseCo:

; 117  : 
; 118  : 		memcpy( readbuffer, r->rguc_reserved, 32 );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _r$[ebp]
	add	ecx, 94					; 0000005eH
	push	ecx
	lea	edx, DWORD PTR _readbuffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 119  : 
; 120  : 		if( !memcmp( readbuffer, nullbuffer, 32 ))

	push	32					; 00000020H
	lea	eax, DWORD PTR _nullbuffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _readbuffer$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_ParseCo

; 121  : 		{
; 122  : 			value = MSG_ReadUBitLong( msg, 32 );

	push	32					; 00000020H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _value$[ebp], eax

; 123  : 
; 124  : 			// will be compare only first 4 bytes
; 125  : 			if( value != *(int *)r->rgucMD5_hash )

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	cmp	ecx, DWORD PTR [eax+77]
	je	SHORT $LN14@SV_ParseCo

; 126  : 				badresindex = idx + 1;

	mov	edx, DWORD PTR _idx$[ebp]
	add	edx, 1
	mov	DWORD PTR _badresindex$[ebp], edx
$LN14@SV_ParseCo:

; 127  : 		}

	jmp	$LN4@SV_ParseCo
$LN12@SV_ParseCo:

; 128  : 		else
; 129  : 		{
; 130  : 			MSG_ReadBytes( msg, cmins, sizeof( cmins ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _cmins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 131  : 			MSG_ReadBytes( msg, cmaxs, sizeof( cmaxs ));

	push	12					; 0000000cH
	lea	edx, DWORD PTR _cmaxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 132  : 
; 133  : 			memcpy( resbuffer, r->rguc_reserved, 32 );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _r$[ebp]
	add	ecx, 94					; 0000005eH
	push	ecx
	lea	edx, DWORD PTR _resbuffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 134  : 			ft = resbuffer[0];

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _resbuffer$[ebp+ecx]
	mov	DWORD PTR _ft$[ebp], edx

; 135  : 
; 136  : 			switch( ft )

	mov	eax, DWORD PTR _ft$[ebp]
	mov	DWORD PTR tv141[ebp], eax
	cmp	DWORD PTR tv141[ebp], 1
	je	SHORT $LN15@SV_ParseCo
	cmp	DWORD PTR tv141[ebp], 2
	je	$LN19@SV_ParseCo
	jmp	$LN22@SV_ParseCo
$LN15@SV_ParseCo:

; 137  : 			{
; 138  : 			case force_model_samebounds:
; 139  : 				memcpy( mins, &resbuffer[0x01], sizeof( mins ));

	push	12					; 0000000cH
	mov	ecx, 1
	shl	ecx, 0
	lea	edx, DWORD PTR _resbuffer$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 140  : 				memcpy( maxs, &resbuffer[0x0D], sizeof( maxs ));

	push	12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 13
	lea	eax, DWORD PTR _resbuffer$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 141  : 
; 142  : 				if( !VectorCompare( cmins, mins ) || !VectorCompare( cmaxs, maxs ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _cmins$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _mins$[ebp+edx]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN18@SV_ParseCo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _cmins$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _mins$[ebp+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN18@SV_ParseCo
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _cmins$[ebp+edx]
	ucomiss	xmm0, DWORD PTR _mins$[ebp+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_ParseCo
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _cmaxs$[ebp+edx]
	ucomiss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_ParseCo
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cmaxs$[ebp+edx]
	ucomiss	xmm0, DWORD PTR _maxs$[ebp+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_ParseCo
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _cmaxs$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR _maxs$[ebp+edx]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@SV_ParseCo
$LN18@SV_ParseCo:

; 143  : 					badresindex = idx + 1;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _badresindex$[ebp], eax
$LN16@SV_ParseCo:

; 144  : 				break;

	jmp	$LN4@SV_ParseCo
$LN19@SV_ParseCo:

; 145  : 			case force_model_specifybounds:
; 146  : 				memcpy( mins, &resbuffer[0x01], sizeof( mins ));

	push	12					; 0000000cH
	mov	ecx, 1
	shl	ecx, 0
	lea	edx, DWORD PTR _resbuffer$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 147  : 				memcpy( maxs, &resbuffer[0x0D], sizeof( maxs ));

	push	12					; 0000000cH
	mov	ecx, 1
	imul	edx, ecx, 13
	lea	eax, DWORD PTR _resbuffer$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 148  : 
; 149  : 				for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@SV_ParseCo
$LN6@SV_ParseCo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@SV_ParseCo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN7@SV_ParseCo

; 150  : 				{
; 151  : 					if( cmins[i] < mins[i] || cmaxs[i] > maxs[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+eax*4]
	comiss	xmm0, DWORD PTR _cmins$[ebp+ecx*4]
	ja	SHORT $LN21@SV_ParseCo
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _cmaxs$[ebp+edx*4]
	comiss	xmm0, DWORD PTR _maxs$[ebp+eax*4]
	jbe	SHORT $LN20@SV_ParseCo
$LN21@SV_ParseCo:

; 152  : 					{
; 153  : 						badresindex = idx + 1;

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _badresindex$[ebp], ecx

; 154  : 						break;

	jmp	SHORT $LN7@SV_ParseCo
$LN20@SV_ParseCo:

; 155  : 					}
; 156  : 				}

	jmp	SHORT $LN6@SV_ParseCo
$LN7@SV_ParseCo:

; 157  : 				break;

	jmp	SHORT $LN4@SV_ParseCo
$LN22@SV_ParseCo:

; 158  : 			default:
; 159  : 				invalid_type = true;

	mov	DWORD PTR _invalid_type$[ebp], 1
$LN4@SV_ParseCo:

; 160  : 				break;
; 161  : 			}
; 162  : 		}
; 163  : 
; 164  : 		if( invalid_type )

	cmp	DWORD PTR _invalid_type$[ebp], 0
	je	SHORT $LN23@SV_ParseCo

; 165  : 			break;

	jmp	SHORT $LN3@SV_ParseCo
$LN23@SV_ParseCo:

; 166  : 		c++;

	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 1
	mov	DWORD PTR _c$[ebp], edx

; 167  : 	}

	jmp	$LN2@SV_ParseCo
$LN3@SV_ParseCo:

; 168  : 
; 169  : 	if( sv.num_consistency != c )

	mov	eax, DWORD PTR _sv+1157320
	cmp	eax, DWORD PTR _c$[ebp]
	je	SHORT $LN24@SV_ParseCo

; 170  : 	{
; 171  : 		Con_Printf( S_WARN "%s:%s sent bad file data\n", cl->name, NET_AdrToString( cl->netchan.remote_address ));

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG136168
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 172  : 		SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 173  : 		return;

	jmp	$LN26@SV_ParseCo
$LN24@SV_ParseCo:

; 174  : 	}
; 175  : 
; 176  : 	if( badresindex != 0 )

	cmp	DWORD PTR _badresindex$[ebp], 0
	je	$LN25@SV_ParseCo

; 177  : 	{
; 178  : 		char	dropmessage[256];
; 179  : 
; 180  : 		dropmessage[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN30@SV_ParseCo
	jmp	SHORT $LN31@SV_ParseCo
$LN30@SV_ParseCo:
	call	___report_rangecheckfailure
$LN31@SV_ParseCo:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _dropmessage$2[ebp+eax], 0

; 181  : 		if( svgame.dllFuncs.pfnInconsistentFile( cl->edict, sv.resources[badresindex - 1].szFileName, dropmessage ))

	lea	ecx, DWORD PTR _dropmessage$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _badresindex$[ebp]
	sub	edx, 1
	imul	eax, edx, 136
	add	eax, OFFSET _sv+461000
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	DWORD PTR _svgame+19432
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@SV_ParseCo

; 182  : 		{
; 183  : 			if( COM_CheckString( dropmessage ))

	lea	eax, DWORD PTR _dropmessage$2[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@SV_ParseCo

; 184  : 				SV_ClientPrintf( cl, dropmessage );

	lea	ecx, DWORD PTR _dropmessage$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_ClientPrintf
	add	esp, 8
$LN28@SV_ParseCo:

; 185  : 			SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8
$LN27@SV_ParseCo:

; 186  : 		}
; 187  : 	}

	jmp	SHORT $LN26@SV_ParseCo
$LN25@SV_ParseCo:

; 188  : 	else
; 189  : 	{
; 190  : 		ClearBits( cl->flags, FCL_FORCE_UNMODIFIED );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, -1025				; fffffbffH
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx
$LN26@SV_ParseCo:

; 191  : 	}
; 192  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseConsistencyResponse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pResource$ = 8						; size = 4
_SV_RemoveFromResourceList PROC

; 353  : {

	push	ebp
	mov	ebp, esp

; 354  : 	pResource->pPrev->pNext = pResource->pNext;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR [ecx+128], eax

; 355  : 	pResource->pNext->pPrev = pResource->pPrev;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR [edx+132], ecx

; 356  : 	pResource->pPrev = NULL;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [edx+132], 0

; 357  : 	pResource->pNext = NULL;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+128], 0

; 358  : }

	pop	ebp
	ret	0
_SV_RemoveFromResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_pResource$ = 12					; size = 4
_SV_MoveToOnHandList PROC

; 313  : {

	push	ebp
	mov	ebp, esp

; 314  : 	if( !pResource )

	cmp	DWORD PTR _pResource$[ebp], 0
	jne	SHORT $LN2@SV_MoveToO

; 315  : 	{
; 316  : 		Con_Reportf( "Null resource passed to SV_MoveToOnHandList\n" );

	push	OFFSET $SG136240
	call	_Con_Reportf
	add	esp, 4

; 317  : 		return;

	jmp	SHORT $LN1@SV_MoveToO
$LN2@SV_MoveToO:

; 318  : 	}
; 319  : 
; 320  : 	SV_RemoveFromResourceList( pResource );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_SV_RemoveFromResourceList
	add	esp, 4

; 321  : 	SV_AddToResourceList( pResource, &cl->resourcesonhand );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264616				; 000409a8H
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	call	_SV_AddToResourceList
	add	esp, 8
$LN1@SV_MoveToO:

; 322  : }

	pop	ebp
	ret	0
_SV_MoveToOnHandList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pResource$ = 8						; size = 4
_pList$ = 12						; size = 4
_SV_AddToResourceList PROC

; 325  : {

	push	ebp
	mov	ebp, esp

; 326  : 	if( pResource->pPrev != NULL || pResource->pNext != NULL )

	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jne	SHORT $LN3@SV_AddToRe
	mov	ecx, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [ecx+128], 0
	je	SHORT $LN2@SV_AddToRe
$LN3@SV_AddToRe:

; 327  : 	{
; 328  : 		Con_Reportf( S_ERROR "Resource already linked\n" );

	push	OFFSET $SG136250
	call	_Con_Reportf
	add	esp, 4

; 329  : 		return;

	jmp	SHORT $LN1@SV_AddToRe
$LN2@SV_AddToRe:

; 330  : 	}
; 331  : 
; 332  : 	pResource->pPrev = pList->pPrev;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR [edx+132], ecx

; 333  : 	pResource->pNext = pList;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR _pList$[ebp]
	mov	DWORD PTR [edx+128], eax

; 334  : 	pList->pPrev->pNext = pResource;

	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [edx+128], eax

; 335  : 	pList->pPrev = pResource;

	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+132], edx
$LN1@SV_AddToRe:

; 336  : }

	pop	ebp
	ret	0
_SV_AddToResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_custom.c
_TEXT	SEGMENT
_pResource$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_SendResource PROC

; 535  : {

	push	ebp
	mov	ebp, esp

; 536  : 	static byte	nullrguc[36];
; 537  : 
; 538  : 	MSG_WriteUBitLong( msg, pResource->type, 4 );

	push	4
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 539  : 	MSG_WriteString( msg, pResource->szFileName );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 540  : 	MSG_WriteUBitLong( msg, pResource->nIndex, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 541  : 	MSG_WriteSBitLong( msg, pResource->nDownloadSize, 24 ); // prevent to download a very big files?

	push	24					; 00000018H
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 542  : 	MSG_WriteUBitLong( msg, pResource->ucFlags & ( RES_FATALIFMISSING|RES_WASMISSING ), 3 );

	push	3
	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 3
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 543  : 
; 544  : 	if( FBitSet( pResource->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	je	SHORT $LN2@SV_SendRes

; 545  : 		MSG_WriteBytes( msg, pResource->rgucMD5_hash, sizeof( pResource->rgucMD5_hash ));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH
$LN2@SV_SendRes:

; 546  : 
; 547  : 	if( memcmp( nullrguc, pResource->rguc_reserved, sizeof( nullrguc )))

	push	36					; 00000024H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 94					; 0000005eH
	push	eax
	push	OFFSET ?nullrguc@?1??SV_SendResource@@9@9
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@SV_SendRes

; 548  : 	{
; 549  : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 550  : 		MSG_WriteBytes( msg, pResource->rguc_reserved, sizeof( pResource->rguc_reserved ));

	push	32					; 00000020H
	mov	edx, DWORD PTR _pResource$[ebp]
	add	edx, 94					; 0000005eH
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 551  : 	}

	jmp	SHORT $LN1@SV_SendRes
$LN3@SV_SendRes:

; 552  : 	else MSG_WriteOneBit( msg, 0 );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_SendRes:

; 553  : }

	pop	ebp
	ret	0
_SV_SendResource ENDP
_TEXT	ENDS
END
