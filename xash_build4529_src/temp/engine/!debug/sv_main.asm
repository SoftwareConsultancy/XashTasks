; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\server\sv_main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_sv_lan
PUBLIC	_sv_lan_rate
PUBLIC	_mp_logecho
PUBLIC	_mp_logfile
PUBLIC	_sv_unlag
PUBLIC	_sv_maxunlag
PUBLIC	_sv_unlagpush
PUBLIC	_sv_unlagsamples
PUBLIC	_rcon_password
PUBLIC	_sv_instancedbaseline
PUBLIC	_sv_background_freeze
PUBLIC	_sv_minupdaterate
PUBLIC	_sv_maxupdaterate
PUBLIC	_sv_downloadurl
PUBLIC	_sv_newunit
PUBLIC	_sv_clienttrace
PUBLIC	_sv_failuretime
PUBLIC	_sv_send_resources
PUBLIC	_sv_send_logos
PUBLIC	_sv_allow_upload
PUBLIC	_sv_allow_download
PUBLIC	_sv_airaccelerate
PUBLIC	_sv_accelerate
PUBLIC	_sv_friction
PUBLIC	_sv_edgefriction
PUBLIC	_sv_gravity
PUBLIC	_sv_stopspeed
PUBLIC	_sv_maxspeed
PUBLIC	_sv_wateralpha
PUBLIC	_sv_wateramp
PUBLIC	_sv_stepsize
PUBLIC	_sv_maxvelocity
PUBLIC	_sv_rollangle
PUBLIC	_sv_rollspeed
PUBLIC	_sv_skyname
PUBLIC	_sv_skycolor_r
PUBLIC	_sv_skycolor_g
PUBLIC	_sv_skycolor_b
PUBLIC	_sv_skyvec_x
PUBLIC	_sv_skyvec_y
PUBLIC	_sv_skyvec_z
PUBLIC	_sv_consistency
PUBLIC	_sv_password
PUBLIC	_sv_uploadmax
PUBLIC	_deathmatch
PUBLIC	_hostname
PUBLIC	_skill
PUBLIC	_coop
PUBLIC	_sv_aim
PUBLIC	_sv_filterban
PUBLIC	_sv_cheats
PUBLIC	_sv_contact
PUBLIC	_sv_minrate
PUBLIC	_sv_maxrate
PUBLIC	_sv_logrelay
PUBLIC	_sv_timeout
PUBLIC	_sv_proxies
PUBLIC	_sv_logbans
PUBLIC	_mapcyclefile
PUBLIC	_motdfile
PUBLIC	_logsdir
PUBLIC	_bannedcfgfile
PUBLIC	_teamplay
PUBLIC	_temp1
PUBLIC	_sv_spectatormaxspeed
PUBLIC	_sv_wateraccelerate
PUBLIC	_sv_waterfriction
PUBLIC	_sv_bounce
PUBLIC	_sv_zmax
PUBLIC	_sv_footsteps
PUBLIC	_showtriggers
PUBLIC	_sv_airmove
PUBLIC	_sv_version
PUBLIC	_sv_fps
PUBLIC	_violence_hblood
PUBLIC	_violence_ablood
PUBLIC	_violence_hgibs
PUBLIC	_violence_agibs
_DATA	SEGMENT
COMM	_sv_pausable:DWORD
COMM	_sv_check_errors:DWORD
COMM	_sv_reconnect_limit:DWORD
COMM	_sv_lighting_modulate:DWORD
COMM	_sv_novis:DWORD
COMM	_sv_hostmap:DWORD
COMM	_sv_validate_changelevel:DWORD
COMM	_public_server:DWORD
COMM	_sv_maxclients:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG136338 DB	01H DUP (?)
$SG136357 DB	01H DUP (?)
$SG136401 DB	01H DUP (?)
$SG136435 DB	01H DUP (?)
$SG136618 DB	01H DUP (?)
$SG136622 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_timeout:DWORD
COMM	_sv_sendvelocity:DWORD
_DATA	ENDS
_DATA	SEGMENT
_sv_lan	DD	FLAT:$SG136308
	DD	FLAT:$SG136309
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136310
	ORG $+4
_sv_lan_rate DD	FLAT:$SG136312
	DD	FLAT:$SG136313
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136314
	ORG $+4
_mp_logecho DD	FLAT:$SG136442
	DD	FLAT:$SG136443
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136444
	ORG $+4
_mp_logfile DD	FLAT:$SG136446
	DD	FLAT:$SG136447
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136448
	ORG $+4
_sv_unlag DD	FLAT:$SG136321
	DD	FLAT:$SG136322
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136323
	ORG $+4
_sv_maxunlag DD	FLAT:$SG136325
	DD	FLAT:$SG136326
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136327
	ORG $+4
_sv_unlagpush DD FLAT:$SG136329
	DD	FLAT:$SG136330
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136331
	ORG $+4
_sv_unlagsamples DD FLAT:$SG136333
	DD	FLAT:$SG136334
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136335
	ORG $+4
_rcon_password DD FLAT:$SG136337
	DD	FLAT:$SG136338
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136339
	ORG $+4
_sv_instancedbaseline DD FLAT:$SG136351
	DD	FLAT:$SG136352
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136353
	ORG $+4
_sv_background_freeze DD FLAT:$SG136602
	DD	FLAT:$SG136603
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136604
	ORG $+4
_sv_minupdaterate DD FLAT:$SG136360
	DD	FLAT:$SG136361
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136362
	ORG $+4
_sv_maxupdaterate DD FLAT:$SG136364
	DD	FLAT:$SG136365
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136366
	ORG $+4
_sv_downloadurl DD FLAT:$SG136434
	DD	FLAT:$SG136435
	DD	020H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136436
	ORG $+4
_sv_newunit DD	FLAT:$SG136383
	DD	FLAT:$SG136384
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136385
	ORG $+4
_sv_clienttrace DD FLAT:$SG136387
	DD	FLAT:$SG136388
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136389
	ORG $+4
_sv_failuretime DD FLAT:$SG136396
	DD	FLAT:$SG136397
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136398
	ORG $+4
_sv_send_resources DD FLAT:$SG136413
	DD	FLAT:$SG136414
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136415
	ORG $+4
_sv_send_logos DD FLAT:$SG136409
	DD	FLAT:$SG136410
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136411
	ORG $+4
_sv_allow_upload DD FLAT:$SG136422
	DD	FLAT:$SG136423
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136424
	ORG $+4
_sv_allow_download DD FLAT:$SG136426
	DD	FLAT:$SG136427
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136428
	ORG $+4
_sv_airaccelerate DD FLAT:$SG136513
	DD	FLAT:$SG136514
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136515
	ORG $+4
_sv_accelerate DD FLAT:$SG136509
	DD	FLAT:$SG136510
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136511
	ORG $+4
_sv_friction DD	FLAT:$SG136522
	DD	FLAT:$SG136523
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136524
	ORG $+4
_sv_edgefriction DD FLAT:$SG136526
	DD	FLAT:$SG136527
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136528
	ORG $+4
_sv_gravity DD	FLAT:$SG136492
	DD	FLAT:$SG136493
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136494
	ORG $+4
_sv_stopspeed DD FLAT:$SG136496
	DD	FLAT:$SG136497
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136498
	ORG $+4
_sv_maxspeed DD	FLAT:$SG136500
	DD	FLAT:$SG136501
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136502
	ORG $+4
_sv_wateralpha DD FLAT:$SG136598
	DD	FLAT:$SG136599
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136600
	ORG $+4
_sv_wateramp DD	FLAT:$SG136553
	DD	FLAT:$SG136554
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136555
	ORG $+4
_sv_stepsize DD	FLAT:$SG136540
	DD	FLAT:$SG136541
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136542
	ORG $+4
_sv_maxvelocity DD FLAT:$SG136544
	DD	FLAT:$SG136545
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136546
	ORG $+4
_sv_rollangle DD FLAT:$SG136566
	DD	FLAT:$SG136567
	DD	0501H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136568
	ORG $+4
_sv_rollspeed DD FLAT:$SG136570
	DD	FLAT:$SG136571
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136572
	ORG $+4
_sv_skyname DD	FLAT:$SG136562
	DD	FLAT:$SG136563
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136564
	ORG $+4
_sv_skycolor_r DD FLAT:$SG136574
	DD	FLAT:$SG136575
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136576
	ORG $+4
_sv_skycolor_g DD FLAT:$SG136578
	DD	FLAT:$SG136579
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136580
	ORG $+4
_sv_skycolor_b DD FLAT:$SG136582
	DD	FLAT:$SG136583
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136584
	ORG $+4
_sv_skyvec_x DD	FLAT:$SG136586
	DD	FLAT:$SG136587
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136588
	ORG $+4
_sv_skyvec_y DD	FLAT:$SG136590
	DD	FLAT:$SG136591
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136592
	ORG $+4
_sv_skyvec_z DD	FLAT:$SG136594
	DD	FLAT:$SG136595
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136596
	ORG $+4
_sv_consistency DD FLAT:$SG136438
	DD	FLAT:$SG136439
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136440
	ORG $+4
_sv_password DD	FLAT:$SG136400
	DD	FLAT:$SG136401
	DD	024H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136402
	ORG $+4
_sv_uploadmax DD FLAT:$SG136430
	DD	FLAT:$SG136431
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136432
	ORG $+4
_deathmatch DD	FLAT:$SG136470
	DD	FLAT:$SG136471
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136472
	ORG $+4
_hostname DD	FLAT:$SG136621
	DD	FLAT:$SG136622
	DD	084H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136623
	ORG $+4
_skill	DD	FLAT:$SG136483
	DD	FLAT:$SG136484
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136485
	ORG $+4
_coop	DD	FLAT:$SG136474
	DD	FLAT:$SG136475
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136476
	ORG $+4
$SG136308 DB	'sv_lan', 00H
	ORG $+1
$SG136309 DB	'0', 00H
	ORG $+2
$SG136312 DB	'sv_lan_rate', 00H
$SG136310 DB	'server is a lan server ( no heartbeat, no authentication'
	DB	', no non-class C addresses, 9999.0 rate, etc.', 00H
	ORG $+2
$SG136313 DB	'20000.0', 00H
$SG136314 DB	'rate for lan server', 00H
_sv_aim	DD	FLAT:$SG136317
	DD	FLAT:$SG136318
	DD	05H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136319
	ORG $+4
$SG136317 DB	'sv_aim', 00H
	ORG $+1
$SG136318 DB	'1', 00H
	ORG $+2
$SG136319 DB	'auto aiming option', 00H
	ORG $+1
$SG136321 DB	'sv_unlag', 00H
	ORG $+3
$SG136322 DB	'1', 00H
	ORG $+2
$SG136323 DB	'allow lag compensation on server-side', 00H
	ORG $+2
$SG136325 DB	'sv_maxunlag', 00H
$SG136326 DB	'0.5', 00H
$SG136327 DB	'max latency value which can be interpolated (by default '
	DB	'ping should not exceed 500 units)', 00H
	ORG $+2
$SG136329 DB	'sv_unlagpush', 00H
	ORG $+3
$SG136330 DB	'0.0', 00H
$SG136331 DB	'interpolation bias for unlag time', 00H
	ORG $+2
$SG136333 DB	'sv_unlagsamples', 00H
$SG136334 DB	'1', 00H
	ORG $+2
$SG136335 DB	'max samples to interpolate', 00H
	ORG $+1
$SG136337 DB	'rcon_password', 00H
	ORG $+2
$SG136339 DB	'remote connect password', 00H
_sv_filterban DD FLAT:$SG136342
	DD	FLAT:$SG136343
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136344
	ORG $+4
$SG136342 DB	'sv_filterban', 00H
	ORG $+3
$SG136343 DB	'1', 00H
	ORG $+2
$SG136344 DB	'filter banned users', 00H
_sv_cheats DD	FLAT:$SG136347
	DD	FLAT:$SG136348
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136349
	ORG $+4
$SG136347 DB	'sv_cheats', 00H
	ORG $+2
$SG136348 DB	'0', 00H
	ORG $+2
$SG136349 DB	'allow cheats on server', 00H
	ORG $+1
$SG136351 DB	'sv_instancedbaseline', 00H
	ORG $+3
$SG136352 DB	'1', 00H
	ORG $+2
$SG136353 DB	'allow to use instanced baselines to saves network overhe'
	DB	'ad', 00H
	ORG $+1
_sv_contact DD	FLAT:$SG136356
	DD	FLAT:$SG136357
	DD	05H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136358
	ORG $+4
$SG136356 DB	'sv_contact', 00H
	ORG $+1
$SG136358 DB	'server techincal support contact address or web-page', 00H
	ORG $+3
$SG136360 DB	'sv_minupdaterate', 00H
	ORG $+3
$SG136361 DB	'10.0', 00H
	ORG $+3
$SG136362 DB	'minimal value for ''cl_updaterate'' window', 00H
	ORG $+3
$SG136364 DB	'sv_maxupdaterate', 00H
	ORG $+3
$SG136365 DB	'30.0', 00H
	ORG $+3
$SG136366 DB	'maximal value for ''cl_updaterate'' window', 00H
	ORG $+3
_sv_minrate DD	FLAT:$SG136369
	DD	FLAT:$SG136370
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136371
	ORG $+4
$SG136369 DB	'sv_minrate', 00H
	ORG $+1
$SG136370 DB	'0', 00H
	ORG $+2
$SG136371 DB	'min bandwidth rate allowed on server, 0 == unlimited', 00H
	ORG $+3
_sv_maxrate DD	FLAT:$SG136374
	DD	FLAT:$SG136375
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136376
	ORG $+4
$SG136374 DB	'sv_maxrate', 00H
	ORG $+1
$SG136375 DB	'0', 00H
	ORG $+2
$SG136376 DB	'max bandwidth rate allowed on server, 0 == unlimited', 00H
	ORG $+3
_sv_logrelay DD	FLAT:$SG136379
	DD	FLAT:$SG136380
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136381
	ORG $+4
$SG136379 DB	'sv_logrelay', 00H
$SG136380 DB	'0', 00H
	ORG $+2
$SG136381 DB	'allow log messages from remote machines to be logged on '
	DB	'this server', 00H
$SG136383 DB	'sv_newunit', 00H
	ORG $+1
$SG136384 DB	'0', 00H
	ORG $+2
$SG136387 DB	'sv_clienttrace', 00H
	ORG $+1
$SG136388 DB	'1', 00H
	ORG $+2
$SG136385 DB	'clear level-saves from previous SP game chapter to help '
	DB	'keep .sav file size as minimum', 00H
	ORG $+1
$SG136389 DB	'0 = big box(Quake), 0.5 = halfsize, 1 = normal (100%), o'
	DB	'therwise it''s a scaling factor', 00H
	ORG $+1
_sv_timeout DD	FLAT:$SG136392
	DD	FLAT:$SG136393
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136394
	ORG $+4
$SG136392 DB	'sv_timeout', 00H
	ORG $+1
$SG136393 DB	'65', 00H
	ORG $+1
$SG136397 DB	'0.5', 00H
$SG136394 DB	'after this many seconds without a message from a client,'
	DB	' the client is dropped', 00H
	ORG $+1
$SG136396 DB	'sv_failuretime', 00H
	ORG $+1
$SG136398 DB	'after this long without a packet from client, don''t sen'
	DB	'd any more until client starts sending again', 00H
$SG136400 DB	'sv_password', 00H
$SG136402 DB	'server password for entry into multiplayer games', 00H
	ORG $+3
_sv_proxies DD	FLAT:$SG136405
	DD	FLAT:$SG136406
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136407
	ORG $+4
$SG136405 DB	'sv_proxies', 00H
	ORG $+1
$SG136406 DB	'1', 00H
	ORG $+2
$SG136407 DB	'maximum count of allowed proxies for HLTV spectating', 00H
	ORG $+3
$SG136409 DB	'sv_send_logos', 00H
	ORG $+2
$SG136410 DB	'1', 00H
	ORG $+2
$SG136413 DB	'sv_send_resources', 00H
	ORG $+2
$SG136411 DB	'send custom decal logo to other players so they can view'
	DB	' his too', 00H
	ORG $+3
$SG136414 DB	'1', 00H
	ORG $+2
$SG136415 DB	'allow to download missed resources for players', 00H
	ORG $+1
_sv_logbans DD	FLAT:$SG136418
	DD	FLAT:$SG136419
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136420
	ORG $+4
$SG136418 DB	'sv_logbans', 00H
	ORG $+1
$SG136419 DB	'0', 00H
	ORG $+2
$SG136420 DB	'print into the server log info about player bans', 00H
	ORG $+3
$SG136422 DB	'sv_allow_upload', 00H
$SG136423 DB	'1', 00H
	ORG $+2
$SG136424 DB	'allow uploading custom resources on a server', 00H
	ORG $+3
$SG136426 DB	'sv_allow_download', 00H
	ORG $+2
$SG136427 DB	'1', 00H
	ORG $+2
$SG136428 DB	'allow downloading custom resources to the client', 00H
	ORG $+3
$SG136430 DB	'sv_uploadmax', 00H
	ORG $+3
$SG136431 DB	'0.5', 00H
$SG136432 DB	'max size to upload custom resources (500 kB as default)', 00H
$SG136434 DB	'sv_downloadurl', 00H
	ORG $+1
$SG136436 DB	'location from which clients can download missing files', 00H
	ORG $+1
$SG136438 DB	'mp_consistency', 00H
	ORG $+1
$SG136439 DB	'1', 00H
	ORG $+2
$SG136440 DB	'enbale consistency check in multiplayer', 00H
$SG136442 DB	'mp_logecho', 00H
	ORG $+1
$SG136443 DB	'1', 00H
	ORG $+2
$SG136444 DB	'log multiplayer frags to server logfile', 00H
$SG136446 DB	'mp_logfile', 00H
	ORG $+1
$SG136447 DB	'1', 00H
	ORG $+2
$SG136448 DB	'log multiplayer frags to console', 00H
	ORG $+3
_mapcyclefile DD FLAT:$SG136451
	DD	FLAT:$SG136452
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136453
	ORG $+4
$SG136451 DB	'mapcyclefile', 00H
	ORG $+3
$SG136452 DB	'mapcycle.txt', 00H
	ORG $+3
$SG136453 DB	'name of multiplayer map cycle configuration file', 00H
	ORG $+3
_motdfile DD	FLAT:$SG136456
	DD	FLAT:$SG136457
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136458
	ORG $+4
$SG136456 DB	'motdfile', 00H
	ORG $+3
$SG136457 DB	'motd.txt', 00H
	ORG $+3
$SG136458 DB	'name of ''message of the day'' file', 00H
	ORG $+2
_logsdir DD	FLAT:$SG136461
	DD	FLAT:$SG136462
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136463
	ORG $+4
$SG136461 DB	'logsdir', 00H
$SG136462 DB	'logs', 00H
	ORG $+3
$SG136463 DB	'place to store multiplayer logs', 00H
_bannedcfgfile DD FLAT:$SG136466
	DD	FLAT:$SG136467
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136468
	ORG $+4
$SG136466 DB	'bannedcfgfile', 00H
	ORG $+2
$SG136467 DB	'banned.cfg', 00H
	ORG $+1
$SG136468 DB	'name of list of banned users', 00H
	ORG $+3
$SG136470 DB	'deathmatch', 00H
	ORG $+1
$SG136471 DB	'0', 00H
	ORG $+2
$SG136472 DB	'deathmatch mode in multiplayer game', 00H
$SG136474 DB	'coop', 00H
	ORG $+3
$SG136475 DB	'0', 00H
	ORG $+2
$SG136476 DB	'cooperative mode in multiplayer game', 00H
	ORG $+3
_teamplay DD	FLAT:$SG136479
	DD	FLAT:$SG136480
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136481
	ORG $+4
$SG136479 DB	'teamplay', 00H
	ORG $+3
$SG136480 DB	'0', 00H
	ORG $+2
$SG136481 DB	'team mode in multiplayer game', 00H
	ORG $+2
$SG136483 DB	'skill', 00H
	ORG $+2
$SG136484 DB	'1', 00H
	ORG $+2
$SG136485 DB	'skill level in singleplayer game', 00H
	ORG $+3
_temp1	DD	FLAT:$SG136488
	DD	FLAT:$SG136489
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136490
	ORG $+4
$SG136488 DB	'temp1', 00H
	ORG $+2
$SG136489 DB	'0', 00H
	ORG $+2
$SG136490 DB	'temporary cvar that used by some mods', 00H
	ORG $+2
$SG136492 DB	'sv_gravity', 00H
	ORG $+1
$SG136493 DB	'800', 00H
$SG136494 DB	'world gravity value', 00H
$SG136496 DB	'sv_stopspeed', 00H
	ORG $+3
$SG136497 DB	'100', 00H
$SG136498 DB	'how fast you come to a complete stop', 00H
	ORG $+3
$SG136500 DB	'sv_maxspeed', 00H
$SG136501 DB	'320', 00H
$SG136502 DB	'maximum speed a player can accelerate to when on ground', 00H
_sv_spectatormaxspeed DD FLAT:$SG136505
	DD	FLAT:$SG136506
	DD	0500H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136507
	ORG $+4
$SG136505 DB	'sv_spectatormaxspeed', 00H
	ORG $+3
$SG136506 DB	'500', 00H
$SG136507 DB	'maximum speed a spectator can accelerate in air', 00H
$SG136509 DB	'sv_accelerate', 00H
	ORG $+2
$SG136510 DB	'10', 00H
	ORG $+1
$SG136511 DB	'rate at which a player accelerates to sv_maxspeed', 00H
	ORG $+2
$SG136513 DB	'sv_airaccelerate', 00H
	ORG $+3
$SG136514 DB	'10', 00H
	ORG $+1
_sv_wateraccelerate DD FLAT:$SG136518
	DD	FLAT:$SG136519
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136520
	ORG $+4
$SG136515 DB	'rate at which a player accelerates to sv_maxspeed while '
	DB	'in the air', 00H
	ORG $+1
$SG136518 DB	'sv_wateraccelerate', 00H
	ORG $+1
$SG136519 DB	'10', 00H
	ORG $+1
$SG136522 DB	'sv_friction', 00H
$SG136520 DB	'rate at which a player accelerates to sv_maxspeed while '
	DB	'in the water', 00H
	ORG $+3
$SG136523 DB	'4', 00H
	ORG $+2
$SG136524 DB	'how fast you slow down', 00H
	ORG $+1
$SG136526 DB	'edgefriction', 00H
	ORG $+3
$SG136527 DB	'2', 00H
	ORG $+2
$SG136528 DB	'how much you slow down when nearing a ledge you might fa'
	DB	'll off', 00H
	ORG $+1
_sv_waterfriction DD FLAT:$SG136531
	DD	FLAT:$SG136532
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136533
	ORG $+4
$SG136531 DB	'sv_waterfriction', 00H
	ORG $+3
$SG136532 DB	'1', 00H
	ORG $+2
$SG136533 DB	'how fast you slow down in water', 00H
_sv_bounce DD	FLAT:$SG136536
	DD	FLAT:$SG136537
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136538
	ORG $+4
$SG136536 DB	'sv_bounce', 00H
	ORG $+2
$SG136537 DB	'1', 00H
	ORG $+2
$SG136538 DB	'bounce factor for entities with MOVETYPE_BOUNCE', 00H
$SG136540 DB	'sv_stepsize', 00H
$SG136541 DB	'18', 00H
	ORG $+1
$SG136542 DB	'how high you and NPS''s can step up', 00H
	ORG $+1
$SG136544 DB	'sv_maxvelocity', 00H
	ORG $+1
$SG136545 DB	'2000', 00H
	ORG $+3
$SG136546 DB	'max velocity for all things in the world', 00H
	ORG $+3
_sv_zmax DD	FLAT:$SG136549
	DD	FLAT:$SG136550
	DD	0440H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136551
	ORG $+4
$SG136549 DB	'sv_zmax', 00H
$SG136550 DB	'4096', 00H
	ORG $+3
$SG136551 DB	'maximum viewable distance', 00H
	ORG $+2
$SG136553 DB	'sv_wateramp', 00H
$SG136554 DB	'0', 00H
	ORG $+2
$SG136555 DB	'world waveheight factor', 00H
_sv_footsteps DD FLAT:$SG136558
	DD	FLAT:$SG136559
	DD	0400H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136560
	ORG $+4
$SG136558 DB	'mp_footsteps', 00H
	ORG $+3
$SG136559 DB	'1', 00H
	ORG $+2
$SG136560 DB	'world gravity value', 00H
$SG136562 DB	'sv_skyname', 00H
	ORG $+1
$SG136563 DB	'desert', 00H
	ORG $+1
$SG136564 DB	'skybox name (can be dynamically changed in-game)', 00H
	ORG $+3
$SG136566 DB	'sv_rollangle', 00H
	ORG $+3
$SG136567 DB	'0', 00H
	ORG $+2
$SG136568 DB	'how much to tilt the view when strafing', 00H
$SG136570 DB	'sv_rollspeed', 00H
	ORG $+3
$SG136571 DB	'200', 00H
$SG136572 DB	'how much strafing is necessary to tilt the view', 00H
$SG136574 DB	'sv_skycolor_r', 00H
	ORG $+2
$SG136575 DB	'0', 00H
	ORG $+2
$SG136576 DB	'skylight red component value', 00H
	ORG $+3
$SG136578 DB	'sv_skycolor_g', 00H
	ORG $+2
$SG136579 DB	'0', 00H
	ORG $+2
$SG136580 DB	'skylight green component value', 00H
	ORG $+1
$SG136582 DB	'sv_skycolor_b', 00H
	ORG $+2
$SG136583 DB	'0', 00H
	ORG $+2
$SG136584 DB	'skylight blue component value', 00H
	ORG $+2
$SG136586 DB	'sv_skyvec_x', 00H
$SG136587 DB	'0', 00H
	ORG $+2
$SG136588 DB	'skylight direction by x-axis', 00H
	ORG $+3
$SG136590 DB	'sv_skyvec_y', 00H
$SG136591 DB	'0', 00H
	ORG $+2
$SG136592 DB	'skylight direction by y-axis', 00H
	ORG $+3
$SG136594 DB	'sv_skyvec_z', 00H
$SG136595 DB	'0', 00H
	ORG $+2
$SG136596 DB	'skylight direction by z-axis', 00H
	ORG $+3
$SG136598 DB	'sv_wateralpha', 00H
	ORG $+2
$SG136599 DB	'1', 00H
	ORG $+2
$SG136603 DB	'1', 00H
	ORG $+2
$SG136600 DB	'world surfaces water transparency factor. 1.0 - solid, 0'
	DB	'.0 - fully transparent', 00H
	ORG $+1
$SG136602 DB	'sv_background_freeze', 00H
	ORG $+3
$SG136604 DB	'freeze player movement on background maps (e.g. to preve'
	DB	'nt falling)', 00H
_showtriggers DD FLAT:$SG136607
	DD	FLAT:$SG136608
	DD	0800H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136609
	ORG $+4
$SG136607 DB	'showtriggers', 00H
	ORG $+3
$SG136608 DB	'0', 00H
	ORG $+2
$SG136609 DB	'debug cvar shows triggers', 00H
	ORG $+2
_sv_airmove DD	FLAT:$SG136612
	DD	FLAT:$SG136613
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136614
	ORG $+4
$SG136612 DB	'sv_airmove', 00H
	ORG $+1
$SG136613 DB	'1', 00H
	ORG $+2
$SG136614 DB	'obsolete, compatibility issues', 00H
	ORG $+1
_sv_version DD	FLAT:$SG136617
	DD	FLAT:$SG136618
	DD	020000H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136619
	ORG $+4
$SG136617 DB	'sv_version', 00H
	ORG $+1
$SG136619 DB	'engine version string', 00H
	ORG $+2
$SG136621 DB	'hostname', 00H
	ORG $+3
$SG136623 DB	'name of current host', 00H
	ORG $+3
_sv_fps	DD	FLAT:$SG136626
	DD	FLAT:$SG136627
	DD	04H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136628
	ORG $+4
$SG136626 DB	'sv_fps', 00H
	ORG $+1
$SG136627 DB	'0.0', 00H
$SG136628 DB	'server framerate', 00H
	ORG $+3
_violence_hblood DD FLAT:$SG136631
	DD	FLAT:$SG136632
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136633
	ORG $+4
$SG136631 DB	'violence_hblood', 00H
$SG136632 DB	'1', 00H
	ORG $+2
$SG136633 DB	'draw human blood', 00H
	ORG $+3
_violence_ablood DD FLAT:$SG136636
	DD	FLAT:$SG136637
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136638
	ORG $+4
$SG136636 DB	'violence_ablood', 00H
$SG136637 DB	'1', 00H
	ORG $+2
$SG136638 DB	'draw alien blood', 00H
	ORG $+3
_violence_hgibs DD FLAT:$SG136641
	DD	FLAT:$SG136642
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136643
	ORG $+4
$SG136641 DB	'violence_hgibs', 00H
	ORG $+1
$SG136642 DB	'1', 00H
	ORG $+2
$SG136643 DB	'show human gib entities', 00H
_violence_agibs DD FLAT:$SG136646
	DD	FLAT:$SG136647
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG136648
	ORG $+4
$SG136646 DB	'violence_agibs', 00H
	ORG $+1
$SG136647 DB	'1', 00H
	ORG $+2
$SG136648 DB	'show alien gib entities', 00H
_DATA	ENDS
PUBLIC	_SV_Init
PUBLIC	_SV_Shutdown
PUBLIC	_Host_ServerFrame
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetMaxBytes
PUBLIC	_MSG_GetData
PUBLIC	_SV_FinalMessage
PUBLIC	_SV_UpdateMovevars
PUBLIC	_SV_PrepWorldFrame
PUBLIC	_SV_ProcessFile
PUBLIC	_SV_AddToMaster
PUBLIC	_Host_SetServerState
PUBLIC	_SV_IsSimulating
PUBLIC	_SV_FreeClients
PUBLIC	_Master_Add
PUBLIC	_Master_Heartbeat
PUBLIC	_Master_Shutdown
PUBLIC	_SV_HasActivePlayers
PUBLIC	_SV_CheckCmdTimes
PUBLIC	_SV_ReadPackets
PUBLIC	_SV_CheckTimeouts
PUBLIC	_SV_RunGameFrame
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae147ae147b
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@4069000000000000
PUBLIC	__real@4072c00000000000
PUBLIC	__real@41a00000
PUBLIC	__real@43480000
PUBLIC	__real@43800000
PUBLIC	__real@46fffe00
PUBLIC	__real@47ffff00
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_RegisterVariable:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_NET_Config:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_NET_CompareBaseAdr:PROC
EXTRN	_NET_GetPacket:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Q_buildnum:PROC
EXTRN	_Host_IsLocalGame:PROC
EXTRN	_CL_Active:PROC
EXTRN	_SV_Active:PROC
EXTRN	_COM_HexConvert:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_CreateCustomization:PROC
EXTRN	_HPAK_AddLump:PROC
EXTRN	_HPAK_FlushHostQueue:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_CL_IsInConsole:PROC
EXTRN	_Log_Printf:PROC
EXTRN	_SV_BroadcastPrintf:PROC
EXTRN	_CL_IsPlaybackDemo:PROC
EXTRN	_SV_Initialized:PROC
EXTRN	_CL_Drop:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Mod_FreeAll:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_CopyNormalFragments:PROC
EXTRN	_Netchan_CopyFileFragments:PROC
EXTRN	_Netchan_TransmitBits:PROC
EXTRN	_Netchan_Process:PROC
EXTRN	_Netchan_IncomingReady:PROC
EXTRN	_SV_DropClient:PROC
EXTRN	_SV_RemoteCommand:PROC
EXTRN	_SV_Physics:PROC
EXTRN	_SV_SendClientMessages:PROC
EXTRN	_SV_TogglePause:PROC
EXTRN	_SV_ExecuteClientMessage:PROC
EXTRN	_SV_ConnectionlessPacket:PROC
EXTRN	_SV_BuildReconnect:PROC
EXTRN	_SV_EndRedirect:PROC
EXTRN	_SV_InitHostCommands:PROC
EXTRN	_SV_MoveToOnHandList:PROC
EXTRN	_SV_RequestMissingResources:PROC
EXTRN	_SV_UnloadProgs:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_Log_Close:PROC
EXTRN	_SV_ClearGameState:PROC
EXTRN	_MSG_WriteDeltaMovevars:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host_limitlocal:DWORD
EXTRN	_net_clockwindow:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_net_from:BYTE
EXTRN	_net_message:BYTE
EXTRN	_net_message_buffer:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	8

?lastreset@?1??SV_CheckCmdTimes@@9@9 DQ 01H DUP (?)	; `SV_CheckCmdTimes'::`2'::lastreset
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@47ffff00
CONST	SEGMENT
__real@47ffff00 DD 047ffff00r			; 131070
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@4072c00000000000
CONST	SEGMENT
__real@4072c00000000000 DQ 04072c00000000000r	; 300
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f847ae147ae147b
CONST	SEGMENT
__real@3f847ae147ae147b DQ 03f847ae147ae147br	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG136669 DB	'sv_zmax', 00H
$SG136673 DB	'sv_zmax', 00H
$SG136675 DB	'sv_zmax', 00H
$SG136691 DB	'sv_fps', 00H
	ORG $+1
$SG136693 DB	'sv_fps', 00H
	ORG $+1
$SG136722 DB	'Ignoring non-customization file upload of %s', 0aH, 00H
	ORG $+2
$SG136725 DB	'SV_ProcessFile:  Unrequested decal', 0aH, 00H
$SG136727 DB	'Downloaded %i bytes for purported %i byte file', 0aH, 00H
$SG136728 DB	'custom.hpk', 00H
	ORG $+1
$SG136733 DB	'Duplicate resource received and ignored.', 0aH, 00H
	ORG $+2
$SG136735 DB	'^1Error:^7 parsing custom decal from %s', 0aH, 00H
	ORG $+3
$SG136755 DB	'ClientPacket', 00H
	ORG $+3
$SG136760 DB	'rcon', 00H
	ORG $+3
$SG136773 DB	'ClientPacket', 00H
	ORG $+3
$SG136798 DB	'%s timed out', 0aH, 00H
	ORG $+2
$SG136800 DB	'Pause released since no players are left.', 00H
	ORG $+2
$SG136842 DB	'%i', 00H
	ORG $+1
$SG136843 DB	'host_serverstate', 00H
	ORG $+3
$SG136849 DB	'ms.xash.su:27010', 00H
	ORG $+3
$SG136850 DB	'ms.xash.su:27010', 00H
	ORG $+3
$SG136851 DB	'can''t resolve adr: %s', 0aH, 00H
	ORG $+1
$SG136852 DB	'q', 0ffH, 00H
	ORG $+1
$SG136864 DB	'ms.xash.su:27010', 00H
	ORG $+3
$SG136865 DB	'ms.xash.su:27010', 00H
	ORG $+3
$SG136866 DB	'can''t resolve addr: %s', 0aH, 00H
$SG136867 DB	'b', 0aH, 00H
	ORG $+1
$SG136883 DB	'0', 0aH, 00H
	ORG $+1
$SG136888 DB	'%d', 00H
	ORG $+1
$SG136889 DB	'protocol', 00H
	ORG $+3
$SG136890 DB	'%u', 00H
	ORG $+1
$SG136891 DB	'challenge', 00H
	ORG $+2
$SG136892 DB	'%d', 00H
	ORG $+1
$SG136893 DB	'players', 00H
$SG136894 DB	'%d', 00H
	ORG $+1
$SG136895 DB	'max', 00H
$SG136896 DB	'%d', 00H
	ORG $+1
$SG136897 DB	'bots', 00H
	ORG $+3
$SG136898 DB	'gamedir', 00H
$SG136899 DB	'map', 00H
$SG136900 DB	'd', 00H
	ORG $+2
$SG136901 DB	'l', 00H
	ORG $+2
$SG136902 DB	'type', 00H
	ORG $+3
$SG136903 DB	'0', 00H
	ORG $+2
$SG136904 DB	'password', 00H
	ORG $+3
$SG136905 DB	'w', 00H
	ORG $+2
$SG136906 DB	'os', 00H
	ORG $+1
$SG136907 DB	'0', 00H
	ORG $+2
$SG136908 DB	'secure', 00H
	ORG $+1
$SG136909 DB	'0', 00H
	ORG $+2
$SG136910 DB	'lan', 00H
$SG136911 DB	'0.99', 00H
	ORG $+3
$SG136912 DB	'%s', 00H
	ORG $+1
$SG136913 DB	'version', 00H
$SG136914 DB	'255', 00H
$SG136915 DB	'region', 00H
	ORG $+1
$SG136916 DB	'product', 00H
$SG136920 DB	'displays server protocol version', 00H
	ORG $+3
$SG136921 DB	'%i', 00H
	ORG $+1
$SG136922 DB	'protocol', 00H
	ORG $+3
$SG136923 DB	'HEV suit volume', 00H
$SG136924 DB	'0.25', 00H
	ORG $+3
$SG136925 DB	'suitvolume', 00H
	ORG $+1
$SG136926 DB	'indicate what background map is running', 00H
$SG136927 DB	'0', 00H
	ORG $+2
$SG136928 DB	'sv_background', 00H
	ORG $+2
$SG136929 DB	'game folder', 00H
$SG136930 DB	'gamedir', 00H
$SG136931 DB	'allow to talking for all players (legacy, unused)', 00H
	ORG $+2
$SG136932 DB	'1', 00H
	ORG $+2
$SG136933 DB	'sv_alltalk', 00H
	ORG $+1
$SG136934 DB	'allow XashXT to usage PhysX engine', 00H
	ORG $+1
$SG136935 DB	'1', 00H
	ORG $+2
$SG136936 DB	'sv_allow_PhysX', 00H
	ORG $+1
$SG136937 DB	'cache SOLID_CUSTOM meshes before level loading', 00H
	ORG $+1
$SG136938 DB	'1', 00H
	ORG $+2
$SG136939 DB	'sv_precache_meshes', 00H
	ORG $+1
$SG136940 DB	'name of config file for map changing rules', 00H
	ORG $+1
$SG136941 DB	'mapcycle.txt', 00H
	ORG $+3
$SG136942 DB	'mapcyclefile', 00H
	ORG $+3
$SG136943 DB	'name of dedicated server configuration file', 00H
$SG136944 DB	'server.cfg', 00H
	ORG $+1
$SG136945 DB	'servercfgfile', 00H
	ORG $+2
$SG136946 DB	'name of listen server configuration file', 00H
	ORG $+3
$SG136947 DB	'listenserver.cfg', 00H
	ORG $+3
$SG136948 DB	'lservercfgfile', 00H
	ORG $+1
$SG136949 DB	'default folder to write server logs', 00H
$SG136950 DB	'logs', 00H
	ORG $+3
$SG136951 DB	'logsdir', 00H
$SG136952 DB	'connection timeout', 00H
	ORG $+1
$SG136953 DB	'125', 00H
$SG136954 DB	'timeout', 00H
$SG136955 DB	'allow players to pause or not', 00H
	ORG $+2
$SG136956 DB	'1', 00H
	ORG $+2
$SG136957 DB	'pausable', 00H
	ORG $+3
$SG136958 DB	'test change level for level-designer errors', 00H
$SG136959 DB	'1', 00H
	ORG $+2
$SG136960 DB	'sv_validate_changelevel', 00H
$SG136961 DB	'server max capacity', 00H
$SG136962 DB	'1', 00H
	ORG $+2
$SG136963 DB	'maxplayers', 00H
	ORG $+1
$SG136964 DB	'check edicts for errors', 00H
$SG136965 DB	'0', 00H
	ORG $+2
$SG136966 DB	'sv_check_errors', 00H
$SG136967 DB	'change server type from private to public', 00H
	ORG $+2
$SG136968 DB	'0', 00H
	ORG $+2
$SG136969 DB	'public', 00H
	ORG $+1
$SG136970 DB	'lightstyles modulate scale', 00H
	ORG $+1
$SG136971 DB	'0.6', 00H
$SG136972 DB	'r_lighting_modulate', 00H
$SG136973 DB	'max reconnect attempts', 00H
	ORG $+1
$SG136974 DB	'3', 00H
	ORG $+2
$SG136975 DB	'sv_reconnect_limit', 00H
	ORG $+1
$SG136976 DB	'force to ignore server visibility', 00H
	ORG $+2
$SG136977 DB	'0', 00H
	ORG $+2
$SG136978 DB	'sv_novis', 00H
	ORG $+3
$SG136979 DB	'keep name of last entered map', 00H
	ORG $+2
$SG136980 DB	'hostmap', 00H
$SG136982 DB	'sv_cheats', 00H
	ORG $+2
$SG136983 DB	'NetMessage', 00H
	ORG $+1
$SG136984 DB	'0.99', 00H
	ORG $+3
$SG136985 DB	'Xash3D', 00H
	ORG $+1
$SG136986 DB	'%s: %s,%i,%i', 00H
	ORG $+3
$SG136987 DB	'sv_version', 00H
	ORG $+1
$SG137006 DB	'FinalMessage', 00H
	ORG $+3
$SG137033 DB	'%s', 00H
	ORG $+1
$SG137023 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_main.c', 00H
$SG137036 DB	'Server shutdown', 0aH, 00H
	ORG $+3
$SG137026 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_main.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_fps$1 = -16						; size = 8
tv78 = -8						; size = 4
_numFrames$2 = -4					; size = 4
_SV_RunGameFrame PROC

; 567  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 568  : 	sv.simulating = SV_IsSimulating();

	call	_SV_IsSimulating
	mov	DWORD PTR _sv+1359684, eax

; 569  : 
; 570  : 	if( !sv.simulating )

	cmp	DWORD PTR _sv+1359684, 0
	jne	SHORT $LN4@SV_RunGame

; 571  : 		return true;

	mov	eax, 1
	jmp	$LN6@SV_RunGame
$LN4@SV_RunGame:

; 572  : 
; 573  : 	if( sv_fps.value != 0.0f )

	movss	xmm0, DWORD PTR _sv_fps+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@SV_RunGame

; 574  : 	{
; 575  : 		double		fps = (1.0 / (double)( sv_fps.value - 0.01 )); // FP issues

	cvtss2sd xmm0, DWORD PTR _sv_fps+12
	subsd	xmm0, QWORD PTR __real@3f847ae147ae147b
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movsd	QWORD PTR _fps$1[ebp], xmm1

; 576  : 		int		numFrames = 0;

	mov	DWORD PTR _numFrames$2[ebp], 0
$LN2@SV_RunGame:

; 577  : 		static double	oldtime;
; 578  : 
; 579  : 		while( sv.time_residual >= fps )

	movsd	xmm0, QWORD PTR _sv+24
	comisd	xmm0, QWORD PTR _fps$1[ebp]
	jb	SHORT $LN3@SV_RunGame

; 580  : 		{
; 581  : 			sv.frametime = fps;

	cvtsd2ss xmm0, QWORD PTR _fps$1[ebp]
	movss	DWORD PTR _sv+32, xmm0

; 582  : 
; 583  : 			SV_Physics();

	call	_SV_Physics

; 584  : 
; 585  : 			sv.time_residual -= fps;

	movsd	xmm0, QWORD PTR _sv+24
	subsd	xmm0, QWORD PTR _fps$1[ebp]
	movsd	QWORD PTR _sv+24, xmm0

; 586  : 			sv.time += fps;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR _fps$1[ebp]
	movsd	QWORD PTR _sv+16, xmm0

; 587  : 			numFrames++;

	mov	eax, DWORD PTR _numFrames$2[ebp]
	add	eax, 1
	mov	DWORD PTR _numFrames$2[ebp], eax

; 588  : 		}

	jmp	SHORT $LN2@SV_RunGame
$LN3@SV_RunGame:

; 589  : 
; 590  : 		return (numFrames != 0);

	cmp	DWORD PTR _numFrames$2[ebp], 0
	je	SHORT $LN8@SV_RunGame
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN9@SV_RunGame
$LN8@SV_RunGame:
	mov	DWORD PTR tv78[ebp], 0
$LN9@SV_RunGame:
	mov	eax, DWORD PTR tv78[ebp]
	jmp	SHORT $LN6@SV_RunGame

; 591  : 	}

	jmp	SHORT $LN6@SV_RunGame
$LN5@SV_RunGame:

; 592  : 	else
; 593  : 	{
; 594  : 		SV_Physics();

	call	_SV_Physics

; 595  : 		sv.time += sv.frametime;

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _sv+16
	movsd	QWORD PTR _sv+16, xmm0

; 596  : 		return true;

	mov	eax, 1
$LN6@SV_RunGame:

; 597  : 	}
; 598  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RunGameFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_droppoint$ = -20					; size = 8
_numclients$ = -12					; size = 4
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_CheckTimeouts PROC

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 463  : 	sv_client_t	*cl;
; 464  : 	double		droppoint;
; 465  : 	int		i, numclients = 0;

	mov	DWORD PTR _numclients$[ebp], 0

; 466  : 
; 467  : 	droppoint = host.realtime - timeout->value;

	mov	eax, DWORD PTR _timeout
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _host+1440
	subsd	xmm1, xmm0
	movsd	QWORD PTR _droppoint$[ebp], xmm1

; 468  : 
; 469  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], ecx
	jmp	SHORT $LN4@SV_CheckTi
$LN2@SV_CheckTi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], eax
$LN4@SV_CheckTi:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	$LN3@SV_CheckTi

; 470  : 	{
; 471  : 		if( cl->state >= cs_connected )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 2
	jl	SHORT $LN6@SV_CheckTi

; 472  : 		{
; 473  : 			if( cl->edict && !FBitSet( cl->edict->v.flags, FL_SPECTATOR|FL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264980], 0
	je	SHORT $LN6@SV_CheckTi
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 67117056				; 04002000H
	jne	SHORT $LN6@SV_CheckTi

; 474  : 				numclients++;

	mov	ecx, DWORD PTR _numclients$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numclients$[ebp], ecx
$LN6@SV_CheckTi:

; 475  :                     }
; 476  : 
; 477  : 		// fake clients do not timeout
; 478  : 		if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN7@SV_CheckTi

; 479  : 			continue;

	jmp	SHORT $LN2@SV_CheckTi
$LN7@SV_CheckTi:

; 480  : 
; 481  : 		// FIXME: get rid of the zombie state
; 482  : 		if( cl->state == cs_zombie )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN8@SV_CheckTi

; 483  : 		{
; 484  : 			cl->state = cs_free; // can now be reused

	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx], 0

; 485  : 			continue;

	jmp	SHORT $LN2@SV_CheckTi
$LN8@SV_CheckTi:

; 486  : 		}
; 487  : 
; 488  : 		if(( cl->state == cs_connected || cl->state == cs_spawned ) && cl->netchan.last_received < droppoint )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN10@SV_CheckTi
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN11@SV_CheckTi
$LN10@SV_CheckTi:
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _droppoint$[ebp]
	comisd	xmm0, QWORD PTR [edx+592]
	jbe	SHORT $LN11@SV_CheckTi

; 489  : 		{
; 490  : 			if( !NET_IsLocalAddress( cl->netchan.remote_address ))

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN11@SV_CheckTi

; 491  : 			{
; 492  : 				SV_BroadcastPrintf( NULL, "%s timed out\n", cl->name );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG136798
	push	0
	call	_SV_BroadcastPrintf
	add	esp, 12					; 0000000cH

; 493  : 				SV_DropClient( cl, false ); 

	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_DropClient
	add	esp, 8

; 494  : 				cl->state = cs_free; // don't bother with zombie state

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], 0
$LN11@SV_CheckTi:

; 495  : 			}
; 496  : 		}
; 497  : 	}

	jmp	$LN2@SV_CheckTi
$LN3@SV_CheckTi:

; 498  : 
; 499  : 	if( svs.maxclients > 1 && sv.paused && !numclients )

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN12@SV_CheckTi
	cmp	DWORD PTR _sv+1359688, 0
	je	SHORT $LN12@SV_CheckTi
	cmp	DWORD PTR _numclients$[ebp], 0
	jne	SHORT $LN12@SV_CheckTi

; 500  : 	{
; 501  : 		// nobody left, unpause the server
; 502  : 		SV_TogglePause( "Pause released since no players are left." );

	push	OFFSET $SG136800
	call	_SV_TogglePause
	add	esp, 4
$LN12@SV_CheckTi:

; 503  : 	}
; 504  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckTimeouts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_qport$ = -24						; size = 4
_c$1 = -20						; size = 4
_args$2 = -16						; size = 4
_curSize$ = -12						; size = 4
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_ReadPackets PROC

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
$LN31@SV_ReadPac:

; 346  : 	sv_client_t	*cl;
; 347  : 	int		i, qport;
; 348  : 	size_t		curSize;
; 349  : 
; 350  : 	while( NET_GetPacket( NS_SERVER, &net_from, net_message_buffer, &curSize ))

	lea	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message_buffer
	push	OFFSET _net_from
	push	1
	call	_NET_GetPacket
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN3@SV_ReadPac

; 351  : 	{
; 352  : 		MSG_Init( &net_message, "ClientPacket", net_message_buffer, curSize );

	push	-1
	mov	ecx, DWORD PTR _curSize$[ebp]
	push	ecx
	push	OFFSET _net_message_buffer
	push	OFFSET $SG136755
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 353  : 
; 354  : 		// check for connectionless packet (0xffffffff) first
; 355  : 		if( MSG_GetMaxBytes( &net_message ) >= 4 && *(int *)net_message.pData == -1 )

	push	OFFSET _net_message
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	eax, 4
	jl	$LN7@SV_ReadPac
	mov	edx, DWORD PTR _net_message+8
	cmp	DWORD PTR [edx], -1
	jne	$LN7@SV_ReadPac

; 356  : 		{
; 357  : 			if( !svs.initialized )

	cmp	DWORD PTR _svs, 0
	jne	$LN8@SV_ReadPac

; 358  : 			{
; 359  : 				char	*args, *c;
; 360  : 
; 361  : 				MSG_Clear( &net_message  );

	push	OFFSET _net_message
	call	_MSG_Clear
	add	esp, 4

; 362  : 				MSG_ReadLong( &net_message  );// skip the -1 marker

	push	OFFSET _net_message
	call	_MSG_ReadLong
	add	esp, 4

; 363  : 
; 364  : 				args = MSG_ReadStringLine( &net_message  );

	push	1
	push	OFFSET _net_message
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$2[ebp], eax

; 365  : 				Cmd_TokenizeString( args );

	mov	eax, DWORD PTR _args$2[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 366  : 				c = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _c$1[ebp], eax

; 367  : 
; 368  : 				if( !Q_strcmp( c, "rcon" ))

	push	99999					; 0001869fH
	push	OFFSET $SG136760
	mov	ecx, DWORD PTR _c$1[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@SV_ReadPac

; 369  : 					SV_RemoteCommand( net_from, &net_message );

	push	OFFSET _net_message
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _net_from
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _net_from+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _net_from+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _net_from+12
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _net_from+16
	mov	DWORD PTR [edx+16], eax
	call	_SV_RemoteCommand
	add	esp, 24					; 00000018H
$LN10@SV_ReadPac:

; 370  : 			}

	jmp	SHORT $LN9@SV_ReadPac
$LN8@SV_ReadPac:

; 371  : 			else SV_ConnectionlessPacket( net_from, &net_message );

	push	OFFSET _net_message
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _net_from
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _net_from+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _net_from+8
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _net_from+12
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _net_from+16
	mov	DWORD PTR [ecx+16], edx
	call	_SV_ConnectionlessPacket
	add	esp, 24					; 00000018H
$LN9@SV_ReadPac:

; 372  : 
; 373  : 			continue;

	jmp	$LN31@SV_ReadPac
$LN7@SV_ReadPac:

; 374  : 		}
; 375  : 
; 376  : 		// read the qport out of the message so we can fix up
; 377  : 		// stupid address translating routers
; 378  : 		MSG_Clear( &net_message );

	push	OFFSET _net_message
	call	_MSG_Clear
	add	esp, 4

; 379  : 		MSG_ReadLong( &net_message );	// sequence number

	push	OFFSET _net_message
	call	_MSG_ReadLong
	add	esp, 4

; 380  : 		MSG_ReadLong( &net_message );	// sequence number

	push	OFFSET _net_message
	call	_MSG_ReadLong
	add	esp, 4

; 381  : 		qport = (int)MSG_ReadShort( &net_message ) & 0xffff;

	push	OFFSET _net_message
	call	_MSG_ReadShort
	add	esp, 4
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _qport$[ebp], eax

; 382  : 
; 383  : 		// check for packets from connected clients
; 384  : 		for( i = 0, sv.current_client = svs.clients; i < svs.maxclients; i++, sv.current_client++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _sv+40, eax
	jmp	SHORT $LN6@SV_ReadPac
$LN4@SV_ReadPac:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _sv+40
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _sv+40, edx
$LN6@SV_ReadPac:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN5@SV_ReadPac

; 385  : 		{
; 386  : 			cl = sv.current_client;

	mov	ecx, DWORD PTR _sv+40
	mov	DWORD PTR _cl$[ebp], ecx

; 387  : 
; 388  : 			if( cl->state == cs_free || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN12@SV_ReadPac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN11@SV_ReadPac
$LN12@SV_ReadPac:

; 389  : 				continue;

	jmp	SHORT $LN4@SV_ReadPac
$LN11@SV_ReadPac:

; 390  : 
; 391  : 			if( !NET_CompareBaseAdr( net_from, cl->netchan.remote_address ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_CompareBaseAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN13@SV_ReadPac

; 392  : 				continue;

	jmp	$LN4@SV_ReadPac
$LN13@SV_ReadPac:

; 393  : 
; 394  : 			if( cl->netchan.qport != qport )

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+584]
	cmp	eax, DWORD PTR _qport$[ebp]
	je	SHORT $LN14@SV_ReadPac

; 395  : 				continue;

	jmp	$LN4@SV_ReadPac
$LN14@SV_ReadPac:

; 396  : 
; 397  : 			if( cl->netchan.remote_address.port != net_from.port )

	mov	ecx, DWORD PTR _cl$[ebp]
	movzx	edx, WORD PTR [ecx+582]
	movzx	eax, WORD PTR _net_from+18
	cmp	edx, eax
	je	SHORT $LN15@SV_ReadPac

; 398  : 				cl->netchan.remote_address.port = net_from.port;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	dx, WORD PTR _net_from+18
	mov	WORD PTR [ecx+582], dx
$LN15@SV_ReadPac:

; 399  : 
; 400  : 			if( Netchan_Process( &cl->netchan, &net_message ))

	push	OFFSET _net_message
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_Process
	add	esp, 8
	test	eax, eax
	je	$LN20@SV_ReadPac

; 401  : 			{	
; 402  : 				if(( svs.maxclients == 1 && !host_limitlocal->value ) || ( cl->state != cs_spawned ))

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN19@SV_ReadPac
	mov	ecx, DWORD PTR _host_limitlocal
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN18@SV_ReadPac
$LN19@SV_ReadPac:
	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	je	SHORT $LN17@SV_ReadPac
$LN18@SV_ReadPac:

; 403  : 					SetBits( cl->flags, FCL_SEND_NET_MESSAGE ); // reply at end of frame

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 8
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN17@SV_ReadPac:

; 404  : 
; 405  : 				// this is a valid, sequenced packet, so process it
; 406  : 				if( cl->frames != NULL && cl->state != cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+281916], 0
	je	SHORT $LN20@SV_ReadPac
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN20@SV_ReadPac

; 407  : 				{
; 408  : 					SV_ExecuteClientMessage( cl, &net_message );

	push	OFFSET _net_message
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_ExecuteClientMessage
	add	esp, 8

; 409  : 					svgame.globals->frametime = sv.frametime;

	mov	eax, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [eax+4], xmm0

; 410  : 					svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	ecx, DWORD PTR _svgame+19236
	movss	DWORD PTR [ecx], xmm0
$LN20@SV_ReadPac:

; 411  : 				}
; 412  : 			}
; 413  : 
; 414  : 			// fragmentation/reassembly sending takes priority over all game messages, want this in the future?
; 415  : 			if( Netchan_IncomingReady( &cl->netchan ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_IncomingReady
	add	esp, 4
	test	eax, eax
	je	$LN27@SV_ReadPac

; 416  : 			{
; 417  : 				if( Netchan_CopyNormalFragments( &cl->netchan, &net_message, &curSize ))

	lea	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CopyNormalFragments
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN26@SV_ReadPac

; 418  : 				{
; 419  : 					MSG_Init( &net_message, "ClientPacket", net_message_buffer, curSize );

	push	-1
	mov	edx, DWORD PTR _curSize$[ebp]
	push	edx
	push	OFFSET _net_message_buffer
	push	OFFSET $SG136773
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 420  : 
; 421  : 					if(( svs.maxclients == 1 && !host_limitlocal->value ) || ( cl->state != cs_spawned ))

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN25@SV_ReadPac
	mov	eax, DWORD PTR _host_limitlocal
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SV_ReadPac
$LN25@SV_ReadPac:
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN23@SV_ReadPac
$LN24@SV_ReadPac:

; 422  : 						SetBits( cl->flags, FCL_SEND_NET_MESSAGE ); // reply at end of frame

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 8
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN23@SV_ReadPac:

; 423  : 
; 424  : 					// this is a valid, sequenced packet, so process it
; 425  : 					if( cl->frames != NULL && cl->state != cs_zombie )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+281916], 0
	je	SHORT $LN26@SV_ReadPac
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN26@SV_ReadPac

; 426  : 					{
; 427  : 						SV_ExecuteClientMessage( cl, &net_message );

	push	OFFSET _net_message
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ExecuteClientMessage
	add	esp, 8

; 428  : 						svgame.globals->frametime = sv.frametime;

	mov	edx, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [edx+4], xmm0

; 429  : 						svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19236
	movss	DWORD PTR [eax], xmm0
$LN26@SV_ReadPac:

; 430  : 					}
; 431  : 				}
; 432  : 
; 433  : 				if( Netchan_CopyFileFragments( &cl->netchan, &net_message ))

	push	OFFSET _net_message
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CopyFileFragments
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@SV_ReadPac

; 434  : 				{
; 435  : 					SV_ProcessFile( cl, cl->netchan.incomingfilename );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 262996				; 00040354H
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ProcessFile
	add	esp, 8
$LN27@SV_ReadPac:

; 436  : 				}
; 437  : 			}
; 438  : 			break;

	jmp	SHORT $LN5@SV_ReadPac

; 439  : 		}

	jmp	$LN4@SV_ReadPac
$LN5@SV_ReadPac:

; 440  : 
; 441  : 		if( i != svs.maxclients )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	je	SHORT $LN28@SV_ReadPac

; 442  : 			continue;

	jmp	$LN31@SV_ReadPac
$LN28@SV_ReadPac:

; 443  : 	}

	jmp	$LN31@SV_ReadPac
$LN3@SV_ReadPac:

; 444  : 
; 445  : 	sv.current_client = NULL;

	mov	DWORD PTR _sv+40, 0

; 446  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ReadPackets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_diff$ = -12						; size = 4
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_CheckCmdTimes PROC

; 219  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 220  : 	sv_client_t	*cl;
; 221  : 	static double	lastreset = 0;
; 222  : 	float		diff;
; 223  : 	int		i;
; 224  : 
; 225  : 	if( sv_fps.value != 0.0f )

	movss	xmm0, DWORD PTR _sv_fps+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@SV_CheckCm

; 226  : 	{
; 227  : 		if( sv_fps.value < MIN_FPS )

	cvtss2sd xmm0, DWORD PTR _sv_fps+12
	movsd	xmm1, QWORD PTR __real@4034000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN6@SV_CheckCm

; 228  : 			Cvar_SetValue( "sv_fps", MIN_FPS );

	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136691
	call	_Cvar_SetValue
	add	esp, 8
$LN6@SV_CheckCm:

; 229  : 
; 230  : 		if( sv_fps.value > MAX_FPS )

	cvtss2sd xmm0, DWORD PTR _sv_fps+12
	comisd	xmm0, QWORD PTR __real@4069000000000000
	jbe	SHORT $LN7@SV_CheckCm

; 231  : 			Cvar_SetValue( "sv_fps", MAX_FPS );

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136693
	call	_Cvar_SetValue
	add	esp, 8
$LN7@SV_CheckCm:

; 232  : 	}
; 233  : 
; 234  : 	if( Host_IsLocalGame( ))

	call	_Host_IsLocalGame
	test	eax, eax
	je	SHORT $LN8@SV_CheckCm

; 235  : 		return;

	jmp	$LN3@SV_CheckCm
$LN8@SV_CheckCm:

; 236  : 
; 237  : 	if(( host.realtime - lastreset ) < 1.0 )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR ?lastreset@?1??SV_CheckCmdTimes@@9@9
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN9@SV_CheckCm

; 238  : 		return;

	jmp	$LN3@SV_CheckCm
$LN9@SV_CheckCm:

; 239  : 
; 240  : 	lastreset = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR ?lastreset@?1??SV_CheckCmdTimes@@9@9, xmm0

; 241  : 
; 242  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_CheckCm
$LN2@SV_CheckCm:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_CheckCm:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_CheckCm

; 243  : 	{
; 244  : 		if( cl->state != cs_spawned )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN10@SV_CheckCm

; 245  : 			continue;

	jmp	SHORT $LN2@SV_CheckCm
$LN10@SV_CheckCm:

; 246  : 
; 247  : 		if( cl->connecttime == 0.0 )

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [edx+264944]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_CheckCm

; 248  : 		{
; 249  : 			cl->connecttime = host.realtime;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax+264944], xmm0
$LN11@SV_CheckCm:

; 250  : 		}
; 251  : 
; 252  : 		diff = cl->connecttime + cl->cmdtime - host.realtime;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [ecx+264944]
	addsd	xmm0, QWORD PTR [edx+264952]
	subsd	xmm0, QWORD PTR _host+1440
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _diff$[ebp], xmm0

; 253  : 
; 254  : 		if( diff > net_clockwindow->value )

	mov	eax, DWORD PTR _net_clockwindow
	movss	xmm0, DWORD PTR _diff$[ebp]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN12@SV_CheckCm

; 255  : 		{
; 256  : 			cl->ignorecmdtime = net_clockwindow->value + host.realtime;

	mov	ecx, DWORD PTR _net_clockwindow
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	addsd	xmm0, QWORD PTR _host+1440
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [edx+264960], xmm0

; 257  : 			cl->cmdtime = host.realtime - cl->connecttime;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+264944]
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [ecx+264952], xmm0

; 258  : 		}

	jmp	SHORT $LN14@SV_CheckCm
$LN12@SV_CheckCm:

; 259  : 		else if( diff < -net_clockwindow->value )

	mov	edx, DWORD PTR _net_clockwindow
	movss	xmm0, DWORD PTR [edx+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _diff$[ebp]
	jbe	SHORT $LN14@SV_CheckCm

; 260  : 		{
; 261  : 			cl->cmdtime = host.realtime - cl->connecttime;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+264944]
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [ecx+264952], xmm0
$LN14@SV_CheckCm:

; 262  : 		}
; 263  : 	}

	jmp	$LN2@SV_CheckCm
$LN3@SV_CheckCm:

; 264  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckCmdTimes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_HasActivePlayers PROC

; 131  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 132  : 	int	i;
; 133  : 
; 134  : 	// server inactive
; 135  : 	if( !svs.clients ) return false;

	cmp	DWORD PTR _svs+33344, 0
	jne	SHORT $LN5@SV_HasActi
	xor	eax, eax
	jmp	SHORT $LN1@SV_HasActi
$LN5@SV_HasActi:

; 136  : 
; 137  : 	for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_HasActi
$LN2@SV_HasActi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_HasActi:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_HasActi

; 138  : 	{
; 139  : 		if( svs.clients[i].state == cs_spawned )

	imul	edx, DWORD PTR _i$[ebp], 287560
	mov	eax, DWORD PTR _svs+33344
	cmp	DWORD PTR [eax+edx], 3
	jne	SHORT $LN6@SV_HasActi

; 140  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_HasActi
$LN6@SV_HasActi:

; 141  : 	}

	jmp	SHORT $LN2@SV_HasActi
$LN3@SV_HasActi:

; 142  : 	return false;

	xor	eax, eax
$LN1@SV_HasActi:

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_HasActivePlayers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_adr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_Master_Shutdown PROC

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 709  : 	netadr_t	adr;
; 710  : 
; 711  : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 712  : 
; 713  : 	if( !NET_StringToAdr( MASTERSERVER_ADR, &adr ))

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET $SG136864
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@Master_Shu

; 714  : 		Con_Printf( "can't resolve addr: %s\n", MASTERSERVER_ADR );

	push	OFFSET $SG136865
	push	OFFSET $SG136866
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN1@Master_Shu
$LN2@Master_Shu:

; 715  : 	else NET_SendPacket( NS_SERVER, 2, "\x62\x0A", adr );

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	OFFSET $SG136867
	push	2
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN1@Master_Shu:

; 716  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Master_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_Master_Heartbeat PROC

; 684  : {

	push	ebp
	mov	ebp, esp

; 685  : 	if( !public_server->value || svs.maxclients == 1 )

	mov	eax, DWORD PTR _public_server
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@Master_Hea
	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN2@Master_Hea
$LN3@Master_Hea:

; 686  : 		return; // only public servers send heartbeats

	jmp	SHORT $LN1@Master_Hea
$LN2@Master_Hea:

; 687  : 
; 688  : 	// check for time wraparound
; 689  : 	if( svs.last_heartbeat > host.realtime )

	movsd	xmm0, QWORD PTR _svs+33368
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN4@Master_Hea

; 690  : 		svs.last_heartbeat = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _svs+33368, xmm0
$LN4@Master_Hea:

; 691  : 
; 692  : 	if(( host.realtime - svs.last_heartbeat ) < HEARTBEAT_SECONDS )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _svs+33368
	movsd	xmm1, QWORD PTR __real@4072c00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN5@Master_Hea

; 693  : 		return; // not time to send yet

	jmp	SHORT $LN1@Master_Hea
$LN5@Master_Hea:

; 694  : 
; 695  : 	svs.last_heartbeat = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _svs+33368, xmm0

; 696  : 
; 697  : 	Master_Add();

	call	_Master_Add
$LN1@Master_Hea:

; 698  : }

	pop	ebp
	ret	0
_Master_Heartbeat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_adr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_Master_Add PROC

; 665  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 666  : 	netadr_t	adr;
; 667  : 
; 668  : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 669  : 
; 670  : 	if( !NET_StringToAdr( MASTERSERVER_ADR, &adr ))

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET $SG136849
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@Master_Add

; 671  : 		Con_Printf( "can't resolve adr: %s\n", MASTERSERVER_ADR );

	push	OFFSET $SG136850
	push	OFFSET $SG136851
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN1@Master_Add
$LN2@Master_Add:

; 672  : 	else NET_SendPacket( NS_SERVER, 2, "q\xFF", adr );

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	OFFSET $SG136852
	push	2
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN1@Master_Add:

; 673  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Master_Add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_SV_FreeClients PROC

; 939  : {

	push	ebp
	mov	ebp, esp

; 940  : 	if( svs.maxclients != 0 )

	cmp	DWORD PTR _svs+16, 0
	je	SHORT $LN1@SV_FreeCli

; 941  : 	{
; 942  : 		// free server static data
; 943  : 		if( svs.clients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN3@SV_FreeCli

; 944  : 		{
; 945  : 			Z_Free( svs.clients );

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN4@SV_FreeCli
	push	945					; 000003b1H
	push	OFFSET $SG137023
	mov	eax, DWORD PTR _svs+33344
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_FreeCli:

; 946  : 			svs.clients = NULL;

	mov	DWORD PTR _svs+33344, 0
$LN3@SV_FreeCli:

; 947  : 		}
; 948  : 
; 949  : 		if( svs.packet_entities )

	cmp	DWORD PTR _svs+33356, 0
	je	SHORT $LN1@SV_FreeCli

; 950  : 		{
; 951  : 			Z_Free( svs.packet_entities );

	cmp	DWORD PTR _svs+33356, 0
	je	SHORT $LN6@SV_FreeCli
	push	951					; 000003b7H
	push	OFFSET $SG137026
	mov	ecx, DWORD PTR _svs+33356
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN6@SV_FreeCli:

; 952  : 			svs.packet_entities = NULL;

	mov	DWORD PTR _svs+33356, 0

; 953  : 			svs.num_client_entities = 0;

	mov	DWORD PTR _svs+33348, 0

; 954  : 			svs.next_client_entities = 0;

	mov	DWORD PTR _svs+33352, 0
$LN1@SV_FreeCli:

; 955  : 		}
; 956  : 	}
; 957  : }

	pop	ebp
	ret	0
_SV_FreeClients ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_SV_IsSimulating PROC

; 537  : {

	push	ebp
	mov	ebp, esp

; 538  : 	if( sv.background && SV_Active() && CL_Active())

	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_IsSimul
	call	_SV_Active
	test	eax, eax
	je	SHORT $LN2@SV_IsSimul
	call	_CL_Active
	test	eax, eax
	je	SHORT $LN2@SV_IsSimul

; 539  : 	{
; 540  : 		if( CL_IsInConsole( ))

	call	_CL_IsInConsole
	test	eax, eax
	je	SHORT $LN3@SV_IsSimul

; 541  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_IsSimul
$LN3@SV_IsSimul:

; 542  : 		return true; // force simulating for background map

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsSimul
$LN2@SV_IsSimul:

; 543  : 	}
; 544  : 
; 545  : 	if( !SV_HasActivePlayers( ))

	call	_SV_HasActivePlayers
	test	eax, eax
	jne	SHORT $LN4@SV_IsSimul

; 546  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_IsSimul
$LN4@SV_IsSimul:

; 547  : 
; 548  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@SV_IsSimul

; 549  : 		return true; // always active for dedicated servers

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsSimul
$LN5@SV_IsSimul:

; 550  : 
; 551  : 	// allow to freeze everything in singleplayer
; 552  : 	if( svs.maxclients <= 1 && sv.playersonly )

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN6@SV_IsSimul
	cmp	DWORD PTR _sv+1359680, 0
	je	SHORT $LN6@SV_IsSimul

; 553  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_IsSimul
$LN6@SV_IsSimul:

; 554  : 
; 555  : 	if( !sv.paused && CL_IsInGame( ))

	cmp	DWORD PTR _sv+1359688, 0
	jne	SHORT $LN7@SV_IsSimul
	call	_CL_IsInGame
	test	eax, eax
	je	SHORT $LN7@SV_IsSimul

; 556  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsSimul
$LN7@SV_IsSimul:

; 557  : 
; 558  : 	return false;

	xor	eax, eax
$LN1@SV_IsSimul:

; 559  : }

	pop	ebp
	ret	0
_SV_IsSimulating ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Host_SetServerState PROC

; 652  : {

	push	ebp
	mov	ebp, esp

; 653  : 	Cvar_FullSet( "host_serverstate", va( "%i", state ), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	push	OFFSET $SG136842
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136843
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 654  : 	sv.state = state;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR _sv, ecx

; 655  : }

	pop	ebp
	ret	0
_Host_SetServerState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_challenge$ = -284					; size = 4
tv168 = -280						; size = 4
_bots$ = -276						; size = 4
_clients$ = -272					; size = 4
_index$ = -268						; size = 4
_len$ = -264						; size = 4
_s$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_SV_AddToMaster PROC

; 727  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 728  : 	uint	challenge;
; 729  : 	char	s[MAX_INFO_STRING] = "0\n"; // skip 2 bytes of header

	mov	ax, WORD PTR $SG136883
	mov	WORD PTR _s$[ebp], ax
	mov	cl, BYTE PTR $SG136883+2
	mov	BYTE PTR _s$[ebp+2], cl
	push	253					; 000000fdH
	push	0
	lea	edx, DWORD PTR _s$[ebp+3]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 730  : 	int	clients = 0, bots = 0, index;

	mov	DWORD PTR _clients$[ebp], 0
	mov	DWORD PTR _bots$[ebp], 0

; 731  : 	int	len = sizeof( s );

	mov	DWORD PTR _len$[ebp], 256		; 00000100H

; 732  : 
; 733  : 	if( svs.clients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN5@SV_AddToMa

; 734  : 	{
; 735  : 		for( index = 0; index < svs.maxclients; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@SV_AddToMa
$LN2@SV_AddToMa:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@SV_AddToMa:
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN5@SV_AddToMa

; 736  : 		{
; 737  : 			if( svs.clients[index].state >= cs_connected )

	imul	edx, DWORD PTR _index$[ebp], 287560
	mov	eax, DWORD PTR _svs+33344
	cmp	DWORD PTR [eax+edx], 2
	jl	SHORT $LN6@SV_AddToMa

; 738  : 			{
; 739  : 				if( FBitSet( svs.clients[index].flags, FCL_FAKECLIENT ))

	imul	ecx, DWORD PTR _index$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	mov	eax, DWORD PTR [edx+ecx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN7@SV_AddToMa

; 740  : 					bots++;

	mov	ecx, DWORD PTR _bots$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bots$[ebp], ecx
	jmp	SHORT $LN6@SV_AddToMa
$LN7@SV_AddToMa:

; 741  : 				else clients++;

	mov	edx, DWORD PTR _clients$[ebp]
	add	edx, 1
	mov	DWORD PTR _clients$[ebp], edx
$LN6@SV_AddToMa:

; 742  : 			}
; 743  : 		}

	jmp	SHORT $LN2@SV_AddToMa
$LN5@SV_AddToMa:

; 744  : 	}
; 745  : 
; 746  : 	challenge = MSG_ReadUBitLong( msg, sizeof( uint ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _challenge$[ebp], eax

; 747  : 
; 748  : 	Info_SetValueForKey( s, "protocol", va( "%d", PROTOCOL_VERSION ), len ); // protocol version

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	push	49					; 00000031H
	push	OFFSET $SG136888
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136889
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 749  : 	Info_SetValueForKey( s, "challenge", va( "%u", challenge ), len ); // challenge number

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _challenge$[ebp]
	push	ecx
	push	OFFSET $SG136890
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136891
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 750  : 	Info_SetValueForKey( s, "players", va( "%d", clients ), len ); // current player number, without bots

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clients$[ebp]
	push	ecx
	push	OFFSET $SG136892
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136893
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 751  : 	Info_SetValueForKey( s, "max", va( "%d", svs.maxclients ), len ); // max_players

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svs+16
	push	ecx
	push	OFFSET $SG136894
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136895
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 752  : 	Info_SetValueForKey( s, "bots", va( "%d", bots ), len ); // bot count

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bots$[ebp]
	push	ecx
	push	OFFSET $SG136896
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136897
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 753  : 	Info_SetValueForKey( s, "gamedir", GI->gamedir, len ); // gamedir

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 128				; 00000080H
	push	ecx
	push	OFFSET $SG136898
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 754  : 	Info_SetValueForKey( s, "map", sv.name, len ); // current map

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	OFFSET _sv+56
	push	OFFSET $SG136899
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 755  : 	Info_SetValueForKey( s, "type", (host.type == HOST_DEDICATED) ? "d" : "l", len ); // dedicated or local

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN10@SV_AddToMa
	mov	DWORD PTR tv168[ebp], OFFSET $SG136900
	jmp	SHORT $LN11@SV_AddToMa
$LN10@SV_AddToMa:
	mov	DWORD PTR tv168[ebp], OFFSET $SG136901
$LN11@SV_AddToMa:
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR tv168[ebp]
	push	eax
	push	OFFSET $SG136902
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 756  : 	Info_SetValueForKey( s, "password", "0", len ); // is password set

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	push	OFFSET $SG136903
	push	OFFSET $SG136904
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 757  : 	Info_SetValueForKey( s, "os", "w", len ); // Windows

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	push	OFFSET $SG136905
	push	OFFSET $SG136906
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 758  : 	Info_SetValueForKey( s, "secure", "0", len ); // server anti-cheat

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	OFFSET $SG136907
	push	OFFSET $SG136908
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 759  : 	Info_SetValueForKey( s, "lan", "0", len ); // LAN servers doesn't send info to master

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	push	OFFSET $SG136909
	push	OFFSET $SG136910
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 760  : 	Info_SetValueForKey( s, "version", va( "%s", XASH_VERSION ), len ); // server region. 255 -- all regions

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	push	OFFSET $SG136911
	push	OFFSET $SG136912
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136913
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 761  : 	Info_SetValueForKey( s, "region", "255", len ); // server region. 255 -- all regions

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	OFFSET $SG136914
	push	OFFSET $SG136915
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 762  : 	Info_SetValueForKey( s, "product", GI->gamefolder, len ); // product? Where is the difference with gamedir?

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _SI+768
	push	eax
	push	OFFSET $SG136916
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForKey

; 763  : 
; 764  : 	NET_SendPacket( NS_SERVER, Q_strlen( s ), s, from );

	add	esp, -4					; fffffffcH
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 765  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddToMaster ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_next$ = -40						; size = 4
_bError$ = -36						; size = 4
_bFound$ = -32						; size = 4
_pList$ = -28						; size = 4
_resource$ = -24					; size = 4
_md5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_filename$ = 12						; size = 4
_SV_ProcessFile PROC

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 275  : 	customization_t	*pList;
; 276  : 	resource_t	*resource;
; 277  : 	resource_t	*next;
; 278  : 	byte		md5[16];
; 279  : 	qboolean		bFound;
; 280  : 	qboolean		bError;
; 281  : 
; 282  : 	if( filename[0] != '!' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN8@SV_Process

; 283  : 	{
; 284  : 		Con_Printf( "Ignoring non-customization file upload of %s\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG136722
	call	_Con_Printf
	add	esp, 8

; 285  : 		return;

	jmp	$LN1@SV_Process
$LN8@SV_Process:

; 286  : 	}
; 287  : 
; 288  : 	COM_HexConvert( filename + 4, 32, md5 );

	lea	edx, DWORD PTR _md5$[ebp]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _filename$[ebp]
	add	eax, 4
	push	eax
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 289  : 
; 290  : 	for( resource = cl->resourcesneeded.pNext; resource != &cl->resourcesneeded; resource = next )

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264880]
	mov	DWORD PTR _resource$[ebp], edx
	jmp	SHORT $LN4@SV_Process
$LN2@SV_Process:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _resource$[ebp], eax
$LN4@SV_Process:
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264752				; 00040a30H
	cmp	DWORD PTR _resource$[ebp], ecx
	je	SHORT $LN3@SV_Process

; 291  : 	{
; 292  : 		next = resource->pNext;

	mov	edx, DWORD PTR _resource$[ebp]
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR _next$[ebp], eax

; 293  : 
; 294  : 		if( !memcmp( resource->rgucMD5_hash, md5, 16 ))

	push	16					; 00000010H
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resource$[ebp]
	add	edx, 77					; 0000004dH
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_Process

; 295  : 			break;

	jmp	SHORT $LN3@SV_Process
$LN9@SV_Process:

; 296  : 	}

	jmp	SHORT $LN2@SV_Process
$LN3@SV_Process:

; 297  : 
; 298  : 	if( resource == &cl->resourcesneeded )

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264752				; 00040a30H
	cmp	DWORD PTR _resource$[ebp], eax
	jne	SHORT $LN10@SV_Process

; 299  : 	{
; 300  : 		Con_Printf( "SV_ProcessFile:  Unrequested decal\n" );

	push	OFFSET $SG136725
	call	_Con_Printf
	add	esp, 4

; 301  : 		return;

	jmp	$LN1@SV_Process
$LN10@SV_Process:

; 302  : 	}
; 303  : 
; 304  : 	if( resource->nDownloadSize != cl->netchan.tempbuffersize )

	mov	ecx, DWORD PTR _resource$[ebp]
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [ecx+72]
	cmp	eax, DWORD PTR [edx+263260]
	je	SHORT $LN11@SV_Process

; 305  : 	{
; 306  : 		Con_Printf( "Downloaded %i bytes for purported %i byte file\n", cl->netchan.tempbuffersize, resource->nDownloadSize );

	mov	ecx, DWORD PTR _resource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+263260]
	push	ecx
	push	OFFSET $SG136727
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 307  : 		return;

	jmp	$LN1@SV_Process
$LN11@SV_Process:

; 308  : 	}
; 309  : 
; 310  : 	HPAK_AddLump( true, CUSTOM_RES_PATH, resource, cl->netchan.tempbuffer, NULL );

	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+263256]
	push	eax
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	push	OFFSET $SG136728
	push	1
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H

; 311  : 	ClearBits( resource->ucFlags, RES_WASMISSING );

	mov	edx, DWORD PTR _resource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 312  : 	SV_MoveToOnHandList( cl, resource );

	mov	edx, DWORD PTR _resource$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_MoveToOnHandList
	add	esp, 8

; 313  : 
; 314  : 	bError = false;

	mov	DWORD PTR _bError$[ebp], 0

; 315  : 	bFound = false;

	mov	DWORD PTR _bFound$[ebp], 0

; 316  : 
; 317  : 	for( pList = cl->customdata.pNext; pList; pList = pList->pNext )

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264612]
	mov	DWORD PTR _pList$[ebp], edx
	jmp	SHORT $LN7@SV_Process
$LN5@SV_Process:
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pList$[ebp], ecx
$LN7@SV_Process:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN6@SV_Process

; 318  : 	{
; 319  : 		if( !memcmp( pList->resource.rgucMD5_hash, resource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	edx, DWORD PTR _resource$[ebp]
	add	edx, 77					; 0000004dH
	push	edx
	mov	eax, DWORD PTR _pList$[ebp]
	add	eax, 81					; 00000051H
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_Process

; 320  : 		{
; 321  : 			bFound = true;

	mov	DWORD PTR _bFound$[ebp], 1

; 322  : 			break;

	jmp	SHORT $LN6@SV_Process
$LN12@SV_Process:

; 323  : 		}
; 324  : 	}

	jmp	SHORT $LN5@SV_Process
$LN6@SV_Process:

; 325  : 
; 326  : 	if( !bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	jne	SHORT $LN13@SV_Process

; 327  : 	{
; 328  : 		if( !COM_CreateCustomization( &cl->customdata, resource, -1, FCUST_FROMHPAK|FCUST_WIPEDATA|FCUST_IGNOREINIT, NULL, NULL ))

	push	0
	push	0
	push	7
	push	-1
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264452				; 00040904H
	push	edx
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN15@SV_Process

; 329  : 			bError = true;

	mov	DWORD PTR _bError$[ebp], 1
$LN15@SV_Process:

; 330  : 	}

	jmp	SHORT $LN14@SV_Process
$LN13@SV_Process:

; 331  : 	else
; 332  : 	{
; 333  : 		Con_DPrintf( "Duplicate resource received and ignored.\n" );

	push	OFFSET $SG136733
	call	_Con_DPrintf
	add	esp, 4
$LN14@SV_Process:

; 334  : 	}
; 335  : 
; 336  : 	if( bError ) Con_Printf( S_ERROR "parsing custom decal from %s\n", cl->name );

	cmp	DWORD PTR _bError$[ebp], 0
	je	SHORT $LN1@SV_Process
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG136735
	call	_Con_Printf
	add	esp, 8
$LN1@SV_Process:

; 337  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ProcessFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_ent$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_PrepWorldFrame PROC

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 516  : 	edict_t	*ent;
; 517  : 	int	i;
; 518  : 
; 519  : 	for( i = 1; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_PrepWor
$LN2@SV_PrepWor:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_PrepWor:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svgame+7932
	jge	SHORT $LN3@SV_PrepWor

; 520  : 	{
; 521  : 		ent = EDICT_NUM( i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 522  : 		if( ent->free ) continue;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SV_PrepWor
	jmp	SHORT $LN2@SV_PrepWor
$LN5@SV_PrepWor:

; 523  : 
; 524  : 		ClearBits( ent->v.effects, EF_MUZZLEFLASH|EF_NOINTERP );

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	and	edx, -35				; ffffffddH
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+408], edx

; 525  : 	}

	jmp	SHORT $LN2@SV_PrepWor
$LN3@SV_PrepWor:

; 526  : 
; 527  : 	if( svgame.physFuncs.pfnPrepWorldFrame != NULL )

	cmp	DWORD PTR _svgame+19516, 0
	je	SHORT $LN1@SV_PrepWor

; 528  : 		svgame.physFuncs.pfnPrepWorldFrame();

	call	DWORD PTR _svgame+19516
$LN1@SV_PrepWor:

; 529  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PrepWorldFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_initialize$ = 8					; size = 4
_SV_UpdateMovevars PROC

; 154  : {

	push	ebp
	mov	ebp, esp

; 155  : 	if( sv.state == ss_dead )

	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN2@SV_UpdateM

; 156  : 		return;

	jmp	$LN1@SV_UpdateM
$LN2@SV_UpdateM:

; 157  : 
; 158  : 	if( !initialize && !host.movevars_changed )

	cmp	DWORD PTR _initialize$[ebp], 0
	jne	SHORT $LN3@SV_UpdateM
	cmp	DWORD PTR _host+34412, 0
	jne	SHORT $LN3@SV_UpdateM

; 159  : 		return;

	jmp	$LN1@SV_UpdateM
$LN3@SV_UpdateM:

; 160  : 
; 161  : 	// check range
; 162  : 	if( sv_zmax.value < 256.0f ) Cvar_SetValue( "sv_zmax", 256.0f );

	movss	xmm0, DWORD PTR __real@43800000
	comiss	xmm0, DWORD PTR _sv_zmax+12
	jbe	SHORT $LN4@SV_UpdateM
	push	ecx
	movss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136669
	call	_Cvar_SetValue
	add	esp, 8
$LN4@SV_UpdateM:

; 163  : 
; 164  : 	// clamp it right
; 165  : 	if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 1
	je	SHORT $LN5@SV_UpdateM

; 166  : 	{
; 167  : 		if( sv_zmax.value > 131070.0f )

	movss	xmm0, DWORD PTR _sv_zmax+12
	comiss	xmm0, DWORD PTR __real@47ffff00
	jbe	SHORT $LN7@SV_UpdateM

; 168  : 			Cvar_SetValue( "sv_zmax", 131070.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@47ffff00
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136673
	call	_Cvar_SetValue
	add	esp, 8
$LN7@SV_UpdateM:

; 169  : 	}

	jmp	SHORT $LN8@SV_UpdateM
$LN5@SV_UpdateM:

; 170  : 	else
; 171  : 	{
; 172  : 		if( sv_zmax.value > 32767.0f )

	movss	xmm0, DWORD PTR _sv_zmax+12
	comiss	xmm0, DWORD PTR __real@46fffe00
	jbe	SHORT $LN8@SV_UpdateM

; 173  : 			Cvar_SetValue( "sv_zmax", 32767.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@46fffe00
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136675
	call	_Cvar_SetValue
	add	esp, 8
$LN8@SV_UpdateM:

; 174  : 	}
; 175  : 
; 176  : 	svgame.movevars.gravity = sv_gravity.value;

	movss	xmm0, DWORD PTR _sv_gravity+12
	movss	DWORD PTR _svgame+7936, xmm0

; 177  : 	svgame.movevars.stopspeed = sv_stopspeed.value;

	movss	xmm0, DWORD PTR _sv_stopspeed+12
	movss	DWORD PTR _svgame+7940, xmm0

; 178  : 	svgame.movevars.maxspeed = sv_maxspeed.value;

	movss	xmm0, DWORD PTR _sv_maxspeed+12
	movss	DWORD PTR _svgame+7944, xmm0

; 179  : 	svgame.movevars.spectatormaxspeed = sv_spectatormaxspeed.value;

	movss	xmm0, DWORD PTR _sv_spectatormaxspeed+12
	movss	DWORD PTR _svgame+7948, xmm0

; 180  : 	svgame.movevars.accelerate = sv_accelerate.value;

	movss	xmm0, DWORD PTR _sv_accelerate+12
	movss	DWORD PTR _svgame+7952, xmm0

; 181  : 	svgame.movevars.airaccelerate = sv_airaccelerate.value;

	movss	xmm0, DWORD PTR _sv_airaccelerate+12
	movss	DWORD PTR _svgame+7956, xmm0

; 182  : 	svgame.movevars.wateraccelerate = sv_wateraccelerate.value;

	movss	xmm0, DWORD PTR _sv_wateraccelerate+12
	movss	DWORD PTR _svgame+7960, xmm0

; 183  : 	svgame.movevars.friction = sv_friction.value;

	movss	xmm0, DWORD PTR _sv_friction+12
	movss	DWORD PTR _svgame+7964, xmm0

; 184  : 	svgame.movevars.edgefriction = sv_edgefriction.value;

	movss	xmm0, DWORD PTR _sv_edgefriction+12
	movss	DWORD PTR _svgame+7968, xmm0

; 185  : 	svgame.movevars.waterfriction = sv_waterfriction.value;

	movss	xmm0, DWORD PTR _sv_waterfriction+12
	movss	DWORD PTR _svgame+7972, xmm0

; 186  : 	svgame.movevars.bounce = sv_bounce.value;

	movss	xmm0, DWORD PTR _sv_bounce+12
	movss	DWORD PTR _svgame+7980, xmm0

; 187  : 	svgame.movevars.stepsize = sv_stepsize.value;

	movss	xmm0, DWORD PTR _sv_stepsize+12
	movss	DWORD PTR _svgame+7984, xmm0

; 188  : 	svgame.movevars.maxvelocity = sv_maxvelocity.value;

	movss	xmm0, DWORD PTR _sv_maxvelocity+12
	movss	DWORD PTR _svgame+7988, xmm0

; 189  : 	svgame.movevars.zmax = sv_zmax.value;

	movss	xmm0, DWORD PTR _sv_zmax+12
	movss	DWORD PTR _svgame+7992, xmm0

; 190  : 	svgame.movevars.waveHeight = sv_wateramp.value;

	movss	xmm0, DWORD PTR _sv_wateramp+12
	movss	DWORD PTR _svgame+7996, xmm0

; 191  : 	Q_strncpy( svgame.movevars.skyName, sv_skyname.string, sizeof( svgame.movevars.skyName ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _sv_skyname+4
	push	ecx
	push	OFFSET _svgame+8004
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 192  : 	svgame.movevars.footsteps = sv_footsteps.value;

	cvttss2si edx, DWORD PTR _sv_footsteps+12
	mov	DWORD PTR _svgame+8000, edx

; 193  : 	svgame.movevars.rollangle = sv_rollangle.value;

	movss	xmm0, DWORD PTR _sv_rollangle+12
	movss	DWORD PTR _svgame+8036, xmm0

; 194  : 	svgame.movevars.rollspeed = sv_rollspeed.value;

	movss	xmm0, DWORD PTR _sv_rollspeed+12
	movss	DWORD PTR _svgame+8040, xmm0

; 195  : 	svgame.movevars.skycolor_r = sv_skycolor_r.value;

	movss	xmm0, DWORD PTR _sv_skycolor_r+12
	movss	DWORD PTR _svgame+8044, xmm0

; 196  : 	svgame.movevars.skycolor_g = sv_skycolor_g.value;

	movss	xmm0, DWORD PTR _sv_skycolor_g+12
	movss	DWORD PTR _svgame+8048, xmm0

; 197  : 	svgame.movevars.skycolor_b = sv_skycolor_b.value;

	movss	xmm0, DWORD PTR _sv_skycolor_b+12
	movss	DWORD PTR _svgame+8052, xmm0

; 198  : 	svgame.movevars.skyvec_x = sv_skyvec_x.value;

	movss	xmm0, DWORD PTR _sv_skyvec_x+12
	movss	DWORD PTR _svgame+8056, xmm0

; 199  : 	svgame.movevars.skyvec_y = sv_skyvec_y.value;

	movss	xmm0, DWORD PTR _sv_skyvec_y+12
	movss	DWORD PTR _svgame+8060, xmm0

; 200  : 	svgame.movevars.skyvec_z = sv_skyvec_z.value;

	movss	xmm0, DWORD PTR _sv_skyvec_z+12
	movss	DWORD PTR _svgame+8064, xmm0

; 201  : 	svgame.movevars.wateralpha = sv_wateralpha.value;

	movss	xmm0, DWORD PTR _sv_wateralpha+12
	movss	DWORD PTR _svgame+8076, xmm0

; 202  : 	svgame.movevars.features = host.features; // just in case. not really need

	mov	eax, DWORD PTR _host+34748
	mov	DWORD PTR _svgame+8068, eax

; 203  : 	svgame.movevars.entgravity = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _svgame+7976, xmm0

; 204  : 
; 205  : 	if( initialize ) return; // too early

	cmp	DWORD PTR _initialize$[ebp], 0
	je	SHORT $LN9@SV_UpdateM
	jmp	SHORT $LN1@SV_UpdateM
$LN9@SV_UpdateM:

; 206  : 
; 207  : 	if( MSG_WriteDeltaMovevars( &sv.reliable_datagram, &svgame.oldmovevars, &svgame.movevars ))

	push	OFFSET _svgame+7936
	push	OFFSET _svgame+8080
	push	OFFSET _sv+1195756
	call	_MSG_WriteDeltaMovevars
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@SV_UpdateM

; 208  : 		memcpy( &svgame.oldmovevars, &svgame.movevars, sizeof( movevars_t )); // oldstate changed

	push	144					; 00000090H
	push	OFFSET _svgame+7936
	push	OFFSET _svgame+8080
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@SV_UpdateM:

; 209  : 
; 210  : 	host.movevars_changed = false;

	mov	DWORD PTR _host+34412, 0
$LN1@SV_UpdateM:

; 211  : }

	pop	ebp
	ret	0
_SV_UpdateMovevars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_msg$ = -1056						; size = 20
_i$ = -1036						; size = 4
_cl$ = -1032						; size = 4
_msg_buf$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_message$ = 8						; size = 4
_reconnect$ = 12					; size = 4
_SV_FinalMessage PROC

; 892  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1056				; 00000420H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 893  : 	byte		msg_buf[1024];
; 894  : 	sv_client_t	*cl;
; 895  : 	sizebuf_t		msg;
; 896  : 	int		i;
; 897  : 	
; 898  : 	MSG_Init( &msg, "FinalMessage", msg_buf, sizeof( msg_buf ));

	push	-1
	push	1024					; 00000400H
	lea	eax, DWORD PTR _msg_buf$[ebp]
	push	eax
	push	OFFSET $SG137006
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 899  : 
; 900  : 	if( COM_CheckString( message ))

	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@SV_FinalMe

; 901  : 	{
; 902  : 		MSG_BeginServerCmd( &msg, svc_print );

	push	0
	push	1
	push	8
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 903  : 		MSG_WriteString( &msg, message );

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8
$LN8@SV_FinalMe:

; 904  : 	}
; 905  : 
; 906  : 	if( reconnect )

	cmp	DWORD PTR _reconnect$[ebp], 0
	je	SHORT $LN9@SV_FinalMe

; 907  : 	{
; 908  : 		if( svs.maxclients <= 1 )

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN11@SV_FinalMe

; 909  : 		{
; 910  : 			MSG_BeginServerCmd( &msg, svc_changing );

	push	0
	push	1
	push	4
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 911  : 			MSG_WriteOneBit( &msg, GameState->loadGame );

	mov	ecx, DWORD PTR _host+156
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8

; 912  : 		}

	jmp	SHORT $LN12@SV_FinalMe
$LN11@SV_FinalMe:

; 913  : 		else SV_BuildReconnect( &msg ); 

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SV_BuildReconnect
	add	esp, 4
$LN12@SV_FinalMe:

; 914  : 	}

	jmp	SHORT $LN10@SV_FinalMe
$LN9@SV_FinalMe:

; 915  : 	else
; 916  : 	{
; 917  : 		MSG_BeginServerCmd( &msg, svc_disconnect );

	push	0
	push	1
	push	2
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
$LN10@SV_FinalMe:

; 918  : 	}
; 919  : 
; 920  : 	// send it twice
; 921  : 	// stagger the packets to crutch operating system limited buffers
; 922  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	edx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], edx
	jmp	SHORT $LN4@SV_FinalMe
$LN2@SV_FinalMe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_FinalMe:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_FinalMe

; 923  : 		if( cl->state >= cs_connected && !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN13@SV_FinalMe
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	jne	SHORT $LN13@SV_FinalMe

; 924  : 			Netchan_TransmitBits( &cl->netchan, MSG_GetNumBitsWritten( &msg ), MSG_GetData( &msg ));

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN13@SV_FinalMe:
	jmp	$LN2@SV_FinalMe
$LN3@SV_FinalMe:

; 925  : 
; 926  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN7@SV_FinalMe
$LN5@SV_FinalMe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN7@SV_FinalMe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_FinalMe

; 927  : 		if( cl->state >= cs_connected && !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN14@SV_FinalMe
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	jne	SHORT $LN14@SV_FinalMe

; 928  : 			Netchan_TransmitBits( &cl->netchan, MSG_GetNumBitsWritten( &msg ), MSG_GetData( &msg ));

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN14@SV_FinalMe:
	jmp	SHORT $LN5@SV_FinalMe
$LN1@SV_FinalMe:

; 929  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FinalMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 106  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetMaxBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetMaxBytes PROC					; COMDAT

; 103  : _inline int MSG_GetMaxBytes( sizebuf_t *sb ) { return sb->nDataBits >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetMaxBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 101  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_Host_ServerFrame PROC

; 607  : {

	push	ebp
	mov	ebp, esp

; 608  : 	// if server is not active, do nothing
; 609  : 	if( !svs.initialized ) return;

	cmp	DWORD PTR _svs, 0
	jne	SHORT $LN2@Host_Serve
	jmp	$LN1@Host_Serve
$LN2@Host_Serve:

; 610  : 
; 611  : 	if( sv_fps.value != 0.0f && ( sv.simulating || sv.state != ss_active ))

	movss	xmm0, DWORD PTR _sv_fps+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@Host_Serve
	cmp	DWORD PTR _sv+1359684, 0
	jne	SHORT $LN4@Host_Serve
	cmp	DWORD PTR _sv, 2
	je	SHORT $LN3@Host_Serve
$LN4@Host_Serve:

; 612  : 		sv.time_residual += host.frametime;

	movsd	xmm0, QWORD PTR _sv+24
	addsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _sv+24, xmm0
$LN3@Host_Serve:

; 613  : 
; 614  : 	if( sv_fps.value == 0.0f )

	movss	xmm0, DWORD PTR _sv_fps+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Host_Serve

; 615  : 		sv.frametime = host.frametime;

	cvtsd2ss xmm0, QWORD PTR _host+1448
	movss	DWORD PTR _sv+32, xmm0
$LN5@Host_Serve:

; 616  : 	svgame.globals->frametime = sv.frametime;

	mov	eax, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [eax+4], xmm0

; 617  : 
; 618  : 	// check clients timewindow
; 619  : 	SV_CheckCmdTimes ();

	call	_SV_CheckCmdTimes

; 620  : 
; 621  : 	// read packets from clients
; 622  : 	SV_ReadPackets ();

	call	_SV_ReadPackets

; 623  : 
; 624  : 	// refresh physic movevars on the client side
; 625  : 	SV_UpdateMovevars ( false );

	push	0
	call	_SV_UpdateMovevars
	add	esp, 4

; 626  : 
; 627  : 	// request missing resources for clients
; 628  : 	SV_RequestMissingResources();

	call	_SV_RequestMissingResources

; 629  : 
; 630  : 	// check timeouts
; 631  : 	SV_CheckTimeouts ();

	call	_SV_CheckTimeouts

; 632  : 
; 633  : 	// let everything in the world think and move
; 634  : 	if( !SV_RunGameFrame ()) return;

	call	_SV_RunGameFrame
	test	eax, eax
	jne	SHORT $LN6@Host_Serve
	jmp	SHORT $LN1@Host_Serve
$LN6@Host_Serve:

; 635  : 		
; 636  : 	// send messages back to the clients that had packets read this frame
; 637  : 	SV_SendClientMessages ();

	call	_SV_SendClientMessages

; 638  : 
; 639  : 	// clear edict flags for next frame
; 640  : 	SV_PrepWorldFrame ();

	call	_SV_PrepWorldFrame

; 641  : 
; 642  : 	// send a heartbeat to the master if needed
; 643  : 	Master_Heartbeat ();

	call	_Master_Heartbeat
$LN1@Host_Serve:

; 644  : }

	pop	ebp
	ret	0
_Host_ServerFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_finalmsg$ = 8						; size = 4
_SV_Shutdown PROC

; 968  : {

	push	ebp
	mov	ebp, esp

; 969  : 	// already freed
; 970  : 	if( !SV_Initialized( ))

	call	_SV_Initialized
	test	eax, eax
	jne	SHORT $LN2@SV_Shutdow

; 971  : 	{
; 972  : 		// drop the client if want to load a new map
; 973  : 		if( CL_IsPlaybackDemo( ))

	call	_CL_IsPlaybackDemo
	test	eax, eax
	je	SHORT $LN3@SV_Shutdow

; 974  : 			CL_Drop();

	call	_CL_Drop
$LN3@SV_Shutdow:

; 975  : 		return;

	jmp	$LN1@SV_Shutdow
$LN2@SV_Shutdow:

; 976  : 	}
; 977  : 
; 978  : 	if( COM_CheckString( finalmsg ))

	mov	eax, DWORD PTR _finalmsg$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@SV_Shutdow

; 979  : 		Con_Printf( "%s", finalmsg );

	mov	ecx, DWORD PTR _finalmsg$[ebp]
	push	ecx
	push	OFFSET $SG137033
	call	_Con_Printf
	add	esp, 8
$LN4@SV_Shutdow:

; 980  : 
; 981  : 	// rcon will be disconnected
; 982  : 	SV_EndRedirect();

	call	_SV_EndRedirect

; 983  : 
; 984  : 	if( svs.clients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN5@SV_Shutdow

; 985  : 		SV_FinalMessage( finalmsg, false );

	push	0
	mov	edx, DWORD PTR _finalmsg$[ebp]
	push	edx
	call	_SV_FinalMessage
	add	esp, 8
$LN5@SV_Shutdow:

; 986  : 
; 987  : 	if( public_server->value && svs.maxclients != 1 )

	mov	eax, DWORD PTR _public_server
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@SV_Shutdow
	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN6@SV_Shutdow

; 988  : 		Master_Shutdown();

	call	_Master_Shutdown
$LN6@SV_Shutdow:

; 989  : 
; 990  : 	NET_Config( false );

	push	0
	call	_NET_Config
	add	esp, 4

; 991  : 	SV_UnloadProgs ();

	call	_SV_UnloadProgs

; 992  : 	CL_Drop();

	call	_CL_Drop

; 993  : 
; 994  : 	// free current level
; 995  : 	memset( &sv, 0, sizeof( sv ));

	push	1359704					; 0014bf58H
	push	0
	push	OFFSET _sv
	call	_memset
	add	esp, 12					; 0000000cH

; 996  : 
; 997  : 	SV_FreeClients();

	call	_SV_FreeClients

; 998  : 	svs.maxclients = 0;

	mov	DWORD PTR _svs+16, 0

; 999  : 
; 1000 : 	// release all models
; 1001 : 	Mod_FreeAll();

	call	_Mod_FreeAll

; 1002 : 
; 1003 : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 1004 : 	Log_Printf( "Server shutdown\n" );

	push	OFFSET $SG137036
	call	_Log_Printf
	add	esp, 4

; 1005 : 	Log_Close();

	call	_Log_Close

; 1006 : 
; 1007 : 	svs.initialized = false;

	mov	DWORD PTR _svs, 0
$LN1@SV_Shutdow:

; 1008 : }

	pop	ebp
	ret	0
_SV_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_main.c
_TEXT	SEGMENT
_versionString$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_SV_Init PROC

; 777  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 778  : 	string	versionString;
; 779  : 
; 780  : 	SV_InitHostCommands();

	call	_SV_InitHostCommands

; 781  : 
; 782  : 	Cvar_Get ("protocol", va( "%i", PROTOCOL_VERSION ), FCVAR_READ_ONLY, "displays server protocol version" );

	push	OFFSET $SG136920
	push	131072					; 00020000H
	push	49					; 00000031H
	push	OFFSET $SG136921
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136922
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 783  : 	Cvar_Get ("suitvolume", "0.25", FCVAR_ARCHIVE, "HEV suit volume" );

	push	OFFSET $SG136923
	push	1
	push	OFFSET $SG136924
	push	OFFSET $SG136925
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 784  : 	Cvar_Get ("sv_background", "0", FCVAR_READ_ONLY, "indicate what background map is running" );

	push	OFFSET $SG136926
	push	131072					; 00020000H
	push	OFFSET $SG136927
	push	OFFSET $SG136928
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 785  : 	Cvar_Get( "gamedir", GI->gamefolder, FCVAR_SERVER, "game folder" );

	push	OFFSET $SG136929
	push	4
	mov	eax, DWORD PTR _SI+768
	push	eax
	push	OFFSET $SG136930
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 786  : 	Cvar_Get( "sv_alltalk", "1", 0, "allow to talking for all players (legacy, unused)" );

	push	OFFSET $SG136931
	push	0
	push	OFFSET $SG136932
	push	OFFSET $SG136933
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 787  : 	Cvar_Get( "sv_allow_PhysX", "1", FCVAR_ARCHIVE, "allow XashXT to usage PhysX engine" );			// XashXT cvar

	push	OFFSET $SG136934
	push	1
	push	OFFSET $SG136935
	push	OFFSET $SG136936
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 788  : 	Cvar_Get( "sv_precache_meshes", "1", FCVAR_ARCHIVE, "cache SOLID_CUSTOM meshes before level loading" );	// Paranoia 2 cvar

	push	OFFSET $SG136937
	push	1
	push	OFFSET $SG136938
	push	OFFSET $SG136939
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 789  : 	Cvar_Get ("mapcyclefile", "mapcycle.txt", 0, "name of config file for map changing rules" );

	push	OFFSET $SG136940
	push	0
	push	OFFSET $SG136941
	push	OFFSET $SG136942
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 790  : 	Cvar_Get ("servercfgfile","server.cfg", 0, "name of dedicated server configuration file" );

	push	OFFSET $SG136943
	push	0
	push	OFFSET $SG136944
	push	OFFSET $SG136945
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 791  : 	Cvar_Get ("lservercfgfile","listenserver.cfg", 0, "name of listen server configuration file" );

	push	OFFSET $SG136946
	push	0
	push	OFFSET $SG136947
	push	OFFSET $SG136948
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 792  : 	Cvar_Get ("logsdir","logs", 0, "default folder to write server logs" );

	push	OFFSET $SG136949
	push	0
	push	OFFSET $SG136950
	push	OFFSET $SG136951
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 793  : 
; 794  : 	Cvar_RegisterVariable (&sv_zmax);

	push	OFFSET _sv_zmax
	call	_Cvar_RegisterVariable
	add	esp, 4

; 795  : 	Cvar_RegisterVariable (&sv_wateramp);

	push	OFFSET _sv_wateramp
	call	_Cvar_RegisterVariable
	add	esp, 4

; 796  : 	Cvar_RegisterVariable (&sv_skycolor_r);

	push	OFFSET _sv_skycolor_r
	call	_Cvar_RegisterVariable
	add	esp, 4

; 797  : 	Cvar_RegisterVariable (&sv_skycolor_g);

	push	OFFSET _sv_skycolor_g
	call	_Cvar_RegisterVariable
	add	esp, 4

; 798  : 	Cvar_RegisterVariable (&sv_skycolor_b);

	push	OFFSET _sv_skycolor_b
	call	_Cvar_RegisterVariable
	add	esp, 4

; 799  : 	Cvar_RegisterVariable (&sv_skyvec_x);

	push	OFFSET _sv_skyvec_x
	call	_Cvar_RegisterVariable
	add	esp, 4

; 800  : 	Cvar_RegisterVariable (&sv_skyvec_y);

	push	OFFSET _sv_skyvec_y
	call	_Cvar_RegisterVariable
	add	esp, 4

; 801  : 	Cvar_RegisterVariable (&sv_skyvec_z);

	push	OFFSET _sv_skyvec_z
	call	_Cvar_RegisterVariable
	add	esp, 4

; 802  : 	Cvar_RegisterVariable (&sv_skyname);

	push	OFFSET _sv_skyname
	call	_Cvar_RegisterVariable
	add	esp, 4

; 803  : 	Cvar_RegisterVariable (&sv_footsteps);

	push	OFFSET _sv_footsteps
	call	_Cvar_RegisterVariable
	add	esp, 4

; 804  : 	Cvar_RegisterVariable (&sv_wateralpha);

	push	OFFSET _sv_wateralpha
	call	_Cvar_RegisterVariable
	add	esp, 4

; 805  : 	Cvar_RegisterVariable (&sv_cheats);

	push	OFFSET _sv_cheats
	call	_Cvar_RegisterVariable
	add	esp, 4

; 806  : 	Cvar_RegisterVariable (&sv_airmove);

	push	OFFSET _sv_airmove
	call	_Cvar_RegisterVariable
	add	esp, 4

; 807  : 	Cvar_RegisterVariable (&sv_fps);

	push	OFFSET _sv_fps
	call	_Cvar_RegisterVariable
	add	esp, 4

; 808  : 	Cvar_RegisterVariable (&showtriggers);

	push	OFFSET _showtriggers
	call	_Cvar_RegisterVariable
	add	esp, 4

; 809  : 	Cvar_RegisterVariable (&sv_aim);

	push	OFFSET _sv_aim
	call	_Cvar_RegisterVariable
	add	esp, 4

; 810  : 	Cvar_RegisterVariable (&motdfile);

	push	OFFSET _motdfile
	call	_Cvar_RegisterVariable
	add	esp, 4

; 811  : 	Cvar_RegisterVariable (&deathmatch);

	push	OFFSET _deathmatch
	call	_Cvar_RegisterVariable
	add	esp, 4

; 812  : 	Cvar_RegisterVariable (&coop);

	push	OFFSET _coop
	call	_Cvar_RegisterVariable
	add	esp, 4

; 813  : 	Cvar_RegisterVariable (&teamplay);

	push	OFFSET _teamplay
	call	_Cvar_RegisterVariable
	add	esp, 4

; 814  : 	Cvar_RegisterVariable (&skill);

	push	OFFSET _skill
	call	_Cvar_RegisterVariable
	add	esp, 4

; 815  : 	Cvar_RegisterVariable (&temp1);

	push	OFFSET _temp1
	call	_Cvar_RegisterVariable
	add	esp, 4

; 816  : 
; 817  : 	Cvar_RegisterVariable (&rcon_password);

	push	OFFSET _rcon_password
	call	_Cvar_RegisterVariable
	add	esp, 4

; 818  : 	Cvar_RegisterVariable (&sv_stepsize);

	push	OFFSET _sv_stepsize
	call	_Cvar_RegisterVariable
	add	esp, 4

; 819  : 	Cvar_RegisterVariable (&sv_newunit);

	push	OFFSET _sv_newunit
	call	_Cvar_RegisterVariable
	add	esp, 4

; 820  : 	Cvar_RegisterVariable (&hostname);

	push	OFFSET _hostname
	call	_Cvar_RegisterVariable
	add	esp, 4

; 821  : 	timeout = Cvar_Get( "timeout", "125", FCVAR_SERVER, "connection timeout" );

	push	OFFSET $SG136952
	push	4
	push	OFFSET $SG136953
	push	OFFSET $SG136954
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _timeout, eax

; 822  : 	sv_pausable = Cvar_Get( "pausable", "1", FCVAR_SERVER, "allow players to pause or not" );

	push	OFFSET $SG136955
	push	4
	push	OFFSET $SG136956
	push	OFFSET $SG136957
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_pausable, eax

; 823  : 	sv_validate_changelevel = Cvar_Get( "sv_validate_changelevel", "1", FCVAR_ARCHIVE, "test change level for level-designer errors" );

	push	OFFSET $SG136958
	push	1
	push	OFFSET $SG136959
	push	OFFSET $SG136960
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_validate_changelevel, eax

; 824  : 	Cvar_RegisterVariable (&sv_clienttrace);

	push	OFFSET _sv_clienttrace
	call	_Cvar_RegisterVariable
	add	esp, 4

; 825  : 	Cvar_RegisterVariable (&sv_bounce);

	push	OFFSET _sv_bounce
	call	_Cvar_RegisterVariable
	add	esp, 4

; 826  : 	Cvar_RegisterVariable (&sv_spectatormaxspeed);

	push	OFFSET _sv_spectatormaxspeed
	call	_Cvar_RegisterVariable
	add	esp, 4

; 827  : 	Cvar_RegisterVariable (&sv_waterfriction);

	push	OFFSET _sv_waterfriction
	call	_Cvar_RegisterVariable
	add	esp, 4

; 828  : 	Cvar_RegisterVariable (&sv_wateraccelerate);

	push	OFFSET _sv_wateraccelerate
	call	_Cvar_RegisterVariable
	add	esp, 4

; 829  : 	Cvar_RegisterVariable (&sv_rollangle);

	push	OFFSET _sv_rollangle
	call	_Cvar_RegisterVariable
	add	esp, 4

; 830  : 	Cvar_RegisterVariable (&sv_rollspeed);

	push	OFFSET _sv_rollspeed
	call	_Cvar_RegisterVariable
	add	esp, 4

; 831  : 	Cvar_RegisterVariable (&sv_airaccelerate);

	push	OFFSET _sv_airaccelerate
	call	_Cvar_RegisterVariable
	add	esp, 4

; 832  : 	Cvar_RegisterVariable (&sv_maxvelocity);

	push	OFFSET _sv_maxvelocity
	call	_Cvar_RegisterVariable
	add	esp, 4

; 833  :  	Cvar_RegisterVariable (&sv_gravity);

	push	OFFSET _sv_gravity
	call	_Cvar_RegisterVariable
	add	esp, 4

; 834  : 	Cvar_RegisterVariable (&sv_maxspeed);

	push	OFFSET _sv_maxspeed
	call	_Cvar_RegisterVariable
	add	esp, 4

; 835  : 	Cvar_RegisterVariable (&sv_accelerate);

	push	OFFSET _sv_accelerate
	call	_Cvar_RegisterVariable
	add	esp, 4

; 836  : 	Cvar_RegisterVariable (&sv_friction);

	push	OFFSET _sv_friction
	call	_Cvar_RegisterVariable
	add	esp, 4

; 837  : 	Cvar_RegisterVariable (&sv_edgefriction);

	push	OFFSET _sv_edgefriction
	call	_Cvar_RegisterVariable
	add	esp, 4

; 838  : 	Cvar_RegisterVariable (&sv_stopspeed);

	push	OFFSET _sv_stopspeed
	call	_Cvar_RegisterVariable
	add	esp, 4

; 839  : 	sv_maxclients = Cvar_Get( "maxplayers", "1", FCVAR_LATCH, "server max capacity" );

	push	OFFSET $SG136961
	push	2048					; 00000800H
	push	OFFSET $SG136962
	push	OFFSET $SG136963
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_maxclients, eax

; 840  : 	sv_check_errors = Cvar_Get( "sv_check_errors", "0", FCVAR_ARCHIVE, "check edicts for errors" );

	push	OFFSET $SG136964
	push	1
	push	OFFSET $SG136965
	push	OFFSET $SG136966
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_check_errors, eax

; 841  : 	public_server = Cvar_Get ("public", "0", 0, "change server type from private to public" );

	push	OFFSET $SG136967
	push	0
	push	OFFSET $SG136968
	push	OFFSET $SG136969
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _public_server, eax

; 842  : 	sv_lighting_modulate = Cvar_Get( "r_lighting_modulate", "0.6", FCVAR_ARCHIVE, "lightstyles modulate scale" );

	push	OFFSET $SG136970
	push	1
	push	OFFSET $SG136971
	push	OFFSET $SG136972
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_lighting_modulate, eax

; 843  : 	sv_reconnect_limit = Cvar_Get ("sv_reconnect_limit", "3", FCVAR_ARCHIVE, "max reconnect attempts" );

	push	OFFSET $SG136973
	push	1
	push	OFFSET $SG136974
	push	OFFSET $SG136975
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_reconnect_limit, eax

; 844  : 	Cvar_RegisterVariable (&sv_failuretime );

	push	OFFSET _sv_failuretime
	call	_Cvar_RegisterVariable
	add	esp, 4

; 845  : 	Cvar_RegisterVariable (&sv_unlag);

	push	OFFSET _sv_unlag
	call	_Cvar_RegisterVariable
	add	esp, 4

; 846  : 	Cvar_RegisterVariable (&sv_maxunlag);

	push	OFFSET _sv_maxunlag
	call	_Cvar_RegisterVariable
	add	esp, 4

; 847  : 	Cvar_RegisterVariable (&sv_unlagpush);

	push	OFFSET _sv_unlagpush
	call	_Cvar_RegisterVariable
	add	esp, 4

; 848  : 	Cvar_RegisterVariable (&sv_unlagsamples);

	push	OFFSET _sv_unlagsamples
	call	_Cvar_RegisterVariable
	add	esp, 4

; 849  : 	Cvar_RegisterVariable (&sv_allow_upload);

	push	OFFSET _sv_allow_upload
	call	_Cvar_RegisterVariable
	add	esp, 4

; 850  : 	Cvar_RegisterVariable (&sv_allow_download);

	push	OFFSET _sv_allow_download
	call	_Cvar_RegisterVariable
	add	esp, 4

; 851  : 	Cvar_RegisterVariable (&sv_send_logos);

	push	OFFSET _sv_send_logos
	call	_Cvar_RegisterVariable
	add	esp, 4

; 852  : 	Cvar_RegisterVariable (&sv_send_resources);

	push	OFFSET _sv_send_resources
	call	_Cvar_RegisterVariable
	add	esp, 4

; 853  : 	Cvar_RegisterVariable (&sv_uploadmax);

	push	OFFSET _sv_uploadmax
	call	_Cvar_RegisterVariable
	add	esp, 4

; 854  : 	Cvar_RegisterVariable (&sv_version);

	push	OFFSET _sv_version
	call	_Cvar_RegisterVariable
	add	esp, 4

; 855  : 	Cvar_RegisterVariable (&sv_instancedbaseline);

	push	OFFSET _sv_instancedbaseline
	call	_Cvar_RegisterVariable
	add	esp, 4

; 856  : 	Cvar_RegisterVariable (&sv_consistency);

	push	OFFSET _sv_consistency
	call	_Cvar_RegisterVariable
	add	esp, 4

; 857  : 	Cvar_RegisterVariable (&sv_downloadurl);

	push	OFFSET _sv_downloadurl
	call	_Cvar_RegisterVariable
	add	esp, 4

; 858  : 	sv_novis = Cvar_Get( "sv_novis", "0", 0, "force to ignore server visibility" );

	push	OFFSET $SG136976
	push	0
	push	OFFSET $SG136977
	push	OFFSET $SG136978
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_novis, eax

; 859  : 	sv_hostmap = Cvar_Get( "hostmap", GI->startmap, 0, "keep name of last entered map" );

	push	OFFSET $SG136979
	push	0
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 256				; 00000100H
	push	ecx
	push	OFFSET $SG136980
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sv_hostmap, eax

; 860  : 	Cvar_RegisterVariable (&sv_password);

	push	OFFSET _sv_password
	call	_Cvar_RegisterVariable
	add	esp, 4

; 861  : 	Cvar_RegisterVariable (&sv_lan);

	push	OFFSET _sv_lan
	call	_Cvar_RegisterVariable
	add	esp, 4

; 862  : 	Cvar_RegisterVariable (&violence_ablood);

	push	OFFSET _violence_ablood
	call	_Cvar_RegisterVariable
	add	esp, 4

; 863  : 	Cvar_RegisterVariable (&violence_hblood);

	push	OFFSET _violence_hblood
	call	_Cvar_RegisterVariable
	add	esp, 4

; 864  : 	Cvar_RegisterVariable (&violence_agibs);

	push	OFFSET _violence_agibs
	call	_Cvar_RegisterVariable
	add	esp, 4

; 865  : 	Cvar_RegisterVariable (&violence_hgibs);

	push	OFFSET _violence_hgibs
	call	_Cvar_RegisterVariable
	add	esp, 4

; 866  : 	Cvar_RegisterVariable (&mp_logecho);

	push	OFFSET _mp_logecho
	call	_Cvar_RegisterVariable
	add	esp, 4

; 867  : 	Cvar_RegisterVariable (&mp_logfile);

	push	OFFSET _mp_logfile
	call	_Cvar_RegisterVariable
	add	esp, 4

; 868  : 	Cvar_RegisterVariable (&sv_background_freeze);

	push	OFFSET _sv_background_freeze
	call	_Cvar_RegisterVariable
	add	esp, 4

; 869  : 
; 870  : 	// when we in developer-mode automatically turn cheats on
; 871  : 	if( host_developer.value ) Cvar_SetValue( "sv_cheats", 1.0f );

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_Init
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136982
	call	_Cvar_SetValue
	add	esp, 8
$LN2@SV_Init:

; 872  : 
; 873  : 	MSG_Init( &net_message, "NetMessage", net_message_buffer, sizeof( net_message_buffer ));

	push	-1
	push	131120					; 00020030H
	push	OFFSET _net_message_buffer
	push	OFFSET $SG136983
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 874  : 
; 875  : 	Q_snprintf( versionString, sizeof( versionString ), "%s: %s,%i,%i", "Xash3D", XASH_VERSION, PROTOCOL_VERSION, Q_buildnum() );

	call	_Q_buildnum
	push	eax
	push	49					; 00000031H
	push	OFFSET $SG136984
	push	OFFSET $SG136985
	push	OFFSET $SG136986
	push	256					; 00000100H
	lea	edx, DWORD PTR _versionString$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 876  : 	Cvar_FullSet( "sv_version", versionString, FCVAR_READ_ONLY );

	push	131072					; 00020000H
	lea	eax, DWORD PTR _versionString$[ebp]
	push	eax
	push	OFFSET $SG136987
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 877  : 
; 878  : 	SV_ClearGameState ();	// delete all temporary *.hl files

	call	_SV_ClearGameState

; 879  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Init ENDP
_TEXT	ENDS
END
