; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\titles.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_gMessageParms:BYTE:02cH
_DATA	ENDS
PUBLIC	_CL_TextMessageParse
EXTRN	_memcpy:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_COM_MemFgets:PROC
EXTRN	_COM_TrimSpace:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
$SG138383 DB	'position', 00H
	ORG $+3
$SG138387 DB	'effect', 00H
	ORG $+1
$SG138391 DB	'fxtime', 00H
	ORG $+1
$SG138395 DB	'color2', 00H
	ORG $+1
$SG138399 DB	'color', 00H
	ORG $+2
$SG138403 DB	'fadein', 00H
	ORG $+1
$SG138407 DB	'fadeout', 00H
$SG138411 DB	'holdtime', 00H
	ORG $+3
$SG138413 DB	'^1Error:^7 unknown token: %s', 0aH, 00H
	ORG $+2
$SG138461 DB	'TextMessage: unexpected ''}'' found, line %d', 0aH, 00H
$SG138465 DB	'TextMessage: error while parsing!', 0aH, 00H
	ORG $+1
$SG138467 DB	'TextMessage: unexpected ''{'' found, line %d', 0aH, 00H
$SG138469 DB	'^3Warning:^7 Too many messages in titles.txt, max is %d', 0aH
	DB	00H
	ORG $+3
$SG138470 DB	'TextMessage: parsed %d text messages', 0aH, 00H
	ORG $+2
$SG138472 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\titles.c', 00H
	ORG $+2
$SG138474 DB	'^1Error:^7 TextMessage: overflow text message buffer!', 0aH
	DB	00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_tempFloat$1 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_pText$ = 8						; size = 4
_ParseDirective PROC

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 137  : 	if( pText && pText[0] == '$' )

	cmp	DWORD PTR _pText$[ebp], 0
	je	$LN2@ParseDirec
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 36					; 00000024H
	jne	$LN2@ParseDirec

; 138  : 	{
; 139  : 		float	tempFloat[8];
; 140  : 
; 141  : 		if( IsToken( pText, "position" ))

	push	OFFSET $SG138383
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@ParseDirec

; 142  : 		{
; 143  : 			if( ParseFloats( pText, tempFloat, 2 ))

	push	2
	lea	edx, DWORD PTR _tempFloat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@ParseDirec

; 144  : 			{
; 145  : 				gMessageParms.x = tempFloat[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+edx]
	movss	DWORD PTR _gMessageParms+12, xmm0

; 146  : 				gMessageParms.y = tempFloat[1];

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+eax]
	movss	DWORD PTR _gMessageParms+16, xmm0
$LN5@ParseDirec:

; 147  : 			}
; 148  : 		}

	jmp	$LN25@ParseDirec
$LN3@ParseDirec:

; 149  : 		else if( IsToken( pText, "effect" ))

	push	OFFSET $SG138387
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ParseDirec

; 150  : 		{
; 151  : 			if( ParseFloats( pText, tempFloat, 1 ))

	push	1
	lea	edx, DWORD PTR _tempFloat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@ParseDirec

; 152  : 			{
; 153  : 				gMessageParms.effect = (int)tempFloat[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	cvttss2si eax, DWORD PTR _tempFloat$1[ebp+edx]
	mov	DWORD PTR _gMessageParms, eax
$LN8@ParseDirec:

; 154  : 			}
; 155  : 		}

	jmp	$LN25@ParseDirec
$LN6@ParseDirec:

; 156  : 		else if( IsToken( pText, "fxtime" ))

	push	OFFSET $SG138391
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@ParseDirec

; 157  : 		{
; 158  : 			if( ParseFloats( pText, tempFloat, 1 ))

	push	1
	lea	edx, DWORD PTR _tempFloat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@ParseDirec

; 159  : 			{
; 160  : 				gMessageParms.fxtime = tempFloat[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+edx]
	movss	DWORD PTR _gMessageParms+32, xmm0
$LN11@ParseDirec:

; 161  : 			}
; 162  : 		}

	jmp	$LN25@ParseDirec
$LN9@ParseDirec:

; 163  : 		else if( IsToken( pText, "color2" ))

	push	OFFSET $SG138395
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@ParseDirec

; 164  : 		{
; 165  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	ecx, DWORD PTR _tempFloat$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pText$[ebp]
	push	edx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@ParseDirec

; 166  : 			{
; 167  : 				gMessageParms.r2 = (int)tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	cvttss2si edx, DWORD PTR _tempFloat$1[ebp+ecx]
	mov	BYTE PTR _gMessageParms+8, dl

; 168  : 				gMessageParms.g2 = (int)tempFloat[1];

	mov	eax, 4
	shl	eax, 0
	cvttss2si ecx, DWORD PTR _tempFloat$1[ebp+eax]
	mov	BYTE PTR _gMessageParms+9, cl

; 169  : 				gMessageParms.b2 = (int)tempFloat[2];

	mov	edx, 4
	shl	edx, 1
	cvttss2si eax, DWORD PTR _tempFloat$1[ebp+edx]
	mov	BYTE PTR _gMessageParms+10, al
$LN14@ParseDirec:

; 170  : 			}
; 171  : 		}

	jmp	$LN25@ParseDirec
$LN12@ParseDirec:

; 172  : 		else if( IsToken( pText, "color" ))

	push	OFFSET $SG138399
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@ParseDirec

; 173  : 		{
; 174  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	edx, DWORD PTR _tempFloat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@ParseDirec

; 175  : 			{
; 176  : 				gMessageParms.r1 = (int)tempFloat[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	cvttss2si eax, DWORD PTR _tempFloat$1[ebp+edx]
	mov	BYTE PTR _gMessageParms+4, al

; 177  : 				gMessageParms.g1 = (int)tempFloat[1];

	mov	ecx, 4
	shl	ecx, 0
	cvttss2si edx, DWORD PTR _tempFloat$1[ebp+ecx]
	mov	BYTE PTR _gMessageParms+5, dl

; 178  : 				gMessageParms.b1 = (int)tempFloat[2];

	mov	eax, 4
	shl	eax, 1
	cvttss2si ecx, DWORD PTR _tempFloat$1[ebp+eax]
	mov	BYTE PTR _gMessageParms+6, cl
$LN17@ParseDirec:

; 179  : 			}
; 180  : 		}

	jmp	$LN25@ParseDirec
$LN15@ParseDirec:

; 181  : 		else if( IsToken( pText, "fadein" ))

	push	OFFSET $SG138403
	mov	edx, DWORD PTR _pText$[ebp]
	push	edx
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@ParseDirec

; 182  : 		{
; 183  : 			if( ParseFloats( pText, tempFloat, 1 ))

	push	1
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@ParseDirec

; 184  : 			{
; 185  : 				gMessageParms.fadein = tempFloat[0];

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+eax]
	movss	DWORD PTR _gMessageParms+20, xmm0
$LN20@ParseDirec:

; 186  : 			}
; 187  : 		}

	jmp	$LN25@ParseDirec
$LN18@ParseDirec:

; 188  : 		else if( IsToken( pText, "fadeout" ))

	push	OFFSET $SG138407
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@ParseDirec

; 189  : 		{
; 190  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	edx, DWORD PTR _tempFloat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@ParseDirec

; 191  : 			{
; 192  : 				gMessageParms.fadeout = tempFloat[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+edx]
	movss	DWORD PTR _gMessageParms+24, xmm0
$LN23@ParseDirec:

; 193  : 			}
; 194  : 		}

	jmp	SHORT $LN25@ParseDirec
$LN21@ParseDirec:

; 195  : 		else if( IsToken( pText, "holdtime" ))

	push	OFFSET $SG138411
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@ParseDirec

; 196  : 		{
; 197  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	ecx, DWORD PTR _tempFloat$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pText$[ebp]
	push	edx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@ParseDirec

; 198  : 			{
; 199  : 				gMessageParms.holdtime = tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+ecx]
	movss	DWORD PTR _gMessageParms+28, xmm0
$LN26@ParseDirec:

; 200  : 			}
; 201  : 		}

	jmp	SHORT $LN25@ParseDirec
$LN24@ParseDirec:

; 202  : 		else
; 203  : 		{
; 204  : 			Con_DPrintf( S_ERROR "unknown token: %s\n", pText );

	mov	edx, DWORD PTR _pText$[ebp]
	push	edx
	push	OFFSET $SG138413
	call	_Con_DPrintf
	add	esp, 8
$LN25@ParseDirec:

; 205  : 		}
; 206  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ParseDirec
$LN2@ParseDirec:

; 207  : 	}
; 208  : 	return 0;

	xor	eax, eax
$LN1@ParseDirec:

; 209  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_pTokenName$ = 12					; size = 4
_IsToken PROC

; 125  : {

	push	ebp
	mov	ebp, esp

; 126  : 	if( !pText || !pTokenName )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN3@IsToken
	cmp	DWORD PTR _pTokenName$[ebp], 0
	jne	SHORT $LN2@IsToken
$LN3@IsToken:

; 127  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsToken
$LN2@IsToken:

; 128  : 
; 129  : 	if( !Q_strnicmp( pText+1, pTokenName, Q_strlen( pTokenName )))

	mov	eax, DWORD PTR _pTokenName$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pTokenName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pText$[ebp]
	add	edx, 1
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@IsToken

; 130  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsToken
$LN4@IsToken:

; 131  : 
; 132  : 	return 0;

	xor	eax, eax
$LN1@IsToken:

; 133  : }

	pop	ebp
	ret	0
_IsToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_index$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pText$ = 8						; size = 4
_pFloat$ = 12						; size = 4
_count$ = 16						; size = 4
_ParseFloats PROC

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 100  : 	const char *pTemp = pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _pTemp$[ebp], eax

; 101  : 	int index = 0;

	mov	DWORD PTR _index$[ebp], 0
$LN2@ParseFloat:

; 102  : 
; 103  : 	while( pTemp && count > 0 )

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN3@ParseFloat
	cmp	DWORD PTR _count$[ebp], 0
	jle	SHORT $LN3@ParseFloat

; 104  : 	{
; 105  : 		// skip current token / float
; 106  : 		pTemp = SkipText( pTemp );

	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_SkipText
	add	esp, 4
	mov	DWORD PTR _pTemp$[ebp], eax

; 107  : 		// skip any whitespace in between
; 108  : 		pTemp = SkipSpace( pTemp );

	mov	edx, DWORD PTR _pTemp$[ebp]
	push	edx
	call	_SkipSpace
	add	esp, 4
	mov	DWORD PTR _pTemp$[ebp], eax

; 109  : 
; 110  : 		if( pTemp )

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN4@ParseFloat

; 111  : 		{
; 112  : 			// parse a float
; 113  : 			pFloat[index] = Q_atof( pTemp );

	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _pFloat$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 114  : 			count--;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 115  : 			index++;

	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
$LN4@ParseFloat:

; 116  : 		}
; 117  : 	}

	jmp	SHORT $LN2@ParseFloat
$LN3@ParseFloat:

; 118  : 
; 119  : 	if( count == 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN5@ParseFloat

; 120  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ParseFloat
$LN5@ParseFloat:

; 121  : 	return 0;

	xor	eax, eax
$LN1@ParseFloat:

; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ParseFloats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_pos$1 = -4						; size = 4
_pText$ = 8						; size = 4
_SkipText PROC

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 88   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN4@SkipText

; 89   : 	{
; 90   : 		int pos = 0;

	mov	DWORD PTR _pos$1[ebp], 0
$LN2@SkipText:

; 91   : 		while( pText[pos] && !IsWhiteSpace( pText[pos] ))

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@SkipText
	mov	edx, DWORD PTR _pText$[ebp]
	add	edx, DWORD PTR _pos$1[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@SkipText

; 92   : 			pos++;

	mov	ecx, DWORD PTR _pos$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos$1[ebp], ecx
	jmp	SHORT $LN2@SkipText
$LN3@SkipText:

; 93   : 		return pText + pos;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	jmp	SHORT $LN1@SkipText
$LN4@SkipText:

; 94   : 	}
; 95   : 	return NULL;

	xor	eax, eax
$LN1@SkipText:

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SkipText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_pos$1 = -4						; size = 4
_pText$ = 8						; size = 4
_SkipSpace PROC

; 75   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 76   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN4@SkipSpace

; 77   : 	{
; 78   : 		int pos = 0;

	mov	DWORD PTR _pos$1[ebp], 0
$LN2@SkipSpace:

; 79   : 		while( pText[pos] && IsWhiteSpace( pText[pos] ))

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@SkipSpace
	mov	edx, DWORD PTR _pText$[ebp]
	add	edx, DWORD PTR _pos$1[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SkipSpace

; 80   : 			pos++;

	mov	ecx, DWORD PTR _pos$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos$1[ebp], ecx
	jmp	SHORT $LN2@SkipSpace
$LN3@SkipSpace:

; 81   : 		return pText + pos;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	jmp	SHORT $LN1@SkipSpace
$LN4@SkipSpace:

; 82   : 	}
; 83   : 	return NULL;

	xor	eax, eax
$LN1@SkipSpace:

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_space$ = 8						; size = 1
_IsWhiteSpace PROC

; 68   : {

	push	ebp
	mov	ebp, esp

; 69   : 	if( space == ' ' || space == '\t' || space == '\r' || space == '\n' )

	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@IsWhiteSpa
	movsx	ecx, BYTE PTR _space$[ebp]
	cmp	ecx, 9
	je	SHORT $LN3@IsWhiteSpa
	movsx	edx, BYTE PTR _space$[ebp]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@IsWhiteSpa
$LN3@IsWhiteSpa:

; 70   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsWhiteSpa
$LN2@IsWhiteSpa:

; 71   : 	return 0;

	xor	eax, eax
$LN1@IsWhiteSpa:

; 72   : }

	pop	ebp
	ret	0
_IsWhiteSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_IsEndOfText PROC

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN2@IsEndOfTex

; 60   : 	{
; 61   : 		if( pText[0] == '}' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN2@IsEndOfTex

; 62   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsEndOfTex
$LN2@IsEndOfTex:

; 63   : 	}
; 64   : 	return 0;

	xor	eax, eax
$LN1@IsEndOfTex:

; 65   : }

	pop	ebp
	ret	0
_IsEndOfText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_IsStartOfText PROC

; 47   : {

	push	ebp
	mov	ebp, esp

; 48   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN2@IsStartOfT

; 49   : 	{
; 50   : 		if( pText[0] == '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN2@IsStartOfT

; 51   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsStartOfT
$LN2@IsStartOfT:

; 52   : 	}
; 53   : 	return 0;

	xor	eax, eax
$LN1@IsStartOfT:

; 54   : }

	pop	ebp
	ret	0
_IsStartOfText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_length$1 = -4						; size = 4
_pText$ = 8						; size = 4
_IsComment PROC

; 28   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 29   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN2@IsComment

; 30   : 	{
; 31   : 		int length = Q_strlen( pText );

	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _length$1[ebp], eax

; 32   : 
; 33   : 		if( length >= 2 && pText[0] == '/' && pText[1] == '/' )

	cmp	DWORD PTR _length$1[ebp], 2
	jl	SHORT $LN3@IsComment
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN3@IsComment
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN3@IsComment

; 34   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsComment
$LN3@IsComment:

; 35   : 		
; 36   : 		// no text?
; 37   : 		if( length > 0 )

	cmp	DWORD PTR _length$1[ebp], 0
	jle	SHORT $LN2@IsComment

; 38   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsComment
$LN2@IsComment:

; 39   : 	}
; 40   : 
; 41   : 	// no text is a comment too
; 42   : 	return 1;

	mov	eax, 1
$LN1@IsComment:

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_IsComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\titles.c
_TEXT	SEGMENT
_nameOffset$ = -124480					; size = 4
_length$1 = -124476					; size = 4
_lastLinePos$ = -124472					; size = 4
tv73 = -124468						; size = 4
_pNameHeap$ = -124464					; size = 4
_filePos$ = -124460					; size = 4
_mode$ = -124456					; size = 4
_lineNumber$ = -124452					; size = 4
_messageSize$ = -124448					; size = 4
_nameHeapSize$ = -124444				; size = 4
_textHeapSize$ = -124440				; size = 4
_lastNamePos$ = -124436					; size = 4
_pCurrentText$ = -124432				; size = 4
_messageCount$ = -124428				; size = 4
_i$ = -124424						; size = 4
_textMessages$ = -124420				; size = 90112
_nameHeap$ = -34308					; size = 32768
_buf$ = -1540						; size = 512
_currentName$ = -1028					; size = 512
_trim$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_pMemFile$ = 8						; size = 4
_fileSize$ = 12						; size = 4
_CL_TextMessageParse PROC

; 212  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 124480				; 0001e640H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 213  : 	char			buf[512], trim[512], currentName[512];
; 214  : 	char			*pCurrentText = NULL, *pNameHeap;

	mov	DWORD PTR _pCurrentText$[ebp], 0

; 215  : 	char			nameHeap[32768]; // g-cont. i will scale up heap to handle all TFC messages
; 216  : 	int			mode = MSGFILE_NAME; // searching for a message name	

	mov	DWORD PTR _mode$[ebp], 0

; 217  : 	int			lineNumber, filePos, lastLinePos;
; 218  : 	client_textmessage_t	textMessages[MAX_MESSAGES];
; 219  : 	int			i, nameHeapSize, textHeapSize, messageSize, nameOffset;
; 220  : 	int			messageCount, lastNamePos;
; 221  : 
; 222  : 	lastNamePos = 0;

	mov	DWORD PTR _lastNamePos$[ebp], 0

; 223  : 	lineNumber = 0;

	mov	DWORD PTR _lineNumber$[ebp], 0

; 224  : 	filePos = 0;

	mov	DWORD PTR _filePos$[ebp], 0

; 225  : 	lastLinePos = 0;

	mov	DWORD PTR _lastLinePos$[ebp], 0

; 226  : 	messageCount = 0;

	mov	DWORD PTR _messageCount$[ebp], 0
$LN2@CL_TextMes:

; 227  : 
; 228  : 	while( COM_MemFgets( pMemFile, fileSize, &filePos, buf, 512 ) != NULL )

	push	512					; 00000200H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filePos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMemFile$[ebp]
	push	eax
	call	_COM_MemFgets
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN3@CL_TextMes

; 229  : 	{
; 230  : 		COM_TrimSpace( buf, trim );

	lea	ecx, DWORD PTR _trim$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_COM_TrimSpace
	add	esp, 8

; 231  : 
; 232  : 		switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN12@CL_TextMes
	cmp	DWORD PTR tv73[ebp], 1
	je	$LN17@CL_TextMes
	jmp	$LN4@CL_TextMes
$LN12@CL_TextMes:

; 233  : 		{
; 234  : 		case MSGFILE_NAME:
; 235  : 			// skip comment lines
; 236  : 			if( IsComment( trim ))

	lea	ecx, DWORD PTR _trim$[ebp]
	push	ecx
	call	_IsComment
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@CL_TextMes

; 237  : 				break;

	jmp	$LN4@CL_TextMes
$LN13@CL_TextMes:

; 238  : 
; 239  : 			// Is this a directive "$command"?, if so parse it and break
; 240  : 			if( ParseDirective( trim ))

	lea	edx, DWORD PTR _trim$[ebp]
	push	edx
	call	_ParseDirective
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@CL_TextMes

; 241  : 				break;

	jmp	$LN4@CL_TextMes
$LN14@CL_TextMes:

; 242  : 
; 243  : 			if( IsStartOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsStartOfText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@CL_TextMes

; 244  : 			{
; 245  : 				mode = MSGFILE_TEXT;

	mov	DWORD PTR _mode$[ebp], 1

; 246  : 				pCurrentText = (char*)(pMemFile + filePos);

	mov	ecx, DWORD PTR _pMemFile$[ebp]
	add	ecx, DWORD PTR _filePos$[ebp]
	mov	DWORD PTR _pCurrentText$[ebp], ecx

; 247  : 				break;

	jmp	$LN4@CL_TextMes
$LN15@CL_TextMes:

; 248  : 			}
; 249  : 
; 250  : 			if( IsEndOfText( trim ))

	lea	edx, DWORD PTR _trim$[ebp]
	push	edx
	call	_IsEndOfText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@CL_TextMes

; 251  : 			{
; 252  : 				Con_Reportf( "TextMessage: unexpected '}' found, line %d\n", lineNumber );

	mov	eax, DWORD PTR _lineNumber$[ebp]
	push	eax
	push	OFFSET $SG138461
	call	_Con_Reportf
	add	esp, 8

; 253  : 				return;

	jmp	$LN1@CL_TextMes
$LN16@CL_TextMes:

; 254  : 			}
; 255  : 			Q_strcpy( currentName, trim );

	push	99999					; 0001869fH
	lea	ecx, DWORD PTR _trim$[ebp]
	push	ecx
	lea	edx, DWORD PTR _currentName$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 256  : 			break;

	jmp	$LN4@CL_TextMes
$LN17@CL_TextMes:

; 257  : 		case MSGFILE_TEXT:
; 258  : 			if( IsEndOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsEndOfText
	add	esp, 4
	test	eax, eax
	je	$LN18@CL_TextMes

; 259  : 			{
; 260  : 				int length = Q_strlen( currentName );

	lea	ecx, DWORD PTR _currentName$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _length$1[ebp], eax

; 261  : 
; 262  : 				// save name on name heap
; 263  : 				if( lastNamePos + length > 32768 )

	mov	edx, DWORD PTR _lastNamePos$[ebp]
	add	edx, DWORD PTR _length$1[ebp]
	cmp	edx, 32768				; 00008000H
	jle	SHORT $LN19@CL_TextMes

; 264  : 				{
; 265  : 					Con_Reportf( "TextMessage: error while parsing!\n" );

	push	OFFSET $SG138465
	call	_Con_Reportf
	add	esp, 4

; 266  : 					return;

	jmp	$LN1@CL_TextMes
$LN19@CL_TextMes:

; 267  : 				}
; 268  : 
; 269  : 				Q_strcpy( nameHeap + lastNamePos, currentName );

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _currentName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastNamePos$[ebp]
	lea	edx, DWORD PTR _nameHeap$[ebp+ecx]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 270  : 
; 271  : 				// terminate text in-place in the memory file
; 272  : 				// (it's temporary memory that will be deleted)
; 273  : 				pMemFile[lastLinePos-1] = 0;

	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, DWORD PTR _lastLinePos$[ebp]
	mov	BYTE PTR [eax-1], 0

; 274  : 
; 275  : 				// Save name/text on heap
; 276  : 				textMessages[messageCount] = gMessageParms;

	imul	ecx, DWORD PTR _messageCount$[ebp], 44
	lea	edi, DWORD PTR _textMessages$[ebp+ecx]
	mov	ecx, 11					; 0000000bH
	mov	esi, OFFSET _gMessageParms
	rep movsd

; 277  : 				textMessages[messageCount].pName = nameHeap + lastNamePos;

	mov	edx, DWORD PTR _lastNamePos$[ebp]
	lea	eax, DWORD PTR _nameHeap$[ebp+edx]
	imul	ecx, DWORD PTR _messageCount$[ebp], 44
	mov	DWORD PTR _textMessages$[ebp+ecx+36], eax

; 278  : 				lastNamePos += Q_strlen( currentName ) + 1;

	lea	edx, DWORD PTR _currentName$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lastNamePos$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _lastNamePos$[ebp], edx

; 279  : 				textMessages[messageCount].pMessage = pCurrentText;

	imul	eax, DWORD PTR _messageCount$[ebp], 44
	mov	ecx, DWORD PTR _pCurrentText$[ebp]
	mov	DWORD PTR _textMessages$[ebp+eax+40], ecx

; 280  : 				messageCount++;

	mov	edx, DWORD PTR _messageCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _messageCount$[ebp], edx

; 281  : 
; 282  : 				// reset parser to search for names
; 283  : 				mode = MSGFILE_NAME;

	mov	DWORD PTR _mode$[ebp], 0

; 284  : 				break;

	jmp	SHORT $LN4@CL_TextMes
$LN18@CL_TextMes:

; 285  : 			}
; 286  : 			if( IsStartOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsStartOfText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@CL_TextMes

; 287  : 			{
; 288  : 				Con_Reportf( "TextMessage: unexpected '{' found, line %d\n", lineNumber );

	mov	ecx, DWORD PTR _lineNumber$[ebp]
	push	ecx
	push	OFFSET $SG138467
	call	_Con_Reportf
	add	esp, 8

; 289  : 				return;

	jmp	$LN1@CL_TextMes
$LN4@CL_TextMes:

; 290  : 			}
; 291  : 			break;
; 292  : 		}
; 293  : 
; 294  : 		lineNumber++;

	mov	edx, DWORD PTR _lineNumber$[ebp]
	add	edx, 1
	mov	DWORD PTR _lineNumber$[ebp], edx

; 295  : 		lastLinePos = filePos;

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	DWORD PTR _lastLinePos$[ebp], eax

; 296  : 
; 297  : 		if( messageCount >= MAX_MESSAGES )

	cmp	DWORD PTR _messageCount$[ebp], 2048	; 00000800H
	jl	SHORT $LN21@CL_TextMes

; 298  : 		{
; 299  : 			Con_Printf( S_WARN "Too many messages in titles.txt, max is %d\n", MAX_MESSAGES );

	push	2048					; 00000800H
	push	OFFSET $SG138469
	call	_Con_Printf
	add	esp, 8

; 300  : 			break;

	jmp	SHORT $LN3@CL_TextMes
$LN21@CL_TextMes:

; 301  : 		}
; 302  : 	}

	jmp	$LN2@CL_TextMes
$LN3@CL_TextMes:

; 303  : 
; 304  : 	Con_Reportf( "TextMessage: parsed %d text messages\n", messageCount );

	mov	ecx, DWORD PTR _messageCount$[ebp]
	push	ecx
	push	OFFSET $SG138470
	call	_Con_Reportf
	add	esp, 8

; 305  : 	nameHeapSize = lastNamePos;

	mov	edx, DWORD PTR _lastNamePos$[ebp]
	mov	DWORD PTR _nameHeapSize$[ebp], edx

; 306  : 	textHeapSize = 0;

	mov	DWORD PTR _textHeapSize$[ebp], 0

; 307  : 
; 308  : 	for( i = 0; i < messageCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@CL_TextMes
$LN6@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@CL_TextMes:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _messageCount$[ebp]
	jge	SHORT $LN7@CL_TextMes

; 309  : 		textHeapSize += Q_strlen( textMessages[i].pMessage ) + 1;

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _textMessages$[ebp+edx+40]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _textHeapSize$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _textHeapSize$[ebp], edx
	jmp	SHORT $LN6@CL_TextMes
$LN7@CL_TextMes:

; 310  : 	messageSize = ( messageCount * sizeof( client_textmessage_t ));

	imul	eax, DWORD PTR _messageCount$[ebp], 44
	mov	DWORD PTR _messageSize$[ebp], eax

; 311  : 
; 312  : 	if(( textHeapSize + nameHeapSize + messageSize ) <= 0 )

	mov	ecx, DWORD PTR _textHeapSize$[ebp]
	add	ecx, DWORD PTR _nameHeapSize$[ebp]
	add	ecx, DWORD PTR _messageSize$[ebp]
	test	ecx, ecx
	jg	SHORT $LN22@CL_TextMes

; 313  : 	{
; 314  : 		clgame.titles = NULL;

	mov	DWORD PTR _clgame+144660, 0

; 315  : 		clgame.numTitles = 0;

	mov	DWORD PTR _clgame+144664, 0

; 316  : 		return;

	jmp	$LN1@CL_TextMes
$LN22@CL_TextMes:

; 317  : 	}
; 318  : 
; 319  : 	// must malloc because we need to be able to clear it after initialization
; 320  : 	clgame.titles = (client_textmessage_t *)Mem_Calloc( cls.mempool, textHeapSize + nameHeapSize + messageSize );

	push	320					; 00000140H
	push	OFFSET $SG138472
	push	1
	mov	edx, DWORD PTR _textHeapSize$[ebp]
	add	edx, DWORD PTR _nameHeapSize$[ebp]
	add	edx, DWORD PTR _messageSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+144660, eax

; 321  : 	
; 322  : 	// copy table over
; 323  : 	memcpy( clgame.titles, textMessages, messageSize );

	mov	ecx, DWORD PTR _messageSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _textMessages$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+144660
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 324  : 	
; 325  : 	// copy Name heap
; 326  : 	pNameHeap = ((char *)clgame.titles) + messageSize;

	mov	ecx, DWORD PTR _clgame+144660
	add	ecx, DWORD PTR _messageSize$[ebp]
	mov	DWORD PTR _pNameHeap$[ebp], ecx

; 327  : 	memcpy( pNameHeap, nameHeap, nameHeapSize );

	mov	edx, DWORD PTR _nameHeapSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _nameHeap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNameHeap$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 328  : 	nameOffset = pNameHeap - clgame.titles[0].pName;

	mov	edx, 44					; 0000002cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clgame+144660
	mov	edx, DWORD PTR _pNameHeap$[ebp]
	sub	edx, DWORD PTR [ecx+eax+36]
	mov	DWORD PTR _nameOffset$[ebp], edx

; 329  : 
; 330  : 	// copy text & fixup pointers
; 331  : 	pCurrentText = pNameHeap + nameHeapSize;

	mov	eax, DWORD PTR _pNameHeap$[ebp]
	add	eax, DWORD PTR _nameHeapSize$[ebp]
	mov	DWORD PTR _pCurrentText$[ebp], eax

; 332  : 
; 333  : 	for( i = 0; i < messageCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@CL_TextMes
$LN9@CL_TextMes:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN11@CL_TextMes:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _messageCount$[ebp]
	jge	$LN10@CL_TextMes

; 334  : 	{
; 335  : 		clgame.titles[i].pName += nameOffset;			// adjust name pointer (parallel buffer)

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+144660
	mov	edx, DWORD PTR [ecx+eax+36]
	add	edx, DWORD PTR _nameOffset$[ebp]
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+144660
	mov	DWORD PTR [ecx+eax+36], edx

; 336  : 		Q_strcpy( pCurrentText, clgame.titles[i].pMessage );	// copy text over

	push	99999					; 0001869fH
	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _clgame+144660
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _pCurrentText$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 337  : 		clgame.titles[i].pMessage = pCurrentText;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+144660
	mov	edx, DWORD PTR _pCurrentText$[ebp]
	mov	DWORD PTR [ecx+eax+40], edx

; 338  : 		pCurrentText += Q_strlen( pCurrentText ) + 1;

	mov	eax, DWORD PTR _pCurrentText$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pCurrentText$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pCurrentText$[ebp], edx

; 339  : 	}

	jmp	$LN9@CL_TextMes
$LN10@CL_TextMes:

; 340  : 
; 341  : 	if(( pCurrentText - (char *)clgame.titles ) != ( textHeapSize + nameHeapSize + messageSize ))

	mov	eax, DWORD PTR _pCurrentText$[ebp]
	sub	eax, DWORD PTR _clgame+144660
	mov	ecx, DWORD PTR _textHeapSize$[ebp]
	add	ecx, DWORD PTR _nameHeapSize$[ebp]
	add	ecx, DWORD PTR _messageSize$[ebp]
	cmp	eax, ecx
	je	SHORT $LN23@CL_TextMes

; 342  : 		Con_DPrintf( S_ERROR "TextMessage: overflow text message buffer!\n" );

	push	OFFSET $SG138474
	call	_Con_DPrintf
	add	esp, 4
$LN23@CL_TextMes:

; 343  : 
; 344  : 	clgame.numTitles = messageCount;

	mov	edx, DWORD PTR _messageCount$[ebp]
	mov	DWORD PTR _clgame+144664, edx
$LN1@CL_TextMes:

; 345  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TextMessageParse ENDP
_TEXT	ENDS
END
