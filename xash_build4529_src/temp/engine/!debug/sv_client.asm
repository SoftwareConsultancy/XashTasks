; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\server\sv_client.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_clc_strings
PUBLIC	_ucmds
EXTRN	_SV_ServerLog_f:PROC
_DATA	SEGMENT
_clc_strings DD	FLAT:$SG136399
	DD	FLAT:$SG136400
	DD	FLAT:$SG136401
	DD	FLAT:$SG136402
	DD	FLAT:$SG136403
	DD	FLAT:$SG136404
	DD	FLAT:$SG136405
	DD	FLAT:$SG136406
	DD	FLAT:$SG136407
	DD	FLAT:$SG136408
	DD	FLAT:$SG136409
$SG136399 DB	'clc_bad', 00H
$SG136400 DB	'clc_nop', 00H
$SG136401 DB	'clc_move', 00H
	ORG $+3
$SG136402 DB	'clc_stringcmd', 00H
	ORG $+2
$SG136403 DB	'clc_delta', 00H
	ORG $+2
$SG136404 DB	'clc_resourcelist', 00H
	ORG $+3
$SG136405 DB	'clc_unused6', 00H
$SG136406 DB	'clc_fileconsistency', 00H
$SG136407 DB	'clc_voicedata', 00H
	ORG $+2
$SG136408 DB	'clc_cvarvalue', 00H
	ORG $+2
$SG136409 DB	'clc_cvarvalue2', 00H
	ORG $+1
_ucmds	DD	FLAT:$SG137272
	DD	FLAT:_SV_New_f
	DD	FLAT:$SG137273
	DD	FLAT:_SV_Godmode_f
	DD	FLAT:$SG137274
	DD	FLAT:_SV_Kill_f
	DD	FLAT:$SG137275
	DD	FLAT:_SV_Begin_f
	DD	FLAT:$SG137276
	DD	FLAT:_SV_Spawn_f
	DD	FLAT:$SG137277
	DD	FLAT:_SV_Pause_f
	DD	FLAT:$SG137278
	DD	FLAT:_SV_Noclip_f
	DD	FLAT:$SG137279
	DD	FLAT:_SV_ServerLog_f
	DD	FLAT:$SG137280
	DD	FLAT:_SV_SetInfo_f
	DD	FLAT:$SG137281
	DD	FLAT:_SV_SendRes_f
	DD	FLAT:$SG137282
	DD	FLAT:_SV_Notarget_f
	DD	FLAT:$SG137283
	DD	FLAT:_SV_ShowServerinfo_f
	DD	FLAT:$SG137284
	DD	FLAT:_SV_DownloadFile_f
	DD	FLAT:$SG137285
	DD	FLAT:_SV_Disconnect_f
	DD	FLAT:$SG137286
	DD	FLAT:_SV_UpdateUserinfo_f
	DD	00H
	DD	00H
$SG137272 DB	'new', 00H
$SG137273 DB	'god', 00H
$SG137274 DB	'kill', 00H
	ORG $+3
$SG137275 DB	'begin', 00H
	ORG $+2
$SG137276 DB	'spawn', 00H
	ORG $+2
$SG137277 DB	'pause', 00H
	ORG $+2
$SG137278 DB	'noclip', 00H
	ORG $+1
$SG137279 DB	'log', 00H
$SG137280 DB	'setinfo', 00H
$SG137281 DB	'sendres', 00H
$SG137282 DB	'notarget', 00H
	ORG $+3
$SG137283 DB	'info', 00H
	ORG $+3
$SG137284 DB	'dlfile', 00H
	ORG $+1
$SG137285 DB	'disconnect', 00H
	ORG $+1
$SG137286 DB	'userinfo', 00H
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetRealBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetData
PUBLIC	_SV_DropClient
PUBLIC	_SV_UserinfoChanged
PUBLIC	_SV_RemoteCommand
PUBLIC	_SV_RefreshUserinfo
PUBLIC	_SV_GetChallenge
PUBLIC	_SV_TogglePause
PUBLIC	_SV_ShouldUpdatePing
PUBLIC	_SV_GetClientIDString
PUBLIC	_SV_FullClientUpdate
PUBLIC	_SV_FullUpdateMovevars
PUBLIC	_SV_GetPlayerStats
PUBLIC	_SV_SendServerdata
PUBLIC	_SV_ExecuteClientMessage
PUBLIC	_SV_ConnectionlessPacket
PUBLIC	_SV_FakeConnect
PUBLIC	_SV_ExecuteClientCommand
PUBLIC	_SV_BuildReconnect
PUBLIC	_SV_IsPlayerIndex
PUBLIC	_SV_CalcPing
PUBLIC	_SV_EndRedirect
PUBLIC	_SV_GetFragmentSize
PUBLIC	_SV_RejectConnection
PUBLIC	_SV_FailDownload
PUBLIC	_SV_CheckChallenge
PUBLIC	_SV_CheckIPRestrictions
PUBLIC	_SV_FindEmptySlot
PUBLIC	_SV_ConnectClient
PUBLIC	_SV_BeginRedirect
PUBLIC	_SV_FlushRedirect
PUBLIC	_SV_TestBandWidth
PUBLIC	_SV_Ack
PUBLIC	_SV_Info
PUBLIC	_SV_BuildNetAnswer
PUBLIC	_SV_Ping
PUBLIC	_Rcon_Validate
PUBLIC	_SV_EstablishTimeBase
PUBLIC	_SV_CalcClientTime
PUBLIC	_SV_PutClientInServer
PUBLIC	_SV_UpdateClientView
PUBLIC	_SV_WriteDeltaDescriptionToClient
PUBLIC	_SV_TSourceEngineQuery
PUBLIC	_SV_ParseResourceList
PUBLIC	_SV_ParseCvarValue
PUBLIC	_SV_ParseCvarValue2
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f000000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fc99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@4090000000000000
PUBLIC	__real@40c3878000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@447a0000
PUBLIC	__real@44800000
PUBLIC	__real@461c3c00
PUBLIC	__real@47c35000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__real@c61c3c00
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Cmd_ExecuteString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_IsReservedAdr:PROC
EXTRN	_NET_CompareClassBAdr:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_CompareBaseAdr:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Q_buildnum:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_HexConvert:PROC
EXTRN	_COM_IsSafeFileToDownload:PROC
EXTRN	_COM_TrimSpace:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_BlockSequence:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_MD5Init:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_COM_SizeofResourceList:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_HPAK_ResourceForHash:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_Log_Printf:PROC
EXTRN	_SV_BroadcastPrintf:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_SV_Serverinfo:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_RemovePrefixedKeys:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Info_IsValid:PROC
EXTRN	_Info_Print:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_fabs:PROC
EXTRN	_Mod_StudioTexName:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_SeekToBit:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteChar:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteFloat:PROC
EXTRN	_MSG_WriteVec3Angles:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadCmd:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_Setup:PROC
EXTRN	_Netchan_CreateFileFragmentsFromBuffer:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_CreateFileFragments:PROC
EXTRN	_Netchan_TransmitBits:PROC
EXTRN	_Netchan_OutOfBand:PROC
EXTRN	_Netchan_OutOfBandPrint:PROC
EXTRN	_Netchan_IsLocal:PROC
EXTRN	_Netchan_FragSend:PROC
EXTRN	_Netchan_Clear:PROC
EXTRN	_SV_AddToMaster:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_ClientPrintf:PROC
EXTRN	_SV_RunCmd:PROC
EXTRN	_SV_AddToResourceList:PROC
EXTRN	_SV_ParseConsistencyResponse:PROC
EXTRN	_SV_EstimateNeededResources:PROC
EXTRN	_SV_ClearResourceList:PROC
EXTRN	_SV_BatchUploadRequest:PROC
EXTRN	_SV_SendResources:PROC
EXTRN	_SV_ClearResourceLists:PROC
EXTRN	_SV_InitEdict:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_MakeString:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_SendUserReg:PROC
EXTRN	_SV_RestartAmbientSounds:PROC
EXTRN	_SV_RestartDecals:PROC
EXTRN	_SV_RestartStaticEnts:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_PlayerIsFrozen:PROC
EXTRN	_Delta_NumTables:PROC
EXTRN	_Delta_FindStructByIndex:PROC
EXTRN	_Delta_WriteTableField:PROC
EXTRN	_MSG_ReadDeltaUsercmd:PROC
EXTRN	_MSG_WriteDeltaMovevars:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_net_local:BYTE
EXTRN	_sv_lan:BYTE
EXTRN	_net_drop:DWORD
EXTRN	_SV_UPDATE_BACKUP:DWORD
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_unlagsamples:BYTE
EXTRN	_rcon_password:BYTE
EXTRN	_sv_send_resources:BYTE
EXTRN	_sv_send_logos:BYTE
EXTRN	_sv_allow_upload:BYTE
EXTRN	_sv_allow_download:BYTE
EXTRN	_sv_password:BYTE
EXTRN	_sv_uploadmax:BYTE
EXTRN	_hostname:BYTE
EXTRN	_sv_pausable:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?result@?1??SV_GetClientIDString@@9@9 DB 040H DUP (?)	; `SV_GetClientIDString'::`2'::result
$SG136661 DB	01H DUP (?)
	ALIGN	4

$SG136764 DB	01H DUP (?)
	ALIGN	4

?outputbuf@?1??SV_RemoteCommand@@9@9 DB 0800H DUP (?)	; `SV_RemoteCommand'::`2'::outputbuf
?last_ping@?1??SV_GetPlayerStats@@9@9 DD 020H DUP (?)	; `SV_GetPlayerStats'::`2'::last_ping
?last_loss@?1??SV_GetPlayerStats@@9@9 DD 020H DUP (?)	; `SV_GetPlayerStats'::`2'::last_loss
?msg_buf@?1??SV_PutClientInServer@@9@9 DB 020200H DUP (?) ; `SV_PutClientInServer'::`2'::msg_buf
$SG137317 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@c61c3c00
CONST	SEGMENT
__real@c61c3c00 DD 0c61c3c00r			; -9999
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@40c3878000000000
CONST	SEGMENT
__real@40c3878000000000 DQ 040c3878000000000r	; 9999
CONST	ENDS
;	COMDAT __real@4090000000000000
CONST	SEGMENT
__real@4090000000000000 DQ 04090000000000000r	; 1024
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc99999a0000000
CONST	SEGMENT
__real@3fc99999a0000000 DQ 03fc99999a0000000r	; 0.2
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
_g_userid DD	01H
$SG136429 DB	'challenge %i', 00H
	ORG $+3
$SG136436 DB	'cl_dlmax', 00H
	ORG $+3
$SG136452 DB	'%s connection refused. Reason: %s', 0aH, 00H
	ORG $+1
$SG136453 DB	'print', 0aH, '^1Server was reject the connection:^7 %s', 00H
	ORG $+1
$SG136454 DB	'disconnect', 0aH, 00H
$SG136477 DB	'no challenge for your address', 0aH, 00H
	ORG $+1
$SG136498 DB	'server is full', 0aH, 00H
$SG136526 DB	'insufficient connection info', 0aH, 00H
	ORG $+2
$SG136528 DB	'unsupported protocol (%i should be %i)', 0aH, 00H
$SG136531 DB	'invalid protinfo in connect command', 0aH, 00H
	ORG $+3
$SG136532 DB	'qport', 00H
	ORG $+2
$SG136533 DB	'uuid', 00H
	ORG $+3
$SG136535 DB	'invalid authentication certificate length', 0aH, 00H
	ORG $+1
$SG136537 DB	'LAN servers are restricted to local clients (class C)', 0aH
	DB	00H
	ORG $+1
$SG136540 DB	'invalid userinfo in connect command', 0aH, 00H
	ORG $+3
$SG136542 DB	'password', 00H
	ORG $+3
$SG136543 DB	'invalid password', 0aH, 00H
	ORG $+2
$SG136551 DB	'^2Note:^7 %s:reconnect', 0aH, 00H
$SG136556 DB	'Datagram', 00H
	ORG $+3
$SG136553 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG136554 DB	'assert failed at %s:%i', 0aH, 00H
$SG136555 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG136557 DB	'client_connect', 00H
	ORG $+1
$SG136558 DB	'uuid', 00H
	ORG $+3
$SG136560 DB	'"%s<%i><%i><>" connected, address "%s"', 0aH, 00H
$SG136580 DB	'Bot', 00H
$SG136583 DB	'name', 00H
	ORG $+3
$SG136584 DB	'gordon', 00H
	ORG $+1
$SG136585 DB	'model', 00H
	ORG $+2
$SG136586 DB	'1', 00H
	ORG $+2
$SG136587 DB	'topcolor', 00H
	ORG $+3
$SG136588 DB	'1', 00H
	ORG $+2
$SG136589 DB	'bottomcolor', 00H
$SG136593 DB	'"%s<%i><%i><>" connected, address "local"', 0aH, 00H
	ORG $+1
$SG136591 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG136614 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG136645 DB	'print', 0aH, '%s', 00H
	ORG $+3
$SG136649 DB	'^1Error:^7 SV_FlushRedirect: %s: invalid destination', 0aH
	DB	00H
	ORG $+2
$SG136664 DB	'ID_BOT', 00H
	ORG $+1
$SG136667 DB	'ID_LOOPBACK', 00H
$SG136670 DB	'ID_LAN', 00H
	ORG $+1
$SG136671 DB	'ID_%s', 00H
	ORG $+2
$SG136686 DB	'unsupported protocol (%i should be %i)', 0aH, 00H
$SG136687 DB	'rb', 00H
	ORG $+1
$SG136688 DB	'gfx.wad', 00H
$SG136690 DB	'BandWidthPacket', 00H
$SG136691 DB	'testpacket', 00H
	ORG $+1
$SG136696 DB	'ping %s', 0aH, 00H
	ORG $+3
$SG136716 DB	'%s: wrong version', 0aH, 00H
	ORG $+1
$SG136718 DB	'host', 00H
	ORG $+3
$SG136719 DB	'map', 00H
$SG136720 DB	'%i', 00H
	ORG $+1
$SG136721 DB	'dm', 00H
	ORG $+1
$SG136722 DB	'%i', 00H
	ORG $+1
$SG136723 DB	'team', 00H
	ORG $+3
$SG136724 DB	'%i', 00H
	ORG $+1
$SG136725 DB	'coop', 00H
	ORG $+3
$SG136726 DB	'%i', 00H
	ORG $+1
$SG136727 DB	'numcl', 00H
	ORG $+2
$SG136728 DB	'%i', 00H
	ORG $+1
$SG136729 DB	'maxcl', 00H
	ORG $+2
$SG136730 DB	'gamedir', 00H
$SG136731 DB	'info', 0aH, '%s', 00H
$SG136759 DB	'protocol', 00H
	ORG $+3
$SG136760 DB	'neterror', 00H
	ORG $+3
$SG136761 DB	'netinfo %i %i %s', 0aH, 00H
	ORG $+2
$SG136765 DB	'netinfo %i %i %s', 0aH, 00H
	ORG $+2
$SG136768 DB	'netinfo %i %i %s', 0aH, 00H
	ORG $+2
$SG136772 DB	'%c\%s\%i\%f\', 00H
	ORG $+3
$SG136773 DB	'netinfo %i %i %s', 0aH, 00H
	ORG $+2
$SG136777 DB	'hostname', 00H
	ORG $+3
$SG136778 DB	'gamedir', 00H
$SG136779 DB	'%i', 00H
	ORG $+1
$SG136780 DB	'current', 00H
$SG136781 DB	'%i', 00H
	ORG $+1
$SG136782 DB	'max', 00H
$SG136783 DB	'map', 00H
$SG136784 DB	'netinfo %i %i %s', 0aH, 00H
	ORG $+2
$SG136785 DB	'undefined', 00H
	ORG $+2
$SG136786 DB	'neterror', 00H
	ORG $+3
$SG136787 DB	'netinfo %i %i %s', 0aH, 00H
	ORG $+2
$SG136792 DB	'ack', 00H
$SG136811 DB	'Rcon from %s:', 0aH, '%s', 0aH, 00H
	ORG $+2
$SG136812 DB	'Rcon: "%s" from "%s"', 0aH, 00H
	ORG $+2
$SG136815 DB	' ', 00H
	ORG $+2
$SG136816 DB	'^1Error:^7 Bad rcon_password.', 0aH, 00H
	ORG $+1
$SG136969 DB	'Spawn', 00H
	ORG $+2
$SG136974 DB	'save/', 00H
	ORG $+2
$SG136975 DB	'%s%s.HL2', 00H
	ORG $+3
$SG136977 DB	'hltv', 00H
	ORG $+3
$SG136982 DB	'cd loop %3d', 0aH, 00H
	ORG $+3
$SG136984 DB	'invasion', 00H
	ORG $+3
$SG136985 DB	'test', 0aH, 00H
	ORG $+2
$SG136993 DB	'spawn player: overflowed', 0aH, 00H
	ORG $+2
$SG137013 DB	'%s', 00H
	ORG $+1
$SG137018 DB	'reconnect', 0aH, 00H
	ORG $+1
$SG137053 DB	0aH, '^3BUILD %d SERVER (%i CRC)', 0aH, 'Server #%i', 0aH
	DB	00H
$SG137070 DB	'New', 00H
$SG137073 DB	'%s', 00H
	ORG $+1
$SG137074 DB	'%s', 00H
	ORG $+1
$SG137075 DB	'Connection rejected by game', 0aH, 00H
	ORG $+3
$SG137077 DB	'%s', 0aH, 00H
$SG137078 DB	'fullserverinfo "%s"', 0aH, 00H
	ORG $+3
$SG137096 DB	'Pause not allowed.', 0aH, 00H
$SG137098 DB	'Spectators can not pause.', 0aH, 00H
	ORG $+1
$SG137101 DB	'^2%s^7 paused the game', 0aH, 00H
$SG137102 DB	'^2%s^7 unpaused the game', 0aH, 00H
	ORG $+2
$SG137120 DB	'name', 00H
	ORG $+3
$SG137123 DB	'console', 00H
$SG137124 DB	'unnamed', 00H
$SG137125 DB	'name', 00H
	ORG $+3
$SG137126 DB	'name', 00H
	ORG $+3
$SG137128 DB	'name', 00H
	ORG $+3
$SG137129 DB	'name', 00H
	ORG $+3
$SG137131 DB	'unnamed', 00H
$SG137132 DB	'name', 00H
	ORG $+3
$SG137133 DB	'name', 00H
	ORG $+3
$SG137134 DB	'unnamed', 00H
$SG137135 DB	'unnamed', 00H
$SG137141 DB	'%s (%u)', 00H
$SG137142 DB	'name', 00H
	ORG $+3
$SG137143 DB	'name', 00H
	ORG $+3
$SG137145 DB	'rate', 00H
	ORG $+3
$SG137150 DB	'cl_nopred', 00H
	ORG $+2
$SG137153 DB	'cl_lc', 00H
	ORG $+2
$SG137156 DB	'cl_lw', 00H
	ORG $+2
$SG137157 DB	'cl_updaterate', 00H
	ORG $+2
$SG137161 DB	'name', 00H
	ORG $+3
$SG137179 DB	'sv_cheats', 00H
	ORG $+2
$SG137182 DB	'noclip ON', 0aH, 00H
	ORG $+1
$SG137183 DB	'noclip OFF', 0aH, 00H
$SG137191 DB	'sv_cheats', 00H
	ORG $+2
$SG137196 DB	'godmode OFF', 0aH, 00H
	ORG $+3
$SG137197 DB	'godmode ON', 0aH, 00H
$SG137205 DB	'sv_cheats', 00H
	ORG $+2
$SG137208 DB	'notarget OFF', 0aH, 00H
	ORG $+2
$SG137209 DB	'notarget ON', 0aH, 00H
	ORG $+3
$SG137215 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG137217 DB	'Can''t suicide - already dead!', 0aH, 00H
	ORG $+1
$SG137225 DB	'SendResources', 00H
	ORG $+2
$SG137243 DB	'mdl', 00H
$SG137248 DB	'!MD5', 00H
	ORG $+3
$SG137250 DB	'custom.hpk', 00H
	ORG $+1
$SG137252 DB	'custom.hpk', 00H
	ORG $+1
$SG137263 DB	'Server is paused.', 0aH, 00H
	ORG $+1
$SG137254 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG137299 DB	'''%s'' is not valid from the console', 0aH, 00H
$SG137300 DB	'ucmd->%s()', 0aH, 00H
$SG137303 DB	'fullupdate', 00H
	ORG $+1
$SG137322 DB	'TSourceEngineQuery', 00H
	ORG $+1
$SG137325 DB	'valve', 00H
	ORG $+2
$SG137330 DB	'hl.', 00H
$SG137340 DB	'SV_ConnectionlessPacket: %s : %s', 0aH, 00H
	ORG $+2
$SG137343 DB	'ping', 00H
	ORG $+3
$SG137346 DB	'ack', 00H
$SG137349 DB	'info', 00H
	ORG $+3
$SG137352 DB	'bandwidth', 00H
	ORG $+2
$SG137355 DB	'getchallenge', 00H
	ORG $+3
$SG137358 DB	'connect', 00H
$SG137361 DB	'rcon', 00H
	ORG $+3
$SG137364 DB	'netinfo', 00H
$SG137367 DB	's', 00H
	ORG $+2
$SG137370 DB	'TSource', 00H
$SG137373 DB	'i', 00H
	ORG $+2
$SG137374 DB	0ffH, 0ffH, 0ffH, 0ffH, 'j', 00H
	ORG $+2
$SG137378 DB	'^1Error:^7 bad connectionless packet from %s:', 0aH, '%s'
	DB	0aH, 00H
	ORG $+2
$SG137456 DB	'  Models:  %.2fK', 0aH, 00H
	ORG $+2
$SG137417 DB	'^1Error:^7 SV_ParseClientMove: %s sending too many comma'
	DB	'nds %i', 0aH, 00H
$SG137420 DB	'^1Error:^7 SV_UserMove: failed command checksum for %s ('
	DB	'%d != %d)', 0aH, 00H
	ORG $+1
$SG137458 DB	'  Sounds:  %.2fK', 0aH, 00H
	ORG $+2
$SG137447 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG137452 DB	'Verifying and uploading resources...', 0aH, 00H
	ORG $+2
$SG137454 DB	'Custom resources total %.2fK', 0aH, 00H
	ORG $+2
$SG137460 DB	'  Decals:  %.2fK', 0aH, 00H
	ORG $+2
$SG137462 DB	'  Skins :  %.2fK', 0aH, 00H
	ORG $+2
$SG137464 DB	'  Generic :  %.2fK', 0aH, 00H
$SG137466 DB	'  Events  :  %.2fK', 0aH, 00H
$SG137467 DB	'----------------------', 0aH, 00H
$SG137469 DB	'resources to request: %s', 0aH, 00H
	ORG $+2
$SG137479 DB	'Cvar query response: name:%s, value:%s', 0aH, 00H
	ORG $+4
$SG137491 DB	'Cvar query response: name:%s, request ID %d, cvar:%s, va'
	DB	'lue:%s', 0aH, 00H
$SG137506 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_client.c', 00H
	ORG $+3
$SG137507 DB	'assert failed at %s:%i', 0aH, 00H
$SG137511 DB	'^1Error:^7 incoming overflow for %s', 0aH, 00H
	ORG $+3
$SG137524 DB	'^1Error:^7 %s: clc_bad', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_requestID$ = -520					; size = 4
_name$ = -516						; size = 256
_value$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseCvarValue2 PROC

; 2355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 520				; 00000208H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2356 : 	string	name, value;
; 2357 : 	int	requestID = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _requestID$[ebp], eax

; 2358 : 
; 2359 : 	Q_strcpy( name, MSG_ReadString( msg ));

	push	99999					; 0001869fH
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2360 : 	Q_strcpy( value, MSG_ReadString( msg ));

	push	99999					; 0001869fH
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2361 : 
; 2362 : 	if( svgame.dllFuncs2.pfnCvarValue2 != NULL )

	cmp	DWORD PTR _svgame+19456, 0
	je	SHORT $LN2@SV_ParseCv

; 2363 : 		svgame.dllFuncs2.pfnCvarValue2( cl->edict, requestID, name, value );

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _requestID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	push	eax
	call	DWORD PTR _svgame+19456
	add	esp, 16					; 00000010H
$LN2@SV_ParseCv:

; 2364 : 	Con_Reportf( "Cvar query response: name:%s, request ID %d, cvar:%s, value:%s\n", cl->name, requestID, name, value );

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _requestID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG137491
	call	_Con_Reportf
	add	esp, 20					; 00000014H

; 2365 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseCvarValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_value$ = -4						; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseCvarValue PROC

; 2339 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2340 : 	const char *value = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _value$[ebp], eax

; 2341 : 
; 2342 : 	if( svgame.dllFuncs2.pfnCvarValue != NULL )

	cmp	DWORD PTR _svgame+19452, 0
	je	SHORT $LN2@SV_ParseCv

; 2343 : 		svgame.dllFuncs2.pfnCvarValue( cl->edict, value );

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	push	eax
	call	DWORD PTR _svgame+19452
	add	esp, 8
$LN2@SV_ParseCv:

; 2344 : 	Con_Reportf( "Cvar query response: name:%s, value:%s\n", cl->name, value );

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG137479
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2345 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseCvarValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_total$ = -52						; size = 4
_i$ = -48						; size = 4
_totalsize$ = -44					; size = 4
_resource$ = -40					; size = 4
_ri$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseResourceList PROC

; 2250 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2251 : 	int		totalsize;
; 2252 : 	resource_t	*resource;
; 2253 : 	int		i, total;
; 2254 : 	resourceinfo_t	ri;
; 2255 : 
; 2256 : 	total = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _total$[ebp], eax

; 2257 : 
; 2258 : 	SV_ClearResourceList( &cl->resourcesneeded );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264752				; 00040a30H
	push	ecx
	call	_SV_ClearResourceList
	add	esp, 4

; 2259 : 	SV_ClearResourceList( &cl->resourcesonhand );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264616				; 000409a8H
	push	edx
	call	_SV_ClearResourceList
	add	esp, 4

; 2260 : 
; 2261 : 	for( i = 0; i < total; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_ParseRe
$LN2@SV_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ParseRe:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _total$[ebp]
	jge	$LN3@SV_ParseRe

; 2262 : 	{
; 2263 : 		resource = Z_Calloc( sizeof( resource_t ) );

	push	2263					; 000008d7H
	push	OFFSET $SG137447
	push	1
	push	136					; 00000088H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _resource$[ebp], eax

; 2264 : 		Q_strncpy( resource->szFileName, MSG_ReadString( msg ), sizeof( resource->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2265 : 		resource->type = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 2266 : 		resource->nIndex = MSG_ReadShort( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 2267 : 		resource->nDownloadSize = MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 2268 : 		resource->ucFlags = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 2269 : 		resource->pNext = NULL;

	mov	edx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [edx+128], 0

; 2270 : 		resource->pPrev = NULL;

	mov	eax, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [eax+132], 0

; 2271 : 		ClearBits( resource->ucFlags, RES_WASMISSING );

	mov	ecx, DWORD PTR _resource$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _resource$[ebp]
	mov	BYTE PTR [eax+76], dl

; 2272 : 
; 2273 : 		if( FBitSet( resource->ucFlags, RES_CUSTOM ))

	mov	ecx, DWORD PTR _resource$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	and	edx, 4
	je	SHORT $LN5@SV_ParseRe

; 2274 : 			MSG_ReadBytes( msg, resource->rgucMD5_hash, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _resource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN5@SV_ParseRe:

; 2275 : 
; 2276 : 		if( resource->type > t_world || resource->nDownloadSize > 1024 * 1024 * 1024 )

	mov	edx, DWORD PTR _resource$[ebp]
	cmp	DWORD PTR [edx+64], 6
	jg	SHORT $LN7@SV_ParseRe
	mov	eax, DWORD PTR _resource$[ebp]
	cmp	DWORD PTR [eax+72], 1073741824		; 40000000H
	jle	SHORT $LN6@SV_ParseRe
$LN7@SV_ParseRe:

; 2277 : 		{
; 2278 : 			SV_ClearResourceList( &cl->resourcesneeded );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264752				; 00040a30H
	push	ecx
	call	_SV_ClearResourceList
	add	esp, 4

; 2279 : 			SV_ClearResourceList( &cl->resourcesonhand );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264616				; 000409a8H
	push	edx
	call	_SV_ClearResourceList
	add	esp, 4

; 2280 : 			return;

	jmp	$LN1@SV_ParseRe
$LN6@SV_ParseRe:

; 2281 : 		}
; 2282 : 		SV_AddToResourceList( resource, &cl->resourcesneeded );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264752				; 00040a30H
	push	eax
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	call	_SV_AddToResourceList
	add	esp, 8

; 2283 : 	}

	jmp	$LN2@SV_ParseRe
$LN3@SV_ParseRe:

; 2284 : 
; 2285 : 	totalsize = COM_SizeofResourceList( &cl->resourcesneeded, &ri );

	lea	edx, DWORD PTR _ri$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264752				; 00040a30H
	push	eax
	call	_COM_SizeofResourceList
	add	esp, 8
	mov	DWORD PTR _totalsize$[ebp], eax

; 2286 : 
; 2287 : 	if( totalsize != 0 && sv_allow_upload.value )

	cmp	DWORD PTR _totalsize$[ebp], 0
	je	$LN8@SV_ParseRe
	movss	xmm0, DWORD PTR _sv_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@SV_ParseRe

; 2288 : 	{
; 2289 : 		Con_DPrintf( "Verifying and uploading resources...\n" );

	push	OFFSET $SG137452
	call	_Con_DPrintf
	add	esp, 4

; 2290 : 
; 2291 : 		if( totalsize != 0 )

	cmp	DWORD PTR _totalsize$[ebp], 0
	je	$LN9@SV_ParseRe

; 2292 : 		{
; 2293 : 			Con_DPrintf( "Custom resources total %.2fK\n", totalsize / 1024.0 );

	cvtsi2sd xmm0, DWORD PTR _totalsize$[ebp]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137454
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 2294 : 
; 2295 : 			if ( ri.info[t_model].size != 0 )

	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN10@SV_ParseRe

; 2296 : 				Con_DPrintf( "  Models:  %.2fK\n", ri.info[t_model].size / 1024.0 );

	mov	edx, 4
	shl	edx, 1
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+edx]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137456
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN10@SV_ParseRe:

; 2297 : 
; 2298 : 			if ( ri.info[t_sound].size != 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN11@SV_ParseRe

; 2299 : 				Con_DPrintf( "  Sounds:  %.2fK\n", ri.info[t_sound].size / 1024.0 );

	mov	edx, 4
	imul	eax, edx, 0
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+eax]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137458
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN11@SV_ParseRe:

; 2300 : 
; 2301 : 			if ( ri.info[t_decal].size != 0 )

	mov	ecx, 4
	imul	edx, ecx, 3
	cmp	DWORD PTR _ri$[ebp+edx], 0
	je	SHORT $LN12@SV_ParseRe

; 2302 : 				Con_DPrintf( "  Decals:  %.2fK\n", ri.info[t_decal].size / 1024.0 );

	mov	eax, 4
	imul	ecx, eax, 3
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+ecx]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137460
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN12@SV_ParseRe:

; 2303 : 
; 2304 : 			if ( ri.info[t_skin].size != 0 )

	mov	edx, 4
	shl	edx, 0
	cmp	DWORD PTR _ri$[ebp+edx], 0
	je	SHORT $LN13@SV_ParseRe

; 2305 : 				Con_DPrintf( "  Skins :  %.2fK\n", ri.info[t_skin].size / 1024.0 );

	mov	eax, 4
	shl	eax, 0
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+eax]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137462
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN13@SV_ParseRe:

; 2306 : 
; 2307 : 			if ( ri.info[t_generic].size != 0 )

	mov	ecx, 4
	shl	ecx, 2
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN14@SV_ParseRe

; 2308 : 				Con_DPrintf( "  Generic :  %.2fK\n", ri.info[t_generic].size / 1024.0 );

	mov	edx, 4
	shl	edx, 2
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+edx]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137464
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN14@SV_ParseRe:

; 2309 : 
; 2310 : 			if ( ri.info[t_eventscript].size != 0 )

	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN15@SV_ParseRe

; 2311 : 				Con_DPrintf( "  Events  :  %.2fK\n", ri.info[t_eventscript].size / 1024.0 );

	mov	edx, 4
	imul	eax, edx, 5
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+eax]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG137466
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN15@SV_ParseRe:

; 2312 : 
; 2313 : 			Con_DPrintf( "----------------------\n" );

	push	OFFSET $SG137467
	call	_Con_DPrintf
	add	esp, 4
$LN9@SV_ParseRe:

; 2314 : 		}
; 2315 : 
; 2316 : 		totalsize = SV_EstimateNeededResources( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_EstimateNeededResources
	add	esp, 4
	mov	DWORD PTR _totalsize$[ebp], eax

; 2317 : 
; 2318 : 		if( totalsize > sv_uploadmax.value * 1024 * 1024 )

	cvtsi2ss xmm0, DWORD PTR _totalsize$[ebp]
	movss	xmm1, DWORD PTR _sv_uploadmax+12
	mulss	xmm1, DWORD PTR __real@44800000
	mulss	xmm1, DWORD PTR __real@44800000
	comiss	xmm0, xmm1
	jbe	SHORT $LN16@SV_ParseRe

; 2319 : 		{
; 2320 : 			SV_ClearResourceList( &cl->resourcesneeded );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264752				; 00040a30H
	push	edx
	call	_SV_ClearResourceList
	add	esp, 4

; 2321 : 			SV_ClearResourceList( &cl->resourcesonhand );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264616				; 000409a8H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2322 : 			return;

	jmp	SHORT $LN1@SV_ParseRe
$LN16@SV_ParseRe:

; 2323 : 		}
; 2324 : 		Con_DPrintf( "resources to request: %s\n", Q_memprint( totalsize ));

	push	2
	cvtsi2ss xmm0, DWORD PTR _totalsize$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG137469
	call	_Con_DPrintf
	add	esp, 8
$LN8@SV_ParseRe:

; 2325 : 	}
; 2326 : 
; 2327 : 	cl->upstate = us_processing;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 2328 : 	SV_BatchUploadRequest( cl );

	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_BatchUploadRequest
	add	esp, 4
$LN1@SV_ParseRe:

; 2329 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_packet_loss$ = -3444					; size = 4
_size$ = -3440						; size = 4
_model$ = -3436						; size = 4
tv294 = -3432						; size = 4
_checksum2$ = -3428					; size = 4
_checksum1$ = -3424					; size = 4
_key$ = -3420						; size = 4
_from$ = -3416						; size = 4
_to$ = -3412						; size = 4
_numbackup$ = -3408					; size = 4
_totalcmds$ = -3404					; size = 4
_frame$ = -3400						; size = 4
_numcmds$ = -3396					; size = 4
_player$ = -3392					; size = 4
_i$ = -3388						; size = 4
_nullcmd$ = -3384					; size = 52
_cmds$ = -3332						; size = 3328
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseClientMove PROC

; 2118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3444				; 00000d74H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2119 : 	client_frame_t	*frame;
; 2120 : 	int		key, size, checksum1, checksum2;
; 2121 : 	int		i, numbackup, totalcmds, numcmds;
; 2122 : 	usercmd_t		nullcmd, *to, *from;
; 2123 : 	usercmd_t		cmds[CMD_BACKUP];
; 2124 : 	float		packet_loss;
; 2125 : 	edict_t		*player;
; 2126 : 	model_t		*model;
; 2127 : 
; 2128 : 	player = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _player$[ebp], ecx

; 2129 : 
; 2130 : 	frame = &cl->frames[cl->netchan.incoming_acknowledged & SV_UPDATE_MASK];

	mov	edx, DWORD PTR _SV_UPDATE_BACKUP
	sub	edx, 1
	mov	eax, DWORD PTR _cl$[ebp]
	and	edx, DWORD PTR [eax+628]
	imul	ecx, edx, 6128
	mov	edx, DWORD PTR _cl$[ebp]
	add	ecx, DWORD PTR [edx+281916]
	mov	DWORD PTR _frame$[ebp], ecx

; 2131 : 	memset( &nullcmd, 0, sizeof( usercmd_t ));

	push	52					; 00000034H
	push	0
	lea	eax, DWORD PTR _nullcmd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2132 : 	memset( cmds, 0, sizeof( cmds ));

	push	3328					; 00000d00H
	push	0
	lea	ecx, DWORD PTR _cmds$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2133 : 
; 2134 : 	key = MSG_GetRealBytesRead( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	mov	DWORD PTR _key$[ebp], eax

; 2135 : 	checksum1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _checksum1$[ebp], eax

; 2136 : 	packet_loss = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _packet_loss$[ebp], xmm0

; 2137 : 
; 2138 : 	numbackup = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _numbackup$[ebp], eax

; 2139 : 	numcmds = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _numcmds$[ebp], eax

; 2140 : 
; 2141 : 	totalcmds = numcmds + numbackup;

	mov	ecx, DWORD PTR _numcmds$[ebp]
	add	ecx, DWORD PTR _numbackup$[ebp]
	mov	DWORD PTR _totalcmds$[ebp], ecx

; 2142 : 	net_drop -= (numcmds - 1);

	mov	edx, DWORD PTR _numcmds$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _net_drop
	sub	eax, edx
	mov	DWORD PTR _net_drop, eax

; 2143 : 
; 2144 : 	if( totalcmds < 0 || totalcmds >= CMD_MASK )

	cmp	DWORD PTR _totalcmds$[ebp], 0
	jl	SHORT $LN16@SV_ParseCl
	cmp	DWORD PTR _totalcmds$[ebp], 63		; 0000003fH
	jl	SHORT $LN15@SV_ParseCl
$LN16@SV_ParseCl:

; 2145 : 	{
; 2146 : 		Con_Reportf( S_ERROR "SV_ParseClientMove: %s sending too many commands %i\n", cl->name, totalcmds );

	mov	ecx, DWORD PTR _totalcmds$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG137417
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2147 : 		SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 2148 : 		return;

	jmp	$LN27@SV_ParseCl
$LN15@SV_ParseCl:

; 2149 : 	}
; 2150 : 
; 2151 : 	from = &nullcmd;	// first cmd are starting from null-compressed usercmd_t

	lea	ecx, DWORD PTR _nullcmd$[ebp]
	mov	DWORD PTR _from$[ebp], ecx

; 2152 : 
; 2153 : 	for( i = totalcmds - 1; i >= 0; i-- )

	mov	edx, DWORD PTR _totalcmds$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN4@SV_ParseCl
$LN2@SV_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ParseCl:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@SV_ParseCl

; 2154 : 	{
; 2155 : 		to = &cmds[i];

	imul	ecx, DWORD PTR _i$[ebp], 52
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	DWORD PTR _to$[ebp], edx

; 2156 : 		MSG_ReadDeltaUsercmd( msg, from, to );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadDeltaUsercmd
	add	esp, 12					; 0000000cH

; 2157 : 		from = to; // get new baseline

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 2158 : 	}

	jmp	SHORT $LN2@SV_ParseCl
$LN3@SV_ParseCl:

; 2159 : 
; 2160 : 	if( cl->state != cs_spawned )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN17@SV_ParseCl

; 2161 : 		return;

	jmp	$LN27@SV_ParseCl
$LN17@SV_ParseCl:

; 2162 : 
; 2163 : 	// if the checksum fails, ignore the rest of the packet
; 2164 : 	size = MSG_GetRealBytesRead( msg ) - key - 1;

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _key$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 2165 : 	checksum2 = CRC32_BlockSequence( msg->pData + key + 1, size, cl->netchan.incoming_sequence );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _key$[ebp]
	lea	eax, DWORD PTR [ecx+edx+1]
	push	eax
	call	_CRC32_BlockSequence
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	mov	DWORD PTR _checksum2$[ebp], ecx

; 2166 : 
; 2167 : 	if( checksum2 != checksum1 )

	mov	edx, DWORD PTR _checksum2$[ebp]
	cmp	edx, DWORD PTR _checksum1$[ebp]
	je	SHORT $LN18@SV_ParseCl

; 2168 : 	{
; 2169 : 		Con_Reportf( S_ERROR "SV_UserMove: failed command checksum for %s (%d != %d)\n", cl->name, checksum2, checksum1 );

	mov	eax, DWORD PTR _checksum1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _checksum2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG137420
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 2170 : 		return;

	jmp	$LN27@SV_ParseCl
$LN18@SV_ParseCl:

; 2171 : 	}
; 2172 : 
; 2173 : 	cl->packet_loss = packet_loss;

	cvttss2si eax, DWORD PTR _packet_loss$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+264968], eax

; 2174 : 
; 2175 : 	// freeze player for some reasons if loadgame was executed
; 2176 : 	if( GameState->loadGame )

	cmp	DWORD PTR _host+156, 0
	je	SHORT $LN19@SV_ParseCl

; 2177 : 		return;

	jmp	$LN27@SV_ParseCl
$LN19@SV_ParseCl:

; 2178 : 
; 2179 : 	// check for pause or frozen
; 2180 : 	if( sv.paused || !CL_IsInGame() || SV_PlayerIsFrozen( player ))

	cmp	DWORD PTR _sv+1359688, 0
	jne	SHORT $LN22@SV_ParseCl
	call	_CL_IsInGame
	test	eax, eax
	je	SHORT $LN22@SV_ParseCl
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	call	_SV_PlayerIsFrozen
	add	esp, 4
	test	eax, eax
	je	$LN20@SV_ParseCl
$LN22@SV_ParseCl:

; 2181 : 	{
; 2182 : 		for( i = 0; i < numcmds; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_ParseCl
$LN5@SV_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_ParseCl:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numcmds$[ebp]
	jge	$LN6@SV_ParseCl

; 2183 : 		{
; 2184 : 			cmds[i].msec = 0;

	imul	edx, DWORD PTR _i$[ebp], 52
	mov	BYTE PTR _cmds$[ebp+edx+2], 0

; 2185 : 			cmds[i].forwardmove = 0;

	imul	eax, DWORD PTR _i$[ebp], 52
	xorps	xmm0, xmm0
	movss	DWORD PTR _cmds$[ebp+eax+16], xmm0

; 2186 : 			cmds[i].sidemove = 0;

	imul	ecx, DWORD PTR _i$[ebp], 52
	xorps	xmm0, xmm0
	movss	DWORD PTR _cmds$[ebp+ecx+20], xmm0

; 2187 : 			cmds[i].upmove = 0;

	imul	edx, DWORD PTR _i$[ebp], 52
	xorps	xmm0, xmm0
	movss	DWORD PTR _cmds$[ebp+edx+24], xmm0

; 2188 : 			cmds[i].buttons = 0;

	imul	eax, DWORD PTR _i$[ebp], 52
	xor	ecx, ecx
	mov	WORD PTR _cmds$[ebp+eax+30], cx

; 2189 : 
; 2190 : 			if( SV_PlayerIsFrozen( player ))

	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	call	_SV_PlayerIsFrozen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@SV_ParseCl

; 2191 : 				cmds[i].impulse = 0;

	imul	eax, DWORD PTR _i$[ebp], 52
	mov	BYTE PTR _cmds$[ebp+eax+32], 0
$LN23@SV_ParseCl:

; 2192 : 
; 2193 : 			VectorCopy( cmds[i].viewangles, player->v.v_angle );

	imul	ecx, DWORD PTR _i$[ebp], 52
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR [esi+eax+244], ecx
	imul	edx, DWORD PTR _i$[ebp], 52
	lea	eax, DWORD PTR _cmds$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [esi+edx+244], eax
	imul	ecx, DWORD PTR _i$[ebp], 52
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+244], edx

; 2194 : 		}

	jmp	$LN5@SV_ParseCl
$LN6@SV_ParseCl:

; 2195 : 		net_drop = 0;

	mov	DWORD PTR _net_drop, 0

; 2196 : 	}

	jmp	$LN24@SV_ParseCl
$LN20@SV_ParseCl:

; 2197 : 	else
; 2198 : 	{
; 2199 : 		if( !player->v.fixangle )

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	$LN24@SV_ParseCl

; 2200 : 			VectorCopy( cmds[0].viewangles, player->v.v_angle );

	mov	ecx, 52					; 00000034H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _cmds$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR [esi+ecx+244], edx
	mov	eax, 52					; 00000034H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+244], edx
	mov	eax, 52					; 00000034H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+244], edx
$LN24@SV_ParseCl:

; 2201 : 	}
; 2202 : 
; 2203 : 	SV_EstablishTimeBase( cl, cmds, net_drop, numbackup, numcmds );

	mov	eax, DWORD PTR _numcmds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numbackup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _net_drop
	push	edx
	lea	eax, DWORD PTR _cmds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_EstablishTimeBase
	add	esp, 20					; 00000014H

; 2204 : 
; 2205 : 	if( net_drop < 24 )

	cmp	DWORD PTR _net_drop, 24			; 00000018H
	jge	$LN11@SV_ParseCl
$LN8@SV_ParseCl:

; 2206 : 	{
; 2207 : 		while( net_drop > numbackup )

	mov	edx, DWORD PTR _net_drop
	cmp	edx, DWORD PTR _numbackup$[ebp]
	jle	SHORT $LN9@SV_ParseCl

; 2208 : 		{
; 2209 : 			SV_RunCmd( cl, &cl->lastcmd, 0 );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264888				; 00040ab8H
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 2210 : 			net_drop--;

	mov	edx, DWORD PTR _net_drop
	sub	edx, 1
	mov	DWORD PTR _net_drop, edx

; 2211 : 		}

	jmp	SHORT $LN8@SV_ParseCl
$LN9@SV_ParseCl:

; 2212 : 
; 2213 : 		while( net_drop > 0 )

	cmp	DWORD PTR _net_drop, 0
	jle	SHORT $LN11@SV_ParseCl

; 2214 : 		{
; 2215 : 			i = numcmds + net_drop - 1;

	mov	eax, DWORD PTR _net_drop
	mov	ecx, DWORD PTR _numcmds$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _i$[ebp], edx

; 2216 : 			SV_RunCmd( cl, &cmds[i], cl->netchan.incoming_sequence - i );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	sub	ecx, DWORD PTR _i$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 52
	lea	eax, DWORD PTR _cmds$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 2217 : 			net_drop--;

	mov	edx, DWORD PTR _net_drop
	sub	edx, 1
	mov	DWORD PTR _net_drop, edx

; 2218 : 		}

	jmp	SHORT $LN9@SV_ParseCl
$LN11@SV_ParseCl:

; 2219 : 	}
; 2220 : 
; 2221 : 	for( i = numcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN14@SV_ParseCl
$LN12@SV_ParseCl:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN14@SV_ParseCl:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN13@SV_ParseCl

; 2222 : 	{
; 2223 : 		SV_RunCmd( cl, &cmds[i], cl->netchan.incoming_sequence - i );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+624]
	sub	eax, DWORD PTR _i$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 52
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 2224 : 	}

	jmp	SHORT $LN12@SV_ParseCl
$LN13@SV_ParseCl:

; 2225 : 
; 2226 : 	cl->lastcmd = cmds[0];

	mov	ecx, 52					; 00000034H
	imul	edx, ecx, 0
	lea	esi, DWORD PTR _cmds$[ebp+edx]
	mov	edi, DWORD PTR _cl$[ebp]
	add	edi, 264888				; 00040ab8H
	mov	ecx, 13					; 0000000dH
	rep movsd

; 2227 : 
; 2228 : 	// adjust latency time by 1/2 last client frame since
; 2229 : 	// the message probably arrived 1/2 through client's frame loop
; 2230 : 	frame->ping_time -= ( cl->lastcmd.msec * 0.5f ) / 1000.0f;

	mov	eax, DWORD PTR _cl$[ebp]
	movzx	ecx, BYTE PTR [eax+264890]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [eax+8], xmm1

; 2231 : 	frame->ping_time = Q_max( 0.0f, frame->ping_time );

	mov	ecx, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+8]
	jbe	SHORT $LN29@SV_ParseCl
	xorps	xmm0, xmm0
	movss	DWORD PTR tv294[ebp], xmm0
	jmp	SHORT $LN30@SV_ParseCl
$LN29@SV_ParseCl:
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR tv294[ebp], xmm0
$LN30@SV_ParseCl:
	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR tv294[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 2232 : 	model = SV_ModelHandle( player->v.modelindex );

	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	push	edx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 2233 : 
; 2234 : 	if( model && model->type == mod_studio )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN27@SV_ParseCl
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN27@SV_ParseCl

; 2235 : 	{
; 2236 : 		// g-cont. yes we using svgame.globals->time instead of sv.time
; 2237 : 		if( player->v.animtime > svgame.globals->time + sv.frametime )

	mov	ecx, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR _sv+32
	mov	edx, DWORD PTR _player$[ebp]
	movss	xmm1, DWORD PTR [edx+436]
	comiss	xmm1, xmm0
	jbe	SHORT $LN27@SV_ParseCl

; 2238 : 			player->v.animtime = svgame.globals->time + sv.frametime;

	mov	eax, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _player$[ebp]
	movss	DWORD PTR [ecx+436], xmm0
$LN27@SV_ParseCl:

; 2239 : 	}
; 2240 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseClientMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
tv146 = -1064						; size = 4
_bots$ = -1060						; size = 4
_count$ = -1056						; size = 4
_buf$ = -1052						; size = 20
_index$ = -1032						; size = 4
_answer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_TSourceEngineQuery PROC

; 2002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1064				; 00000428H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2003 : 	// A2S_INFO
; 2004 : 	char	answer[1024] = "";

	mov	al, BYTE PTR $SG137317
	mov	BYTE PTR _answer$[ebp], al
	push	1023					; 000003ffH
	push	0
	lea	ecx, DWORD PTR _answer$[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2005 : 	int	count = 0, bots = 0;

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _bots$[ebp], 0

; 2006 : 	int	index;
; 2007 : 	sizebuf_t	buf;
; 2008 : 
; 2009 : 	if( svs.clients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN3@SV_TSource

; 2010 : 	{
; 2011 : 		for( index = 0; index < svs.maxclients; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@SV_TSource
$LN2@SV_TSource:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN4@SV_TSource:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_TSource

; 2012 : 		{
; 2013 : 			if( svs.clients[index].state >= cs_connected )

	imul	ecx, DWORD PTR _index$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 2
	jl	SHORT $LN8@SV_TSource

; 2014 : 			{
; 2015 : 				if( FBitSet( svs.clients[index].flags, FCL_FAKECLIENT ))

	imul	eax, DWORD PTR _index$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	edx, DWORD PTR [ecx+eax+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN7@SV_TSource

; 2016 : 					bots++;

	mov	eax, DWORD PTR _bots$[ebp]
	add	eax, 1
	mov	DWORD PTR _bots$[ebp], eax
	jmp	SHORT $LN8@SV_TSource
$LN7@SV_TSource:

; 2017 : 				else count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
$LN8@SV_TSource:

; 2018 : 			}
; 2019 : 		}

	jmp	SHORT $LN2@SV_TSource
$LN3@SV_TSource:

; 2020 : 	}
; 2021 : 
; 2022 : 	MSG_Init( &buf, "TSourceEngineQuery", answer, sizeof( answer ));

	push	-1
	push	1024					; 00000400H
	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	push	OFFSET $SG137322
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2023 : 
; 2024 : 	MSG_WriteByte( &buf, 'm' );

	push	109					; 0000006dH
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte

; 2025 : 	MSG_WriteString( &buf, NET_AdrToString( net_local ));

	add	esp, -12				; fffffff4H
	mov	edx, esp
	mov	eax, DWORD PTR _net_local
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _net_local+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _net_local+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _net_local+12
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _net_local+16
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2026 : 	MSG_WriteString( &buf, hostname.string );

	mov	edx, DWORD PTR _hostname+4
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 2027 : 	MSG_WriteString( &buf, sv.name );

	push	OFFSET _sv+56
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2028 : 	MSG_WriteString( &buf, GI->gamefolder );

	mov	edx, DWORD PTR _SI+768
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 2029 : 	MSG_WriteString( &buf, GI->title );

	mov	ecx, DWORD PTR _SI+768
	add	ecx, 384				; 00000180H
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 2030 : 	MSG_WriteByte( &buf, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2031 : 	MSG_WriteByte( &buf, svs.maxclients );

	mov	edx, DWORD PTR _svs+16
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2032 : 	MSG_WriteByte( &buf, PROTOCOL_VERSION );

	push	49					; 00000031H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2033 : 	MSG_WriteByte( &buf, host.type == HOST_DEDICATED ? 'D' : 'L' );

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN16@SV_TSource
	mov	DWORD PTR tv146[ebp], 68		; 00000044H
	jmp	SHORT $LN17@SV_TSource
$LN16@SV_TSource:
	mov	DWORD PTR tv146[ebp], 76		; 0000004cH
$LN17@SV_TSource:
	mov	edx, DWORD PTR tv146[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2034 : 	MSG_WriteByte( &buf, 'W' );

	push	87					; 00000057H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2035 : 
; 2036 : 	if( Q_stricmp( GI->gamedir, "valve" ))

	push	99999					; 0001869fH
	push	OFFSET $SG137325
	mov	edx, DWORD PTR _SI+768
	add	edx, 128				; 00000080H
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN9@SV_TSource

; 2037 : 	{
; 2038 : 		MSG_WriteByte( &buf, 1 ); // mod

	push	1
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2039 : 		MSG_WriteString( &buf, GI->game_url );

	mov	ecx, DWORD PTR _SI+768
	add	ecx, 644				; 00000284H
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 2040 : 		MSG_WriteString( &buf, GI->update_url );

	mov	eax, DWORD PTR _SI+768
	add	eax, 900				; 00000384H
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2041 : 		MSG_WriteByte( &buf, 0 );

	push	0
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 2042 : 		MSG_WriteLong( &buf, (long)GI->version );

	mov	eax, DWORD PTR _SI+768
	cvttss2si ecx, DWORD PTR [eax+448]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 2043 : 		MSG_WriteLong( &buf, GI->size );

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1284]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 2044 : 
; 2045 : 		if( GI->gamemode == 2 )

	mov	eax, DWORD PTR _SI+768
	cmp	DWORD PTR [eax+1288], 2
	jne	SHORT $LN11@SV_TSource

; 2046 : 			MSG_WriteByte( &buf, 1 ); // multiplayer_only

	push	1
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
	jmp	SHORT $LN12@SV_TSource
$LN11@SV_TSource:

; 2047 : 		else MSG_WriteByte( &buf, 0 );

	push	0
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8
$LN12@SV_TSource:

; 2048 : 
; 2049 : 		if( Q_strstr( GI->game_dll, "hl." ))

	push	OFFSET $SG137330
	mov	eax, DWORD PTR _SI+768
	add	eax, 516				; 00000204H
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@SV_TSource

; 2050 : 			MSG_WriteByte( &buf, 0 ); // Half-Life DLL

	push	0
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
	jmp	SHORT $LN14@SV_TSource
$LN13@SV_TSource:

; 2051 : 		else MSG_WriteByte( &buf, 1 ); // Own DLL

	push	1
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8
$LN14@SV_TSource:

; 2052 : 	}

	jmp	SHORT $LN10@SV_TSource
$LN9@SV_TSource:

; 2053 : 	else MSG_WriteByte( &buf, 0 ); // Half-Life

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN10@SV_TSource:

; 2054 : 
; 2055 : 	MSG_WriteByte( &buf, GI->secure ); // unsecure

	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [ecx+1292]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2056 : 	MSG_WriteByte( &buf, bots );

	mov	ecx, DWORD PTR _bots$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteByte

; 2057 : 
; 2058 : 	NET_SendPacket( NS_SERVER, MSG_GetNumBytesWritten( &buf ), MSG_GetData( &buf ), from );

	add	esp, -12				; fffffff4H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 2059 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TSourceEngineQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Begin_f PROC

; 1926 : {

	push	ebp
	mov	ebp, esp

; 1927 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@SV_Begin_f

; 1928 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_Begin_f
$LN2@SV_Begin_f:

; 1929 : 
; 1930 : 	// now client is spawned
; 1931 : 	cl->state = cs_spawned;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx], 3

; 1932 : 	return true;

	mov	eax, 1
$LN1@SV_Begin_f:

; 1933 : }

	pop	ebp
	ret	0
_SV_Begin_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Spawn_f PROC

; 1897 : {

	push	ebp
	mov	ebp, esp

; 1898 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@SV_Spawn_f

; 1899 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_Spawn_f
$LN2@SV_Spawn_f:

; 1900 : 
; 1901 : 	// handle the case of a level changing while a client was connecting
; 1902 : 	if( Q_atoi( Cmd_Argv( 1 )) != svs.spawncount )

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, DWORD PTR _svs+33340
	je	SHORT $LN3@SV_Spawn_f

; 1903 : 	{
; 1904 : 		SV_New_f( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_New_f
	add	esp, 4

; 1905 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Spawn_f
$LN3@SV_Spawn_f:

; 1906 : 	}
; 1907 : 
; 1908 : 	SV_PutClientInServer( cl );

	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_PutClientInServer
	add	esp, 4

; 1909 : 
; 1910 : 	// if we are paused, tell the clients
; 1911 : 	if( sv.paused )

	cmp	DWORD PTR _sv+1359688, 0
	je	SHORT $LN4@SV_Spawn_f

; 1912 : 	{
; 1913 : 		MSG_BeginServerCmd( &sv.reliable_datagram, svc_setpause );

	push	0
	push	1
	push	24					; 00000018H
	push	OFFSET _sv+1195756
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1914 : 		MSG_WriteByte( &sv.reliable_datagram, sv.paused );

	mov	eax, DWORD PTR _sv+1359688
	push	eax
	push	OFFSET _sv+1195756
	call	_MSG_WriteByte
	add	esp, 8

; 1915 : 		SV_ClientPrintf( cl, "Server is paused.\n" );

	push	OFFSET $SG137263
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 8
$LN4@SV_Spawn_f:

; 1916 : 	}
; 1917 : 	return true;

	mov	eax, 1
$LN1@SV_Spawn_f:

; 1918 : }

	pop	ebp
	ret	0
_SV_Spawn_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_pbuf$1 = -184						; size = 4
_size$2 = -180						; size = 4
_name$ = -176						; size = 4
_custResource$3 = -172					; size = 136
_md5$4 = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_DownloadFile_f PROC

; 1820 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1821 : 	char	*name;
; 1822 : 
; 1823 : 	if( Cmd_Argc() < 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jae	SHORT $LN2@SV_Downloa

; 1824 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN2@SV_Downloa:

; 1825 : 
; 1826 : 	name = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 1827 : 
; 1828 : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@SV_Downloa

; 1829 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN3@SV_Downloa:

; 1830 : 
; 1831 : 	if( !COM_IsSafeFileToDownload( name ) || !sv_allow_download.value )

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_IsSafeFileToDownload
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@SV_Downloa
	movss	xmm0, DWORD PTR _sv_allow_download+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_Downloa
$LN5@SV_Downloa:

; 1832 : 	{
; 1833 : 		SV_FailDownload( cl, name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_FailDownload
	add	esp, 8

; 1834 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN4@SV_Downloa:

; 1835 : 	}
; 1836 : 
; 1837 : 	// g-cont. now we supports hot precache
; 1838 : 	if( name[0] != '!' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	je	$LN6@SV_Downloa

; 1839 : 	{
; 1840 : 		if( sv_send_resources.value )

	movss	xmm0, DWORD PTR _sv_send_resources+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN10@SV_Downloa

; 1841 : 		{
; 1842 : 			// also check the model textures
; 1843 : 			if( !Q_stricmp( COM_FileExtension( name ), "mdl" ))

	push	99999					; 0001869fH
	push	OFFSET $SG137243
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_Downloa

; 1844 : 			{
; 1845 : 				if( FS_FileExists( Mod_StudioTexName( name ), false ) > 0 )

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_StudioTexName
	add	esp, 4
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN9@SV_Downloa

; 1846 : 					Netchan_CreateFileFragments( &cl->netchan, Mod_StudioTexName( name ));

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Mod_StudioTexName
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_CreateFileFragments
	add	esp, 8
$LN9@SV_Downloa:

; 1847 : 			}
; 1848 : 
; 1849 : 			if( Netchan_CreateFileFragments( &cl->netchan, name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFileFragments
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@SV_Downloa

; 1850 : 			{
; 1851 : 				Netchan_FragSend( &cl->netchan );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_FragSend
	add	esp, 4

; 1852 : 				return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN10@SV_Downloa:

; 1853 : 			}
; 1854 : 		}
; 1855 : 
; 1856 : 		SV_FailDownload( cl, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FailDownload
	add	esp, 8

; 1857 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN6@SV_Downloa:

; 1858 : 	}
; 1859 : 
; 1860 : 	if( Q_strlen( name ) == 36 && !Q_strnicmp( name, "!MD5", 4 ) && sv_send_logos.value )

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jne	$LN11@SV_Downloa
	push	4
	push	OFFSET $SG137248
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@SV_Downloa
	movss	xmm0, DWORD PTR _sv_send_logos+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN11@SV_Downloa

; 1861 : 	{
; 1862 : 		resource_t	custResource;
; 1863 : 		byte		md5[32];
; 1864 : 		byte		*pbuf;
; 1865 : 		int		size;
; 1866 : 
; 1867 : 		memset( &custResource, 0, sizeof( custResource ) );

	push	136					; 00000088H
	push	0
	lea	ecx, DWORD PTR _custResource$3[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1868 : 		COM_HexConvert( name + 4, 32, md5 );

	lea	edx, DWORD PTR _md5$4[ebp]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 4
	push	eax
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 1869 : 
; 1870 : 		if( HPAK_ResourceForHash( CUSTOM_RES_PATH, md5, &custResource ))

	lea	ecx, DWORD PTR _custResource$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _md5$4[ebp]
	push	edx
	push	OFFSET $SG137250
	call	_HPAK_ResourceForHash
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN15@SV_Downloa

; 1871 : 		{
; 1872 : 			if( HPAK_GetDataPointer( CUSTOM_RES_PATH, &custResource, &pbuf, &size ))

	lea	eax, DWORD PTR _size$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _custResource$3[ebp]
	push	edx
	push	OFFSET $SG137252
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN15@SV_Downloa

; 1873 : 			{
; 1874 : 				if( size )

	cmp	DWORD PTR _size$2[ebp], 0
	je	SHORT $LN15@SV_Downloa

; 1875 : 				{
; 1876 : 					Netchan_CreateFileFragmentsFromBuffer( &cl->netchan, name, pbuf, size );

	mov	eax, DWORD PTR _size$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_CreateFileFragmentsFromBuffer
	add	esp, 16					; 00000010H

; 1877 : 					Netchan_FragSend( &cl->netchan );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_FragSend
	add	esp, 4

; 1878 : 					Mem_Free( pbuf );

	push	1878					; 00000756H
	push	OFFSET $SG137254
	mov	edx, DWORD PTR _pbuf$1[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN15@SV_Downloa:

; 1879 : 				}
; 1880 : 			}
; 1881 : 		}
; 1882 : 	}

	jmp	SHORT $LN12@SV_Downloa
$LN11@SV_Downloa:

; 1883 : 	else
; 1884 : 	{
; 1885 : 		SV_FailDownload( cl, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FailDownload
	add	esp, 8
$LN12@SV_Downloa:

; 1886 : 	}
; 1887 : 
; 1888 : 	return true;

	mov	eax, 1
$LN1@SV_Downloa:

; 1889 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DownloadFile_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_msg$ = -131096						; size = 20
_buffer$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_SendRes_f PROC

; 1793 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131096				; 00020018H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1794 : 	byte	buffer[MAX_INIT_MSG];
; 1795 : 	sizebuf_t	msg;
; 1796 : 
; 1797 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@SV_SendRes

; 1798 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_SendRes
$LN2@SV_SendRes:

; 1799 : 
; 1800 : 	MSG_Init( &msg, "SendResources", buffer, sizeof( buffer ));

	push	-1
	push	131072					; 00020000H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET $SG137225
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1801 : 
; 1802 : 	if( svs.maxclients > 1 && FBitSet( cl->flags, FCL_SEND_RESOURCES ))

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN3@SV_SendRes
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 512				; 00000200H
	je	SHORT $LN3@SV_SendRes

; 1803 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_SendRes
$LN3@SV_SendRes:

; 1804 : 
; 1805 : 	SetBits( cl->flags, FCL_SEND_RESOURCES );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 1806 : 	SV_SendResources( cl, &msg );

	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_SendResources
	add	esp, 8

; 1807 : 
; 1808 : 	Netchan_CreateFragments( &cl->netchan, &msg );

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_CreateFragments
	add	esp, 8

; 1809 : 	Netchan_FragSend( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_FragSend
	add	esp, 4

; 1810 : 
; 1811 : 	return true;

	mov	eax, 1
$LN1@SV_SendRes:

; 1812 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendRes_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Kill_f PROC

; 1772 : {

	push	ebp
	mov	ebp, esp

; 1773 : 	if( !SV_IsValidEdict( cl->edict ))

	push	1773					; 000006edH
	push	OFFSET $SG137215
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_Kill_f

; 1774 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Kill_f
$LN2@SV_Kill_f:

; 1775 : 
; 1776 : 	if( cl->edict->v.health <= 0.0f )

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+480]
	jb	SHORT $LN3@SV_Kill_f

; 1777 : 	{
; 1778 : 		SV_ClientPrintf( cl, "Can't suicide - already dead!\n");

	push	OFFSET $SG137217
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 8

; 1779 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Kill_f
$LN3@SV_Kill_f:

; 1780 : 	}
; 1781 : 
; 1782 : 	svgame.dllFuncs.pfnClientKill( cl->edict );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	push	eax
	call	DWORD PTR _svgame+19308
	add	esp, 4

; 1783 : 
; 1784 : 	return true;

	mov	eax, 1
$LN1@SV_Kill_f:

; 1785 : }

	pop	ebp
	ret	0
_SV_Kill_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_pEntity$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_Notarget_f PROC

; 1751 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1752 : 	edict_t	*pEntity = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 1753 : 
; 1754 : 	if( !Cvar_VariableInteger( "sv_cheats" ) || sv.background )

	push	OFFSET $SG137205
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_Notarge
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_Notarge
$LN3@SV_Notarge:

; 1755 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Notarge
$LN2@SV_Notarge:

; 1756 : 
; 1757 : 	pEntity->v.flags = pEntity->v.flags ^ FL_NOTARGET;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+548]
	xor	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+548], eax

; 1758 : 
; 1759 : 	if( !FBitSet( pEntity->v.flags, FL_NOTARGET ))

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 128				; 00000080H
	jne	SHORT $LN4@SV_Notarge

; 1760 : 		SV_ClientPrintf( cl, "notarget OFF\n" );

	push	OFFSET $SG137208
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 8
	jmp	SHORT $LN5@SV_Notarge
$LN4@SV_Notarge:

; 1761 : 	else SV_ClientPrintf( cl, "notarget ON\n" );

	push	OFFSET $SG137209
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_ClientPrintf
	add	esp, 8
$LN5@SV_Notarge:

; 1762 : 
; 1763 : 	return true;

	mov	eax, 1
$LN1@SV_Notarge:

; 1764 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Notarget_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_pEntity$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_Godmode_f PROC

; 1727 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1728 : 	edict_t	*pEntity = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 1729 : 
; 1730 : 	if( !Cvar_VariableInteger( "sv_cheats" ) || sv.background )

	push	OFFSET $SG137191
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_Godmode
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_Godmode
$LN3@SV_Godmode:

; 1731 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Godmode
$LN2@SV_Godmode:

; 1732 : 
; 1733 : 	pEntity->v.flags = pEntity->v.flags ^ FL_GODMODE;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+548]
	xor	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+548], eax

; 1734 : 	if( pEntity->v.takedamage == DAMAGE_AIM )

	mov	edx, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [edx+492]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_Godmode

; 1735 : 		pEntity->v.takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _pEntity$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+492], xmm0
	jmp	SHORT $LN5@SV_Godmode
$LN4@SV_Godmode:

; 1736 : 	else pEntity->v.takedamage = DAMAGE_AIM;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [ecx+492], xmm0
$LN5@SV_Godmode:

; 1737 : 
; 1738 : 	if( !FBitSet( pEntity->v.flags, FL_GODMODE ))

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 64					; 00000040H
	jne	SHORT $LN6@SV_Godmode

; 1739 : 		SV_ClientPrintf( cl, "godmode OFF\n" );

	push	OFFSET $SG137196
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 8
	jmp	SHORT $LN7@SV_Godmode
$LN6@SV_Godmode:

; 1740 : 	else SV_ClientPrintf( cl, "godmode ON\n" );

	push	OFFSET $SG137197
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_ClientPrintf
	add	esp, 8
$LN7@SV_Godmode:

; 1741 : 
; 1742 : 	return true;

	mov	eax, 1
$LN1@SV_Godmode:

; 1743 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Godmode_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_pEntity$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_Noclip_f PROC

; 1701 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1702 : 	edict_t	*pEntity = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 1703 : 
; 1704 : 	if( !Cvar_VariableInteger( "sv_cheats" ) || sv.background )

	push	OFFSET $SG137179
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_Noclip_
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_Noclip_
$LN3@SV_Noclip_:

; 1705 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Noclip_
$LN2@SV_Noclip_:

; 1706 : 
; 1707 : 	if( pEntity->v.movetype != MOVETYPE_NOCLIP )

	mov	edx, DWORD PTR _pEntity$[ebp]
	cmp	DWORD PTR [edx+392], 8
	je	SHORT $LN4@SV_Noclip_

; 1708 : 	{
; 1709 : 		SV_ClientPrintf( cl, "noclip ON\n" );

	push	OFFSET $SG137182
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8

; 1710 : 		pEntity->v.movetype = MOVETYPE_NOCLIP;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+392], 8

; 1711 : 	}

	jmp	SHORT $LN5@SV_Noclip_
$LN4@SV_Noclip_:

; 1712 : 	else
; 1713 : 	{
; 1714 : 		SV_ClientPrintf( cl, "noclip OFF\n" );

	push	OFFSET $SG137183
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_ClientPrintf
	add	esp, 8

; 1715 : 		pEntity->v.movetype =  MOVETYPE_WALK;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+392], 3
$LN5@SV_Noclip_:

; 1716 : 	}
; 1717 : 
; 1718 : 	return true;

	mov	eax, 1
$LN1@SV_Noclip_:

; 1719 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Noclip_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_SetInfo_f PROC

; 1687 : {

	push	ebp
	mov	ebp, esp

; 1688 : 	Info_SetValueForKey( cl->userinfo, Cmd_Argv( 1 ), Cmd_Argv( 2 ), MAX_INFO_STRING );

	push	256					; 00000100H
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1689 : 
; 1690 : 	if( cl->state >= cs_connected )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN2@SV_SetInfo

; 1691 : 		SetBits( cl->flags, FCL_RESEND_USERINFO ); // needs for update client info

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN2@SV_SetInfo:

; 1692 : 	return true;

	mov	eax, 1

; 1693 : }

	pop	ebp
	ret	0
_SV_SetInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_UpdateUserinfo_f PROC

; 1673 : {

	push	ebp
	mov	ebp, esp

; 1674 : 	Q_strncpy( cl->userinfo, Cmd_Argv( 1 ), sizeof( cl->userinfo ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1675 : 
; 1676 : 	if( cl->state >= cs_connected )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN2@SV_UpdateU

; 1677 : 		SetBits( cl->flags, FCL_RESEND_USERINFO ); // needs for update client info

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN2@SV_UpdateU:

; 1678 : 	return true;

	mov	eax, 1

; 1679 : }

	pop	ebp
	ret	0
_SV_UpdateUserinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_message$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_Pause_f PROC

; 1530 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1531 : 	string	message;
; 1532 : 
; 1533 : 	if( UI_CreditsActive( ))

	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN2@SV_Pause_f

; 1534 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Pause_f
$LN2@SV_Pause_f:

; 1535 : 
; 1536 : 	if( !sv_pausable->value )

	mov	eax, DWORD PTR _sv_pausable
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SV_Pause_f

; 1537 : 	{
; 1538 : 		SV_ClientPrintf( cl, "Pause not allowed.\n" );

	push	OFFSET $SG137096
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 8

; 1539 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Pause_f
$LN3@SV_Pause_f:

; 1540 : 	}
; 1541 : 
; 1542 : 	if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 256				; 00000100H
	je	SHORT $LN4@SV_Pause_f

; 1543 : 	{
; 1544 : 		SV_ClientPrintf( cl, "Spectators can not pause.\n" );

	push	OFFSET $SG137098
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ClientPrintf
	add	esp, 8

; 1545 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Pause_f
$LN4@SV_Pause_f:

; 1546 : 	}
; 1547 : 
; 1548 : 	if( !sv.paused ) Q_snprintf( message, MAX_STRING, "^2%s^7 paused the game\n", cl->name );

	cmp	DWORD PTR _sv+1359688, 0
	jne	SHORT $LN5@SV_Pause_f
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG137101
	push	256					; 00000100H
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN6@SV_Pause_f
$LN5@SV_Pause_f:

; 1549 : 	else Q_snprintf( message, MAX_STRING, "^2%s^7 unpaused the game\n", cl->name );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG137102
	push	256					; 00000100H
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN6@SV_Pause_f:

; 1550 : 
; 1551 : 	SV_TogglePause( message );

	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_SV_TogglePause
	add	esp, 4

; 1552 : 
; 1553 : 	return true;

	mov	eax, 1
$LN1@SV_Pause_f:

; 1554 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Pause_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_ShowServerinfo_f PROC

; 1519 : {

	push	ebp
	mov	ebp, esp

; 1520 : 	Info_Print( svs.serverinfo );

	push	OFFSET _svs+60
	call	_Info_Print
	add	esp, 4

; 1521 : 	return true;

	mov	eax, 1

; 1522 : }

	pop	ebp
	ret	0
_SV_ShowServerinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Disconnect_f PROC

; 1506 : {

	push	ebp
	mov	ebp, esp

; 1507 : 	SV_DropClient( cl, false );	

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 1508 : 	return true;

	mov	eax, 1

; 1509 : }

	pop	ebp
	ret	0
_SV_Disconnect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_msg$ = -131392						; size = 20
_i$ = -131372						; size = 4
_cur$ = -131368						; size = 4
_msg_buf$ = -131364					; size = 131072
_szAddress$ = -292					; size = 128
_szRejectReason$ = -164					; size = 128
_szName$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_New_f PROC

; 1443 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131392				; 00020140H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1444 : 	byte		msg_buf[MAX_INIT_MSG];
; 1445 : 	char		szRejectReason[128];
; 1446 : 	char		szAddress[128];
; 1447 : 	char		szName[32];
; 1448 : 	sv_client_t	*cur;
; 1449 : 	sizebuf_t		msg;
; 1450 : 	int		i;
; 1451 : 
; 1452 : 	MSG_Init( &msg, "New", msg_buf, sizeof( msg_buf ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _msg_buf$[ebp]
	push	eax
	push	OFFSET $SG137070
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1453 : 
; 1454 : 	if( cl->state != cs_connected )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 2
	je	SHORT $LN5@SV_New_f

; 1455 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_New_f
$LN5@SV_New_f:

; 1456 : 
; 1457 : 	// send the serverdata
; 1458 : 	SV_SendServerdata( &msg, cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_SV_SendServerdata
	add	esp, 8

; 1459 : 
; 1460 : 	// if the client was connected, tell the game .dll to disconnect him/her.
; 1461 : 	if(( cl->state == cs_spawned ) && cl->edict )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN6@SV_New_f
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264980], 0
	je	SHORT $LN6@SV_New_f

; 1462 : 		svgame.dllFuncs.pfnClientDisconnect( cl->edict );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	DWORD PTR _svgame+19304
	add	esp, 4
$LN6@SV_New_f:

; 1463 : 
; 1464 : 	Q_snprintf( szName, sizeof( szName ), "%s", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG137073
	push	32					; 00000020H
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1465 : 	Q_snprintf( szAddress, sizeof( szAddress ), "%s", NET_AdrToString( cl->netchan.remote_address ));

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG137074
	push	128					; 00000080H
	lea	eax, DWORD PTR _szAddress$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1466 : 	Q_snprintf( szRejectReason, sizeof( szRejectReason ), "Connection rejected by game\n");

	push	OFFSET $SG137075
	push	128					; 00000080H
	lea	ecx, DWORD PTR _szRejectReason$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 12					; 0000000cH

; 1467 : 
; 1468 : 	// Allow the game dll to reject this client.
; 1469 : 	if( !svgame.dllFuncs.pfnClientConnect( cl->edict, szName, szAddress, szRejectReason ))

	lea	edx, DWORD PTR _szRejectReason$[ebp]
	push	edx
	lea	eax, DWORD PTR _szAddress$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	push	eax
	call	DWORD PTR _svgame+19300
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN7@SV_New_f

; 1470 : 	{
; 1471 : 		// reject the connection and drop the client.
; 1472 : 		SV_RejectConnection( cl->netchan.remote_address, "%s\n", szRejectReason );

	lea	ecx, DWORD PTR _szRejectReason$[ebp]
	push	ecx
	push	OFFSET $SG137077
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_SV_RejectConnection
	add	esp, 28					; 0000001cH

; 1473 : 		SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 1474 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_New_f
$LN7@SV_New_f:

; 1475 : 	}
; 1476 : 
; 1477 : 	// server info string
; 1478 : 	MSG_BeginServerCmd( &msg, svc_stufftext );

	push	0
	push	1
	push	9
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1479 : 	MSG_WriteString( &msg, va( "fullserverinfo \"%s\"\n", SV_Serverinfo( )));

	call	_SV_Serverinfo
	push	eax
	push	OFFSET $SG137078
	call	_va
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 1480 : 
; 1481 : 	// collect the info about all the players and send to me
; 1482 : 	for( i = 0, cur = svs.clients; i < svs.maxclients; i++, cur++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@SV_New_f
$LN2@SV_New_f:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cur$[ebp], edx
$LN4@SV_New_f:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_New_f

; 1483 : 	{
; 1484 : 		if( !cur->edict || cur->state != cs_spawned )

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+264980], 0
	je	SHORT $LN9@SV_New_f
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx], 3
	je	SHORT $LN8@SV_New_f
$LN9@SV_New_f:

; 1485 : 			continue;	// not in game yet

	jmp	SHORT $LN2@SV_New_f
$LN8@SV_New_f:

; 1486 : 		SV_FullClientUpdate( cur, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_SV_FullClientUpdate
	add	esp, 8

; 1487 : 	}

	jmp	SHORT $LN2@SV_New_f
$LN3@SV_New_f:

; 1488 : 
; 1489 : 	// g-cont. why this is there?
; 1490 : 	memset( &cl->lastcmd, 0, sizeof( cl->lastcmd ));

	push	52					; 00000034H
	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264888				; 00040ab8H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1491 : 
; 1492 : 	Netchan_CreateFragments( &cl->netchan, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFragments
	add	esp, 8

; 1493 : 	Netchan_FragSend( &cl->netchan );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_FragSend
	add	esp, 4

; 1494 : 
; 1495 : 	return true;

	mov	eax, 1
$LN1@SV_New_f:

; 1496 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_New_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_dt$1 = -12						; size = 4
_fieldIndex$ = -8					; size = 4
_tableIndex$ = -4					; size = 4
_msg$ = 8						; size = 4
_SV_WriteDeltaDescriptionToClient PROC

; 1349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1350 : 	int	tableIndex;
; 1351 : 	int	fieldIndex;
; 1352 : 
; 1353 : 	for( tableIndex = 0; tableIndex < Delta_NumTables(); tableIndex++ )

	mov	DWORD PTR _tableIndex$[ebp], 0
	jmp	SHORT $LN4@SV_WriteDe
$LN2@SV_WriteDe:
	mov	eax, DWORD PTR _tableIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _tableIndex$[ebp], eax
$LN4@SV_WriteDe:
	call	_Delta_NumTables
	cmp	DWORD PTR _tableIndex$[ebp], eax
	jge	SHORT $LN1@SV_WriteDe

; 1354 : 	{
; 1355 : 		delta_info_t	*dt = Delta_FindStructByIndex( tableIndex );

	mov	ecx, DWORD PTR _tableIndex$[ebp]
	push	ecx
	call	_Delta_FindStructByIndex
	add	esp, 4
	mov	DWORD PTR _dt$1[ebp], eax

; 1356 : 
; 1357 : 		for( fieldIndex = 0; fieldIndex < dt->numFields; fieldIndex++ )

	mov	DWORD PTR _fieldIndex$[ebp], 0
	jmp	SHORT $LN7@SV_WriteDe
$LN5@SV_WriteDe:
	mov	edx, DWORD PTR _fieldIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _fieldIndex$[ebp], edx
$LN7@SV_WriteDe:
	mov	eax, DWORD PTR _dt$1[ebp]
	mov	ecx, DWORD PTR _fieldIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN6@SV_WriteDe

; 1358 : 			Delta_WriteTableField( msg, tableIndex, &dt->pFields[fieldIndex] );

	mov	edx, DWORD PTR _fieldIndex$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _dt$1[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR _tableIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_Delta_WriteTableField
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@SV_WriteDe
$LN6@SV_WriteDe:

; 1359 : 	}

	jmp	SHORT $LN2@SV_WriteDe
$LN1@SV_WriteDe:

; 1360 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WriteDeltaDescriptionToClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_viewEnt$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_UpdateClientView PROC

; 1298 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1299 : 	int	viewEnt;
; 1300 : 
; 1301 : 	if( cl->pViewEntity )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264984], 0
	je	SHORT $LN2@SV_UpdateC

; 1302 : 		viewEnt = NUM_FOR_EDICT( cl->pViewEntity );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [ecx+264984]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
	jmp	SHORT $LN3@SV_UpdateC
$LN2@SV_UpdateC:

; 1303 : 	else viewEnt = NUM_FOR_EDICT( cl->edict );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
$LN3@SV_UpdateC:

; 1304 : 
; 1305 : 	MSG_BeginServerCmd( &cl->netchan.message, svc_setview );

	push	0
	push	1
	push	5
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1306 : 	MSG_WriteWord( &cl->netchan.message, viewEnt );

	mov	eax, DWORD PTR _viewEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 1307 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UpdateClientView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_viewEnt$1 = -1688					; size = 4
_msg$ = -1684						; size = 20
_i$2 = -1664						; size = 4
_ent$ = -1660						; size = 4
_levelData$3 = -1656					; size = 1396
_name$4 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_PutClientInServer PROC

; 1165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1688				; 00000698H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1166 : 	static byte    	msg_buf[0x20200];	// MAX_INIT_MSG + some space
; 1167 : 	edict_t		*ent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _ent$[ebp], ecx

; 1168 : 	sizebuf_t		msg;
; 1169 : 
; 1170 : 	MSG_Init( &msg, "Spawn", msg_buf, sizeof( msg_buf ));

	push	-1
	push	131584					; 00020200H
	push	OFFSET ?msg_buf@?1??SV_PutClientInServer@@9@9
	push	OFFSET $SG136969
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1171 : 
; 1172 : 	if( sv.loadgame )

	cmp	DWORD PTR _sv+8, 0
	je	$LN5@SV_PutClie

; 1173 : 	{
; 1174 : 		// NOTE: we needs to setup angles on restore here
; 1175 : 		if( ent->v.fixangle == 1 )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+288], 1
	jne	SHORT $LN7@SV_PutClie

; 1176 : 		{
; 1177 : 			MSG_BeginServerCmd( &msg, svc_setangle );

	push	0
	push	1
	push	10					; 0000000aH
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1178 : 			MSG_WriteVec3Angles( &msg, ent->v.angles );

	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 208				; 000000d0H
	push	edx
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteVec3Angles
	add	esp, 8

; 1179 : 			ent->v.fixangle = 0;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+288], 0
$LN7@SV_PutClie:

; 1180 : 		}
; 1181 : 
; 1182 : 		if( svgame.dllFuncs.pfnParmsChangeLevel )

	cmp	DWORD PTR _svgame+19348, 0
	je	$LN8@SV_PutClie

; 1183 : 		{
; 1184 : 			SAVERESTOREDATA	levelData;
; 1185 : 			string		name;
; 1186 : 			int		i;
; 1187 : 
; 1188 : 			memset( &levelData, 0, sizeof( levelData ));

	push	1396					; 00000574H
	push	0
	lea	edx, DWORD PTR _levelData$3[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1189 : 			svgame.globals->pSaveData = &levelData;

	mov	eax, DWORD PTR _svgame+19236
	lea	ecx, DWORD PTR _levelData$3[ebp]
	mov	DWORD PTR [eax+156], ecx

; 1190 : 			svgame.dllFuncs.pfnParmsChangeLevel();

	call	DWORD PTR _svgame+19348

; 1191 : 
; 1192 : 			MSG_BeginServerCmd( &msg, svc_restore );

	push	0
	push	1
	push	33					; 00000021H
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1193 : 			Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, sv.name );

	push	OFFSET _sv+56
	push	OFFSET $SG136974
	push	OFFSET $SG136975
	push	256					; 00000100H
	lea	eax, DWORD PTR _name$4[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1194 : 			COM_FixSlashes( name );

	lea	ecx, DWORD PTR _name$4[ebp]
	push	ecx
	call	_COM_FixSlashes
	add	esp, 4

; 1195 : 			MSG_WriteString( &msg, name );

	lea	edx, DWORD PTR _name$4[ebp]
	push	edx
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1196 : 			MSG_WriteByte( &msg, levelData.connectionCount );

	mov	ecx, DWORD PTR _levelData$3[ebp+36]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 1197 : 
; 1198 : 			for( i = 0; i < levelData.connectionCount; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SV_PutClie
$LN2@SV_PutClie:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SV_PutClie:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _levelData$3[ebp+36]
	jge	SHORT $LN3@SV_PutClie

; 1199 : 				MSG_WriteString( &msg, levelData.levelList[i].mapName );

	imul	edx, DWORD PTR _i$2[ebp], 80
	lea	eax, DWORD PTR _levelData$3[ebp+edx+44]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8
	jmp	SHORT $LN2@SV_PutClie
$LN3@SV_PutClie:

; 1200 : 
; 1201 : 			svgame.globals->pSaveData = NULL;

	mov	edx, DWORD PTR _svgame+19236
	mov	DWORD PTR [edx+156], 0
$LN8@SV_PutClie:

; 1202 : 		}
; 1203 : 
; 1204 : 		// reset weaponanim
; 1205 : 		MSG_BeginServerCmd( &msg, svc_weaponanim );

	push	0
	push	1
	push	35					; 00000023H
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1206 : 		MSG_WriteByte( &msg, 0 );

	push	0
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 1207 : 		MSG_WriteByte( &msg, 0 );

	push	0
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 1208 : 
; 1209 : 		sv.loadgame = false;

	mov	DWORD PTR _sv+8, 0

; 1210 : 		sv.paused = false;

	mov	DWORD PTR _sv+1359688, 0

; 1211 : 	}

	jmp	$LN6@SV_PutClie
$LN5@SV_PutClie:

; 1212 : 	else
; 1213 : 	{	
; 1214 : 		if( Q_atoi( Info_ValueForKey( cl->userinfo, "hltv" )))

	push	OFFSET $SG136977
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@SV_PutClie

; 1215 : 			SetBits( cl->flags, FCL_HLTV_PROXY );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx
$LN9@SV_PutClie:

; 1216 : 
; 1217 : 		// need to realloc private data for client
; 1218 : 		SV_InitEdict( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_InitEdict
	add	esp, 4

; 1219 : 
; 1220 : 		if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 256				; 00000100H
	je	SHORT $LN10@SV_PutClie

; 1221 : 			SetBits( ent->v.flags, FL_PROXY );

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	or	edx, 1048576				; 00100000H
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+548], edx
	jmp	SHORT $LN11@SV_PutClie
$LN10@SV_PutClie:

; 1222 : 		else ent->v.flags = 0;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+548], 0
$LN11@SV_PutClie:

; 1223 : 
; 1224 : 		ent->v.netname = MAKE_STRING( cl->name );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+592], eax

; 1225 : 		ent->v.colormap = NUM_FOR_EDICT( ent );	// ???

	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+552], eax

; 1226 : 
; 1227 : 		// fisrt entering
; 1228 : 		svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19236
	movss	DWORD PTR [eax], xmm0

; 1229 : 		svgame.dllFuncs.pfnClientPutInServer( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 4

; 1230 : 
; 1231 : 		if( sv.background )	// don't attack player in background mode

	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN12@SV_PutClie

; 1232 : 			SetBits( ent->v.flags, FL_GODMODE|FL_NOTARGET );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	or	eax, 192				; 000000c0H
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+548], eax
$LN12@SV_PutClie:

; 1233 : 
; 1234 : 		cl->pViewEntity = NULL; // reset pViewEntity

	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+264984], 0
$LN6@SV_PutClie:

; 1235 : 	}
; 1236 : 
; 1237 : 	if( svgame.globals->cdAudioTrack )

	mov	eax, DWORD PTR _svgame+19236
	cmp	DWORD PTR [eax+140], 0
	je	SHORT $LN13@SV_PutClie

; 1238 : 	{
; 1239 : 		MSG_BeginServerCmd( &msg, svc_stufftext );

	push	0
	push	1
	push	9
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1240 : 		MSG_WriteString( &msg, va( "cd loop %3d\n", svgame.globals->cdAudioTrack ));

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR [edx+140]
	push	eax
	push	OFFSET $SG136982
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1241 : 		svgame.globals->cdAudioTrack = 0;

	mov	edx, DWORD PTR _svgame+19236
	mov	DWORD PTR [edx+140], 0
$LN13@SV_PutClie:

; 1242 : 	}
; 1243 : 
; 1244 : #ifdef HACKS_RELATED_HLMODS
; 1245 : 	// enable dev-mode to prevent crash cheat-protecting from Invasion mod
; 1246 : 	if( FBitSet( ent->v.flags, FL_GODMODE|FL_NOTARGET ) && !Q_stricmp( GI->gamefolder, "invasion" ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 192				; 000000c0H
	je	SHORT $LN14@SV_PutClie
	push	99999					; 0001869fH
	push	OFFSET $SG136984
	mov	edx, DWORD PTR _SI+768
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_PutClie

; 1247 : 		SV_ExecuteClientCommand( cl, "test\n" );

	push	OFFSET $SG136985
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ExecuteClientCommand
	add	esp, 8
$LN14@SV_PutClie:

; 1248 : #endif
; 1249 : 	// refresh the userinfo and movevars
; 1250 : 	// NOTE: because movevars can be changed during the connection process
; 1251 : 	SetBits( cl->flags, FCL_RESEND_USERINFO|FCL_RESEND_MOVEVARS );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	or	edx, 3
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx

; 1252 : 
; 1253 : 	// reset client times
; 1254 : 	cl->connecttime = 0.0;

	mov	ecx, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [ecx+264944], xmm0

; 1255 : 	cl->ignorecmdtime = 0.0;

	mov	edx, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [edx+264960], xmm0

; 1256 : 	cl->cmdtime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264952], xmm0

; 1257 : 
; 1258 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	jne	$LN19@SV_PutClie

; 1259 : 	{
; 1260 : 		int	viewEnt;
; 1261 : 
; 1262 : 		// NOTE: it's will be fragmented automatically in right ordering
; 1263 : 		MSG_WriteBits( &msg, MSG_GetData( &sv.signon ), MSG_GetNumBitsWritten( &sv.signon ));

	push	OFFSET _sv+1220372
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1220372
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 1264 : 
; 1265 : 		if( cl->pViewEntity )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+264984], 0
	je	SHORT $LN16@SV_PutClie

; 1266 : 			viewEnt = NUM_FOR_EDICT( cl->pViewEntity );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264984]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _viewEnt$1[ebp], eax
	jmp	SHORT $LN17@SV_PutClie
$LN16@SV_PutClie:

; 1267 : 		else viewEnt = NUM_FOR_EDICT( cl->edict );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _viewEnt$1[ebp], eax
$LN17@SV_PutClie:

; 1268 : 
; 1269 : 		MSG_BeginServerCmd( &msg, svc_setview );

	push	0
	push	1
	push	5
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1270 : 		MSG_WriteWord( &msg, viewEnt );

	mov	eax, DWORD PTR _viewEnt$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 1271 : 
; 1272 : 		MSG_BeginServerCmd( &msg, svc_signonnum );

	push	0
	push	1
	push	25					; 00000019H
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1273 : 		MSG_WriteByte( &msg, 1 );

	push	1
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 1274 : 
; 1275 : 		if( MSG_CheckOverflow( &msg ))

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@SV_PutClie

; 1276 : 		{
; 1277 : 			if( svs.maxclients == 1 )

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN20@SV_PutClie

; 1278 : 				Host_Error( "spawn player: overflowed\n" );

	push	OFFSET $SG136993
	call	_Host_Error
	add	esp, 4
	jmp	SHORT $LN21@SV_PutClie
$LN20@SV_PutClie:

; 1279 : 			else SV_DropClient( cl, false );

	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_DropClient
	add	esp, 8
$LN21@SV_PutClie:

; 1280 : 		}

	jmp	SHORT $LN19@SV_PutClie
$LN18@SV_PutClie:

; 1281 : 		else
; 1282 : 		{
; 1283 : 			// send initialization data
; 1284 : 			Netchan_CreateFragments( &cl->netchan, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFragments
	add	esp, 8

; 1285 : 			Netchan_FragSend( &cl->netchan );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_FragSend
	add	esp, 4
$LN19@SV_PutClie:

; 1286 : 		}
; 1287 : 	}
; 1288 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PutClientInServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
tv192 = -52						; size = 8
tv91 = -44						; size = 4
_frame$1 = -40						; size = 4
tv70 = -36						; size = 4
tv67 = -32						; size = 4
_minping$ = -28						; size = 4
_maxping$ = -24						; size = 4
_count$ = -20						; size = 4
_ping$ = -16						; size = 4
_frame$2 = -12						; size = 4
_backtrack$ = -8					; size = 4
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_CalcClientTime PROC

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 967  : 	float	minping, maxping;
; 968  : 	float	ping = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _ping$[ebp], xmm0

; 969  : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 970  : 	int	backtrack;
; 971  : 
; 972  : 	backtrack = (int)sv_unlagsamples.value;

	cvttss2si eax, DWORD PTR _sv_unlagsamples+12
	mov	DWORD PTR _backtrack$[ebp], eax

; 973  : 	if( backtrack < 1 ) backtrack = 1;

	cmp	DWORD PTR _backtrack$[ebp], 1
	jge	SHORT $LN8@SV_CalcCli
	mov	DWORD PTR _backtrack$[ebp], 1
$LN8@SV_CalcCli:

; 974  : 
; 975  : 	if( backtrack >= (SV_UPDATE_BACKUP <= 16 ? SV_UPDATE_BACKUP : 16 ))

	cmp	DWORD PTR _SV_UPDATE_BACKUP, 16		; 00000010H
	jg	SHORT $LN19@SV_CalcCli
	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN20@SV_CalcCli
$LN19@SV_CalcCli:
	mov	DWORD PTR tv67[ebp], 16			; 00000010H
$LN20@SV_CalcCli:
	mov	edx, DWORD PTR _backtrack$[ebp]
	cmp	edx, DWORD PTR tv67[ebp]
	jl	SHORT $LN9@SV_CalcCli

; 976  : 		backtrack = ( SV_UPDATE_BACKUP <= 16 ? SV_UPDATE_BACKUP : 16 );

	cmp	DWORD PTR _SV_UPDATE_BACKUP, 16		; 00000010H
	jg	SHORT $LN21@SV_CalcCli
	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN22@SV_CalcCli
$LN21@SV_CalcCli:
	mov	DWORD PTR tv70[ebp], 16			; 00000010H
$LN22@SV_CalcCli:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _backtrack$[ebp], ecx
$LN9@SV_CalcCli:

; 977  : 
; 978  : 	if( backtrack <= 0 )

	cmp	DWORD PTR _backtrack$[ebp], 0
	jg	SHORT $LN10@SV_CalcCli

; 979  : 		return 0.0f;

	fldz
	jmp	$LN1@SV_CalcCli
$LN10@SV_CalcCli:

; 980  : 
; 981  : 	for( i = 0; i < backtrack; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CalcCli
$LN2@SV_CalcCli:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_CalcCli:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _backtrack$[ebp]
	jge	SHORT $LN3@SV_CalcCli

; 982  : 	{
; 983  : 		client_frame_t	*frame = &cl->frames[SV_UPDATE_MASK & (cl->netchan.incoming_acknowledged - i)];

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+628]
	sub	eax, DWORD PTR _i$[ebp]
	and	ecx, eax
	imul	ecx, ecx, 6128
	mov	edx, DWORD PTR _cl$[ebp]
	add	ecx, DWORD PTR [edx+281916]
	mov	DWORD PTR _frame$1[ebp], ecx

; 984  : 		if( frame->ping_time <= 0.0f )

	mov	eax, DWORD PTR _frame$1[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+8]
	jb	SHORT $LN11@SV_CalcCli

; 985  : 			continue;

	jmp	SHORT $LN2@SV_CalcCli
$LN11@SV_CalcCli:

; 986  : 
; 987  : 		ping += frame->ping_time;

	mov	ecx, DWORD PTR _frame$1[ebp]
	movss	xmm0, DWORD PTR _ping$[ebp]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR _ping$[ebp], xmm0

; 988  : 		count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 989  : 	}

	jmp	SHORT $LN2@SV_CalcCli
$LN3@SV_CalcCli:

; 990  : 
; 991  : 	if( !count ) return 0.0f;

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN12@SV_CalcCli
	fldz
	jmp	$LN1@SV_CalcCli
$LN12@SV_CalcCli:

; 992  : 
; 993  : 	minping =  9999.0f;

	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR _minping$[ebp], xmm0

; 994  : 	maxping = -9999.0f;

	movss	xmm0, DWORD PTR __real@c61c3c00
	movss	DWORD PTR _maxping$[ebp], xmm0

; 995  : 	ping /= count;

	cvtsi2ss xmm0, DWORD PTR _count$[ebp]
	movss	xmm1, DWORD PTR _ping$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _ping$[ebp], xmm1

; 996  : 	
; 997  : 	for( i = 0; i < ( SV_UPDATE_BACKUP <= 4 ? SV_UPDATE_BACKUP : 4 ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_CalcCli
$LN5@SV_CalcCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_CalcCli:
	cmp	DWORD PTR _SV_UPDATE_BACKUP, 4
	jg	SHORT $LN23@SV_CalcCli
	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	mov	DWORD PTR tv91[ebp], ecx
	jmp	SHORT $LN24@SV_CalcCli
$LN23@SV_CalcCli:
	mov	DWORD PTR tv91[ebp], 4
$LN24@SV_CalcCli:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR tv91[ebp]
	jge	SHORT $LN6@SV_CalcCli

; 998  : 	{
; 999  : 		client_frame_t	*frame = &cl->frames[SV_UPDATE_MASK & (cl->netchan.incoming_acknowledged - i)];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	sub	edx, DWORD PTR _i$[ebp]
	and	eax, edx
	imul	eax, eax, 6128
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+281916]
	mov	DWORD PTR _frame$2[ebp], eax

; 1000 : 		if( frame->ping_time <= 0.0f )

	mov	edx, DWORD PTR _frame$2[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+8]
	jb	SHORT $LN13@SV_CalcCli

; 1001 : 			continue;

	jmp	SHORT $LN5@SV_CalcCli
$LN13@SV_CalcCli:

; 1002 : 
; 1003 : 		if( frame->ping_time < minping )

	mov	eax, DWORD PTR _frame$2[ebp]
	movss	xmm0, DWORD PTR _minping$[ebp]
	comiss	xmm0, DWORD PTR [eax+8]
	jbe	SHORT $LN14@SV_CalcCli

; 1004 : 			minping = frame->ping_time;

	mov	ecx, DWORD PTR _frame$2[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR _minping$[ebp], xmm0
$LN14@SV_CalcCli:

; 1005 : 
; 1006 : 		if( frame->ping_time > maxping )

	mov	edx, DWORD PTR _frame$2[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR _maxping$[ebp]
	jbe	SHORT $LN15@SV_CalcCli

; 1007 : 			maxping = frame->ping_time;

	mov	eax, DWORD PTR _frame$2[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _maxping$[ebp], xmm0
$LN15@SV_CalcCli:

; 1008 : 	}

	jmp	$LN5@SV_CalcCli
$LN6@SV_CalcCli:

; 1009 : 
; 1010 : 	if( maxping < minping || fabs( maxping - minping ) <= 0.2f )

	movss	xmm0, DWORD PTR _minping$[ebp]
	comiss	xmm0, DWORD PTR _maxping$[ebp]
	ja	SHORT $LN17@SV_CalcCli
	movss	xmm0, DWORD PTR _maxping$[ebp]
	subss	xmm0, DWORD PTR _minping$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv192[ebp]
	movsd	xmm0, QWORD PTR __real@3fc99999a0000000
	comisd	xmm0, QWORD PTR tv192[ebp]
	jb	SHORT $LN16@SV_CalcCli
$LN17@SV_CalcCli:

; 1011 : 		return ping;

	fld	DWORD PTR _ping$[ebp]
	jmp	SHORT $LN1@SV_CalcCli
$LN16@SV_CalcCli:

; 1012 : 
; 1013 : 	return 0.0f;

	fldz
$LN1@SV_CalcCli:

; 1014 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CalcClientTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_runcmd_time$ = -16					; size = 8
_cmdnum$ = -8						; size = 4
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_cmds$ = 12						; size = 4
_dropped$ = 16						; size = 4
_numbackup$ = 20					; size = 4
_numcmds$ = 24						; size = 4
_SV_EstablishTimeBase PROC

; 932  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 933  : 	double	runcmd_time = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0

; 934  : 	int	i, cmdnum = dropped;

	mov	eax, DWORD PTR _dropped$[ebp]
	mov	DWORD PTR _cmdnum$[ebp], eax

; 935  : 
; 936  : 	if( dropped < 24 )

	cmp	DWORD PTR _dropped$[ebp], 24		; 00000018H
	jge	SHORT $LN5@SV_Establi
$LN2@SV_Establi:

; 937  : 	{
; 938  : 		while( dropped > numbackup )

	mov	ecx, DWORD PTR _dropped$[ebp]
	cmp	ecx, DWORD PTR _numbackup$[ebp]
	jle	SHORT $LN3@SV_Establi

; 939  : 		{
; 940  : 			runcmd_time = (double)cl->lastcmd.msec / 1000.0;

	mov	edx, DWORD PTR _cl$[ebp]
	movzx	eax, BYTE PTR [edx+264890]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0

; 941  : 			dropped--;

	mov	ecx, DWORD PTR _dropped$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _dropped$[ebp], ecx

; 942  : 		}

	jmp	SHORT $LN2@SV_Establi
$LN3@SV_Establi:

; 943  : 
; 944  : 		while( dropped > 0 )

	cmp	DWORD PTR _dropped$[ebp], 0
	jle	SHORT $LN5@SV_Establi

; 945  : 		{
; 946  : 			cmdnum = dropped + numcmds - 1;

	mov	edx, DWORD PTR _numcmds$[ebp]
	mov	eax, DWORD PTR _dropped$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	mov	DWORD PTR _cmdnum$[ebp], ecx

; 947  : 			runcmd_time += (double)cmds[cmdnum].msec / 1000.0;

	imul	edx, DWORD PTR _cmdnum$[ebp], 52
	mov	eax, DWORD PTR _cmds$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR _runcmd_time$[ebp]
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0

; 948  : 			dropped--;

	mov	edx, DWORD PTR _dropped$[ebp]
	sub	edx, 1
	mov	DWORD PTR _dropped$[ebp], edx

; 949  : 		}		

	jmp	SHORT $LN3@SV_Establi
$LN5@SV_Establi:

; 950  : 	}
; 951  : 
; 952  : 	for( i = numcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN8@SV_Establi
$LN6@SV_Establi:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN8@SV_Establi:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN7@SV_Establi

; 953  : 		runcmd_time += cmds[i].msec / 1000.0;

	imul	edx, DWORD PTR _i$[ebp], 52
	mov	eax, DWORD PTR _cmds$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR _runcmd_time$[ebp]
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0
	jmp	SHORT $LN6@SV_Establi
$LN7@SV_Establi:

; 954  : 
; 955  : 	cl->timebase = sv.time + sv.frametime - runcmd_time;

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _sv+16
	subsd	xmm0, QWORD PTR _runcmd_time$[ebp]
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [edx+264400], xmm0

; 956  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EstablishTimeBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_Rcon_Validate PROC

; 838  : {

	push	ebp
	mov	ebp, esp

; 839  : 	if( !Q_strlen( rcon_password.string ))

	mov	eax, DWORD PTR _rcon_password+4
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Rcon_Valid

; 840  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Rcon_Valid
$LN2@Rcon_Valid:

; 841  : 	if( Q_strcmp( Cmd_Argv( 1 ), rcon_password.string ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _rcon_password+4
	push	ecx
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@Rcon_Valid

; 842  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Rcon_Valid
$LN3@Rcon_Valid:

; 843  : 	return true;

	mov	eax, 1
$LN1@Rcon_Valid:

; 844  : }

	pop	ebp
	ret	0
_Rcon_Validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_from$ = 8						; size = 20
_SV_Ping PROC

; 828  : {

	push	ebp
	mov	ebp, esp

; 829  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "ack" );

	push	OFFSET $SG136792
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 830  : }

	pop	ebp
	ret	0
_SV_Ping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_ed$1 = -816						; size = 4
_time$2 = -812						; size = 4
_version$ = -808					; size = 4
$T3 = -804						; size = 4
$T4 = -800						; size = 4
$T5 = -796						; size = 4
$T6 = -792						; size = 4
_context$ = -788					; size = 4
_count$ = -784						; size = 4
_type$ = -780						; size = 4
_i$ = -776						; size = 4
_answer$ = -772						; size = 512
_string$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_BuildNetAnswer PROC

; 737  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 816				; 00000330H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 738  : 	char	string[MAX_INFO_STRING], answer[512];
; 739  : 	int	version, context, type;
; 740  : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 741  : 
; 742  : 	// ignore in single player
; 743  : 	if( svs.maxclients == 1 || !svs.initialized )

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN9@SV_BuildNe
	cmp	DWORD PTR _svs, 0
	jne	SHORT $LN8@SV_BuildNe
$LN9@SV_BuildNe:

; 744  : 		return;

	jmp	$LN19@SV_BuildNe
$LN8@SV_BuildNe:

; 745  : 
; 746  : 	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 747  : 	context = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _context$[ebp], eax

; 748  : 	type = Q_atoi( Cmd_Argv( 3 ));

	push	3
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 749  : 
; 750  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	$LN10@SV_BuildNe

; 751  : 	{
; 752  : 		// handle the unsupported protocol
; 753  : 		string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 256			; 00000100H
	jae	SHORT $LN22@SV_BuildNe
	jmp	SHORT $LN23@SV_BuildNe
$LN22@SV_BuildNe:
	call	___report_rangecheckfailure
$LN23@SV_BuildNe:
	mov	edx, DWORD PTR $T6[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 754  : 		Info_SetValueForKey( string, "neterror", "protocol", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG136759
	push	OFFSET $SG136760
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 755  : 
; 756  : 		// send error unsupported protocol
; 757  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET $SG136761
	push	512					; 00000200H
	lea	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 758  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 759  : 		return;

	jmp	$LN19@SV_BuildNe
$LN10@SV_BuildNe:

; 760  : 	}
; 761  : 
; 762  : 	if( type == NETAPI_REQUEST_PING )

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN11@SV_BuildNe

; 763  : 	{
; 764  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, "" );

	push	OFFSET $SG136764
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET $SG136765
	push	512					; 00000200H
	lea	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 765  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 766  : 	}

	jmp	$LN19@SV_BuildNe
$LN11@SV_BuildNe:

; 767  : 	else if( type == NETAPI_REQUEST_RULES )

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN13@SV_BuildNe

; 768  : 	{
; 769  : 		// send serverinfo
; 770  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, svs.serverinfo );

	push	OFFSET _svs+60
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET $SG136768
	push	512					; 00000200H
	lea	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 771  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 772  : 	}

	jmp	$LN19@SV_BuildNe
$LN13@SV_BuildNe:

; 773  : 	else if( type == NETAPI_REQUEST_PLAYERS )

	cmp	DWORD PTR _type$[ebp], 3
	jne	$LN15@SV_BuildNe

; 774  : 	{
; 775  : 		string[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 256			; 00000100H
	jae	SHORT $LN24@SV_BuildNe
	jmp	SHORT $LN25@SV_BuildNe
$LN24@SV_BuildNe:
	call	___report_rangecheckfailure
$LN25@SV_BuildNe:
	mov	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _string$[ebp+ecx], 0

; 776  : 
; 777  : 		for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_BuildNe
$LN2@SV_BuildNe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_BuildNe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_BuildNe

; 778  : 		{
; 779  : 			if( svs.clients[i].state >= cs_connected )

	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 2
	jl	$LN17@SV_BuildNe

; 780  : 			{
; 781  : 				edict_t *ed = svs.clients[i].edict;

	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	edx, DWORD PTR [ecx+eax+264980]
	mov	DWORD PTR _ed$1[ebp], edx

; 782  : 				float time = host.realtime - svs.clients[i].connection_started;

	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx+eax+264408]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _time$2[ebp], xmm0

; 783  : 				Q_strncat( string, va( "%c\\%s\\%i\\%f\\", count, svs.clients[i].name, (int)ed->v.frags, time ), sizeof( string )); 

	push	256					; 00000100H
	cvtss2sd xmm0, DWORD PTR _time$2[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ed$1[ebp]
	cvttss2si eax, DWORD PTR [edx+484]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	lea	eax, DWORD PTR [edx+ecx+8]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	OFFSET $SG136772
	call	_va
	add	esp, 24					; 00000018H
	push	eax
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 784  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN17@SV_BuildNe:

; 785  : 			}
; 786  : 		}

	jmp	$LN2@SV_BuildNe
$LN3@SV_BuildNe:

; 787  : 
; 788  : 		// send playernames
; 789  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET $SG136773
	push	512					; 00000200H
	lea	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 790  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 791  : 	}

	jmp	$LN19@SV_BuildNe
$LN15@SV_BuildNe:

; 792  : 	else if( type == NETAPI_REQUEST_DETAILS )

	cmp	DWORD PTR _type$[ebp], 4
	jne	$LN18@SV_BuildNe

; 793  : 	{
; 794  : 		for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_BuildNe
$LN5@SV_BuildNe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@SV_BuildNe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_BuildNe

; 795  : 			if( svs.clients[i].state >= cs_connected )

	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 2
	jl	SHORT $LN20@SV_BuildNe

; 796  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN20@SV_BuildNe:
	jmp	SHORT $LN5@SV_BuildNe
$LN6@SV_BuildNe:

; 797  : 
; 798  : 		string[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN26@SV_BuildNe
	jmp	SHORT $LN27@SV_BuildNe
$LN26@SV_BuildNe:
	call	___report_rangecheckfailure
$LN27@SV_BuildNe:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _string$[ebp+eax], 0

; 799  : 		Info_SetValueForKey( string, "hostname", hostname.string, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _hostname+4
	push	ecx
	push	OFFSET $SG136777
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 800  : 		Info_SetValueForKey( string, "gamedir", GI->gamefolder, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _SI+768
	push	eax
	push	OFFSET $SG136778
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 801  : 		Info_SetValueForKey( string, "current", va( "%i", count ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	push	OFFSET $SG136779
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136780
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 802  : 		Info_SetValueForKey( string, "max", va( "%i", svs.maxclients ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _svs+16
	push	ecx
	push	OFFSET $SG136781
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136782
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 803  : 		Info_SetValueForKey( string, "map", sv.name, MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET _sv+56
	push	OFFSET $SG136783
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 804  : 
; 805  : 		// send serverinfo
; 806  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET $SG136784
	push	512					; 00000200H
	lea	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 807  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 808  : 	}

	jmp	$LN19@SV_BuildNe
$LN18@SV_BuildNe:

; 809  : 	else
; 810  : 	{
; 811  : 		string[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 256			; 00000100H
	jae	SHORT $LN28@SV_BuildNe
	jmp	SHORT $LN29@SV_BuildNe
$LN28@SV_BuildNe:
	call	___report_rangecheckfailure
$LN29@SV_BuildNe:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _string$[ebp+ecx], 0

; 812  : 		Info_SetValueForKey( string, "neterror", "undefined", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG136785
	push	OFFSET $SG136786
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 813  : 
; 814  : 		// send error undefined request type
; 815  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _context$[ebp]
	push	edx
	push	OFFSET $SG136787
	push	512					; 00000200H
	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 816  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH
$LN19@SV_BuildNe:

; 817  : 	}
; 818  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BuildNetAnswer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_version$ = -276					; size = 4
$T1 = -272						; size = 4
_count$ = -268						; size = 4
_i$ = -264						; size = 4
_string$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_Info PROC

; 694  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 695  : 	char	string[MAX_INFO_STRING];
; 696  : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 697  : 	int	version;
; 698  : 
; 699  : 	// ignore in single player
; 700  : 	if( svs.maxclients == 1 || !svs.initialized )

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN6@SV_Info
	cmp	DWORD PTR _svs, 0
	jne	SHORT $LN5@SV_Info
$LN6@SV_Info:

; 701  : 		return;

	jmp	$LN1@SV_Info
$LN5@SV_Info:

; 702  : 
; 703  : 	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 704  : 	string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN11@SV_Info
	jmp	SHORT $LN12@SV_Info
$LN11@SV_Info:
	call	___report_rangecheckfailure
$LN12@SV_Info:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 705  : 
; 706  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	SHORT $LN7@SV_Info

; 707  : 	{
; 708  : 		Q_snprintf( string, sizeof( string ), "%s: wrong version\n", hostname.string );

	mov	eax, DWORD PTR _hostname+4
	push	eax
	push	OFFSET $SG136716
	push	256					; 00000100H
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 709  : 	}

	jmp	$LN8@SV_Info
$LN7@SV_Info:

; 710  : 	else
; 711  : 	{
; 712  : 		for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Info
$LN2@SV_Info:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_Info:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_Info

; 713  : 			if( svs.clients[i].state >= cs_connected )

	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 2
	jl	SHORT $LN9@SV_Info

; 714  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN9@SV_Info:
	jmp	SHORT $LN2@SV_Info
$LN3@SV_Info:

; 715  : 
; 716  : 		Info_SetValueForKey( string, "host", hostname.string, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _hostname+4
	push	ecx
	push	OFFSET $SG136718
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 717  : 		Info_SetValueForKey( string, "map", sv.name, MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET _sv+56
	push	OFFSET $SG136719
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 718  : 		Info_SetValueForKey( string, "dm", va( "%i", (int)svgame.globals->deathmatch ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _svgame+19236
	cvttss2si edx, DWORD PTR [ecx+20]
	push	edx
	push	OFFSET $SG136720
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136721
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 719  : 		Info_SetValueForKey( string, "team", va( "%i", (int)svgame.globals->teamplay ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _svgame+19236
	cvttss2si edx, DWORD PTR [ecx+28]
	push	edx
	push	OFFSET $SG136722
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136723
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 720  : 		Info_SetValueForKey( string, "coop", va( "%i", (int)svgame.globals->coop ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _svgame+19236
	cvttss2si edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET $SG136724
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136725
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 721  : 		Info_SetValueForKey( string, "numcl", va( "%i", count ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	OFFSET $SG136726
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136727
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 722  : 		Info_SetValueForKey( string, "maxcl", va( "%i", svs.maxclients ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _svs+16
	push	eax
	push	OFFSET $SG136728
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136729
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 723  : 		Info_SetValueForKey( string, "gamedir", GI->gamefolder, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	edx, DWORD PTR _SI+768
	push	edx
	push	OFFSET $SG136730
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H
$LN8@SV_Info:

; 724  : 	}
; 725  : 
; 726  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "info\n%s", string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	push	OFFSET $SG136731
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H
$LN1@SV_Info:

; 727  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_from$ = 8						; size = 20
_SV_Ack	PROC

; 681  : {

	push	ebp
	mov	ebp, esp

; 682  : 	Con_Printf( "ping %s\n", NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG136696
	call	_Con_Printf
	add	esp, 8

; 683  : }

	pop	ebp
	ret	0
_SV_Ack	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_crcpos$ = -64048					; size = 4
_send$ = -64044						; size = 20
_crcValue$ = -64024					; size = 4
_filepos$ = -64020					; size = 4
_version$ = -64016					; size = 4
_test$ = -64012						; size = 4
_packetsize$ = -64008					; size = 4
_send_buf$ = -64004					; size = 64000
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_TestBandWidth PROC

; 629  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 64048				; 0000fa30H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 630  : 	int	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 631  : 	int	packetsize = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _packetsize$[ebp], eax

; 632  : 	byte	send_buf[FRAGMENT_MAX_SIZE];
; 633  : 	dword	crcValue = 0;

	mov	DWORD PTR _crcValue$[ebp], 0

; 634  : 	byte	*filepos;
; 635  : 	int	crcpos;
; 636  : 	file_t	*test;
; 637  : 	sizebuf_t	send;
; 638  : 
; 639  : 	// don't waste time of protocol mismatched
; 640  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	SHORT $LN2@SV_TestBan

; 641  : 	{
; 642  : 		SV_RejectConnection( from, "unsupported protocol (%i should be %i)\n", version, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET $SG136686
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_RejectConnection
	add	esp, 32					; 00000020H

; 643  : 		return;

	jmp	$LN1@SV_TestBan
$LN2@SV_TestBan:

; 644  : 	}
; 645  : 
; 646  : 	test = FS_Open( "gfx.wad", "rb", false );

	push	0
	push	OFFSET $SG136687
	push	OFFSET $SG136688
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _test$[ebp], eax

; 647  : 
; 648  : 	if( FS_FileLength( test ) < sizeof( send_buf ))

	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	call	_FS_FileLength
	add	esp, 4
	cmp	eax, 64000				; 0000fa00H
	jae	SHORT $LN3@SV_TestBan

; 649  : 	{
; 650  : 		// skip the test and just get challenge
; 651  : 		SV_GetChallenge( from );

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_GetChallenge
	add	esp, 20					; 00000014H

; 652  : 		return;

	jmp	$LN1@SV_TestBan
$LN3@SV_TestBan:

; 653  : 	}
; 654  : 
; 655  : 	// write the packet header
; 656  : 	MSG_Init( &send, "BandWidthPacket", send_buf, sizeof( send_buf ));

	push	-1
	push	64000					; 0000fa00H
	lea	eax, DWORD PTR _send_buf$[ebp]
	push	eax
	push	OFFSET $SG136690
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 657  : 	MSG_WriteLong( &send, -1 );	// -1 sequence means out of band

	push	-1
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 658  : 	MSG_WriteString( &send, "testpacket" );

	push	OFFSET $SG136691
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 659  : 	crcpos = MSG_GetNumBytesWritten( &send );

	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _crcpos$[ebp], eax

; 660  : 	MSG_WriteLong( &send, 0 ); // reserve space for crc

	push	0
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 661  : 	filepos = send.pData + MSG_GetNumBytesWritten( &send );

	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, DWORD PTR _send$[ebp+8]
	mov	DWORD PTR _filepos$[ebp], eax

; 662  : 	packetsize = packetsize - MSG_GetNumBytesWritten( &send ); // adjust the packet size

	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	edx, DWORD PTR _packetsize$[ebp]
	sub	edx, eax
	mov	DWORD PTR _packetsize$[ebp], edx

; 663  : 	FS_Read( test, filepos, packetsize );

	mov	eax, DWORD PTR _packetsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filepos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 664  : 	FS_Close( test );

	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 665  : 
; 666  : 	CRC32_ProcessBuffer( &crcValue, filepos, packetsize );	// calc CRC

	mov	ecx, DWORD PTR _packetsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filepos$[ebp]
	push	edx
	lea	eax, DWORD PTR _crcValue$[ebp]
	push	eax
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 667  : 	MSG_SeekToBit( &send, packetsize << 3, SEEK_CUR );

	push	1
	mov	ecx, DWORD PTR _packetsize$[ebp]
	shl	ecx, 3
	push	ecx
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 668  : 	*(uint *)&send.pData[crcpos] = crcValue;

	mov	eax, DWORD PTR _send$[ebp+8]
	add	eax, DWORD PTR _crcpos$[ebp]
	mov	ecx, DWORD PTR _crcValue$[ebp]
	mov	DWORD PTR [eax], ecx

; 669  : 
; 670  : 	// send the datagram
; 671  : 	NET_SendPacket( NS_SERVER, MSG_GetNumBytesWritten( &send ), MSG_GetData( &send ), from );

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN1@SV_TestBan:

; 672  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TestBandWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
tv68 = -4						; size = 4
_adr$ = 8						; size = 20
_dest$ = 28						; size = 4
_buf$ = 32						; size = 4
_SV_FlushRedirect PROC

; 558  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 559  : 	if( sv.current_client && FBitSet( sv.current_client->flags, FCL_FAKECLIENT ))

	cmp	DWORD PTR _sv+40, 0
	je	SHORT $LN4@SV_FlushRe
	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN4@SV_FlushRe

; 560  : 		return;

	jmp	$LN1@SV_FlushRe
$LN4@SV_FlushRe:

; 561  : 
; 562  : 	switch( dest )

	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	je	$LN8@SV_FlushRe
	cmp	DWORD PTR tv68[ebp], 1
	je	SHORT $LN6@SV_FlushRe
	cmp	DWORD PTR tv68[ebp], 2
	je	SHORT $LN5@SV_FlushRe
	jmp	$LN1@SV_FlushRe
$LN5@SV_FlushRe:

; 563  : 	{
; 564  : 	case RD_PACKET:
; 565  : 		Netchan_OutOfBandPrint( NS_SERVER, adr, "print\n%s", buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	OFFSET $SG136645
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 566  : 		break;

	jmp	SHORT $LN1@SV_FlushRe
$LN6@SV_FlushRe:

; 567  : 	case RD_CLIENT:
; 568  : 		if( !sv.current_client ) return; // client not set

	cmp	DWORD PTR _sv+40, 0
	jne	SHORT $LN7@SV_FlushRe
	jmp	SHORT $LN1@SV_FlushRe
$LN7@SV_FlushRe:

; 569  : 		MSG_BeginServerCmd( &sv.current_client->netchan.message, svc_print );

	push	0
	push	1
	push	8
	mov	eax, DWORD PTR _sv+40
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 570  : 		MSG_WriteString( &sv.current_client->netchan.message, buf );

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sv+40
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 571  : 		break;

	jmp	SHORT $LN1@SV_FlushRe
$LN8@SV_FlushRe:

; 572  : 	case RD_NONE:
; 573  : 		Con_Printf( S_ERROR "SV_FlushRedirect: %s: invalid destination\n", NET_AdrToString( adr ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG136649
	call	_Con_Printf
	add	esp, 8
$LN1@SV_FlushRe:

; 574  : 		break;
; 575  : 	}
; 576  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FlushRedirect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_adr$ = 8						; size = 20
_target$ = 28						; size = 4
_buffer$ = 32						; size = 4
_buffersize$ = 36					; size = 4
_flush$ = 40						; size = 4
_SV_BeginRedirect PROC

; 545  : {

	push	ebp
	mov	ebp, esp

; 546  : 	if( !target || !buffer || !buffersize || !flush )

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN3@SV_BeginRe
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@SV_BeginRe
	cmp	DWORD PTR _buffersize$[ebp], 0
	je	SHORT $LN3@SV_BeginRe
	cmp	DWORD PTR _flush$[ebp], 0
	jne	SHORT $LN2@SV_BeginRe
$LN3@SV_BeginRe:

; 547  : 		return;

	jmp	SHORT $LN1@SV_BeginRe
$LN2@SV_BeginRe:

; 548  : 
; 549  : 	host.rd.target = target;

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR _host+884, eax

; 550  : 	host.rd.buffer = buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _host+888, ecx

; 551  : 	host.rd.buffersize = buffersize;

	mov	edx, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR _host+892, edx

; 552  : 	host.rd.flush = flush;

	mov	eax, DWORD PTR _flush$[ebp]
	mov	DWORD PTR _host+916, eax

; 553  : 	host.rd.address = adr;

	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR _host+896, ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR _host+900, edx
	mov	eax, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR _host+904, eax
	mov	ecx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR _host+908, ecx
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR _host+912, edx

; 554  : 	host.rd.buffer[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host+888
	mov	BYTE PTR [edx+ecx], 0
$LN1@SV_BeginRe:

; 555  : }

	pop	ebp
	ret	0
_SV_BeginRedirect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_nClientSlot$ = -556					; size = 4
_qport$ = -552						; size = 4
_challenge$ = -548					; size = 4
_reconnect$ = -544					; size = 4
_version$ = -540					; size = 4
_count$ = -536						; size = 4
_i$ = -532						; size = 4
_s$ = -528						; size = 4
_cl$ = -524						; size = 4
_newcl$ = -520						; size = 4
_userinfo$ = -516					; size = 256
_protinfo$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_ConnectClient PROC

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 234  : 	char		userinfo[MAX_INFO_STRING];
; 235  : 	char		protinfo[MAX_INFO_STRING];
; 236  : 	sv_client_t	*cl, *newcl = NULL;

	mov	DWORD PTR _newcl$[ebp], 0

; 237  : 	qboolean		reconnect = false;

	mov	DWORD PTR _reconnect$[ebp], 0

; 238  : 	int		nClientSlot = 0;

	mov	DWORD PTR _nClientSlot$[ebp], 0

; 239  : 	int		qport, version;
; 240  : 	int		i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 241  : 	int		challenge;
; 242  : 	char		*s;
; 243  : 
; 244  : 	if( Cmd_Argc() < 5 )

	call	_Cmd_Argc
	cmp	eax, 5
	jae	SHORT $LN8@SV_Connect

; 245  : 	{
; 246  : 		SV_RejectConnection( from, "insufficient connection info\n" );

	push	OFFSET $SG136526
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 247  : 		return;

	jmp	$LN26@SV_Connect
$LN8@SV_Connect:

; 248  : 	}
; 249  : 
; 250  : 	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 251  : 
; 252  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	SHORT $LN9@SV_Connect

; 253  : 	{
; 254  : 		SV_RejectConnection( from, "unsupported protocol (%i should be %i)\n", version, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	edx, DWORD PTR _version$[ebp]
	push	edx
	push	OFFSET $SG136528
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 32					; 00000020H

; 255  : 		return;

	jmp	$LN26@SV_Connect
$LN9@SV_Connect:

; 256  : 	}
; 257  : 
; 258  : 	challenge = Q_atoi( Cmd_Argv( 2 )); // get challenge

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _challenge$[ebp], eax

; 259  : 
; 260  : 	// see if the challenge is valid (local clients don't need to challenge)
; 261  : 	if( !SV_CheckChallenge( from, challenge ))

	mov	edx, DWORD PTR _challenge$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_CheckChallenge
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN10@SV_Connect

; 262  : 		return;

	jmp	$LN26@SV_Connect
$LN10@SV_Connect:

; 263  : 
; 264  : 	s = Cmd_Argv( 3 );	// protocol info

	push	3
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 265  : 
; 266  : 	if( !Info_IsValid( s ))

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_IsValid
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SV_Connect

; 267  : 	{
; 268  : 		SV_RejectConnection( from, "invalid protinfo in connect command\n" );

	push	OFFSET $SG136531
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 269  : 		return;

	jmp	$LN26@SV_Connect
$LN11@SV_Connect:

; 270  : 	}
; 271  : 
; 272  : 	Q_strncpy( protinfo, s, sizeof( protinfo ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 273  : 
; 274  : 	// extract qport from protocol info
; 275  : 	qport = Q_atoi( Info_ValueForKey( protinfo, "qport" ));

	push	OFFSET $SG136532
	lea	ecx, DWORD PTR _protinfo$[ebp]
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _qport$[ebp], eax

; 276  : 
; 277  : 	s = Info_ValueForKey( protinfo, "uuid" );

	push	OFFSET $SG136533
	lea	edx, DWORD PTR _protinfo$[ebp]
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 278  : 	if( Q_strlen( s ) != 32 )

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	je	SHORT $LN12@SV_Connect

; 279  : 	{
; 280  : 		SV_RejectConnection( from, "invalid authentication certificate length\n" );

	push	OFFSET $SG136535
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 281  : 		return;

	jmp	$LN26@SV_Connect
$LN12@SV_Connect:

; 282  : 	}
; 283  : 
; 284  : 	// LAN servers restrict to class b IP addresses
; 285  : 	if( !SV_CheckIPRestrictions( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_CheckIPRestrictions
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN13@SV_Connect

; 286  : 	{
; 287  : 		SV_RejectConnection( from, "LAN servers are restricted to local clients (class C)\n" );

	push	OFFSET $SG136537
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 288  : 		return;

	jmp	$LN26@SV_Connect
$LN13@SV_Connect:

; 289  : 	}
; 290  : 
; 291  : 	s = Cmd_Argv( 4 );	// user info

	push	4
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 292  : 
; 293  : 	if( Q_strlen( s ) > MAX_INFO_STRING || !Info_IsValid( s ))

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 256				; 00000100H
	jg	SHORT $LN15@SV_Connect
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_IsValid
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@SV_Connect
$LN15@SV_Connect:

; 294  : 	{
; 295  : 		SV_RejectConnection( from, "invalid userinfo in connect command\n" );

	push	OFFSET $SG136540
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 296  : 		return;

	jmp	$LN26@SV_Connect
$LN14@SV_Connect:

; 297  : 	}
; 298  : 
; 299  : 	Q_strncpy( userinfo, s, sizeof( userinfo ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	call	_Q_strncpy

; 300  : 
; 301  : 	// check connection password (don't verify local client)
; 302  : 	if( !NET_IsLocalAddress( from ) && sv_password.string[0] && Q_stricmp( sv_password.string, Info_ValueForKey( userinfo, "password" )))

	add	esp, -8					; fffffff8H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN16@SV_Connect
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sv_password+4
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN16@SV_Connect
	push	99999					; 0001869fH
	push	OFFSET $SG136542
	lea	ecx, DWORD PTR _userinfo$[ebp]
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _sv_password+4
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@SV_Connect

; 303  : 	{
; 304  : 		SV_RejectConnection( from, "invalid password\n" );

	push	OFFSET $SG136543
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 305  : 		return;

	jmp	$LN26@SV_Connect
$LN16@SV_Connect:

; 306  : 	}
; 307  : 
; 308  : 	// if there is already a slot for this ip, reuse it
; 309  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	edx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], edx
	jmp	SHORT $LN4@SV_Connect
$LN2@SV_Connect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_Connect:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jge	$LN3@SV_Connect

; 310  : 	{
; 311  : 		if( cl->state == cs_free || cl->state == cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN18@SV_Connect
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN17@SV_Connect
$LN18@SV_Connect:

; 312  : 			continue;

	jmp	SHORT $LN2@SV_Connect
$LN17@SV_Connect:

; 313  : 
; 314  : 		if( NET_CompareBaseAdr( from, cl->netchan.remote_address ) && ( cl->netchan.qport == qport || from.port == cl->netchan.remote_address.port ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_CompareBaseAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN19@SV_Connect
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+584]
	cmp	eax, DWORD PTR _qport$[ebp]
	je	SHORT $LN20@SV_Connect
	movzx	ecx, WORD PTR _from$[ebp+18]
	mov	edx, DWORD PTR _cl$[ebp]
	movzx	eax, WORD PTR [edx+582]
	cmp	ecx, eax
	jne	SHORT $LN19@SV_Connect
$LN20@SV_Connect:

; 315  : 		{
; 316  : 			reconnect = true;

	mov	DWORD PTR _reconnect$[ebp], 1

; 317  : 			newcl = cl;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR _newcl$[ebp], ecx

; 318  : 			break;

	jmp	SHORT $LN3@SV_Connect
$LN19@SV_Connect:

; 319  : 		}
; 320  : 	}

	jmp	$LN2@SV_Connect
$LN3@SV_Connect:

; 321  : 
; 322  : 	// A reconnecting client will re-use the slot found above when checking for reconnection.
; 323  : 	// the slot will be wiped clean.
; 324  : 	if( !reconnect )

	cmp	DWORD PTR _reconnect$[ebp], 0
	jne	SHORT $LN21@SV_Connect

; 325  : 	{
; 326  : 		// connect the client if there are empty slots.
; 327  : 		if( !SV_FindEmptySlot( from, &nClientSlot, &newcl ))

	lea	edx, DWORD PTR _newcl$[ebp]
	push	edx
	lea	eax, DWORD PTR _nClientSlot$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_FindEmptySlot
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN23@SV_Connect

; 328  : 			return;

	jmp	$LN26@SV_Connect
$LN23@SV_Connect:

; 329  : 	}

	jmp	SHORT $LN22@SV_Connect
$LN21@SV_Connect:

; 330  : 	else
; 331  : 	{
; 332  : 		Con_Reportf( S_NOTE "%s:reconnect\n", NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG136551
	call	_Con_Reportf
	add	esp, 8
$LN22@SV_Connect:

; 333  : 	}
; 334  : 
; 335  : 	// find a client slot
; 336  : 	ASSERT( newcl != NULL );

	cmp	DWORD PTR _newcl$[ebp], 0
	jne	SHORT $LN24@SV_Connect
	push	336					; 00000150H
	push	OFFSET $SG136553
	push	OFFSET $SG136554
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN24@SV_Connect:

; 337  : 
; 338  : 	// build a new connection
; 339  : 	// accept the new client
; 340  : 	sv.current_client = newcl;

	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR _sv+40, edx

; 341  : 	newcl->edict = EDICT_NUM( (newcl - svs.clients) + 1 );

	mov	eax, DWORD PTR _newcl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	add	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [edx+264980], eax

; 342  : 	newcl->challenge = challenge; // save challenge for checksumming

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	ecx, DWORD PTR _challenge$[ebp]
	mov	DWORD PTR [eax+287552], ecx

; 343  : 	newcl->frames = (client_frame_t *)Z_Calloc( sizeof( client_frame_t ) * SV_UPDATE_BACKUP );

	push	343					; 00000157H
	push	OFFSET $SG136555
	push	1
	imul	edx, DWORD PTR _SV_UPDATE_BACKUP, 6128
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [ecx+281916], eax

; 344  : 	newcl->userid = g_userid++;	// create unique userid

	mov	edx, DWORD PTR _newcl$[ebp]
	mov	eax, DWORD PTR _g_userid
	mov	DWORD PTR [edx+287556], eax
	mov	ecx, DWORD PTR _g_userid
	add	ecx, 1
	mov	DWORD PTR _g_userid, ecx

; 345  : 	newcl->state = cs_connected;

	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [edx], 2

; 346  : 
; 347  : 	// reset viewentities (from previous level)
; 348  : 	memset( newcl->viewentity, 0, sizeof( newcl->viewentity ));

	push	512					; 00000200H
	push	0
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 264988				; 00040b1cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 349  : 	newcl->num_viewents = 0;

	mov	ecx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [ecx+265500], 0

; 350  : 	newcl->listeners = 0;

	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [edx+265508], 0

; 351  : 
; 352  : 	// initailize netchan
; 353  : 	Netchan_Setup( NS_SERVER, &newcl->netchan, from, qport, newcl, SV_GetFragmentSize );

	push	OFFSET _SV_GetFragmentSize
	mov	eax, DWORD PTR _newcl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _qport$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	push	1
	call	_Netchan_Setup
	add	esp, 40					; 00000028H

; 354  : 	MSG_Init( &newcl->datagram, "Datagram", newcl->datagram_buf, sizeof( newcl->datagram_buf )); // datagram buf

	push	-1
	push	16384					; 00004000H
	mov	edx, DWORD PTR _newcl$[ebp]
	add	edx, 265532				; 00040d3cH
	push	edx
	push	OFFSET $SG136556
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 265512				; 00040d28H
	push	eax
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 355  : 
; 356  : 	// send the connect packet to the client
; 357  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "client_connect" );

	push	OFFSET $SG136557
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 358  : 
; 359  : 	newcl->upstate = us_inactive;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+4], 0

; 360  : 	newcl->connection_started = host.realtime;

	mov	ecx, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [ecx+264408], xmm0

; 361  : 	newcl->cl_updaterate = 0.05;	// 20 fps as default

	mov	edx, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR __real@3fa999999999999a
	movsd	QWORD PTR [edx+264392], xmm0

; 362  : 	newcl->delta_sequence = -1;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+264364], -1

; 363  : 	newcl->flags = 0;

	mov	ecx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 364  : 
; 365  : 	Q_strncpy( newcl->hashedcdkey, Info_ValueForKey( protinfo, "uuid" ), 32 );

	push	32					; 00000020H
	push	OFFSET $SG136558
	lea	edx, DWORD PTR _protinfo$[ebp]
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 264416				; 000408e0H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 366  : 	newcl->hashedcdkey[32] = '\0';

	mov	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _newcl$[ebp]
	mov	BYTE PTR [edx+ecx+264416], 0

; 367  : 
; 368  : 	// reset any remaining events
; 369  : 	memset( &newcl->events, 0, sizeof( newcl->events ));

	push	5632					; 00001600H
	push	0
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 281920				; 00044d40H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 370  : 
; 371  : 	// parse some info from the info strings (this can override cl_updaterate)
; 372  : 	Q_strncpy( newcl->userinfo, userinfo, sizeof( newcl->userinfo ));

	push	256					; 00000100H
	lea	ecx, DWORD PTR _userinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newcl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 373  : 	SV_UserinfoChanged( newcl );

	mov	eax, DWORD PTR _newcl$[ebp]
	push	eax
	call	_SV_UserinfoChanged
	add	esp, 4

; 374  : 	SV_ClearResourceLists( newcl );

	mov	ecx, DWORD PTR _newcl$[ebp]
	push	ecx
	call	_SV_ClearResourceLists
	add	esp, 4

; 375  : #if 0
; 376  : 	memset( &newcl->resourcesneeded, 0, sizeof( resource_t ));
; 377  : 	memset( &newcl->resourcesonhand, 0, sizeof( resource_t ));
; 378  : 	newcl->resourcesneeded.pNext = newcl->resourcesneeded.pPrev = &newcl->resourcesneeded;
; 379  : 	newcl->resourcesonhand.pNext = newcl->resourcesonhand.pPrev = &newcl->resourcesonhand;
; 380  : #endif
; 381  : 	newcl->next_messagetime = host.realtime + newcl->cl_updaterate;

	mov	edx, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR [edx+264392]
	mov	eax, DWORD PTR _newcl$[ebp]
	movsd	QWORD PTR [eax+264368], xmm0

; 382  : 	newcl->next_sendinfotime = 0.0;

	mov	ecx, DWORD PTR _newcl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [ecx+264384], xmm0

; 383  : 	newcl->ignored_ents = 0;

	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [edx+264976], 0

; 384  : 	newcl->chokecount = 0;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+264360], 0

; 385  : 
; 386  : 	// reset stats
; 387  : 	newcl->next_checkpingtime = -1.0;

	mov	ecx, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR [ecx+264376], xmm0

; 388  : 	newcl->packet_loss = 0.0f;

	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [edx+264968], 0

; 389  : 
; 390  : 	// if this was the first client on the server, or the last client
; 391  : 	// the server can hold, send a heartbeat to the master.
; 392  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN7@SV_Connect
$LN5@SV_Connect:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN7@SV_Connect:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_Connect

; 393  : 		if( cl->state >= cs_connected ) count++;

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN25@SV_Connect
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN25@SV_Connect:
	jmp	SHORT $LN5@SV_Connect
$LN6@SV_Connect:

; 394  : 
; 395  : 	Log_Printf( "\"%s<%i><%i><>\" connected, address \"%s\"\n", newcl->name, newcl->userid, i, NET_AdrToString( newcl->netchan.remote_address ));

	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newcl$[ebp]
	mov	eax, DWORD PTR [edx+287556]
	push	eax
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG136560
	call	_Log_Printf
	add	esp, 20					; 00000014H

; 396  : 
; 397  : 	if( count == 1 || count == svs.maxclients )

	cmp	DWORD PTR _count$[ebp], 1
	je	SHORT $LN27@SV_Connect
	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jne	SHORT $LN26@SV_Connect
$LN27@SV_Connect:

; 398  : 		svs.last_heartbeat = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0
$LN26@SV_Connect:

; 399  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ConnectClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_from$ = 8						; size = 20
_pslot$ = 28						; size = 4
_ppClient$ = 32						; size = 4
_SV_FindEmptySlot PROC

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 208  : 	sv_client_t	*cl;
; 209  : 	int		i;
; 210  : 
; 211  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_FindEmp
$LN2@SV_FindEmp:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_FindEmp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_FindEmp

; 212  : 	{
; 213  : 		if( cl->state == cs_free )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@SV_FindEmp

; 214  : 		{
; 215  : 			*ppClient = cl;

	mov	edx, DWORD PTR _ppClient$[ebp]
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx], eax

; 216  : 			*pslot = i;

	mov	ecx, DWORD PTR _pslot$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx

; 217  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@SV_FindEmp
$LN5@SV_FindEmp:

; 218  : 		}
; 219  : 	}

	jmp	SHORT $LN2@SV_FindEmp
$LN3@SV_FindEmp:

; 220  : 
; 221  : 	SV_RejectConnection( from, "server is full\n" );

	push	OFFSET $SG136498
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 222  : 	return 0;

	xor	eax, eax
$LN1@SV_FindEmp:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindEmptySlot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_from$ = 8						; size = 20
_SV_CheckIPRestrictions PROC

; 189  : {

	push	ebp
	mov	ebp, esp

; 190  : 	if( sv_lan.value )

	movss	xmm0, DWORD PTR _sv_lan+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@SV_CheckIP

; 191  : 	{
; 192  : 		if( !NET_CompareClassBAdr( from, net_local ) && !NET_IsReservedAdr( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_CompareClassBAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN3@SV_CheckIP
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_IsReservedAdr
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN3@SV_CheckIP

; 193  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckIP
$LN3@SV_CheckIP:

; 194  : 	}
; 195  : 	return 1;

	mov	eax, 1
$LN1@SV_CheckIP:

; 196  : }

	pop	ebp
	ret	0
_SV_CheckIPRestrictions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_from$ = 8						; size = 20
_challenge$ = 28					; size = 4
_SV_CheckChallenge PROC

; 149  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 150  : 	int	i;
; 151  : 
; 152  : 	// see if the challenge is valid
; 153  : 	// don't care if it is a local address.
; 154  : 	if( NET_IsLocalAddress( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN5@SV_CheckCh

; 155  : 		return 1;

	mov	eax, 1
	jmp	$LN1@SV_CheckCh
$LN5@SV_CheckCh:

; 156  : 
; 157  : 	for( i = 0; i < MAX_CHALLENGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CheckCh
$LN2@SV_CheckCh:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_CheckCh:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_CheckCh

; 158  : 	{
; 159  : 		if( NET_CompareAdr( from, svs.challenges[i].adr ))

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svs+33376
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN6@SV_CheckCh

; 160  : 		{
; 161  : 			if( challenge == svs.challenges[i].challenge )

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _challenge$[ebp]
	cmp	ecx, DWORD PTR _svs[eax+33408]
	jne	SHORT $LN6@SV_CheckCh

; 162  : 				break; // valid challenge

	jmp	SHORT $LN3@SV_CheckCh
$LN6@SV_CheckCh:

; 163  : #if 0
; 164  : 			// g-cont. this breaks multiple connections from single machine
; 165  : 			SV_RejectConnection( from, "bad challenge %i\n", challenge );
; 166  : 			return 0;
; 167  : #endif
; 168  : 		}
; 169  : 	}

	jmp	SHORT $LN2@SV_CheckCh
$LN3@SV_CheckCh:

; 170  : 
; 171  : 	if( i == MAX_CHALLENGES )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN8@SV_CheckCh

; 172  : 	{
; 173  : 		SV_RejectConnection( from, "no challenge for your address\n" );

	push	OFFSET $SG136477
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 174  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckCh
$LN8@SV_CheckCh:

; 175  : 	}
; 176  : 	svs.challenges[i].connected = true;

	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _svs[ecx+33412], 1

; 177  : 
; 178  : 	return 1;

	mov	eax, 1
$LN1@SV_CheckCh:

; 179  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckChallenge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_filename$ = 12						; size = 4
_SV_FailDownload PROC

; 133  : {

	push	ebp
	mov	ebp, esp

; 134  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_FailDow

; 135  : 		return;

	jmp	SHORT $LN1@SV_FailDow
$LN2@SV_FailDow:

; 136  : 
; 137  : 	MSG_BeginServerCmd( &cl->netchan.message, svc_filetxferfailed );

	push	0
	push	1
	push	49					; 00000031H
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 138  : 	MSG_WriteString( &cl->netchan.message, filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteString
	add	esp, 8
$LN1@SV_FailDow:

; 139  : }

	pop	ebp
	ret	0
_SV_FailDownload ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_argptr$ = -1032					; size = 4
_text$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_fmt$ = 28						; size = 4
_SV_RejectConnection PROC

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1032				; 00000408H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 112  : 	char	text[1024];
; 113  : 	va_list	argptr;
; 114  : 
; 115  : 	va_start( argptr, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 116  : 	Q_vsnprintf( text, sizeof( text ), fmt, argptr );

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	push	1024					; 00000400H
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 117  : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 118  : 
; 119  : 	Con_Reportf( "%s connection refused. Reason: %s\n", NET_AdrToString( from ), text );

	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG136452
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 120  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "print\n^1Server was reject the connection:^7 %s", text );

	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	push	OFFSET $SG136453
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 121  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "disconnect\n" );

	push	OFFSET $SG136454
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 122  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RejectConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
tv77 = -12						; size = 4
tv76 = -8						; size = 4
_cl_frag_size$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_GetFragmentSize PROC

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 92   : 	int	cl_frag_size;
; 93   : 
; 94   : 	if( Netchan_IsLocal( &cl->netchan ))

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_IsLocal
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SV_GetFrag

; 95   : 		return FRAGMENT_LOCAL_SIZE;

	mov	eax, 64000				; 0000fa00H
	jmp	SHORT $LN1@SV_GetFrag
$LN2@SV_GetFrag:

; 96   : 
; 97   : 	cl_frag_size = Q_atoi( Info_ValueForKey( cl->userinfo, "cl_dlmax" ));

	push	OFFSET $SG136436
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _cl_frag_size$[ebp], eax

; 98   : 	cl_frag_size = bound( FRAGMENT_MIN_SIZE, cl_frag_size, FRAGMENT_MAX_SIZE );

	cmp	DWORD PTR _cl_frag_size$[ebp], 1200	; 000004b0H
	jl	SHORT $LN6@SV_GetFrag
	cmp	DWORD PTR _cl_frag_size$[ebp], 64000	; 0000fa00H
	jge	SHORT $LN4@SV_GetFrag
	mov	edx, DWORD PTR _cl_frag_size$[ebp]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN5@SV_GetFrag
$LN4@SV_GetFrag:
	mov	DWORD PTR tv76[ebp], 64000		; 0000fa00H
$LN5@SV_GetFrag:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@SV_GetFrag
$LN6@SV_GetFrag:
	mov	DWORD PTR tv77[ebp], 1200		; 000004b0H
$LN7@SV_GetFrag:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _cl_frag_size$[ebp], ecx

; 99   : 
; 100  : 	return cl_frag_size;

	mov	eax, DWORD PTR _cl_frag_size$[ebp]
$LN1@SV_GetFrag:

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetFragmentSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_SV_EndRedirect PROC

; 579  : {

	push	ebp
	mov	ebp, esp

; 580  : 	if( host.rd.flush )

	cmp	DWORD PTR _host+916, 0
	je	SHORT $LN2@SV_EndRedi

; 581  : 		host.rd.flush( host.rd.address, host.rd.target, host.rd.buffer );

	mov	eax, DWORD PTR _host+888
	push	eax
	mov	ecx, DWORD PTR _host+884
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _host+896
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _host+900
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _host+904
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _host+908
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _host+912
	mov	DWORD PTR [edx+16], eax
	call	DWORD PTR _host+916
	add	esp, 28					; 0000001cH
$LN2@SV_EndRedi:

; 582  : 
; 583  : 	host.rd.target = 0;

	mov	DWORD PTR _host+884, 0

; 584  : 	host.rd.buffer = NULL;

	mov	DWORD PTR _host+888, 0

; 585  : 	host.rd.buffersize = 0;

	mov	DWORD PTR _host+892, 0

; 586  : 	host.rd.flush = NULL;

	mov	DWORD PTR _host+916, 0

; 587  : }

	pop	ebp
	ret	0
_SV_EndRedirect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_idx$ = -24						; size = 4
_frame$ = -20						; size = 4
_ping$ = -16						; size = 4
_back$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_CalcPing PROC

; 888  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 889  : 	float		ping = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _ping$[ebp], xmm0

; 890  : 	int		i, count;
; 891  : 	int		idx, back;
; 892  : 	client_frame_t	*frame;
; 893  : 
; 894  : 	// bots don't have a real ping
; 895  : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ) || !cl->frames )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN6@SV_CalcPin
	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+281916], 0
	jne	SHORT $LN5@SV_CalcPin
$LN6@SV_CalcPin:

; 896  : 		return 5;

	mov	eax, 5
	jmp	$LN1@SV_CalcPin
$LN5@SV_CalcPin:

; 897  : 
; 898  : 	if( SV_UPDATE_BACKUP <= 31 )

	cmp	DWORD PTR _SV_UPDATE_BACKUP, 31		; 0000001fH
	jg	SHORT $LN7@SV_CalcPin

; 899  : 	{
; 900  : 		back = SV_UPDATE_BACKUP / 2;

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _back$[ebp], eax

; 901  : 		if( back <= 0 ) return 0;

	cmp	DWORD PTR _back$[ebp], 0
	jg	SHORT $LN9@SV_CalcPin
	xor	eax, eax
	jmp	$LN1@SV_CalcPin
$LN9@SV_CalcPin:

; 902  : 	}

	jmp	SHORT $LN8@SV_CalcPin
$LN7@SV_CalcPin:

; 903  : 	else back = 16;

	mov	DWORD PTR _back$[ebp], 16		; 00000010H
$LN8@SV_CalcPin:

; 904  : 
; 905  : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 906  : 
; 907  : 	for( i = 0; i < back; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CalcPin
$LN2@SV_CalcPin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CalcPin:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _back$[ebp]
	jge	SHORT $LN3@SV_CalcPin

; 908  : 	{
; 909  : 		idx = cl->netchan.incoming_acknowledged + ~i;

	mov	edx, DWORD PTR _i$[ebp]
	not	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	edx, DWORD PTR [eax+628]
	mov	DWORD PTR _idx$[ebp], edx

; 910  : 		frame = &cl->frames[idx & SV_UPDATE_MASK];

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _idx$[ebp]
	imul	edx, ecx, 6128
	mov	eax, DWORD PTR _cl$[ebp]
	add	edx, DWORD PTR [eax+281916]
	mov	DWORD PTR _frame$[ebp], edx

; 911  : 
; 912  : 		if( frame->ping_time > 0.0f )

	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@SV_CalcPin

; 913  : 		{
; 914  : 			ping += frame->ping_time;

	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR _ping$[ebp]
	addss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR _ping$[ebp], xmm0

; 915  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN10@SV_CalcPin:

; 916  : 		}
; 917  : 	}

	jmp	SHORT $LN2@SV_CalcPin
$LN3@SV_CalcPin:

; 918  : 
; 919  : 	if( count > 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jle	SHORT $LN11@SV_CalcPin

; 920  : 		return (( ping / count ) * 1000.0f );

	cvtsi2ss xmm0, DWORD PTR _count$[ebp]
	movss	xmm1, DWORD PTR _ping$[ebp]
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@447a0000
	cvttss2si eax, xmm1
	jmp	SHORT $LN1@SV_CalcPin
$LN11@SV_CalcPin:

; 921  : 	return 0;

	xor	eax, eax
$LN1@SV_CalcPin:

; 922  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CalcPing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_SV_IsPlayerIndex PROC

; 1122 : {

	push	ebp
	mov	ebp, esp

; 1123 : 	if( idx > 0 && idx <= svs.maxclients )

	cmp	DWORD PTR _idx$[ebp], 0
	jle	SHORT $LN2@SV_IsPlaye
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN2@SV_IsPlaye

; 1124 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsPlaye
$LN2@SV_IsPlaye:

; 1125 : 	return false;

	xor	eax, eax
$LN1@SV_IsPlaye:

; 1126 : }

	pop	ebp
	ret	0
_SV_IsPlayerIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_SV_BuildReconnect PROC

; 1336 : {

	push	ebp
	mov	ebp, esp

; 1337 : 	MSG_BeginServerCmd( msg, svc_stufftext );

	push	0
	push	1
	push	9
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1338 : 	MSG_WriteString( msg, "reconnect\n" );

	push	OFFSET $SG137018
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1339 : }

	pop	ebp
	ret	0
_SV_BuildReconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_u$ = -4						; size = 4
_cl$ = 8						; size = 4
_s$ = 12						; size = 4
_SV_ExecuteClientCommand PROC

; 1961 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1962 : 	ucmd_t	*u;
; 1963 : 
; 1964 : 	Cmd_TokenizeString( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 1965 : 
; 1966 : 	for( u = ucmds; u->name; u++ )

	mov	DWORD PTR _u$[ebp], OFFSET _ucmds
	jmp	SHORT $LN4@SV_Execute
$LN2@SV_Execute:
	mov	ecx, DWORD PTR _u$[ebp]
	add	ecx, 8
	mov	DWORD PTR _u$[ebp], ecx
$LN4@SV_Execute:
	mov	edx, DWORD PTR _u$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@SV_Execute

; 1967 : 	{
; 1968 : 		if( !Q_strcmp( Cmd_Argv( 0 ), u->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_Execute

; 1969 : 		{
; 1970 : 			if( !u->func( cl ))

	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	ecx
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_Execute

; 1971 : 				Con_Printf( "'%s' is not valid from the console\n", u->name );

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET $SG137299
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN7@SV_Execute
$LN6@SV_Execute:

; 1972 : 			else Con_Reportf( "ucmd->%s()\n", u->name );

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG137300
	call	_Con_Reportf
	add	esp, 8
$LN7@SV_Execute:

; 1973 : 			break;

	jmp	SHORT $LN3@SV_Execute
$LN5@SV_Execute:

; 1974 : 		}
; 1975 : 	}

	jmp	SHORT $LN2@SV_Execute
$LN3@SV_Execute:

; 1976 : 
; 1977 : 	if( !u->name && sv.state == ss_active )

	mov	eax, DWORD PTR _u$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@SV_Execute
	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN1@SV_Execute

; 1978 : 	{
; 1979 : 		// custom client commands
; 1980 : 		svgame.dllFuncs.pfnClientCommand( cl->edict );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	DWORD PTR _svgame+19316
	add	esp, 4

; 1981 : 
; 1982 : 		if( !Q_strcmp( Cmd_Argv( 0 ), "fullupdate" ))

	push	99999					; 0001869fH
	push	OFFSET $SG137303
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SV_Execute

; 1983 : 		{
; 1984 : 			// resend the ambient sounds for demo recording
; 1985 : 			SV_RestartAmbientSounds();

	call	_SV_RestartAmbientSounds

; 1986 : 			// resend all the decals for demo recording
; 1987 : 			SV_RestartDecals();

	call	_SV_RestartDecals

; 1988 : 			// resend all the static ents for demo recording
; 1989 : 			SV_RestartStaticEnts();

	call	_SV_RestartStaticEnts

; 1990 : 			// resend the viewentity
; 1991 : 			SV_UpdateClientView( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_UpdateClientView
	add	esp, 4
$LN1@SV_Execute:

; 1992 : 		}
; 1993 : 	}
; 1994 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ExecuteClientCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
$T1 = -276						; size = 4
_count$ = -272						; size = 4
_i$ = -268						; size = 4
_cl$ = -264						; size = 4
_userinfo$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_netname$ = 8						; size = 4
_SV_FakeConnect PROC

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 410  : 	char		userinfo[MAX_INFO_STRING];
; 411  : 	int		i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 412  : 	sv_client_t	*cl;
; 413  : 
; 414  : 	if( !COM_CheckString( netname ))

	mov	eax, DWORD PTR _netname$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@SV_FakeCon

; 415  : 		netname = "Bot";

	mov	DWORD PTR _netname$[ebp], OFFSET $SG136580
$LN8@SV_FakeCon:

; 416  : 
; 417  : 	// find a client slot
; 418  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], ecx
	jmp	SHORT $LN4@SV_FakeCon
$LN2@SV_FakeCon:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], eax
$LN4@SV_FakeCon:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_FakeCon

; 419  : 	{
; 420  : 		if( cl->state == cs_free )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@SV_FakeCon

; 421  : 			break;

	jmp	SHORT $LN3@SV_FakeCon
$LN9@SV_FakeCon:

; 422  : 	}

	jmp	SHORT $LN2@SV_FakeCon
$LN3@SV_FakeCon:

; 423  : 
; 424  : 	if( i == svs.maxclients )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN10@SV_FakeCon

; 425  : 		return NULL; // server is full

	xor	eax, eax
	jmp	$LN1@SV_FakeCon
$LN10@SV_FakeCon:

; 426  : 
; 427  : 	userinfo[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN16@SV_FakeCon
	jmp	SHORT $LN17@SV_FakeCon
$LN16@SV_FakeCon:
	call	___report_rangecheckfailure
$LN17@SV_FakeCon:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _userinfo$[ebp+eax], 0

; 428  : 
; 429  : 	// setup fake client params
; 430  : 	Info_SetValueForKey( userinfo, "name", netname, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _netname$[ebp]
	push	ecx
	push	OFFSET $SG136583
	lea	edx, DWORD PTR _userinfo$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 431  : 	Info_SetValueForKey( userinfo, "model", "gordon", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG136584
	push	OFFSET $SG136585
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 432  : 	Info_SetValueForKey( userinfo, "topcolor", "1", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG136586
	push	OFFSET $SG136587
	lea	ecx, DWORD PTR _userinfo$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 433  : 	Info_SetValueForKey( userinfo, "bottomcolor", "1", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG136588
	push	OFFSET $SG136589
	lea	edx, DWORD PTR _userinfo$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 434  : 
; 435  : 	// build a new connection
; 436  : 	// accept the new client
; 437  : 	sv.current_client = cl;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR _sv+40, eax

; 438  : 
; 439  : 	if( cl->frames ) Mem_Free( cl->frames );	// fakeclients doesn't have frames

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+281916], 0
	je	SHORT $LN11@SV_FakeCon
	push	439					; 000001b7H
	push	OFFSET $SG136591
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+281916]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN11@SV_FakeCon:

; 440  : 	memset( cl, 0, sizeof( sv_client_t ));

	push	287560					; 00046348H
	push	0
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 441  : 
; 442  : 	cl->edict = EDICT_NUM( (cl - svs.clients) + 1 );

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	add	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+264980], eax

; 443  : 	cl->userid = g_userid++;		// create unique userid

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _g_userid
	mov	DWORD PTR [eax+287556], ecx
	mov	edx, DWORD PTR _g_userid
	add	edx, 1
	mov	DWORD PTR _g_userid, edx

; 444  : 	SetBits( cl->flags, FCL_FAKECLIENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 445  : 
; 446  : 	// parse some info from the info strings
; 447  : 	Q_strncpy( cl->userinfo, userinfo, sizeof( cl->userinfo ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 448  : 	SV_UserinfoChanged( cl );

	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_UserinfoChanged
	add	esp, 4

; 449  : 	SetBits( cl->flags, FCL_RESEND_USERINFO );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 450  : 	cl->next_sendinfotime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264384], xmm0

; 451  : 
; 452  : 	// if this was the first client on the server, or the last client
; 453  : 	// the server can hold, send a heartbeat to the master.
; 454  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], ecx
	jmp	SHORT $LN7@SV_FakeCon
$LN5@SV_FakeCon:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], eax
$LN7@SV_FakeCon:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_FakeCon

; 455  : 		if( cl->state >= cs_connected ) count++;

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 2
	jl	SHORT $LN12@SV_FakeCon
	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN12@SV_FakeCon:
	jmp	SHORT $LN5@SV_FakeCon
$LN6@SV_FakeCon:

; 456  : 	cl = sv.current_client;

	mov	ecx, DWORD PTR _sv+40
	mov	DWORD PTR _cl$[ebp], ecx

; 457  : 
; 458  : 	Log_Printf( "\"%s<%i><%i><>\" connected, address \"local\"\n", cl->name, cl->userid, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+287556]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG136593
	call	_Log_Printf
	add	esp, 16					; 00000010H

; 459  : 
; 460  : 	SetBits( cl->edict->v.flags, FL_CLIENT|FL_FAKECLIENT );	// mark it as fakeclient

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, DWORD PTR [ecx+548]
	or	edx, 8200				; 00002008H
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR [ecx+548], edx

; 461  : 	cl->connection_started = host.realtime;

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx+264408], xmm0

; 462  : 	cl->state = cs_spawned;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], 3

; 463  : 
; 464  : 	if( count == 1 || count == svs.maxclients )

	cmp	DWORD PTR _count$[ebp], 1
	je	SHORT $LN14@SV_FakeCon
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jne	SHORT $LN13@SV_FakeCon
$LN14@SV_FakeCon:

; 465  : 		svs.last_heartbeat = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0
$LN13@SV_FakeCon:

; 466  : 	
; 467  : 	return cl->edict;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
$LN1@SV_FakeCon:

; 468  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FakeConnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_args$ = -1040						; size = 4
_len$ = -1036						; size = 4
_pcmd$ = -1032						; size = 4
_buf$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_SV_ConnectionlessPacket PROC

; 2072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1040				; 00000410H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2073 : 	char	*args;
; 2074 : 	char	*pcmd, buf[MAX_SYSPATH];
; 2075 : 	int	len = sizeof( buf );

	mov	DWORD PTR _len$[ebp], 1024		; 00000400H

; 2076 : 
; 2077 : 	MSG_Clear( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 2078 : 	MSG_ReadLong( msg );// skip the -1 marker

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4

; 2079 : 
; 2080 : 	args = MSG_ReadStringLine( msg );

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$[ebp], eax

; 2081 : 	Cmd_TokenizeString( args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 2082 : 
; 2083 : 	pcmd = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _pcmd$[ebp], eax

; 2084 : 	Con_Reportf( "SV_ConnectionlessPacket: %s : %s\n", NET_AdrToString( from ), pcmd );

	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG137340
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2085 : 
; 2086 : 	if( !Q_strcmp( pcmd, "ping" )) SV_Ping( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137343
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_Connect
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_Ping
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN2@SV_Connect:

; 2087 : 	else if( !Q_strcmp( pcmd, "ack" )) SV_Ack( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137346
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@SV_Connect
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_Ack
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN4@SV_Connect:

; 2088 : 	else if( !Q_strcmp( pcmd, "info" )) SV_Info( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137349
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_Connect
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_Info
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN6@SV_Connect:

; 2089 : 	else if( !Q_strcmp( pcmd, "bandwidth" )) SV_TestBandWidth( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137352
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_Connect
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_TestBandWidth
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN8@SV_Connect:

; 2090 : 	else if( !Q_strcmp( pcmd, "getchallenge" )) SV_GetChallenge( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137355
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@SV_Connect
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_GetChallenge
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN10@SV_Connect:

; 2091 : 	else if( !Q_strcmp( pcmd, "connect" )) SV_ConnectClient( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137358
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_Connect
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_ConnectClient
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN12@SV_Connect:

; 2092 : 	else if( !Q_strcmp( pcmd, "rcon" )) SV_RemoteCommand( from, msg );

	push	99999					; 0001869fH
	push	OFFSET $SG137361
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_Connect
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RemoteCommand
	add	esp, 24					; 00000018H
	jmp	$LN1@SV_Connect
$LN14@SV_Connect:

; 2093 : 	else if( !Q_strcmp( pcmd, "netinfo" )) SV_BuildNetAnswer( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137364
	mov	edx, DWORD PTR _pcmd$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_BuildNetAnswer
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN16@SV_Connect:

; 2094 : 	else if( !Q_strcmp( pcmd, "s" )) SV_AddToMaster( from, msg );

	push	99999					; 0001869fH
	push	OFFSET $SG137367
	mov	edx, DWORD PTR _pcmd$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@SV_Connect
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_AddToMaster
	add	esp, 24					; 00000018H
	jmp	$LN1@SV_Connect
$LN18@SV_Connect:

; 2095 : 	else if( !Q_strcmp( pcmd, "T" "Source" )) SV_TSourceEngineQuery( from );

	push	99999					; 0001869fH
	push	OFFSET $SG137370
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@SV_Connect
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_TSourceEngineQuery
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN20@SV_Connect:

; 2096 : 	else if( !Q_strcmp( pcmd, "i" )) NET_SendPacket( NS_SERVER, 5, "\xFF\xFF\xFF\xFFj", from ); // A2A_PING

	push	99999					; 0001869fH
	push	OFFSET $SG137373
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@SV_Connect
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	OFFSET $SG137374
	push	5
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
	jmp	$LN1@SV_Connect
$LN22@SV_Connect:

; 2097 : 	else if( svgame.dllFuncs.pfnConnectionlessPacket( &from, args, buf, &len ))

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	DWORD PTR _svgame+19420
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN24@SV_Connect

; 2098 : 	{
; 2099 : 		// user out of band message (must be handled in CL_ConnectionlessPacket)
; 2100 : 		if( len > 0 ) Netchan_OutOfBand( NS_SERVER, from, len, buf );

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN26@SV_Connect
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBand
	add	esp, 32					; 00000020H
$LN26@SV_Connect:

; 2101 : 	}

	jmp	SHORT $LN1@SV_Connect
$LN24@SV_Connect:

; 2102 : 	else Con_DPrintf( S_ERROR "bad connectionless packet from %s:\n%s\n", NET_AdrToString( from ), args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG137378
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN1@SV_Connect:

; 2103 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ConnectionlessPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_c$ = -16						; size = 4
_move_issued$ = -12					; size = 4
tv144 = -8						; size = 4
_frame$ = -4						; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ExecuteClientMessage PROC

; 2375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2376 : 	qboolean		move_issued = false;

	mov	DWORD PTR _move_issued$[ebp], 0

; 2377 : 	client_frame_t	*frame;
; 2378 : 	int		c;
; 2379 : 
; 2380 : 	ASSERT( cl->frames != NULL );

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+281916], 0
	jne	SHORT $LN6@SV_Execute
	push	2380					; 0000094cH
	push	OFFSET $SG137506
	push	OFFSET $SG137507
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN6@SV_Execute:

; 2381 : 
; 2382 : 	// calc ping time
; 2383 : 	frame = &cl->frames[cl->netchan.incoming_acknowledged & SV_UPDATE_MASK];

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	and	ecx, DWORD PTR [edx+628]
	imul	eax, ecx, 6128
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+281916]
	mov	DWORD PTR _frame$[ebp], eax

; 2384 : 
; 2385 : 	// ping time doesn't factor in message interval, either
; 2386 : 	frame->ping_time = host.realtime - frame->senttime - cl->cl_updaterate;

	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [edx]
	mov	eax, DWORD PTR _cl$[ebp]
	subsd	xmm0, QWORD PTR [eax+264392]
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 2387 : 
; 2388 : 	// on first frame ( no senttime ) don't skew ping
; 2389 : 	if( frame->senttime == 0.0f ) frame->ping_time = 0.0f;

	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@SV_Execute
	mov	eax, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0
$LN7@SV_Execute:

; 2390 : 
; 2391 : 	// don't skew ping based on signon stuff either
; 2392 : 	if(( host.realtime - cl->connection_started ) < 2.0f && ( frame->ping_time > 0.0 ))

	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx+264408]
	movsd	xmm1, QWORD PTR __real@4000000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@SV_Execute
	mov	edx, DWORD PTR _frame$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+8]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN8@SV_Execute

; 2393 : 		frame->ping_time = 0.0f;

	mov	eax, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0
$LN8@SV_Execute:

; 2394 : 
; 2395 : 	cl->latency = SV_CalcClientTime( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_CalcClientTime
	add	esp, 4
	mov	edx, DWORD PTR _cl$[ebp]
	fstp	DWORD PTR [edx+264972]

; 2396 : 	cl->delta_sequence = -1; // no delta unless requested

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264364], -1
$LN2@SV_Execute:

; 2397 : 				
; 2398 : 	// read optional clientCommand strings
; 2399 : 	while( cl->state != cs_zombie )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 1
	je	$LN3@SV_Execute

; 2400 : 	{
; 2401 : 		if( MSG_CheckOverflow( msg ))

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@SV_Execute

; 2402 : 		{
; 2403 : 			Con_DPrintf( S_ERROR "incoming overflow for %s\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG137511
	call	_Con_DPrintf
	add	esp, 8

; 2404 : 			SV_DropClient( cl, false );

	push	0
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_DropClient
	add	esp, 8

; 2405 : 			return;

	jmp	$LN3@SV_Execute
$LN9@SV_Execute:

; 2406 : 		}
; 2407 : 
; 2408 : 		// end of message
; 2409 : 		if( MSG_GetNumBitsLeft( msg ) < 8 )

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN10@SV_Execute

; 2410 : 			break;

	jmp	$LN3@SV_Execute
$LN10@SV_Execute:

; 2411 : 
; 2412 : 		c = MSG_ReadClientCmd( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCmd
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 2413 : 
; 2414 : 		switch( c )

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR tv144[ebp]
	sub	edx, 1
	mov	DWORD PTR tv144[ebp], edx
	cmp	DWORD PTR tv144[ebp], 9
	ja	$LN21@SV_Execute
	mov	eax, DWORD PTR tv144[ebp]
	jmp	DWORD PTR $LN23@SV_Execute[eax*4]
$LN11@SV_Execute:

; 2415 : 		{
; 2416 : 		case clc_nop:
; 2417 : 			break;

	jmp	$LN4@SV_Execute
$LN12@SV_Execute:

; 2418 : 		case clc_delta:
; 2419 : 			cl->delta_sequence = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+264364], eax

; 2420 : 			break;

	jmp	$LN4@SV_Execute
$LN13@SV_Execute:

; 2421 : 		case clc_move:
; 2422 : 			if( move_issued ) return; // someone is trying to cheat...

	cmp	DWORD PTR _move_issued$[ebp], 0
	je	SHORT $LN14@SV_Execute
	jmp	$LN3@SV_Execute
$LN14@SV_Execute:

; 2423 : 			move_issued = true;

	mov	DWORD PTR _move_issued$[ebp], 1

; 2424 : 			SV_ParseClientMove( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseClientMove
	add	esp, 8

; 2425 : 			break;

	jmp	$LN4@SV_Execute
$LN15@SV_Execute:

; 2426 : 		case clc_stringcmd:	
; 2427 : 			SV_ExecuteClientCommand( cl, MSG_ReadString( msg ));

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ExecuteClientCommand
	add	esp, 8

; 2428 : 			if( cl->state == cs_zombie )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN16@SV_Execute

; 2429 : 				return; // disconnect command

	jmp	SHORT $LN3@SV_Execute
$LN16@SV_Execute:

; 2430 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN17@SV_Execute:

; 2431 : 		case clc_resourcelist:
; 2432 : 			SV_ParseResourceList( cl, msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ParseResourceList
	add	esp, 8

; 2433 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN18@SV_Execute:

; 2434 : 		case clc_fileconsistency:
; 2435 : 			SV_ParseConsistencyResponse( cl, msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_ParseConsistencyResponse
	add	esp, 8

; 2436 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN19@SV_Execute:

; 2437 : 		case clc_requestcvarvalue:
; 2438 : 			SV_ParseCvarValue( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseCvarValue
	add	esp, 8

; 2439 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN20@SV_Execute:

; 2440 : 		case clc_requestcvarvalue2:
; 2441 : 			SV_ParseCvarValue2( cl, msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ParseCvarValue2
	add	esp, 8

; 2442 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN21@SV_Execute:

; 2443 : 		default:
; 2444 : 			Con_DPrintf( S_ERROR "%s: clc_bad\n", cl->name );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG137524
	call	_Con_DPrintf
	add	esp, 8

; 2445 : 			SV_DropClient( cl, false );

	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_DropClient
	add	esp, 8

; 2446 : 			return;

	jmp	SHORT $LN3@SV_Execute
$LN4@SV_Execute:

; 2447 : 		}
; 2448 : 	}

	jmp	$LN2@SV_Execute
$LN3@SV_Execute:

; 2449 :  }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@SV_Execute:
	DD	$LN11@SV_Execute
	DD	$LN13@SV_Execute
	DD	$LN15@SV_Execute
	DD	$LN12@SV_Execute
	DD	$LN17@SV_Execute
	DD	$LN21@SV_Execute
	DD	$LN18@SV_Execute
	DD	$LN21@SV_Execute
	DD	$LN19@SV_Execute
	DD	$LN20@SV_Execute
_SV_ExecuteClientMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -264						; size = 4
_message$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_cl$ = 12						; size = 4
_SV_SendServerdata PROC

; 1371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1372 : 	string	message;
; 1373 : 	int	i;
; 1374 : 
; 1375 : 	// Only send this message to developer console, or multiplayer clients.
; 1376 : 	if(( host_developer.value ) || ( svs.maxclients > 1 ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@SV_SendSer
	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN11@SV_SendSer
$LN12@SV_SendSer:

; 1377 : 	{
; 1378 : 		MSG_BeginServerCmd( msg, svc_print );

	push	0
	push	1
	push	8
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1379 : 		Q_snprintf( message, sizeof( message ), "\n^3BUILD %d SERVER (%i CRC)\nServer #%i\n", Q_buildnum(), sv.progsCRC, svs.spawncount );

	mov	ecx, DWORD PTR _svs+33340
	push	ecx
	mov	edx, DWORD PTR _sv+52
	push	edx
	call	_Q_buildnum
	push	eax
	push	OFFSET $SG137053
	push	256					; 00000100H
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 1380 : 		MSG_WriteString( msg, message );

	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8
$LN11@SV_SendSer:

; 1381 : 	}
; 1382 : 
; 1383 : 	// send the serverdata
; 1384 : 	MSG_BeginServerCmd( msg, svc_serverdata );

	push	0
	push	1
	push	11					; 0000000bH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1385 : 	MSG_WriteLong( msg, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1386 : 	MSG_WriteLong( msg, svs.spawncount );

	mov	edx, DWORD PTR _svs+33340
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 1387 : 	MSG_WriteLong( msg, sv.worldmapCRC );

	mov	ecx, DWORD PTR _sv+48
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 1388 : 	MSG_WriteByte( msg, cl - svs.clients );

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 1389 : 	MSG_WriteByte( msg, svs.maxclients );

	mov	eax, DWORD PTR _svs+16
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 1390 : 	MSG_WriteWord( msg, GI->max_edicts );

	mov	edx, DWORD PTR _SI+768
	mov	eax, DWORD PTR [edx+1656]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 1391 : 	MSG_WriteWord( msg, MAX_MODELS );

	push	1024					; 00000400H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteWord
	add	esp, 8

; 1392 : 	MSG_WriteString( msg, sv.name );

	push	OFFSET _sv+56
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1393 : 	MSG_WriteString( msg, STRING( svgame.edicts->v.message )); // Map Message

	mov	ecx, DWORD PTR _svgame+7928
	mov	edx, DWORD PTR [ecx+596]
	push	edx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1394 : 	MSG_WriteOneBit( msg, sv.background ); // tell client about background map

	mov	ecx, DWORD PTR _sv+4
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8

; 1395 : 	MSG_WriteString( msg, GI->gamefolder );

	mov	eax, DWORD PTR _SI+768
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1396 : 	MSG_WriteLong( msg, host.features );

	mov	edx, DWORD PTR _host+34748
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 1397 : 
; 1398 : 	// send the player hulls
; 1399 : 	for( i = 0; i < MAX_MAP_HULLS * 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SendSer
$LN2@SV_SendSer:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_SendSer:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN3@SV_SendSer

; 1400 : 	{
; 1401 : 		MSG_WriteChar( msg, host.player_mins[i/3][i%3] );

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	imul	ecx, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	cvttss2si edx, DWORD PTR _host[ecx+edx*4+34236]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteChar
	add	esp, 8

; 1402 : 		MSG_WriteChar( msg, host.player_maxs[i/3][i%3] );

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	imul	ecx, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	cvttss2si edx, DWORD PTR _host[ecx+edx*4+34284]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteChar
	add	esp, 8

; 1403 : 	}

	jmp	$LN2@SV_SendSer
$LN3@SV_SendSer:

; 1404 : 
; 1405 : 	// send delta-encoding
; 1406 : 	SV_WriteDeltaDescriptionToClient( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_SV_WriteDeltaDescriptionToClient
	add	esp, 4

; 1407 : 
; 1408 : 	// now client know delta and can reading encoded messages
; 1409 : 	SV_FullUpdateMovevars( cl, msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_FullUpdateMovevars
	add	esp, 8

; 1410 : 
; 1411 : 	// send the user messages registration
; 1412 : 	for( i = 1; i < MAX_USER_MESSAGES && svgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@SV_SendSer
$LN5@SV_SendSer:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@SV_SendSer:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN6@SV_SendSer
	imul	edx, DWORD PTR _i$[ebp], 40
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _svgame[edx+ecx+4]
	test	edx, edx
	je	SHORT $LN6@SV_SendSer

; 1413 : 		SV_SendUserReg( msg, &svgame.msg[i] );

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svgame+4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_SV_SendUserReg
	add	esp, 8
	jmp	SHORT $LN5@SV_SendSer
$LN6@SV_SendSer:

; 1414 : 
; 1415 : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SV_SendSer
$LN8@SV_SendSer:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@SV_SendSer:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN9@SV_SendSer

; 1416 : 	{
; 1417 : 		if( !sv.lightstyles[i].pattern[0] )

	imul	eax, DWORD PTR _i$[ebp], 1296
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+333000]
	test	eax, eax
	jne	SHORT $LN13@SV_SendSer

; 1418 : 			continue;	// unused style

	jmp	SHORT $LN8@SV_SendSer
$LN13@SV_SendSer:

; 1419 : 
; 1420 : 		MSG_BeginServerCmd( msg, svc_lightstyle );

	push	0
	push	1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1421 : 		MSG_WriteByte( msg, i ); // stylenum

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 1422 : 		MSG_WriteString( msg, sv.lightstyles[i].pattern );

	imul	ecx, DWORD PTR _i$[ebp], 1296
	add	ecx, OFFSET _sv+333000
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 1423 : 		MSG_WriteFloat( msg, sv.lightstyles[i].time );

	imul	eax, DWORD PTR _i$[ebp], 1296
	push	ecx
	movss	xmm0, DWORD PTR _sv[eax+334292]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteFloat
	add	esp, 8

; 1424 : 	}

	jmp	$LN8@SV_SendSer
$LN9@SV_SendSer:

; 1425 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendServerdata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_ping$ = 12						; size = 4
_packet_loss$ = 16					; size = 4
_SV_GetPlayerStats PROC

; 1138 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1139 : 	static int	last_ping[MAX_CLIENTS];
; 1140 : 	static int	last_loss[MAX_CLIENTS];
; 1141 : 	int		i;
; 1142 : 
; 1143 : 	i = cl - svs.clients;

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	mov	DWORD PTR _i$[ebp], eax

; 1144 : 
; 1145 : 	if( host.realtime >= cl->next_checkpingtime )

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [edx+264376]
	jb	SHORT $LN2@SV_GetPlay

; 1146 : 	{
; 1147 : 		cl->next_checkpingtime = host.realtime + 2.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264376], xmm0

; 1148 : 		last_ping[i] = SV_CalcPing( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_CalcPing
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?last_ping@?1??SV_GetPlayerStats@@9@9[edx*4], eax

; 1149 : 		last_loss[i] = cl->packet_loss;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264968]
	mov	DWORD PTR ?last_loss@?1??SV_GetPlayerStats@@9@9[eax*4], edx
$LN2@SV_GetPlay:

; 1150 : 	}
; 1151 : 
; 1152 : 	if( ping ) *ping = last_ping[i];

	cmp	DWORD PTR _ping$[ebp], 0
	je	SHORT $LN3@SV_GetPlay
	mov	eax, DWORD PTR _ping$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?last_ping@?1??SV_GetPlayerStats@@9@9[ecx*4]
	mov	DWORD PTR [eax], edx
$LN3@SV_GetPlay:

; 1153 : 	if( packet_loss ) *packet_loss = last_loss[i];

	cmp	DWORD PTR _packet_loss$[ebp], 0
	je	SHORT $LN4@SV_GetPlay
	mov	eax, DWORD PTR _packet_loss$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?last_loss@?1??SV_GetPlayerStats@@9@9[ecx*4]
	mov	DWORD PTR [eax], edx
$LN4@SV_GetPlay:

; 1154 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetPlayerStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_nullmovevars$ = -148					; size = 144
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_FullUpdateMovevars PROC

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1086 : 	movevars_t	nullmovevars;
; 1087 : 
; 1088 : 	memset( &nullmovevars, 0, sizeof( nullmovevars ));

	push	144					; 00000090H
	push	0
	lea	eax, DWORD PTR _nullmovevars$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1089 : 	MSG_WriteDeltaMovevars( msg, &nullmovevars, &svgame.movevars );

	push	OFFSET _svgame+7936
	lea	ecx, DWORD PTR _nullmovevars$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteDeltaMovevars
	add	esp, 12					; 0000000cH

; 1090 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FullUpdateMovevars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -368						; size = 4
_ctx$ = -364						; size = 88
_info$ = -276						; size = 256
_digest$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_FullClientUpdate PROC

; 1024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1025 : 	char		info[MAX_INFO_STRING];
; 1026 : 	char		digest[16];
; 1027 : 	MD5Context_t	ctx;
; 1028 : 	int		i;	
; 1029 : 
; 1030 : 	// process userinfo before updating
; 1031 : 	SV_UserinfoChanged( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_UserinfoChanged
	add	esp, 4

; 1032 : 
; 1033 : 	i = cl - svs.clients;

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	mov	DWORD PTR _i$[ebp], eax

; 1034 : 
; 1035 : 	MSG_BeginServerCmd( msg, svc_updateuserinfo );

	push	0
	push	1
	push	13					; 0000000dH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1036 : 	MSG_WriteUBitLong( msg, i, MAX_CLIENT_BITS );

	push	5
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 1037 : 	MSG_WriteLong( msg, cl->userid );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+287556]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1038 : 
; 1039 : 	if( cl->name[0] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+8]
	test	edx, edx
	je	$LN2@SV_FullCli

; 1040 : 	{
; 1041 : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 1042 : 
; 1043 : 		Q_strncpy( info, cl->userinfo, sizeof( info ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	lea	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1044 : 
; 1045 : 		// remove server passwords, etc.
; 1046 : 		Info_RemovePrefixedKeys( info, '_' );

	push	95					; 0000005fH
	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_Info_RemovePrefixedKeys
	add	esp, 8

; 1047 : 		MSG_WriteString( msg, info );

	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 1048 : 
; 1049 : 		MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 1050 : 		MD5Update( &ctx, cl->hashedcdkey, sizeof( cl->hashedcdkey ));

	push	34					; 00000022H
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264416				; 000408e0H
	push	ecx
	lea	edx, DWORD PTR _ctx$[ebp]
	push	edx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 1051 : 		MD5Final( digest, &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _digest$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 1052 : 
; 1053 : 		MSG_WriteBytes( msg, digest, sizeof( digest ));

	push	16					; 00000010H
	lea	edx, DWORD PTR _digest$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1054 : 	}

	jmp	SHORT $LN1@SV_FullCli
$LN2@SV_FullCli:

; 1055 : 	else MSG_WriteOneBit( msg, 0 );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_FullCli:

; 1056 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FullClientUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_GetClientIDString PROC

; 597  : {

	push	ebp
	mov	ebp, esp

; 598  : 	static char	result[MAX_QPATH];
; 599  : 
; 600  : 	if( !cl ) return "";

	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@SV_GetClie
	mov	eax, OFFSET $SG136661
	jmp	$LN1@SV_GetClie
$LN2@SV_GetClie:

; 601  : 
; 602  : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN3@SV_GetClie

; 603  : 	{
; 604  : 		Q_strncpy( result, "ID_BOT", sizeof( result ));

	push	64					; 00000040H
	push	OFFSET $SG136664
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 605  : 	}

	jmp	$LN8@SV_GetClie
$LN3@SV_GetClie:

; 606  : 	else if( NET_IsLocalAddress( cl->netchan.remote_address ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN5@SV_GetClie

; 607  : 	{
; 608  : 		Q_strncpy( result, "ID_LOOPBACK", sizeof( result ));

	push	64					; 00000040H
	push	OFFSET $SG136667
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 609  : 	}

	jmp	SHORT $LN8@SV_GetClie
$LN5@SV_GetClie:

; 610  : 	else if( sv_lan.value )

	movss	xmm0, DWORD PTR _sv_lan+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@SV_GetClie

; 611  : 	{
; 612  : 		Q_strncpy( result, "ID_LAN", sizeof( result ));

	push	64					; 00000040H
	push	OFFSET $SG136670
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 613  : 	}

	jmp	SHORT $LN8@SV_GetClie
$LN7@SV_GetClie:

; 614  : 	else
; 615  : 	{
; 616  : 		Q_snprintf( result, sizeof( result ), "ID_%s", MD5_Print( cl->hashedcdkey ));

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264416				; 000408e0H
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET $SG136671
	push	64					; 00000040H
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN8@SV_GetClie:

; 617  : 	}
; 618  : 
; 619  : 	return result;

	mov	eax, OFFSET ?result@?1??SV_GetClientIDString@@9@9
$LN1@SV_GetClie:

; 620  : }

	pop	ebp
	ret	0
_SV_GetClientIDString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
tv75 = -4						; size = 4
_cl$ = 8						; size = 4
_SV_ShouldUpdatePing PROC

; 1101 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1102 : 	if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	je	SHORT $LN2@SV_ShouldU

; 1103 : 	{
; 1104 : 		if( host.realtime < cl->next_checkpingtime )

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [edx+264376]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN3@SV_ShouldU

; 1105 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN3@SV_ShouldU:

; 1106 : 
; 1107 : 		cl->next_checkpingtime = host.realtime + 2.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264376], xmm0

; 1108 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_ShouldU
$LN2@SV_ShouldU:

; 1109 : 	}
; 1110 : 
; 1111 : 	// they are viewing the scoreboard.  Send them pings.
; 1112 : 	return FBitSet( cl->lastcmd.buttons, IN_SCORE ) ? true : false;

	mov	ecx, DWORD PTR _cl$[ebp]
	movzx	edx, WORD PTR [ecx+264918]
	and	edx, 32768				; 00008000H
	je	SHORT $LN5@SV_ShouldU
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN6@SV_ShouldU
$LN5@SV_ShouldU:
	mov	DWORD PTR tv75[ebp], 0
$LN6@SV_ShouldU:
	mov	eax, DWORD PTR tv75[ebp]
$LN1@SV_ShouldU:

; 1113 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ShouldUpdatePing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_SV_TogglePause PROC

; 1315 : {

	push	ebp
	mov	ebp, esp

; 1316 : 	if( sv.background ) return;

	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_ToggleP
	jmp	SHORT $LN1@SV_ToggleP
$LN2@SV_ToggleP:

; 1317 : 
; 1318 : 	sv.paused ^= 1;

	mov	eax, DWORD PTR _sv+1359688
	xor	eax, 1
	mov	DWORD PTR _sv+1359688, eax

; 1319 : 
; 1320 : 	if( COM_CheckString( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_ToggleP

; 1321 : 		SV_BroadcastPrintf( NULL, "%s", msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	OFFSET $SG137013
	push	0
	call	_SV_BroadcastPrintf
	add	esp, 12					; 0000000cH
$LN3@SV_ToggleP:

; 1322 : 
; 1323 : 	// send notification to all clients
; 1324 : 	MSG_BeginServerCmd( &sv.reliable_datagram, svc_setpause );

	push	0
	push	1
	push	24					; 00000018H
	push	OFFSET _sv+1195756
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1325 : 	MSG_WriteOneBit( &sv.reliable_datagram, sv.paused );

	mov	eax, DWORD PTR _sv+1359688
	push	eax
	push	OFFSET _sv+1195756
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_ToggleP:

; 1326 : }

	pop	ebp
	ret	0
_SV_TogglePause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_oldestTime$ = -16					; size = 8
_oldest$ = -8						; size = 4
_i$ = -4						; size = 4
_from$ = 8						; size = 20
_SV_GetChallenge PROC

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 58   : 	int	i, oldest = 0;

	mov	DWORD PTR _oldest$[ebp], 0

; 59   : 	double	oldestTime;
; 60   : 
; 61   : 	oldestTime = 0x7fffffff;

	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	movsd	QWORD PTR _oldestTime$[ebp], xmm0

; 62   : 
; 63   : 	// see if we already have a challenge for this ip
; 64   : 	for( i = 0; i < MAX_CHALLENGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_GetChal
$LN2@SV_GetChal:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_GetChal:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@SV_GetChal

; 65   : 	{
; 66   : 		if( !svs.challenges[i].connected && NET_CompareAdr( from, svs.challenges[i].adr ))

	imul	ecx, DWORD PTR _i$[ebp], 40
	cmp	DWORD PTR _svs[ecx+33412], 0
	jne	SHORT $LN5@SV_GetChal
	imul	edx, DWORD PTR _i$[ebp], 40
	add	edx, OFFSET _svs+33376
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN5@SV_GetChal

; 67   : 			break;

	jmp	SHORT $LN3@SV_GetChal
$LN5@SV_GetChal:

; 68   : 
; 69   : 		if( svs.challenges[i].time < oldestTime )

	imul	edx, DWORD PTR _i$[ebp], 40
	movsd	xmm0, QWORD PTR _oldestTime$[ebp]
	comisd	xmm0, QWORD PTR _svs[edx+33400]
	jbe	SHORT $LN6@SV_GetChal

; 70   : 		{
; 71   : 			oldestTime = svs.challenges[i].time;

	imul	eax, DWORD PTR _i$[ebp], 40
	movsd	xmm0, QWORD PTR _svs[eax+33400]
	movsd	QWORD PTR _oldestTime$[ebp], xmm0

; 72   : 			oldest = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _oldest$[ebp], ecx
$LN6@SV_GetChal:

; 73   : 		}
; 74   : 	}

	jmp	$LN2@SV_GetChal
$LN3@SV_GetChal:

; 75   : 
; 76   : 	if( i == MAX_CHALLENGES )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN7@SV_GetChal

; 77   : 	{
; 78   : 		// this is the first time this client has asked for a challenge
; 79   : 		svs.challenges[oldest].challenge = (COM_RandomLong( 0, 0xFFFF ) << 16) | COM_RandomLong( 0, 0xFFFF );

	push	65535					; 0000ffffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	esi, eax
	shl	esi, 16					; 00000010H
	push	65535					; 0000ffffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	or	esi, eax
	imul	edx, DWORD PTR _oldest$[ebp], 40
	mov	DWORD PTR _svs[edx+33408], esi

; 80   : 		svs.challenges[oldest].adr = from;

	imul	eax, DWORD PTR _oldest$[ebp], 40
	add	eax, OFFSET _svs+33376
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 81   : 		svs.challenges[oldest].time = host.realtime;

	imul	edx, DWORD PTR _oldest$[ebp], 40
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _svs[edx+33400], xmm0

; 82   : 		svs.challenges[oldest].connected = false;

	imul	eax, DWORD PTR _oldest$[ebp], 40
	mov	DWORD PTR _svs[eax+33412], 0

; 83   : 		i = oldest;

	mov	ecx, DWORD PTR _oldest$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
$LN7@SV_GetChal:

; 84   : 	}
; 85   : 
; 86   : 	// send it back
; 87   : 	Netchan_OutOfBandPrint( NS_SERVER, svs.challenges[i].adr, "challenge %i", svs.challenges[i].challenge );

	imul	edx, DWORD PTR _i$[ebp], 40
	mov	eax, DWORD PTR _svs[edx+33408]
	push	eax
	push	OFFSET $SG136429
	imul	ecx, DWORD PTR _i$[ebp], 40
	add	ecx, OFFSET _svs+33376
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 88   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetChallenge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_RefreshUserinfo PROC

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1066 : 	sv_client_t	*cl;
; 1067 : 	int		i;
; 1068 : 
; 1069 : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Refresh
$LN2@SV_Refresh:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_Refresh:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_Refresh

; 1070 : 	{
; 1071 : 		if( cl->state >= cs_connected )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN5@SV_Refresh

; 1072 : 			SetBits( cl->flags, FCL_RESEND_USERINFO );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN5@SV_Refresh:

; 1073 : 	}

	jmp	SHORT $LN2@SV_Refresh
$LN1@SV_Refresh:

; 1074 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RefreshUserinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
$T1 = -1036						; size = 4
_i$ = -1032						; size = 4
_remaining$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_SV_RemoteCommand PROC

; 856  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1036				; 0000040cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 857  : 	static char	outputbuf[2048];
; 858  : 	char		remaining[1024];
; 859  : 	int		i;
; 860  : 
; 861  : 	Con_Printf( "Rcon from %s:\n%s\n", NET_AdrToString( from ), MSG_GetData( msg ) + 4 );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	add	eax, 4
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG136811
	call	_Con_Printf

; 862  : 	Log_Printf( "Rcon: \"%s\" from \"%s\"\n", MSG_GetData( msg ) + 4, NET_AdrToString( from ));

	add	esp, -8					; fffffff8H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	add	eax, 4
	push	eax
	push	OFFSET $SG136812
	call	_Log_Printf
	add	esp, 12					; 0000000cH

; 863  : 	SV_BeginRedirect( from, RD_PACKET, outputbuf, sizeof( outputbuf ) - 16, SV_FlushRedirect );

	push	OFFSET _SV_FlushRedirect
	push	2032					; 000007f0H
	push	OFFSET ?outputbuf@?1??SV_RemoteCommand@@9@9
	push	2
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_BeginRedirect
	add	esp, 36					; 00000024H

; 864  : 
; 865  : 	if( Rcon_Validate( ))

	call	_Rcon_Validate
	test	eax, eax
	je	$LN5@SV_RemoteC

; 866  : 	{
; 867  : 		remaining[0] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN8@SV_RemoteC
	jmp	SHORT $LN9@SV_RemoteC
$LN8@SV_RemoteC:
	call	___report_rangecheckfailure
$LN9@SV_RemoteC:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _remaining$[ebp+ecx], 0

; 868  : 		for( i = 2; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN4@SV_RemoteC
$LN2@SV_RemoteC:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_RemoteC:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@SV_RemoteC

; 869  : 		{
; 870  : 			Q_strcat( remaining, Cmd_Argv( i ));

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _remaining$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 871  : 			Q_strcat( remaining, " " );

	push	99999					; 0001869fH
	push	OFFSET $SG136815
	lea	edx, DWORD PTR _remaining$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 872  : 		}

	jmp	SHORT $LN2@SV_RemoteC
$LN3@SV_RemoteC:

; 873  : 		Cmd_ExecuteString( remaining );

	lea	eax, DWORD PTR _remaining$[ebp]
	push	eax
	call	_Cmd_ExecuteString
	add	esp, 4

; 874  : 	}

	jmp	SHORT $LN6@SV_RemoteC
$LN5@SV_RemoteC:

; 875  : 	else Con_Printf( S_ERROR "Bad rcon_password.\n" );

	push	OFFSET $SG136816
	call	_Con_Printf
	add	esp, 4
$LN6@SV_RemoteC:

; 876  : 
; 877  : 	SV_EndRedirect();

	call	_SV_EndRedirect
$LN7@SV_RemoteC:

; 878  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RemoteCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_ent$ = -560						; size = 4
_i$1 = -556						; size = 4
tv172 = -552						; size = 4
tv276 = -548						; size = 4
tv275 = -544						; size = 4
tv215 = -540						; size = 4
tv214 = -536						; size = 4
_dupc$ = -532						; size = 4
_i$ = -528						; size = 4
_current$ = -524					; size = 4
_val$ = -520						; size = 4
_name2$ = -516						; size = 256
_name1$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_UserinfoChanged PROC

; 1565 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1566 : 	int		i, dupc = 1;

	mov	DWORD PTR _dupc$[ebp], 1

; 1567 : 	edict_t		*ent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _ent$[ebp], ecx

; 1568 : 	string		name1, name2;	
; 1569 : 	sv_client_t	*current;
; 1570 : 	char		*val;
; 1571 : 
; 1572 : 	if( !COM_CheckString( cl->userinfo ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@SV_Userinf

; 1573 : 		return;

	jmp	$LN1@SV_Userinf
$LN7@SV_Userinf:

; 1574 : 
; 1575 : 	val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET $SG137120
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1576 : 	Q_strncpy( name2, val, sizeof( name2 ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name2$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1577 : 	COM_TrimSpace( name2, name1 );

	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	call	_COM_TrimSpace
	add	esp, 8

; 1578 : 
; 1579 : 	if( !Q_stricmp( name1, "console" ))

	push	99999					; 0001869fH
	push	OFFSET $SG137123
	lea	edx, DWORD PTR _name1$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_Userinf

; 1580 : 	{
; 1581 : 		Info_SetValueForKey( cl->userinfo, "name", "unnamed", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG137124
	push	OFFSET $SG137125
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1582 : 		val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET $SG137126
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1583 : 	}

	jmp	SHORT $LN10@SV_Userinf
$LN8@SV_Userinf:

; 1584 : 	else if( Q_strcmp( name1, val ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@SV_Userinf

; 1585 : 	{
; 1586 : 		Info_SetValueForKey( cl->userinfo, "name", name1, MAX_INFO_STRING );

	push	256					; 00000100H
	lea	ecx, DWORD PTR _name1$[ebp]
	push	ecx
	push	OFFSET $SG137128
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1587 : 		val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET $SG137129
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax
$LN10@SV_Userinf:

; 1588 : 	}
; 1589 : 
; 1590 : 	if( !Q_strlen( name1 ))

	lea	ecx, DWORD PTR _name1$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SV_Userinf

; 1591 : 	{
; 1592 : 		Info_SetValueForKey( cl->userinfo, "name", "unnamed", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET $SG137131
	push	OFFSET $SG137132
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1593 : 		val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET $SG137133
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1594 : 		Q_strncpy( name2, "unnamed", sizeof( name2 ));

	push	256					; 00000100H
	push	OFFSET $SG137134
	lea	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1595 : 		Q_strncpy( name1, "unnamed", sizeof( name1 ));

	push	256					; 00000100H
	push	OFFSET $SG137135
	lea	edx, DWORD PTR _name1$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN11@SV_Userinf:

; 1596 : 	}
; 1597 : 
; 1598 : 	// check to see if another user by the same name exists
; 1599 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@SV_Userinf

; 1600 : 	{
; 1601 : 		for( i = 0, current = svs.clients; i < svs.maxclients; i++, current++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _current$[ebp], ecx
	jmp	SHORT $LN6@SV_Userinf
$LN4@SV_Userinf:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _current$[ebp], eax
$LN6@SV_Userinf:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN5@SV_Userinf

; 1602 : 		{
; 1603 : 			if( current == cl || current->state != cs_spawned )

	mov	edx, DWORD PTR _current$[ebp]
	cmp	edx, DWORD PTR _cl$[ebp]
	je	SHORT $LN13@SV_Userinf
	mov	eax, DWORD PTR _current$[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN12@SV_Userinf
$LN13@SV_Userinf:

; 1604 : 				continue;

	jmp	SHORT $LN4@SV_Userinf
$LN12@SV_Userinf:

; 1605 : 
; 1606 : 			if( !Q_stricmp( current->name, val ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 8
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_Userinf

; 1607 : 				break;

	jmp	SHORT $LN5@SV_Userinf
$LN14@SV_Userinf:

; 1608 : 		}

	jmp	SHORT $LN4@SV_Userinf
$LN5@SV_Userinf:

; 1609 : 
; 1610 : 		if( i != svs.maxclients )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	je	$LN15@SV_Userinf

; 1611 : 		{
; 1612 : 			// dup name
; 1613 : 			Q_snprintf( name2, sizeof( name2 ), "%s (%u)", name1, dupc++ );

	mov	ecx, DWORD PTR _dupc$[ebp]
	mov	DWORD PTR tv172[ebp], ecx
	mov	edx, DWORD PTR tv172[ebp]
	push	edx
	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	push	OFFSET $SG137141
	push	256					; 00000100H
	lea	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _dupc$[ebp]
	add	edx, 1
	mov	DWORD PTR _dupc$[ebp], edx

; 1614 : 			Info_SetValueForKey( cl->userinfo, "name", name2, MAX_INFO_STRING );

	push	256					; 00000100H
	lea	eax, DWORD PTR _name2$[ebp]
	push	eax
	push	OFFSET $SG137142
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1615 : 			val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET $SG137143
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1616 : 			Q_strncpy( cl->name, name2, sizeof( cl->name ));

	push	32					; 00000020H
	lea	eax, DWORD PTR _name2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1617 : 		}

	jmp	SHORT $LN16@SV_Userinf
$LN15@SV_Userinf:

; 1618 : 		else
; 1619 : 		{
; 1620 : 			if( dupc == 1 ) // unchanged

	cmp	DWORD PTR _dupc$[ebp], 1
	jne	SHORT $LN17@SV_Userinf

; 1621 : 				Q_strncpy( cl->name, name1, sizeof( cl->name ));

	push	32					; 00000020H
	lea	edx, DWORD PTR _name1$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN17@SV_Userinf:

; 1622 : 			break;

	jmp	SHORT $LN3@SV_Userinf
$LN16@SV_Userinf:

; 1623 : 		}
; 1624 : 	}

	jmp	$LN11@SV_Userinf
$LN3@SV_Userinf:

; 1625 : 
; 1626 : 	// rate command
; 1627 : 	val = Info_ValueForKey( cl->userinfo, "rate" );

	push	OFFSET $SG137145
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1628 : 	if( Q_strlen( val ))

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	$LN18@SV_Userinf

; 1629 : 		cl->netchan.rate = bound( MIN_RATE, Q_atoi( val ), MAX_RATE );

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR __real@447a0000
	jb	SHORT $LN32@SV_Userinf
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@47c35000
	comiss	xmm1, xmm0
	jbe	SHORT $LN30@SV_Userinf
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv214[ebp], xmm0
	jmp	SHORT $LN31@SV_Userinf
$LN30@SV_Userinf:
	movss	xmm0, DWORD PTR __real@47c35000
	movss	DWORD PTR tv214[ebp], xmm0
$LN31@SV_Userinf:
	movss	xmm0, DWORD PTR tv214[ebp]
	movss	DWORD PTR tv215[ebp], xmm0
	jmp	SHORT $LN33@SV_Userinf
$LN32@SV_Userinf:
	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv215[ebp], xmm0
$LN33@SV_Userinf:
	cvtss2sd xmm0, DWORD PTR tv215[ebp]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+608], xmm0
	jmp	SHORT $LN19@SV_Userinf
$LN18@SV_Userinf:

; 1630 : 	else cl->netchan.rate = DEFAULT_RATE;

	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR __real@40c3878000000000
	movsd	QWORD PTR [ecx+608], xmm0
$LN19@SV_Userinf:

; 1631 : 
; 1632 : 	// movement prediction	
; 1633 : 	if( Q_atoi( Info_ValueForKey( cl->userinfo, "cl_nopred" )))

	push	OFFSET $SG137150
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@SV_Userinf

; 1634 : 		ClearBits( cl->flags, FCL_PREDICT_MOVEMENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN21@SV_Userinf
$LN20@SV_Userinf:

; 1635 : 	else SetBits( cl->flags, FCL_PREDICT_MOVEMENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN21@SV_Userinf:

; 1636 : 
; 1637 : 	// lag compensation
; 1638 : 	if( Q_atoi( Info_ValueForKey( cl->userinfo, "cl_lc" )))

	push	OFFSET $SG137153
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN22@SV_Userinf

; 1639 : 		SetBits( cl->flags, FCL_LAG_COMPENSATION );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx
	jmp	SHORT $LN23@SV_Userinf
$LN22@SV_Userinf:

; 1640 : 	else ClearBits( cl->flags, FCL_LAG_COMPENSATION );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx
$LN23@SV_Userinf:

; 1641 : 
; 1642 : 	// weapon perdiction
; 1643 : 	if( Q_atoi( Info_ValueForKey( cl->userinfo, "cl_lw" )))

	push	OFFSET $SG137156
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@SV_Userinf

; 1644 : 		SetBits( cl->flags, FCL_LOCAL_WEAPONS );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN25@SV_Userinf
$LN24@SV_Userinf:

; 1645 : 	else ClearBits( cl->flags, FCL_LOCAL_WEAPONS );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN25@SV_Userinf:

; 1646 : 
; 1647 : 	val = Info_ValueForKey( cl->userinfo, "cl_updaterate" );

	push	OFFSET $SG137157
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1648 : 
; 1649 : 	if( Q_strlen( val ))

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	$LN28@SV_Userinf

; 1650 : 	{
; 1651 : 		if( Q_atoi( val ) != 0 )

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	$LN27@SV_Userinf

; 1652 : 		{
; 1653 : 			int i = bound( 10, Q_atoi( val ), 300 );

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN36@SV_Userinf
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 300				; 0000012cH
	jge	SHORT $LN34@SV_Userinf
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN35@SV_Userinf
$LN34@SV_Userinf:
	mov	DWORD PTR tv275[ebp], 300		; 0000012cH
$LN35@SV_Userinf:
	mov	edx, DWORD PTR tv275[ebp]
	mov	DWORD PTR tv276[ebp], edx
	jmp	SHORT $LN37@SV_Userinf
$LN36@SV_Userinf:
	mov	DWORD PTR tv276[ebp], 10		; 0000000aH
$LN37@SV_Userinf:
	mov	eax, DWORD PTR tv276[ebp]
	mov	DWORD PTR _i$1[ebp], eax

; 1654 : 			cl->cl_updaterate = 1.0 / i;

	cvtsi2sd xmm0, DWORD PTR _i$1[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [ecx+264392], xmm1

; 1655 : 		}

	jmp	SHORT $LN28@SV_Userinf
$LN27@SV_Userinf:

; 1656 : 		else cl->cl_updaterate = 0.0;

	mov	edx, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [edx+264392], xmm0
$LN28@SV_Userinf:

; 1657 : 	}
; 1658 : 
; 1659 : 	// call prog code to allow overrides
; 1660 : 	svgame.dllFuncs.pfnClientUserInfoChanged( cl->edict, cl->userinfo );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	DWORD PTR _svgame+19320
	add	esp, 8

; 1661 : 
; 1662 : 	val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET $SG137161
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1663 : 	Q_strncpy( cl->name, val, sizeof( cl->name ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1664 : 	ent->v.netname = MAKE_STRING( cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+592], eax
$LN1@SV_Userinf:

; 1665 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UserinfoChanged ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_client.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_crash$ = 12						; size = 4
_SV_DropClient PROC

; 480  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 481  : 	int	i;
; 482  : 	
; 483  : 	if( cl->state == cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@SV_DropCli

; 484  : 		return;	// already dropped

	jmp	$LN12@SV_DropCli
$LN5@SV_DropCli:

; 485  : 
; 486  : 	if( !crash )

	cmp	DWORD PTR _crash$[ebp], 0
	jne	SHORT $LN6@SV_DropCli

; 487  : 	{
; 488  : 		// add the disconnect
; 489  : 		if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	jne	SHORT $LN7@SV_DropCli

; 490  : 			MSG_BeginServerCmd( &cl->netchan.message, svc_disconnect );

	push	0
	push	1
	push	2
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
$LN7@SV_DropCli:

; 491  : 
; 492  : 		if( cl->edict && cl->state == cs_spawned )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+264980], 0
	je	SHORT $LN8@SV_DropCli
	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN8@SV_DropCli

; 493  : 			svgame.dllFuncs.pfnClientDisconnect( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	push	ecx
	call	DWORD PTR _svgame+19304
	add	esp, 4
$LN8@SV_DropCli:

; 494  : 		Netchan_TransmitBits( &cl->netchan, 0, NULL );

	push	0
	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN6@SV_DropCli:

; 495  : 	}
; 496  : 
; 497  : 	ClearBits( cl->flags, FCL_FAKECLIENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 498  : 	ClearBits( cl->flags, FCL_HLTV_PROXY );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 499  : 	cl->state = cs_zombie; // become free in a few seconds

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], 1

; 500  : 	cl->name[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cl$[ebp]
	mov	BYTE PTR [eax+edx+8], 0

; 501  : 
; 502  : 	if( cl->frames )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+281916], 0
	je	SHORT $LN9@SV_DropCli

; 503  : 		Mem_Free( cl->frames ); // release delta

	push	503					; 000001f7H
	push	OFFSET $SG136614
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+281916]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@SV_DropCli:

; 504  : 	cl->frames = NULL;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+281916], 0

; 505  : 
; 506  : 	if( NET_CompareBaseAdr( cl->netchan.remote_address, host.rd.address ))

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _host+896
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _host+900
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _host+904
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _host+908
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _host+912
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_CompareBaseAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN10@SV_DropCli

; 507  : 		SV_EndRedirect();

	call	_SV_EndRedirect
$LN10@SV_DropCli:

; 508  : 
; 509  : 	// throw away any residual garbage in the channel.
; 510  : 	Netchan_Clear( &cl->netchan );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_Clear
	add	esp, 4

; 511  : 
; 512  : 	// clean client data on disconnect
; 513  : 	memset( cl->userinfo, 0, MAX_INFO_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 514  : 	memset( cl->physinfo, 0, MAX_INFO_STRING );

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 515  : 	COM_ClearCustomizationList( &cl->customdata, false );

	push	0
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 264452				; 00040904H
	push	edx
	call	_COM_ClearCustomizationList
	add	esp, 8

; 516  : 
; 517  : 	// don't send to other clients
; 518  : 	cl->edict = NULL;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264980], 0

; 519  : 
; 520  : 	// send notification to all other clients
; 521  : 	SV_FullClientUpdate( cl, &sv.reliable_datagram );

	push	OFFSET _sv+1195756
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FullClientUpdate
	add	esp, 8

; 522  : 
; 523  : 	// if this was the last client on the server, send a heartbeat
; 524  : 	// to the master so it is known the server is empty
; 525  : 	// send a heartbeat now so the master will get up to date info
; 526  : 	// if there is already a slot for this ip, reuse it
; 527  : 	for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_DropCli
$LN2@SV_DropCli:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_DropCli:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_DropCli

; 528  : 	{
; 529  : 		if( svs.clients[i].state >= cs_connected )

	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 2
	jl	SHORT $LN11@SV_DropCli

; 530  : 			break;

	jmp	SHORT $LN3@SV_DropCli
$LN11@SV_DropCli:

; 531  : 	}

	jmp	SHORT $LN2@SV_DropCli
$LN3@SV_DropCli:

; 532  : 
; 533  : 	if( i == svs.maxclients )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN12@SV_DropCli

; 534  : 		svs.last_heartbeat = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0
$LN12@SV_DropCli:

; 535  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DropClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 106  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 101  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetRealBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetRealBytesWritten PROC				; COMDAT

; 100  : _inline int MSG_GetRealBytesWritten( sizebuf_t *sb ) { return sb->iCurBit >> 3; }	// unpadded

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetRealBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
