; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\net_chan.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ns_strings
_DATA	SEGMENT
COMM	_net_chokeloopback:DWORD
COMM	_net_showdrop:DWORD
COMM	_net_qport:DWORD
COMM	_net_mempool:DWORD
COMM	_net_showpackets:DWORD
COMM	_net_from:BYTE:014H
COMM	_net_message:BYTE:014H
COMM	_net_message_buffer:BYTE:020030H
COMM	_net_speeds:DWORD
COMM	_net_drop:DWORD
_DATA	ENDS
_DATA	SEGMENT
_ns_strings DD	FLAT:$SG132382
	DD	FLAT:$SG132383
$SG132382 DB	'Client', 00H
	ORG $+1
$SG132383 DB	'Server', 00H
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetMaxBytes
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetData
PUBLIC	_Netchan_Init
PUBLIC	_Netchan_Shutdown
PUBLIC	_Netchan_Setup
PUBLIC	_Netchan_CreateFileFragmentsFromBuffer
PUBLIC	_Netchan_CopyNormalFragments
PUBLIC	_Netchan_CopyFileFragments
PUBLIC	_Netchan_CreateFragments
PUBLIC	_Netchan_CreateFileFragments
PUBLIC	_Netchan_Transmit
PUBLIC	_Netchan_TransmitBits
PUBLIC	_Netchan_OutOfBand
PUBLIC	_Netchan_OutOfBandPrint
PUBLIC	_Netchan_Process
PUBLIC	_Netchan_UpdateProgress
PUBLIC	_Netchan_IncomingReady
PUBLIC	_Netchan_CanPacket
PUBLIC	_Netchan_IsLocal
PUBLIC	_Netchan_ReportFlow
PUBLIC	_Netchan_FragSend
PUBLIC	_Netchan_Clear
PUBLIC	_Netchan_FlushIncoming
PUBLIC	_Netchan_AddBufferToList
PUBLIC	_Netchan_UnlinkFragment
PUBLIC	_Netchan_ClearFragbufs
PUBLIC	_Netchan_ClearFragments
PUBLIC	_Netchan_AllocFragbuf
PUBLIC	_Netchan_AddFragbufToTail
PUBLIC	_Netchan_UpdateFlow
PUBLIC	_Netchan_FindBufferById
PUBLIC	_Netchan_CheckForCompletion
PUBLIC	_Netchan_Validate
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fd5555555555556
PUBLIC	__real@3fe5555555555555
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40c3878000000000
PUBLIC	__real@42c80000
PUBLIC	__real@44800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_NET_IsActive:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_ReplaceExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Close:PROC
EXTRN	_SV_Active:PROC
EXTRN	_COM_IsSafeFileToDownload:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_IsPlaybackDemo:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_LZSS_IsCompressed:PROC
EXTRN	_LZSS_GetActualSize:PROC
EXTRN	_LZSS_Compress:PROC
EXTRN	_LZSS_Decompress:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_InitMasks:PROC
EXTRN	_MSG_SeekToBit:PROC
EXTRN	_MSG_ExciseBits:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_StartWriting:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadBits:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_scr_download:DWORD
EXTRN	_host:BYTE
EXTRN	_sv_lan:BYTE
EXTRN	_sv_lan_rate:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40c3878000000000
CONST	SEGMENT
__real@40c3878000000000 DQ 040c3878000000000r	; 9999
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe5555555555555
CONST	SEGMENT
__real@3fe5555555555555 DQ 03fe5555555555555r	; 0.666667
CONST	ENDS
;	COMDAT __real@3fd5555555555556
CONST	SEGMENT
__real@3fd5555555555556 DQ 03fd5555555555556r	; 0.333333
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG132387 DB	'show network packets', 00H
	ORG $+3
$SG132388 DB	'0', 00H
	ORG $+2
$SG132389 DB	'net_showpackets', 00H
$SG132390 DB	'apply bandwidth choke to loopback packets', 00H
	ORG $+2
$SG132391 DB	'0', 00H
	ORG $+2
$SG132392 DB	'net_chokeloop', 00H
	ORG $+2
$SG132393 DB	'show packets that are dropped', 00H
	ORG $+2
$SG132394 DB	'0', 00H
	ORG $+2
$SG132395 DB	'net_showdrop', 00H
	ORG $+3
$SG132396 DB	'show network packets', 00H
	ORG $+3
$SG132397 DB	'0', 00H
	ORG $+2
$SG132398 DB	'net_speeds', 00H
	ORG $+1
$SG132399 DB	'current quake netport', 00H
	ORG $+2
$SG132400 DB	'%i', 00H
	ORG $+1
$SG132401 DB	'net_qport', 00H
	ORG $+2
$SG132402 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132403 DB	'Network Pool', 00H
	ORG $+3
$SG132406 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132417 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132418 DB	'chan != NULL', 00H
	ORG $+3
$SG132419 DB	'Signon network traffic:  %s from server, %s to server', 0aH
	DB	00H
	ORG $+1
$SG132439 DB	'NetData', 00H
$SG132466 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132468 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132479 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132493 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132503 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132515 DB	'SequencePacket', 00H
	ORG $+1
$SG132539 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132540 DB	'Frag Message', 00H
	ORG $+3
$SG132585 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132628 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132631 DB	'Compressing split packet (%d -> %d bytes)', 0aH, 00H
	ORG $+1
$SG132674 DB	'reconnect', 0aH, 00H
	ORG $+1
$SG132673 DB	'^1Error:^7 Lost/dropped fragment would cause stall, retr'
	DB	'ying connection', 0aH, 00H
	ORG $+3
$SG132708 DB	'Compressing filebuffer (%s -> %s)', 0aH, 00H
	ORG $+1
$SG132710 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132744 DB	'^3Warning:^7 Unable to open %s for transfer', 0aH, 00H
	ORG $+3
$SG132747 DB	'.ztmp', 00H
	ORG $+2
$SG132752 DB	'compressed file %s (%s -> %s)', 0aH, 00H
	ORG $+1
$SG132753 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132754 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132768 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132786 DB	'NetMessage', 00H
	ORG $+1
$SG132791 DB	'^1Error:^7 buffer to small to decompress message', 0aH, 00H
	ORG $+2
$SG132787 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132814 DB	'NetMessage', 00H
	ORG $+1
$SG132819 DB	'^1Error:^7 file fragment received with bad path, ignorin'
	DB	'g', 0aH, 00H
	ORG $+1
$SG132817 DB	'^1Error:^7 file fragment received with no filename', 0aH
	DB	'Flushing input queue', 0aH, 00H
	ORG $+3
$SG132821 DB	'^1Error:^7 can''t download %s, already exists', 0aH, 00H
	ORG $+2
$SG132959 DB	'^1Error:^7 %s:outgoing message overflow', 0aH, 00H
	ORG $+3
$SG132823 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132826 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132828 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132829 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132833 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132834 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\net_chan.c', 00H
	ORG $+3
$SG132975 DB	'.ztmp', 00H
	ORG $+2
$SG132976 DB	'rb', 00H
	ORG $+1
$SG132977 DB	'rb', 00H
	ORG $+1
$SG132978 DB	'NetSend', 00H
$SG132982 DB	'net_qport', 00H
	ORG $+2
$SG132989 DB	'^3Warning:^7 Netchan_Transmit: unreliable message overfl'
	DB	'ow', 0aH, 00H
$SG133000 DB	' %s --> sz=%i seq=%i ack=%i rel=%i tm=%f', 0aH, 00H
	ORG $+2
$SG133056 DB	' %s <-- sz=%i seq=%i ack=%i rel=%i tm=%f', 0aH, 00H
	ORG $+2
$SG133061 DB	'%s:duplicate packet %i at %i', 0aH, 00H
	ORG $+2
$SG133062 DB	'%s:out of order packet %i at %i', 0aH, 00H
	ORG $+3
$SG133064 DB	'%s:dropped %i packets at %i', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_offset$ = -20						; size = 4
_length$ = -16						; size = 4
_count$ = -12						; size = 4
_buffer$ = -8						; size = 4
_i$ = -4						; size = 4
_chan$ = 8						; size = 4
_sb$ = 12						; size = 4
_frag_message$ = 16					; size = 4
_fragid$ = 20						; size = 4
_frag_offset$ = 24					; size = 4
_frag_length$ = 28					; size = 4
_Netchan_Validate PROC

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1143 : 	int	i, buffer, offset;
; 1144 : 	int	count, length;
; 1145 : 
; 1146 : 	for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_Va
$LN2@Netchan_Va:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_Va:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN3@Netchan_Va

; 1147 : 	{
; 1148 : 		if( !frag_message[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frag_message$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN5@Netchan_Va

; 1149 : 			continue;

	jmp	SHORT $LN2@Netchan_Va
$LN5@Netchan_Va:

; 1150 : 
; 1151 : 		buffer = FRAG_GETID( fragid[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fragid$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	shr	edx, 16					; 00000010H
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _buffer$[ebp], edx

; 1152 : 		count = FRAG_GETCOUNT( fragid[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fragid$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _count$[ebp], edx

; 1153 : 		offset = BitByte( frag_offset[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _frag_offset$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_BitByte
	add	esp, 4
	mov	DWORD PTR _offset$[ebp], eax

; 1154 : 		length = BitByte( frag_length[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _frag_length$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_BitByte
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 1155 : 
; 1156 : 		if( buffer < 0 || buffer > NET_MAX_BUFFER_ID )

	cmp	DWORD PTR _buffer$[ebp], 0
	jl	SHORT $LN7@Netchan_Va
	cmp	DWORD PTR _buffer$[ebp], 32767		; 00007fffH
	jle	SHORT $LN6@Netchan_Va
$LN7@Netchan_Va:

; 1157 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Va
$LN6@Netchan_Va:

; 1158 : 
; 1159 : 		if( count < 0 || count > NET_MAX_BUFFERS_COUNT )

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN9@Netchan_Va
	cmp	DWORD PTR _count$[ebp], 32767		; 00007fffH
	jle	SHORT $LN8@Netchan_Va
$LN9@Netchan_Va:

; 1160 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Va
$LN8@Netchan_Va:

; 1161 : 
; 1162 : 		if( length < 0 || length > ( FRAGMENT_MAX_SIZE << 3 ))

	cmp	DWORD PTR _length$[ebp], 0
	jl	SHORT $LN11@Netchan_Va
	cmp	DWORD PTR _length$[ebp], 512000		; 0007d000H
	jle	SHORT $LN10@Netchan_Va
$LN11@Netchan_Va:

; 1163 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Va
$LN10@Netchan_Va:

; 1164 : 
; 1165 : 		if( offset < 0 || offset > ( FRAGMENT_MAX_SIZE << 3 ))

	cmp	DWORD PTR _offset$[ebp], 0
	jl	SHORT $LN13@Netchan_Va
	cmp	DWORD PTR _offset$[ebp], 512000		; 0007d000H
	jle	SHORT $LN12@Netchan_Va
$LN13@Netchan_Va:

; 1166 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Va
$LN12@Netchan_Va:

; 1167 : 	}

	jmp	$LN2@Netchan_Va
$LN3@Netchan_Va:

; 1168 : 
; 1169 : 	return true;

	mov	eax, 1
$LN1@Netchan_Va:

; 1170 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_Validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_id$ = -16						; size = 4
_size$ = -12						; size = 4
_c$ = -8						; size = 4
_p$ = -4						; size = 4
_chan$ = 8						; size = 4
_stream$ = 12						; size = 4
_intotalbuffers$ = 16					; size = 4
_Netchan_CheckForCompletion PROC

; 687  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 688  : 	int	c, id;
; 689  : 	int	size;
; 690  : 	fragbuf_t	*p;
; 691  : 
; 692  : 	size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 693  : 	c = 0;

	mov	DWORD PTR _c$[ebp], 0

; 694  : 
; 695  : 	p = chan->incomingbufs[stream];

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+262420]
	mov	DWORD PTR _p$[ebp], edx

; 696  : 	if( !p ) return;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@Netchan_Ch
	jmp	$LN1@Netchan_Ch
$LN2@Netchan_Ch:

; 697  : 
; 698  : 	while( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Netchan_Ch

; 699  : 	{
; 700  : 		size += MSG_GetNumBytesWritten( &p->frag_message );

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 701  : 		c++;

	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx

; 702  : 
; 703  : 		id = FRAG_GETID( p->bufferid );

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sar	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _id$[ebp], eax

; 704  : 		if( id != c )

	mov	ecx, DWORD PTR _id$[ebp]
	cmp	ecx, DWORD PTR _c$[ebp]
	je	SHORT $LN5@Netchan_Ch

; 705  : 		{
; 706  : 			if( chan->sock == NS_CLIENT )

	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN5@Netchan_Ch

; 707  : 			{
; 708  : 				Con_DPrintf( S_ERROR "Lost/dropped fragment would cause stall, retrying connection\n" );

	push	OFFSET $SG132673
	call	_Con_DPrintf
	add	esp, 4

; 709  : 				Cbuf_AddText( "reconnect\n" );

	push	OFFSET $SG132674
	call	_Cbuf_AddText
	add	esp, 4
$LN5@Netchan_Ch:

; 710  : 			}
; 711  : 		}
; 712  : 		p = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 713  : 	}

	jmp	SHORT $LN2@Netchan_Ch
$LN3@Netchan_Ch:

; 714  : 
; 715  : 	// received final message
; 716  : 	if( c == intotalbuffers )

	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, DWORD PTR _intotalbuffers$[ebp]
	jne	SHORT $LN1@Netchan_Ch

; 717  : 		chan->incomingready[stream] = true;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax*4+262428], 1
$LN1@Netchan_Ch:

; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CheckForCompletion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_pnewbuf$ = -8						; size = 4
_list$ = -4						; size = 4
_pplist$ = 8						; size = 4
_id$ = 12						; size = 4
_allocate$ = 16						; size = 4
_Netchan_FindBufferById PROC

; 657  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 658  : 	fragbuf_t	*list = *pplist;

	mov	eax, DWORD PTR _pplist$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _list$[ebp], ecx
$LN2@Netchan_Fi:

; 659  : 	fragbuf_t	*pnewbuf;
; 660  : 
; 661  : 	while( list )

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN3@Netchan_Fi

; 662  : 	{
; 663  : 		if( list->bufferid == id )

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _id$[ebp]
	jne	SHORT $LN4@Netchan_Fi

; 664  : 			return list;

	mov	eax, DWORD PTR _list$[ebp]
	jmp	SHORT $LN1@Netchan_Fi
$LN4@Netchan_Fi:

; 665  : 
; 666  : 		list = list->next;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _list$[ebp], edx

; 667  : 	}

	jmp	SHORT $LN2@Netchan_Fi
$LN3@Netchan_Fi:

; 668  : 
; 669  : 	if( !allocate )

	cmp	DWORD PTR _allocate$[ebp], 0
	jne	SHORT $LN5@Netchan_Fi

; 670  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Fi
$LN5@Netchan_Fi:

; 671  : 
; 672  : 	// create new entry
; 673  : 	pnewbuf = Netchan_AllocFragbuf();

	call	_Netchan_AllocFragbuf
	mov	DWORD PTR _pnewbuf$[ebp], eax

; 674  : 	pnewbuf->bufferid = id;

	mov	eax, DWORD PTR _pnewbuf$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 675  : 	Netchan_AddBufferToList( pplist, pnewbuf );

	mov	edx, DWORD PTR _pnewbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _pplist$[ebp]
	push	eax
	call	_Netchan_AddBufferToList
	add	esp, 8

; 676  : 
; 677  : 	return pnewbuf;

	mov	eax, DWORD PTR _pnewbuf$[ebp]
$LN1@Netchan_Fi:

; 678  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_FindBufferById ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
tv143 = -48						; size = 4
_wait$ = -44						; size = 4
_pos$ = -40						; size = 4
_bytes$ = -36						; size = 4
_bufferid$ = -32					; size = 4
_chunksize$ = -28					; size = 4
_uSourceSize$1 = -24					; size = 4
_p$ = -20						; size = 4
_buf$ = -16						; size = 4
_pbOut$2 = -12						; size = 4
_remaining$ = -8					; size = 4
_uCompressedSize$3 = -4					; size = 4
_chan$ = 8						; size = 4
_msg$ = 12						; size = 4
_Netchan_CreateFragments_ PROC

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 567  : 	fragbuf_t		*buf;
; 568  : 	int		chunksize;
; 569  : 	int		remaining;
; 570  : 	int		bytes, pos;
; 571  : 	int		bufferid = 1;

	mov	DWORD PTR _bufferid$[ebp], 1

; 572  : 	fragbufwaiting_t	*wait, *p;
; 573  : 	
; 574  : 	if( MSG_GetNumBytesWritten( msg ) == 0 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@Netchan_Cr

; 575  : 		return;

	jmp	$LN1@Netchan_Cr
$LN6@Netchan_Cr:

; 576  : 
; 577  : 	if( chan->pfnBlockSize != NULL )

	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+96], 0
	je	SHORT $LN7@Netchan_Cr

; 578  : 		chunksize = chan->pfnBlockSize( chan->client );

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	call	edx
	add	esp, 4
	mov	DWORD PTR _chunksize$[ebp], eax
	jmp	SHORT $LN8@Netchan_Cr
$LN7@Netchan_Cr:

; 579  : 	else chunksize = FRAGMENT_MAX_SIZE; // fallback

	mov	DWORD PTR _chunksize$[ebp], 64000	; 0000fa00H
$LN8@Netchan_Cr:

; 580  : 
; 581  : 	wait = (fragbufwaiting_t *)Mem_Calloc( net_mempool, sizeof( fragbufwaiting_t ));

	push	581					; 00000245H
	push	OFFSET $SG132628
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR _net_mempool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _wait$[ebp], eax

; 582  : 
; 583  : 	if( !LZSS_IsCompressed( MSG_GetData( msg )))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	call	_LZSS_IsCompressed
	add	esp, 4
	test	eax, eax
	jne	$LN9@Netchan_Cr

; 584  : 	{
; 585  : 		uint	uCompressedSize = 0;

	mov	DWORD PTR _uCompressedSize$3[ebp], 0

; 586  : 		uint	uSourceSize = MSG_GetNumBytesWritten( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _uSourceSize$1[ebp], eax

; 587  : 		byte	*pbOut = LZSS_Compress( msg->pData, uSourceSize, &uCompressedSize );

	lea	eax, DWORD PTR _uCompressedSize$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _uSourceSize$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_LZSS_Compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pbOut$2[ebp], eax

; 588  : 
; 589  : 		if( pbOut && uCompressedSize > 0 && uCompressedSize < uSourceSize )

	cmp	DWORD PTR _pbOut$2[ebp], 0
	je	SHORT $LN10@Netchan_Cr
	cmp	DWORD PTR _uCompressedSize$3[ebp], 0
	jbe	SHORT $LN10@Netchan_Cr
	mov	ecx, DWORD PTR _uCompressedSize$3[ebp]
	cmp	ecx, DWORD PTR _uSourceSize$1[ebp]
	jae	SHORT $LN10@Netchan_Cr

; 590  : 		{
; 591  : 			Con_Reportf( "Compressing split packet (%d -> %d bytes)\n", uSourceSize, uCompressedSize );

	mov	edx, DWORD PTR _uCompressedSize$3[ebp]
	push	edx
	mov	eax, DWORD PTR _uSourceSize$1[ebp]
	push	eax
	push	OFFSET $SG132631
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 592  : 			memcpy( msg->pData, pbOut, uCompressedSize );

	mov	ecx, DWORD PTR _uCompressedSize$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbOut$2[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 593  : 			MSG_SeekToBit( msg, uCompressedSize << 3, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _uCompressedSize$3[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH
$LN10@Netchan_Cr:

; 594  : 		}
; 595  : 		if( pbOut ) free( pbOut );

	cmp	DWORD PTR _pbOut$2[ebp], 0
	je	SHORT $LN9@Netchan_Cr
	mov	ecx, DWORD PTR _pbOut$2[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN9@Netchan_Cr:

; 596  : 	}
; 597  : 
; 598  : 	remaining = MSG_GetNumBytesWritten( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _remaining$[ebp], eax

; 599  : 	pos = 0;	// current position in bytes

	mov	DWORD PTR _pos$[ebp], 0
$LN2@Netchan_Cr:

; 600  : 
; 601  : 	while( remaining > 0 )

	cmp	DWORD PTR _remaining$[ebp], 0
	jle	$LN3@Netchan_Cr

; 602  : 	{
; 603  : 		bytes = Q_min( remaining, chunksize );

	mov	eax, DWORD PTR _remaining$[ebp]
	cmp	eax, DWORD PTR _chunksize$[ebp]
	jge	SHORT $LN15@Netchan_Cr
	mov	ecx, DWORD PTR _remaining$[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN16@Netchan_Cr
$LN15@Netchan_Cr:
	mov	edx, DWORD PTR _chunksize$[ebp]
	mov	DWORD PTR tv143[ebp], edx
$LN16@Netchan_Cr:
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 604  : 		remaining -= bytes;

	mov	ecx, DWORD PTR _remaining$[ebp]
	sub	ecx, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _remaining$[ebp], ecx

; 605  : 	
; 606  : 		buf = Netchan_AllocFragbuf();

	call	_Netchan_AllocFragbuf
	mov	DWORD PTR _buf$[ebp], eax

; 607  : 		buf->bufferid = bufferid++;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _bufferid$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _bufferid$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bufferid$[ebp], ecx

; 608  : 
; 609  : 		// Copy in data
; 610  : 		MSG_Clear( &buf->frag_message );

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_Clear
	add	esp, 4

; 611  : 		MSG_WriteBits( &buf->frag_message, &msg->pData[pos], bytes << 3 );

	mov	eax, DWORD PTR _bytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, 8
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 612  : 
; 613  : 		Netchan_AddFragbufToTail( wait, buf );

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wait$[ebp]
	push	edx
	call	_Netchan_AddFragbufToTail
	add	esp, 8

; 614  : 		pos += bytes;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 615  : 	}

	jmp	$LN2@Netchan_Cr
$LN3@Netchan_Cr:

; 616  : 
; 617  : 	// now add waiting list item to end of buffer queue
; 618  : 	if( !chan->waitlist[FRAG_NORMAL_STREAM] )

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [eax+edx+262364], 0
	jne	SHORT $LN12@Netchan_Cr

; 619  : 	{
; 620  : 		chan->waitlist[FRAG_NORMAL_STREAM] = wait;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [eax+edx+262364], ecx

; 621  : 	}

	jmp	SHORT $LN1@Netchan_Cr
$LN12@Netchan_Cr:

; 622  : 	else
; 623  : 	{
; 624  : 		p = chan->waitlist[FRAG_NORMAL_STREAM];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax+262364]
	mov	DWORD PTR _p$[ebp], edx
$LN4@Netchan_Cr:

; 625  : 
; 626  : 		while( p->next )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Netchan_Cr

; 627  : 			p = p->next;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN4@Netchan_Cr
$LN5@Netchan_Cr:

; 628  : 		p->next = wait;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Netchan_Cr:

; 629  : 	}
; 630  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CreateFragments_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_pprev$1 = -36						; size = 4
tv137 = -32						; size = 4
_pstat$2 = -28						; size = 4
_start$ = -24						; size = 4
_bytes$ = -20						; size = 4
_faccumulatedtime$ = -16				; size = 4
_flow$ = -12						; size = 4
_i$ = -8						; size = 4
_pflow$3 = -4						; size = 4
_chan$ = 8						; size = 4
_Netchan_UpdateFlow PROC

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 446  : 	float	faccumulatedtime = 0.0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _faccumulatedtime$[ebp], xmm0

; 447  : 	int	i, bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 448  : 	int	flow, start;
; 449  : 
; 450  : 	if( !chan ) return;

	cmp	DWORD PTR _chan$[ebp], 0
	jne	SHORT $LN8@Netchan_Up
	jmp	$LN3@Netchan_Up
$LN8@Netchan_Up:

; 451  : 
; 452  : 	for( flow = 0; flow < 2; flow++ )

	mov	DWORD PTR _flow$[ebp], 0
	jmp	SHORT $LN4@Netchan_Up
$LN2@Netchan_Up:
	mov	eax, DWORD PTR _flow$[ebp]
	add	eax, 1
	mov	DWORD PTR _flow$[ebp], eax
$LN4@Netchan_Up:
	cmp	DWORD PTR _flow$[ebp], 2
	jge	$LN3@Netchan_Up

; 453  : 	{
; 454  : 		flow_t	*pflow = &chan->flow[flow];

	imul	ecx, DWORD PTR _flow$[ebp], 544
	mov	edx, DWORD PTR _chan$[ebp]
	lea	eax, DWORD PTR [edx+ecx+262704]
	mov	DWORD PTR _pflow$3[ebp], eax

; 455  : 
; 456  : 		if(( host.realtime - pflow->nextcompute ) < FLOW_INTERVAL )

	mov	ecx, DWORD PTR _pflow$3[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx+520]
	movsd	xmm1, QWORD PTR __real@3fb999999999999a
	comisd	xmm1, xmm0
	jbe	SHORT $LN9@Netchan_Up

; 457  : 			continue;

	jmp	SHORT $LN2@Netchan_Up
$LN9@Netchan_Up:

; 458  : 
; 459  : 		pflow->nextcompute = host.realtime + FLOW_INTERVAL;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@3fb999999999999a
	mov	edx, DWORD PTR _pflow$3[ebp]
	movsd	QWORD PTR [edx+520], xmm0

; 460  : 		start = pflow->current - 1;

	mov	eax, DWORD PTR _pflow$3[ebp]
	mov	ecx, DWORD PTR [eax+512]
	sub	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx

; 461  : 
; 462  : 		// compute data flow rate
; 463  : 		for( i = 0; i < MASK_LATENT; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Netchan_Up
$LN5@Netchan_Up:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Netchan_Up:
	cmp	DWORD PTR _i$[ebp], 31			; 0000001fH
	jge	SHORT $LN6@Netchan_Up

; 464  : 		{
; 465  : 			flowstats_t *pprev = &pflow->stats[(start - i) & MASK_LATENT];

	mov	eax, DWORD PTR _start$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 4
	add	eax, DWORD PTR _pflow$3[ebp]
	mov	DWORD PTR _pprev$1[ebp], eax

; 466  : 			flowstats_t *pstat = &pflow->stats[(start - i - 1) & MASK_LATENT];

	mov	ecx, DWORD PTR _start$[ebp]
	sub	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	and	ecx, 31					; 0000001fH
	shl	ecx, 4
	add	ecx, DWORD PTR _pflow$3[ebp]
	mov	DWORD PTR _pstat$2[ebp], ecx

; 467  : 
; 468  : 			faccumulatedtime += ( pprev->time - pstat->time );

	mov	edx, DWORD PTR _pprev$1[ebp]
	mov	eax, DWORD PTR _pstat$2[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	subsd	xmm0, QWORD PTR [eax+8]
	cvtss2sd xmm1, DWORD PTR _faccumulatedtime$[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _faccumulatedtime$[ebp], xmm0

; 469  : 			bytes += pstat->size;

	mov	ecx, DWORD PTR _pstat$2[ebp]
	mov	edx, DWORD PTR _bytes$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _bytes$[ebp], edx

; 470  : 		}

	jmp	SHORT $LN5@Netchan_Up
$LN6@Netchan_Up:

; 471  : 
; 472  : 		pflow->kbytespersec = (faccumulatedtime == 0.0f) ? 0.0f : bytes / faccumulatedtime / 1024.0f;

	movss	xmm0, DWORD PTR _faccumulatedtime$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Netchan_Up
	xorps	xmm0, xmm0
	movss	DWORD PTR tv137[ebp], xmm0
	jmp	SHORT $LN12@Netchan_Up
$LN11@Netchan_Up:
	cvtsi2ss xmm0, DWORD PTR _bytes$[ebp]
	divss	xmm0, DWORD PTR _faccumulatedtime$[ebp]
	divss	xmm0, DWORD PTR __real@44800000
	movss	DWORD PTR tv137[ebp], xmm0
$LN12@Netchan_Up:
	mov	eax, DWORD PTR _pflow$3[ebp]
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR [eax+528], xmm0

; 473  : 		pflow->avgkbytespersec = pflow->avgkbytespersec * FLOW_AVG + pflow->kbytespersec * (1.0 - FLOW_AVG);

	mov	ecx, DWORD PTR _pflow$3[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+532]
	mulsd	xmm0, QWORD PTR __real@3fe5555555555555
	mov	edx, DWORD PTR _pflow$3[ebp]
	cvtss2sd xmm1, DWORD PTR [edx+528]
	mulsd	xmm1, QWORD PTR __real@3fd5555555555556
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pflow$3[ebp]
	movss	DWORD PTR [eax+532], xmm0

; 474  : 	}

	jmp	$LN2@Netchan_Up
$LN3@Netchan_Up:

; 475  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_UpdateFlow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_p$ = -4						; size = 4
_wait$ = 8						; size = 4
_buf$ = 12						; size = 4
_Netchan_AddFragbufToTail PROC

; 422  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 423  : 	fragbuf_t	*p;
; 424  : 
; 425  : 	buf->next = NULL;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax], 0

; 426  : 	wait->fragbufcount++;

	mov	ecx, DWORD PTR _wait$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [eax+4], edx

; 427  : 	p = wait->fragbufs;

	mov	ecx, DWORD PTR _wait$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _p$[ebp], edx

; 428  : 
; 429  : 	if( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@Netchan_Ad
$LN2@Netchan_Ad:

; 430  : 	{
; 431  : 		while( p->next )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Netchan_Ad

; 432  : 			p = p->next;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN2@Netchan_Ad
$LN3@Netchan_Ad:

; 433  : 		p->next = buf;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax], ecx

; 434  : 	}

	jmp	SHORT $LN1@Netchan_Ad
$LN4@Netchan_Ad:

; 435  : 	else wait->fragbufs = buf;

	mov	edx, DWORD PTR _wait$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@Netchan_Ad:

; 436  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_AddFragbufToTail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_buf$ = -4						; size = 4
_Netchan_AllocFragbuf PROC

; 406  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 407  : 	fragbuf_t	*buf;
; 408  : 
; 409  : 	buf = (fragbuf_t *)Mem_Calloc( net_mempool, sizeof( fragbuf_t ));

	push	409					; 00000199H
	push	OFFSET $SG132539
	push	1
	push	65844					; 00010134H
	mov	eax, DWORD PTR _net_mempool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buf$[ebp], eax

; 410  : 	MSG_Init( &buf->frag_message, "Frag Message", buf->frag_message_buf, sizeof( buf->frag_message_buf ));

	push	-1
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	OFFSET $SG132540
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 411  : 
; 412  : 	return buf;

	mov	eax, DWORD PTR _buf$[ebp]

; 413  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_AllocFragbuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_next$ = -12						; size = 4
_wait$ = -8						; size = 4
_i$ = -4						; size = 4
_chan$ = 8						; size = 4
_Netchan_ClearFragments PROC

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 299  : 	fragbufwaiting_t	*wait, *next;
; 300  : 	int		i;
; 301  : 
; 302  : 	for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_Cl
$LN2@Netchan_Cl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_Cl:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN1@Netchan_Cl

; 303  : 	{
; 304  : 		wait = chan->waitlist[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+262364]
	mov	DWORD PTR _wait$[ebp], eax
$LN5@Netchan_Cl:

; 305  : 
; 306  : 		while( wait )

	cmp	DWORD PTR _wait$[ebp], 0
	je	SHORT $LN6@Netchan_Cl

; 307  : 		{
; 308  : 			next = wait->next;

	mov	ecx, DWORD PTR _wait$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _next$[ebp], edx

; 309  : 			Netchan_ClearFragbufs( &wait->fragbufs );

	mov	eax, DWORD PTR _wait$[ebp]
	add	eax, 8
	push	eax
	call	_Netchan_ClearFragbufs
	add	esp, 4

; 310  : 			Mem_Free( wait );

	push	310					; 00000136H
	push	OFFSET $SG132493
	mov	ecx, DWORD PTR _wait$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 311  : 			wait = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _wait$[ebp], edx

; 312  : 		}

	jmp	SHORT $LN5@Netchan_Cl
$LN6@Netchan_Cl:

; 313  : 		chan->waitlist[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax*4+262364], 0

; 314  : 
; 315  : 		Netchan_ClearFragbufs( &chan->fragbufs[i] );

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+262388]
	push	ecx
	call	_Netchan_ClearFragbufs
	add	esp, 4

; 316  : 		Netchan_FlushIncoming( chan, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_FlushIncoming
	add	esp, 8

; 317  : 	}

	jmp	$LN2@Netchan_Cl
$LN1@Netchan_Cl:

; 318  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_ClearFragments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_n$ = -8						; size = 4
_buf$ = -4						; size = 4
_ppbuf$ = 8						; size = 4
_Netchan_ClearFragbufs PROC

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 274  : 	fragbuf_t	*buf, *n;
; 275  : 
; 276  : 	if( !ppbuf ) return;

	cmp	DWORD PTR _ppbuf$[ebp], 0
	jne	SHORT $LN4@Netchan_Cl
	jmp	SHORT $LN1@Netchan_Cl
$LN4@Netchan_Cl:

; 277  : 
; 278  : 	// Throw away any that are sitting around
; 279  : 	buf = *ppbuf;

	mov	eax, DWORD PTR _ppbuf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _buf$[ebp], ecx
$LN2@Netchan_Cl:

; 280  : 
; 281  : 	while( buf )

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@Netchan_Cl

; 282  : 	{
; 283  : 		n = buf->next;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _n$[ebp], eax

; 284  : 		Mem_Free( buf );

	push	284					; 0000011cH
	push	OFFSET $SG132479
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 285  : 		buf = n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _buf$[ebp], edx

; 286  : 	}

	jmp	SHORT $LN2@Netchan_Cl
$LN3@Netchan_Cl:

; 287  : 
; 288  : 	*ppbuf = NULL;

	mov	eax, DWORD PTR _ppbuf$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Netchan_Cl:

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_ClearFragbufs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_search$ = -4						; size = 4
_buf$ = 8						; size = 4
_list$ = 12						; size = 4
_Netchan_UnlinkFragment PROC

; 235  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 236  : 	fragbuf_t	*search;
; 237  : 
; 238  : 	if( !list ) return;

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN4@Netchan_Un
	jmp	SHORT $LN1@Netchan_Un
$LN4@Netchan_Un:

; 239  : 
; 240  : 	// at head of list
; 241  : 	if( buf == *list )

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@Netchan_Un

; 242  : 	{
; 243  : 		// remove first element
; 244  : 		*list = buf->next;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 245  : 		
; 246  : 		// destroy remnant
; 247  : 		Mem_Free( buf );

	push	247					; 000000f7H
	push	OFFSET $SG132466
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 248  : 		return;

	jmp	SHORT $LN1@Netchan_Un
$LN5@Netchan_Un:

; 249  : 	}
; 250  : 
; 251  : 	search = *list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _search$[ebp], ecx
$LN2@Netchan_Un:

; 252  : 	while( search->next )

	mov	edx, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN1@Netchan_Un

; 253  : 	{
; 254  : 		if( search->next == buf )

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _buf$[ebp]
	jne	SHORT $LN6@Netchan_Un

; 255  : 		{
; 256  : 			search->next = buf->next;

	mov	edx, DWORD PTR _search$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 257  : 
; 258  : 			// destroy remnant
; 259  : 			Mem_Free( buf );

	push	259					; 00000103H
	push	OFFSET $SG132468
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 260  : 			return;

	jmp	SHORT $LN1@Netchan_Un
$LN6@Netchan_Un:

; 261  : 		}
; 262  : 		search = search->next;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _search$[ebp], ecx

; 263  : 	}

	jmp	SHORT $LN2@Netchan_Un
$LN1@Netchan_Un:

; 264  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_UnlinkFragment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_id2$ = -16						; size = 4
_id1$ = -12						; size = 4
_n$ = -8						; size = 4
_pprev$ = -4						; size = 4
_pplist$ = 8						; size = 4
_pbuf$ = 12						; size = 4
_Netchan_AddBufferToList PROC

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 522  : 	// Find best slot
; 523  : 	fragbuf_t	*pprev, *n;
; 524  : 	int	id1, id2;
; 525  : 
; 526  : 	pbuf->next = NULL;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax], 0

; 527  : 
; 528  : 	if( !pplist )

	cmp	DWORD PTR _pplist$[ebp], 0
	jne	SHORT $LN4@Netchan_Ad

; 529  : 		return;

	jmp	$LN1@Netchan_Ad
$LN4@Netchan_Ad:

; 530  : 
; 531  : 	if( !*pplist )

	mov	ecx, DWORD PTR _pplist$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@Netchan_Ad

; 532  : 	{
; 533  : 		pbuf->next = *pplist;

	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR _pplist$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 534  : 		*pplist = pbuf;

	mov	edx, DWORD PTR _pplist$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [edx], eax

; 535  : 		return;

	jmp	SHORT $LN1@Netchan_Ad
$LN5@Netchan_Ad:

; 536  : 	}
; 537  : 
; 538  : 	pprev = *pplist;

	mov	ecx, DWORD PTR _pplist$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pprev$[ebp], edx
$LN2@Netchan_Ad:

; 539  : 	while( pprev->next )

	mov	eax, DWORD PTR _pprev$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Netchan_Ad

; 540  : 	{
; 541  : 		n = pprev->next; // next item in list

	mov	ecx, DWORD PTR _pprev$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _n$[ebp], edx

; 542  : 		id1 = FRAG_GETID( n->bufferid );

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sar	ecx, 16					; 00000010H
	and	ecx, 65535				; 0000ffffH
	mov	DWORD PTR _id1$[ebp], ecx

; 543  : 		id2 = FRAG_GETID( pbuf->bufferid );

	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sar	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _id2$[ebp], eax

; 544  : 
; 545  : 		if( id1 > id2 )

	mov	ecx, DWORD PTR _id1$[ebp]
	cmp	ecx, DWORD PTR _id2$[ebp]
	jle	SHORT $LN6@Netchan_Ad

; 546  : 		{
; 547  : 			// insert here
; 548  : 			pbuf->next = n->next;

	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 549  : 			pprev->next = pbuf;

	mov	edx, DWORD PTR _pprev$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [edx], eax

; 550  : 			return;

	jmp	SHORT $LN1@Netchan_Ad
$LN6@Netchan_Ad:

; 551  : 		}
; 552  : 		pprev = pprev->next;

	mov	ecx, DWORD PTR _pprev$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pprev$[ebp], edx

; 553  : 	}

	jmp	SHORT $LN2@Netchan_Ad
$LN3@Netchan_Ad:

; 554  : 
; 555  : 	// insert at end
; 556  : 	pprev->next = pbuf;

	mov	eax, DWORD PTR _pprev$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Netchan_Ad:

; 557  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_AddBufferToList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_n$ = -8						; size = 4
_p$ = -4						; size = 4
_chan$ = 8						; size = 4
_stream$ = 12						; size = 4
_Netchan_FlushIncoming PROC

; 931  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 932  : 	fragbuf_t	*p, *n;
; 933  : 
; 934  : 	MSG_Clear( &net_message );

	push	OFFSET _net_message
	call	_MSG_Clear
	add	esp, 4

; 935  : 
; 936  : 	p = chan->incomingbufs[ stream ];

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+262420]
	mov	DWORD PTR _p$[ebp], edx
$LN2@Netchan_Fl:

; 937  : 
; 938  : 	while( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Netchan_Fl

; 939  : 	{
; 940  : 		n = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n$[ebp], ecx

; 941  : 		Mem_Free( p );

	push	941					; 000003adH
	push	OFFSET $SG132768
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 942  : 		p = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 943  : 	}

	jmp	SHORT $LN2@Netchan_Fl
$LN3@Netchan_Fl:

; 944  : 	chan->incomingbufs[stream] = NULL;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx*4+262420], 0

; 945  : 	chan->incomingready[stream] = false;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax*4+262428], 0

; 946  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_FlushIncoming ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_chan$ = 8						; size = 4
_Netchan_Clear PROC

; 327  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 328  : 	int	i;
; 329  : 
; 330  : 	Netchan_ClearFragments( chan );

	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_ClearFragments
	add	esp, 4

; 331  : 
; 332  : 	chan->cleartime = 0.0;

	mov	ecx, DWORD PTR _chan$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [ecx+56], xmm0

; 333  : 	chan->reliable_length = 0;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+131240], 0

; 334  : 
; 335  : 	for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_Cl
$LN2@Netchan_Cl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_Cl:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@Netchan_Cl

; 336  : 	{
; 337  : 		chan->reliable_fragid[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx*4+262380], 0

; 338  : 		chan->reliable_fragment[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax*4+262372], 0

; 339  : 		chan->fragbufcount[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+edx*4+262396], 0

; 340  : 		chan->frag_startpos[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx*4+262404], 0

; 341  : 		chan->frag_length[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax*4+262412], 0

; 342  : 		chan->incomingready[i] = false;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+edx*4+262428], 0

; 343  : 	}

	jmp	SHORT $LN2@Netchan_Cl
$LN3@Netchan_Cl:

; 344  : 
; 345  : 	if( chan->tempbuffer )

	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+262696], 0
	je	SHORT $LN5@Netchan_Cl

; 346  : 	{
; 347  : 		Mem_Free( chan->tempbuffer );

	push	347					; 0000015bH
	push	OFFSET $SG132503
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+262696]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 348  : 		chan->tempbuffer = NULL;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+262696], 0
$LN5@Netchan_Cl:

; 349  : 	}
; 350  : 	chan->tempbuffersize = 0;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+262700], 0

; 351  : 
; 352  : 	memset( chan->flow, 0, sizeof( chan->flow ));

	push	1088					; 00000440H
	push	0
	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 262704				; 00040230H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 353  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_wait$ = -8						; size = 4
_i$ = -4						; size = 4
_chan$ = 8						; size = 4
_Netchan_FragSend PROC

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 486  : 	fragbufwaiting_t	*wait;
; 487  : 	int		i;
; 488  : 
; 489  : 	if( !chan ) return;

	cmp	DWORD PTR _chan$[ebp], 0
	jne	SHORT $LN5@Netchan_Fr
	jmp	$LN1@Netchan_Fr
$LN5@Netchan_Fr:

; 490  : 
; 491  : 	for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_Fr
$LN2@Netchan_Fr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_Fr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN1@Netchan_Fr

; 492  : 	{
; 493  : 		// already something queued up, just leave in waitlist
; 494  : 		if( chan->fragbufs[i] ) continue;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx*4+262388], 0
	je	SHORT $LN6@Netchan_Fr
	jmp	SHORT $LN2@Netchan_Fr
$LN6@Netchan_Fr:

; 495  : 
; 496  : 		wait = chan->waitlist[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+262364]
	mov	DWORD PTR _wait$[ebp], edx

; 497  : 
; 498  : 		// nothing to queue?
; 499  : 		if( !wait ) continue;

	cmp	DWORD PTR _wait$[ebp], 0
	jne	SHORT $LN7@Netchan_Fr
	jmp	SHORT $LN2@Netchan_Fr
$LN7@Netchan_Fr:

; 500  : 
; 501  : 		chan->waitlist[i] = wait->next;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _wait$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+262364], edx

; 502  : 
; 503  : 		wait->next = NULL;

	mov	eax, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [eax], 0

; 504  : 
; 505  : 		// copy in to fragbuf
; 506  : 		chan->fragbufs[i] = wait->fragbufs;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _wait$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx*4+262388], eax

; 507  : 		chan->fragbufcount[i] = wait->fragbufcount;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _wait$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx*4+262396], eax

; 508  : 
; 509  : 		// throw away wait list
; 510  : 		Mem_Free( wait );

	push	510					; 000001feH
	push	OFFSET $SG132585
	mov	ecx, DWORD PTR _wait$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 511  : 	}

	jmp	$LN2@Netchan_Fr
$LN1@Netchan_Fr:

; 512  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_FragSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
tv71 = -136						; size = 4
_incoming$ = -132					; size = 64
_outgoing$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_Netchan_ReportFlow PROC

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	char	incoming[64];
; 136  : 	char	outgoing[64];
; 137  : 
; 138  : 	if( CL_IsPlaybackDemo( ))

	call	_CL_IsPlaybackDemo
	test	eax, eax
	je	SHORT $LN2@Netchan_Re

; 139  : 		return;

	jmp	$LN1@Netchan_Re
$LN2@Netchan_Re:

; 140  : 
; 141  : 	Assert( chan != NULL );

	cmp	DWORD PTR _chan$[ebp], 0
	je	SHORT $LN4@Netchan_Re
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@Netchan_Re
$LN4@Netchan_Re:
	mov	DWORD PTR tv71[ebp], 0
$LN5@Netchan_Re:
	push	0
	push	141					; 0000008dH
	push	OFFSET $SG132417
	push	OFFSET $SG132418
	mov	eax, DWORD PTR tv71[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 142  : 
; 143  : 	Q_strcpy( incoming, Q_pretifymem((float)chan->flow[FLOW_INCOMING].totalbytes, 3 ));

	push	99999					; 0001869fH
	push	3
	mov	ecx, 544				; 00000220H
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+263240]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _incoming$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 144  : 	Q_strcpy( outgoing, Q_pretifymem((float)chan->flow[FLOW_OUTGOING].totalbytes, 3 ));

	push	99999					; 0001869fH
	push	3
	mov	ecx, 544				; 00000220H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+edx+263240]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _outgoing$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 145  : 
; 146  : 	Con_DPrintf( "Signon network traffic:  %s from server, %s to server\n", incoming, outgoing );

	lea	edx, DWORD PTR _outgoing$[ebp]
	push	edx
	lea	eax, DWORD PTR _incoming$[ebp]
	push	eax
	push	OFFSET $SG132419
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN1@Netchan_Re:

; 147  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_ReportFlow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_chan$ = 8						; size = 4
_Netchan_IsLocal PROC

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  : 	if( !NET_IsActive() || NET_IsLocalAddress( chan->remote_address ))

	call	_NET_IsActive
	test	eax, eax
	je	SHORT $LN3@Netchan_Is
	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 4
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@Netchan_Is
$LN3@Netchan_Is:

; 159  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Netchan_Is
$LN2@Netchan_Is:

; 160  : 	return false;

	xor	eax, eax
$LN1@Netchan_Is:

; 161  : }

	pop	ebp
	ret	0
_Netchan_IsLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
tv74 = -4						; size = 4
_chan$ = 8						; size = 4
_choke$ = 12						; size = 4
_Netchan_CanPacket PROC

; 217  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 218  : 	// never choke loopback packets.
; 219  : 	if( !choke || !net_chokeloopback->value && NET_IsLocalAddress( chan->remote_address ))

	cmp	DWORD PTR _choke$[ebp], 0
	je	SHORT $LN3@Netchan_Ca
	mov	eax, DWORD PTR _net_chokeloopback
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@Netchan_Ca
	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 4
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@Netchan_Ca
$LN3@Netchan_Ca:

; 220  : 	{
; 221  : 		chan->cleartime = host.realtime;

	mov	edx, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx+56], xmm0

; 222  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Netchan_Ca
$LN2@Netchan_Ca:

; 223  : 	}
; 224  : 
; 225  : 	return chan->cleartime < host.realtime ? true : false;

	mov	eax, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jbe	SHORT $LN5@Netchan_Ca
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN6@Netchan_Ca
$LN5@Netchan_Ca:
	mov	DWORD PTR tv74[ebp], 0
$LN6@Netchan_Ca:
	mov	eax, DWORD PTR tv74[ebp]
$LN1@Netchan_Ca:

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CanPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_chan$ = 8						; size = 4
_Netchan_IncomingReady PROC

; 197  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 198  : 	int	i;
; 199  : 
; 200  : 	for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_In
$LN2@Netchan_In:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_In:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@Netchan_In

; 201  : 	{
; 202  : 		if( chan->incomingready[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx*4+262428], 0
	je	SHORT $LN5@Netchan_In

; 203  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Netchan_In
$LN5@Netchan_In:

; 204  : 	}

	jmp	SHORT $LN2@Netchan_In
$LN3@Netchan_In:

; 205  : 
; 206  : 	return false;

	xor	eax, eax
$LN1@Netchan_In:

; 207  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_IncomingReady ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_percent$1 = -1068					; size = 4
_percent$2 = -1064					; size = 4
_len$3 = -1060						; size = 4
_total$ = -1056						; size = 4
_c$ = -1052						; size = 4
_out$4 = -1048						; size = 4
_in$5 = -1044						; size = 4
_bestpercent$ = -1040					; size = 4
_p$ = -1036						; size = 4
_i$ = -1032						; size = 4
_sz$6 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_Netchan_UpdateProgress PROC

; 1179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1068				; 0000042cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1180 : 	fragbuf_t *p;
; 1181 : 	int	i, c = 0;

	mov	DWORD PTR _c$[ebp], 0

; 1182 : 	int	total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 1183 : 	float	bestpercent = 0.0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _bestpercent$[ebp], xmm0

; 1184 : 
; 1185 : 	if( host.downloadcount == 0 )

	cmp	DWORD PTR _host+752, 0
	jne	SHORT $LN9@Netchan_Up

; 1186 : 	{
; 1187 : 		scr_download->value = -1.0f;

	mov	eax, DWORD PTR _scr_download
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+12], xmm0

; 1188 : 		host.downloadfile[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _host[edx+496], 0
$LN9@Netchan_Up:

; 1189 : 	}
; 1190 : 
; 1191 : 	// do show slider for file downloads.
; 1192 : 	if( !chan->incomingbufs[FRAG_FILE_STREAM] )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+eax+262420], 0
	jne	SHORT $LN10@Netchan_Up

; 1193 : 		return;

	jmp	$LN1@Netchan_Up
$LN10@Netchan_Up:

; 1194 : 
; 1195 : 	for( i = MAX_STREAMS - 1; i >= 0; i-- )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Netchan_Up
$LN2@Netchan_Up:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Netchan_Up:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$LN3@Netchan_Up

; 1196 : 	{
; 1197 : 		// receiving data
; 1198 : 		if( chan->incomingbufs[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+eax*4+262420], 0
	je	$LN11@Netchan_Up

; 1199 : 		{
; 1200 : 			p = chan->incomingbufs[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+262420]
	mov	DWORD PTR _p$[ebp], ecx

; 1201 : 
; 1202 : 			total = FRAG_GETCOUNT( p->bufferid );

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _total$[ebp], eax
$LN5@Netchan_Up:

; 1203 : 
; 1204 : 			while( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN6@Netchan_Up

; 1205 : 			{
; 1206 : 				c++;

	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx

; 1207 : 				p = p->next;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _p$[ebp], eax

; 1208 : 			}

	jmp	SHORT $LN5@Netchan_Up
$LN6@Netchan_Up:

; 1209 : 
; 1210 : 			if( total )

	cmp	DWORD PTR _total$[ebp], 0
	je	SHORT $LN14@Netchan_Up

; 1211 : 			{
; 1212 : 				float	percent = 100.0f * (float)c / (float)total;

	cvtsi2ss xmm0, DWORD PTR _c$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _total$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _percent$2[ebp], xmm0

; 1213 : 
; 1214 : 				if( percent > bestpercent )

	movss	xmm0, DWORD PTR _percent$2[ebp]
	comiss	xmm0, DWORD PTR _bestpercent$[ebp]
	jbe	SHORT $LN14@Netchan_Up

; 1215 : 					bestpercent = percent;

	movss	xmm0, DWORD PTR _percent$2[ebp]
	movss	DWORD PTR _bestpercent$[ebp], xmm0
$LN14@Netchan_Up:

; 1216 : 			}
; 1217 : 
; 1218 : 			p = chan->incomingbufs[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+262420]
	mov	DWORD PTR _p$[ebp], eax

; 1219 : 
; 1220 : 			if( i == FRAG_FILE_STREAM ) 

	cmp	DWORD PTR _i$[ebp], 1
	jne	$LN17@Netchan_Up

; 1221 : 			{
; 1222 : 				char	sz[MAX_SYSPATH];
; 1223 : 				char	*in, *out;
; 1224 : 				int	len = 0;

	mov	DWORD PTR _len$3[ebp], 0

; 1225 : 
; 1226 : 				in = (char *)MSG_GetData( &p->frag_message );

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	mov	DWORD PTR _in$5[ebp], eax

; 1227 : 				out = sz;

	lea	edx, DWORD PTR _sz$6[ebp]
	mov	DWORD PTR _out$4[ebp], edx
$LN7@Netchan_Up:

; 1228 : 
; 1229 : 				while( *in )

	mov	eax, DWORD PTR _in$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@Netchan_Up

; 1230 : 				{
; 1231 : 					*out++ = *in++;

	mov	edx, DWORD PTR _out$4[ebp]
	mov	eax, DWORD PTR _in$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$4[ebp]
	add	edx, 1
	mov	DWORD PTR _out$4[ebp], edx
	mov	eax, DWORD PTR _in$5[ebp]
	add	eax, 1
	mov	DWORD PTR _in$5[ebp], eax

; 1232 : 					len++;

	mov	ecx, DWORD PTR _len$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$3[ebp], ecx

; 1233 : 					if( len > 128 )

	cmp	DWORD PTR _len$3[ebp], 128		; 00000080H
	jle	SHORT $LN16@Netchan_Up

; 1234 : 						break;

	jmp	SHORT $LN8@Netchan_Up
$LN16@Netchan_Up:

; 1235 : 				}

	jmp	SHORT $LN7@Netchan_Up
$LN8@Netchan_Up:

; 1236 : 				*out = '\0';

	mov	edx, DWORD PTR _out$4[ebp]
	mov	BYTE PTR [edx], 0

; 1237 : 
; 1238 : 				if( Q_strlen( sz ) > 0 && sz[0] != '!' )

	lea	eax, DWORD PTR _sz$6[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN17@Netchan_Up
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$6[ebp+edx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN17@Netchan_Up

; 1239 : 					Q_strncpy( host.downloadfile, sz, sizeof( host.downloadfile ));

	push	256					; 00000100H
	lea	ecx, DWORD PTR _sz$6[ebp]
	push	ecx
	push	OFFSET _host+496
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN17@Netchan_Up:

; 1240 : 			}
; 1241 : 		}

	jmp	$LN20@Netchan_Up
$LN11@Netchan_Up:

; 1242 : 		else if( chan->fragbufs[i] )	// Sending data

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [eax+edx*4+262388], 0
	je	SHORT $LN20@Netchan_Up

; 1243 : 		{
; 1244 : 			if( chan->fragbufcount[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx*4+262396], 0
	je	SHORT $LN20@Netchan_Up

; 1245 : 			{
; 1246 : 				float	percent = 100.0f * (float)chan->fragbufs[i]->bufferid / (float)chan->fragbufcount[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+262388]
	cvtsi2ss xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+eax*4+262396]
	divss	xmm0, xmm1
	movss	DWORD PTR _percent$1[ebp], xmm0

; 1247 : 
; 1248 : 				if( percent > bestpercent )

	movss	xmm0, DWORD PTR _percent$1[ebp]
	comiss	xmm0, DWORD PTR _bestpercent$[ebp]
	jbe	SHORT $LN20@Netchan_Up

; 1249 : 					bestpercent = percent;

	movss	xmm0, DWORD PTR _percent$1[ebp]
	movss	DWORD PTR _bestpercent$[ebp], xmm0
$LN20@Netchan_Up:

; 1250 : 			}
; 1251 : 		}
; 1252 : 
; 1253 : 	}

	jmp	$LN2@Netchan_Up
$LN3@Netchan_Up:

; 1254 : 
; 1255 : 	scr_download->value = bestpercent;

	mov	edx, DWORD PTR _scr_download
	movss	xmm0, DWORD PTR _bestpercent$[ebp]
	movss	DWORD PTR [edx+12], xmm0
$LN1@Netchan_Up:

; 1256 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_UpdateProgress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_temp$1 = -65668					; size = 20
_inbufferid$2 = -65648					; size = 4
_qport$ = -65644					; size = 4
_oldpos$3 = -65640					; size = 4
_curbit$4 = -65636					; size = 4
_numbitstoremove$5 = -65632				; size = 4
_intotalbuffers$6 = -65628				; size = 4
_size$7 = -65624					; size = 4
_frag_message$ = -65620					; size = 8
_bits$8 = -65612					; size = 4
_message_contains_fragments$ = -65608			; size = 4
_reliable_message$ = -65604				; size = 4
_reliable_ack$ = -65600					; size = 4
_adr$9 = -65596						; size = 4
tv84 = -65592						; size = 4
_frag_length$ = -65588					; size = 8
_frag_offset$ = -65580					; size = 8
_fragid$ = -65572					; size = 8
_pbuf$10 = -65564					; size = 4
_statId$ = -65560					; size = 4
_j$11 = -65556						; size = 4
_sequence_ack$ = -65552					; size = 4
_sequence$ = -65548					; size = 4
_i$ = -65544						; size = 4
_buffer$12 = -65540					; size = 65536
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_msg$ = 12						; size = 4
_Netchan_Process PROC

; 1572 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 65668				; 00010084H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1573 : 	uint	sequence, sequence_ack;
; 1574 : 	uint	reliable_ack, reliable_message;
; 1575 : 	uint	fragid[MAX_STREAMS] = { 0, 0 };

	mov	DWORD PTR _fragid$[ebp], 0
	mov	DWORD PTR _fragid$[ebp+4], 0

; 1576 : 	qboolean	frag_message[MAX_STREAMS] = { false, false };

	mov	DWORD PTR _frag_message$[ebp], 0
	mov	DWORD PTR _frag_message$[ebp+4], 0

; 1577 : 	int	frag_offset[MAX_STREAMS] = { 0, 0 };

	mov	DWORD PTR _frag_offset$[ebp], 0
	mov	DWORD PTR _frag_offset$[ebp+4], 0

; 1578 : 	int	frag_length[MAX_STREAMS] = { 0, 0 };

	mov	DWORD PTR _frag_length$[ebp], 0
	mov	DWORD PTR _frag_length$[ebp+4], 0

; 1579 : 	qboolean	message_contains_fragments;
; 1580 : 	int	i, qport, statId;
; 1581 : 
; 1582 : 	if( !CL_IsPlaybackDemo() && !NET_CompareAdr( net_from, chan->remote_address ))

	call	_CL_IsPlaybackDemo
	test	eax, eax
	jne	SHORT $LN11@Netchan_Pr
	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 4
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _net_from
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _net_from+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _net_from+8
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _net_from+12
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _net_from+16
	mov	DWORD PTR [ecx+16], edx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN11@Netchan_Pr

; 1583 : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Pr
$LN11@Netchan_Pr:

; 1584 : 
; 1585 : 	// get sequence numbers
; 1586 : 	MSG_Clear( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 1587 : 	sequence = MSG_ReadLong( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _sequence$[ebp], eax

; 1588 : 	sequence_ack = MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _sequence_ack$[ebp], eax

; 1589 : 
; 1590 : 	// read the qport if we are a server
; 1591 : 	if( chan->sock == NS_SERVER )

	mov	eax, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@Netchan_Pr

; 1592 : 		qport = MSG_ReadShort( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _qport$[ebp], eax
$LN12@Netchan_Pr:

; 1593 : 
; 1594 : 	reliable_message = sequence >> 31;

	mov	edx, DWORD PTR _sequence$[ebp]
	shr	edx, 31					; 0000001fH
	mov	DWORD PTR _reliable_message$[ebp], edx

; 1595 : 	reliable_ack = sequence_ack >> 31;

	mov	eax, DWORD PTR _sequence_ack$[ebp]
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _reliable_ack$[ebp], eax

; 1596 : 
; 1597 : 	message_contains_fragments = FBitSet( sequence, BIT( 30 )) ? true : false;

	mov	ecx, DWORD PTR _sequence$[ebp]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN31@Netchan_Pr
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN32@Netchan_Pr
$LN31@Netchan_Pr:
	mov	DWORD PTR tv84[ebp], 0
$LN32@Netchan_Pr:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _message_contains_fragments$[ebp], edx

; 1598 : 
; 1599 : 	if( message_contains_fragments )

	cmp	DWORD PTR _message_contains_fragments$[ebp], 0
	je	$LN15@Netchan_Pr

; 1600 : 	{
; 1601 : 		for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_Pr
$LN2@Netchan_Pr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_Pr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@Netchan_Pr

; 1602 : 		{
; 1603 : 			if( MSG_ReadByte( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@Netchan_Pr

; 1604 : 			{
; 1605 : 				frag_message[i] = true;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _frag_message$[ebp+edx*4], 1

; 1606 : 				fragid[i] = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _fragid$[ebp+ecx*4], eax

; 1607 : 				frag_offset[i] = MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _frag_offset$[ebp+ecx*4], eax

; 1608 : 				frag_length[i] = MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _frag_length$[ebp+ecx*4], eax
$LN14@Netchan_Pr:

; 1609 : 			}
; 1610 : 		}

	jmp	$LN2@Netchan_Pr
$LN3@Netchan_Pr:

; 1611 : 
; 1612 : 		if( !Netchan_Validate( chan, msg, frag_message, fragid, frag_offset, frag_length ))

	lea	edx, DWORD PTR _frag_length$[ebp]
	push	edx
	lea	eax, DWORD PTR _frag_offset$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fragid$[ebp]
	push	ecx
	lea	edx, DWORD PTR _frag_message$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	call	_Netchan_Validate
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN15@Netchan_Pr

; 1613 : 			return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Pr
$LN15@Netchan_Pr:

; 1614 : 	}
; 1615 : 
; 1616 : 	sequence &= ~BIT( 31 );

	mov	edx, DWORD PTR _sequence$[ebp]
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _sequence$[ebp], edx

; 1617 : 	sequence &= ~BIT( 30 );

	mov	eax, DWORD PTR _sequence$[ebp]
	and	eax, -1073741825			; bfffffffH
	mov	DWORD PTR _sequence$[ebp], eax

; 1618 : 	sequence_ack &= ~BIT( 30 );

	mov	ecx, DWORD PTR _sequence_ack$[ebp]
	and	ecx, -1073741825			; bfffffffH
	mov	DWORD PTR _sequence_ack$[ebp], ecx

; 1619 : 	sequence_ack &= ~BIT( 31 );

	mov	edx, DWORD PTR _sequence_ack$[ebp]
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _sequence_ack$[ebp], edx

; 1620 : 
; 1621 : 	if( net_showpackets->value && net_showpackets->value != 3.0f )

	mov	eax, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@Netchan_Pr
	mov	ecx, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@40400000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@Netchan_Pr

; 1622 : 	{
; 1623 : 		Con_Printf( " %s <-- sz=%i seq=%i ack=%i rel=%i tm=%f\n"

	sub	esp, 8
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _reliable_message$[ebp]
	push	edx
	mov	eax, DWORD PTR _sequence_ack$[ebp]
	and	eax, 63					; 0000003fH
	push	eax
	mov	ecx, DWORD PTR _sequence$[ebp]
	and	ecx, 63					; 0000003fH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetMaxBytes
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ns_strings[ecx*4]
	push	edx
	push	OFFSET $SG133056
	call	_Con_Printf
	add	esp, 32					; 00000020H
$LN16@Netchan_Pr:

; 1624 : 			, ns_strings[chan->sock]
; 1625 : 			, MSG_GetMaxBytes( msg )
; 1626 : 			, sequence & 63
; 1627 : 			, sequence_ack & 63 
; 1628 : 			, reliable_message
; 1629 : 			, host.realtime );
; 1630 : 	}
; 1631 : 
; 1632 : 	// discard stale or duplicated packets
; 1633 : 	if( sequence <= (uint)chan->incoming_sequence )

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	ja	$LN17@Netchan_Pr

; 1634 : 	{
; 1635 : 		if( net_showdrop->value )

	mov	edx, DWORD PTR _net_showdrop
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN20@Netchan_Pr

; 1636 : 		{
; 1637 : 			const char *adr = NET_AdrToString( chan->remote_address );

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 4
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	mov	DWORD PTR _adr$9[ebp], eax

; 1638 : 
; 1639 : 			if( sequence == (uint)chan->incoming_sequence )

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _sequence$[ebp]
	cmp	edx, DWORD PTR [ecx+64]
	jne	SHORT $LN19@Netchan_Pr

; 1640 : 				Con_Printf( "%s:duplicate packet %i at %i\n", adr, sequence, chan->incoming_sequence );

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _sequence$[ebp]
	push	edx
	mov	eax, DWORD PTR _adr$9[ebp]
	push	eax
	push	OFFSET $SG133061
	call	_Con_Printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN20@Netchan_Pr
$LN19@Netchan_Pr:

; 1641 : 			else Con_Printf( "%s:out of order packet %i at %i\n", adr, sequence, chan->incoming_sequence );

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _adr$9[ebp]
	push	ecx
	push	OFFSET $SG133062
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN20@Netchan_Pr:

; 1642 : 		}
; 1643 : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Pr
$LN17@Netchan_Pr:

; 1644 : 	}
; 1645 : 
; 1646 : 	// dropped packets don't keep the message from being used
; 1647 : 	net_drop = sequence - ( chan->incoming_sequence + 1 );

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+64]
	add	eax, 1
	mov	ecx, DWORD PTR _sequence$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _net_drop, ecx

; 1648 : 	if( net_drop > 0 && net_showdrop->value )

	cmp	DWORD PTR _net_drop, 0
	jle	SHORT $LN21@Netchan_Pr
	mov	edx, DWORD PTR _net_showdrop
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@Netchan_Pr

; 1649 : 		Con_Printf( "%s:dropped %i packets at %i\n", NET_AdrToString( chan->remote_address ), net_drop, sequence );

	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_drop
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	add	edx, 4
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG133064
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN21@Netchan_Pr:

; 1650 : 
; 1651 : 	// if the current outgoing reliable message has been acknowledged
; 1652 : 	// clear the buffer to make way for the next
; 1653 : 	if( reliable_ack == (uint)chan->reliable_sequence )

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _reliable_ack$[ebp]
	cmp	ecx, DWORD PTR [eax+84]
	jne	SHORT $LN23@Netchan_Pr

; 1654 : 	{
; 1655 : 		// make sure we actually could have ack'd this message
; 1656 : 		if( sequence_ack >= (uint)chan->last_reliable_sequence )

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _sequence_ack$[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jb	SHORT $LN23@Netchan_Pr

; 1657 : 		{
; 1658 : 			chan->reliable_length = 0;	// it has been received

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+131240], 0
$LN23@Netchan_Pr:

; 1659 : 		}
; 1660 : 	}
; 1661 : 	
; 1662 : 	// if this message contains a reliable message, bump incoming_reliable_sequence 
; 1663 : 	chan->incoming_sequence = sequence;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _sequence$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1664 : 	chan->incoming_acknowledged = sequence_ack;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _sequence_ack$[ebp]
	mov	DWORD PTR [ecx+68], edx

; 1665 : 	chan->incoming_reliable_acknowledged = reliable_ack;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _reliable_ack$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1666 : 	if( reliable_message )

	cmp	DWORD PTR _reliable_message$[ebp], 0
	je	SHORT $LN24@Netchan_Pr

; 1667 : 	{
; 1668 : 		chan->incoming_reliable_sequence ^= 1;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+76]
	xor	eax, 1
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN24@Netchan_Pr:

; 1669 : 	}
; 1670 : 
; 1671 : 	chan->last_received = host.realtime;

	mov	edx, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx+32], xmm0

; 1672 : 
; 1673 : 	// Update data flow stats
; 1674 : 	statId = chan->flow[FLOW_INCOMING].current & MASK_LATENT;

	mov	eax, 544				; 00000220H
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax+263216]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _statId$[ebp], edx

; 1675 : 	chan->flow[FLOW_INCOMING].stats[statId].size = MSG_GetMaxBytes( msg ) + UDP_HEADER_SIZE;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetMaxBytes
	add	esp, 4
	add	eax, 28					; 0000001cH
	mov	ecx, 544				; 00000220H
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+262704]
	mov	edx, DWORD PTR _statId$[ebp]
	shl	edx, 4
	mov	DWORD PTR [ecx+edx], eax

; 1676 : 	chan->flow[FLOW_INCOMING].stats[statId].time = host.realtime;

	mov	eax, 544				; 00000220H
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	lea	edx, DWORD PTR [ecx+eax+262704]
	mov	eax, DWORD PTR _statId$[ebp]
	shl	eax, 4
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx+eax+8], xmm0

; 1677 : 	chan->flow[FLOW_INCOMING].totalbytes += chan->flow[FLOW_INCOMING].stats[statId].size;

	mov	ecx, 544				; 00000220H
	shl	ecx, 0
	mov	edx, 544				; 00000220H
	shl	edx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	lea	edx, DWORD PTR [eax+edx+262704]
	mov	eax, DWORD PTR _statId$[ebp]
	shl	eax, 4
	mov	esi, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+263240]
	add	ecx, DWORD PTR [edx+eax]
	mov	edx, 544				; 00000220H
	shl	edx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+edx+263240], ecx

; 1678 : 	chan->flow[FLOW_INCOMING].current++;

	mov	ecx, 544				; 00000220H
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+263216]
	add	eax, 1
	mov	ecx, 544				; 00000220H
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx+263216], eax

; 1679 : 
; 1680 : 	Netchan_UpdateFlow( chan );

	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_UpdateFlow
	add	esp, 4

; 1681 : 
; 1682 : 	chan->total_received += MSG_GetMaxBytes( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	mov	edx, DWORD PTR _chan$[ebp]
	add	eax, DWORD PTR [edx+263796]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+263796], eax

; 1683 : 
; 1684 : 	if( message_contains_fragments )

	cmp	DWORD PTR _message_contains_fragments$[ebp], 0
	je	$LN29@Netchan_Pr

; 1685 : 	{
; 1686 : 		for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Netchan_Pr
$LN5@Netchan_Pr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Netchan_Pr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN6@Netchan_Pr

; 1687 : 		{
; 1688 : 			int	j, inbufferid;
; 1689 : 			int	intotalbuffers;
; 1690 : 			int	oldpos, curbit;
; 1691 : 			int	numbitstoremove;
; 1692 : 			fragbuf_t	*pbuf;
; 1693 : 
; 1694 : 			if( !frag_message[i] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _frag_message$[ebp+eax*4], 0
	jne	SHORT $LN26@Netchan_Pr

; 1695 : 				continue;

	jmp	SHORT $LN5@Netchan_Pr
$LN26@Netchan_Pr:

; 1696 : 		
; 1697 : 			inbufferid = FRAG_GETID( fragid[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fragid$[ebp+ecx*4]
	shr	edx, 16					; 00000010H
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _inbufferid$2[ebp], edx

; 1698 : 			intotalbuffers = FRAG_GETCOUNT( fragid[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fragid$[ebp+eax*4]
	and	ecx, 65535				; 0000ffffH
	mov	DWORD PTR _intotalbuffers$6[ebp], ecx

; 1699 : 
; 1700 : 			if( fragid[i] != 0 )

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _fragid$[ebp+edx*4], 0
	je	$LN27@Netchan_Pr

; 1701 : 			{
; 1702 : 				pbuf = Netchan_FindBufferById( &chan->incomingbufs[i], fragid[i], true );

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fragid$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+262420]
	push	ecx
	call	_Netchan_FindBufferById
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pbuf$10[ebp], eax

; 1703 : 
; 1704 : 				if( pbuf )

	cmp	DWORD PTR _pbuf$10[ebp], 0
	je	$LN28@Netchan_Pr

; 1705 : 				{
; 1706 : 					byte	buffer[NET_MAX_FRAGMENT];
; 1707 : 					int	bits, size;
; 1708 : 					sizebuf_t	temp;
; 1709 : 
; 1710 : 					size = MSG_GetNumBitsRead( msg ) + frag_offset[i];

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _frag_offset$[ebp+ecx*4]
	mov	DWORD PTR _size$7[ebp], eax

; 1711 : 					bits = frag_length[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _frag_length$[ebp+edx*4]
	mov	DWORD PTR _bits$8[ebp], eax

; 1712 : 				
; 1713 : 					// copy in data
; 1714 : 					MSG_Clear( &pbuf->frag_message );

	mov	ecx, DWORD PTR _pbuf$10[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_Clear
	add	esp, 4

; 1715 : 
; 1716 : 					MSG_StartReading( &temp, msg->pData, MSG_GetMaxBytes( msg ), size, -1 );

	push	-1
	mov	edx, DWORD PTR _size$7[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetMaxBytes
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR _temp$1[ebp]
	push	eax
	call	_MSG_StartWriting
	add	esp, 20					; 00000014H

; 1717 : 					MSG_ReadBits( &temp, buffer, bits );

	mov	ecx, DWORD PTR _bits$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$12[ebp]
	push	edx
	lea	eax, DWORD PTR _temp$1[ebp]
	push	eax
	call	_MSG_ReadBits
	add	esp, 12					; 0000000cH

; 1718 : 					MSG_WriteBits( &pbuf->frag_message, buffer, bits );

	mov	ecx, DWORD PTR _bits$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$12[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$10[ebp]
	add	eax, 8
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
$LN28@Netchan_Pr:

; 1719 : 				}
; 1720 : 
; 1721 : 				// count # of incoming bufs we've queued? are we done?
; 1722 : 				Netchan_CheckForCompletion( chan, i, intotalbuffers );

	mov	ecx, DWORD PTR _intotalbuffers$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_CheckForCompletion
	add	esp, 12					; 0000000cH
$LN27@Netchan_Pr:

; 1723 : 			}
; 1724 : 
; 1725 : 			// rearrange incoming data to not have the frag stuff in the middle of it
; 1726 : 			oldpos = MSG_GetNumBitsRead( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	DWORD PTR _oldpos$3[ebp], eax

; 1727 : 			curbit = MSG_GetNumBitsRead( msg ) + frag_offset[i];

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _frag_offset$[ebp+ecx*4]
	mov	DWORD PTR _curbit$4[ebp], eax

; 1728 : 			numbitstoremove = frag_length[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _frag_length$[ebp+edx*4]
	mov	DWORD PTR _numbitstoremove$5[ebp], eax

; 1729 : 
; 1730 : 			MSG_ExciseBits( msg, curbit, numbitstoremove );

	mov	ecx, DWORD PTR _numbitstoremove$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _curbit$4[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ExciseBits
	add	esp, 12					; 0000000cH

; 1731 : 			MSG_SeekToBit( msg, oldpos, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _oldpos$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 1732 : 
; 1733 : 			for( j = i + 1; j < MAX_STREAMS; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$11[ebp], eax
	jmp	SHORT $LN10@Netchan_Pr
$LN8@Netchan_Pr:
	mov	ecx, DWORD PTR _j$11[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$11[ebp], ecx
$LN10@Netchan_Pr:
	cmp	DWORD PTR _j$11[ebp], 2
	jge	SHORT $LN9@Netchan_Pr

; 1734 : 				frag_offset[j] -= frag_length[i];

	mov	edx, DWORD PTR _j$11[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _frag_offset$[ebp+edx*4]
	sub	ecx, DWORD PTR _frag_length$[ebp+eax*4]
	mov	edx, DWORD PTR _j$11[ebp]
	mov	DWORD PTR _frag_offset$[ebp+edx*4], ecx
	jmp	SHORT $LN8@Netchan_Pr
$LN9@Netchan_Pr:

; 1735 : 		}

	jmp	$LN5@Netchan_Pr
$LN6@Netchan_Pr:

; 1736 : 
; 1737 : 		// is there anything left to process?
; 1738 : 		if( MSG_GetNumBitsLeft( msg ) <= 0 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN29@Netchan_Pr

; 1739 : 		{
; 1740 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Pr
$LN29@Netchan_Pr:

; 1741 : 		}
; 1742 : 	}
; 1743 : 
; 1744 : 	return true;

	mov	eax, 1
$LN1@Netchan_Pr:

; 1745 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_argptr$ = -8200					; size = 4
_string$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_net_socket$ = 8					; size = 4
_adr$ = 12						; size = 20
_format$ = 32						; size = 4
_Netchan_OutOfBandPrint PROC

; 388  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8200				; 00002008H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 389  : 	char	string[MAX_PRINT_MSG];
; 390  : 	va_list	argptr;
; 391  : 
; 392  : 	va_start( argptr, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 393  : 	Q_vsnprintf( string, sizeof( string ) - 1, format, argptr );

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	push	8191					; 00001fffH
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 394  : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 395  : 
; 396  : 	Netchan_OutOfBand( net_socket, adr, Q_strlen( string ), string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	_Netchan_OutOfBand
	add	esp, 32					; 00000020H

; 397  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_OutOfBandPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_send$ = -8216						; size = 20
_send_buf$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_net_socket$ = 8					; size = 4
_adr$ = 12						; size = 20
_length$ = 32						; size = 4
_data$ = 36						; size = 4
_Netchan_OutOfBand PROC

; 363  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8216				; 00002018H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 364  : 	byte	send_buf[MAX_PRINT_MSG];
; 365  : 	sizebuf_t	send;
; 366  : 
; 367  : 	// write the packet header
; 368  : 	MSG_Init( &send, "SequencePacket", send_buf, sizeof( send_buf ));

	push	-1
	push	8192					; 00002000H
	lea	eax, DWORD PTR _send_buf$[ebp]
	push	eax
	push	OFFSET $SG132515
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 369  : 	
; 370  : 	MSG_WriteLong( &send, NET_HEADER_OUTOFBANDPACKET ); // -1 sequence means out of band

	push	-1
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 371  : 	MSG_WriteBytes( &send, data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 372  : 
; 373  : 	if( !CL_IsPlaybackDemo( ))

	call	_CL_IsPlaybackDemo
	test	eax, eax
	jne	SHORT $LN1@Netchan_Ou

; 374  : 	{
; 375  : 		// send the datagram
; 376  : 		NET_SendPacket( net_socket, MSG_GetNumBytesWritten( &send ), MSG_GetData( &send ), adr );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN1@Netchan_Ou:

; 377  : 	}
; 378  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_OutOfBand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_temp$1 = -197032					; size = 20
_w2$ = -197012						; size = 4
_newpayloadsize$2 = -197008				; size = 4
_send_from_frag$3 = -197004				; size = 8
tv502 = -196996						; size = 4
_fRate$ = -196992					; size = 4
_send_frag$4 = -196988					; size = 4
tv86 = -196984						; size = 4
_statId$ = -196980					; size = 4
_send_reliable_fragment$ = -196976			; size = 4
_w1$ = -196972						; size = 4
_fragment_size$5 = -196968				; size = 4
_send$ = -196964					; size = 20
_file$6 = -196944					; size = 4
_j$ = -196940						; size = 4
_send_from_regular$7 = -196936				; size = 4
_send_reliable$ = -196932				; size = 4
_pbuf$8 = -196928					; size = 4
_i$ = -196924						; size = 4
_send_buf$ = -196920					; size = 131120
_filebuffer$9 = -65800					; size = 65536
_compressedfilename$10 = -264				; size = 260
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_length$ = 12						; size = 4
_data$ = 16						; size = 4
_Netchan_TransmitBits PROC

; 1269 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 197032				; 000301a8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1270 : 	byte	send_buf[NET_MAX_MESSAGE];
; 1271 : 	qboolean	send_reliable_fragment;
; 1272 : 	uint	w1, w2, statId;
; 1273 : 	qboolean	send_reliable;
; 1274 : 	sizebuf_t	send;
; 1275 : 	int	i, j;
; 1276 : 	float	fRate;
; 1277 : 
; 1278 : 	// check for message overflow
; 1279 : 	if( MSG_CheckOverflow( &chan->message ))

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN26@Netchan_Tr

; 1280 : 	{
; 1281 : 		Con_Printf( S_ERROR "%s:outgoing message overflow\n", NET_AdrToString( chan->remote_address ));

	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 4
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG132959
	call	_Con_Printf
	add	esp, 8

; 1282 : 		return;

	jmp	$LN60@Netchan_Tr
$LN26@Netchan_Tr:

; 1283 : 	}
; 1284 : 
; 1285 : 	// if the remote side dropped the last reliable message, resend it
; 1286 : 	send_reliable = false;

	mov	DWORD PTR _send_reliable$[ebp], 0

; 1287 : 
; 1288 : 	if( chan->incoming_acknowledged > chan->last_reliable_sequence && chan->incoming_reliable_acknowledged != chan->reliable_sequence )

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [edx+68]
	cmp	ecx, DWORD PTR [eax+88]
	jle	SHORT $LN27@Netchan_Tr
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	cmp	ecx, DWORD PTR [eax+84]
	je	SHORT $LN27@Netchan_Tr

; 1289 : 		send_reliable = true;

	mov	DWORD PTR _send_reliable$[ebp], 1
$LN27@Netchan_Tr:

; 1290 : 
; 1291 : 	// A packet can have "reliable payload + frag payload + unreliable payload
; 1292 : 	// frag payload can be a file chunk, if so, it needs to be parsed on the receiving end and reliable payload + unreliable payload need
; 1293 : 	// to be passed on to the message queue.  The processing routine needs to be able to handle the case where a message comes in and a file
; 1294 : 	// transfer completes
; 1295 : 
; 1296 : 	// if the reliable transmit buffer is empty, copy the current message out
; 1297 : 	if( !chan->reliable_length )

	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+131240], 0
	jne	$LN12@Netchan_Tr

; 1298 : 	{
; 1299 : 		qboolean	send_frag = false;

	mov	DWORD PTR _send_frag$4[ebp], 0

; 1300 : 		fragbuf_t	*pbuf;
; 1301 : 
; 1302 : 		// will be true if we are active and should let chan->message get some bandwidth
; 1303 : 		int	send_from_frag[MAX_STREAMS] = { 0, 0 };

	mov	DWORD PTR _send_from_frag$3[ebp], 0
	mov	DWORD PTR _send_from_frag$3[ebp+4], 0

; 1304 : 		int	send_from_regular = 0;

	mov	DWORD PTR _send_from_regular$7[ebp], 0

; 1305 : 
; 1306 : 		// if we have data in the waiting list(s) and we have cleared the current queue(s), then 
; 1307 : 		// push the waitlist(s) into the current queue(s)
; 1308 : 		Netchan_FragSend( chan );

	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_FragSend
	add	esp, 4

; 1309 : 
; 1310 : 		// sending regular payload
; 1311 : 		send_from_regular = MSG_GetNumBytesWritten( &chan->message ) ? 1 : 0;

	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	je	SHORT $LN62@Netchan_Tr
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN63@Netchan_Tr
$LN62@Netchan_Tr:
	mov	DWORD PTR tv86[ebp], 0
$LN63@Netchan_Tr:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _send_from_regular$7[ebp], edx

; 1312 : 
; 1313 : 		// check to see if we are sending a frag payload
; 1314 : 		for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Netchan_Tr
$LN2@Netchan_Tr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@Netchan_Tr

; 1315 : 		{
; 1316 : 			if( chan->fragbufs[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx*4+262388], 0
	je	SHORT $LN29@Netchan_Tr

; 1317 : 				send_from_frag[i] = 1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _send_from_frag$3[ebp+eax*4], 1
$LN29@Netchan_Tr:

; 1318 : 		}

	jmp	SHORT $LN2@Netchan_Tr
$LN3@Netchan_Tr:

; 1319 : 
; 1320 : 		// stall reliable payloads if sending from frag buffer
; 1321 : 		if( send_from_regular && ( send_from_frag[FRAG_NORMAL_STREAM] ))

	cmp	DWORD PTR _send_from_regular$7[ebp], 0
	je	SHORT $LN31@Netchan_Tr
	mov	ecx, 4
	imul	edx, ecx, 0
	cmp	DWORD PTR _send_from_frag$3[ebp+edx], 0
	je	SHORT $LN31@Netchan_Tr

; 1322 : 		{	
; 1323 : 			send_from_regular = false;

	mov	DWORD PTR _send_from_regular$7[ebp], 0

; 1324 : 
; 1325 : 			// if the reliable buffer has gotten too big, queue it at the end of everything and clear out buffer
; 1326 : 			if( MSG_GetNumBytesWritten( &chan->message ) > MAX_RELIABLE_PAYLOAD )

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	cmp	eax, 1400				; 00000578H
	jle	SHORT $LN31@Netchan_Tr

; 1327 : 			{
; 1328 : 				Netchan_CreateFragments_( chan, &chan->message );

	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	call	_Netchan_CreateFragments_
	add	esp, 8

; 1329 : 				MSG_Clear( &chan->message );

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_MSG_Clear
	add	esp, 4
$LN31@Netchan_Tr:

; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 		// startpos will be zero if there is no regular payload
; 1334 : 		for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Netchan_Tr
$LN5@Netchan_Tr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN6@Netchan_Tr

; 1335 : 		{
; 1336 : 			chan->frag_startpos[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+edx*4+262404], 0

; 1337 : 
; 1338 : 			// assume no fragment is being sent
; 1339 : 			chan->reliable_fragment[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx*4+262372], 0

; 1340 : 			chan->reliable_fragid[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax*4+262380], 0

; 1341 : 			chan->frag_length[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+edx*4+262412], 0

; 1342 : 
; 1343 : 			if( send_from_frag[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _send_from_frag$3[ebp+ecx*4], 0
	je	SHORT $LN32@Netchan_Tr

; 1344 : 			{
; 1345 : 				send_frag = true;

	mov	DWORD PTR _send_frag$4[ebp], 1
$LN32@Netchan_Tr:

; 1346 : 			}
; 1347 : 		}

	jmp	$LN5@Netchan_Tr
$LN6@Netchan_Tr:

; 1348 : 
; 1349 : 		if( send_from_regular || send_frag )

	cmp	DWORD PTR _send_from_regular$7[ebp], 0
	jne	SHORT $LN34@Netchan_Tr
	cmp	DWORD PTR _send_frag$4[ebp], 0
	je	SHORT $LN33@Netchan_Tr
$LN34@Netchan_Tr:

; 1350 : 		{
; 1351 : 			chan->reliable_sequence ^= 1;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+84]
	xor	eax, 1
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 1352 : 			send_reliable = true;

	mov	DWORD PTR _send_reliable$[ebp], 1
$LN33@Netchan_Tr:

; 1353 : 		}
; 1354 : 
; 1355 : 		if( send_from_regular )

	cmp	DWORD PTR _send_from_regular$7[ebp], 0
	je	$LN9@Netchan_Tr

; 1356 : 		{
; 1357 : 			memcpy( chan->reliable_buf, chan->message_buf, MSG_GetNumBytesWritten( &chan->message ));

	mov	edx, DWORD PTR _chan$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 131244				; 000200acH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1358 : 			chan->reliable_length = MSG_GetNumBitsWritten( &chan->message );

	mov	edx, DWORD PTR _chan$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+131240], eax

; 1359 : 			MSG_Clear( &chan->message );

	mov	edx, DWORD PTR _chan$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	_MSG_Clear
	add	esp, 4

; 1360 : 
; 1361 : 			// if we send fragments, this is where they'll start
; 1362 : 			for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Netchan_Tr
$LN8@Netchan_Tr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN9@Netchan_Tr

; 1363 : 				chan->frag_startpos[i] = chan->reliable_length;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [eax+131240]
	mov	DWORD PTR [edx+ecx*4+262404], eax
	jmp	SHORT $LN8@Netchan_Tr
$LN9@Netchan_Tr:

; 1364 : 		}
; 1365 : 
; 1366 : 		for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Netchan_Tr
$LN11@Netchan_Tr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN12@Netchan_Tr

; 1367 : 		{
; 1368 : 			int	newpayloadsize;
; 1369 : 			int	fragment_size;
; 1370 : 
; 1371 : 			// is there someting in the fragbuf?
; 1372 : 			pbuf = chan->fragbufs[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+262388]
	mov	DWORD PTR _pbuf$8[ebp], ecx

; 1373 : 			fragment_size = 0;

	mov	DWORD PTR _fragment_size$5[ebp], 0

; 1374 : 
; 1375 : 			if( pbuf )

	cmp	DWORD PTR _pbuf$8[ebp], 0
	je	SHORT $LN37@Netchan_Tr

; 1376 : 			{
; 1377 : 				fragment_size = MSG_GetNumBytesWritten( &pbuf->frag_message );

	mov	edx, DWORD PTR _pbuf$8[ebp]
	add	edx, 8
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _fragment_size$5[ebp], eax

; 1378 : 				
; 1379 : 				// files set size a bit differently.
; 1380 : 				if( pbuf->isfile && !pbuf->isbuffer )

	mov	eax, DWORD PTR _pbuf$8[ebp]
	cmp	DWORD PTR [eax+65564], 0
	je	SHORT $LN37@Netchan_Tr
	mov	ecx, DWORD PTR _pbuf$8[ebp]
	cmp	DWORD PTR [ecx+65568], 0
	jne	SHORT $LN37@Netchan_Tr

; 1381 : 				{
; 1382 : 					fragment_size = pbuf->size;

	mov	edx, DWORD PTR _pbuf$8[ebp]
	mov	eax, DWORD PTR [edx+65840]
	mov	DWORD PTR _fragment_size$5[ebp], eax
$LN37@Netchan_Tr:

; 1383 : 				}
; 1384 : 			}
; 1385 : 
; 1386 : 			newpayloadsize = (( chan->reliable_length + ( fragment_size << 3 )) + 7 ) >> 3;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+131240]
	mov	eax, DWORD PTR _fragment_size$5[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+7]
	sar	ecx, 3
	mov	DWORD PTR _newpayloadsize$2[ebp], ecx

; 1387 : 
; 1388 : 			// make sure we have enought space left
; 1389 : 			if( send_from_frag[i] && pbuf && newpayloadsize < NET_MAX_FRAGMENT )

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _send_from_frag$3[ebp+edx*4], 0
	je	$LN15@Netchan_Tr
	cmp	DWORD PTR _pbuf$8[ebp], 0
	je	$LN15@Netchan_Tr
	cmp	DWORD PTR _newpayloadsize$2[ebp], 65536	; 00010000H
	jge	$LN15@Netchan_Tr

; 1390 : 			{
; 1391 : 				sizebuf_t	temp;
; 1392 : 
; 1393 : 				// which buffer are we sending ?
; 1394 : 				chan->reliable_fragid[i] = MAKE_FRAGID( pbuf->bufferid, chan->fragbufcount[i] );

	mov	eax, DWORD PTR _pbuf$8[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 65535				; 0000ffffH
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+262396]
	and	edx, 65535				; 0000ffffH
	or	ecx, edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+eax*4+262380], ecx

; 1395 : 			
; 1396 : 				// if it's not in-memory, then we'll need to copy it in frame the file handle.
; 1397 : 				if( pbuf->isfile && !pbuf->isbuffer )

	mov	eax, DWORD PTR _pbuf$8[ebp]
	cmp	DWORD PTR [eax+65564], 0
	je	$LN39@Netchan_Tr
	mov	ecx, DWORD PTR _pbuf$8[ebp]
	cmp	DWORD PTR [ecx+65568], 0
	jne	$LN39@Netchan_Tr

; 1398 : 				{
; 1399 : 					byte	filebuffer[NET_MAX_FRAGMENT];
; 1400 : 					file_t	*file;
; 1401 : 
; 1402 : 					if( pbuf->iscompressed )

	mov	edx, DWORD PTR _pbuf$8[ebp]
	cmp	DWORD PTR [edx+65572], 0
	je	SHORT $LN40@Netchan_Tr

; 1403 : 					{
; 1404 : 						char	compressedfilename[MAX_OSPATH];
; 1405 : 
; 1406 : 						Q_strncpy( compressedfilename, pbuf->filename, sizeof( compressedfilename ));

	push	260					; 00000104H
	mov	eax, DWORD PTR _pbuf$8[ebp]
	add	eax, 65576				; 00010028H
	push	eax
	lea	ecx, DWORD PTR _compressedfilename$10[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1407 : 						COM_ReplaceExtension( compressedfilename, ".ztmp" );

	push	OFFSET $SG132975
	lea	edx, DWORD PTR _compressedfilename$10[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 1408 : 						file = FS_Open( compressedfilename, "rb", false );

	push	0
	push	OFFSET $SG132976
	lea	eax, DWORD PTR _compressedfilename$10[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$6[ebp], eax

; 1409 : 					}

	jmp	SHORT $LN41@Netchan_Tr
$LN40@Netchan_Tr:

; 1410 : 					else file = FS_Open( pbuf->filename, "rb", false );

	push	0
	push	OFFSET $SG132977
	mov	ecx, DWORD PTR _pbuf$8[ebp]
	add	ecx, 65576				; 00010028H
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$6[ebp], eax
$LN41@Netchan_Tr:

; 1411 : 
; 1412 : 					FS_Seek( file, pbuf->foffset, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _pbuf$8[ebp]
	mov	eax, DWORD PTR [edx+65836]
	push	eax
	mov	ecx, DWORD PTR _file$6[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1413 : 					FS_Read( file, filebuffer, pbuf->size );

	mov	edx, DWORD PTR _pbuf$8[ebp]
	mov	eax, DWORD PTR [edx+65840]
	push	eax
	lea	ecx, DWORD PTR _filebuffer$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$6[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1414 : 
; 1415 : 					MSG_WriteBits( &pbuf->frag_message, filebuffer, pbuf->size << 3 );

	mov	eax, DWORD PTR _pbuf$8[ebp]
	mov	ecx, DWORD PTR [eax+65840]
	shl	ecx, 3
	push	ecx
	lea	edx, DWORD PTR _filebuffer$9[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$8[ebp]
	add	eax, 8
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 1416 : 					FS_Close( file );

	mov	ecx, DWORD PTR _file$6[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4
$LN39@Netchan_Tr:

; 1417 : 				}
; 1418 : 
; 1419 : 				// copy frag stuff on top of current buffer
; 1420 : 				MSG_StartWriting( &temp, chan->reliable_buf, sizeof( chan->reliable_buf ), chan->reliable_length, -1 );

	push	-1
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+131240]
	push	eax
	push	131120					; 00020030H
	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 131244				; 000200acH
	push	ecx
	lea	edx, DWORD PTR _temp$1[ebp]
	push	edx
	call	_MSG_StartWriting
	add	esp, 20					; 00000014H

; 1421 : 				MSG_WriteBits( &temp, MSG_GetData( &pbuf->frag_message ), MSG_GetNumBitsWritten( &pbuf->frag_message ));

	mov	eax, DWORD PTR _pbuf$8[ebp]
	add	eax, 8
	push	eax
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pbuf$8[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _temp$1[ebp]
	push	edx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 1422 : 				chan->reliable_length += MSG_GetNumBitsWritten( &pbuf->frag_message );

	mov	eax, DWORD PTR _pbuf$8[ebp]
	add	eax, 8
	push	eax
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	ecx, DWORD PTR _chan$[ebp]
	add	eax, DWORD PTR [ecx+131240]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+131240], eax

; 1423 : 				chan->frag_length[i] = MSG_GetNumBitsWritten( &pbuf->frag_message );

	mov	eax, DWORD PTR _pbuf$8[ebp]
	add	eax, 8
	push	eax
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx*4+262412], eax

; 1424 : 
; 1425 : 				// unlink pbuf
; 1426 : 				Netchan_UnlinkFragment( pbuf, &chan->fragbufs[i] );	

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+262388]
	push	edx
	mov	eax, DWORD PTR _pbuf$8[ebp]
	push	eax
	call	_Netchan_UnlinkFragment
	add	esp, 8

; 1427 : 
; 1428 : 				chan->reliable_fragment[i] = 1;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx*4+262372], 1

; 1429 : 
; 1430 : 				// offset the rest of the starting positions
; 1431 : 				for( j = i + 1; j < MAX_STREAMS; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN16@Netchan_Tr
$LN14@Netchan_Tr:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN16@Netchan_Tr:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN15@Netchan_Tr

; 1432 : 					chan->frag_startpos[j] += chan->frag_length[i];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+262404]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+262412]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+edx*4+262404], ecx
	jmp	SHORT $LN14@Netchan_Tr
$LN15@Netchan_Tr:

; 1433 : 			}
; 1434 : 		}

	jmp	$LN11@Netchan_Tr
$LN12@Netchan_Tr:

; 1435 : 	}
; 1436 : 
; 1437 : 	MSG_Init( &send, "NetSend", send_buf, sizeof( send_buf ));

	push	-1
	push	131120					; 00020030H
	lea	ecx, DWORD PTR _send_buf$[ebp]
	push	ecx
	push	OFFSET $SG132978
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1438 : 
; 1439 : 	// prepare the packet header
; 1440 : 	w1 = chan->outgoing_sequence | (send_reliable << 31);

	mov	eax, DWORD PTR _send_reliable$[ebp]
	shl	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _chan$[ebp]
	or	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR _w1$[ebp], eax

; 1441 : 	w2 = chan->incoming_sequence | (chan->incoming_reliable_sequence << 31);

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+76]
	shl	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _chan$[ebp]
	or	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR _w2$[ebp], eax

; 1442 : 
; 1443 : 	send_reliable_fragment = false;

	mov	DWORD PTR _send_reliable_fragment$[ebp], 0

; 1444 : 
; 1445 : 	for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@Netchan_Tr
$LN17@Netchan_Tr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN19@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN18@Netchan_Tr

; 1446 : 	{
; 1447 : 		if( chan->reliable_fragment[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+eax*4+262372], 0
	je	SHORT $LN42@Netchan_Tr

; 1448 : 		{
; 1449 : 			send_reliable_fragment = true;

	mov	DWORD PTR _send_reliable_fragment$[ebp], 1

; 1450 : 			break;

	jmp	SHORT $LN18@Netchan_Tr
$LN42@Netchan_Tr:

; 1451 : 		}
; 1452 : 	}

	jmp	SHORT $LN17@Netchan_Tr
$LN18@Netchan_Tr:

; 1453 : 
; 1454 : 	if( send_reliable && send_reliable_fragment )

	cmp	DWORD PTR _send_reliable$[ebp], 0
	je	SHORT $LN43@Netchan_Tr
	cmp	DWORD PTR _send_reliable_fragment$[ebp], 0
	je	SHORT $LN43@Netchan_Tr

; 1455 : 		SetBits( w1, BIT( 30 ));

	mov	edx, DWORD PTR _w1$[ebp]
	or	edx, 1073741824				; 40000000H
	mov	DWORD PTR _w1$[ebp], edx
$LN43@Netchan_Tr:

; 1456 : 
; 1457 : 	chan->outgoing_sequence++;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+80], ecx

; 1458 : 
; 1459 : 	MSG_WriteLong( &send, w1 );

	mov	eax, DWORD PTR _w1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1460 : 	MSG_WriteLong( &send, w2 );

	mov	edx, DWORD PTR _w2$[ebp]
	push	edx
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 1461 : 
; 1462 : 	// send the qport if we are a client
; 1463 : 	if( chan->sock == NS_CLIENT )

	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN44@Netchan_Tr

; 1464 : 	{
; 1465 : 		MSG_WriteWord( &send, Cvar_VariableInteger( "net_qport" ));

	push	OFFSET $SG132982
	call	_Cvar_VariableInteger
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteWord
	add	esp, 8
$LN44@Netchan_Tr:

; 1466 : 	}	
; 1467 : 
; 1468 : 	if( send_reliable && send_reliable_fragment )

	cmp	DWORD PTR _send_reliable$[ebp], 0
	je	$LN21@Netchan_Tr
	cmp	DWORD PTR _send_reliable_fragment$[ebp], 0
	je	$LN21@Netchan_Tr

; 1469 : 	{
; 1470 : 		for( i = 0; i < MAX_STREAMS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@Netchan_Tr
$LN20@Netchan_Tr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN22@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN21@Netchan_Tr

; 1471 : 		{
; 1472 : 			if( chan->reliable_fragment[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx*4+262372], 0
	je	SHORT $LN46@Netchan_Tr

; 1473 : 			{
; 1474 : 				MSG_WriteByte( &send, 1 );

	push	1
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 1475 : 				MSG_WriteLong( &send, chan->reliable_fragid[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+262380]
	push	eax
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1476 : 				MSG_WriteLong( &send, chan->frag_startpos[i] );

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+262404]
	push	ecx
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 1477 : 				MSG_WriteLong( &send, chan->frag_length[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+262412]
	push	edx
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 1478 : 			}

	jmp	SHORT $LN47@Netchan_Tr
$LN46@Netchan_Tr:

; 1479 : 			else 
; 1480 : 			{
; 1481 : 				MSG_WriteByte( &send, 0 );

	push	0
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
$LN47@Netchan_Tr:

; 1482 : 			}
; 1483 : 		}

	jmp	$LN20@Netchan_Tr
$LN21@Netchan_Tr:

; 1484 : 	}
; 1485 : 
; 1486 : 	// copy the reliable message to the packet first
; 1487 : 	if( send_reliable )

	cmp	DWORD PTR _send_reliable$[ebp], 0
	je	SHORT $LN48@Netchan_Tr

; 1488 : 	{
; 1489 : 		MSG_WriteBits( &send, chan->reliable_buf, chan->reliable_length );

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+131240]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 131244				; 000200acH
	push	ecx
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 1490 : 		chan->last_reliable_sequence = chan->outgoing_sequence - 1;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	sub	ecx, 1
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+88], ecx
$LN48@Netchan_Tr:

; 1491 : 	}
; 1492 : 
; 1493 : 	if( MSG_GetNumBitsLeft( &send ) >= length )

	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, DWORD PTR _length$[ebp]
	jl	SHORT $LN49@Netchan_Tr

; 1494 : 		MSG_WriteBits( &send, data, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN50@Netchan_Tr
$LN49@Netchan_Tr:

; 1495 : 	else Con_Printf( S_WARN "Netchan_Transmit: unreliable message overflow\n" );

	push	OFFSET $SG132989
	call	_Con_Printf
	add	esp, 4
$LN50@Netchan_Tr:

; 1496 : 
; 1497 : 	// deal with packets that are too small for some networks
; 1498 : 	if( MSG_GetNumBytesWritten( &send ) < 16 && !NET_IsLocalAddress( chan->remote_address )) // packet too small for some networks

	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	cmp	eax, 16					; 00000010H
	jge	$LN24@Netchan_Tr
	mov	edx, DWORD PTR _chan$[ebp]
	add	edx, 4
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN24@Netchan_Tr

; 1499 : 	{
; 1500 : 		// go ahead and pad a full 16 extra bytes -- this only happens during authentication / signon
; 1501 : 		for( i = MSG_GetNumBytesWritten( &send ); i < 16; i++ )		

	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN25@Netchan_Tr
$LN23@Netchan_Tr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN25@Netchan_Tr:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN24@Netchan_Tr

; 1502 : 		{
; 1503 : 			if( chan->sock == NS_CLIENT )

	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN52@Netchan_Tr

; 1504 : 				MSG_BeginClientCmd( &send, clc_nop );

	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
	jmp	SHORT $LN55@Netchan_Tr
$LN52@Netchan_Tr:

; 1505 : 			else if( chan->sock == NS_SERVER )

	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN54@Netchan_Tr

; 1506 : 				MSG_BeginServerCmd( &send, svc_nop );			

	push	0
	push	1
	push	1
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
	jmp	SHORT $LN55@Netchan_Tr
$LN54@Netchan_Tr:

; 1507 : 			else break;

	jmp	SHORT $LN24@Netchan_Tr
$LN55@Netchan_Tr:

; 1508 : 		}

	jmp	SHORT $LN23@Netchan_Tr
$LN24@Netchan_Tr:

; 1509 : 	}
; 1510 : 
; 1511 : 	statId = chan->flow[FLOW_OUTGOING].current & MASK_LATENT;

	mov	eax, 544				; 00000220H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+263216]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _statId$[ebp], eax

; 1512 : 	chan->flow[FLOW_OUTGOING].stats[statId].size = MSG_GetNumBytesWritten( &send ) + UDP_HEADER_SIZE;

	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, 28					; 0000001cH
	mov	edx, 544				; 00000220H
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+262704]
	mov	edx, DWORD PTR _statId$[ebp]
	shl	edx, 4
	mov	DWORD PTR [ecx+edx], eax

; 1513 : 	chan->flow[FLOW_OUTGOING].stats[statId].time = host.realtime;

	mov	eax, 544				; 00000220H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	lea	eax, DWORD PTR [edx+ecx+262704]
	mov	ecx, DWORD PTR _statId$[ebp]
	shl	ecx, 4
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax+ecx+8], xmm0

; 1514 : 	chan->flow[FLOW_OUTGOING].totalbytes += chan->flow[FLOW_OUTGOING].stats[statId].size;

	mov	edx, 544				; 00000220H
	imul	eax, edx, 0
	mov	ecx, 544				; 00000220H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	lea	edx, DWORD PTR [ecx+edx+262704]
	mov	ecx, DWORD PTR _statId$[ebp]
	shl	ecx, 4
	mov	esi, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [esi+eax+263240]
	add	eax, DWORD PTR [edx+ecx]
	mov	ecx, 544				; 00000220H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+edx+263240], eax

; 1515 : 	chan->flow[FLOW_OUTGOING].current++;

	mov	edx, 544				; 00000220H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax+263216]
	add	edx, 1
	mov	eax, 544				; 00000220H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+ecx+263216], edx

; 1516 : 
; 1517 : 	Netchan_UpdateFlow( chan );

	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	call	_Netchan_UpdateFlow
	add	esp, 4

; 1518 : 
; 1519 : 	chan->total_sended += MSG_GetNumBytesWritten( &send );

	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _chan$[ebp]
	add	eax, DWORD PTR [ecx+263792]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+263792], eax

; 1520 : 
; 1521 : 	// send the datagram
; 1522 : 	if( !CL_IsPlaybackDemo( ))

	call	_CL_IsPlaybackDemo
	test	eax, eax
	jne	SHORT $LN56@Netchan_Tr

; 1523 : 	{
; 1524 : 		NET_SendPacket( chan->sock, MSG_GetNumBytesWritten( &send ), MSG_GetData( &send ), chan->remote_address );

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 4
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN56@Netchan_Tr:

; 1525 : 	}
; 1526 : 
; 1527 : 	if( SV_Active() && sv_lan.value && sv_lan_rate.value > 1000.0 )

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN57@Netchan_Tr
	movss	xmm0, DWORD PTR _sv_lan+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN57@Netchan_Tr
	cvtss2sd xmm0, DWORD PTR _sv_lan_rate+12
	comisd	xmm0, QWORD PTR __real@408f400000000000
	jbe	SHORT $LN57@Netchan_Tr

; 1528 : 		fRate = 1.0f / sv_lan_rate.value;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _sv_lan_rate+12
	movss	DWORD PTR _fRate$[ebp], xmm0
	jmp	SHORT $LN58@Netchan_Tr
$LN57@Netchan_Tr:

; 1529 : 	else fRate = 1.0f / chan->rate;

	mov	edx, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	divsd	xmm0, QWORD PTR [edx+48]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fRate$[ebp], xmm0
$LN58@Netchan_Tr:

; 1530 : 
; 1531 : 	if( chan->cleartime < host.realtime )

	mov	eax, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jbe	SHORT $LN59@Netchan_Tr

; 1532 : 		chan->cleartime = host.realtime;

	mov	ecx, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [ecx+56], xmm0
$LN59@Netchan_Tr:

; 1533 : 
; 1534 : 	chan->cleartime += ( MSG_GetNumBytesWritten( &send ) + UDP_HEADER_SIZE ) * fRate;

	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, 28					; 0000001cH
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _fRate$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _chan$[ebp]
	addsd	xmm0, QWORD PTR [eax+56]
	mov	ecx, DWORD PTR _chan$[ebp]
	movsd	QWORD PTR [ecx+56], xmm0

; 1535 : 
; 1536 : 	if( net_showpackets->value && net_showpackets->value != 2.0f )

	mov	edx, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN60@Netchan_Tr
	mov	eax, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN60@Netchan_Tr

; 1537 : 	{
; 1538 : 		Con_Printf( " %s --> sz=%i seq=%i ack=%i rel=%i tm=%f\n"

	cmp	DWORD PTR _send_reliable$[ebp], 0
	je	SHORT $LN64@Netchan_Tr
	mov	DWORD PTR tv502[ebp], 1
	jmp	SHORT $LN65@Netchan_Tr
$LN64@Netchan_Tr:
	mov	DWORD PTR tv502[ebp], 0
$LN65@Netchan_Tr:
	cvtsd2ss xmm0, QWORD PTR _host+1440
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR tv502[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+64]
	and	eax, 63					; 0000003fH
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	sub	edx, 1
	and	edx, 63					; 0000003fH
	push	edx
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ns_strings[edx*4]
	push	eax
	push	OFFSET $SG133000
	call	_Con_Printf
	add	esp, 32					; 00000020H
$LN60@Netchan_Tr:

; 1539 : 			, ns_strings[chan->sock]
; 1540 : 			, MSG_GetNumBytesWritten( &send )
; 1541 : 			, ( chan->outgoing_sequence - 1 ) & 63
; 1542 : 			, chan->incoming_sequence & 63
; 1543 : 			, send_reliable ? 1 : 0
; 1544 : 			, (float)host.realtime );
; 1545 : 	}
; 1546 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_TransmitBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_chan$ = 8						; size = 4
_lengthInBytes$ = 12					; size = 4
_data$ = 16						; size = 4
_Netchan_Transmit PROC

; 1559 : {

	push	ebp
	mov	ebp, esp

; 1560 : 	Netchan_TransmitBits( chan, lengthInBytes << 3, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lengthInBytes$[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 1561 : }

	pop	ebp
	ret	0
_Netchan_Transmit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
tv231 = -344						; size = 8
_fileTime$ = -336					; size = 4
_compressedFileTime$ = -332				; size = 4
_firstfragment$ = -328					; size = 4
tv160 = -324						; size = 4
_uncompressed$1 = -320					; size = 4
tv227 = -316						; size = 4
_wait$ = -312						; size = 4
_pos$ = -308						; size = 4
_bCompressed$ = -304					; size = 4
_bufferid$ = -300					; size = 4
_chunksize$ = -296					; size = 4
_compressed$2 = -292					; size = 4
_uCompressedSize$3 = -288				; size = 4
_p$ = -284						; size = 4
_remaining$ = -280					; size = 4
_send$ = -276						; size = 4
_filesize$ = -272					; size = 4
_buf$ = -268						; size = 4
_compressedfilename$ = -264				; size = 260
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_filename$ = 12						; size = 4
_Netchan_CreateFileFragments PROC

; 816  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 817  : 	int		chunksize;
; 818  : 	int		send, pos;
; 819  : 	int		remaining;
; 820  : 	int		bufferid = 1;

	mov	DWORD PTR _bufferid$[ebp], 1

; 821  : 	int		filesize = 0;

	mov	DWORD PTR _filesize$[ebp], 0

; 822  : 	char		compressedfilename[MAX_OSPATH];
; 823  : 	int		compressedFileTime;
; 824  : 	int		fileTime;
; 825  : 	qboolean		firstfragment = true;

	mov	DWORD PTR _firstfragment$[ebp], 1

; 826  : 	qboolean		bCompressed = false;

	mov	DWORD PTR _bCompressed$[ebp], 0

; 827  : 	fragbufwaiting_t	*wait, *p;
; 828  : 	fragbuf_t		*buf;
; 829  : 	
; 830  : 	if(( filesize = FS_FileSize( filename, false )) <= 0 )

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _filesize$[ebp], eax
	cmp	DWORD PTR _filesize$[ebp], 0
	jg	SHORT $LN6@Netchan_Cr

; 831  : 	{
; 832  : 		Con_Printf( S_WARN "Unable to open %s for transfer\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG132744
	call	_Con_Printf
	add	esp, 8

; 833  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Netchan_Cr
$LN6@Netchan_Cr:

; 834  : 	}
; 835  : 
; 836  : 	if( chan->pfnBlockSize != NULL )

	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN7@Netchan_Cr

; 837  : 		chunksize = chan->pfnBlockSize( chan->client );

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+96]
	call	eax
	add	esp, 4
	mov	DWORD PTR _chunksize$[ebp], eax
	jmp	SHORT $LN8@Netchan_Cr
$LN7@Netchan_Cr:

; 838  : 	else chunksize = FRAGMENT_MAX_SIZE; // fallback

	mov	DWORD PTR _chunksize$[ebp], 64000	; 0000fa00H
$LN8@Netchan_Cr:

; 839  : 
; 840  : 	Q_strncpy( compressedfilename, filename, sizeof( compressedfilename ));

	push	260					; 00000104H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _compressedfilename$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 841  : 	COM_ReplaceExtension( compressedfilename, ".ztmp" );

	push	OFFSET $SG132747
	lea	eax, DWORD PTR _compressedfilename$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 842  : 	compressedFileTime = FS_FileTime( compressedfilename, false );

	push	0
	lea	ecx, DWORD PTR _compressedfilename$[ebp]
	push	ecx
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _compressedFileTime$[ebp], eax

; 843  : 	fileTime = FS_FileTime( filename, false );

	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _fileTime$[ebp], eax

; 844  : 
; 845  : 	if( compressedFileTime >= fileTime )

	mov	eax, DWORD PTR _compressedFileTime$[ebp]
	cmp	eax, DWORD PTR _fileTime$[ebp]
	jl	SHORT $LN9@Netchan_Cr

; 846  : 	{
; 847  : 		// if compressed file already created and newer than source
; 848  : 		if( FS_FileSize( compressedfilename, false ) != -1 )

	push	0
	lea	ecx, DWORD PTR _compressedfilename$[ebp]
	push	ecx
	call	_FS_FileSize
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN11@Netchan_Cr

; 849  : 			bCompressed = true;

	mov	DWORD PTR _bCompressed$[ebp], 1
$LN11@Netchan_Cr:

; 850  : 	}

	jmp	$LN10@Netchan_Cr
$LN9@Netchan_Cr:

; 851  : 	else
; 852  : 	{
; 853  : 		uint	uCompressedSize;
; 854  : 		byte	*uncompressed;
; 855  : 		byte	*compressed;
; 856  : 
; 857  : 		uncompressed = FS_LoadFile( filename, &filesize, false );

	push	0
	lea	edx, DWORD PTR _filesize$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _uncompressed$1[ebp], eax

; 858  : 		compressed = LZSS_Compress( uncompressed, filesize, &uCompressedSize );

	lea	ecx, DWORD PTR _uCompressedSize$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _filesize$[ebp]
	push	edx
	mov	eax, DWORD PTR _uncompressed$1[ebp]
	push	eax
	call	_LZSS_Compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _compressed$2[ebp], eax

; 859  : 
; 860  : 		if( compressed )

	cmp	DWORD PTR _compressed$2[ebp], 0
	je	$LN12@Netchan_Cr

; 861  : 		{
; 862  : 			Con_DPrintf( "compressed file %s (%s -> %s)\n", filename, Q_memprint( filesize ), Q_memprint( uCompressedSize ));

	push	2
	mov	ecx, DWORD PTR _uCompressedSize$3[ebp]
	mov	DWORD PTR tv227[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv227[ebp]
	mov	edx, DWORD PTR tv227[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv231[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv231[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	2
	cvtsi2ss xmm0, DWORD PTR _filesize$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG132752
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 863  : 			FS_WriteFile( compressedfilename, compressed, uCompressedSize );

	mov	ecx, DWORD PTR _uCompressedSize$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _compressed$2[ebp]
	push	edx
	lea	eax, DWORD PTR _compressedfilename$[ebp]
	push	eax
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 864  : 			filesize = uCompressedSize;

	mov	ecx, DWORD PTR _uCompressedSize$3[ebp]
	mov	DWORD PTR _filesize$[ebp], ecx

; 865  : 			bCompressed = true;

	mov	DWORD PTR _bCompressed$[ebp], 1

; 866  : 			free( compressed );

	mov	edx, DWORD PTR _compressed$2[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN12@Netchan_Cr:

; 867  : 		}
; 868  : 		Mem_Free( uncompressed );

	push	868					; 00000364H
	push	OFFSET $SG132753
	mov	eax, DWORD PTR _uncompressed$1[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN10@Netchan_Cr:

; 869  : 	}
; 870  : 
; 871  : 	wait = (fragbufwaiting_t *)Mem_Calloc( net_mempool, sizeof( fragbufwaiting_t ));

	push	871					; 00000367H
	push	OFFSET $SG132754
	push	1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _net_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _wait$[ebp], eax

; 872  : 	remaining = filesize;

	mov	edx, DWORD PTR _filesize$[ebp]
	mov	DWORD PTR _remaining$[ebp], edx

; 873  : 	pos = 0;

	mov	DWORD PTR _pos$[ebp], 0
$LN2@Netchan_Cr:

; 874  : 
; 875  : 	while( remaining > 0 )

	cmp	DWORD PTR _remaining$[ebp], 0
	jle	$LN3@Netchan_Cr

; 876  : 	{
; 877  : 		send = Q_min( remaining, chunksize );

	mov	eax, DWORD PTR _remaining$[ebp]
	cmp	eax, DWORD PTR _chunksize$[ebp]
	jge	SHORT $LN17@Netchan_Cr
	mov	ecx, DWORD PTR _remaining$[ebp]
	mov	DWORD PTR tv160[ebp], ecx
	jmp	SHORT $LN18@Netchan_Cr
$LN17@Netchan_Cr:
	mov	edx, DWORD PTR _chunksize$[ebp]
	mov	DWORD PTR tv160[ebp], edx
$LN18@Netchan_Cr:
	mov	eax, DWORD PTR tv160[ebp]
	mov	DWORD PTR _send$[ebp], eax

; 878  : 
; 879  : 		buf = Netchan_AllocFragbuf();

	call	_Netchan_AllocFragbuf
	mov	DWORD PTR _buf$[ebp], eax

; 880  : 		buf->bufferid = bufferid++;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _bufferid$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _bufferid$[ebp]
	add	eax, 1
	mov	DWORD PTR _bufferid$[ebp], eax

; 881  : 
; 882  : 		// copy in data
; 883  : 		MSG_Clear( &buf->frag_message );

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_Clear
	add	esp, 4

; 884  : 
; 885  : 		if( firstfragment )

	cmp	DWORD PTR _firstfragment$[ebp], 0
	je	SHORT $LN13@Netchan_Cr

; 886  : 		{
; 887  : 			// Write filename
; 888  : 			MSG_WriteString( &buf->frag_message, filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, 8
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 889  : 
; 890  : 			// Send a bit less on first package
; 891  : 			send -= MSG_GetNumBytesWritten( &buf->frag_message );

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	edx, DWORD PTR _send$[ebp]
	sub	edx, eax
	mov	DWORD PTR _send$[ebp], edx

; 892  : 
; 893  : 			firstfragment = false;

	mov	DWORD PTR _firstfragment$[ebp], 0
$LN13@Netchan_Cr:

; 894  : 		}
; 895  : 
; 896  : 		buf->isfile = true;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+65564], 1

; 897  : 		buf->size = send;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _send$[ebp]
	mov	DWORD PTR [ecx+65840], edx

; 898  : 		buf->foffset = pos;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax+65836], ecx

; 899  : 		buf->iscompressed = bCompressed;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _bCompressed$[ebp]
	mov	DWORD PTR [edx+65572], eax

; 900  : 		Q_strncpy( buf->filename, filename, sizeof( buf->filename ));

	push	260					; 00000104H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, 65576				; 00010028H
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 901  : 
; 902  : 		pos += send;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _send$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 903  : 		remaining -= send;

	mov	ecx, DWORD PTR _remaining$[ebp]
	sub	ecx, DWORD PTR _send$[ebp]
	mov	DWORD PTR _remaining$[ebp], ecx

; 904  : 
; 905  : 		Netchan_AddFragbufToTail( wait, buf );

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _wait$[ebp]
	push	eax
	call	_Netchan_AddFragbufToTail
	add	esp, 8

; 906  : 	}

	jmp	$LN2@Netchan_Cr
$LN3@Netchan_Cr:

; 907  : 
; 908  : 	// now add waiting list item to end of buffer queue
; 909  : 	if( !chan->waitlist[FRAG_FILE_STREAM] )

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx+262364], 0
	jne	SHORT $LN14@Netchan_Cr

; 910  : 	{
; 911  : 		chan->waitlist[FRAG_FILE_STREAM] = wait;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [ecx+eax+262364], edx

; 912  : 	}

	jmp	SHORT $LN15@Netchan_Cr
$LN14@Netchan_Cr:

; 913  : 	else
; 914  : 	{
; 915  : 		p = chan->waitlist[FRAG_FILE_STREAM];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax+262364]
	mov	DWORD PTR _p$[ebp], edx
$LN4@Netchan_Cr:

; 916  : 		while( p->next )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Netchan_Cr

; 917  : 			p = p->next;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN4@Netchan_Cr
$LN5@Netchan_Cr:

; 918  : 		p->next = wait;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@Netchan_Cr:

; 919  : 	}
; 920  : 
; 921  : 	return 1;

	mov	eax, 1
$LN1@Netchan_Cr:

; 922  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CreateFileFragments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_chan$ = 8						; size = 4
_msg$ = 12						; size = 4
_Netchan_CreateFragments PROC

; 639  : {

	push	ebp
	mov	ebp, esp

; 640  : 	// always queue any pending reliable data ahead of the fragmentation buffer
; 641  : 	if( MSG_GetNumBytesWritten( &chan->message ) > 0 )

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN2@Netchan_Cr

; 642  : 	{
; 643  : 		Netchan_CreateFragments_( chan, &chan->message );

	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	call	_Netchan_CreateFragments_
	add	esp, 8

; 644  : 		MSG_Clear( &chan->message );

	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_MSG_Clear
	add	esp, 4
$LN2@Netchan_Cr:

; 645  : 	}
; 646  : 
; 647  : 	Netchan_CreateFragments_( chan, msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	call	_Netchan_CreateFragments_
	add	esp, 8

; 648  : }

	pop	ebp
	ret	0
_Netchan_CreateFragments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_uncompressedSize$1 = -296				; size = 4
_n$ = -292						; size = 4
_uncompressedBuffer$2 = -288				; size = 4
_pos$ = -284						; size = 4
_cursize$3 = -280					; size = 4
_nsize$ = -276						; size = 4
_buffer$ = -272						; size = 4
_p$ = -268						; size = 4
_filename$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_msg$ = 12						; size = 4
_Netchan_CopyFileFragments PROC

; 1020 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1021 : 	char	filename[MAX_OSPATH];
; 1022 : 	int	nsize, pos;
; 1023 : 	byte	*buffer;
; 1024 : 	fragbuf_t	*p, *n;
; 1025 : 
; 1026 : 	if( !chan->incomingready[FRAG_FILE_STREAM] )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+eax+262428], 0
	jne	SHORT $LN6@Netchan_Co

; 1027 : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Co
$LN6@Netchan_Co:

; 1028 : 
; 1029 : 	if( !chan->incomingbufs[FRAG_FILE_STREAM] )

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [eax+edx+262420], 0
	jne	SHORT $LN7@Netchan_Co

; 1030 : 	{
; 1031 : 		chan->incomingready[FRAG_FILE_STREAM] = false;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx+262428], 0

; 1032 : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Co
$LN7@Netchan_Co:

; 1033 : 	}
; 1034 : 
; 1035 : 	p = chan->incomingbufs[FRAG_FILE_STREAM];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax+262420]
	mov	DWORD PTR _p$[ebp], edx

; 1036 : 
; 1037 : 	MSG_Init( msg, "NetMessage", net_message_buffer, sizeof( net_message_buffer ));

	push	-1
	push	131120					; 00020030H
	push	OFFSET _net_message_buffer
	push	OFFSET $SG132814
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1038 : 
; 1039 : 	// copy in first chunk so we can get filename out
; 1040 : 	MSG_WriteBytes( msg, MSG_GetData( &p->frag_message ), MSG_GetNumBytesWritten( &p->frag_message ));

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1041 : 	MSG_Clear( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_Clear
	add	esp, 4

; 1042 : 
; 1043 : 	Q_strncpy( filename, MSG_ReadString( msg ), sizeof( filename ));

	push	260					; 00000104H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1044 : 
; 1045 : 	if( !COM_CheckString( filename ))

	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@Netchan_Co

; 1046 : 	{
; 1047 : 		Con_Printf( S_ERROR "file fragment received with no filename\nFlushing input queue\n" );

	push	OFFSET $SG132817
	call	_Con_Printf
	add	esp, 4

; 1048 : 		Netchan_FlushIncoming( chan, FRAG_FILE_STREAM );

	push	1
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	call	_Netchan_FlushIncoming
	add	esp, 8

; 1049 : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Co

; 1050 : 	}

	jmp	SHORT $LN9@Netchan_Co
$LN8@Netchan_Co:

; 1051 : 	else if( filename[0] != '!' && !COM_IsSafeFileToDownload( filename ))

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _filename$[ebp+ecx]
	cmp	edx, 33					; 00000021H
	je	SHORT $LN9@Netchan_Co
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_IsSafeFileToDownload
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@Netchan_Co

; 1052 : 	{
; 1053 : 		Con_Printf( S_ERROR "file fragment received with bad path, ignoring\n" );

	push	OFFSET $SG132819
	call	_Con_Printf
	add	esp, 4

; 1054 : 		Netchan_FlushIncoming( chan, FRAG_FILE_STREAM );

	push	1
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	call	_Netchan_FlushIncoming
	add	esp, 8

; 1055 : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Co
$LN9@Netchan_Co:

; 1056 : 	}
; 1057 : 
; 1058 : 	Q_strncpy( chan->incomingfilename, filename, sizeof( chan->incomingfilename ));

	push	260					; 00000104H
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 262436				; 00040124H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1059 : 
; 1060 : 	if( filename[0] != '!' && FS_FileExists( filename, false ))

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _filename$[ebp+edx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN11@Netchan_Co
	push	0
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@Netchan_Co

; 1061 : 	{
; 1062 : 		Con_Printf( S_ERROR "can't download %s, already exists\n", filename );

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG132821
	call	_Con_Printf
	add	esp, 8

; 1063 : 		Netchan_FlushIncoming( chan, FRAG_FILE_STREAM );

	push	1
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_FlushIncoming
	add	esp, 8

; 1064 : 		return true;

	mov	eax, 1
	jmp	$LN1@Netchan_Co
$LN11@Netchan_Co:

; 1065 : 	}
; 1066 : 
; 1067 : 	// create file from buffers
; 1068 : 	nsize = 0;

	mov	DWORD PTR _nsize$[ebp], 0
$LN2@Netchan_Co:

; 1069 : 	while ( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Netchan_Co

; 1070 : 	{
; 1071 : 		nsize += MSG_GetNumBytesWritten( &p->frag_message ); // Size will include a bit of slop, oh well

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, DWORD PTR _nsize$[ebp]
	mov	DWORD PTR _nsize$[ebp], eax

; 1072 : 		if( p == chan->incomingbufs[FRAG_FILE_STREAM] )

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+262420]
	jne	SHORT $LN12@Netchan_Co

; 1073 : 			nsize -= MSG_GetNumBytesRead( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _nsize$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _nsize$[ebp], ecx
$LN12@Netchan_Co:

; 1074 : 		p = p->next;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _p$[ebp], eax

; 1075 : 	}

	jmp	SHORT $LN2@Netchan_Co
$LN3@Netchan_Co:

; 1076 : 
; 1077 : 	buffer = Mem_Calloc( net_mempool, nsize + 1 );

	push	1077					; 00000435H
	push	OFFSET $SG132823
	push	1
	mov	ecx, DWORD PTR _nsize$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _net_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buffer$[ebp], eax

; 1078 : 	p = chan->incomingbufs[FRAG_FILE_STREAM];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+eax+262420]
	mov	DWORD PTR _p$[ebp], edx

; 1079 : 	pos = 0;

	mov	DWORD PTR _pos$[ebp], 0
$LN4@Netchan_Co:

; 1080 : 
; 1081 : 	while( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN5@Netchan_Co

; 1082 : 	{
; 1083 : 		int	cursize;
; 1084 : 
; 1085 : 		n = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n$[ebp], ecx

; 1086 : 		
; 1087 : 		cursize = MSG_GetNumBytesWritten( &p->frag_message );

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _cursize$3[ebp], eax

; 1088 : 
; 1089 : 		// first message has the file name, don't write that into the data stream,
; 1090 : 		// just write the rest of the actual data
; 1091 : 		if( p == chan->incomingbufs[FRAG_FILE_STREAM] ) 

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+262420]
	jne	SHORT $LN13@Netchan_Co

; 1092 : 		{
; 1093 : 			// copy it in
; 1094 : 			cursize -= MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _cursize$3[ebp]
	sub	ecx, eax
	mov	DWORD PTR _cursize$3[ebp], ecx

; 1095 : 			memcpy( &buffer[pos], &p->frag_message.pData[MSG_GetNumBytesRead( msg )], cursize );

	mov	edx, DWORD PTR _cursize$3[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1096 : 		}

	jmp	SHORT $LN14@Netchan_Co
$LN13@Netchan_Co:

; 1097 : 		else
; 1098 : 		{
; 1099 : 			memcpy( &buffer[pos], p->frag_message.pData, cursize );

	mov	ecx, DWORD PTR _cursize$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Netchan_Co:

; 1100 : 		}
; 1101 : 
; 1102 : 		pos += cursize;

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR _cursize$3[ebp]
	mov	DWORD PTR _pos$[ebp], edx

; 1103 : 		Mem_Free( p );

	push	1103					; 0000044fH
	push	OFFSET $SG132826
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1104 : 		p = n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 1105 : 	}

	jmp	$LN4@Netchan_Co
$LN5@Netchan_Co:

; 1106 : 
; 1107 : 	if( LZSS_IsCompressed( buffer ))

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_LZSS_IsCompressed
	add	esp, 4
	test	eax, eax
	je	$LN15@Netchan_Co

; 1108 : 	{
; 1109 : 		uint	uncompressedSize = LZSS_GetActualSize( buffer ) + 1;

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_LZSS_GetActualSize
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _uncompressedSize$1[ebp], eax

; 1110 : 		byte	*uncompressedBuffer = Mem_Calloc( net_mempool, uncompressedSize );

	push	1110					; 00000456H
	push	OFFSET $SG132828
	push	1
	mov	ecx, DWORD PTR _uncompressedSize$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _net_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _uncompressedBuffer$2[ebp], eax

; 1111 : 
; 1112 : 		nsize = LZSS_Decompress( buffer, uncompressedBuffer );

	mov	eax, DWORD PTR _uncompressedBuffer$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_LZSS_Decompress
	add	esp, 8
	mov	DWORD PTR _nsize$[ebp], eax

; 1113 : 		Mem_Free( buffer );

	push	1113					; 00000459H
	push	OFFSET $SG132829
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1114 : 		buffer = uncompressedBuffer;

	mov	eax, DWORD PTR _uncompressedBuffer$2[ebp]
	mov	DWORD PTR _buffer$[ebp], eax
$LN15@Netchan_Co:

; 1115 : 	}
; 1116 : 
; 1117 : 	// customization files goes int tempbuffer
; 1118 : 	if( filename[0] == '!' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _filename$[ebp+edx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN16@Netchan_Co

; 1119 : 	{
; 1120 : 		if( chan->tempbuffer )

	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+262696], 0
	je	SHORT $LN18@Netchan_Co

; 1121 : 			Mem_Free( chan->tempbuffer );

	push	1121					; 00000461H
	push	OFFSET $SG132833
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+262696]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN18@Netchan_Co:

; 1122 : 		chan->tempbuffer = buffer;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx+262696], edx

; 1123 : 		chan->tempbuffersize = nsize;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _nsize$[ebp]
	mov	DWORD PTR [eax+262700], ecx

; 1124 : 	}

	jmp	SHORT $LN17@Netchan_Co
$LN16@Netchan_Co:

; 1125 : 	else
; 1126 : 	{
; 1127 : 		// g-cont. it's will be stored downloaded files directly into game folder
; 1128 : 		FS_WriteFile( filename, buffer, nsize );

	mov	edx, DWORD PTR _nsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 1129 : 		Mem_Free( buffer );

	push	1129					; 00000469H
	push	OFFSET $SG132834
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN17@Netchan_Co:

; 1130 : 	}
; 1131 : 
; 1132 : 	// clear remnants
; 1133 : 	MSG_Clear( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 1134 : 
; 1135 : 	chan->incomingbufs[FRAG_FILE_STREAM] = NULL;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx+262420], 0

; 1136 : 	chan->incomingready[FRAG_FILE_STREAM] = false;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+eax+262428], 0

; 1137 : 
; 1138 : 	return true;

	mov	eax, 1
$LN1@Netchan_Co:

; 1139 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CopyFileFragments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_uDecompressedLen$1 = -131140				; size = 4
_n$ = -131136						; size = 4
_size$ = -131132					; size = 4
_p$ = -131128						; size = 4
_buf$2 = -131124					; size = 131120
__$ArrayPad$ = -4					; size = 4
_chan$ = 8						; size = 4
_msg$ = 12						; size = 4
_length$ = 16						; size = 4
_Netchan_CopyNormalFragments PROC

; 955  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131140				; 00020044H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 956  : 	size_t	size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 957  : 	fragbuf_t	*p, *n;
; 958  : 
; 959  : 	if( !chan->incomingready[FRAG_NORMAL_STREAM] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx+262428], 0
	jne	SHORT $LN4@Netchan_Co

; 960  : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Co
$LN4@Netchan_Co:

; 961  : 
; 962  : 	if( !chan->incomingbufs[FRAG_NORMAL_STREAM] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+ecx+262420], 0
	jne	SHORT $LN5@Netchan_Co

; 963  : 	{
; 964  : 		chan->incomingready[FRAG_NORMAL_STREAM] = false;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx+262428], 0

; 965  : 		return false;

	xor	eax, eax
	jmp	$LN1@Netchan_Co
$LN5@Netchan_Co:

; 966  : 	}
; 967  : 
; 968  : 	p = chan->incomingbufs[FRAG_NORMAL_STREAM];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+262420]
	mov	DWORD PTR _p$[ebp], eax

; 969  : 
; 970  : 	MSG_Init( msg, "NetMessage", net_message_buffer, sizeof( net_message_buffer ));

	push	-1
	push	131120					; 00020030H
	push	OFFSET _net_message_buffer
	push	OFFSET $SG132786
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H
$LN2@Netchan_Co:

; 971  : 
; 972  : 	while( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@Netchan_Co

; 973  : 	{
; 974  : 		n = p->next;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _n$[ebp], eax

; 975  : 		
; 976  : 		// copy it in
; 977  : 		MSG_WriteBytes( msg, MSG_GetData( &p->frag_message ), MSG_GetNumBytesWritten( &p->frag_message ));

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 978  : 		size += MSG_GetNumBytesWritten( &p->frag_message );

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 979  : 
; 980  : 		Mem_Free( p );

	push	980					; 000003d4H
	push	OFFSET $SG132787
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 981  : 		p = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 982  : 	}

	jmp	$LN2@Netchan_Co
$LN3@Netchan_Co:

; 983  : 
; 984  : 	if( LZSS_IsCompressed( MSG_GetData( msg )))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	call	_LZSS_IsCompressed
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@Netchan_Co

; 985  : 	{
; 986  : 		uint	uDecompressedLen = LZSS_GetActualSize( MSG_GetData( msg ));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	call	_LZSS_GetActualSize
	add	esp, 4
	mov	DWORD PTR _uDecompressedLen$1[ebp], eax

; 987  : 		byte	buf[NET_MAX_MESSAGE];
; 988  : 
; 989  : 		if( uDecompressedLen <= sizeof( buf ))

	cmp	DWORD PTR _uDecompressedLen$1[ebp], 131120 ; 00020030H
	ja	SHORT $LN7@Netchan_Co

; 990  : 		{
; 991  : 			size = LZSS_Decompress( MSG_GetData( msg ), buf );

	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	call	_LZSS_Decompress
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 992  : 			memcpy( msg->pData, buf, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 993  : 		}

	jmp	SHORT $LN6@Netchan_Co
$LN7@Netchan_Co:

; 994  : 		else
; 995  : 		{
; 996  : 			// g-cont. this should not happens
; 997  : 			Con_Printf( S_ERROR "buffer to small to decompress message\n" );

	push	OFFSET $SG132791
	call	_Con_Printf
	add	esp, 4

; 998  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Netchan_Co
$LN6@Netchan_Co:

; 999  : 		}
; 1000 : 	}
; 1001 : 	
; 1002 : 	chan->incomingbufs[FRAG_NORMAL_STREAM] = NULL;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx+262420], 0

; 1003 : 
; 1004 : 	// reset flag
; 1005 : 	chan->incomingready[FRAG_NORMAL_STREAM] = false;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+ecx+262428], 0

; 1006 : 
; 1007 : 	// tell about message size
; 1008 : 	if( length ) *length = size;

	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Netchan_Co
	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax], ecx
$LN9@Netchan_Co:

; 1009 : 
; 1010 : 	return true;

	mov	eax, 1
$LN1@Netchan_Co:

; 1011 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CopyNormalFragments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
tv196 = -60						; size = 8
_firstfragment$ = -52					; size = 4
tv137 = -48						; size = 4
tv192 = -44						; size = 4
_wait$ = -40						; size = 4
_bufferid$ = -36					; size = 4
_chunksize$ = -32					; size = 4
_p$ = -28						; size = 4
_pos$ = -24						; size = 4
_pbOut$1 = -20						; size = 4
_remaining$ = -16					; size = 4
_send$ = -12						; size = 4
_uCompressedSize$2 = -8					; size = 4
_buf$ = -4						; size = 4
_chan$ = 8						; size = 4
_filename$ = 12						; size = 4
_pbuf$ = 16						; size = 4
_size$ = 20						; size = 4
_Netchan_CreateFileFragmentsFromBuffer PROC

; 727  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 728  : 	int		chunksize;
; 729  : 	int		send, pos;
; 730  : 	int		remaining;
; 731  : 	int		bufferid = 1;

	mov	DWORD PTR _bufferid$[ebp], 1

; 732  : 	qboolean		firstfragment = true;

	mov	DWORD PTR _firstfragment$[ebp], 1

; 733  : 	fragbufwaiting_t	*wait, *p;
; 734  : 	fragbuf_t 	*buf;
; 735  : 
; 736  : 	if( !size ) return;

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN6@Netchan_Cr
	jmp	$LN14@Netchan_Cr
$LN6@Netchan_Cr:

; 737  : 
; 738  : 	if( chan->pfnBlockSize != NULL )

	mov	eax, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN7@Netchan_Cr

; 739  : 		chunksize = chan->pfnBlockSize( chan->client );

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _chunksize$[ebp], eax
	jmp	SHORT $LN8@Netchan_Cr
$LN7@Netchan_Cr:

; 740  : 	else chunksize = FRAGMENT_MAX_SIZE; // fallback

	mov	DWORD PTR _chunksize$[ebp], 64000	; 0000fa00H
$LN8@Netchan_Cr:

; 741  : 
; 742  : 	if( !LZSS_IsCompressed( pbuf ))

	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_LZSS_IsCompressed
	add	esp, 4
	test	eax, eax
	jne	$LN11@Netchan_Cr

; 743  : 	{
; 744  : 		uint	uCompressedSize = 0;

	mov	DWORD PTR _uCompressedSize$2[ebp], 0

; 745  : 		byte	*pbOut = LZSS_Compress( pbuf, size, &uCompressedSize );

	lea	eax, DWORD PTR _uCompressedSize$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_LZSS_Compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pbOut$1[ebp], eax

; 746  : 
; 747  : 		if( pbOut && uCompressedSize > 0 && uCompressedSize < size )

	cmp	DWORD PTR _pbOut$1[ebp], 0
	je	$LN10@Netchan_Cr
	cmp	DWORD PTR _uCompressedSize$2[ebp], 0
	jbe	SHORT $LN10@Netchan_Cr
	mov	eax, DWORD PTR _uCompressedSize$2[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN10@Netchan_Cr

; 748  : 		{
; 749  : 			Con_DPrintf( "Compressing filebuffer (%s -> %s)\n", Q_memprint( size ), Q_memprint( uCompressedSize ));

	push	2
	mov	ecx, DWORD PTR _uCompressedSize$2[ebp]
	mov	DWORD PTR tv192[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv192[ebp]
	mov	edx, DWORD PTR tv192[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv196[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv196[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	2
	cvtsi2ss xmm0, DWORD PTR _size$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG132708
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 750  : 			memcpy( pbuf, pbOut, uCompressedSize );

	mov	eax, DWORD PTR _uCompressedSize$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbOut$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 751  : 			size = uCompressedSize;

	mov	eax, DWORD PTR _uCompressedSize$2[ebp]
	mov	DWORD PTR _size$[ebp], eax
$LN10@Netchan_Cr:

; 752  : 		}
; 753  : 		if( pbOut ) free( pbOut );

	cmp	DWORD PTR _pbOut$1[ebp], 0
	je	SHORT $LN11@Netchan_Cr
	mov	ecx, DWORD PTR _pbOut$1[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN11@Netchan_Cr:

; 754  : 	}
; 755  : 
; 756  : 	wait = (fragbufwaiting_t *)Mem_Calloc( net_mempool, sizeof( fragbufwaiting_t ));

	push	756					; 000002f4H
	push	OFFSET $SG132710
	push	1
	push	12					; 0000000cH
	mov	edx, DWORD PTR _net_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _wait$[ebp], eax

; 757  : 	remaining = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _remaining$[ebp], eax

; 758  : 	pos = 0;

	mov	DWORD PTR _pos$[ebp], 0
$LN2@Netchan_Cr:

; 759  : 
; 760  : 	while( remaining > 0 )

	cmp	DWORD PTR _remaining$[ebp], 0
	jle	$LN3@Netchan_Cr

; 761  : 	{
; 762  : 		send = Q_min( remaining, chunksize );

	mov	ecx, DWORD PTR _remaining$[ebp]
	cmp	ecx, DWORD PTR _chunksize$[ebp]
	jge	SHORT $LN16@Netchan_Cr
	mov	edx, DWORD PTR _remaining$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	jmp	SHORT $LN17@Netchan_Cr
$LN16@Netchan_Cr:
	mov	eax, DWORD PTR _chunksize$[ebp]
	mov	DWORD PTR tv137[ebp], eax
$LN17@Netchan_Cr:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _send$[ebp], ecx

; 763  : 
; 764  : 		buf = Netchan_AllocFragbuf();

	call	_Netchan_AllocFragbuf
	mov	DWORD PTR _buf$[ebp], eax

; 765  : 		buf->bufferid = bufferid++;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _bufferid$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _bufferid$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bufferid$[ebp], ecx

; 766  : 
; 767  : 		// copy in data
; 768  : 		MSG_Clear( &buf->frag_message );

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_Clear
	add	esp, 4

; 769  : 
; 770  : 		if( firstfragment )

	cmp	DWORD PTR _firstfragment$[ebp], 0
	je	SHORT $LN12@Netchan_Cr

; 771  : 		{
; 772  : 			// write filename
; 773  : 			MSG_WriteString( &buf->frag_message, filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 774  : 
; 775  : 			// send a bit less on first package
; 776  : 			send -= MSG_GetNumBytesWritten( &buf->frag_message );

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, 8
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _send$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _send$[ebp], ecx

; 777  : 
; 778  : 			firstfragment = false;

	mov	DWORD PTR _firstfragment$[ebp], 0
$LN12@Netchan_Cr:

; 779  : 		}
; 780  : 
; 781  : 		buf->isbuffer = true;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+65568], 1

; 782  : 		buf->isfile = true;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+65564], 1

; 783  : 		buf->size = send;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR _send$[ebp]
	mov	DWORD PTR [ecx+65840], edx

; 784  : 		buf->foffset = pos;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax+65836], ecx

; 785  : 	
; 786  : 		MSG_WriteBits( &buf->frag_message, pbuf + pos, send << 3 );

	mov	edx, DWORD PTR _send$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	add	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, 8
	push	ecx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 787  : 
; 788  : 		remaining -= send;

	mov	edx, DWORD PTR _remaining$[ebp]
	sub	edx, DWORD PTR _send$[ebp]
	mov	DWORD PTR _remaining$[ebp], edx

; 789  : 		pos += send;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _send$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 790  : 
; 791  : 		Netchan_AddFragbufToTail( wait, buf );

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wait$[ebp]
	push	edx
	call	_Netchan_AddFragbufToTail
	add	esp, 8

; 792  : 	}

	jmp	$LN2@Netchan_Cr
$LN3@Netchan_Cr:

; 793  : 
; 794  : 	// now add waiting list item to end of buffer queue
; 795  : 	if( !chan->waitlist[FRAG_FILE_STREAM] )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [ecx+eax+262364], 0
	jne	SHORT $LN13@Netchan_Cr

; 796  : 	{
; 797  : 		chan->waitlist[FRAG_FILE_STREAM] = wait;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [eax+edx+262364], ecx

; 798  : 	}

	jmp	SHORT $LN14@Netchan_Cr
$LN13@Netchan_Cr:

; 799  : 	else
; 800  : 	{
; 801  : 		p = chan->waitlist[FRAG_FILE_STREAM];

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR [eax+edx+262364]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@Netchan_Cr:

; 802  : 
; 803  : 		while( p->next )

	mov	edx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN5@Netchan_Cr

; 804  : 			p = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@Netchan_Cr
$LN5@Netchan_Cr:

; 805  : 		p->next = wait;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _wait$[ebp]
	mov	DWORD PTR [edx], eax
$LN14@Netchan_Cr:

; 806  : 	}
; 807  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_CreateFileFragmentsFromBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_chan$ = 12						; size = 4
_adr$ = 16						; size = 20
_qport$ = 36						; size = 4
_client$ = 40						; size = 4
_pfnBlockSize$ = 44					; size = 4
_Netchan_Setup PROC

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  : 	Netchan_Clear( chan );

	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	call	_Netchan_Clear
	add	esp, 4

; 173  : 
; 174  : 	memset( chan, 0, sizeof( *chan ));

	push	263800					; 00040678H
	push	0
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 175  : 	
; 176  : 	chan->sock = sock;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _sock$[ebp]
	mov	DWORD PTR [edx], eax

; 177  : 	chan->remote_address = adr;

	mov	ecx, DWORD PTR _chan$[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx

; 178  : 	chan->last_received = host.realtime;

	mov	eax, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax+32], xmm0

; 179  : 	chan->connect_time = host.realtime;

	mov	ecx, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [ecx+40], xmm0

; 180  : 	chan->incoming_sequence = 0;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+64], 0

; 181  : 	chan->outgoing_sequence = 1;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+80], 1

; 182  : 	chan->rate = DEFAULT_RATE;

	mov	ecx, DWORD PTR _chan$[ebp]
	movsd	xmm0, QWORD PTR __real@40c3878000000000
	movsd	QWORD PTR [ecx+48], xmm0

; 183  : 	chan->qport = qport;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	eax, DWORD PTR _qport$[ebp]
	mov	DWORD PTR [edx+24], eax

; 184  : 	chan->client = client;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR _client$[ebp]
	mov	DWORD PTR [ecx+92], edx

; 185  : 	chan->pfnBlockSize = pfnBlockSize;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _pfnBlockSize$[ebp]
	mov	DWORD PTR [eax+96], ecx

; 186  : 
; 187  : 	MSG_Init( &chan->message, "NetData", chan->message_buf, sizeof( chan->message_buf ));

	push	-1
	push	131120					; 00020030H
	mov	edx, DWORD PTR _chan$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	push	OFFSET $SG132439
	mov	eax, DWORD PTR _chan$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 188  : }

	pop	ebp
	ret	0
_Netchan_Setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_Netchan_Shutdown PROC

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  : 	Mem_FreePool( &net_mempool );

	push	130					; 00000082H
	push	OFFSET $SG132406
	push	OFFSET _net_mempool
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 131  : }

	pop	ebp
	ret	0
_Netchan_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_chan.c
_TEXT	SEGMENT
_port$ = -4						; size = 4
_Netchan_Init PROC

; 111  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 112  : 	int	port;
; 113  : 
; 114  : 	// pick a port value that should be nice and random
; 115  : 	port = COM_RandomLong( 1, 65535 );

	push	65535					; 0000ffffH
	push	1
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _port$[ebp], eax

; 116  : 
; 117  : 	net_showpackets = Cvar_Get ("net_showpackets", "0", 0, "show network packets" );

	push	OFFSET $SG132387
	push	0
	push	OFFSET $SG132388
	push	OFFSET $SG132389
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_showpackets, eax

; 118  : 	net_chokeloopback = Cvar_Get( "net_chokeloop", "0", 0, "apply bandwidth choke to loopback packets" );

	push	OFFSET $SG132390
	push	0
	push	OFFSET $SG132391
	push	OFFSET $SG132392
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_chokeloopback, eax

; 119  : 	net_showdrop = Cvar_Get( "net_showdrop", "0", 0, "show packets that are dropped" );

	push	OFFSET $SG132393
	push	0
	push	OFFSET $SG132394
	push	OFFSET $SG132395
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_showdrop, eax

; 120  : 	net_speeds = Cvar_Get( "net_speeds", "0", FCVAR_ARCHIVE, "show network packets" );

	push	OFFSET $SG132396
	push	1
	push	OFFSET $SG132397
	push	OFFSET $SG132398
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_speeds, eax

; 121  : 	net_qport = Cvar_Get( "net_qport", va( "%i", port ), FCVAR_READ_ONLY, "current quake netport" );

	push	OFFSET $SG132399
	push	131072					; 00020000H
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET $SG132400
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG132401
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_qport, eax

; 122  : 
; 123  : 	net_mempool = Mem_AllocPool( "Network Pool" );

	push	123					; 0000007bH
	push	OFFSET $SG132402
	push	OFFSET $SG132403
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _net_mempool, eax

; 124  : 
; 125  : 	MSG_InitMasks();	// initialize bit-masks

	call	_MSG_InitMasks

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Netchan_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 106  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetMaxBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetMaxBytes PROC					; COMDAT

; 103  : _inline int MSG_GetMaxBytes( sizebuf_t *sb ) { return sb->nDataBits >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetMaxBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 101  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
