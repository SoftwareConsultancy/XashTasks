; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

EXTRN	_Sound_LoadWAV:PROC
EXTRN	_Sound_LoadMPG:PROC
EXTRN	_Stream_OpenWAV:PROC
EXTRN	_Stream_ReadWAV:PROC
EXTRN	_Stream_SetPosWAV:PROC
EXTRN	_Stream_GetPosWAV:PROC
EXTRN	_Stream_FreeWAV:PROC
EXTRN	_Stream_OpenMPG:PROC
EXTRN	_Stream_ReadMPG:PROC
EXTRN	_Stream_SetPosMPG:PROC
EXTRN	_Stream_GetPosMPG:PROC
EXTRN	_Stream_FreeMPG:PROC
_DATA	SEGMENT
$SG129899 DB	'sound/%s%s.%s', 00H
	ORG $+2
$SG129900 DB	'wav', 00H
$SG129901 DB	'%s%s.%s', 00H
$SG129902 DB	'wav', 00H
$SG129903 DB	'sound/%s%s.%s', 00H
	ORG $+2
$SG129904 DB	'mp3', 00H
$SG129905 DB	'%s%s.%s', 00H
$SG129906 DB	'mp3', 00H
$SG129923 DB	'%s%s.%s', 00H
$SG129924 DB	'mp3', 00H
$SG129925 DB	'%s%s.%s', 00H
$SG129926 DB	'wav', 00H
_DATA	ENDS
CONST	SEGMENT
_load_null DD	00H
	DD	00H
	DD	00H
_load_game DD	FLAT:$SG129899
	DD	FLAT:$SG129900
	DD	FLAT:_Sound_LoadWAV
	DD	FLAT:$SG129901
	DD	FLAT:$SG129902
	DD	FLAT:_Sound_LoadWAV
	DD	FLAT:$SG129903
	DD	FLAT:$SG129904
	DD	FLAT:_Sound_LoadMPG
	DD	FLAT:$SG129905
	DD	FLAT:$SG129906
	DD	FLAT:_Sound_LoadMPG
	DD	00H
	DD	00H
	DD	00H
_stream_null DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_stream_game DD	FLAT:$SG129923
	DD	FLAT:$SG129924
	DD	FLAT:_Stream_OpenMPG
	DD	FLAT:_Stream_ReadMPG
	DD	FLAT:_Stream_SetPosMPG
	DD	FLAT:_Stream_GetPosMPG
	DD	FLAT:_Stream_FreeMPG
	DD	FLAT:$SG129925
	DD	FLAT:$SG129926
	DD	FLAT:_Stream_OpenWAV
	DD	FLAT:_Stream_ReadWAV
	DD	FLAT:_Stream_SetPosWAV
	DD	FLAT:_Stream_GetPosWAV
	DD	FLAT:_Stream_FreeWAV
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	_Sound_Init
PUBLIC	_Sound_Shutdown
PUBLIC	_Sound_Process
PUBLIC	_Sound_Copy
PUBLIC	_Sound_ConvertToSigned
PUBLIC	_Sound_ResampleInternal
PUBLIC	__real@3f800000
PUBLIC	__real@43800000
EXTRN	_memcpy:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	__Mem_Check:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_host:BYTE
EXTRN	_sound:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
_DATA	SEGMENT
$SG129932 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_utils.c', 00H
	ORG $+1
$SG129933 DB	'SoundLib Pool', 00H
	ORG $+2
$SG129938 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_utils.c', 00H
	ORG $+1
$SG129939 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_utils.c', 00H
	ORG $+1
$SG129945 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_utils.c', 00H
	ORG $+1
$SG130016 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_utils.c', 00H
	ORG $+1
$SG130030 DB	'Sound_Resample: from[%d bit %d kHz] to [%d bit %d kHz]', 0aH
	DB	00H
$SG130048 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_utils.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
_TEXT	SEGMENT
_fracstep$ = -36					; size = 4
_sample2$ = -32						; size = 4
_stepscale$ = -28					; size = 4
_outcount$ = -24					; size = 4
_samplefrac$ = -20					; size = 4
_sample$ = -16						; size = 4
_srcsample$ = -12					; size = 4
_data$ = -8						; size = 4
_i$ = -4						; size = 4
_sc$ = 8						; size = 4
_inrate$ = 12						; size = 4
_inwidth$ = 16						; size = 4
_outrate$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_Sound_ResampleInternal PROC

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 131  : 	float	stepscale;
; 132  : 	int	outcount, srcsample;
; 133  : 	int	i, sample, sample2, samplefrac, fracstep;
; 134  : 	byte	*data;
; 135  : 
; 136  : 	data = sc->buffer;

	mov	eax, DWORD PTR _sc$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _data$[ebp], ecx

; 137  : 	stepscale = (float)inrate / outrate;	// this is usually 0.5, 1, or 2

	cvtsi2ss xmm0, DWORD PTR _inrate$[ebp]
	cvtsi2ss xmm1, DWORD PTR _outrate$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _stepscale$[ebp], xmm0

; 138  : 	outcount = sc->samples / stepscale;

	mov	edx, DWORD PTR _sc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+8]
	divss	xmm0, DWORD PTR _stepscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _outcount$[ebp], eax

; 139  : 	sc->size = outcount * outwidth * sc->channels;

	mov	ecx, DWORD PTR _outcount$[ebp]
	imul	ecx, DWORD PTR _outwidth$[ebp]
	mov	edx, DWORD PTR _sc$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	edx, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 140  : 
; 141  : 	sound.tempbuffer = (byte *)Mem_Realloc( host.soundpool, sound.tempbuffer, sc->size );

	push	141					; 0000008dH
	push	OFFSET $SG130016
	push	1
	mov	eax, DWORD PTR _sc$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _sound+44
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _sound+44, eax

; 142  : 
; 143  : 	sc->samples = outcount;

	mov	ecx, DWORD PTR _sc$[ebp]
	mov	edx, DWORD PTR _outcount$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 144  : 	if( sc->loopStart != -1 )

	mov	eax, DWORD PTR _sc$[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN8@Sound_Resa

; 145  : 		sc->loopStart = sc->loopStart / stepscale;

	mov	ecx, DWORD PTR _sc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+4]
	divss	xmm0, DWORD PTR _stepscale$[ebp]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN8@Sound_Resa:

; 146  : 
; 147  : 	// resample / decimate to the current source rate
; 148  : 	if( stepscale == 1.0f && inwidth == 1 && outwidth == 1 )

	movss	xmm0, DWORD PTR _stepscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@Sound_Resa
	cmp	DWORD PTR _inwidth$[ebp], 1
	jne	SHORT $LN9@Sound_Resa
	cmp	DWORD PTR _outwidth$[ebp], 1
	jne	SHORT $LN9@Sound_Resa

; 149  : 	{
; 150  : 		Sound_ConvertToSigned( data, sc->channels, outcount );

	mov	ecx, DWORD PTR _outcount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sc$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_Sound_ConvertToSigned
	add	esp, 12					; 0000000cH

; 151  : 	}

	jmp	$LN10@Sound_Resa
$LN9@Sound_Resa:

; 152  : 	else
; 153  : 	{
; 154  : 		// general case
; 155  : 		samplefrac = 0;

	mov	DWORD PTR _samplefrac$[ebp], 0

; 156  : 		fracstep = stepscale * 256;

	movss	xmm0, DWORD PTR _stepscale$[ebp]
	mulss	xmm0, DWORD PTR __real@43800000
	cvttss2si edx, xmm0
	mov	DWORD PTR _fracstep$[ebp], edx

; 157  : 
; 158  : 		if( sc->channels == 2 )

	mov	eax, DWORD PTR _sc$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	cmp	ecx, 2
	jne	$LN11@Sound_Resa

; 159  : 		{
; 160  : 			for( i = 0; i < outcount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Sound_Resa
$LN2@Sound_Resa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Sound_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outcount$[ebp]
	jge	$LN3@Sound_Resa

; 161  : 			{
; 162  : 				srcsample = samplefrac >> 8;

	mov	ecx, DWORD PTR _samplefrac$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _srcsample$[ebp], ecx

; 163  : 				samplefrac += fracstep;

	mov	edx, DWORD PTR _samplefrac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], edx

; 164  : 
; 165  : 				if( inwidth == 2 )

	cmp	DWORD PTR _inwidth$[ebp], 2
	jne	SHORT $LN13@Sound_Resa

; 166  : 				{
; 167  : 					sample = ((short *)data)[srcsample*2+0];

	mov	eax, DWORD PTR _srcsample$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _sample$[ebp], edx

; 168  : 					sample2 = ((short *)data)[srcsample*2+1];

	mov	eax, DWORD PTR _srcsample$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+2]
	mov	DWORD PTR _sample2$[ebp], edx

; 169  : 				}

	jmp	SHORT $LN14@Sound_Resa
$LN13@Sound_Resa:

; 170  : 				else
; 171  : 				{
; 172  : 					sample = (int)((char)(data[srcsample*2+0])) << 8;

	mov	eax, DWORD PTR _srcsample$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	edx, BYTE PTR [ecx+eax*2]
	shl	edx, 8
	mov	DWORD PTR _sample$[ebp], edx

; 173  : 					sample2 = (int)((char)(data[srcsample*2+1])) << 8;

	mov	eax, DWORD PTR _srcsample$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	edx, BYTE PTR [ecx+eax*2+1]
	shl	edx, 8
	mov	DWORD PTR _sample2$[ebp], edx
$LN14@Sound_Resa:

; 174  : 				}
; 175  : 
; 176  : 				if( outwidth == 2 )

	cmp	DWORD PTR _outwidth$[ebp], 2
	jne	SHORT $LN15@Sound_Resa

; 177  : 				{
; 178  : 					((short *)sound.tempbuffer)[i*2+0] = sample;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _sound+44
	mov	dx, WORD PTR _sample$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 179  : 					((short *)sound.tempbuffer)[i*2+1] = sample2;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _sound+44
	mov	dx, WORD PTR _sample2$[ebp]
	mov	WORD PTR [ecx+eax*2+2], dx

; 180  : 				}

	jmp	SHORT $LN16@Sound_Resa
$LN15@Sound_Resa:

; 181  : 				else
; 182  : 				{
; 183  : 					((signed char *)sound.tempbuffer)[i*2+0] = sample >> 8;

	mov	eax, DWORD PTR _sample$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sound+44
	mov	BYTE PTR [edx+ecx*2], al

; 184  : 					((signed char *)sound.tempbuffer)[i*2+1] = sample2 >> 8;

	mov	eax, DWORD PTR _sample2$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sound+44
	mov	BYTE PTR [edx+ecx*2+1], al
$LN16@Sound_Resa:

; 185  : 				}
; 186  : 			}

	jmp	$LN2@Sound_Resa
$LN3@Sound_Resa:

; 187  : 		}

	jmp	SHORT $LN6@Sound_Resa
$LN11@Sound_Resa:

; 188  : 		else
; 189  : 		{
; 190  : 			for( i = 0; i < outcount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Sound_Resa
$LN5@Sound_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Sound_Resa:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _outcount$[ebp]
	jge	SHORT $LN6@Sound_Resa

; 191  : 			{
; 192  : 				srcsample = samplefrac >> 8;

	mov	edx, DWORD PTR _samplefrac$[ebp]
	sar	edx, 8
	mov	DWORD PTR _srcsample$[ebp], edx

; 193  : 				samplefrac += fracstep;

	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax

; 194  : 
; 195  : 				if( inwidth == 2 ) sample = ((short *)data)[srcsample];

	cmp	DWORD PTR _inwidth$[ebp], 2
	jne	SHORT $LN17@Sound_Resa
	mov	ecx, DWORD PTR _srcsample$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	mov	DWORD PTR _sample$[ebp], eax
	jmp	SHORT $LN18@Sound_Resa
$LN17@Sound_Resa:

; 196  : 				else sample = (int)( (char)(data[srcsample])) << 8;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, DWORD PTR _srcsample$[ebp]
	movsx	edx, BYTE PTR [ecx]
	shl	edx, 8
	mov	DWORD PTR _sample$[ebp], edx
$LN18@Sound_Resa:

; 197  : 
; 198  : 				if( outwidth == 2 ) ((short *)sound.tempbuffer)[i] = sample;

	cmp	DWORD PTR _outwidth$[ebp], 2
	jne	SHORT $LN19@Sound_Resa
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sound+44
	mov	dx, WORD PTR _sample$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	jmp	SHORT $LN20@Sound_Resa
$LN19@Sound_Resa:

; 199  : 				else ((signed char *)sound.tempbuffer)[i] = sample >> 8;

	mov	eax, DWORD PTR _sample$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _sound+44
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
$LN20@Sound_Resa:

; 200  : 			}

	jmp	SHORT $LN5@Sound_Resa
$LN6@Sound_Resa:

; 201  : 		}
; 202  : 
; 203  : 		Con_Reportf( "Sound_Resample: from[%d bit %d kHz] to [%d bit %d kHz]\n", inwidth * 8, inrate, outwidth * 8, outrate );

	mov	edx, DWORD PTR _outrate$[ebp]
	push	edx
	mov	eax, DWORD PTR _outwidth$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _inrate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	shl	edx, 3
	push	edx
	push	OFFSET $SG130030
	call	_Con_Reportf
	add	esp, 20					; 00000014H
$LN10@Sound_Resa:

; 204  : 	}
; 205  : 
; 206  : 	sc->rate = outrate;

	mov	eax, DWORD PTR _sc$[ebp]
	mov	cx, WORD PTR _outrate$[ebp]
	mov	WORD PTR [eax], cx

; 207  : 	sc->width = outwidth;

	mov	edx, DWORD PTR _sc$[ebp]
	mov	al, BYTE PTR _outwidth$[ebp]
	mov	BYTE PTR [edx+2], al

; 208  : 
; 209  : 	return true;

	mov	eax, 1

; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_ResampleInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_data$ = 8						; size = 4
_channels$ = 12						; size = 4
_samples$ = 16						; size = 4
_Sound_ConvertToSigned PROC

; 104  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 105  : 	int	i;
; 106  : 
; 107  : 	if( channels == 2 )

	cmp	DWORD PTR _channels$[ebp], 2
	jne	SHORT $LN8@Sound_Conv

; 108  : 	{
; 109  : 		for( i = 0; i < samples; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Sound_Conv
$LN2@Sound_Conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Sound_Conv:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _samples$[ebp]
	jge	SHORT $LN3@Sound_Conv

; 110  : 		{
; 111  : 			((signed char *)sound.tempbuffer)[i*2+0] = (int)((byte)(data[i*2+0]) - 128);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax+edx*2]
	sub	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sound+44
	mov	BYTE PTR [eax+edx*2], cl

; 112  : 			((signed char *)sound.tempbuffer)[i*2+1] = (int)((byte)(data[i*2+1]) - 128);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx*2+1]
	sub	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sound+44
	mov	BYTE PTR [edx+ecx*2+1], al

; 113  : 		}

	jmp	SHORT $LN2@Sound_Conv
$LN3@Sound_Conv:

; 114  : 	}

	jmp	SHORT $LN1@Sound_Conv
$LN8@Sound_Conv:

; 115  : 	else
; 116  : 	{
; 117  : 		for( i = 0; i < samples; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Sound_Conv
$LN5@Sound_Conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Sound_Conv:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _samples$[ebp]
	jge	SHORT $LN1@Sound_Conv

; 118  : 			((signed char *)sound.tempbuffer)[i] = (int)((unsigned char)(data[i]) - 128);

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _sound+44
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN5@Sound_Conv
$LN1@Sound_Conv:

; 119  : 	}
; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_ConvertToSigned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
_TEXT	SEGMENT
_out$ = -4						; size = 4
_size$ = 8						; size = 4
_Sound_Copy PROC

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 88   : 	byte	*out;
; 89   : 
; 90   : 	out = Mem_Malloc( host.soundpool, size );

	push	90					; 0000005aH
	push	OFFSET $SG129945
	push	0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 91   : 	memcpy( out, sound.tempbuffer, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _sound+44
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 92   : 
; 93   : 	return out; 

	mov	eax, DWORD PTR _out$[ebp]

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_Copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
_TEXT	SEGMENT
_result$ = -8						; size = 4
_snd$ = -4						; size = 4
_wav$ = 8						; size = 4
_rate$ = 12						; size = 4
_width$ = 16						; size = 4
_flags$ = 20						; size = 4
_Sound_Process PROC

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 214  : 	wavdata_t	*snd = *wav;

	mov	eax, DWORD PTR _wav$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _snd$[ebp], ecx

; 215  : 	qboolean	result = true;

	mov	DWORD PTR _result$[ebp], 1

; 216  : 				
; 217  : 	// check for buffers
; 218  : 	if( !snd || !snd->buffer )

	cmp	DWORD PTR _snd$[ebp], 0
	je	SHORT $LN3@Sound_Proc
	mov	edx, DWORD PTR _snd$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN2@Sound_Proc
$LN3@Sound_Proc:

; 219  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Sound_Proc
$LN2@Sound_Proc:

; 220  : 
; 221  : 	if(( flags & SOUND_RESAMPLE ) && ( width > 0 || rate > 0 ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN4@Sound_Proc
	cmp	DWORD PTR _width$[ebp], 0
	jg	SHORT $LN5@Sound_Proc
	cmp	DWORD PTR _rate$[ebp], 0
	jle	SHORT $LN4@Sound_Proc
$LN5@Sound_Proc:

; 222  : 	{
; 223  : 		if( Sound_ResampleInternal( snd, snd->rate, snd->width, rate, width ))

	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rate$[ebp]
	push	edx
	mov	eax, DWORD PTR _snd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _snd$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _snd$[ebp]
	push	ecx
	call	_Sound_ResampleInternal
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN6@Sound_Proc

; 224  : 		{
; 225  : 			Mem_Free( snd->buffer );		// free original image buffer

	push	225					; 000000e1H
	push	OFFSET $SG130048
	mov	edx, DWORD PTR _snd$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 226  : 			snd->buffer = Sound_Copy( snd->size );	// unzone buffer (don't touch image.tempbuffer)

	mov	ecx, DWORD PTR _snd$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_Sound_Copy
	add	esp, 4
	mov	ecx, DWORD PTR _snd$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 227  : 		}

	jmp	SHORT $LN4@Sound_Proc
$LN6@Sound_Proc:

; 228  : 		else
; 229  : 		{
; 230  : 			// not resampled
; 231  : 			result = false;

	mov	DWORD PTR _result$[ebp], 0
$LN4@Sound_Proc:

; 232  : 		}
; 233  : 	}
; 234  : 
; 235  : 	*wav = snd;

	mov	edx, DWORD PTR _wav$[ebp]
	mov	eax, DWORD PTR _snd$[ebp]
	mov	DWORD PTR [edx], eax

; 236  : 
; 237  : 	return false;

	xor	eax, eax
$LN1@Sound_Proc:

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
_TEXT	SEGMENT
_Sound_Shutdown PROC

; 81   : {

	push	ebp
	mov	ebp, esp

; 82   : 	Mem_Check(); // check for leaks

	push	82					; 00000052H
	push	OFFSET $SG129938
	call	__Mem_Check
	add	esp, 8

; 83   : 	Mem_FreePool( &host.soundpool );

	push	83					; 00000053H
	push	OFFSET $SG129939
	push	OFFSET _host+34744
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 84   : }

	pop	ebp
	ret	0
_Sound_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_utils.c
_TEXT	SEGMENT
tv68 = -4						; size = 4
_Sound_Init PROC

; 61   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 62   : 	// init pools
; 63   : 	host.soundpool = Mem_AllocPool( "SoundLib Pool" );

	push	63					; 0000003fH
	push	OFFSET $SG129932
	push	OFFSET $SG129933
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _host+34744, eax

; 64   : 
; 65   : 	// install image formats (can be re-install later by Sound_Setup)
; 66   : 	switch( host.type )

	mov	eax, DWORD PTR _host+164
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN4@Sound_Init
	jmp	SHORT $LN5@Sound_Init
$LN4@Sound_Init:

; 67   : 	{
; 68   : 	case HOST_NORMAL:
; 69   : 		sound.loadformats = load_game;

	mov	DWORD PTR _sound, OFFSET _load_game

; 70   : 		sound.streamformat = stream_game;		

	mov	DWORD PTR _sound+4, OFFSET _stream_game

; 71   : 		break;

	jmp	SHORT $LN2@Sound_Init
$LN5@Sound_Init:

; 72   : 	default:	// all other instances not using soundlib or will be reinstalling later
; 73   : 		sound.loadformats = load_null;

	mov	DWORD PTR _sound, OFFSET _load_null

; 74   : 		sound.streamformat = stream_null;

	mov	DWORD PTR _sound+4, OFFSET _stream_null
$LN2@Sound_Init:

; 75   : 		break;
; 76   : 	}
; 77   : 	sound.tempbuffer = NULL;

	mov	DWORD PTR _sound+44, 0

; 78   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_Init ENDP
_TEXT	ENDS
END
