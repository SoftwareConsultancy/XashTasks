; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Sound_LoadWAV
PUBLIC	_Stream_OpenWAV
PUBLIC	_Stream_ReadWAV
PUBLIC	_Stream_SetPosWAV
PUBLIC	_Stream_GetPosWAV
PUBLIC	_Stream_FreeWAV
PUBLIC	_StreamFindNextChunk
EXTRN	_memcpy:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Eof:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Sound_LoadMPG:PROC
EXTRN	_host:BYTE
EXTRN	_sound:BYTE
_BSS	SEGMENT
_iff_data DD	01H DUP (?)
_iff_dataPtr DD	01H DUP (?)
_iff_end DD	01H DUP (?)
_iff_lastChunk DD 01H DUP (?)
_iff_chunkLen DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG129960 DB	'RIFF', 00H
	ORG $+3
$SG129963 DB	'WAVE', 00H
	ORG $+3
$SG129964 DB	'^1Error:^7 Sound_LoadWAV: %s missing ''RIFF/WAVE'' chunk'
	DB	's', 0aH, 00H
	ORG $+3
$SG129965 DB	'fmt ', 00H
	ORG $+3
$SG129967 DB	'^1Error:^7 Sound_LoadWAV: %s missing ''fmt '' chunk', 0aH
	DB	00H
	ORG $+1
$SG129971 DB	'^1Error:^7 Sound_LoadWAV: %s not a microsoft PCM format', 0aH
	DB	00H
	ORG $+3
$SG129986 DB	'^1Error:^7 Sound_LoadWAV: %s missing ''data'' chunk', 0aH
	DB	00H
	ORG $+1
$SG129973 DB	'^1Error:^7 Sound_LoadWAV: only mono and stereo WAV files'
	DB	' supported (%s)', 0aH, 00H
	ORG $+3
$SG129990 DB	'^1Error:^7 Sound_LoadWAV: %s has a bad loop length', 0aH
	DB	00H
$SG129976 DB	'^1Error:^7 Sound_LoadWAV: only 8 and 16 bit WAV files su'
	DB	'pported (%s)', 0aH, 00H
	ORG $+2
$SG129977 DB	'cue ', 00H
	ORG $+3
$SG129980 DB	'LIST', 00H
	ORG $+3
$SG129983 DB	'mark', 00H
	ORG $+3
$SG129984 DB	'data', 00H
	ORG $+3
$SG129992 DB	'^1Error:^7 Sound_LoadWAV: file with %i samples (%s)', 0aH
	DB	00H
	ORG $+3
$SG129995 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_wav.c', 00H
$SG130019 DB	'rb', 00H
	ORG $+1
$SG129996 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_wav.c', 00H
$SG130022 DB	'RIFF', 00H
	ORG $+3
$SG130023 DB	'^1Error:^7 Stream_OpenWAV: %s missing RIFF chunk', 0aH, 00H
	ORG $+2
$SG130025 DB	'WAVE', 00H
	ORG $+3
$SG130026 DB	'^1Error:^7 Stream_OpenWAV: %s missing WAVE chunk', 0aH, 00H
	ORG $+2
$SG130028 DB	'fmt ', 00H
	ORG $+3
$SG130029 DB	'^1Error:^7 Stream_OpenWAV: %s missing ''fmt '' chunk', 0aH
	DB	00H
$SG130031 DB	'^1Error:^7 Stream_OpenWAV: %s not a microsoft PCM format'
	DB	0aH, 00H
	ORG $+2
$SG130033 DB	'data', 00H
	ORG $+3
$SG130034 DB	'^1Error:^7 Stream_OpenWAV: %s missing ''data'' chunk', 0aH
	DB	00H
$SG130035 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_wav.c', 00H
	ORG $+4
$SG130060 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_wav.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_chunkName$ = -8					; size = 4
_iff_chunk_len$ = -4					; size = 4
_file$ = 8						; size = 4
_name$ = 12						; size = 4
_last_chunk$ = 16					; size = 4
_StreamFindNextChunk PROC

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
$LN2@StreamFind:

; 111  : 	char	chunkName[4];
; 112  : 	int	iff_chunk_len;
; 113  : 
; 114  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@StreamFind

; 115  : 	{
; 116  : 		FS_Seek( file, *last_chunk, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _last_chunk$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 117  : 
; 118  : 		if( FS_Eof( file ))

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@StreamFind

; 119  : 			return false;	// didn't find the chunk

	xor	eax, eax
	jmp	$LN1@StreamFind
$LN4@StreamFind:

; 120  : 
; 121  : 		FS_Seek( file, 4, SEEK_CUR );

	push	1
	push	4
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 122  : 		FS_Read( file, &iff_chunk_len, sizeof( iff_chunk_len ));

	push	4
	lea	eax, DWORD PTR _iff_chunk_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 123  : 		if( iff_chunk_len < 0 )

	cmp	DWORD PTR _iff_chunk_len$[ebp], 0
	jge	SHORT $LN5@StreamFind

; 124  : 			return false;	// didn't find the chunk

	xor	eax, eax
	jmp	SHORT $LN1@StreamFind
$LN5@StreamFind:

; 125  : 
; 126  : 		FS_Seek( file, -8, SEEK_CUR );

	push	1
	push	-8					; fffffff8H
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 127  : 		*last_chunk = FS_Tell( file ) + 8 + (( iff_chunk_len + 1 ) & ~1 );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _iff_chunk_len$[ebp]
	add	ecx, 1
	and	ecx, -2					; fffffffeH
	lea	edx, DWORD PTR [eax+ecx+8]
	mov	eax, DWORD PTR _last_chunk$[ebp]
	mov	DWORD PTR [eax], edx

; 128  : 		FS_Read( file, chunkName, 4 );

	push	4
	lea	ecx, DWORD PTR _chunkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 129  : 
; 130  : 		if( !Q_strncmp( chunkName, name, 4 ))

	push	4
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _chunkName$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@StreamFind

; 131  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@StreamFind
$LN6@StreamFind:

; 132  : 	}

	jmp	$LN2@StreamFind
$LN3@StreamFind:

; 133  : 
; 134  : 	return false;

	xor	eax, eax
$LN1@StreamFind:

; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_StreamFindNextChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FindChunk PROC

; 99   : {

	push	ebp
	mov	ebp, esp

; 100  : 	iff_lastChunk = iff_data;

	mov	eax, DWORD PTR _iff_data
	mov	DWORD PTR _iff_lastChunk, eax

; 101  : 	FindNextChunk( name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_FindNextChunk
	add	esp, 4

; 102  : }

	pop	ebp
	ret	0
_FindChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FindNextChunk PROC

; 64   : {

	push	ebp
	mov	ebp, esp
$LN2@FindNextCh:

; 65   : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN1@FindNextCh

; 66   : 	{
; 67   : 		iff_dataPtr = iff_lastChunk;

	mov	ecx, DWORD PTR _iff_lastChunk
	mov	DWORD PTR _iff_dataPtr, ecx

; 68   : 
; 69   : 		if( iff_dataPtr >= iff_end )

	mov	edx, DWORD PTR _iff_dataPtr
	cmp	edx, DWORD PTR _iff_end
	jb	SHORT $LN4@FindNextCh

; 70   : 		{
; 71   : 			// didn't find the chunk
; 72   : 			iff_dataPtr = NULL;

	mov	DWORD PTR _iff_dataPtr, 0

; 73   : 			return;

	jmp	SHORT $LN1@FindNextCh
$LN4@FindNextCh:

; 74   : 		}
; 75   : 		
; 76   : 		iff_dataPtr += 4;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 4
	mov	DWORD PTR _iff_dataPtr, eax

; 77   : 		iff_chunkLen = GetLittleLong();

	call	_GetLittleLong
	mov	DWORD PTR _iff_chunkLen, eax

; 78   : 
; 79   : 		if( iff_chunkLen < 0 )

	cmp	DWORD PTR _iff_chunkLen, 0
	jge	SHORT $LN5@FindNextCh

; 80   : 		{
; 81   : 			iff_dataPtr = NULL;

	mov	DWORD PTR _iff_dataPtr, 0

; 82   : 			return;

	jmp	SHORT $LN1@FindNextCh
$LN5@FindNextCh:

; 83   : 		}
; 84   : 
; 85   : 		iff_dataPtr -= 8;

	mov	ecx, DWORD PTR _iff_dataPtr
	sub	ecx, 8
	mov	DWORD PTR _iff_dataPtr, ecx

; 86   : 		iff_lastChunk = iff_dataPtr + 8 + ((iff_chunkLen + 1) & ~1);

	mov	edx, DWORD PTR _iff_chunkLen
	add	edx, 1
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _iff_dataPtr
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _iff_lastChunk, ecx

; 87   : 
; 88   : 		if( !Q_strncmp( iff_dataPtr, name, 4 ))

	push	4
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _iff_dataPtr
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FindNextCh

; 89   : 			return;

	jmp	SHORT $LN1@FindNextCh
$LN6@FindNextCh:

; 90   : 	}

	jmp	$LN2@FindNextCh
$LN1@FindNextCh:

; 91   : }

	pop	ebp
	ret	0
_FindNextChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_val$ = -4						; size = 4
_GetLittleLong PROC

; 46   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 47   : 	int	val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 48   : 
; 49   : 	val += (*(iff_dataPtr+0) << 0);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 50   : 	val += (*(iff_dataPtr+1) << 8);

	mov	edx, DWORD PTR _iff_dataPtr
	movzx	eax, BYTE PTR [edx+1]
	shl	eax, 8
	add	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 51   : 	val += (*(iff_dataPtr+2) <<16);

	mov	ecx, DWORD PTR _iff_dataPtr
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 16					; 00000010H
	add	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], edx

; 52   : 	val += (*(iff_dataPtr+3) <<24);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax+3]
	shl	ecx, 24					; 00000018H
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 53   : 	iff_dataPtr += 4;

	mov	edx, DWORD PTR _iff_dataPtr
	add	edx, 4
	mov	DWORD PTR _iff_dataPtr, edx

; 54   : 
; 55   : 	return val;

	mov	eax, DWORD PTR _val$[ebp]

; 56   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GetLittleLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_val$ = -4						; size = 2
_GetLittleShort PROC

; 30   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 31   : 	short	val = 0;

	xor	eax, eax
	mov	WORD PTR _val$[ebp], ax

; 32   : 
; 33   : 	val += (*(iff_dataPtr+0) << 0);

	mov	ecx, DWORD PTR _iff_dataPtr
	movzx	edx, BYTE PTR [ecx]
	movsx	eax, WORD PTR _val$[ebp]
	add	eax, edx
	mov	WORD PTR _val$[ebp], ax

; 34   : 	val += (*(iff_dataPtr+1) << 8);

	mov	ecx, DWORD PTR _iff_dataPtr
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 8
	movsx	eax, WORD PTR _val$[ebp]
	add	eax, edx
	mov	WORD PTR _val$[ebp], ax

; 35   : 	iff_dataPtr += 2;

	mov	ecx, DWORD PTR _iff_dataPtr
	add	ecx, 2
	mov	DWORD PTR _iff_dataPtr, ecx

; 36   : 
; 37   : 	return val;

	mov	ax, WORD PTR _val$[ebp]

; 38   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GetLittleShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_FreeWAV PROC

; 461  : {

	push	ebp
	mov	ebp, esp

; 462  : 	if( stream->file )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Stream_Fre

; 463  : 		FS_Close( stream->file );

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_FS_Close
	add	esp, 4
$LN2@Stream_Fre:

; 464  : 	Mem_Free( stream );

	push	464					; 000001d0H
	push	OFFSET $SG130060
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 465  : }

	pop	ebp
	ret	0
_Stream_FreeWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_GetPosWAV PROC

; 449  : {

	push	ebp
	mov	ebp, esp

; 450  : 	return stream->pos;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [eax+8224]

; 451  : }

	pop	ebp
	ret	0
_Stream_GetPosWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_newpos$ = 12						; size = 4
_Stream_SetPosWAV PROC

; 430  : {

	push	ebp
	mov	ebp, esp

; 431  : 	// NOTE: stream->pos it's real file position without header size
; 432  : 	if( FS_Seek( stream->file, stream->buffsize + newpos, SEEK_SET ) != -1 )

	push	0
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8228]
	add	ecx, DWORD PTR _newpos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	SHORT $LN2@Stream_Set

; 433  : 	{
; 434  : 		stream->pos = newpos;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _newpos$[ebp]
	mov	DWORD PTR [ecx+8224], edx

; 435  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Stream_Set
$LN2@Stream_Set:

; 436  : 	}
; 437  : 
; 438  : 	return false;

	xor	eax, eax
$LN1@Stream_Set:

; 439  : }

	pop	ebp
	ret	0
_Stream_SetPosWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_remaining$ = -4					; size = 4
_stream$ = 8						; size = 4
_bytes$ = 12						; size = 4
_buffer$ = 16						; size = 4
_Stream_ReadWAV PROC

; 407  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 408  : 	int	remaining;
; 409  : 
; 410  : 	if( !stream->file ) return 0;	// invalid file

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@Stream_Rea
	xor	eax, eax
	jmp	SHORT $LN1@Stream_Rea
$LN2@Stream_Rea:

; 411  : 
; 412  : 	remaining = stream->size - stream->pos;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [edx+8224]
	mov	DWORD PTR _remaining$[ebp], eax

; 413  : 	if( remaining <= 0 ) return 0;

	cmp	DWORD PTR _remaining$[ebp], 0
	jg	SHORT $LN3@Stream_Rea
	xor	eax, eax
	jmp	SHORT $LN1@Stream_Rea
$LN3@Stream_Rea:

; 414  : 	if( bytes > remaining ) bytes = remaining;

	mov	ecx, DWORD PTR _bytes$[ebp]
	cmp	ecx, DWORD PTR _remaining$[ebp]
	jle	SHORT $LN4@Stream_Rea
	mov	edx, DWORD PTR _remaining$[ebp]
	mov	DWORD PTR _bytes$[ebp], edx
$LN4@Stream_Rea:

; 415  : 
; 416  : 	stream->pos += bytes;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8224]
	add	ecx, DWORD PTR _bytes$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+8224], ecx

; 417  : 	FS_Read( stream->file, buffer, bytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 418  : 
; 419  : 	return bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
$LN1@Stream_Rea:

; 420  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_ReadWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_iff_data$ = -24					; size = 4
_chunkName$ = -20					; size = 4
_last_chunk$ = -16					; size = 4
_stream$ = -12						; size = 4
_file$ = -8						; size = 4
_t$ = -4						; size = 2
_filename$ = 8						; size = 4
_Stream_OpenWAV PROC

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 312  : 	stream_t	*stream;
; 313  : 	int 	last_chunk = 0;

	mov	DWORD PTR _last_chunk$[ebp], 0

; 314  : 	char	chunkName[4];
; 315  : 	int	iff_data;
; 316  : 	file_t	*file;
; 317  : 	short	t;
; 318  : 
; 319  : 	if( !filename || !*filename )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN3@Stream_Ope
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Stream_Ope
$LN3@Stream_Ope:

; 320  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN2@Stream_Ope:

; 321  : 
; 322  : 	// open
; 323  : 	file = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET $SG130019
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax

; 324  : 	if( !file ) return NULL;	

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN4@Stream_Ope
	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN4@Stream_Ope:

; 325  : 
; 326  : 	// find "RIFF" chunk
; 327  : 	if( !StreamFindNextChunk( file, "RIFF", &last_chunk ))

	lea	eax, DWORD PTR _last_chunk$[ebp]
	push	eax
	push	OFFSET $SG130022
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_StreamFindNextChunk
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@Stream_Ope

; 328  : 	{
; 329  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing RIFF chunk\n", filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG130023
	call	_Con_DPrintf
	add	esp, 8

; 330  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 331  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN5@Stream_Ope:

; 332  : 	}
; 333  : 
; 334  : 	FS_Read( file, chunkName, 4 );

	push	4
	lea	ecx, DWORD PTR _chunkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 335  : 	if( !Q_strncmp( chunkName, "WAVE", 4 ))

	push	4
	push	OFFSET $SG130025
	lea	eax, DWORD PTR _chunkName$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@Stream_Ope

; 336  : 	{
; 337  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing WAVE chunk\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG130026
	call	_Con_DPrintf
	add	esp, 8

; 338  : 		FS_Close( file );

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 339  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN6@Stream_Ope:

; 340  : 	}
; 341  : 
; 342  : 	// get "fmt " chunk
; 343  : 	iff_data = FS_Tell( file ) + 4;

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR _iff_data$[ebp], eax

; 344  : 	last_chunk = iff_data;

	mov	ecx, DWORD PTR _iff_data$[ebp]
	mov	DWORD PTR _last_chunk$[ebp], ecx

; 345  : 	if( !StreamFindNextChunk( file, "fmt ", &last_chunk ))

	lea	edx, DWORD PTR _last_chunk$[ebp]
	push	edx
	push	OFFSET $SG130028
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_StreamFindNextChunk
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@Stream_Ope

; 346  : 	{
; 347  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing 'fmt ' chunk\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG130029
	call	_Con_DPrintf
	add	esp, 8

; 348  : 		FS_Close( file );

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 349  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN7@Stream_Ope:

; 350  : 	}
; 351  : 
; 352  : 	FS_Read( file, chunkName, 4 );

	push	4
	lea	eax, DWORD PTR _chunkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 353  : 
; 354  : 	FS_Read( file, &t, sizeof( t ));

	push	2
	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 355  : 	if( t != 1 )

	movsx	ecx, WORD PTR _t$[ebp]
	cmp	ecx, 1
	je	SHORT $LN8@Stream_Ope

; 356  : 	{
; 357  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s not a microsoft PCM format\n", filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG130031
	call	_Con_DPrintf
	add	esp, 8

; 358  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 359  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN8@Stream_Ope:

; 360  : 	}
; 361  : 
; 362  : 	FS_Read( file, &t, sizeof( t ));

	push	2
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 363  : 	sound.channels = t;

	movsx	eax, WORD PTR _t$[ebp]
	mov	DWORD PTR _sound+20, eax

; 364  : 
; 365  : 	FS_Read( file, &sound.rate, sizeof( int ));

	push	4
	push	OFFSET _sound+12
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 366  : 
; 367  : 	FS_Seek( file, 6, SEEK_CUR );

	push	1
	push	6
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 368  : 
; 369  : 	FS_Read( file, &t, sizeof( t ));

	push	2
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 370  : 	sound.width = t / 8;

	movsx	eax, WORD PTR _t$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _sound+16, eax

; 371  : 
; 372  : 	sound.loopstart = 0;

	mov	DWORD PTR _sound+24, 0

; 373  : 
; 374  : 	// find data chunk
; 375  : 	last_chunk = iff_data;

	mov	edx, DWORD PTR _iff_data$[ebp]
	mov	DWORD PTR _last_chunk$[ebp], edx

; 376  : 	if( !StreamFindNextChunk( file, "data", &last_chunk ))

	lea	eax, DWORD PTR _last_chunk$[ebp]
	push	eax
	push	OFFSET $SG130033
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_StreamFindNextChunk
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Stream_Ope

; 377  : 	{
; 378  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing 'data' chunk\n", filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG130034
	call	_Con_DPrintf
	add	esp, 8

; 379  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 380  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN9@Stream_Ope:

; 381  : 	}
; 382  : 
; 383  : 	FS_Read( file, &sound.samples, sizeof( int ));

	push	4
	push	OFFSET _sound+28
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 384  : 	sound.samples = ( sound.samples / sound.width ) / sound.channels;

	mov	eax, DWORD PTR _sound+28
	xor	edx, edx
	div	DWORD PTR _sound+16
	xor	edx, edx
	div	DWORD PTR _sound+20
	mov	DWORD PTR _sound+28, eax

; 385  : 
; 386  : 	// at this point we have valid stream
; 387  : 	stream = Mem_Calloc( host.soundpool, sizeof( stream_t ));

	push	387					; 00000183H
	push	OFFSET $SG130035
	push	1
	push	8232					; 00002028H
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _stream$[ebp], eax

; 388  : 	stream->file = file;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 389  : 	stream->size = sound.samples * sound.width * sound.channels;

	mov	edx, DWORD PTR _sound+28
	imul	edx, DWORD PTR _sound+16
	imul	edx, DWORD PTR _sound+20
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+24], edx

; 390  : 	stream->buffsize = FS_Tell( file ); // header length

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Tell
	add	esp, 4
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+8228], eax

; 391  : 	stream->channels = sound.channels;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sound+20
	mov	DWORD PTR [eax+16], ecx

; 392  : 	stream->width = sound.width;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _sound+16
	mov	DWORD PTR [edx+8], eax

; 393  : 	stream->rate = sound.rate;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _sound+12
	mov	DWORD PTR [ecx+12], edx

; 394  : 	stream->type = WF_PCMDATA;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+20], 1

; 395  : 	
; 396  : 	return stream;

	mov	eax, DWORD PTR _stream$[ebp]
$LN1@Stream_Ope:

; 397  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_OpenWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_wav.c
_TEXT	SEGMENT
_samples$ = -28						; size = 4
_fmt$ = -24						; size = 4
_j$1 = -20						; size = 4
_i$2 = -16						; size = 4
_mpeg_stream$ = -12					; size = 4
_pData$3 = -8						; size = 4
_hdr_size$4 = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Sound_LoadWAV PROC

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 144  : 	int	samples, fmt;
; 145  : 	qboolean	mpeg_stream = false;

	mov	DWORD PTR _mpeg_stream$[ebp], 0

; 146  : 
; 147  : 	if( !buffer || filesize <= 0 )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN9@Sound_Load
	cmp	DWORD PTR _filesize$[ebp], 0
	ja	SHORT $LN8@Sound_Load
$LN9@Sound_Load:

; 148  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN8@Sound_Load:

; 149  : 
; 150  : 	iff_data = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _iff_data, eax

; 151  : 	iff_end = buffer + filesize;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _filesize$[ebp]
	mov	DWORD PTR _iff_end, ecx

; 152  : 
; 153  : 	// find "RIFF" chunk
; 154  : 	FindChunk( "RIFF" );

	push	OFFSET $SG129960
	call	_FindChunk
	add	esp, 4

; 155  : 
; 156  : 	if( !( iff_dataPtr && !Q_strncmp( iff_dataPtr + 8, "WAVE", 4 )))

	cmp	DWORD PTR _iff_dataPtr, 0
	je	SHORT $LN11@Sound_Load
	push	4
	push	OFFSET $SG129963
	mov	edx, DWORD PTR _iff_dataPtr
	add	edx, 8
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@Sound_Load
$LN11@Sound_Load:

; 157  : 	{
; 158  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: %s missing 'RIFF/WAVE' chunks\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG129964
	call	_Con_DPrintf
	add	esp, 8

; 159  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN10@Sound_Load:

; 160  : 	}
; 161  : 
; 162  : 	// get "fmt " chunk
; 163  : 	iff_data = iff_dataPtr + 12;

	mov	ecx, DWORD PTR _iff_dataPtr
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _iff_data, ecx

; 164  : 	FindChunk( "fmt " );

	push	OFFSET $SG129965
	call	_FindChunk
	add	esp, 4

; 165  : 
; 166  : 	if( !iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	jne	SHORT $LN12@Sound_Load

; 167  : 	{
; 168  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: %s missing 'fmt ' chunk\n", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG129967
	call	_Con_DPrintf
	add	esp, 8

; 169  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN12@Sound_Load:

; 170  : 	}
; 171  : 
; 172  : 	iff_dataPtr += 8;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 8
	mov	DWORD PTR _iff_dataPtr, eax

; 173  : 	fmt = GetLittleShort();

	call	_GetLittleShort
	movsx	ecx, ax
	mov	DWORD PTR _fmt$[ebp], ecx

; 174  : 
; 175  : 	if( fmt != 1 )

	cmp	DWORD PTR _fmt$[ebp], 1
	je	SHORT $LN13@Sound_Load

; 176  : 	{
; 177  : 		if( fmt != 85 )

	cmp	DWORD PTR _fmt$[ebp], 85		; 00000055H
	je	SHORT $LN14@Sound_Load

; 178  : 		{
; 179  : 			Con_DPrintf( S_ERROR "Sound_LoadWAV: %s not a microsoft PCM format\n", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG129971
	call	_Con_DPrintf
	add	esp, 8

; 180  : 			return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load

; 181  : 		}

	jmp	SHORT $LN13@Sound_Load
$LN14@Sound_Load:

; 182  : 		else
; 183  : 		{
; 184  : 			// mpeg stream in wav container
; 185  : 			mpeg_stream = true;

	mov	DWORD PTR _mpeg_stream$[ebp], 1
$LN13@Sound_Load:

; 186  : 		}
; 187  : 	}
; 188  : 
; 189  : 	sound.channels = GetLittleShort();

	call	_GetLittleShort
	cwde
	mov	DWORD PTR _sound+20, eax

; 190  : 	if( sound.channels != 1 && sound.channels != 2 )

	cmp	DWORD PTR _sound+20, 1
	je	SHORT $LN16@Sound_Load
	cmp	DWORD PTR _sound+20, 2
	je	SHORT $LN16@Sound_Load

; 191  : 	{
; 192  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: only mono and stereo WAV files supported (%s)\n", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG129973
	call	_Con_DPrintf
	add	esp, 8

; 193  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN16@Sound_Load:

; 194  : 	}
; 195  : 
; 196  : 	sound.rate = GetLittleLong();

	call	_GetLittleLong
	mov	DWORD PTR _sound+12, eax

; 197  : 	iff_dataPtr += 6;

	mov	edx, DWORD PTR _iff_dataPtr
	add	edx, 6
	mov	DWORD PTR _iff_dataPtr, edx

; 198  : 
; 199  : 	sound.width = GetLittleShort() / 8;

	call	_GetLittleShort
	cwde
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _sound+16, eax

; 200  : 	if( mpeg_stream ) sound.width = 2; // mp3 always 16bit

	cmp	DWORD PTR _mpeg_stream$[ebp], 0
	je	SHORT $LN17@Sound_Load
	mov	DWORD PTR _sound+16, 2
$LN17@Sound_Load:

; 201  : 
; 202  : 	if( sound.width != 1 && sound.width != 2 )

	cmp	DWORD PTR _sound+16, 1
	je	SHORT $LN18@Sound_Load
	cmp	DWORD PTR _sound+16, 2
	je	SHORT $LN18@Sound_Load

; 203  : 	{
; 204  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: only 8 and 16 bit WAV files supported (%s)\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG129976
	call	_Con_DPrintf
	add	esp, 8

; 205  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN18@Sound_Load:

; 206  : 	}
; 207  : 
; 208  : 	// get cue chunk
; 209  : 	FindChunk( "cue " );

	push	OFFSET $SG129977
	call	_FindChunk
	add	esp, 4

; 210  : 
; 211  : 	if( iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	je	SHORT $LN19@Sound_Load

; 212  : 	{
; 213  : 		iff_dataPtr += 32;

	mov	ecx, DWORD PTR _iff_dataPtr
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _iff_dataPtr, ecx

; 214  : 		sound.loopstart = GetLittleLong();

	call	_GetLittleLong
	mov	DWORD PTR _sound+24, eax

; 215  : 		FindNextChunk( "LIST" ); // if the next chunk is a LIST chunk, look for a cue length marker

	push	OFFSET $SG129980
	call	_FindNextChunk
	add	esp, 4

; 216  : 
; 217  : 		if( iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	je	SHORT $LN21@Sound_Load

; 218  : 		{
; 219  : 			if( !Q_strncmp( iff_dataPtr + 28, "mark", 4 ))

	push	4
	push	OFFSET $SG129983
	mov	edx, DWORD PTR _iff_dataPtr
	add	edx, 28					; 0000001cH
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Sound_Load

; 220  : 			{	
; 221  : 				// this is not a proper parse, but it works with CoolEdit...
; 222  : 				iff_dataPtr += 24;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 24					; 00000018H
	mov	DWORD PTR _iff_dataPtr, eax

; 223  : 				sound.samples = sound.loopstart + GetLittleLong(); // samples in loop

	call	_GetLittleLong
	add	eax, DWORD PTR _sound+24
	mov	DWORD PTR _sound+28, eax
$LN21@Sound_Load:

; 224  : 			}
; 225  : 		}
; 226  : 	}

	jmp	SHORT $LN20@Sound_Load
$LN19@Sound_Load:

; 227  : 	else 
; 228  : 	{
; 229  : 		sound.loopstart = -1;

	mov	DWORD PTR _sound+24, -1

; 230  : 		sound.samples = 0;

	mov	DWORD PTR _sound+28, 0
$LN20@Sound_Load:

; 231  : 	}
; 232  : 
; 233  : 	// find data chunk
; 234  : 	FindChunk( "data" );

	push	OFFSET $SG129984
	call	_FindChunk
	add	esp, 4

; 235  : 
; 236  : 	if( !iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	jne	SHORT $LN23@Sound_Load

; 237  : 	{
; 238  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: %s missing 'data' chunk\n", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG129986
	call	_Con_DPrintf
	add	esp, 8

; 239  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN23@Sound_Load:

; 240  : 	}
; 241  : 
; 242  : 	iff_dataPtr += 4;

	mov	edx, DWORD PTR _iff_dataPtr
	add	edx, 4
	mov	DWORD PTR _iff_dataPtr, edx

; 243  : 	samples = GetLittleLong() / sound.width;

	call	_GetLittleLong
	cdq
	idiv	DWORD PTR _sound+16
	mov	DWORD PTR _samples$[ebp], eax

; 244  : 
; 245  : 	if( sound.samples )

	cmp	DWORD PTR _sound+28, 0
	je	SHORT $LN24@Sound_Load

; 246  : 	{
; 247  : 		if( samples < sound.samples )

	mov	eax, DWORD PTR _samples$[ebp]
	cmp	eax, DWORD PTR _sound+28
	jae	SHORT $LN26@Sound_Load

; 248  : 		{
; 249  : 			Con_DPrintf( S_ERROR "Sound_LoadWAV: %s has a bad loop length\n", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG129990
	call	_Con_DPrintf
	add	esp, 8

; 250  : 			return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN26@Sound_Load:

; 251  : 		}
; 252  : 	}

	jmp	SHORT $LN25@Sound_Load
$LN24@Sound_Load:

; 253  : 	else sound.samples = samples;

	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _sound+28, edx
$LN25@Sound_Load:

; 254  : 
; 255  : 	if( sound.samples <= 0 )

	cmp	DWORD PTR _sound+28, 0
	ja	SHORT $LN27@Sound_Load

; 256  : 	{
; 257  : 		Con_Reportf( S_ERROR "Sound_LoadWAV: file with %i samples (%s)\n", sound.samples, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sound+28
	push	ecx
	push	OFFSET $SG129992
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 258  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN27@Sound_Load:

; 259  : 	}
; 260  : 
; 261  : 	sound.type = WF_PCMDATA;

	mov	DWORD PTR _sound+8, 1

; 262  : 	sound.samples /= sound.channels;

	mov	eax, DWORD PTR _sound+28
	xor	edx, edx
	div	DWORD PTR _sound+20
	mov	DWORD PTR _sound+28, eax

; 263  : 
; 264  : 	// g-cont. get support for mp3 streams packed in wav container
; 265  : 	// e.g. CAd menu sounds
; 266  : 	if( mpeg_stream )

	cmp	DWORD PTR _mpeg_stream$[ebp], 0
	je	$LN28@Sound_Load

; 267  : 	{
; 268  : 		int	hdr_size = (iff_dataPtr - buffer);

	mov	edx, DWORD PTR _iff_dataPtr
	sub	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _hdr_size$4[ebp], edx

; 269  : 
; 270  : 		if(( filesize - hdr_size ) < FRAME_SIZE )

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, DWORD PTR _hdr_size$4[ebp]
	cmp	eax, 32768				; 00008000H
	jae	SHORT $LN29@Sound_Load

; 271  : 		{
; 272  : 			sound.tempbuffer = (byte *)Mem_Realloc( host.soundpool, sound.tempbuffer, FRAME_SIZE );

	push	272					; 00000110H
	push	OFFSET $SG129995
	push	1
	push	32768					; 00008000H
	mov	ecx, DWORD PTR _sound+44
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _sound+44, eax

; 273  : 			memcpy( sound.tempbuffer, buffer + (iff_dataPtr - buffer), filesize - hdr_size );

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, DWORD PTR _hdr_size$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _iff_dataPtr
	push	ecx
	mov	edx, DWORD PTR _sound+44
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 274  : 			return Sound_LoadMPG( name, sound.tempbuffer, FRAME_SIZE );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _sound+44
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Sound_LoadMPG
	add	esp, 12					; 0000000cH
	jmp	$LN1@Sound_Load
$LN29@Sound_Load:

; 275  : 		}
; 276  : 
; 277  : 		return Sound_LoadMPG( name, buffer + hdr_size, filesize - hdr_size );

	mov	edx, DWORD PTR _filesize$[ebp]
	sub	edx, DWORD PTR _hdr_size$4[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _hdr_size$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Sound_LoadMPG
	add	esp, 12					; 0000000cH
	jmp	$LN1@Sound_Load
$LN28@Sound_Load:

; 278  : 	}
; 279  : 
; 280  : 	// Load the data
; 281  : 	sound.size = sound.samples * sound.width * sound.channels;

	mov	edx, DWORD PTR _sound+28
	imul	edx, DWORD PTR _sound+16
	imul	edx, DWORD PTR _sound+20
	mov	DWORD PTR _sound+36, edx

; 282  : 	sound.wav = Mem_Malloc( host.soundpool, sound.size );

	push	282					; 0000011aH
	push	OFFSET $SG129996
	push	0
	mov	eax, DWORD PTR _sound+36
	push	eax
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _sound+40, eax

; 283  : 
; 284  : 	memcpy( sound.wav, buffer + (iff_dataPtr - buffer), sound.size );

	mov	edx, DWORD PTR _sound+36
	push	edx
	mov	eax, DWORD PTR _iff_dataPtr
	push	eax
	mov	ecx, DWORD PTR _sound+40
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 285  : 
; 286  : 	// now convert 8-bit sounds to signed
; 287  : 	if( sound.width == 1 )

	cmp	DWORD PTR _sound+16, 1
	jne	SHORT $LN30@Sound_Load

; 288  : 	{
; 289  : 		int	i, j;
; 290  : 		char	*pData = sound.wav;

	mov	edx, DWORD PTR _sound+40
	mov	DWORD PTR _pData$3[ebp], edx

; 291  : 
; 292  : 		for( i = 0; i < sound.samples; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@Sound_Load
$LN2@Sound_Load:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@Sound_Load:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _sound+28
	jae	SHORT $LN30@Sound_Load

; 293  : 		{
; 294  : 			for( j = 0; j < sound.channels; j++ )

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN7@Sound_Load
$LN5@Sound_Load:
	mov	edx, DWORD PTR _j$1[ebp]
	add	edx, 1
	mov	DWORD PTR _j$1[ebp], edx
$LN7@Sound_Load:
	mov	eax, DWORD PTR _j$1[ebp]
	cmp	eax, DWORD PTR _sound+20
	jge	SHORT $LN6@Sound_Load

; 295  : 			{
; 296  : 				*pData = (byte)((int)((byte)*pData) - 128 );

	mov	ecx, DWORD PTR _pData$3[ebp]
	movzx	edx, BYTE PTR [ecx]
	sub	edx, 128				; 00000080H
	mov	eax, DWORD PTR _pData$3[ebp]
	mov	BYTE PTR [eax], dl

; 297  : 				pData++;

	mov	ecx, DWORD PTR _pData$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pData$3[ebp], ecx

; 298  : 			}

	jmp	SHORT $LN5@Sound_Load
$LN6@Sound_Load:

; 299  : 		}

	jmp	SHORT $LN2@Sound_Load
$LN30@Sound_Load:

; 300  : 	}
; 301  : 
; 302  : 	return true;

	mov	eax, 1
$LN1@Sound_Load:

; 303  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_LoadWAV ENDP
_TEXT	ENDS
END
