; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\mod_bmodel.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_world:BYTE:0a4cH
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
_DATA	ENDS
_BSS	SEGMENT
_srcmodel DB	024acH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_DATA	SEGMENT
$SG145238 DB	'entities', 00H
	ORG $+3
$SG145239 DB	'planes', 00H
	ORG $+1
$SG145240 DB	'textures', 00H
	ORG $+3
$SG145241 DB	'vertexes', 00H
	ORG $+3
$SG145242 DB	'visibility', 00H
	ORG $+1
$SG145243 DB	'nodes', 00H
	ORG $+2
$SG145244 DB	'texinfo', 00H
$SG145245 DB	'faces', 00H
	ORG $+2
$SG145246 DB	'lightmaps', 00H
	ORG $+2
$SG145247 DB	'clipnodes', 00H
	ORG $+2
$SG145248 DB	'leafs', 00H
	ORG $+2
$SG145249 DB	'markfaces', 00H
	ORG $+2
$SG145250 DB	'edges', 00H
	ORG $+2
$SG145251 DB	'surfedges', 00H
	ORG $+2
$SG145252 DB	'models', 00H
	ORG $+1
$SG145260 DB	'deluxmaps', 00H
	ORG $+2
$SG145261 DB	'faceinfos', 00H
	ORG $+2
$SG145262 DB	'shadowmap', 00H
_DATA	ENDS
PUBLIC	_Mod_LoadBrushModel
PUBLIC	_Mod_TestBmodelLumps
PUBLIC	_Mod_HeadnodeVisible
PUBLIC	_Mod_FatPVS
PUBLIC	_Mod_BoxVisible
PUBLIC	_Mod_CheckLump
PUBLIC	_Mod_ReadLump
PUBLIC	_Mod_SaveLump
PUBLIC	_Mod_PointInLeaf
PUBLIC	_Mod_AmbientLevels
PUBLIC	_Mod_SampleSizeForFace
PUBLIC	_Mod_GetPVSForPoint
PUBLIC	_Mod_UnloadBrushModel
PUBLIC	_Mod_PrintWorldStats_f
PUBLIC	_Mod_DecompressPVS
PUBLIC	_Mod_LoadBmodelLumps
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fefff2e40000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42a00000
PUBLIC	__real@42be0000
PUBLIC	__real@42c7fae1
PUBLIC	__real@42c80000
PUBLIC	__real@497423f0
PUBLIC	__real@c97423f0
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strtok:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strnlwr:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_toupper:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atov:PROC
EXTRN	_Q_strchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_ReplaceExtension:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Mod_FindName:PROC
EXTRN	_Mod_InitDebugHulls:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	_PlaneTypeForNormal:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_BoxOnPlaneSide:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_GL_SubdivideSurface:PROC
EXTRN	_R_InitSkyClouds:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_r_wadtextures:DWORD
EXTRN	_tr:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_loadstat DB	048H DUP (?)
_worldmodel DD	01H DUP (?)
_g_visdata DB	01000H DUP (?)
_worldstats DB	01b0H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c97423f0
CONST	SEGMENT
__real@c97423f0 DD 0c97423f0r			; -999999
CONST	ENDS
;	COMDAT __real@497423f0
CONST	SEGMENT
__real@497423f0 DD 0497423f0r			; 999999
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42c7fae1
CONST	SEGMENT
__real@42c7fae1 DD 042c7fae1r			; 99.99
CONST	ENDS
;	COMDAT __real@42be0000
CONST	SEGMENT
__real@42be0000 DD 042be0000r			; 95
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fefff2e40000000
CONST	SEGMENT
__real@3fefff2e40000000 DQ 03fefff2e40000000r	; 0.9999
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+6
_srclumps DD	00H
	DD	020H
	DD	0100000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:$SG145238
	DD	00H
	DD	FLAT:_srcmodel+128
	DD	FLAT:_srcmodel+132
	DD	01H
	DD	01H
	DD	010000H
	DD	014H
	DD	0ffffffffH
	DD	FLAT:$SG145239
	DD	00H
	DD	FLAT:_srcmodel+16
	DD	FLAT:_srcmodel+20
	DD	02H
	DD	01H
	DD	02000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:$SG145240
	DD	00H
	DD	FLAT:_srcmodel+136
	DD	FLAT:_srcmodel+140
	DD	03H
	DD	00H
	DD	0ffffH
	DD	0cH
	DD	0ffffffffH
	DD	FLAT:$SG145241
	DD	00H
	DD	FLAT:_srcmodel+8
	DD	FLAT:_srcmodel+12
	DD	04H
	DD	00H
	DD	01000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:$SG145242
	DD	00H
	DD	FLAT:_srcmodel+96
	DD	FLAT:_srcmodel+100
	DD	05H
	DD	01H
	DD	07fffH
	DD	018H
	DD	02cH
	DD	FLAT:$SG145243
	DD	01H
	DD	FLAT:_srcmodel+24
	DD	FLAT:_srcmodel+28
	DD	06H
	DD	00H
	DD	0ffffH
	DD	028H
	DD	0ffffffffH
	DD	FLAT:$SG145244
	DD	01H
	DD	FLAT:_srcmodel+48
	DD	FLAT:_srcmodel+52
	DD	07H
	DD	00H
	DD	0ffffH
	DD	014H
	DD	01cH
	DD	FLAT:$SG145245
	DD	01H
	DD	FLAT:_srcmodel+80
	DD	FLAT:_srcmodel+84
	DD	08H
	DD	00H
	DD	02000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:$SG145246
	DD	00H
	DD	FLAT:_srcmodel+104
	DD	FLAT:_srcmodel+108
	DD	09H
	DD	00H
	DD	07fffH
	DD	08H
	DD	0cH
	DD	FLAT:$SG145247
	DD	00H
	DD	FLAT:_srcmodel+40
	DD	FLAT:_srcmodel+44
	DD	0aH
	DD	01H
	DD	07fffH
	DD	01cH
	DD	02cH
	DD	FLAT:$SG145248
	DD	01H
	DD	FLAT:_srcmodel+32
	DD	FLAT:_srcmodel+36
	DD	0bH
	DD	00H
	DD	0ffffH
	DD	02H
	DD	04H
	DD	FLAT:$SG145249
	DD	00H
	DD	FLAT:_srcmodel+56
	DD	FLAT:_srcmodel+60
	DD	0cH
	DD	00H
	DD	0100000H
	DD	04H
	DD	08H
	DD	FLAT:$SG145250
	DD	00H
	DD	FLAT:_srcmodel+72
	DD	FLAT:_srcmodel+76
	DD	0dH
	DD	00H
	DD	0200000H
	DD	04H
	DD	0ffffffffH
	DD	FLAT:$SG145251
	DD	00H
	DD	FLAT:_srcmodel+64
	DD	FLAT:_srcmodel+68
	DD	0eH
	DD	01H
	DD	0300H
	DD	040H
	DD	0ffffffffH
	DD	FLAT:$SG145252
	DD	01H
	DD	FLAT:_srcmodel
	DD	FLAT:_srcmodel+4
$SG145308 DB	'^3Warning:^7 map ^2%s^7 has no %s', 0aH, 00H
	ORG $+1
_extlumps DD	00H
	DD	00H
	DD	02000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:$SG145260
	DD	02H
	DD	FLAT:_srcmodel+112
	DD	FLAT:_srcmodel+116
	DD	01H
	DD	00H
	DD	02000H
	DD	016H
	DD	0ffffffffH
	DD	FLAT:$SG145261
	DD	03H
	DD	FLAT:_srcmodel+88
	DD	FLAT:_srcmodel+92
	DD	08H
	DD	00H
	DD	0aaaaaaH
	DD	01H
	DD	0ffffffffH
	DD	FLAT:$SG145262
	DD	02H
	DD	FLAT:_srcmodel+120
	DD	FLAT:_srcmodel+124
	ORG $+324
$SG145311 DB	'^1Error:^7 map ^2%s^7 has no %s', 0aH, 00H
	ORG $+3
$SG145314 DB	'^1Error:^7 Mod_Load%s: funny lump size', 0aH, 00H
$SG145317 DB	'^1Error:^7 map ^2%s^7 has no %s', 0aH, 00H
	ORG $+3
$SG145322 DB	'^1Error:^7 map ^2%s^7 has too many %s', 0aH, 00H
	ORG $+1
$SG145324 DB	'^3Warning:^7 map ^2%s^7 has too many %s', 0aH, 00H
	ORG $+3
$SG145339 DB	'%-12s  %7i/%-7i  %8i/%-8i  (%4.1f%%) ', 00H
	ORG $+2
$SG145342 DB	'^1SIZE OVERFLOW!!!^7', 0aH, 00H
	ORG $+2
$SG145345 DB	'^3SIZE DANGER!^7', 0aH, 00H
	ORG $+2
$SG145348 DB	'^2VERY FULL!^7', 0aH, 00H
$SG145349 DB	0aH, 00H
	ORG $+2
$SG145359 DB	'[variable]', 00H
	ORG $+1
$SG145360 DB	'%-15s  %-12s  %8i/%-8i  (%4.1f%%) ', 00H
	ORG $+1
$SG145363 DB	'^1SIZE OVERFLOW!!!^7', 0aH, 00H
	ORG $+2
$SG145366 DB	'^3SIZE DANGER!^7', 0aH, 00H
	ORG $+2
$SG145369 DB	'^2VERY FULL!^7', 0aH, 00H
$SG145370 DB	0aH, 00H
	ORG $+2
$SG145383 DB	'No map loaded', 0aH, 00H
	ORG $+1
$SG145384 DB	0aH, 00H
	ORG $+2
$SG145385 DB	'Object names  Objects/Maxobjs  Memory / Maxmem  Fullness'
	DB	0aH, 00H
	ORG $+2
$SG145386 DB	'------------  ---------------  ---------------  --------'
	DB	0aH, 00H
	ORG $+2
$SG145391 DB	'=== Total BSP file data space used: %s ===', 0aH, 00H
$SG145392 DB	'World size ( %g %g %g ) units', 0aH, 00H
	ORG $+1
$SG145393 DB	'Yes', 00H
$SG145394 DB	'No', 00H
	ORG $+1
$SG145395 DB	'Supports transparency world water: %s', 0aH, 00H
	ORG $+1
$SG145396 DB	'colored', 00H
$SG145397 DB	'monochrome', 00H
	ORG $+1
$SG145398 DB	'Lighting: %s', 0aH, 00H
	ORG $+2
$SG145399 DB	'World total leafs: %d', 0aH, 00H
	ORG $+1
$SG145400 DB	'original name: ^1%s', 0aH, 00H
	ORG $+3
$SG145401 DB	'^2%s', 00H
	ORG $+3
$SG145402 DB	'none', 00H
	ORG $+3
$SG145403 DB	'internal name: %s', 0aH, 00H
	ORG $+1
$SG145404 DB	'^3%s', 00H
	ORG $+3
$SG145405 DB	'unknown', 00H
$SG145406 DB	'map compiler: %s', 0aH, 00H
	ORG $+2
$SG145407 DB	'^2%s', 00H
	ORG $+3
$SG145408 DB	'unknown', 00H
$SG145409 DB	'map editor: %s', 0aH, 00H
$SG145438 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145439 DB	'node != NULL', 00H
	ORG $+3
$SG145453 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145454 DB	'assert failed at %s:%i', 0aH, 00H
$SG145502 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145503 DB	'assert failed at %s:%i', 0aH, 00H
$SG145617 DB	'Mod_FindModelOrigin: found %s when expecting {', 0aH, 00H
$SG145619 DB	'Mod_FindModelOrigin: EOF without closing brace', 0aH, 00H
$SG145622 DB	'Mod_FindModelOrigin: EOF without closing brace', 0aH, 00H
$SG145624 DB	'Mod_FindModelOrigin: closing brace without data', 0aH, 00H
	ORG $+3
$SG145626 DB	'model', 00H
	ORG $+2
$SG145628 DB	'origin', 00H
	ORG $+1
$SG145663 DB	'SKY', 00H
$SG145668 DB	'lava', 00H
	ORG $+3
$SG145670 DB	'slime', 00H
	ORG $+2
$SG145672 DB	'water', 00H
	ORG $+2
$SG145756 DB	'Mod_CalcSurfaceExtents: bad edge', 0aH, 00H
	ORG $+2
$SG145762 DB	'^1Error:^7 Bad surface extents %i', 0aH, 00H
	ORG $+1
$SG145775 DB	'Mod_CalcSurfaceBounds: bad edge', 0aH, 00H
	ORG $+3
$SG145831 DB	'MAX_MAP_CLIPNODES limit exceeded', 0aH, 00H
	ORG $+2
$SG145810 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145842 DB	'MAX_MAP_CLIPNODES limit exceeded', 0aH, 00H
	ORG $+2
$SG145860 DB	'MAX_MAP_CLIPNODES limit exceeded', 0aH, 00H
	ORG $+2
$SG145876 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145905 DB	'Mod_SetupHull: bad hull number %i', 0aH, 00H
	ORG $+1
$SG145921 DB	'maps/%s.lit', 00H
$SG145907 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145924 DB	'^3Warning:^7 %s probably is out of date', 0aH, 00H
	ORG $+3
$SG145926 DB	'in != NULL', 00H
	ORG $+1
$SG145925 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145929 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145931 DB	'^1Error:^7 %s has mismatched size (%i should be %i)', 0aH
	DB	00H
	ORG $+3
$SG145932 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145933 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145934 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145949 DB	'maps/%s.dlit', 00H
	ORG $+3
$SG145952 DB	'^3Warning:^7 %s probably is out of date', 0aH, 00H
	ORG $+3
$SG145954 DB	'in != NULL', 00H
	ORG $+1
$SG145953 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145957 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145959 DB	'^1Error:^7 %s has mismatched size (%i should be %i)', 0aH
	DB	00H
	ORG $+3
$SG145960 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145961 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145962 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG145990 DB	'*%i', 00H
$SG145994 DB	'maps/c2a1.bsp', 00H
	ORG $+2
$SG145999 DB	'*%i', 00H
$SG146001 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146022 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146028 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146061 DB	'.ent', 00H
	ORG $+3
$SG146065 DB	'^3Warning:^7 Entity patch is older than bsp. Ignored.', 0aH
	DB	00H
	ORG $+1
$SG146067 DB	'^2Read entity patch:^7 %s', 0aH, 00H
	ORG $+1
$SG146083 DB	'wad', 00H
$SG146068 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146070 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146073 DB	'Mod_LoadEntities: found %s when expecting {', 0aH, 00H
	ORG $+3
$SG146075 DB	'Mod_LoadEntities: EOF without closing brace', 0aH, 00H
	ORG $+3
$SG146078 DB	'Mod_LoadEntities: EOF without closing brace', 0aH, 00H
	ORG $+3
$SG146080 DB	'Mod_LoadEntities: closing brace without data', 0aH, 00H
	ORG $+2
$SG146085 DB	';', 00H
	ORG $+2
$SG146086 DB	';', 00H
	ORG $+2
$SG146087 DB	';', 00H
	ORG $+2
$SG146089 DB	'%s.wad', 00H
	ORG $+1
$SG146093 DB	'message', 00H
$SG146097 DB	'compiler', 00H
	ORG $+3
$SG146098 DB	'_compiler', 00H
	ORG $+2
$SG146101 DB	'generator', 00H
	ORG $+2
$SG146102 DB	'_generator', 00H
	ORG $+1
$SG146264 DB	'*default', 00H
	ORG $+3
$SG146117 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146120 DB	'^1Error:^7 bad normal for plane #%i', 0aH, 00H
	ORG $+3
$SG146135 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146158 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146167 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146182 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146187 DB	'Mod_LoadMarkFaces: bad surface number in ''%s''', 0aH, 00H
	ORG $+1
$SG146190 DB	'Mod_LoadMarkFaces: bad surface number in ''%s''', 0aH, 00H
	ORG $+1
$SG146261 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146263 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146266 DB	'miptex_%i', 00H
	ORG $+2
$SG146274 DB	'sky', 00H
$SG146267 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146279 DB	'%s.mip', 00H
	ORG $+1
$SG146280 DB	'%s.wad/%s', 00H
	ORG $+2
$SG146284 DB	'#%s:%s.mip', 00H
	ORG $+1
$SG146286 DB	'^1Error:^7 unable to find %s.mip', 0aH, 00H
	ORG $+2
$SG146288 DB	'#%s:%s_luma.mip', 00H
$SG146292 DB	'%s.wad/%s.mip', 00H
	ORG $+2
$SG146303 DB	'^1Error:^7 Mod_LoadTextures: bad animating texture %s', 0aH
	DB	00H
	ORG $+1
$SG146397 DB	'^1Error:^7 bad surface %i from %i', 0aH, 00H
	ORG $+1
$SG146295 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146313 DB	'^1Error:^7 Mod_LoadTextures: bad animating texture %s', 0aH
	DB	00H
	ORG $+1
$SG146315 DB	'^1Error:^7 Mod_LoadTextures: missing frame %i of %s', 0aH
	DB	00H
	ORG $+3
$SG146318 DB	'^1Error:^7 Mod_LoadTextures: missing frame %i of %s', 0aH
	DB	00H
	ORG $+3
$SG146342 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146343 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146387 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146388 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146400 DB	'sky', 00H
$SG146404 DB	'*default', 00H
	ORG $+3
$SG146408 DB	'water', 00H
	ORG $+2
$SG146409 DB	'laser', 00H
	ORG $+2
$SG146411 DB	'scroll', 00H
	ORG $+1
$SG146414 DB	'{scroll', 00H
$SG146426 DB	'monochrome', 00H
	ORG $+1
$SG146427 DB	'colored', 00H
$SG146428 DB	'lighting: %s', 0aH, 00H
	ORG $+2
$SG146507 DB	'^3Warning:^7 Mod_LoadLeafs: invalid visofs for leaf #%i', 0aH
	DB	00H
	ORG $+3
$SG146429 DB	'^3Warning:^7 lighting invalid samplecount: %g, defaultin'
	DB	'g to %i', 0aH, 00H
	ORG $+3
$SG146512 DB	'Mod_LoadLeafs: Map %s has leaf 0 is not CONTENTS_SOLID', 0aH
	DB	00H
$SG146629 DB	'^1Error:^7 %s has wrong version number (%i should be %i)'
	DB	0aH, 00H
	ORG $+2
$SG146459 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146497 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146531 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146541 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146549 DB	'^1Error:^7 Mod_LoadLightVecs: has mismatched size (%i sh'
	DB	'ould be %i)', 0aH, 00H
	ORG $+3
$SG146550 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146557 DB	'^1Error:^7 Mod_LoadShadowmap: has mismatched size (%i sh'
	DB	'ould be %i)', 0aH, 00H
	ORG $+3
$SG146558 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146582 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146584 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146586 DB	'Mod_LoadLighting: bad lightmap sample count %i', 0aH, 00H
$SG146626 DB	'^1Error:^7 %s can''t be loaded in this build. Please reb'
	DB	'uild engine with enabled SUPPORT_BSP2_FORMAT', 0aH, 00H
	ORG $+3
$SG146633 DB	'World', 00H
	ORG $+2
$SG146634 DB	'Brush', 00H
	ORG $+2
$SG146635 DB	'Mod_Load%s: %i error(s), %i warning(s)', 0aH, 00H
$SG146637 DB	'World', 00H
	ORG $+2
$SG146638 DB	'Brush', 00H
	ORG $+2
$SG146639 DB	'Mod_Load%s: %i warning(s)', 0aH, 00H
	ORG $+1
$SG146642 DB	'%s.wad; ', 00H
	ORG $+3
$SG146644 DB	'Wad files required to run the map: "%s"', 0aH, 00H
	ORG $+3
$SG146672 DB	'^1Error:^7 %s has wrong version number (%i should be %i)'
	DB	0aH, 00H
	ORG $+2
$SG146668 DB	'^1Error:^7 %s can''t be loaded in this build. Please reb'
	DB	'uild engine with enabled SUPPORT_BSP2_FORMAT', 0aH, 00H
	ORG $+3
$SG146676 DB	'Mod_LoadWorld: %i error(s), %i warning(s)', 0aH, 00H
	ORG $+1
$SG146679 DB	'Mod_LoadWorld: %i warning(s)', 0aH, 00H
	ORG $+2
$SG146689 DB	'^2%s^7', 00H
	ORG $+1
$SG146706 DB	'mod != NULL', 00H
$SG146688 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146705 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146712 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\mod_bmodel.c', 00H
	ORG $+1
$SG146731 DB	'rb', 00H
	ORG $+1
$SG146763 DB	'rb', 00H
	ORG $+1
$SG146804 DB	'e+b', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_extrahdr$ = -2100					; size = 4
_mod$ = -2096						; size = 4
$T1 = -2092						; size = 4
tv170 = -2088						; size = 4
tv162 = -2084						; size = 4
tv146 = -2080						; size = 4
tv134 = -2076						; size = 4
$T2 = -2072						; size = 4
tv84 = -2068						; size = 4
_header$ = -2064					; size = 4
_i$ = -2060						; size = 4
_bmod$ = -2056						; size = 4
_wadvalue$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_mod_base$ = 8						; size = 4
_isworld$ = 12						; size = 4
_Mod_LoadBmodelLumps PROC

; 2726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2100				; 00000834H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2727 : 	dheader_t		*header = (dheader_t *)mod_base;

	mov	eax, DWORD PTR _mod_base$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 2728 : 	dextrahdr_t	*extrahdr = (dextrahdr_t *)((byte *)mod_base + sizeof( dheader_t ));

	mov	ecx, DWORD PTR _mod_base$[ebp]
	add	ecx, 124				; 0000007cH
	mov	DWORD PTR _extrahdr$[ebp], ecx

; 2729 : 	dbspmodel_t	*bmod = &srcmodel;

	mov	DWORD PTR _bmod$[ebp], OFFSET _srcmodel

; 2730 : 	model_t		*mod = loadmodel;

	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR _mod$[ebp], edx

; 2731 : 	char		wadvalue[2048];
; 2732 : 	int		i;
; 2733 : 
; 2734 : 	// always reset the intermediate struct
; 2735 : 	memset( bmod, 0, sizeof( dbspmodel_t ));

	push	9388					; 000024acH
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2736 : 	memset( &loadstat, 0, sizeof( loadstat_t ));

	push	72					; 00000048H
	push	0
	push	OFFSET _loadstat
	call	_memset
	add	esp, 12					; 0000000cH

; 2737 : 
; 2738 : 	Q_strncpy( loadstat.name, loadmodel->name, sizeof( loadstat.name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET _loadstat
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2739 : 	wadvalue[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 2048		; 00000800H
	jae	SHORT $LN24@Mod_LoadBm
	jmp	SHORT $LN25@Mod_LoadBm
$LN24@Mod_LoadBm:
	call	___report_rangecheckfailure
$LN25@Mod_LoadBm:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _wadvalue$[ebp+ecx], 0

; 2740 : 
; 2741 : #ifndef SUPPORT_BSP2_FORMAT
; 2742 : 	if( header->version == QBSP2_VERSION )

	mov	edx, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [edx], 844124994		; 32505342H
	jne	SHORT $LN13@Mod_LoadBm

; 2743 : 	{
; 2744 : 		Con_Printf( S_ERROR DEFAULT_BSP_BUILD_ERROR, loadmodel->name );

	mov	eax, DWORD PTR _loadmodel
	push	eax
	push	OFFSET $SG146626
	call	_Con_Printf
	add	esp, 8

; 2745 : 		return false;

	xor	eax, eax
	jmp	$LN23@Mod_LoadBm
$LN13@Mod_LoadBm:

; 2746 : 	}
; 2747 : #endif
; 2748 : 	switch( header->version )

	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv84[ebp], edx
	cmp	DWORD PTR tv84[ebp], 29			; 0000001dH
	jl	SHORT $LN15@Mod_LoadBm
	cmp	DWORD PTR tv84[ebp], 30			; 0000001eH
	jle	SHORT $LN14@Mod_LoadBm
	cmp	DWORD PTR tv84[ebp], 844124994		; 32505342H
	je	SHORT $LN14@Mod_LoadBm
	jmp	SHORT $LN15@Mod_LoadBm
$LN14@Mod_LoadBm:

; 2749 : 	{
; 2750 : 	case Q1BSP_VERSION:
; 2751 : 	case HLBSP_VERSION:
; 2752 : 	case QBSP2_VERSION:
; 2753 : 		break;

	jmp	SHORT $LN2@Mod_LoadBm
$LN15@Mod_LoadBm:

; 2754 : 	default:
; 2755 : 		Con_Printf( S_ERROR "%s has wrong version number (%i should be %i)\n", loadmodel->name, header->version, HLBSP_VERSION );

	push	30					; 0000001eH
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	push	OFFSET $SG146629
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 2756 : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 2757 : 		return false;

	xor	eax, eax
	jmp	$LN23@Mod_LoadBm
$LN2@Mod_LoadBm:

; 2758 : 	}
; 2759 : 
; 2760 : 	bmod->version = header->version;	// share up global

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+9380], eax

; 2761 : 	if( isworld ) world.flags = 0;	// clear world settings

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN16@Mod_LoadBm
	mov	DWORD PTR _world+4, 0
$LN16@Mod_LoadBm:

; 2762 : 	bmod->isworld = isworld;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _isworld$[ebp]
	mov	DWORD PTR [ecx+9384], edx

; 2763 : 
; 2764 : 	// loading base lumps
; 2765 : 	for( i = 0; i < ARRAYSIZE_XASH( srclumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_LoadBm
$LN4@Mod_LoadBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Mod_LoadBm:
	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	jae	SHORT $LN5@Mod_LoadBm

; 2766 : 		Mod_LoadLump( mod_base, &srclumps[i], &worldstats[i], isworld ? (LUMP_SAVESTATS|LUMP_SILENT) : 0 );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN26@Mod_LoadBm
	mov	DWORD PTR tv134[ebp], 5
	jmp	SHORT $LN27@Mod_LoadBm
$LN26@Mod_LoadBm:
	mov	DWORD PTR tv134[ebp], 0
$LN27@Mod_LoadBm:
	mov	ecx, DWORD PTR tv134[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, OFFSET _worldstats
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 36
	add	eax, OFFSET _srclumps
	push	eax
	mov	ecx, DWORD PTR _mod_base$[ebp]
	push	ecx
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN4@Mod_LoadBm
$LN5@Mod_LoadBm:

; 2767 : 
; 2768 : 	// loading extralumps
; 2769 : 	for( i = 0; i < ARRAYSIZE_XASH( extlumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_LoadBm
$LN7@Mod_LoadBm:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@Mod_LoadBm:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jae	SHORT $LN8@Mod_LoadBm

; 2770 : 		Mod_LoadLump( mod_base, &extlumps[i], &worldstats[ARRAYSIZE_XASH( srclumps ) + i], isworld ? (LUMP_SAVESTATS|LUMP_SILENT) : 0 );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN28@Mod_LoadBm
	mov	DWORD PTR tv146[ebp], 5
	jmp	SHORT $LN29@Mod_LoadBm
$LN28@Mod_LoadBm:
	mov	DWORD PTR tv146[ebp], 0
$LN29@Mod_LoadBm:
	mov	eax, DWORD PTR tv146[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 15					; 0000000fH
	shl	ecx, 4
	add	ecx, OFFSET _worldstats
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 36
	add	edx, OFFSET _extlumps
	push	edx
	mov	eax, DWORD PTR _mod_base$[ebp]
	push	eax
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN7@Mod_LoadBm
$LN8@Mod_LoadBm:

; 2771 : 
; 2772 : 	if( !bmod->isworld && loadstat.numerrors )

	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9384], 0
	jne	SHORT $LN17@Mod_LoadBm
	cmp	DWORD PTR _loadstat+64, 0
	je	SHORT $LN17@Mod_LoadBm

; 2773 : 	{
; 2774 : 		Con_DPrintf( "Mod_Load%s: %i error(s), %i warning(s)\n", isworld ? "World" : "Brush", loadstat.numerrors, loadstat.numwarnings );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN30@Mod_LoadBm
	mov	DWORD PTR tv162[ebp], OFFSET $SG146633
	jmp	SHORT $LN31@Mod_LoadBm
$LN30@Mod_LoadBm:
	mov	DWORD PTR tv162[ebp], OFFSET $SG146634
$LN31@Mod_LoadBm:
	mov	edx, DWORD PTR _loadstat+68
	push	edx
	mov	eax, DWORD PTR _loadstat+64
	push	eax
	mov	ecx, DWORD PTR tv162[ebp]
	push	ecx
	push	OFFSET $SG146635
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 2775 : 		return false; // there were errors, we can't load this map

	xor	eax, eax
	jmp	$LN23@Mod_LoadBm

; 2776 : 	}	

	jmp	SHORT $LN18@Mod_LoadBm
$LN17@Mod_LoadBm:

; 2777 : 	else if( !bmod->isworld && loadstat.numwarnings )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9384], 0
	jne	SHORT $LN18@Mod_LoadBm
	cmp	DWORD PTR _loadstat+68, 0
	je	SHORT $LN18@Mod_LoadBm

; 2778 : 		Con_DPrintf( "Mod_Load%s: %i warning(s)\n", isworld ? "World" : "Brush", loadstat.numwarnings );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN32@Mod_LoadBm
	mov	DWORD PTR tv170[ebp], OFFSET $SG146637
	jmp	SHORT $LN33@Mod_LoadBm
$LN32@Mod_LoadBm:
	mov	DWORD PTR tv170[ebp], OFFSET $SG146638
$LN33@Mod_LoadBm:
	mov	eax, DWORD PTR _loadstat+68
	push	eax
	mov	ecx, DWORD PTR tv170[ebp]
	push	ecx
	push	OFFSET $SG146639
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN18@Mod_LoadBm:

; 2779 : 
; 2780 : 	// load into heap
; 2781 : 	Mod_LoadEntities( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadEntities
	add	esp, 4

; 2782 : 	Mod_LoadPlanes( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadPlanes
	add	esp, 4

; 2783 : 	Mod_LoadSubmodels( bmod );

	mov	ecx, DWORD PTR _bmod$[ebp]
	push	ecx
	call	_Mod_LoadSubmodels
	add	esp, 4

; 2784 : 	Mod_LoadVertexes( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadVertexes
	add	esp, 4

; 2785 : 	Mod_LoadEdges( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadEdges
	add	esp, 4

; 2786 : 	Mod_LoadSurfEdges( bmod );

	mov	ecx, DWORD PTR _bmod$[ebp]
	push	ecx
	call	_Mod_LoadSurfEdges
	add	esp, 4

; 2787 : 	Mod_LoadTextures( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadTextures
	add	esp, 4

; 2788 : 	Mod_LoadVisibility( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadVisibility
	add	esp, 4

; 2789 : 	Mod_LoadTexInfo( bmod );

	mov	ecx, DWORD PTR _bmod$[ebp]
	push	ecx
	call	_Mod_LoadTexInfo
	add	esp, 4

; 2790 : 	Mod_LoadSurfaces( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadSurfaces
	add	esp, 4

; 2791 : 	Mod_LoadLighting( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadLighting
	add	esp, 4

; 2792 : 	Mod_LoadMarkSurfaces( bmod );

	mov	ecx, DWORD PTR _bmod$[ebp]
	push	ecx
	call	_Mod_LoadMarkSurfaces
	add	esp, 4

; 2793 : 	Mod_LoadLeafs( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadLeafs
	add	esp, 4

; 2794 : 	Mod_LoadNodes( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadNodes
	add	esp, 4

; 2795 : 	Mod_LoadClipnodes( bmod );

	mov	ecx, DWORD PTR _bmod$[ebp]
	push	ecx
	call	_Mod_LoadClipnodes
	add	esp, 4

; 2796 : 
; 2797 : 	// preform some post-initalization
; 2798 : 	Mod_MakeHull0 ();

	call	_Mod_MakeHull0

; 2799 : 	Mod_SetupSubmodels( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_SetupSubmodels
	add	esp, 4

; 2800 : 
; 2801 : 	if( isworld )

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN20@Mod_LoadBm

; 2802 : 	{
; 2803 : 		loadmodel = mod;		// restore pointer to world

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _loadmodel, eax

; 2804 : 		Mod_InitDebugHulls();	// FIXME: build hulls for separate bmodels (shells, medkits etc)

	call	_Mod_InitDebugHulls

; 2805 : 		world.deluxedata = bmod->deluxedata_out;	// deluxemap data pointer

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR _world+2584, edx

; 2806 : 		world.shadowdata = bmod->shadowdata_out;	// occlusion data pointer

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR _world+2588, ecx
$LN20@Mod_LoadBm:

; 2807 : 	}
; 2808 : 
; 2809 : 	for( i = 0; i < bmod->wadlist.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Mod_LoadBm
$LN10@Mod_LoadBm:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN12@Mod_LoadBm:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+9372]
	jge	SHORT $LN11@Mod_LoadBm

; 2810 : 	{
; 2811 : 		if( !bmod->wadlist.wadusage[i] )

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+edx*4+8348], 0
	jne	SHORT $LN21@Mod_LoadBm

; 2812 : 			continue;

	jmp	SHORT $LN10@Mod_LoadBm
$LN21@Mod_LoadBm:

; 2813 : 		Q_strncat( wadvalue, va( "%s.wad; ", bmod->wadlist.wadnames[i] ), sizeof( wadvalue ));

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _bmod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	push	OFFSET $SG146642
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _wadvalue$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 2814 : 	}

	jmp	SHORT $LN10@Mod_LoadBm
$LN11@Mod_LoadBm:

; 2815 : 
; 2816 : 	if( COM_CheckString( wadvalue ))

	lea	edx, DWORD PTR _wadvalue$[ebp]
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN22@Mod_LoadBm

; 2817 : 	{
; 2818 : 		wadvalue[Q_strlen( wadvalue ) - 2] = '\0'; // kill the last semicolon

	lea	eax, DWORD PTR _wadvalue$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN34@Mod_LoadBm
	jmp	SHORT $LN35@Mod_LoadBm
$LN34@Mod_LoadBm:
	call	___report_rangecheckfailure
$LN35@Mod_LoadBm:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _wadvalue$[ebp+ecx], 0

; 2819 : 		Con_Reportf( "Wad files required to run the map: \"%s\"\n", wadvalue );

	lea	edx, DWORD PTR _wadvalue$[ebp]
	push	edx
	push	OFFSET $SG146644
	call	_Con_Reportf
	add	esp, 8
$LN22@Mod_LoadBm:

; 2820 : 	}
; 2821 : 
; 2822 : 	return true;

	mov	eax, 1
$LN23@Mod_LoadBm:

; 2823 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadBmodelLumps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv67 = -28						; size = 4
_offset$1 = -24						; size = 4
_lightofs$ = -20					; size = 4
_in$ = -16						; size = 4
_surf$ = -12						; size = 4
_out$ = -8						; size = 4
_i$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadLighting PROC

; 2648 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2649 : 	int		i, lightofs;
; 2650 : 	msurface_t	*surf;
; 2651 : 	color24		*out;
; 2652 : 	byte		*in;
; 2653 : 
; 2654 : 	if( !bmod->lightdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+108], 0
	jne	SHORT $LN10@Mod_LoadLi

; 2655 : 		return;

	jmp	$LN1@Mod_LoadLi
$LN10@Mod_LoadLi:

; 2656 : 
; 2657 : 	switch( bmod->lightmap_samples )

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+9376]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 1
	je	SHORT $LN11@Mod_LoadLi
	cmp	DWORD PTR tv67[ebp], 3
	je	$LN13@Mod_LoadLi
	jmp	$LN14@Mod_LoadLi
$LN11@Mod_LoadLi:

; 2658 : 	{
; 2659 : 	case 1:
; 2660 : 		if( !Mod_LoadColoredLighting( bmod ))

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadColoredLighting
	add	esp, 4
	test	eax, eax
	jne	$LN12@Mod_LoadLi

; 2661 : 		{
; 2662 : 			loadmodel->lightdata = out = (color24 *)Mem_Malloc( loadmodel->mempool, bmod->lightdatasize * sizeof( color24 ));

	push	2662					; 00000a66H
	push	OFFSET $SG146582
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+108], 3
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+380], eax

; 2663 : 			in = bmod->lightdata;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR _in$[ebp], edx

; 2664 : 
; 2665 : 			// expand the white lighting data
; 2666 : 			for( i = 0; i < bmod->lightdatasize; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_LoadLi
$LN4@Mod_LoadLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 3
	mov	DWORD PTR _out$[ebp], ecx
$LN6@Mod_LoadLi:
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+108]
	jae	SHORT $LN12@Mod_LoadLi

; 2667 : 				out->r = out->g = out->b = *in++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+2], al
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+1], al
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN4@Mod_LoadLi
$LN12@Mod_LoadLi:

; 2668 : 		}
; 2669 : 		break;

	jmp	$LN2@Mod_LoadLi
$LN13@Mod_LoadLi:

; 2670 : 	case 3:	// load colored lighting
; 2671 : 		loadmodel->lightdata = Mem_Malloc( loadmodel->mempool, bmod->lightdatasize );

	push	2671					; 00000a6fH
	push	OFFSET $SG146584
	push	0
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+380], eax

; 2672 : 		memcpy( loadmodel->lightdata, bmod->lightdata, bmod->lightdatasize );

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+380]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2673 : 		SetBits( loadmodel->flags, MODEL_COLORED_LIGHTING );

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+80]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+80], eax

; 2674 : 		break;

	jmp	SHORT $LN2@Mod_LoadLi
$LN14@Mod_LoadLi:

; 2675 : 	default:
; 2676 : 		Host_Error( "Mod_LoadLighting: bad lightmap sample count %i\n", bmod->lightmap_samples );

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+9376]
	push	eax
	push	OFFSET $SG146586
	call	_Host_Error
	add	esp, 8
$LN2@Mod_LoadLi:

; 2677 : 		break;
; 2678 : 	}
; 2679 : 
; 2680 : 	// not supposed to be load ?
; 2681 : 	if( FBitSet( host.features, ENGINE_LOAD_DELUXEDATA ))

	mov	ecx, DWORD PTR _host+34748
	and	ecx, 4
	je	SHORT $LN15@Mod_LoadLi

; 2682 : 	{
; 2683 : 		Mod_LoadLightVecs( bmod );

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadLightVecs
	add	esp, 4

; 2684 : 		Mod_LoadShadowmap( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadShadowmap
	add	esp, 4

; 2685 : 
; 2686 : 		if( bmod->isworld && bmod->deluxdatasize )

	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9384], 0
	je	SHORT $LN15@Mod_LoadLi
	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+116], 0
	je	SHORT $LN15@Mod_LoadLi

; 2687 : 			SetBits( world.flags, FWORLD_HAS_DELUXEMAP );

	mov	eax, DWORD PTR _world+4
	or	eax, 8
	mov	DWORD PTR _world+4, eax
$LN15@Mod_LoadLi:

; 2688 : 	}
; 2689 : 
; 2690 : 	surf = loadmodel->surfaces;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR _surf$[ebp], edx

; 2691 : 
; 2692 : 	// setup lightdata pointers
; 2693 : 	for( i = 0; i < loadmodel->numsurfaces; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_LoadLi
$LN7@Mod_LoadLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN9@Mod_LoadLi:
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+176]
	jge	$LN1@Mod_LoadLi

; 2694 : 	{
; 2695 : 		if( bmod->version == QBSP2_VERSION )

	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9380], 844124994		; 32505342H
	jne	SHORT $LN17@Mod_LoadLi

; 2696 : 			lightofs = bmod->surfaces32[i].lightofs;

	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _lightofs$[ebp], edx
	jmp	SHORT $LN18@Mod_LoadLi
$LN17@Mod_LoadLi:

; 2697 : 		else lightofs = bmod->surfaces[i].lightofs;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _lightofs$[ebp], eax
$LN18@Mod_LoadLi:

; 2698 : 
; 2699 : 		if( loadmodel->lightdata && lightofs != -1 )

	mov	ecx, DWORD PTR _loadmodel
	cmp	DWORD PTR [ecx+380], 0
	je	SHORT $LN19@Mod_LoadLi
	cmp	DWORD PTR _lightofs$[ebp], -1
	je	SHORT $LN19@Mod_LoadLi

; 2700 : 		{
; 2701 : 			int	offset = (lightofs / bmod->lightmap_samples);

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _lightofs$[ebp]
	cdq
	idiv	DWORD PTR [ecx+9376]
	mov	DWORD PTR _offset$1[ebp], eax

; 2702 : 
; 2703 : 			// NOTE: we divide offset by three because lighting and deluxemap keep their pointers
; 2704 : 			// into three-bytes structs and shadowmap just monochrome
; 2705 : 			surf->samples = loadmodel->lightdata + offset;

	imul	edx, DWORD PTR _offset$1[ebp], 3
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+380]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [ecx+84], edx

; 2706 : 
; 2707 : 			// if deluxemap is present setup it too
; 2708 : 			if( bmod->deluxedata_out )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+144], 0
	je	SHORT $LN20@Mod_LoadLi

; 2709 : 				surf->info->deluxemap = bmod->deluxedata_out + offset;

	imul	eax, DWORD PTR _offset$1[ebp], 3
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+144]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+88], eax
$LN20@Mod_LoadLi:

; 2710 : 
; 2711 : 			// will be used by mods
; 2712 : 			if( bmod->shadowdata_out )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+148], 0
	je	SHORT $LN19@Mod_LoadLi

; 2713 : 				surf->info->shadowmap = bmod->shadowdata_out + offset;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	add	ecx, DWORD PTR _offset$1[ebp]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+92], ecx
$LN19@Mod_LoadLi:

; 2714 : 		}
; 2715 : 	}

	jmp	$LN7@Mod_LoadLi
$LN1@Mod_LoadLi:

; 2716 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadShadowmap PROC

; 2630 : {

	push	ebp
	mov	ebp, esp

; 2631 : 	if( bmod->shadowdatasize != ( bmod->lightdatasize / 3 ))

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [eax+108]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+124], eax
	je	SHORT $LN2@Mod_LoadSh

; 2632 : 	{
; 2633 : 		if( bmod->shadowdatasize > 0 )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jbe	SHORT $LN3@Mod_LoadSh

; 2634 : 			Con_Printf( S_ERROR "Mod_LoadShadowmap: has mismatched size (%i should be %i)\n", bmod->shadowdatasize, bmod->lightdatasize / 3 );

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	push	eax
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	push	OFFSET $SG146557
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN3@Mod_LoadSh:

; 2635 : 		return;

	jmp	SHORT $LN1@Mod_LoadSh
$LN2@Mod_LoadSh:

; 2636 : 	}
; 2637 : 
; 2638 : 	bmod->shadowdata_out = Mem_Malloc( loadmodel->mempool, bmod->shadowdatasize );

	push	2638					; 00000a4eH
	push	OFFSET $SG146558
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [edx+148], eax

; 2639 : 	memcpy( bmod->shadowdata_out, bmod->shadowdata, bmod->shadowdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadSh:

; 2640 : }

	pop	ebp
	ret	0
_Mod_LoadShadowmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadLightVecs PROC

; 2611 : {

	push	ebp
	mov	ebp, esp

; 2612 : 	if( bmod->deluxdatasize != bmod->lightdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [eax+116]
	cmp	edx, DWORD PTR [ecx+108]
	je	SHORT $LN2@Mod_LoadLi

; 2613 : 	{
; 2614 : 		if( bmod->deluxdatasize > 0 )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jbe	SHORT $LN3@Mod_LoadLi

; 2615 : 			Con_Printf( S_ERROR "Mod_LoadLightVecs: has mismatched size (%i should be %i)\n", bmod->deluxdatasize, bmod->lightdatasize );

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	push	OFFSET $SG146549
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@Mod_LoadLi
$LN3@Mod_LoadLi:

; 2616 : 		else Mod_LoadDeluxemap( bmod ); // old method

	mov	edx, DWORD PTR _bmod$[ebp]
	push	edx
	call	_Mod_LoadDeluxemap
	add	esp, 4
$LN4@Mod_LoadLi:

; 2617 : 		return;

	jmp	SHORT $LN1@Mod_LoadLi
$LN2@Mod_LoadLi:

; 2618 : 	}
; 2619 : 
; 2620 : 	bmod->deluxedata_out = Mem_Malloc( loadmodel->mempool, bmod->deluxdatasize );

	push	2620					; 00000a3cH
	push	OFFSET $SG146550
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+144], eax

; 2621 : 	memcpy( bmod->deluxedata_out, bmod->deluxdata, bmod->deluxdatasize );

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+116]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadLi:

; 2622 : }

	pop	ebp
	ret	0
_Mod_LoadLightVecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadVisibility PROC

; 2600 : {

	push	ebp
	mov	ebp, esp

; 2601 : 	loadmodel->visdata = Mem_Malloc( loadmodel->mempool, bmod->visdatasize );

	push	2601					; 00000a29H
	push	OFFSET $SG146541
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+376], eax

; 2602 : 	memcpy( loadmodel->visdata, bmod->visdata, bmod->visdatasize );

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+100]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+376]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2603 : }

	pop	ebp
	ret	0
_Mod_LoadVisibility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_in$1 = -16						; size = 4
_in$2 = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadClipnodes PROC

; 2554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 2555 : 	dclipnode32_t	*out;
; 2556 : 	int		i;
; 2557 : 
; 2558 : 	bmod->clipnodes_out = out = (dclipnode32_t *)Mem_Malloc( loadmodel->mempool, bmod->numclipnodes * sizeof( *out ));	

	push	2558					; 000009feH
	push	OFFSET $SG146531
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+44], 12
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+152], edx

; 2559 : 
; 2560 : 	if(( bmod->version == QBSP2_VERSION ) || ( bmod->version == HLBSP_VERSION && bmod->numclipnodes >= MAX_MAP_CLIPNODES ))

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	je	SHORT $LN10@Mod_LoadCl
	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9380], 30		; 0000001eH
	jne	$LN8@Mod_LoadCl
	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+44], 32767		; 00007fffH
	jl	$LN8@Mod_LoadCl
$LN10@Mod_LoadCl:

; 2561 : 	{
; 2562 : 		dclipnode32_t	*in = bmod->clipnodes32;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _in$2[ebp], ecx

; 2563 : 
; 2564 : 		for( i = 0; i < bmod->numclipnodes; i++, out++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadCl
$LN2@Mod_LoadCl:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$2[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _in$2[ebp], ecx
$LN4@Mod_LoadCl:
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+44]
	jge	SHORT $LN3@Mod_LoadCl

; 2565 : 		{
; 2566 : 			out->planenum = in->planenum;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 2567 : 			out->children[0] = in->children[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [eax+ecx+4], edx

; 2568 : 			out->children[1] = in->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+4], eax

; 2569 : 		}

	jmp	SHORT $LN2@Mod_LoadCl
$LN3@Mod_LoadCl:

; 2570 : 	}

	jmp	$LN9@Mod_LoadCl
$LN8@Mod_LoadCl:

; 2571 : 	else
; 2572 : 	{
; 2573 : 		dclipnode_t	*in = bmod->clipnodes;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _in$1[ebp], edx

; 2574 : 
; 2575 : 		for( i = 0; i < bmod->numclipnodes; i++, out++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadCl
$LN5@Mod_LoadCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _in$1[ebp]
	add	edx, 8
	mov	DWORD PTR _in$1[ebp], edx
$LN7@Mod_LoadCl:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+44]
	jge	$LN9@Mod_LoadCl

; 2576 : 		{
; 2577 : 			out->planenum = in->planenum;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 2578 : 
; 2579 : 			out->children[0] = (unsigned short)in->children[0];

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$1[ebp]
	movzx	eax, WORD PTR [ecx+eax+4]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+edx+4], eax

; 2580 : 			out->children[1] = (unsigned short)in->children[1];

	mov	edx, 2
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _in$1[ebp]
	movzx	edx, WORD PTR [ecx+edx+4]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 2581 : 
; 2582 : 			// Arguire QBSP 'broken' clipnodes
; 2583 : 			if( out->children[0] >= bmod->numclipnodes )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	cmp	eax, DWORD PTR [edx+44]
	jl	SHORT $LN11@Mod_LoadCl

; 2584 : 				out->children[0] -= 65536;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	sub	ecx, 65536				; 00010000H
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+eax+4], ecx
$LN11@Mod_LoadCl:

; 2585 : 			if( out->children[1] >= bmod->numclipnodes )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	cmp	eax, DWORD PTR [edx+44]
	jl	SHORT $LN12@Mod_LoadCl

; 2586 : 				out->children[1] -= 65536;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	sub	eax, 65536				; 00010000H
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+ecx+4], eax
$LN12@Mod_LoadCl:

; 2587 : 		}

	jmp	$LN5@Mod_LoadCl
$LN9@Mod_LoadCl:

; 2588 : 	}
; 2589 : 
; 2590 : 	// FIXME: fill loadmodel->clipnodes?
; 2591 : 	loadmodel->numclipnodes = bmod->numclipnodes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+192], edx

; 2592 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadClipnodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_visclusters$ = -28					; size = 4
_p$ = -24						; size = 4
_i$ = -20						; size = 4
_in$1 = -16						; size = 4
_in$2 = -12						; size = 4
_out$ = -8						; size = 4
_j$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadLeafs PROC

; 2453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 2454 : 	mleaf_t	*out;
; 2455 : 	int	i, j, p;
; 2456 : 	int	visclusters = 0;

	mov	DWORD PTR _visclusters$[ebp], 0

; 2457 : 
; 2458 : 	loadmodel->leafs = out = (mleaf_t *)Mem_Calloc( loadmodel->mempool, bmod->numleafs * sizeof( *out ));

	push	2458					; 0000099aH
	push	OFFSET $SG146497
	push	1
	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+36], 60
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+140], edx

; 2459 : 	loadmodel->numleafs = bmod->numleafs;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+136], edx

; 2460 : 
; 2461 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN20@Mod_LoadLe

; 2462 : 	{
; 2463 : 		visclusters = loadmodel->submodels[0].visleafs;

	mov	ecx, 64					; 00000040H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+124]
	mov	edx, DWORD PTR [ecx+edx+52]
	mov	DWORD PTR _visclusters$[ebp], edx

; 2464 : 		world.visbytes = (visclusters + 7) >> 3;

	mov	eax, DWORD PTR _visclusters$[ebp]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _world+2592, eax

; 2465 : 		world.fatbytes = (visclusters + 31) >> 3;

	mov	ecx, DWORD PTR _visclusters$[ebp]
	add	ecx, 31					; 0000001fH
	sar	ecx, 3
	mov	DWORD PTR _world+2596, ecx
$LN20@Mod_LoadLe:

; 2466 : 	}
; 2467 : 
; 2468 : 	for( i = 0; i < bmod->numleafs; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadLe
$LN2@Mod_LoadLe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR _out$[ebp], eax
$LN4@Mod_LoadLe:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jge	$LN3@Mod_LoadLe

; 2469 : 	{
; 2470 : 		if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	$LN21@Mod_LoadLe

; 2471 : 		{
; 2472 : 			dleaf32_t	*in = &bmod->leafs32[i];

	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	edx, DWORD PTR _bmod$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _in$2[ebp], ecx

; 2473 : 
; 2474 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadLe
$LN5@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@Mod_LoadLe

; 2475 : 			{
; 2476 : 				out->minmaxs[j+0] = in->mins[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 2477 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [esi+eax*4+20]
	mov	DWORD PTR [edx+ecx*4+20], eax

; 2478 : 			}

	jmp	SHORT $LN5@Mod_LoadLe
$LN6@Mod_LoadLe:

; 2479 : 
; 2480 : 			out->contents = in->contents;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 2481 : 			p = in->visofs;

	mov	ecx, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[ebp], edx

; 2482 : 
; 2483 : 			for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadLe
$LN8@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Mod_LoadLe

; 2484 : 				out->ambient_sound_level[j] = in->ambient_level[j];

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$2[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+56], al
	jmp	SHORT $LN8@Mod_LoadLe
$LN9@Mod_LoadLe:

; 2485 : 
; 2486 : 			out->firstmarksurface = loadmodel->marksurfaces + in->firstmarksurface;

	mov	ecx, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+204]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+44], edx

; 2487 : 			out->nummarksurfaces = in->nummarksurfaces;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+48], eax

; 2488 : 		}

	jmp	$LN22@Mod_LoadLe
$LN21@Mod_LoadLe:

; 2489 : 		else
; 2490 : 		{
; 2491 : 			dleaf_t	*in = &bmod->leafs[i];

	imul	ecx, DWORD PTR _i$[ebp], 28
	mov	edx, DWORD PTR _bmod$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _in$1[ebp], ecx

; 2492 : 
; 2493 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadLe
$LN11@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN12@Mod_LoadLe

; 2494 : 			{
; 2495 : 				out->minmaxs[j+0] = in->mins[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$1[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+8]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx*4+8], xmm0

; 2496 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+14]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+20], xmm0

; 2497 : 			}

	jmp	SHORT $LN11@Mod_LoadLe
$LN12@Mod_LoadLe:

; 2498 : 
; 2499 : 			out->contents = in->contents;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 2500 : 			p = in->visofs;

	mov	edx, DWORD PTR _in$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _p$[ebp], eax

; 2501 : 
; 2502 : 			for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadLe
$LN14@Mod_LoadLe:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN16@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN15@Mod_LoadLe

; 2503 : 				out->ambient_sound_level[j] = in->ambient_level[j];

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _in$1[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+56], cl
	jmp	SHORT $LN14@Mod_LoadLe
$LN15@Mod_LoadLe:

; 2504 : 
; 2505 : 			out->firstmarksurface = loadmodel->marksurfaces + in->firstmarksurface;

	mov	edx, DWORD PTR _in$1[ebp]
	movzx	eax, WORD PTR [edx+20]
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+204]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2506 : 			out->nummarksurfaces = in->nummarksurfaces;

	mov	edx, DWORD PTR _in$1[ebp]
	movzx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN22@Mod_LoadLe:

; 2507 : 		}
; 2508 : 
; 2509 : 		if( bmod->isworld )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9384], 0
	je	SHORT $LN23@Mod_LoadLe

; 2510 : 		{
; 2511 : 			out->cluster = ( i - 1 ); // solid leaf 0 has no visdata

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 2512 : 
; 2513 : 			if( out->cluster >= visclusters )

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	eax, DWORD PTR _visclusters$[ebp]
	jl	SHORT $LN25@Mod_LoadLe

; 2514 : 				out->cluster = -1;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+52], -1
$LN25@Mod_LoadLe:

; 2515 : 
; 2516 : 			// ignore visofs errors on leaf 0 (solid)
; 2517 : 			if( p >= 0 && out->cluster >= 0 && loadmodel->visdata )

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN28@Mod_LoadLe
	mov	edx, DWORD PTR _out$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jl	SHORT $LN28@Mod_LoadLe
	mov	eax, DWORD PTR _loadmodel
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN28@Mod_LoadLe

; 2518 : 			{
; 2519 : 				if( p < bmod->visdatasize )

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+100]
	jae	SHORT $LN27@Mod_LoadLe

; 2520 : 					out->compressed_vis = loadmodel->visdata + p;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+376]
	add	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN28@Mod_LoadLe
$LN27@Mod_LoadLe:

; 2521 : 				else Con_Reportf( S_WARN "Mod_LoadLeafs: invalid visofs for leaf #%i\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG146507
	call	_Con_Reportf
	add	esp, 8
$LN28@Mod_LoadLe:

; 2522 : 			}
; 2523 : 	          }

	jmp	SHORT $LN24@Mod_LoadLe
$LN23@Mod_LoadLe:

; 2524 : 		else out->cluster = -1; // no visclusters on bmodels

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+52], -1
$LN24@Mod_LoadLe:

; 2525 : 
; 2526 : 		if( p == -1 ) out->compressed_vis = NULL;

	cmp	DWORD PTR _p$[ebp], -1
	jne	SHORT $LN29@Mod_LoadLe
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], 0
	jmp	SHORT $LN30@Mod_LoadLe
$LN29@Mod_LoadLe:

; 2527 : 		else out->compressed_vis = loadmodel->visdata + p;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+376]
	add	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN30@Mod_LoadLe:

; 2528 : 
; 2529 : 		// gl underwater warp
; 2530 : 		if( out->contents != CONTENTS_EMPTY )

	mov	eax, DWORD PTR _out$[ebp]
	cmp	DWORD PTR [eax], -1
	je	SHORT $LN18@Mod_LoadLe

; 2531 : 		{
; 2532 : 			for( j = 0; j < out->nummarksurfaces; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN19@Mod_LoadLe
$LN17@Mod_LoadLe:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN19@Mod_LoadLe:
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	SHORT $LN18@Mod_LoadLe

; 2533 : 			{
; 2534 : 				// mark underwater surfaces
; 2535 : 				SetBits( out->firstmarksurface[j]->flags, SURF_UNDERWATER );

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+8], edx

; 2536 : 			}

	jmp	SHORT $LN17@Mod_LoadLe
$LN18@Mod_LoadLe:

; 2537 : 		}
; 2538 : 	}

	jmp	$LN2@Mod_LoadLe
$LN3@Mod_LoadLe:

; 2539 : 
; 2540 : 	if( bmod->isworld && loadmodel->leafs[0].contents != CONTENTS_SOLID )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9384], 0
	je	SHORT $LN32@Mod_LoadLe
	mov	eax, 60					; 0000003cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+140]
	cmp	DWORD PTR [eax+ecx], -2			; fffffffeH
	je	SHORT $LN32@Mod_LoadLe

; 2541 : 		Host_Error( "Mod_LoadLeafs: Map %s has leaf 0 is not CONTENTS_SOLID\n", loadmodel->name );

	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET $SG146512
	call	_Host_Error
	add	esp, 8
$LN32@Mod_LoadLe:

; 2542 : 
; 2543 : 	// do some final things for world
; 2544 : 	if( bmod->isworld && Mod_CheckWaterAlphaSupport( bmod ))

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9384], 0
	je	SHORT $LN33@Mod_LoadLe
	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_CheckWaterAlphaSupport
	add	esp, 4
	test	eax, eax
	je	SHORT $LN33@Mod_LoadLe

; 2545 : 		SetBits( world.flags, FWORLD_WATERALPHA );

	mov	ecx, DWORD PTR _world+4
	or	ecx, 4
	mov	DWORD PTR _world+4, ecx
$LN33@Mod_LoadLe:

; 2546 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLeafs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_i$ = -24						; size = 4
_in$1 = -20						; size = 4
_in$2 = -16						; size = 4
_p$ = -12						; size = 4
_out$ = -8						; size = 4
_j$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadNodes PROC

; 2388 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 2389 : 	mnode_t	*out;
; 2390 : 	int	i, j, p;
; 2391 : 
; 2392 : 	loadmodel->nodes = out = (mnode_t *)Mem_Calloc( loadmodel->mempool, bmod->numnodes * sizeof( *out ));

	push	2392					; 00000958H
	push	OFFSET $SG146459
	push	1
	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+28], 52
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+164], edx

; 2393 : 	loadmodel->numnodes = bmod->numnodes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+160], edx

; 2394 : 
; 2395 : 	for( i = 0; i < loadmodel->numnodes; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadNo
$LN2@Mod_LoadNo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _out$[ebp], ecx
$LN4@Mod_LoadNo:
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+160]
	jge	$LN3@Mod_LoadNo

; 2396 : 	{
; 2397 : 		if( bmod->version == QBSP2_VERSION )

	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9380], 844124994		; 32505342H
	jne	$LN17@Mod_LoadNo

; 2398 : 		{
; 2399 : 			dnode32_t	*in = &bmod->nodes32[i];

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _bmod$[ebp]
	add	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _in$2[ebp], edx

; 2400 : 
; 2401 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadNo
$LN5@Mod_LoadNo:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@Mod_LoadNo

; 2402 : 			{
; 2403 : 				out->minmaxs[j+0] = in->mins[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+12]
	mov	DWORD PTR [eax+edx*4+8], ecx

; 2404 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+24]
	mov	DWORD PTR [eax+edx*4+20], ecx

; 2405 : 			}

	jmp	SHORT $LN5@Mod_LoadNo
$LN6@Mod_LoadNo:

; 2406 : 
; 2407 : 			p = in->planenum;

	mov	edx, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _p$[ebp], eax

; 2408 : 			out->plane = loadmodel->planes + p;

	imul	ecx, DWORD PTR _p$[ebp], 20
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 2409 : 			out->firstsurface = in->firstface;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$2[ebp]
	mov	ax, WORD PTR [edx+36]
	mov	WORD PTR [ecx+48], ax

; 2410 : 			out->numsurfaces = in->numfaces;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$2[ebp]
	mov	ax, WORD PTR [edx+40]
	mov	WORD PTR [ecx+50], ax

; 2411 : 
; 2412 : 			for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadNo
$LN8@Mod_LoadNo:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN9@Mod_LoadNo

; 2413 : 			{
; 2414 : 				p = in->children[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _p$[ebp], ecx

; 2415 : 				if( p >= 0 ) out->children[j] = loadmodel->nodes + p;

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN19@Mod_LoadNo
	imul	edx, DWORD PTR _p$[ebp], 52
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+164]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+ecx*4+40], edx
	jmp	SHORT $LN20@Mod_LoadNo
$LN19@Mod_LoadNo:

; 2416 : 				else out->children[j] = (mnode_t *)(loadmodel->leafs + ( -1 - p ));

	or	ecx, -1
	sub	ecx, DWORD PTR _p$[ebp]
	imul	edx, ecx, 60
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+ecx*4+40], edx
$LN20@Mod_LoadNo:

; 2417 : 			}

	jmp	SHORT $LN8@Mod_LoadNo
$LN9@Mod_LoadNo:

; 2418 : 		}

	jmp	$LN15@Mod_LoadNo
$LN17@Mod_LoadNo:

; 2419 : 		else
; 2420 : 		{
; 2421 : 			dnode_t	*in = &bmod->nodes[i];

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _bmod$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _in$1[ebp], ecx

; 2422 : 
; 2423 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadNo
$LN11@Mod_LoadNo:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN12@Mod_LoadNo

; 2424 : 			{
; 2425 : 				out->minmaxs[j+0] = in->mins[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$1[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+8]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx*4+8], xmm0

; 2426 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+14]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+20], xmm0

; 2427 : 			}

	jmp	SHORT $LN11@Mod_LoadNo
$LN12@Mod_LoadNo:

; 2428 : 
; 2429 : 			p = in->planenum;

	mov	edx, DWORD PTR _in$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _p$[ebp], eax

; 2430 : 			out->plane = loadmodel->planes + p;

	imul	ecx, DWORD PTR _p$[ebp], 20
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 2431 : 			out->firstsurface = in->firstface;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$1[ebp]
	mov	ax, WORD PTR [edx+20]
	mov	WORD PTR [ecx+48], ax

; 2432 : 			out->numsurfaces = in->numfaces;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$1[ebp]
	mov	ax, WORD PTR [edx+22]
	mov	WORD PTR [ecx+50], ax

; 2433 : 
; 2434 : 			for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadNo
$LN14@Mod_LoadNo:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN16@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN15@Mod_LoadNo

; 2435 : 			{
; 2436 : 				p = in->children[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _in$1[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+4]
	mov	DWORD PTR _p$[ebp], ecx

; 2437 : 				if( p >= 0 ) out->children[j] = loadmodel->nodes + p;

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN21@Mod_LoadNo
	imul	edx, DWORD PTR _p$[ebp], 52
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+164]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+ecx*4+40], edx
	jmp	SHORT $LN22@Mod_LoadNo
$LN21@Mod_LoadNo:

; 2438 : 				else out->children[j] = (mnode_t *)(loadmodel->leafs + ( -1 - p ));

	or	ecx, -1
	sub	ecx, DWORD PTR _p$[ebp]
	imul	edx, ecx, 60
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+ecx*4+40], edx
$LN22@Mod_LoadNo:

; 2439 : 			}

	jmp	SHORT $LN14@Mod_LoadNo
$LN15@Mod_LoadNo:

; 2440 : 		}
; 2441 : 	}

	jmp	$LN2@Mod_LoadNo
$LN3@Mod_LoadNo:

; 2442 : 
; 2443 : 	// sets nodes and leafs
; 2444 : 	Mod_SetParent( loadmodel->nodes, NULL );

	push	0
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	_Mod_SetParent
	add	esp, 8

; 2445 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_tmax$1 = -72						; size = 4
_smax$2 = -68						; size = 4
tv367 = -64						; size = 4
tv360 = -60						; size = 4
_sample_size$3 = -56					; size = 4
_lightstyles$4 = -52					; size = 4
_prev_lightofs$ = -48					; size = 4
_info$ = -44						; size = 4
_i$ = -40						; size = 4
_samples$5 = -36					; size = 4
_next_lightofs$ = -32					; size = 4
_lightofs$ = -28					; size = 4
_tex$6 = -24						; size = 4
_in$7 = -20						; size = 4
_in$8 = -16						; size = 4
_test_lightsize$ = -12					; size = 4
_j$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadSurfaces PROC

; 2236 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 2237 : 	int		test_lightsize = -1;

	mov	DWORD PTR _test_lightsize$[ebp], -1

; 2238 : 	int		next_lightofs = -1;

	mov	DWORD PTR _next_lightofs$[ebp], -1

; 2239 : 	int		prev_lightofs = -1;

	mov	DWORD PTR _prev_lightofs$[ebp], -1

; 2240 : 	int		i, j, lightofs;
; 2241 : 	mextrasurf_t	*info;
; 2242 : 	msurface_t	*out;
; 2243 : 
; 2244 : 	loadmodel->surfaces = out = Mem_Calloc( loadmodel->mempool, bmod->numsurfaces * sizeof( msurface_t ));

	push	2244					; 000008c4H
	push	OFFSET $SG146387
	push	1
	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+84], 92
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+180], edx

; 2245 : 	info = Mem_Calloc( loadmodel->mempool, bmod->numsurfaces * sizeof( mextrasurf_t ));

	push	2245					; 000008c5H
	push	OFFSET $SG146388
	push	1
	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+84], 324
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _info$[ebp], eax

; 2246 : 	loadmodel->numsurfaces = bmod->numsurfaces;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+176], eax

; 2247 : 
; 2248 : 	// predict samplecount based on bspversion
; 2249 : 	if( bmod->version == Q1BSP_VERSION || bmod->version == QBSP2_VERSION )

	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9380], 29		; 0000001dH
	je	SHORT $LN16@Mod_LoadSu
	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9380], 844124994		; 32505342H
	jne	SHORT $LN14@Mod_LoadSu
$LN16@Mod_LoadSu:

; 2250 : 		bmod->lightmap_samples = 1;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [eax+9376], 1
	jmp	SHORT $LN15@Mod_LoadSu
$LN14@Mod_LoadSu:

; 2251 : 	else bmod->lightmap_samples = 3;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+9376], 3
$LN15@Mod_LoadSu:

; 2252 : 
; 2253 : 	for( i = 0; i < bmod->numsurfaces; i++, out++, info++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadSu
$LN2@Mod_LoadSu:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 92					; 0000005cH
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 324				; 00000144H
	mov	DWORD PTR _info$[ebp], ecx
$LN4@Mod_LoadSu:
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+84]
	jae	$LN3@Mod_LoadSu

; 2254 : 	{
; 2255 : 		texture_t	*tex;
; 2256 : 
; 2257 : 		// setup crosslinks between two parts of msurface_t
; 2258 : 		out->info = info;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+80], edx

; 2259 : 		info->surf = out;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 2260 : 
; 2261 : 		if( bmod->version == QBSP2_VERSION )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9380], 844124994		; 32505342H
	jne	$LN17@Mod_LoadSu

; 2262 : 		{
; 2263 : 			dface32_t	*in = &bmod->surfaces32[i];

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR _in$8[ebp], eax

; 2264 : 
; 2265 : 			if(( in->firstedge + in->numedges ) > loadmodel->numsurfedges )

	mov	edx, DWORD PTR _in$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _in$8[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _loadmodel
	cmp	eax, DWORD PTR [edx+184]
	jle	SHORT $LN19@Mod_LoadSu

; 2266 : 				continue;	// corrupted level?

	jmp	SHORT $LN2@Mod_LoadSu
$LN19@Mod_LoadSu:

; 2267 : 			out->firstedge = in->firstedge;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 2268 : 			out->numedges = in->numedges;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$8[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+16], edx

; 2269 : 			if( in->side ) SetBits( out->flags, SURF_PLANEBACK );

	mov	eax, DWORD PTR _in$8[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN20@Mod_LoadSu
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 2
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN20@Mod_LoadSu:

; 2270 : 			out->plane = loadmodel->planes + in->planenum;

	mov	ecx, DWORD PTR _in$8[ebp]
	imul	edx, DWORD PTR [ecx], 20
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2271 : 			out->texinfo = loadmodel->texinfo + in->texinfo;

	mov	edx, DWORD PTR _in$8[ebp]
	imul	eax, DWORD PTR [edx+16], 44
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+172]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+44], eax

; 2272 : 
; 2273 : 			for( j = 0; j < MAXLIGHTMAPS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadSu
$LN5@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_LoadSu

; 2274 : 				out->styles[j] = in->styles[j];

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$8[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+60], al
	jmp	SHORT $LN5@Mod_LoadSu
$LN6@Mod_LoadSu:

; 2275 : 			lightofs = in->lightofs;

	mov	ecx, DWORD PTR _in$8[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _lightofs$[ebp], edx

; 2276 : 		}

	jmp	$LN18@Mod_LoadSu
$LN17@Mod_LoadSu:

; 2277 : 		else
; 2278 : 		{
; 2279 : 			dface_t	*in = &bmod->surfaces[i];

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR _in$7[ebp], eax

; 2280 : 
; 2281 : 			if(( in->firstedge + in->numedges ) > loadmodel->numsurfedges )

	mov	edx, DWORD PTR _in$7[ebp]
	movsx	eax, WORD PTR [edx+8]
	mov	ecx, DWORD PTR _in$7[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _loadmodel
	cmp	eax, DWORD PTR [edx+184]
	jle	SHORT $LN21@Mod_LoadSu

; 2282 : 			{
; 2283 : 				Con_Reportf( S_ERROR "bad surface %i from %i\n", i, bmod->numsurfaces );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG146397
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2284 : 				continue;

	jmp	$LN2@Mod_LoadSu
$LN21@Mod_LoadSu:

; 2285 : 			}
; 2286 : 
; 2287 : 			out->firstedge = in->firstedge;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$7[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx

; 2288 : 			out->numedges = in->numedges;

	mov	eax, DWORD PTR _in$7[ebp]
	movsx	ecx, WORD PTR [eax+8]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 2289 : 			if( in->side ) SetBits( out->flags, SURF_PLANEBACK );

	mov	eax, DWORD PTR _in$7[ebp]
	movsx	ecx, WORD PTR [eax+2]
	test	ecx, ecx
	je	SHORT $LN22@Mod_LoadSu
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+8]
	or	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN22@Mod_LoadSu:

; 2290 : 			out->plane = loadmodel->planes + in->planenum;

	mov	edx, DWORD PTR _in$7[ebp]
	movzx	eax, WORD PTR [edx]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2291 : 			out->texinfo = loadmodel->texinfo + in->texinfo;

	mov	ecx, DWORD PTR _in$7[ebp]
	movsx	edx, WORD PTR [ecx+10]
	imul	eax, edx, 44
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+172]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+44], eax

; 2292 : 
; 2293 : 			for( j = 0; j < MAXLIGHTMAPS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadSu
$LN8@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Mod_LoadSu

; 2294 : 				out->styles[j] = in->styles[j];

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$7[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR [edx+12]
	mov	BYTE PTR [ecx+60], al
	jmp	SHORT $LN8@Mod_LoadSu
$LN9@Mod_LoadSu:

; 2295 : 			lightofs = in->lightofs;

	mov	ecx, DWORD PTR _in$7[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _lightofs$[ebp], edx
$LN18@Mod_LoadSu:

; 2296 : 		}
; 2297 : 
; 2298 : 		tex = out->texinfo->texture;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _tex$6[ebp], edx

; 2299 : 
; 2300 : 		if( !Q_strncmp( tex->name, "sky", 3 ))

	push	3
	push	OFFSET $SG146400
	mov	eax, DWORD PTR _tex$6[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@Mod_LoadSu

; 2301 : 			SetBits( out->flags, SURF_DRAWSKY );

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 4
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN23@Mod_LoadSu:

; 2302 : 
; 2303 : 		if(( tex->name[0] == '*' && Q_stricmp( tex->name, "*default" )) || tex->name[0] == '!' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _tex$6[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN26@Mod_LoadSu
	push	99999					; 0001869fH
	push	OFFSET $SG146404
	mov	edx, DWORD PTR _tex$6[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@Mod_LoadSu
$LN26@Mod_LoadSu:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$6[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN24@Mod_LoadSu
$LN25@Mod_LoadSu:

; 2304 : 			SetBits( out->flags, SURF_DRAWTURB );

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN24@Mod_LoadSu:

; 2305 : 
; 2306 : 		if( !CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN28@Mod_LoadSu

; 2307 : 		{
; 2308 : 			if( !Q_strncmp( tex->name, "water", 5 ) || !Q_strnicmp( tex->name, "laser", 5 ))

	push	5
	push	OFFSET $SG146408
	mov	ecx, DWORD PTR _tex$6[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN29@Mod_LoadSu
	push	5
	push	OFFSET $SG146409
	mov	edx, DWORD PTR _tex$6[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@Mod_LoadSu
$LN29@Mod_LoadSu:

; 2309 : 				SetBits( out->flags, SURF_DRAWTURB );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN28@Mod_LoadSu:

; 2310 : 		}
; 2311 : 
; 2312 : 		if( !Q_strncmp( tex->name, "scroll", 6 ))

	push	6
	push	OFFSET $SG146411
	mov	eax, DWORD PTR _tex$6[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@Mod_LoadSu

; 2313 : 			SetBits( out->flags, SURF_CONVEYOR );

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN30@Mod_LoadSu:

; 2314 : 
; 2315 : 		if( FBitSet( out->texinfo->flags, TEX_SCROLL ))

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 64					; 00000040H
	je	SHORT $LN31@Mod_LoadSu

; 2316 : 			SetBits( out->flags, SURF_CONVEYOR );

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN31@Mod_LoadSu:

; 2317 : 
; 2318 : 		// g-cont. added a combined conveyor-transparent
; 2319 : 		if( !Q_strncmp( tex->name, "{scroll", 7 ))

	push	7
	push	OFFSET $SG146414
	mov	ecx, DWORD PTR _tex$6[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@Mod_LoadSu

; 2320 : 			SetBits( out->flags, SURF_CONVEYOR|SURF_TRANSPARENT );

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+8]
	or	eax, 320				; 00000140H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN32@Mod_LoadSu:

; 2321 : 
; 2322 : 		if( tex->name[0] == '{' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _tex$6[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 123				; 0000007bH
	jne	SHORT $LN33@Mod_LoadSu

; 2323 : 			SetBits( out->flags, SURF_TRANSPARENT );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN33@Mod_LoadSu:

; 2324 : 
; 2325 : 		if( FBitSet( out->texinfo->flags, TEX_SPECIAL ))

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 1
	je	SHORT $LN34@Mod_LoadSu

; 2326 : 			SetBits( out->flags, SURF_DRAWTILED );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN34@Mod_LoadSu:

; 2327 : 
; 2328 : 		Mod_CalcSurfaceBounds( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_Mod_CalcSurfaceBounds
	add	esp, 4

; 2329 : 		Mod_CalcSurfaceExtents( out );

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_Mod_CalcSurfaceExtents
	add	esp, 4

; 2330 : 		Mod_CreateFaceBevels( out );

	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_Mod_CreateFaceBevels
	add	esp, 4

; 2331 : 
; 2332 : 		// grab the second sample to detect colored lighting
; 2333 : 		if( test_lightsize > 0 && lightofs != -1 )

	cmp	DWORD PTR _test_lightsize$[ebp], 0
	jle	SHORT $LN36@Mod_LoadSu
	cmp	DWORD PTR _lightofs$[ebp], -1
	je	SHORT $LN36@Mod_LoadSu

; 2334 : 		{
; 2335 : 			if( lightofs > prev_lightofs && lightofs < next_lightofs )

	mov	eax, DWORD PTR _lightofs$[ebp]
	cmp	eax, DWORD PTR _prev_lightofs$[ebp]
	jle	SHORT $LN36@Mod_LoadSu
	mov	ecx, DWORD PTR _lightofs$[ebp]
	cmp	ecx, DWORD PTR _next_lightofs$[ebp]
	jge	SHORT $LN36@Mod_LoadSu

; 2336 : 				next_lightofs = lightofs;

	mov	edx, DWORD PTR _lightofs$[ebp]
	mov	DWORD PTR _next_lightofs$[ebp], edx
$LN36@Mod_LoadSu:

; 2337 : 		}
; 2338 : 
; 2339 : 		// grab the first sample to determine lightmap size
; 2340 : 		if( lightofs != -1 && test_lightsize == -1 )

	cmp	DWORD PTR _lightofs$[ebp], -1
	je	$LN37@Mod_LoadSu
	cmp	DWORD PTR _test_lightsize$[ebp], -1
	jne	$LN37@Mod_LoadSu

; 2341 : 		{
; 2342 : 			int	sample_size = Mod_SampleSizeForFace( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$3[ebp], eax

; 2343 : 			int	smax = (info->lightextents[0] / sample_size) + 1;

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [eax+edx+52]
	cdq
	idiv	DWORD PTR _sample_size$3[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$2[ebp], eax

; 2344 : 			int	tmax = (info->lightextents[1] / sample_size) + 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$3[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$1[ebp], eax

; 2345 : 			int	lightstyles = 0;

	mov	DWORD PTR _lightstyles$4[ebp], 0

; 2346 : 
; 2347 : 			test_lightsize = smax * tmax;

	mov	eax, DWORD PTR _smax$2[ebp]
	imul	eax, DWORD PTR _tmax$1[ebp]
	mov	DWORD PTR _test_lightsize$[ebp], eax

; 2348 : 			// count styles to right compute test_lightsize
; 2349 : 			for( j = 0; j < MAXLIGHTMAPS && out->styles[j] != 255; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadSu
$LN11@Mod_LoadSu:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN13@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN12@Mod_LoadSu
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN12@Mod_LoadSu

; 2350 : 				lightstyles++;

	mov	ecx, DWORD PTR _lightstyles$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _lightstyles$4[ebp], ecx
	jmp	SHORT $LN11@Mod_LoadSu
$LN12@Mod_LoadSu:

; 2351 : 
; 2352 : 			test_lightsize *= lightstyles;

	mov	edx, DWORD PTR _test_lightsize$[ebp]
	imul	edx, DWORD PTR _lightstyles$4[ebp]
	mov	DWORD PTR _test_lightsize$[ebp], edx

; 2353 : 			prev_lightofs = lightofs;

	mov	eax, DWORD PTR _lightofs$[ebp]
	mov	DWORD PTR _prev_lightofs$[ebp], eax

; 2354 : 			next_lightofs = 99999999;

	mov	DWORD PTR _next_lightofs$[ebp], 99999999 ; 05f5e0ffH
$LN37@Mod_LoadSu:

; 2355 : 		}
; 2356 : 
; 2357 : 		if( FBitSet( out->flags, SURF_DRAWTURB ))

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16					; 00000010H
	je	SHORT $LN38@Mod_LoadSu

; 2358 : 			GL_SubdivideSurface( out ); // cut up polygon for warps

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_SubdivideSurface
	add	esp, 4
$LN38@Mod_LoadSu:

; 2359 : 	}

	jmp	$LN2@Mod_LoadSu
$LN3@Mod_LoadSu:

; 2360 : 
; 2361 : 	// now we have enough data to trying determine samplecount per lightmap pixel
; 2362 : 	if( test_lightsize > 0 && prev_lightofs != -1 && next_lightofs != -1 && next_lightofs != 99999999 )

	cmp	DWORD PTR _test_lightsize$[ebp], 0
	jle	$LN42@Mod_LoadSu
	cmp	DWORD PTR _prev_lightofs$[ebp], -1
	je	$LN42@Mod_LoadSu
	cmp	DWORD PTR _next_lightofs$[ebp], -1
	je	$LN42@Mod_LoadSu
	cmp	DWORD PTR _next_lightofs$[ebp], 99999999 ; 05f5e0ffH
	je	$LN42@Mod_LoadSu

; 2363 : 	{
; 2364 : 		float	samples = (float)(next_lightofs - prev_lightofs) / (float)test_lightsize;

	mov	ecx, DWORD PTR _next_lightofs$[ebp]
	sub	ecx, DWORD PTR _prev_lightofs$[ebp]
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _test_lightsize$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _samples$5[ebp], xmm0

; 2365 : 
; 2366 : 		if( samples != (int)samples )

	cvttss2si edx, DWORD PTR _samples$5[ebp]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _samples$5[ebp]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@Mod_LoadSu

; 2367 : 		{
; 2368 : 			test_lightsize = (test_lightsize + 3) & ~3; // align datasize and try again

	mov	eax, DWORD PTR _test_lightsize$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	DWORD PTR _test_lightsize$[ebp], eax

; 2369 : 			samples = (float)(next_lightofs - prev_lightofs) / (float)test_lightsize;

	mov	ecx, DWORD PTR _next_lightofs$[ebp]
	sub	ecx, DWORD PTR _prev_lightofs$[ebp]
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _test_lightsize$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _samples$5[ebp], xmm0
$LN40@Mod_LoadSu:

; 2370 : 		}
; 2371 : 
; 2372 : 		if( samples == 1 || samples == 3 )

	movss	xmm0, DWORD PTR _samples$5[ebp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN43@Mod_LoadSu
	movss	xmm0, DWORD PTR _samples$5[ebp]
	ucomiss	xmm0, DWORD PTR __real@40400000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN41@Mod_LoadSu
$LN43@Mod_LoadSu:

; 2373 : 		{
; 2374 : 			bmod->lightmap_samples = (int)samples;

	cvttss2si edx, DWORD PTR _samples$5[ebp]
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [eax+9376], edx

; 2375 : 			Con_Reportf( "lighting: %s\n", (bmod->lightmap_samples == 1) ? "monochrome" : "colored" );

	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9376], 1
	jne	SHORT $LN45@Mod_LoadSu
	mov	DWORD PTR tv360[ebp], OFFSET $SG146426
	jmp	SHORT $LN46@Mod_LoadSu
$LN45@Mod_LoadSu:
	mov	DWORD PTR tv360[ebp], OFFSET $SG146427
$LN46@Mod_LoadSu:
	mov	edx, DWORD PTR tv360[ebp]
	push	edx
	push	OFFSET $SG146428
	call	_Con_Reportf
	add	esp, 8

; 2376 : 			bmod->lightmap_samples = Q_max( bmod->lightmap_samples, 1 ); // avoid division by zero

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9376], 1
	jle	SHORT $LN47@Mod_LoadSu
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+9376]
	mov	DWORD PTR tv367[ebp], edx
	jmp	SHORT $LN48@Mod_LoadSu
$LN47@Mod_LoadSu:
	mov	DWORD PTR tv367[ebp], 1
$LN48@Mod_LoadSu:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR tv367[ebp]
	mov	DWORD PTR [eax+9376], ecx

; 2377 : 		}

	jmp	SHORT $LN42@Mod_LoadSu
$LN41@Mod_LoadSu:

; 2378 : 		else Con_DPrintf( S_WARN "lighting invalid samplecount: %g, defaulting to %i\n", samples, bmod->lightmap_samples );

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+9376]
	push	eax
	cvtss2sd xmm0, DWORD PTR _samples$5[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG146429
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN42@Mod_LoadSu:

; 2379 : 	}
; 2380 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_faceinfo$ = -32					; size = 4
_miptex$ = -28						; size = 4
_j$ = -24						; size = 4
_fin$ = -20						; size = 4
_out$ = -16						; size = 4
_i$ = -12						; size = 4
_fout$ = -8						; size = 4
_in$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadTexInfo PROC

; 2190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2191 : 	mfaceinfo_t	*fout, *faceinfo;
; 2192 : 	int		i, j, miptex;
; 2193 : 	dfaceinfo_t	*fin;
; 2194 : 	mtexinfo_t	*out;
; 2195 : 	dtexinfo_t	*in;
; 2196 : 
; 2197 : 	// trying to load faceinfo
; 2198 : 	faceinfo = fout = Mem_Calloc( loadmodel->mempool, bmod->numfaceinfo * sizeof( *fout ));

	push	2198					; 00000896H
	push	OFFSET $SG146342
	push	1
	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+92], 176
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _fout$[ebp], eax
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	DWORD PTR _faceinfo$[ebp], ecx

; 2199 : 	fin = bmod->faceinfo;

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _fin$[ebp], eax

; 2200 : 
; 2201 : 	for( i = 0; i < bmod->numfaceinfo; i++, fin++, fout++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadTe
$LN2@Mod_LoadTe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, 22					; 00000016H
	mov	DWORD PTR _fin$[ebp], edx
	mov	eax, DWORD PTR _fout$[ebp]
	add	eax, 176				; 000000b0H
	mov	DWORD PTR _fout$[ebp], eax
$LN4@Mod_LoadTe:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+92]
	jae	SHORT $LN3@Mod_LoadTe

; 2202 : 	{
; 2203 : 		Q_strncpy( fout->landname, fin->landname, sizeof( fout->landname ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2204 : 		fout->texture_step = fin->texture_step;

	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	mov	cx, WORD PTR [eax+16]
	mov	WORD PTR [edx+16], cx

; 2205 : 		fout->max_extent = fin->max_extent;

	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	mov	cx, WORD PTR [eax+18]
	mov	WORD PTR [edx+18], cx

; 2206 : 		fout->groupid = fin->groupid;

	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	mov	cx, WORD PTR [eax+20]
	mov	WORD PTR [edx+20], cx

; 2207 : 	}

	jmp	SHORT $LN2@Mod_LoadTe
$LN3@Mod_LoadTe:

; 2208 : 
; 2209 : 	loadmodel->texinfo = out = Mem_Calloc( loadmodel->mempool, bmod->numtexinfo * sizeof( *out ));

	push	2209					; 000008a1H
	push	OFFSET $SG146343
	push	1
	mov	edx, DWORD PTR _bmod$[ebp]
	imul	eax, DWORD PTR [edx+52], 44
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+172], ecx

; 2210 : 	loadmodel->numtexinfo = bmod->numtexinfo;

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+168], ecx

; 2211 : 	in = bmod->texinfo;

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _in$[ebp], eax

; 2212 : 
; 2213 : 	for( i = 0; i < bmod->numtexinfo; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadTe
$LN5@Mod_LoadTe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR _in$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _out$[ebp], eax
$LN7@Mod_LoadTe:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jae	$LN6@Mod_LoadTe

; 2214 : 	{
; 2215 : 		for( j = 0; j < 8; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadTe
$LN8@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadTe:
	cmp	DWORD PTR _j$[ebp], 8
	jge	SHORT $LN9@Mod_LoadTe

; 2216 : 			out->vecs[0][j] = in->vecs[0][j];

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _in$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN8@Mod_LoadTe
$LN9@Mod_LoadTe:

; 2217 : 
; 2218 : 		miptex = in->miptex;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _miptex$[ebp], ecx

; 2219 : 		if( miptex < 0 || miptex > loadmodel->numtextures )

	cmp	DWORD PTR _miptex$[ebp], 0
	jl	SHORT $LN12@Mod_LoadTe
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _miptex$[ebp]
	cmp	eax, DWORD PTR [edx+368]
	jle	SHORT $LN11@Mod_LoadTe
$LN12@Mod_LoadTe:

; 2220 : 			miptex = 0; // this is possible?

	mov	DWORD PTR _miptex$[ebp], 0
$LN11@Mod_LoadTe:

; 2221 : 		out->texture = loadmodel->textures[miptex];

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+372]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _miptex$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+36], edx

; 2222 : 		out->flags = in->flags;

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 2223 : 
; 2224 : 		// make sure what faceinfo is really exist
; 2225 : 		if( faceinfo != NULL && in->faceinfo != -1 && in->faceinfo < bmod->numfaceinfo )

	cmp	DWORD PTR _faceinfo$[ebp], 0
	je	SHORT $LN13@Mod_LoadTe
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, WORD PTR [eax+38]
	cmp	ecx, -1
	je	SHORT $LN13@Mod_LoadTe
	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, WORD PTR [edx+38]
	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	eax, DWORD PTR [ecx+92]
	jae	SHORT $LN13@Mod_LoadTe

; 2226 : 			out->faceinfo = &faceinfo[in->faceinfo];

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, WORD PTR [edx+38]
	imul	ecx, eax, 176
	add	ecx, DWORD PTR _faceinfo$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN13@Mod_LoadTe:

; 2227 : 	}

	jmp	$LN5@Mod_LoadTe
$LN6@Mod_LoadTe:

; 2228 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadTexInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_remaining$1 = -228					; size = 4
_size$2 = -224						; size = 4
_srcSize$3 = -220					; size = 4
_texpath$4 = -216					; size = 4
_texpath$5 = -212					; size = 4
_size$6 = -208						; size = 4
_size$7 = -204						; size = 4
_next_dataofs$8 = -200					; size = 4
_src$9 = -196						; size = 4
_custom_palette$ = -192					; size = 4
_txFlags$10 = -188					; size = 4
_in$ = -184						; size = 4
_altmax$ = -180						; size = 4
_num$ = -176						; size = 4
_i$ = -172						; size = 4
_max$ = -168						; size = 4
_tx2$ = -164						; size = 4
_mt$ = -160						; size = 4
_tx$ = -156						; size = 4
_j$ = -152						; size = 4
_anims$ = -148						; size = 40
_altanims$ = -108					; size = 40
_texname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadTextures PROC

; 1901 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1902 : 	dmiptexlump_t	*in;
; 1903 : 	texture_t		*tx, *tx2;
; 1904 : 	texture_t		*anims[10];
; 1905 : 	texture_t		*altanims[10];
; 1906 : 	int		num, max, altmax;
; 1907 : 	qboolean		custom_palette;
; 1908 : 	char		texname[64];
; 1909 : 	mip_t		*mt;
; 1910 : 	int 		i, j; 
; 1911 : 
; 1912 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN26@Mod_LoadTe

; 1913 : 	{
; 1914 : 		// release old sky layers first
; 1915 : 		GL_FreeTexture( tr.solidskyTexture );

	mov	ecx, DWORD PTR _tr+20
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 1916 : 		GL_FreeTexture( tr.alphaskyTexture );

	mov	edx, DWORD PTR _tr+24
	push	edx
	call	_GL_FreeTexture
	add	esp, 4

; 1917 : 		tr.solidskyTexture = 0;

	mov	DWORD PTR _tr+20, 0

; 1918 : 		tr.alphaskyTexture = 0;

	mov	DWORD PTR _tr+24, 0
$LN26@Mod_LoadTe:

; 1919 : 	}
; 1920 : 
; 1921 : 	if( !bmod->texdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+140], 0
	jne	SHORT $LN27@Mod_LoadTe

; 1922 : 	{
; 1923 : 		// no textures
; 1924 : 		loadmodel->textures = NULL;

	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+372], 0

; 1925 : 		return;

	jmp	$LN15@Mod_LoadTe
$LN27@Mod_LoadTe:

; 1926 : 	}
; 1927 : 
; 1928 : 	in = bmod->textures;

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR _in$[ebp], eax

; 1929 : 	loadmodel->textures = (texture_t **)Mem_Calloc( loadmodel->mempool, in->nummiptex * sizeof( texture_t* ));

	push	1929					; 00000789H
	push	OFFSET $SG146261
	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+372], eax

; 1930 : 	loadmodel->numtextures = in->nummiptex;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+368], edx

; 1931 : 
; 1932 : 	for( i = 0; i < loadmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadTe
$LN2@Mod_LoadTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadTe:
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+368]
	jge	$LN3@Mod_LoadTe

; 1933 : 	{
; 1934 : 		int	txFlags = 0;

	mov	DWORD PTR _txFlags$10[ebp], 0

; 1935 : 
; 1936 : 		if( in->dataofs[i] == -1 )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4], -1
	jne	$LN28@Mod_LoadTe

; 1937 : 		{
; 1938 : 			// create default texture (some mods requires this)
; 1939 : 			tx = Mem_Calloc( loadmodel->mempool, sizeof( *tx ));

	push	1939					; 00000793H
	push	OFFSET $SG146263
	push	1
	push	68					; 00000044H
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tx$[ebp], eax

; 1940 : 			loadmodel->textures[i] = tx;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+372]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1941 : 
; 1942 : 			Q_strncpy( tx->name, "*default", sizeof( tx->name ));

	push	16					; 00000010H
	push	OFFSET $SG146264
	mov	edx, DWORD PTR _tx$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1943 : 			tx->gl_texturenum = tr.defaultTexture;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tr
	mov	DWORD PTR [eax+24], ecx

; 1944 : 			tx->width = tx->height = 16;

	mov	edx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [edx+20], 16			; 00000010H
	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+16], 16			; 00000010H

; 1945 : 			continue; // missed

	jmp	$LN2@Mod_LoadTe
$LN28@Mod_LoadTe:

; 1946 : 		}
; 1947 : 
; 1948 : 		mt = (mip_t *)((byte *)in + in->dataofs[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+4]
	mov	DWORD PTR _mt$[ebp], eax

; 1949 : 
; 1950 : 		if( !mt->name[0] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mt$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN29@Mod_LoadTe

; 1951 : 			Q_snprintf( mt->name, sizeof( mt->name ), "miptex_%i", i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG146266
	push	16					; 00000010H
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN29@Mod_LoadTe:

; 1952 : 		tx = Mem_Calloc( loadmodel->mempool, sizeof( *tx ));

	push	1952					; 000007a0H
	push	OFFSET $SG146267
	push	1
	push	68					; 00000044H
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tx$[ebp], eax

; 1953 : 		loadmodel->textures[i] = tx;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1954 : 
; 1955 : 		// convert to lowercase
; 1956 : 		Q_strncpy( tx->name, mt->name, sizeof( tx->name ));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tx$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1957 : 		Q_strnlwr( tx->name, tx->name, sizeof( tx->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	call	_Q_strnlwr
	add	esp, 12					; 0000000cH

; 1958 : 		custom_palette = false;

	mov	DWORD PTR _custom_palette$[ebp], 0

; 1959 : 
; 1960 : 		tx->width = mt->width;

	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 1961 : 		tx->height = mt->height;

	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 1962 : 
; 1963 : 		if( FBitSet( host.features, ENGINE_IMPROVED_LINETRACE ) && mt->name[0] == '{' )

	mov	edx, DWORD PTR _host+34748
	and	edx, 64					; 00000040H
	je	SHORT $LN30@Mod_LoadTe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN30@Mod_LoadTe

; 1964 : 			SetBits( txFlags, TF_KEEP_SOURCE ); // Paranoia2 texture alpha-tracing

	mov	ecx, DWORD PTR _txFlags$10[ebp]
	or	ecx, 2
	mov	DWORD PTR _txFlags$10[ebp], ecx
$LN30@Mod_LoadTe:

; 1965 : 
; 1966 : 		if( mt->offsets[0] > 0 )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [ecx+eax+24], 0
	jbe	$LN34@Mod_LoadTe

; 1967 : 		{
; 1968 : 			int	size = (int)sizeof( mip_t ) + ((mt->width * mt->height * 85)>>6);

	mov	edx, DWORD PTR _mt$[ebp]
	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	imul	ecx, DWORD PTR [eax+20]
	imul	edx, ecx, 85
	shr	edx, 6
	add	edx, 40					; 00000028H
	mov	DWORD PTR _size$2[ebp], edx

; 1969 : 			int	next_dataofs, remaining;
; 1970 : 
; 1971 : 			// compute next dataofset to determine allocated miptex sapce
; 1972 : 			for( j = i + 1; j < loadmodel->numtextures; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@Mod_LoadTe
$LN5@Mod_LoadTe:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@Mod_LoadTe:
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+368]
	jge	SHORT $LN6@Mod_LoadTe

; 1973 : 			{
; 1974 : 				next_dataofs = in->dataofs[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	mov	DWORD PTR _next_dataofs$8[ebp], eax

; 1975 : 				if( next_dataofs != -1 ) break;

	cmp	DWORD PTR _next_dataofs$8[ebp], -1
	je	SHORT $LN32@Mod_LoadTe
	jmp	SHORT $LN6@Mod_LoadTe
$LN32@Mod_LoadTe:

; 1976 : 			}

	jmp	SHORT $LN5@Mod_LoadTe
$LN6@Mod_LoadTe:

; 1977 : 
; 1978 : 			if( j == loadmodel->numtextures )

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+368]
	jne	SHORT $LN33@Mod_LoadTe

; 1979 : 				next_dataofs = bmod->texdatasize;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _next_dataofs$8[ebp], ecx
$LN33@Mod_LoadTe:

; 1980 : 
; 1981 : 			// NOTE: imagelib detect miptex version by size
; 1982 : 			// 770 additional bytes is indicated custom palette
; 1983 : 			remaining = next_dataofs - (in->dataofs[i] + size);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	add	ecx, DWORD PTR _size$2[ebp]
	mov	edx, DWORD PTR _next_dataofs$8[ebp]
	sub	edx, ecx
	mov	DWORD PTR _remaining$1[ebp], edx

; 1984 : 			if( remaining >= 770 ) custom_palette = true;

	cmp	DWORD PTR _remaining$1[ebp], 770	; 00000302H
	jl	SHORT $LN34@Mod_LoadTe
	mov	DWORD PTR _custom_palette$[ebp], 1
$LN34@Mod_LoadTe:

; 1985 : 		}
; 1986 : 
; 1987 : 		// check for multi-layered sky texture (quake1 specific)
; 1988 : 		if( bmod->isworld && !Q_strncmp( mt->name, "sky", 3 ) && (( mt->width / mt->height ) == 2 ))

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN35@Mod_LoadTe
	push	3
	push	OFFSET $SG146274
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@Mod_LoadTe
	mov	edx, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	xor	edx, edx
	div	DWORD PTR [ecx+20]
	cmp	eax, 2
	jne	SHORT $LN35@Mod_LoadTe

; 1989 : 		{	
; 1990 : 			R_InitSkyClouds( mt, tx, custom_palette ); // load quake sky

	mov	edx, DWORD PTR _custom_palette$[ebp]
	push	edx
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	call	_R_InitSkyClouds
	add	esp, 12					; 0000000cH

; 1991 : 
; 1992 : 			if( tr.solidskyTexture && tr.alphaskyTexture )

	cmp	DWORD PTR _tr+20, 0
	je	SHORT $LN36@Mod_LoadTe
	cmp	DWORD PTR _tr+24, 0
	je	SHORT $LN36@Mod_LoadTe

; 1993 : 				SetBits( world.flags, FWORLD_SKYSPHERE );

	mov	edx, DWORD PTR _world+4
	or	edx, 1
	mov	DWORD PTR _world+4, edx
$LN36@Mod_LoadTe:

; 1994 : 			continue;

	jmp	$LN2@Mod_LoadTe
$LN35@Mod_LoadTe:

; 1995 : 		}
; 1996 : 
; 1997 : 		// texture loading order:
; 1998 : 		// 1. from wad
; 1999 : 		// 2. internal from map
; 2000 : 
; 2001 : 		// trying wad texture (force while r_wadtextures is 1)
; 2002 : 		if(( r_wadtextures->value && bmod->wadlist.count > 0 ) || ( mt->offsets[0] <= 0 ))

	mov	eax, DWORD PTR _r_wadtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN39@Mod_LoadTe
	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+9372], 0
	jg	SHORT $LN38@Mod_LoadTe
$LN39@Mod_LoadTe:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [ecx+eax+24], 0
	ja	$LN9@Mod_LoadTe
$LN38@Mod_LoadTe:

; 2003 : 		{
; 2004 : 			Q_snprintf( texname, sizeof( texname ), "%s.mip", mt->name );

	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	push	OFFSET $SG146279
	push	64					; 00000040H
	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2005 : 
; 2006 : 			// check wads in reverse order
; 2007 : 			for( j = bmod->wadlist.count - 1; j >= 0; j-- )

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+9372]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $LN10@Mod_LoadTe
$LN8@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadTe:
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN9@Mod_LoadTe

; 2008 : 			{
; 2009 : 				char	*texpath = va( "%s.wad/%s", bmod->wadlist.wadnames[j], texname );

	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _bmod$[ebp]
	lea	ecx, DWORD PTR [eax+edx+156]
	push	ecx
	push	OFFSET $SG146280
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _texpath$5[ebp], eax

; 2010 : 
; 2011 : 				if( FS_FileExists( texpath, false ))

	push	0
	mov	edx, DWORD PTR _texpath$5[ebp]
	push	edx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@Mod_LoadTe

; 2012 : 				{
; 2013 : 					tx->gl_texturenum = GL_LoadTexture( texpath, NULL, 0, TF_ALLOW_EMBOSS|txFlags );

	mov	eax, DWORD PTR _txFlags$10[ebp]
	or	eax, 16					; 00000010H
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _texpath$5[ebp]
	push	ecx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [edx+24], eax

; 2014 : 					bmod->wadlist.wadusage[j]++; // this wad are really used

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8348]
	add	edx, 1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+eax*4+8348], edx

; 2015 : 					break;

	jmp	SHORT $LN9@Mod_LoadTe
$LN40@Mod_LoadTe:

; 2016 : 				}
; 2017 : 			}

	jmp	$LN8@Mod_LoadTe
$LN9@Mod_LoadTe:

; 2018 : 		}
; 2019 : 
; 2020 : 		// wad failed, so use internal texture (if present)
; 2021 : 		if( mt->offsets[0] > 0 && !tx->gl_texturenum )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [ecx+eax+24], 0
	jbe	$LN41@Mod_LoadTe
	mov	edx, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN41@Mod_LoadTe

; 2022 : 		{
; 2023 : 			// NOTE: imagelib detect miptex version by size
; 2024 : 			// 770 additional bytes is indicated custom palette
; 2025 : 			int	size = (int)sizeof( mip_t ) + ((mt->width * mt->height * 85)>>6);

	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	imul	eax, edx, 85
	shr	eax, 6
	add	eax, 40					; 00000028H
	mov	DWORD PTR _size$7[ebp], eax

; 2026 : 
; 2027 : 			if( custom_palette ) size += sizeof( short ) + 768;

	cmp	DWORD PTR _custom_palette$[ebp], 0
	je	SHORT $LN42@Mod_LoadTe
	mov	ecx, DWORD PTR _size$7[ebp]
	add	ecx, 770				; 00000302H
	mov	DWORD PTR _size$7[ebp], ecx
$LN42@Mod_LoadTe:

; 2028 : 			Q_snprintf( texname, sizeof( texname ), "#%s:%s.mip", loadstat.name, mt->name );

	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	push	OFFSET _loadstat
	push	OFFSET $SG146284
	push	64					; 00000040H
	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2029 : 			tx->gl_texturenum = GL_LoadTexture( texname, (byte *)mt, size, TF_ALLOW_EMBOSS|txFlags );

	mov	ecx, DWORD PTR _txFlags$10[ebp]
	or	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _size$7[ebp]
	push	edx
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN41@Mod_LoadTe:

; 2030 : 		}
; 2031 : 
; 2032 : 		// if texture is completely missed
; 2033 : 		if( !tx->gl_texturenum )

	mov	eax, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN43@Mod_LoadTe

; 2034 : 		{
; 2035 : 			Con_DPrintf( S_ERROR "unable to find %s.mip\n", mt->name );

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	push	OFFSET $SG146286
	call	_Con_DPrintf
	add	esp, 8

; 2036 : 			tx->gl_texturenum = tr.defaultTexture;

	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR _tr
	mov	DWORD PTR [edx+24], eax
$LN43@Mod_LoadTe:

; 2037 : 		}
; 2038 : 
; 2039 : 		// check for luma texture
; 2040 : 		if( FBitSet( R_GetTexture( tx->gl_texturenum )->flags, TF_HAS_LUMA ))

	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	eax, DWORD PTR [eax+284]
	and	eax, 8192				; 00002000H
	je	$LN49@Mod_LoadTe

; 2041 : 		{
; 2042 : 			Q_snprintf( texname, sizeof( texname ), "#%s:%s_luma.mip", loadstat.name, mt->name );

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	push	OFFSET _loadstat
	push	OFFSET $SG146288
	push	64					; 00000040H
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2043 : 
; 2044 : 			if( mt->offsets[0] > 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [edx+ecx+24], 0
	jbe	SHORT $LN45@Mod_LoadTe

; 2045 : 			{
; 2046 : 				// NOTE: imagelib detect miptex version by size
; 2047 : 				// 770 additional bytes is indicated custom palette
; 2048 : 				int	size = (int)sizeof( mip_t ) + ((mt->width * mt->height * 85)>>6);

	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	imul	eax, edx, 85
	shr	eax, 6
	add	eax, 40					; 00000028H
	mov	DWORD PTR _size$6[ebp], eax

; 2049 : 
; 2050 : 				if( custom_palette ) size += sizeof( short ) + 768;

	cmp	DWORD PTR _custom_palette$[ebp], 0
	je	SHORT $LN47@Mod_LoadTe
	mov	ecx, DWORD PTR _size$6[ebp]
	add	ecx, 770				; 00000302H
	mov	DWORD PTR _size$6[ebp], ecx
$LN47@Mod_LoadTe:

; 2051 : 				tx->fb_texturenum = GL_LoadTexture( texname, (byte *)mt, size, TF_MAKELUMA );

	push	16384					; 00004000H
	mov	edx, DWORD PTR _size$6[ebp]
	push	edx
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _tx$[ebp]
	mov	WORD PTR [edx+52], ax

; 2052 : 			}

	jmp	$LN49@Mod_LoadTe
$LN45@Mod_LoadTe:

; 2053 : 			else
; 2054 : 			{
; 2055 : 				size_t srcSize = 0;

	mov	DWORD PTR _srcSize$3[ebp], 0

; 2056 : 				byte *src = NULL;

	mov	DWORD PTR _src$9[ebp], 0

; 2057 : 
; 2058 : 				// NOTE: we can't loading it from wad as normal because _luma texture doesn't exist
; 2059 : 				// and not be loaded. But original texture is already loaded and can't be modified
; 2060 : 				// So load original texture manually and convert it to luma
; 2061 : 
; 2062 : 				// check wads in reverse order
; 2063 : 				for( j = bmod->wadlist.count - 1; j >= 0; j-- )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9372]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN13@Mod_LoadTe
$LN11@Mod_LoadTe:
	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN13@Mod_LoadTe:
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN12@Mod_LoadTe

; 2064 : 				{
; 2065 : 					char	*texpath = va( "%s.wad/%s.mip", bmod->wadlist.wadnames[j], tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _bmod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	push	OFFSET $SG146292
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _texpath$4[ebp], eax

; 2066 : 
; 2067 : 					if( FS_FileExists( texpath, false ))

	push	0
	mov	ecx, DWORD PTR _texpath$4[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@Mod_LoadTe

; 2068 : 					{
; 2069 : 						src = FS_LoadFile( texpath, &srcSize, false );

	push	0
	lea	edx, DWORD PTR _srcSize$3[ebp]
	push	edx
	mov	eax, DWORD PTR _texpath$4[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _src$9[ebp], eax

; 2070 : 						bmod->wadlist.wadusage[j]++; // this wad are really used

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+8348]
	add	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [edx+ecx*4+8348], eax

; 2071 : 						break;

	jmp	SHORT $LN12@Mod_LoadTe
$LN48@Mod_LoadTe:

; 2072 : 					}
; 2073 : 				}

	jmp	$LN11@Mod_LoadTe
$LN12@Mod_LoadTe:

; 2074 : 
; 2075 : 				// okay, loading it from wad or hi-res version
; 2076 : 				tx->fb_texturenum = GL_LoadTexture( texname, src, srcSize, TF_MAKELUMA );

	push	16384					; 00004000H
	mov	eax, DWORD PTR _srcSize$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	WORD PTR [ecx+52], ax

; 2077 : 				if( src ) Mem_Free( src );

	cmp	DWORD PTR _src$9[ebp], 0
	je	SHORT $LN49@Mod_LoadTe
	push	2077					; 0000081dH
	push	OFFSET $SG146295
	mov	edx, DWORD PTR _src$9[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN49@Mod_LoadTe:

; 2078 : 			}
; 2079 : 		}
; 2080 : 	}

	jmp	$LN2@Mod_LoadTe
$LN3@Mod_LoadTe:

; 2081 : 
; 2082 : 	// sequence the animations and detail textures
; 2083 : 	for( i = 0; i < loadmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadTe
$LN14@Mod_LoadTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@Mod_LoadTe:
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+368]
	jge	$LN15@Mod_LoadTe

; 2084 : 	{
; 2085 : 		tx = loadmodel->textures[i];

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx$[ebp], eax

; 2086 : 
; 2087 : 		if( !tx || ( tx->name[0] != '-' && tx->name[0] != '+' ))

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN51@Mod_LoadTe
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _tx$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN50@Mod_LoadTe
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _tx$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN50@Mod_LoadTe
$LN51@Mod_LoadTe:

; 2088 : 			continue;

	jmp	SHORT $LN14@Mod_LoadTe
$LN50@Mod_LoadTe:

; 2089 : 
; 2090 : 		if( tx->anim_next )

	mov	eax, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN52@Mod_LoadTe

; 2091 : 			continue;	// already sequenced

	jmp	$LN14@Mod_LoadTe
$LN52@Mod_LoadTe:

; 2092 : 
; 2093 : 		// find the number of frames in the animation
; 2094 : 		memset( anims, 0, sizeof( anims ));

	push	40					; 00000028H
	push	0
	lea	ecx, DWORD PTR _anims$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2095 : 		memset( altanims, 0, sizeof( altanims ));

	push	40					; 00000028H
	push	0
	lea	edx, DWORD PTR _altanims$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2096 : 
; 2097 : 		max = tx->name[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tx$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _max$[ebp], edx

; 2098 : 		altmax = 0;

	mov	DWORD PTR _altmax$[ebp], 0

; 2099 : 
; 2100 : 		if( max >= '0' && max <= '9' )

	cmp	DWORD PTR _max$[ebp], 48		; 00000030H
	jl	SHORT $LN53@Mod_LoadTe
	cmp	DWORD PTR _max$[ebp], 57		; 00000039H
	jg	SHORT $LN53@Mod_LoadTe

; 2101 : 		{
; 2102 : 			max -= '0';

	mov	eax, DWORD PTR _max$[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _max$[ebp], eax

; 2103 : 			altmax = 0;

	mov	DWORD PTR _altmax$[ebp], 0

; 2104 : 			anims[max] = tx;

	mov	ecx, DWORD PTR _max$[ebp]
	mov	edx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR _anims$[ebp+ecx*4], edx

; 2105 : 			max++;

	mov	eax, DWORD PTR _max$[ebp]
	add	eax, 1
	mov	DWORD PTR _max$[ebp], eax

; 2106 : 		}

	jmp	SHORT $LN56@Mod_LoadTe
$LN53@Mod_LoadTe:

; 2107 : 		else if( max >= 'a' && max <= 'j' )

	cmp	DWORD PTR _max$[ebp], 97		; 00000061H
	jl	SHORT $LN55@Mod_LoadTe
	cmp	DWORD PTR _max$[ebp], 106		; 0000006aH
	jg	SHORT $LN55@Mod_LoadTe

; 2108 : 		{
; 2109 : 			altmax = max - 'a';

	mov	ecx, DWORD PTR _max$[ebp]
	sub	ecx, 97					; 00000061H
	mov	DWORD PTR _altmax$[ebp], ecx

; 2110 : 			max = 0;

	mov	DWORD PTR _max$[ebp], 0

; 2111 : 			altanims[altmax] = tx;

	mov	edx, DWORD PTR _altmax$[ebp]
	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR _altanims$[ebp+edx*4], eax

; 2112 : 			altmax++;

	mov	ecx, DWORD PTR _altmax$[ebp]
	add	ecx, 1
	mov	DWORD PTR _altmax$[ebp], ecx

; 2113 : 		}

	jmp	SHORT $LN56@Mod_LoadTe
$LN55@Mod_LoadTe:

; 2114 : 		else Con_Printf( S_ERROR "Mod_LoadTextures: bad animating texture %s\n", tx->name );

	mov	edx, DWORD PTR _tx$[ebp]
	push	edx
	push	OFFSET $SG146303
	call	_Con_Printf
	add	esp, 8
$LN56@Mod_LoadTe:

; 2115 : 
; 2116 : 		for( j = i + 1; j < loadmodel->numtextures; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN19@Mod_LoadTe
$LN17@Mod_LoadTe:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN19@Mod_LoadTe:
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+368]
	jge	$LN18@Mod_LoadTe

; 2117 : 		{
; 2118 : 			tx2 = loadmodel->textures[j];

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+372]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _tx2$[ebp], ecx

; 2119 : 
; 2120 : 			if( !tx2 || ( tx2->name[0] != '-' && tx2->name[0] != '+' ))

	cmp	DWORD PTR _tx2$[ebp], 0
	je	SHORT $LN58@Mod_LoadTe
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _tx2$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN57@Mod_LoadTe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx2$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN57@Mod_LoadTe
$LN58@Mod_LoadTe:

; 2121 : 				continue;

	jmp	SHORT $LN17@Mod_LoadTe
$LN57@Mod_LoadTe:

; 2122 : 
; 2123 : 			if( Q_strcmp( tx2->name + 2, tx->name + 2 ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _tx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _tx2$[ebp]
	add	edx, 2
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN59@Mod_LoadTe

; 2124 : 				continue;

	jmp	$LN17@Mod_LoadTe
$LN59@Mod_LoadTe:

; 2125 : 
; 2126 : 			num = tx2->name[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tx2$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _num$[ebp], edx

; 2127 : 
; 2128 : 			if( num >= '0' && num <= '9' )

	cmp	DWORD PTR _num$[ebp], 48		; 00000030H
	jl	SHORT $LN60@Mod_LoadTe
	cmp	DWORD PTR _num$[ebp], 57		; 00000039H
	jg	SHORT $LN60@Mod_LoadTe

; 2129 : 			{
; 2130 : 				num -= '0';

	mov	eax, DWORD PTR _num$[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _num$[ebp], eax

; 2131 : 				anims[num] = tx2;

	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR _anims$[ebp+ecx*4], edx

; 2132 : 				if( num + 1 > max )

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _max$[ebp]
	jle	SHORT $LN62@Mod_LoadTe

; 2133 : 					max = num + 1;

	mov	ecx, DWORD PTR _num$[ebp]
	add	ecx, 1
	mov	DWORD PTR _max$[ebp], ecx
$LN62@Mod_LoadTe:

; 2134 : 			}

	jmp	SHORT $LN64@Mod_LoadTe
$LN60@Mod_LoadTe:

; 2135 : 			else if( num >= 'a' && num <= 'j' )

	cmp	DWORD PTR _num$[ebp], 97		; 00000061H
	jl	SHORT $LN63@Mod_LoadTe
	cmp	DWORD PTR _num$[ebp], 106		; 0000006aH
	jg	SHORT $LN63@Mod_LoadTe

; 2136 : 			{
; 2137 : 				num = num - 'a';

	mov	edx, DWORD PTR _num$[ebp]
	sub	edx, 97					; 00000061H
	mov	DWORD PTR _num$[ebp], edx

; 2138 : 				altanims[num] = tx2;

	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR _altanims$[ebp+eax*4], ecx

; 2139 : 				if( num + 1 > altmax )

	mov	edx, DWORD PTR _num$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _altmax$[ebp]
	jle	SHORT $LN65@Mod_LoadTe

; 2140 : 					altmax = num + 1;

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _altmax$[ebp], eax
$LN65@Mod_LoadTe:

; 2141 : 			}

	jmp	SHORT $LN64@Mod_LoadTe
$LN63@Mod_LoadTe:

; 2142 : 			else Con_Printf( S_ERROR "Mod_LoadTextures: bad animating texture %s\n", tx->name );

	mov	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	push	OFFSET $SG146313
	call	_Con_Printf
	add	esp, 8
$LN64@Mod_LoadTe:

; 2143 : 		}

	jmp	$LN17@Mod_LoadTe
$LN18@Mod_LoadTe:

; 2144 : 
; 2145 : 		// link them all together
; 2146 : 		for( j = 0; j < max; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@Mod_LoadTe
$LN20@Mod_LoadTe:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN22@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jge	$LN21@Mod_LoadTe

; 2147 : 		{
; 2148 : 			tx2 = anims[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _anims$[ebp+ecx*4]
	mov	DWORD PTR _tx2$[ebp], edx

; 2149 : 
; 2150 : 			if( !tx2 )

	cmp	DWORD PTR _tx2$[ebp], 0
	jne	SHORT $LN66@Mod_LoadTe

; 2151 : 			{
; 2152 : 				Con_Printf( S_ERROR "Mod_LoadTextures: missing frame %i of %s\n", j, tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	push	OFFSET $SG146315
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2153 : 				tx->anim_total = 0;

	mov	edx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [edx+32], 0

; 2154 : 				break;

	jmp	SHORT $LN21@Mod_LoadTe
$LN66@Mod_LoadTe:

; 2155 : 			}
; 2156 : 
; 2157 : 			tx2->anim_total = max * ANIM_CYCLE;

	mov	eax, DWORD PTR _max$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2158 : 			tx2->anim_min = j * ANIM_CYCLE;

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2159 : 			tx2->anim_max = (j + 1) * ANIM_CYCLE;

	mov	ecx, DWORD PTR _j$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	eax, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [eax+40], edx

; 2160 : 			tx2->anim_next = anims[(j + 1) % max];

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	edx, DWORD PTR _anims$[ebp+edx*4]
	mov	DWORD PTR [ecx+44], edx

; 2161 : 			if( altmax ) tx2->alternate_anims = altanims[0];

	cmp	DWORD PTR _altmax$[ebp], 0
	je	SHORT $LN67@Mod_LoadTe
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	eax, DWORD PTR _altanims$[ebp+ecx]
	mov	DWORD PTR [edx+48], eax
$LN67@Mod_LoadTe:

; 2162 : 		}

	jmp	$LN20@Mod_LoadTe
$LN21@Mod_LoadTe:

; 2163 : 
; 2164 : 		for( j = 0; j < altmax; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN25@Mod_LoadTe
$LN23@Mod_LoadTe:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN25@Mod_LoadTe:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _altmax$[ebp]
	jge	$LN24@Mod_LoadTe

; 2165 : 		{
; 2166 : 			tx2 = altanims[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _altanims$[ebp+eax*4]
	mov	DWORD PTR _tx2$[ebp], ecx

; 2167 : 
; 2168 : 			if( !tx2 )

	cmp	DWORD PTR _tx2$[ebp], 0
	jne	SHORT $LN68@Mod_LoadTe

; 2169 : 			{
; 2170 : 				Con_Printf( S_ERROR "Mod_LoadTextures: missing frame %i of %s\n", j, tx->name );

	mov	edx, DWORD PTR _tx$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	push	OFFSET $SG146318
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2171 : 				tx->anim_total = 0;

	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 2172 : 				break;

	jmp	SHORT $LN24@Mod_LoadTe
$LN68@Mod_LoadTe:

; 2173 : 			}
; 2174 : 
; 2175 : 			tx2->anim_total = altmax * ANIM_CYCLE;

	mov	edx, DWORD PTR _altmax$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [eax+32], edx

; 2176 : 			tx2->anim_min = j * ANIM_CYCLE;

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 2177 : 			tx2->anim_max = (j+1) * ANIM_CYCLE;

	mov	eax, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 2178 : 			tx2->anim_next = altanims[(j + 1) % altmax];

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _altmax$[ebp]
	mov	eax, DWORD PTR _tx2$[ebp]
	mov	ecx, DWORD PTR _altanims$[ebp+edx*4]
	mov	DWORD PTR [eax+44], ecx

; 2179 : 			if( max ) tx2->alternate_anims = anims[0];

	cmp	DWORD PTR _max$[ebp], 0
	je	SHORT $LN69@Mod_LoadTe
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	edx, DWORD PTR _anims$[ebp+eax]
	mov	DWORD PTR [ecx+48], edx
$LN69@Mod_LoadTe:

; 2180 : 		}

	jmp	$LN23@Mod_LoadTe
$LN24@Mod_LoadTe:

; 2181 : 	}

	jmp	$LN14@Mod_LoadTe
$LN15@Mod_LoadTe:

; 2182 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_out$ = -16						; size = 4
_in$1 = -12						; size = 4
_in$2 = -8						; size = 4
_i$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadMarkSurfaces PROC

; 1864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1865 : 	msurface_t	**out;
; 1866 : 	int		i;
; 1867 : 
; 1868 : 	loadmodel->marksurfaces = out = Mem_Malloc( loadmodel->mempool, bmod->nummarkfaces * sizeof( *out ));

	push	1868					; 0000074cH
	push	OFFSET $SG146182
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+204], edx

; 1869 : 	loadmodel->nummarksurfaces = bmod->nummarkfaces;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+200], edx

; 1870 : 
; 1871 : 	if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	SHORT $LN8@Mod_LoadMa

; 1872 : 	{
; 1873 : 		dmarkface32_t	*in = bmod->markfaces32;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _in$2[ebp], edx

; 1874 : 
; 1875 : 		for( i = 0; i < bmod->nummarkfaces; i++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadMa
$LN2@Mod_LoadMa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$2[ebp], ecx
$LN4@Mod_LoadMa:
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+60]
	jae	SHORT $LN3@Mod_LoadMa

; 1876 : 		{
; 1877 : 			if( *in < 0 || *in >= loadmodel->numsurfaces )

	mov	ecx, DWORD PTR _in$2[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN11@Mod_LoadMa
	mov	edx, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+176]
	jl	SHORT $LN10@Mod_LoadMa
$LN11@Mod_LoadMa:

; 1878 : 				Host_Error( "Mod_LoadMarkFaces: bad surface number in '%s'\n", loadmodel->name );

	mov	edx, DWORD PTR _loadmodel
	push	edx
	push	OFFSET $SG146187
	call	_Host_Error
	add	esp, 8
$LN10@Mod_LoadMa:

; 1879 : 			out[i] = loadmodel->surfaces + *in;

	mov	eax, DWORD PTR _in$2[ebp]
	imul	ecx, DWORD PTR [eax], 92
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+180]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1880 : 		}

	jmp	SHORT $LN2@Mod_LoadMa
$LN3@Mod_LoadMa:

; 1881 : 	}

	jmp	$LN1@Mod_LoadMa
$LN8@Mod_LoadMa:

; 1882 : 	else
; 1883 : 	{
; 1884 : 		dmarkface_t	*in = bmod->markfaces;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _in$1[ebp], ecx

; 1885 : 
; 1886 : 		for( i = 0; i < bmod->nummarkfaces; i++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadMa
$LN5@Mod_LoadMa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _in$1[ebp]
	add	eax, 2
	mov	DWORD PTR _in$1[ebp], eax
$LN7@Mod_LoadMa:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+60]
	jae	SHORT $LN1@Mod_LoadMa

; 1887 : 		{
; 1888 : 			if( *in < 0 || *in >= loadmodel->numsurfaces )

	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN13@Mod_LoadMa
	mov	edx, DWORD PTR _in$1[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _loadmodel
	cmp	eax, DWORD PTR [ecx+176]
	jl	SHORT $LN12@Mod_LoadMa
$LN13@Mod_LoadMa:

; 1889 : 				Host_Error( "Mod_LoadMarkFaces: bad surface number in '%s'\n", loadmodel->name );

	mov	edx, DWORD PTR _loadmodel
	push	edx
	push	OFFSET $SG146190
	call	_Host_Error
	add	esp, 8
$LN12@Mod_LoadMa:

; 1890 : 			out[i] = loadmodel->surfaces + *in;

	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1891 : 		}

	jmp	SHORT $LN5@Mod_LoadMa
$LN1@Mod_LoadMa:

; 1892 : 	}
; 1893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadMarkSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadSurfEdges PROC

; 1852 : {

	push	ebp
	mov	ebp, esp

; 1853 : 	loadmodel->surfedges = Mem_Malloc( loadmodel->mempool, bmod->numsurfedges * sizeof( dsurfedge_t ));

	push	1853					; 0000073dH
	push	OFFSET $SG146167
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+188], eax

; 1854 : 	memcpy( loadmodel->surfedges, bmod->surfedges, bmod->numsurfedges * sizeof( dsurfedge_t ));

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+68]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+188]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1855 : 	loadmodel->numsurfedges = bmod->numsurfedges;

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+184], ecx

; 1856 : }

	pop	ebp
	ret	0
_Mod_LoadSurfEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_in$1 = -16						; size = 4
_in$2 = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadEdges PROC

; 1817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 1818 : 	medge_t	*out;
; 1819 : 	int	i;
; 1820 : 
; 1821 : 	loadmodel->edges = out = Mem_Malloc( loadmodel->mempool, bmod->numedges * sizeof( medge_t ));

	push	1821					; 0000071dH
	push	OFFSET $SG146158
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+156], edx

; 1822 : 	loadmodel->numedges = bmod->numedges;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+152], edx

; 1823 : 
; 1824 : 	if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	SHORT $LN8@Mod_LoadEd

; 1825 : 	{
; 1826 : 		dedge32_t	*in = (dedge32_t *)bmod->edges32;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _in$2[ebp], edx

; 1827 : 
; 1828 : 		for( i = 0; i < bmod->numedges; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadEd
$LN2@Mod_LoadEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _in$2[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 8
	mov	DWORD PTR _out$[ebp], edx
$LN4@Mod_LoadEd:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+76]
	jae	SHORT $LN3@Mod_LoadEd

; 1829 : 		{
; 1830 : 			out->v[0] = in->v[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [ecx+edx], ax

; 1831 : 			out->v[1] = in->v[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [eax+edx], cx

; 1832 : 		}

	jmp	SHORT $LN2@Mod_LoadEd
$LN3@Mod_LoadEd:

; 1833 : 	}

	jmp	SHORT $LN1@Mod_LoadEd
$LN8@Mod_LoadEd:

; 1834 : 	else
; 1835 : 	{
; 1836 : 		dedge_t	*in = (dedge_t *)bmod->edges;

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _in$1[ebp], eax

; 1837 : 
; 1838 : 		for( i = 0; i < bmod->numedges; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadEd
$LN5@Mod_LoadEd:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _in$1[ebp]
	add	edx, 4
	mov	DWORD PTR _in$1[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 8
	mov	DWORD PTR _out$[ebp], eax
$LN7@Mod_LoadEd:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+76]
	jae	SHORT $LN1@Mod_LoadEd

; 1839 : 		{
; 1840 : 			out->v[0] = (word)in->v[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$1[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx

; 1841 : 			out->v[1] = (word)in->v[1];

	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$1[ebp]
	mov	dx, WORD PTR [esi+edx]
	mov	WORD PTR [ecx+eax], dx

; 1842 : 		}

	jmp	SHORT $LN5@Mod_LoadEd
$LN1@Mod_LoadEd:

; 1843 : 	}
; 1844 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv164 = -20						; size = 4
tv66 = -16						; size = 4
_out$ = -12						; size = 4
_in$ = -8						; size = 4
_i$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadVertexes PROC

; 1781 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1782 : 	dvertex_t	*in;
; 1783 : 	mvertex_t	*out;
; 1784 : 	int	i;
; 1785 : 
; 1786 : 	in = bmod->vertexes;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _in$[ebp], ecx

; 1787 : 	out = loadmodel->vertexes = Mem_Malloc( loadmodel->mempool, bmod->numvertexes * sizeof( mvertex_t ));

	push	1787					; 000006fbH
	push	OFFSET $SG146135
	push	0
	mov	edx, DWORD PTR _bmod$[ebp]
	imul	eax, DWORD PTR [edx+12], 12
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR [eax+148], ecx
	mov	edx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _out$[ebp], edx

; 1788 : 	loadmodel->numvertexes = bmod->numvertexes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+144], edx

; 1789 : 
; 1790 : 	if( bmod->isworld ) ClearBounds( world.mins, world.maxs );

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN8@Mod_LoadVe
	push	OFFSET _world+2612
	push	OFFSET _world+2600
	call	_ClearBounds
	add	esp, 8
$LN8@Mod_LoadVe:

; 1791 : 
; 1792 : 	for( i = 0; i < bmod->numvertexes; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadVe
$LN2@Mod_LoadVe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _in$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], eax
$LN4@Mod_LoadVe:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN3@Mod_LoadVe

; 1793 : 	{
; 1794 : 		if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN9@Mod_LoadVe

; 1795 : 			AddPointToBounds( in->point, world.mins, world.maxs );

	push	OFFSET _world+2612
	push	OFFSET _world+2600
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH
$LN9@Mod_LoadVe:

; 1796 : 		VectorCopy( in->point, out->position );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx

; 1797 : 	}

	jmp	$LN2@Mod_LoadVe
$LN3@Mod_LoadVe:

; 1798 : 
; 1799 : 	if( !bmod->isworld ) return;

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	jne	SHORT $LN10@Mod_LoadVe
	jmp	$LN6@Mod_LoadVe
$LN10@Mod_LoadVe:

; 1800 : 
; 1801 : 	VectorSubtract( world.maxs, world.mins, world.size );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _world[edx+2612]
	subss	xmm0, DWORD PTR _world[ecx+2600]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _world[eax+2624], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _world[ecx+2612]
	subss	xmm0, DWORD PTR _world[edx+2600]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _world[eax+2624], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _world[ecx+2612]
	subss	xmm0, DWORD PTR _world[edx+2600]
	movss	DWORD PTR tv164[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _world[eax+2624], xmm0

; 1802 : 
; 1803 : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadVe
$LN5@Mod_LoadVe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@Mod_LoadVe:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@Mod_LoadVe

; 1804 : 	{
; 1805 : 		// spread the mins / maxs by a pixel
; 1806 : 		world.mins[i] -= 1.0f;

	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _world[edx*4+2600]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _world[eax*4+2600], xmm0

; 1807 : 		world.maxs[i] += 1.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _world[ecx*4+2612]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _world[edx*4+2612], xmm0

; 1808 : 	}

	jmp	SHORT $LN5@Mod_LoadVe
$LN6@Mod_LoadVe:

; 1809 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadVertexes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv219 = -24						; size = 8
_i$ = -16						; size = 4
_in$ = -12						; size = 4
_j$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadPlanes PROC

; 1747 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 1748 : 	dplane_t	*in;
; 1749 : 	mplane_t	*out;
; 1750 : 	int	i, j;
; 1751 : 
; 1752 : 	in = bmod->planes;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _in$[ebp], ecx

; 1753 : 	loadmodel->planes = out = Mem_Malloc( loadmodel->mempool, bmod->numplanes * sizeof( *out ));

	push	1753					; 000006d9H
	push	OFFSET $SG146117
	push	0
	mov	edx, DWORD PTR _bmod$[ebp]
	imul	eax, DWORD PTR [edx+20], 20
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+132], ecx

; 1754 : 	loadmodel->numplanes = bmod->numplanes;

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+128], ecx

; 1755 : 
; 1756 : 	for( i = 0; i < bmod->numplanes; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadPl
$LN2@Mod_LoadPl:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _in$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], ecx
$LN4@Mod_LoadPl:
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jae	$LN3@Mod_LoadPl

; 1757 : 	{
; 1758 : 		out->signbits = 0;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+17], 0

; 1759 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadPl
$LN5@Mod_LoadPl:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@Mod_LoadPl:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@Mod_LoadPl

; 1760 : 		{
; 1761 : 			out->normal[j] = in->normal[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 1762 : 
; 1763 : 			if( out->normal[j] < 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jbe	SHORT $LN8@Mod_LoadPl

; 1764 : 				SetBits( out->signbits, BIT( j ));

	mov	edx, DWORD PTR _out$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	or	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+17], al
$LN8@Mod_LoadPl:

; 1765 : 		}

	jmp	SHORT $LN5@Mod_LoadPl
$LN6@Mod_LoadPl:

; 1766 : 
; 1767 : 		if( VectorLength( out->normal ) < 0.5f )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv219[ebp]
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	comisd	xmm0, QWORD PTR tv219[ebp]
	jbe	SHORT $LN9@Mod_LoadPl

; 1768 : 			Con_Printf( S_ERROR "bad normal for plane #%i\n", i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG146120
	call	_Con_Printf
	add	esp, 8
$LN9@Mod_LoadPl:

; 1769 : 
; 1770 : 		out->dist = in->dist;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1771 : 		out->type = in->type;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR [eax+16], dl

; 1772 : 	}

	jmp	$LN2@Mod_LoadPl
$LN3@Mod_LoadPl:

; 1773 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadPlanes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_entpatchsize$1 = -4452					; size = 4
_ft1$2 = -4448						; size = 4
_num$3 = -4444						; size = 4
$T4 = -4440						; size = 4
_ft2$5 = -4436						; size = 4
_pszWadFile$6 = -4432					; size = 4
_entpatch$ = -4428					; size = 4
_pfile$ = -4424						; size = 4
_wadstring$ = -4420					; size = 2048
_token$ = -2372						; size = 2048
_keyname$ = -324					; size = 256
_entfilename$7 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadEntities PROC

; 1632 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4452				; 00001164H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1633 : 	byte	*entpatch = NULL;

	mov	DWORD PTR _entpatch$[ebp], 0

; 1634 : 	char	token[MAX_TOKEN];
; 1635 : 	char	wadstring[MAX_TOKEN];
; 1636 : 	string	keyname;
; 1637 : 	char	*pfile;
; 1638 : 
; 1639 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	$LN9@Mod_LoadEn

; 1640 : 	{
; 1641 : 		char	entfilename[MAX_QPATH];
; 1642 : 		long	entpatchsize;
; 1643 : 		long	ft1, ft2;
; 1644 : 
; 1645 : 		// world is check for entfile too
; 1646 : 		Q_strncpy( entfilename, loadmodel->name, sizeof( entfilename ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	lea	edx, DWORD PTR _entfilename$7[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1647 : 		COM_ReplaceExtension( entfilename, ".ent" );

	push	OFFSET $SG146061
	lea	eax, DWORD PTR _entfilename$7[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 1648 : 
; 1649 : 		// make sure what entity patch is never than bsp
; 1650 : 		ft1 = FS_FileTime( loadmodel->name, false );

	push	0
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft1$2[ebp], eax

; 1651 : 		ft2 = FS_FileTime( entfilename, true );

	push	1
	lea	edx, DWORD PTR _entfilename$7[ebp]
	push	edx
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft2$5[ebp], eax

; 1652 : 
; 1653 : 		if( ft2 != -1 )

	cmp	DWORD PTR _ft2$5[ebp], -1
	je	SHORT $LN9@Mod_LoadEn

; 1654 : 		{
; 1655 : 			if( ft1 > ft2 )

	mov	eax, DWORD PTR _ft1$2[ebp]
	cmp	eax, DWORD PTR _ft2$5[ebp]
	jle	SHORT $LN11@Mod_LoadEn

; 1656 : 			{
; 1657 : 				Con_Printf( S_WARN "Entity patch is older than bsp. Ignored.\n" );			

	push	OFFSET $SG146065
	call	_Con_Printf
	add	esp, 4

; 1658 : 			}

	jmp	SHORT $LN9@Mod_LoadEn
$LN11@Mod_LoadEn:

; 1659 : 			else if(( entpatch = FS_LoadFile( entfilename, &entpatchsize, true )) != NULL )

	push	1
	lea	ecx, DWORD PTR _entpatchsize$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _entfilename$7[ebp]
	push	edx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _entpatch$[ebp], eax
	cmp	DWORD PTR _entpatch$[ebp], 0
	je	SHORT $LN9@Mod_LoadEn

; 1660 : 			{
; 1661 : 				Con_Printf( "^2Read entity patch:^7 %s\n", entfilename );

	lea	eax, DWORD PTR _entfilename$7[ebp]
	push	eax
	push	OFFSET $SG146067
	call	_Con_Printf
	add	esp, 8

; 1662 : 				bmod->entdatasize = entpatchsize;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _entpatchsize$1[ebp]
	mov	DWORD PTR [ecx+132], edx

; 1663 : 				bmod->entdata = entpatch;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _entpatch$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN9@Mod_LoadEn:

; 1664 : 			}
; 1665 : 		}
; 1666 : 	}
; 1667 : 
; 1668 : 	// make sure what we really has terminator
; 1669 : 	loadmodel->entities = Mem_Calloc( loadmodel->mempool, bmod->entdatasize + 1 );

	push	1669					; 00000685H
	push	OFFSET $SG146068
	push	1
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+132]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+384], eax

; 1670 : 	memcpy( loadmodel->entities, bmod->entdata, bmod->entdatasize ); // moving to private model pool

	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1671 : 	if( entpatch ) Mem_Free( entpatch ); // release entpatch if present

	cmp	DWORD PTR _entpatch$[ebp], 0
	je	SHORT $LN14@Mod_LoadEn
	push	1671					; 00000687H
	push	OFFSET $SG146070
	mov	edx, DWORD PTR _entpatch$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN14@Mod_LoadEn:

; 1672 : 	if( !bmod->isworld ) return;

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	jne	SHORT $LN15@Mod_LoadEn
	jmp	$LN33@Mod_LoadEn
$LN15@Mod_LoadEn:

; 1673 : 
; 1674 : 	pfile = (char *)loadmodel->entities;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+384]
	mov	DWORD PTR _pfile$[ebp], edx

; 1675 : 	world.generator[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _world[ecx+2312], 0

; 1676 : 	world.compiler[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _world[eax+2056], 0

; 1677 : 	world.message[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _world[edx+8], 0

; 1678 : 	bmod->wadlist.count = 0;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [eax+9372], 0
$LN2@Mod_LoadEn:

; 1679 : 
; 1680 : 	// parse all the wads for loading textures in right ordering
; 1681 : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN33@Mod_LoadEn

; 1682 : 	{
; 1683 : 		if( token[0] != '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN4@Mod_LoadEn

; 1684 : 			Host_Error( "Mod_LoadEntities: found %s when expecting {\n", token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET $SG146073
	call	_Host_Error
	add	esp, 8
$LN4@Mod_LoadEn:

; 1685 : 
; 1686 : 		while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN5@Mod_LoadEn

; 1687 : 		{
; 1688 : 			// parse key
; 1689 : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL )

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN17@Mod_LoadEn

; 1690 : 				Host_Error( "Mod_LoadEntities: EOF without closing brace\n" );

	push	OFFSET $SG146075
	call	_Host_Error
	add	esp, 4
$LN17@Mod_LoadEn:

; 1691 : 			if( token[0] == '}' ) break; // end of desc

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _token$[ebp+edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN18@Mod_LoadEn
	jmp	$LN5@Mod_LoadEn
$LN18@Mod_LoadEn:

; 1692 : 
; 1693 : 			Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR _keyname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1694 : 
; 1695 : 			// parse value	
; 1696 : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL ) 

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN19@Mod_LoadEn

; 1697 : 				Host_Error( "Mod_LoadEntities: EOF without closing brace\n" );

	push	OFFSET $SG146078
	call	_Host_Error
	add	esp, 4
$LN19@Mod_LoadEn:

; 1698 : 
; 1699 : 			if( token[0] == '}' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _token$[ebp+eax]
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN20@Mod_LoadEn

; 1700 : 				Host_Error( "Mod_LoadEntities: closing brace without data\n" );

	push	OFFSET $SG146080
	call	_Host_Error
	add	esp, 4
$LN20@Mod_LoadEn:

; 1701 : 
; 1702 : 			if( !Q_stricmp( keyname, "wad" ))

	push	99999					; 0001869fH
	push	OFFSET $SG146083
	lea	edx, DWORD PTR _keyname$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN21@Mod_LoadEn

; 1703 : 			{
; 1704 : 				char	*pszWadFile;
; 1705 : 
; 1706 : 				Q_strncpy( wadstring, token, MAX_TOKEN - 2 );

	push	2046					; 000007feH
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadstring$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1707 : 				wadstring[MAX_TOKEN - 2] = 0;

	mov	edx, 1
	imul	eax, edx, 2046
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 2048		; 00000800H
	jae	SHORT $LN34@Mod_LoadEn
	jmp	SHORT $LN35@Mod_LoadEn
$LN34@Mod_LoadEn:
	call	___report_rangecheckfailure
$LN35@Mod_LoadEn:
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _wadstring$[ebp+ecx], 0

; 1708 : 
; 1709 : 				if( !Q_strchr( wadstring, ';' ))

	push	59					; 0000003bH
	lea	edx, DWORD PTR _wadstring$[ebp]
	push	edx
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@Mod_LoadEn

; 1710 : 					Q_strcat( wadstring, ";" );

	push	99999					; 0001869fH
	push	OFFSET $SG146085
	lea	eax, DWORD PTR _wadstring$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN23@Mod_LoadEn:

; 1711 : 
; 1712 : 				// parse wad pathes
; 1713 : 				for( pszWadFile = strtok( wadstring, ";" ); pszWadFile != NULL; pszWadFile = strtok( NULL, ";" ))

	push	OFFSET $SG146086
	lea	ecx, DWORD PTR _wadstring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtok
	add	esp, 8
	mov	DWORD PTR _pszWadFile$6[ebp], eax
	jmp	SHORT $LN8@Mod_LoadEn
$LN6@Mod_LoadEn:
	push	OFFSET $SG146087
	push	0
	call	DWORD PTR __imp__strtok
	add	esp, 8
	mov	DWORD PTR _pszWadFile$6[ebp], eax
$LN8@Mod_LoadEn:
	cmp	DWORD PTR _pszWadFile$6[ebp], 0
	je	$LN7@Mod_LoadEn

; 1714 : 				{
; 1715 : 					COM_FixSlashes( pszWadFile );

	mov	edx, DWORD PTR _pszWadFile$6[ebp]
	push	edx
	call	_COM_FixSlashes
	add	esp, 4

; 1716 : 					COM_FileBase( pszWadFile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszWadFile$6[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1717 : 
; 1718 : 					// make sure what wad is really exist
; 1719 : 					if( FS_FileExists( va( "%s.wad", token ), false ))

	push	0
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	push	OFFSET $SG146089
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@Mod_LoadEn

; 1720 : 					{
; 1721 : 						int num = bmod->wadlist.count++;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9372]
	mov	DWORD PTR _num$3[ebp], ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+9372]
	add	eax, 1
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+9372], eax

; 1722 : 						Q_strncpy( bmod->wadlist.wadnames[num], token, sizeof( bmod->wadlist.wadnames[0] ));

	push	32					; 00000020H
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$3[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _bmod$[ebp]
	lea	edx, DWORD PTR [ecx+eax+156]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1723 : 						bmod->wadlist.wadusage[num] = 0;

	mov	eax, DWORD PTR _num$3[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+eax*4+8348], 0
$LN24@Mod_LoadEn:

; 1724 : 					}
; 1725 : 
; 1726 : 					if( bmod->wadlist.count >= MAX_MAP_WADS )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9372], 256		; 00000100H
	jl	SHORT $LN25@Mod_LoadEn

; 1727 : 						break; // too many wads...

	jmp	SHORT $LN7@Mod_LoadEn
$LN25@Mod_LoadEn:

; 1728 : 				}

	jmp	$LN6@Mod_LoadEn
$LN7@Mod_LoadEn:

; 1729 : 			}

	jmp	$LN22@Mod_LoadEn
$LN21@Mod_LoadEn:

; 1730 : 			else if( !Q_stricmp( keyname, "message" ))

	push	99999					; 0001869fH
	push	OFFSET $SG146093
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN26@Mod_LoadEn

; 1731 : 				Q_strncpy( world.message, token, sizeof( world.message ));

	push	2048					; 00000800H
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	OFFSET _world+8
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN22@Mod_LoadEn
$LN26@Mod_LoadEn:

; 1732 : 			else if( !Q_stricmp( keyname, "compiler" ) || !Q_stricmp( keyname, "_compiler" ))

	push	99999					; 0001869fH
	push	OFFSET $SG146097
	lea	edx, DWORD PTR _keyname$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN30@Mod_LoadEn
	push	99999					; 0001869fH
	push	OFFSET $SG146098
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@Mod_LoadEn
$LN30@Mod_LoadEn:

; 1733 : 				Q_strncpy( world.compiler, token, sizeof( world.compiler ));

	push	256					; 00000100H
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	OFFSET _world+2056
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@Mod_LoadEn
$LN28@Mod_LoadEn:

; 1734 : 			else if( !Q_stricmp( keyname, "generator" ) || !Q_stricmp( keyname, "_generator" ))

	push	99999					; 0001869fH
	push	OFFSET $SG146101
	lea	edx, DWORD PTR _keyname$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN32@Mod_LoadEn
	push	99999					; 0001869fH
	push	OFFSET $SG146102
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@Mod_LoadEn
$LN32@Mod_LoadEn:

; 1735 : 				Q_strncpy( world.generator, token, sizeof( world.generator ));

	push	256					; 00000100H
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	OFFSET _world+2312
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN22@Mod_LoadEn:

; 1736 : 		}

	jmp	$LN4@Mod_LoadEn
$LN5@Mod_LoadEn:

; 1737 : 		return;	// all done

	jmp	SHORT $LN33@Mod_LoadEn

; 1738 : 	}

	jmp	$LN2@Mod_LoadEn
$LN33@Mod_LoadEn:

; 1739 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv172 = -24						; size = 4
_i$ = -20						; size = 4
_oldmaxfaces$ = -16					; size = 4
_out$ = -12						; size = 4
_in$ = -8						; size = 4
_j$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadSubmodels PROC

; 1574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 1575 : 	dmodel_t	*in, *out;
; 1576 : 	int	oldmaxfaces;
; 1577 : 	int	i, j;
; 1578 : 
; 1579 : 	// allocate extradata for each dmodel_t
; 1580 : 	out = Mem_Malloc( loadmodel->mempool, bmod->numsubmodels * sizeof( *out ));

	push	1580					; 0000062cH
	push	OFFSET $SG146022
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 1581 : 
; 1582 : 	loadmodel->numsubmodels = bmod->numsubmodels;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+120], eax

; 1583 : 	loadmodel->submodels = out;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+124], edx

; 1584 : 	in = bmod->submodels;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _in$[ebp], ecx

; 1585 : 
; 1586 : 	if( bmod->isworld )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+9384], 0
	je	SHORT $LN11@Mod_LoadSu

; 1587 : 		world.max_surfaces = 0;

	mov	DWORD PTR _world+2572, 0
$LN11@Mod_LoadSu:

; 1588 : 	oldmaxfaces = world.max_surfaces;

	mov	eax, DWORD PTR _world+2572
	mov	DWORD PTR _oldmaxfaces$[ebp], eax

; 1589 : 
; 1590 : 	for( i = 0; i < bmod->numsubmodels; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadSu
$LN2@Mod_LoadSu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR _in$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _out$[ebp], eax
$LN4@Mod_LoadSu:
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	$LN3@Mod_LoadSu

; 1591 : 	{
; 1592 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadSu
$LN5@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@Mod_LoadSu

; 1593 : 		{
; 1594 : 			// reset empty bounds to prevent error
; 1595 : 			if( in->mins[j] == 999999.0f )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	ucomiss	xmm0, DWORD PTR __real@497423f0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@Mod_LoadSu

; 1596 : 				in->mins[j] = 0.0f;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN12@Mod_LoadSu:

; 1597 : 			if( in->maxs[j] == -999999.0f)

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+12]
	ucomiss	xmm0, DWORD PTR __real@c97423f0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Mod_LoadSu

; 1598 : 				in->maxs[j] = 0.0f; 

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx*4+12], xmm0
$LN13@Mod_LoadSu:

; 1599 : 
; 1600 : 			// spread the mins / maxs by a unit
; 1601 : 			out->mins[j] = in->mins[j] - 1.0f;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0

; 1602 : 			out->maxs[j] = in->maxs[j] + 1.0f;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+12], xmm0

; 1603 : 			out->origin[j] = in->origin[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+24]
	mov	DWORD PTR [eax+edx*4+24], ecx

; 1604 : 		}

	jmp	$LN5@Mod_LoadSu
$LN6@Mod_LoadSu:

; 1605 : 
; 1606 : 		for( j = 0; j < MAX_MAP_HULLS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadSu
$LN8@Mod_LoadSu:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN10@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Mod_LoadSu

; 1607 : 			out->headnode[j] = in->headnode[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+36]
	mov	DWORD PTR [ecx+eax*4+36], edx
	jmp	SHORT $LN8@Mod_LoadSu
$LN9@Mod_LoadSu:

; 1608 : 
; 1609 : 		out->visleafs = in->visleafs;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx

; 1610 : 		out->firstface = in->firstface;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 1611 : 		out->numfaces = in->numfaces;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx

; 1612 : 
; 1613 : 		if( i == 0 && bmod->isworld )

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN14@Mod_LoadSu
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN14@Mod_LoadSu

; 1614 : 			continue; // skip the world to save mem

	jmp	$LN2@Mod_LoadSu
$LN14@Mod_LoadSu:

; 1615 : 		oldmaxfaces = Q_max( oldmaxfaces, out->numfaces ); 

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _oldmaxfaces$[ebp]
	cmp	edx, DWORD PTR [ecx+60]
	jle	SHORT $LN17@Mod_LoadSu
	mov	eax, DWORD PTR _oldmaxfaces$[ebp]
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $LN18@Mod_LoadSu
$LN17@Mod_LoadSu:
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR tv172[ebp], edx
$LN18@Mod_LoadSu:
	mov	eax, DWORD PTR tv172[ebp]
	mov	DWORD PTR _oldmaxfaces$[ebp], eax

; 1616 : 	}

	jmp	$LN2@Mod_LoadSu
$LN3@Mod_LoadSu:

; 1617 : 
; 1618 : 	// these array used to sort translucent faces in bmodels
; 1619 : 	if( oldmaxfaces > world.max_surfaces )

	mov	ecx, DWORD PTR _oldmaxfaces$[ebp]
	cmp	ecx, DWORD PTR _world+2572
	jle	SHORT $LN15@Mod_LoadSu

; 1620 : 	{
; 1621 : 		world.draw_surfaces = (sortedface_t *)Z_Realloc( world.draw_surfaces, oldmaxfaces * sizeof( sortedface_t ));

	push	1621					; 00000655H
	push	OFFSET $SG146028
	push	1
	mov	edx, DWORD PTR _oldmaxfaces$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _world+2568
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _world+2568, eax

; 1622 : 		world.max_surfaces = oldmaxfaces;

	mov	edx, DWORD PTR _oldmaxfaces$[ebp]
	mov	DWORD PTR _world+2572, edx
$LN15@Mod_LoadSu:

; 1623 : 	}
; 1624 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSubmodels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_ents$ = -44						; size = 4
_mempool$ = -40						; size = 4
_colored$ = -36						; size = 4
_surf$1 = -32						; size = 4
_i$ = -28						; size = 4
_j$ = -24						; size = 4
_bm$ = -20						; size = 4
_mod$ = -16						; size = 4
_name$2 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_SetupSubmodels PROC

; 1469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1470 : 	qboolean	colored = false;

	mov	DWORD PTR _colored$[ebp], 0

; 1471 : 	byte	*mempool;
; 1472 : 	char	*ents;
; 1473 : 	model_t	*mod;
; 1474 : 	dmodel_t 	*bm;
; 1475 : 	int	i, j;
; 1476 : 
; 1477 : 	ents = loadmodel->entities;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _ents$[ebp], ecx

; 1478 : 	mempool = loadmodel->mempool;

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _mempool$[ebp], eax

; 1479 : 	if( FBitSet( loadmodel->flags, MODEL_COLORED_LIGHTING ))

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 16					; 00000010H
	je	SHORT $LN11@Mod_SetupS

; 1480 : 		colored = true;

	mov	DWORD PTR _colored$[ebp], 1
$LN11@Mod_SetupS:

; 1481 : 	mod = loadmodel;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR _mod$[ebp], eax

; 1482 : 
; 1483 : 	loadmodel->numframes = 2;	// regular and alternate animation

	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+72], 2

; 1484 : 
; 1485 : 	// set up the submodels
; 1486 : 	for( i = 0; i < mod->numsubmodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_SetupS
$LN2@Mod_SetupS:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Mod_SetupS:
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+120]
	jge	$LN3@Mod_SetupS

; 1487 : 	{
; 1488 : 		bm = &mod->submodels[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _mod$[ebp]
	add	edx, DWORD PTR [eax+124]
	mov	DWORD PTR _bm$[ebp], edx

; 1489 : 
; 1490 : 		// hull 0 is just shared across all bmodels
; 1491 : 		mod->hulls[0].firstclipnode = bm->headnode[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [esi+edx+36]
	mov	DWORD PTR [eax+ecx+216], edx

; 1492 : 		mod->hulls[0].lastclipnode = bm->headnode[0]; // need to be real count

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+36]
	mov	DWORD PTR [edx+eax+220], ecx

; 1493 : 
; 1494 : 		// counting a real number of clipnodes per each submodel
; 1495 : 		CountClipNodes_r( mod->hulls[0].clipnodes, &mod->hulls[0], bm->headnode[0] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+208]
	push	eax
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+edx+208]
	push	ecx
	call	_CountClipNodes_r
	add	esp, 12					; 0000000cH

; 1496 : 
; 1497 : 		// but hulls1-3 is build individually for a each given submodel
; 1498 : 		for( j = 1; j < MAX_MAP_HULLS; j++ )

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN7@Mod_SetupS
$LN5@Mod_SetupS:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@Mod_SetupS:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_SetupS

; 1499 : 			Mod_SetupHull( bmod, mod, mempool, bm->headnode[j], j );

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+36]
	push	eax
	mov	ecx, DWORD PTR _mempool$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_SetupHull
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@Mod_SetupS
$LN6@Mod_SetupS:

; 1500 : 
; 1501 : 		mod->firstmodelsurface = bm->firstface;

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+112], eax

; 1502 : 		mod->nummodelsurfaces = bm->numfaces;

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+116], eax

; 1503 : 
; 1504 : 		VectorCopy( bm->mins, mod->mins );		

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+84], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+84], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+84], ecx

; 1505 : 		VectorCopy( bm->maxs, mod->maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [esi+eax+12]
	mov	DWORD PTR [ecx+edx+96], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [eax+edx+96], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [esi+edx+12]
	mov	DWORD PTR [ecx+eax+96], edx

; 1506 : 
; 1507 : 		mod->radius = RadiusFromBounds( mod->mins, mod->maxs );

	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	mov	edx, DWORD PTR _mod$[ebp]
	fstp	DWORD PTR [edx+108]

; 1508 : 		mod->numleafs = bm->visleafs;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+136], edx

; 1509 : 		mod->flags = 0;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1510 : 
; 1511 : 		// this bit will be shared between all the submodels include worldmodel
; 1512 : 		if( colored ) SetBits( mod->flags, MODEL_COLORED_LIGHTING );

	cmp	DWORD PTR _colored$[ebp], 0
	je	SHORT $LN12@Mod_SetupS
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+80], edx
$LN12@Mod_SetupS:

; 1513 : 
; 1514 : 		if( i != 0 )

	cmp	DWORD PTR _i$[ebp], 0
	je	$LN16@Mod_SetupS

; 1515 : 		{
; 1516 : 			Mod_FindModelOrigin( ents, va( "*%i", i ), bm->origin );

	mov	ecx, DWORD PTR _bm$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG145990
	call	_va
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _ents$[ebp]
	push	eax
	call	_Mod_FindModelOrigin
	add	esp, 12					; 0000000cH

; 1517 : 
; 1518 : 			// mark models that have origin brushes
; 1519 : 			if( !VectorIsNull( bm->origin ))

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _bm$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+24]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@Mod_SetupS
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _bm$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+24]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@Mod_SetupS
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bm$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+24]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@Mod_SetupS
$LN15@Mod_SetupS:

; 1520 : 				SetBits( mod->flags, MODEL_HAS_ORIGIN );

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+80]
	or	eax, 2
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [ecx+80], eax
$LN14@Mod_SetupS:

; 1521 : #ifdef HACKS_RELATED_HLMODS
; 1522 : 			// c2a1 doesn't have origin brush it's just placed at center of the level
; 1523 : 			if( !Q_stricmp( loadmodel->name, "maps/c2a1.bsp" ) && ( i == 11 ))

	push	99999					; 0001869fH
	push	OFFSET $SG145994
	mov	edx, DWORD PTR _loadmodel
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Mod_SetupS
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jne	SHORT $LN16@Mod_SetupS

; 1524 : 				SetBits( mod->flags, MODEL_HAS_ORIGIN );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 2
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN16@Mod_SetupS:

; 1525 : #endif
; 1526 : 		}
; 1527 : 
; 1528 : 		// sets the model flags
; 1529 : 		for( j = 0; i != 0 && j < mod->nummodelsurfaces; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_SetupS
$LN8@Mod_SetupS:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_SetupS:
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN9@Mod_SetupS
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+116]
	jge	SHORT $LN9@Mod_SetupS

; 1530 : 		{
; 1531 : 			msurface_t *surf = mod->surfaces + mod->firstmodelsurface + j;

	mov	eax, DWORD PTR _mod$[ebp]
	imul	ecx, DWORD PTR [eax+112], 92
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+180]
	add	eax, ecx
	imul	ecx, DWORD PTR _j$[ebp], 92
	add	eax, ecx
	mov	DWORD PTR _surf$1[ebp], eax

; 1532 : 
; 1533 : 			if( FBitSet( surf->flags, SURF_CONVEYOR ))

	mov	edx, DWORD PTR _surf$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 64					; 00000040H
	je	SHORT $LN17@Mod_SetupS

; 1534 : 				SetBits( mod->flags, MODEL_CONVEYOR );

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	or	edx, 1
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+80], edx
$LN17@Mod_SetupS:

; 1535 : 
; 1536 : 			if( FBitSet( surf->flags, SURF_TRANSPARENT ))

	mov	ecx, DWORD PTR _surf$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 256				; 00000100H
	je	SHORT $LN18@Mod_SetupS

; 1537 : 				SetBits( mod->flags, MODEL_TRANSPARENT );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 8
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN18@Mod_SetupS:

; 1538 : 
; 1539 : 			if( FBitSet( surf->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _surf$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN19@Mod_SetupS

; 1540 : 				SetBits( mod->flags, MODEL_LIQUID );

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+80]
	or	eax, 4
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [ecx+80], eax
$LN19@Mod_SetupS:

; 1541 : 		}

	jmp	$LN8@Mod_SetupS
$LN9@Mod_SetupS:

; 1542 : 
; 1543 : 		if( i < mod->numsubmodels - 1 )

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+120]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN20@Mod_SetupS

; 1544 : 		{
; 1545 : 			char	name[8];
; 1546 : 
; 1547 : 			// duplicate the basic information
; 1548 : 			Q_snprintf( name, sizeof( name ), "*%i", i + 1 );

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	push	ecx
	push	OFFSET $SG145999
	push	8
	lea	edx, DWORD PTR _name$2[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1549 : 			loadmodel = Mod_FindName( name, true );

	push	1
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _loadmodel, eax

; 1550 : 			*loadmodel = *mod;

	mov	ecx, 98					; 00000062H
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edi, DWORD PTR _loadmodel
	rep movsd

; 1551 : 			Q_strncpy( loadmodel->name, name, sizeof( loadmodel->name ));

	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1552 : 			loadmodel->mempool = NULL;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+76], 0

; 1553 : 			mod = loadmodel;

	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR _mod$[ebp], ecx
$LN20@Mod_SetupS:

; 1554 : 		}
; 1555 : 	}

	jmp	$LN2@Mod_SetupS
$LN3@Mod_SetupS:

; 1556 : 
; 1557 : 	if( bmod->clipnodes_out != NULL )

	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN21@Mod_SetupS

; 1558 : 		Mem_Free( bmod->clipnodes_out );

	push	1558					; 00000616H
	push	OFFSET $SG146001
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN21@Mod_SetupS:

; 1559 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetupSubmodels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_iCompare$ = -148					; size = 4
tv91 = -144						; size = 4
_in$ = -140						; size = 4
_deluxdatasize$ = -136					; size = 4
_modelname$ = -132					; size = 64
_path$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadDeluxemap PROC

; 1414 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1415 : 	char	modelname[64];
; 1416 : 	size_t	deluxdatasize;
; 1417 : 	char	path[64];
; 1418 : 	int	iCompare;
; 1419 : 	byte	*in;
; 1420 : 
; 1421 : 	if( !FBitSet( host.features, ENGINE_LOAD_DELUXEDATA ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 4
	jne	SHORT $LN2@Mod_LoadDe

; 1422 : 		return;

	jmp	$LN1@Mod_LoadDe
$LN2@Mod_LoadDe:

; 1423 : 
; 1424 : 	COM_FileBase( loadmodel->name, modelname );

	lea	ecx, DWORD PTR _modelname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 1425 : 	Q_snprintf( path, sizeof( path ), "maps/%s.dlit", modelname );

	lea	eax, DWORD PTR _modelname$[ebp]
	push	eax
	push	OFFSET $SG145949
	push	64					; 00000040H
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1426 : 
; 1427 : 	// make sure what deluxemap is actual
; 1428 : 	if( !COM_CompareFileTime( path, loadmodel->name, &iCompare ))

	lea	edx, DWORD PTR _iCompare$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_COM_CompareFileTime
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Mod_LoadDe

; 1429 : 		return;

	jmp	$LN1@Mod_LoadDe
$LN3@Mod_LoadDe:

; 1430 : 
; 1431 : 	if( iCompare < 0 ) // this may happens if level-designer used -onlyents key for hlcsg

	cmp	DWORD PTR _iCompare$[ebp], 0
	jge	SHORT $LN4@Mod_LoadDe

; 1432 : 		Con_Printf( S_WARN "%s probably is out of date\n", path );

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET $SG145952
	call	_Con_Printf
	add	esp, 8
$LN4@Mod_LoadDe:

; 1433 : 
; 1434 : 	in = FS_LoadFile( path, &deluxdatasize, false );

	push	0
	lea	eax, DWORD PTR _deluxdatasize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _in$[ebp], eax

; 1435 : 
; 1436 : 	Assert( in != NULL );

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN9@Mod_LoadDe
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN10@Mod_LoadDe
$LN9@Mod_LoadDe:
	mov	DWORD PTR tv91[ebp], 0
$LN10@Mod_LoadDe:
	push	0
	push	1436					; 0000059cH
	push	OFFSET $SG145953
	push	OFFSET $SG145954
	mov	edx, DWORD PTR tv91[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1437 : 
; 1438 : 	if( *(uint *)in != IDDELUXEMAPHEADER || *((uint *)in + 1) != DELUXEMAP_VERSION )

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax], 1414089809		; 54494c51H
	jne	SHORT $LN6@Mod_LoadDe
	mov	ecx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN5@Mod_LoadDe
$LN6@Mod_LoadDe:

; 1439 : 	{
; 1440 : 		Mem_Free( in );

	push	1440					; 000005a0H
	push	OFFSET $SG145957
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1441 : 		return;

	jmp	$LN1@Mod_LoadDe
$LN5@Mod_LoadDe:

; 1442 : 	}
; 1443 : 
; 1444 : 	// skip header bytes
; 1445 : 	deluxdatasize -= 8;

	mov	eax, DWORD PTR _deluxdatasize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _deluxdatasize$[ebp], eax

; 1446 : 
; 1447 : 	if( deluxdatasize != bmod->lightdatasize )

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _deluxdatasize$[ebp]
	cmp	edx, DWORD PTR [ecx+108]
	je	SHORT $LN7@Mod_LoadDe

; 1448 : 	{
; 1449 : 		Con_Reportf( S_ERROR "%s has mismatched size (%i should be %i)\n", path, deluxdatasize, bmod->lightdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _deluxdatasize$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET $SG145959
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1450 : 		Mem_Free( in );

	push	1450					; 000005aaH
	push	OFFSET $SG145960
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1451 : 		return;

	jmp	SHORT $LN1@Mod_LoadDe
$LN7@Mod_LoadDe:

; 1452 : 	}
; 1453 : 
; 1454 : 	bmod->deluxedata_out = Mem_Malloc( loadmodel->mempool, deluxdatasize );

	push	1454					; 000005aeH
	push	OFFSET $SG145961
	push	0
	mov	edx, DWORD PTR _deluxdatasize$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [edx+144], eax

; 1455 : 	memcpy( bmod->deluxedata_out, in + 8, deluxdatasize );

	mov	eax, DWORD PTR _deluxdatasize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+144]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1456 : 	bmod->deluxdatasize = deluxdatasize;

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR _deluxdatasize$[ebp]
	mov	DWORD PTR [ecx+116], edx

; 1457 : 	Mem_Free( in );

	push	1457					; 000005b1H
	push	OFFSET $SG145962
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadDe:

; 1458 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadDeluxemap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_iCompare$ = -148					; size = 4
tv89 = -144						; size = 4
_in$ = -140						; size = 4
_litdatasize$ = -136					; size = 4
_modelname$ = -132					; size = 64
_path$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadColoredLighting PROC

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1363 : 	char	modelname[64];
; 1364 : 	char	path[64];
; 1365 : 	int	iCompare;
; 1366 : 	size_t	litdatasize;
; 1367 : 	byte	*in;
; 1368 : 
; 1369 : 	COM_FileBase( loadmodel->name, modelname );

	lea	eax, DWORD PTR _modelname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1370 : 	Q_snprintf( path, sizeof( path ), "maps/%s.lit", modelname );

	lea	edx, DWORD PTR _modelname$[ebp]
	push	edx
	push	OFFSET $SG145921
	push	64					; 00000040H
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1371 : 
; 1372 : 	// make sure what deluxemap is actual
; 1373 : 	if( !COM_CompareFileTime( path, loadmodel->name, &iCompare ))

	lea	ecx, DWORD PTR _iCompare$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_COM_CompareFileTime
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Mod_LoadCo

; 1374 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_LoadCo
$LN2@Mod_LoadCo:

; 1375 : 
; 1376 : 	if( iCompare < 0 ) // this may happens if level-designer used -onlyents key for hlcsg

	cmp	DWORD PTR _iCompare$[ebp], 0
	jge	SHORT $LN3@Mod_LoadCo

; 1377 : 		Con_Printf( S_WARN "%s probably is out of date\n", path );

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET $SG145924
	call	_Con_Printf
	add	esp, 8
$LN3@Mod_LoadCo:

; 1378 : 
; 1379 : 	in = FS_LoadFile( path, &litdatasize, false );

	push	0
	lea	edx, DWORD PTR _litdatasize$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _in$[ebp], eax

; 1380 : 
; 1381 : 	Assert( in != NULL );

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN8@Mod_LoadCo
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN9@Mod_LoadCo
$LN8@Mod_LoadCo:
	mov	DWORD PTR tv89[ebp], 0
$LN9@Mod_LoadCo:
	push	0
	push	1381					; 00000565H
	push	OFFSET $SG145925
	push	OFFSET $SG145926
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1382 : 
; 1383 : 	if( *(uint *)in != IDDELUXEMAPHEADER || *((uint *)in + 1) != DELUXEMAP_VERSION )

	mov	edx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [edx], 1414089809		; 54494c51H
	jne	SHORT $LN5@Mod_LoadCo
	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN4@Mod_LoadCo
$LN5@Mod_LoadCo:

; 1384 : 	{
; 1385 : 		Mem_Free( in );

	push	1385					; 00000569H
	push	OFFSET $SG145929
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1386 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_LoadCo
$LN4@Mod_LoadCo:

; 1387 : 	}
; 1388 : 
; 1389 : 	// skip header bytes
; 1390 : 	litdatasize -= 8;

	mov	edx, DWORD PTR _litdatasize$[ebp]
	sub	edx, 8
	mov	DWORD PTR _litdatasize$[ebp], edx

; 1391 : 
; 1392 : 	if( litdatasize != ( bmod->lightdatasize * 3 ))

	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+108], 3
	cmp	DWORD PTR _litdatasize$[ebp], ecx
	je	SHORT $LN6@Mod_LoadCo

; 1393 : 	{
; 1394 : 		Con_Printf( S_ERROR "%s has mismatched size (%i should be %i)\n", path, litdatasize, bmod->lightdatasize * 3 );

	mov	edx, DWORD PTR _bmod$[ebp]
	imul	eax, DWORD PTR [edx+108], 3
	push	eax
	mov	ecx, DWORD PTR _litdatasize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET $SG145931
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 1395 : 		Mem_Free( in );

	push	1395					; 00000573H
	push	OFFSET $SG145932
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1396 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_LoadCo
$LN6@Mod_LoadCo:

; 1397 : 	}
; 1398 : 
; 1399 : 	loadmodel->lightdata = Mem_Malloc( loadmodel->mempool, litdatasize );

	push	1399					; 00000577H
	push	OFFSET $SG145933
	push	0
	mov	ecx, DWORD PTR _litdatasize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+380], eax

; 1400 : 	memcpy( loadmodel->lightdata, in + 8, litdatasize );

	mov	edx, DWORD PTR _litdatasize$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+380]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1401 : 	SetBits( loadmodel->flags, MODEL_COLORED_LIGHTING );

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+80], ecx

; 1402 : 	bmod->lightdatasize = litdatasize;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _litdatasize$[ebp]
	mov	DWORD PTR [eax+108], ecx

; 1403 : 	Mem_Free( in );

	push	1403					; 0000057bH
	push	OFFSET $SG145934
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1404 : 
; 1405 : 	return true;

	mov	eax, 1
$LN1@Mod_LoadCo:

; 1406 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadColoredLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
tv75 = -8						; size = 4
_hull$ = -4						; size = 4
_bmod$ = 8						; size = 4
_mod$ = 12						; size = 4
_mempool$ = 16						; size = 4
_headnode$ = 20						; size = 4
_hullnum$ = 24						; size = 4
_Mod_SetupHull PROC

; 1308 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 1309 : 	hull_t	*hull = &mod->hulls[hullnum];

	imul	eax, DWORD PTR _hullnum$[ebp], 40
	mov	ecx, DWORD PTR _mod$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx

; 1310 : 	int	count;
; 1311 : 
; 1312 : 	// assume no hull
; 1313 : 	hull->firstclipnode = hull->lastclipnode = 0;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1314 : 	hull->planes = NULL; // hull is missed

	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [edx+4], 0

; 1315 : 
; 1316 : 	if(( headnode == -1 ) || ( hullnum != 1 && headnode == 0 ))

	cmp	DWORD PTR _headnode$[ebp], -1
	je	SHORT $LN5@Mod_SetupH
	cmp	DWORD PTR _hullnum$[ebp], 1
	je	SHORT $LN4@Mod_SetupH
	cmp	DWORD PTR _headnode$[ebp], 0
	jne	SHORT $LN4@Mod_SetupH
$LN5@Mod_SetupH:

; 1317 : 		return; // hull missed

	jmp	$LN1@Mod_SetupH
$LN4@Mod_SetupH:

; 1318 : 
; 1319 : 	if( headnode >= mod->numclipnodes )

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _headnode$[ebp]
	cmp	ecx, DWORD PTR [eax+192]
	jl	SHORT $LN6@Mod_SetupH

; 1320 : 		return;	// ZHLT weird empty hulls

	jmp	$LN1@Mod_SetupH
$LN6@Mod_SetupH:

; 1321 : 
; 1322 : 	switch( hullnum )

	mov	edx, DWORD PTR _hullnum$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN7@Mod_SetupH
	cmp	DWORD PTR tv75[ebp], 2
	je	$LN8@Mod_SetupH
	cmp	DWORD PTR tv75[ebp], 3
	je	$LN9@Mod_SetupH
	jmp	$LN10@Mod_SetupH
$LN7@Mod_SetupH:

; 1323 : 	{
; 1324 : 	case 1:
; 1325 : 		VectorCopy( host.player_mins[0], hull->clip_mins ); // copy human hull

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34236]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34236]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34236]
	mov	DWORD PTR [esi+eax+16], ecx

; 1326 : 		VectorCopy( host.player_maxs[0], hull->clip_maxs );

	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[eax+edx+34284]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34284]
	mov	DWORD PTR [esi+eax+28], ecx
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[eax+ecx+34284]
	mov	DWORD PTR [esi+edx+28], eax

; 1327 : 		break;

	jmp	$LN2@Mod_SetupH
$LN8@Mod_SetupH:

; 1328 : 	case 2:
; 1329 : 		VectorCopy( host.player_mins[3], hull->clip_mins ); // copy large hull

	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[edx+ecx+34236]
	mov	DWORD PTR [esi+eax+16], ecx
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[eax+ecx+34236]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34236]
	mov	DWORD PTR [esi+ecx+16], edx

; 1330 : 		VectorCopy( host.player_maxs[3], hull->clip_maxs );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34284]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34284]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34284]
	mov	DWORD PTR [esi+eax+28], ecx

; 1331 : 		break;

	jmp	$LN2@Mod_SetupH
$LN9@Mod_SetupH:

; 1332 : 	case 3:
; 1333 : 		VectorCopy( host.player_mins[1], hull->clip_mins ); // copy head hull

	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[edx+ecx+34236]
	mov	DWORD PTR [esi+eax+16], ecx
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34236]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[eax+ecx+34236]
	mov	DWORD PTR [esi+edx+16], eax

; 1334 : 		VectorCopy( host.player_maxs[1], hull->clip_maxs );

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34284]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34284]
	mov	DWORD PTR [esi+eax+28], ecx
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34284]
	mov	DWORD PTR [esi+ecx+28], edx

; 1335 : 		break;

	jmp	SHORT $LN2@Mod_SetupH
$LN10@Mod_SetupH:

; 1336 : 	default:
; 1337 : 		Host_Error( "Mod_SetupHull: bad hull number %i\n", hullnum );

	mov	eax, DWORD PTR _hullnum$[ebp]
	push	eax
	push	OFFSET $SG145905
	call	_Host_Error
	add	esp, 8
$LN2@Mod_SetupH:

; 1338 : 		break;
; 1339 : 	}
; 1340 : 
; 1341 : 	if( VectorIsNull( hull->clip_mins ) && VectorIsNull( hull->clip_maxs ))

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@Mod_SetupH
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH

; 1342 : 		return;	// no hull specified

	jmp	SHORT $LN1@Mod_SetupH
$LN11@Mod_SetupH:

; 1343 : 
; 1344 : 	CountClipNodes32_r( bmod->clipnodes_out, hull, headnode );

	mov	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	call	_CountClipNodes32_r
	add	esp, 12					; 0000000cH

; 1345 : 	count = hull->lastclipnode;

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _count$[ebp], edx

; 1346 : 
; 1347 : 	// fit array to real count
; 1348 : 	hull->clipnodes = (mclipnode_t *)Mem_Malloc( mempool, sizeof( mclipnode_t ) * hull->lastclipnode );

	push	1348					; 00000544H
	push	OFFSET $SG145907
	push	0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _mempool$[ebp]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [ecx], eax

; 1349 : 	hull->planes = mod->planes; // share planes

	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR [edx+4], ecx

; 1350 : 	hull->lastclipnode = 0; // restart counting

	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1351 : 
; 1352 : 	// remap clipnodes to 16-bit indexes
; 1353 : 	RemapClipNodes_r( bmod->clipnodes_out, hull, headnode );

	mov	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	call	_RemapClipNodes_r
	add	esp, 12					; 0000000cH
$LN1@Mod_SetupH:

; 1354 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetupHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_child$ = -24						; size = 4
_i$ = -20						; size = 4
_in$ = -16						; size = 4
_hull$ = -12						; size = 4
_out$ = -8						; size = 4
_j$ = -4						; size = 4
_Mod_MakeHull0 PROC

; 1273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1274 : 	mnode_t		*in, *child;
; 1275 : 	mclipnode_t	*out;
; 1276 : 	hull_t		*hull;
; 1277 : 	int		i, j;
; 1278 : 	
; 1279 : 	hull = &loadmodel->hulls[0];	

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _loadmodel
	lea	eax, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 1280 : 	hull->clipnodes = out = Mem_Malloc( loadmodel->mempool, loadmodel->numnodes * sizeof( *out ));	

	push	1280					; 00000500H
	push	OFFSET $SG145876
	push	0
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+160]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx], eax

; 1281 : 	in = loadmodel->nodes;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR _in$[ebp], edx

; 1282 : 
; 1283 : 	hull->firstclipnode = 0;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1284 : 	hull->lastclipnode = loadmodel->numnodes - 1;

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+160]
	sub	edx, 1
	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1285 : 	hull->planes = loadmodel->planes;

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+132]
	mov	DWORD PTR [ecx+4], eax

; 1286 : 
; 1287 : 	for( i = 0; i < loadmodel->numnodes; i++, out++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_MakeHu
$LN2@Mod_MakeHu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 8
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _in$[ebp], eax
$LN4@Mod_MakeHu:
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+160]
	jge	$LN1@Mod_MakeHu

; 1288 : 	{
; 1289 : 		out->planenum = in->plane - loadmodel->planes;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [eax+36]
	sub	eax, DWORD PTR [ecx+132]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx], eax

; 1290 : 
; 1291 : 		for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_MakeHu
$LN5@Mod_MakeHu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_MakeHu:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN6@Mod_MakeHu

; 1292 : 		{
; 1293 : 			child = in->children[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _child$[ebp], eax

; 1294 : 
; 1295 : 			if( child->contents < 0 )

	mov	ecx, DWORD PTR _child$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN8@Mod_MakeHu

; 1296 : 				out->children[j] = child->contents;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _child$[ebp]
	mov	cx, WORD PTR [ecx]
	mov	WORD PTR [eax+edx*2+4], cx
	jmp	SHORT $LN9@Mod_MakeHu
$LN8@Mod_MakeHu:

; 1297 : 			else out->children[j] = child - loadmodel->nodes;

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _child$[ebp]
	sub	eax, DWORD PTR [edx+164]
	cdq
	mov	ecx, 52					; 00000034H
	idiv	ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx+edx*2+4], ax
$LN9@Mod_MakeHu:

; 1298 : 		}

	jmp	SHORT $LN5@Mod_MakeHu
$LN6@Mod_MakeHu:

; 1299 : 	}

	jmp	$LN2@Mod_MakeHu
$LN1@Mod_MakeHu:

; 1300 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_MakeHull0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_c$ = -16						; size = 4
_out$ = -12						; size = 4
_src$ = -8						; size = 4
_i$ = -4						; size = 4
_srcnodes$ = 8						; size = 4
_hull$ = 12						; size = 4
_nodenum$ = 16						; size = 4
_RemapClipNodes_r PROC

; 1239 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1240 : 	dclipnode32_t	*src;
; 1241 : 	mclipnode_t	*out;
; 1242 : 	int		i, c;
; 1243 : 
; 1244 : 	// leaf?
; 1245 : 	if( nodenum < 0 )

	cmp	DWORD PTR _nodenum$[ebp], 0
	jge	SHORT $LN5@RemapClipN

; 1246 : 		return nodenum;

	mov	eax, DWORD PTR _nodenum$[ebp]
	jmp	$LN1@RemapClipN
$LN5@RemapClipN:

; 1247 : 
; 1248 : 	// emit a clipnode
; 1249 : 	if( hull->lastclipnode == MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+12], 32767		; 00007fffH
	jne	SHORT $LN6@RemapClipN

; 1250 : 		Host_Error( "MAX_MAP_CLIPNODES limit exceeded\n" );

	push	OFFSET $SG145860
	call	_Host_Error
	add	esp, 4
$LN6@RemapClipN:

; 1251 : 	src = srcnodes + nodenum;

	imul	ecx, DWORD PTR _nodenum$[ebp], 12
	add	ecx, DWORD PTR _srcnodes$[ebp]
	mov	DWORD PTR _src$[ebp], ecx

; 1252 : 
; 1253 : 	c = hull->lastclipnode;

	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _c$[ebp], eax

; 1254 : 	out = &hull->clipnodes[c];

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _c$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _out$[ebp], ecx

; 1255 : 	hull->lastclipnode++;

	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1256 : 
; 1257 : 	out->planenum = src->planenum;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 1258 : 
; 1259 : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@RemapClipN
$LN2@RemapClipN:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@RemapClipN:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@RemapClipN

; 1260 : 		out->children[i] = RemapClipNodes_r( srcnodes, hull, src->children[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcnodes$[ebp]
	push	ecx
	call	_RemapClipNodes_r
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx+edx*2+4], ax
	jmp	SHORT $LN2@RemapClipN
$LN3@RemapClipN:

; 1261 : 
; 1262 : 	return c;

	mov	eax, DWORD PTR _c$[ebp]
$LN1@RemapClipN:

; 1263 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RemapClipNodes_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_src$ = 8						; size = 4
_hull$ = 12						; size = 4
_nodenum$ = 16						; size = 4
_CountClipNodes32_r PROC

; 1221 : {

	push	ebp
	mov	ebp, esp

; 1222 : 	// leaf?
; 1223 : 	if( nodenum < 0 ) return;

	cmp	DWORD PTR _nodenum$[ebp], 0
	jge	SHORT $LN2@CountClipN
	jmp	SHORT $LN1@CountClipN
$LN2@CountClipN:

; 1224 : 
; 1225 : 	if( hull->lastclipnode == MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+12], 32767		; 00007fffH
	jne	SHORT $LN3@CountClipN

; 1226 : 		Host_Error( "MAX_MAP_CLIPNODES limit exceeded\n" );

	push	OFFSET $SG145842
	call	_Host_Error
	add	esp, 4
$LN3@CountClipN:

; 1227 : 	hull->lastclipnode++;

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1228 : 
; 1229 : 	CountClipNodes32_r( src, hull, src[nodenum].children[0] );

	imul	ecx, DWORD PTR _nodenum$[ebp], 12
	add	ecx, DWORD PTR _src$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+eax+4]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_CountClipNodes32_r
	add	esp, 12					; 0000000cH

; 1230 : 	CountClipNodes32_r( src, hull, src[nodenum].children[1] );

	imul	ecx, DWORD PTR _nodenum$[ebp], 12
	add	ecx, DWORD PTR _src$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+4]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	_CountClipNodes32_r
	add	esp, 12					; 0000000cH
$LN1@CountClipN:

; 1231 : }

	pop	ebp
	ret	0
_CountClipNodes32_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_src$ = 8						; size = 4
_hull$ = 12						; size = 4
_nodenum$ = 16						; size = 4
_CountClipNodes_r PROC

; 1203 : {

	push	ebp
	mov	ebp, esp

; 1204 : 	// leaf?
; 1205 : 	if( nodenum < 0 ) return;

	cmp	DWORD PTR _nodenum$[ebp], 0
	jge	SHORT $LN2@CountClipN
	jmp	SHORT $LN1@CountClipN
$LN2@CountClipN:

; 1206 : 
; 1207 : 	if( hull->lastclipnode == MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+12], 32767		; 00007fffH
	jne	SHORT $LN3@CountClipN

; 1208 : 		Host_Error( "MAX_MAP_CLIPNODES limit exceeded\n" );

	push	OFFSET $SG145831
	call	_Host_Error
	add	esp, 4
$LN3@CountClipN:

; 1209 : 	hull->lastclipnode++;

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1210 : 
; 1211 : 	CountClipNodes_r( src, hull, src[nodenum].children[0] );

	mov	ecx, DWORD PTR _nodenum$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx+4]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	_CountClipNodes_r
	add	esp, 12					; 0000000cH

; 1212 : 	CountClipNodes_r( src, hull, src[nodenum].children[1] );

	mov	eax, DWORD PTR _nodenum$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax+4]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_CountClipNodes_r
	add	esp, 12					; 0000000cH
$LN1@CountClipN:

; 1213 : }

	pop	ebp
	ret	0
_CountClipNodes_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_node$ = 8						; size = 4
_parent$ = 12						; size = 4
_Mod_SetParent PROC

; 1189 : {

	push	ebp
	mov	ebp, esp

; 1190 : 	node->parent = parent;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1191 : 
; 1192 : 	if( node->contents < 0 ) return; // it's leaf

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], 0
	jge	SHORT $LN2@Mod_SetPar
	jmp	SHORT $LN1@Mod_SetPar
$LN2@Mod_SetPar:

; 1193 : 	Mod_SetParent( node->children[0], node );

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_Mod_SetParent
	add	esp, 8

; 1194 : 	Mod_SetParent( node->children[1], node );

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_Mod_SetParent
	add	esp, 8
$LN1@Mod_SetPar:

; 1195 : }

	pop	ebp
	ret	0
_Mod_SetParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv431 = -108						; size = 4
tv396 = -104						; size = 4
tv363 = -100						; size = 4
tv252 = -96						; size = 4
tv210 = -92						; size = 4
tv146 = -88						; size = 4
_size$ = -84						; size = 4
tv456 = -80						; size = 4
_radius$ = -76						; size = 4
_contents$ = -72					; size = 4
_v1$ = -68						; size = 4
_facebevel$ = -64					; size = 4
_ilength$1 = -60					; size = 4
_i$ = -56						; size = 4
_v0$ = -52						; size = 4
_dest$2 = -48						; size = 4
_fb$ = -44						; size = 4
_delta$ = -40						; size = 12
_edgevec$ = -28						; size = 12
_faceNormal$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_surf$ = 8						; size = 4
_Mod_CreateFaceBevels PROC

; 1129 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1130 : 	vec3_t		delta, edgevec;
; 1131 : 	byte		*facebevel;
; 1132 : 	vec3_t		faceNormal;
; 1133 : 	mvertex_t		*v0, *v1;
; 1134 : 	int		contents;
; 1135 : 	int		i, size;
; 1136 : 	vec_t		radius;
; 1137 : 	mfacebevel_t	*fb;
; 1138 : 
; 1139 : 	if( surf->texinfo && surf->texinfo->texture )

	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@Mod_Create
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN8@Mod_Create

; 1140 : 		contents = Mod_GetFaceContents( surf->texinfo->texture->name );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_Mod_GetFaceContents
	add	esp, 4
	mov	DWORD PTR _contents$[ebp], eax
	jmp	SHORT $LN9@Mod_Create
$LN8@Mod_Create:

; 1141 : 	else contents = CONTENTS_SOLID;

	mov	DWORD PTR _contents$[ebp], -2		; fffffffeH
$LN9@Mod_Create:

; 1142 : 
; 1143 : 	size = sizeof( mfacebevel_t ) + surf->numedges * sizeof( mplane_t );

	mov	eax, DWORD PTR _surf$[ebp]
	imul	ecx, DWORD PTR [eax+16], 20
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _size$[ebp], ecx

; 1144 : 	facebevel = (byte *)Mem_Calloc( loadmodel->mempool, size );

	push	1144					; 00000478H
	push	OFFSET $SG145810
	push	1
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _facebevel$[ebp], eax

; 1145 : 	fb = (mfacebevel_t *)facebevel;

	mov	edx, DWORD PTR _facebevel$[ebp]
	mov	DWORD PTR _fb$[ebp], edx

; 1146 : 	facebevel += sizeof( mfacebevel_t );

	mov	eax, DWORD PTR _facebevel$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _facebevel$[ebp], eax

; 1147 : 	fb->edges = (mplane_t *)facebevel;

	mov	ecx, DWORD PTR _fb$[ebp]
	mov	edx, DWORD PTR _facebevel$[ebp]
	mov	DWORD PTR [ecx], edx

; 1148 : 	fb->numedges = surf->numedges;

	mov	eax, DWORD PTR _fb$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+4], edx

; 1149 : 	fb->contents = contents;

	mov	eax, DWORD PTR _fb$[ebp]
	mov	ecx, DWORD PTR _contents$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1150 : 	surf->info->bevel = fb;

	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _fb$[ebp]
	mov	DWORD PTR [eax+104], ecx

; 1151 : 
; 1152 : 	if( FBitSet( surf->flags, SURF_PLANEBACK ))

	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 2
	je	$LN10@Mod_Create

; 1153 : 		VectorNegate( surf->plane->normal, faceNormal );

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _faceNormal$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _faceNormal$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv146[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR _faceNormal$[ebp+edx], xmm0
	jmp	SHORT $LN11@Mod_Create
$LN10@Mod_Create:

; 1154 : 	else VectorCopy( surf->plane->normal, faceNormal );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _faceNormal$[ebp+edx], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR _faceNormal$[ebp+ecx], edx
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _faceNormal$[ebp+eax], ecx
$LN11@Mod_Create:

; 1155 : 
; 1156 : 	// compute face origin and plane edges
; 1157 : 	for( i = 0; i < surf->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Create
$LN2@Mod_Create:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Mod_Create:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN3@Mod_Create

; 1158 : 	{
; 1159 : 		mplane_t	*dest = &fb->edges[i];

	imul	edx, DWORD PTR _i$[ebp], 20
	mov	eax, DWORD PTR _fb$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _dest$2[ebp], edx

; 1160 : 
; 1161 : 		v0 = Mod_GetVertexByNumber( loadmodel, surf->firstedge + i );

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	push	eax
	call	_Mod_GetVertexByNumber
	add	esp, 8
	mov	DWORD PTR _v0$[ebp], eax

; 1162 : 		v1 = Mod_GetVertexByNumber( loadmodel, surf->firstedge + (i + 1) % surf->numedges );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _surf$[ebp]
	cdq
	idiv	DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _surf$[ebp]
	add	edx, DWORD PTR [eax+12]
	push	edx
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_Mod_GetVertexByNumber
	add	esp, 8
	mov	DWORD PTR _v1$[ebp], eax

; 1163 : 		VectorSubtract( v1->position, v0->position, edgevec );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _v1$[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _edgevec$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _v1$[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _edgevec$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _v1$[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv210[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv210[ebp]
	movss	DWORD PTR _edgevec$[ebp+edx], xmm0

; 1164 : 		CrossProduct( faceNormal, edgevec, dest->normal );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _faceNormal$[ebp+eax]
	mulss	xmm0, DWORD PTR _edgevec$[ebp+ecx]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _faceNormal$[ebp+edx]
	mulss	xmm1, DWORD PTR _edgevec$[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dest$2[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _faceNormal$[ebp+ecx]
	mulss	xmm0, DWORD PTR _edgevec$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _faceNormal$[ebp+edx]
	mulss	xmm1, DWORD PTR _edgevec$[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$2[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _faceNormal$[ebp+ecx]
	mulss	xmm0, DWORD PTR _edgevec$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR _faceNormal$[ebp+eax]
	mulss	xmm1, DWORD PTR _edgevec$[ebp+edx]
	subss	xmm0, xmm1
	movss	DWORD PTR tv252[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dest$2[ebp]
	movss	xmm0, DWORD PTR tv252[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1165 : 		VectorNormalize( dest->normal );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dest$2[ebp]
	mov	esi, DWORD PTR _dest$2[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$2[ebp]
	mov	esi, DWORD PTR _dest$2[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dest$2[ebp]
	mov	esi, DWORD PTR _dest$2[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@Mod_Create
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN12@Mod_Create:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _dest$2[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _dest$2[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dest$2[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dest$2[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dest$2[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dest$2[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1166 : 		dest->dist = DotProduct( dest->normal, v0->position );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _dest$2[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dest$2[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dest$2[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _dest$2[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 1167 : 		dest->type = PlaneTypeForNormal( dest->normal );

	mov	edx, DWORD PTR _dest$2[ebp]
	push	edx
	call	_PlaneTypeForNormal
	add	esp, 4
	mov	ecx, DWORD PTR _dest$2[ebp]
	mov	BYTE PTR [ecx+16], al

; 1168 : 		VectorAdd( fb->origin, v0->position, fb->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _fb$[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+8]
	addss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _fb$[ebp]
	movss	DWORD PTR [ecx+eax+8], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fb$[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+8]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _fb$[ebp]
	movss	DWORD PTR [eax+edx+8], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _fb$[ebp]
	mov	esi, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+8]
	addss	xmm0, DWORD PTR [esi+edx]
	movss	DWORD PTR tv363[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR tv363[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm0

; 1169 : 	}

	jmp	$LN2@Mod_Create
$LN3@Mod_Create:

; 1170 : 
; 1171 : 	VectorScale( fb->origin, 1.0f / surf->numedges, fb->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	mov	eax, DWORD PTR _fb$[ebp]
	mulss	xmm1, DWORD PTR [eax+ecx+8]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _fb$[ebp]
	movss	DWORD PTR [eax+edx+8], xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _surf$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	mov	eax, DWORD PTR _fb$[ebp]
	mulss	xmm1, DWORD PTR [eax+ecx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fb$[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _surf$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+16]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	mov	edx, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+8]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv396[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR tv396[ebp]
	movss	DWORD PTR [ecx+eax+8], xmm0

; 1172 : 
; 1173 : 	// compute face radius
; 1174 : 	for( i = 0; i < surf->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_Create
$LN5@Mod_Create:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Mod_Create:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN6@Mod_Create

; 1175 : 	{
; 1176 : 		v0 = Mod_GetVertexByNumber( loadmodel, surf->firstedge + i );

	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_Mod_GetVertexByNumber
	add	esp, 8
	mov	DWORD PTR _v0$[ebp], eax

; 1177 : 		VectorSubtract( v0->position, fb->origin, delta );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _v0$[ebp]
	mov	esi, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [esi+edx+8]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _v0$[ebp]
	mov	esi, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx+8]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _v0$[ebp]
	mov	esi, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+8]
	movss	DWORD PTR tv431[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv431[ebp]
	movss	DWORD PTR _delta$[ebp+edx], xmm0

; 1178 : 		radius = DotProduct( delta, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _radius$[ebp], xmm0

; 1179 : 		fb->radius = Q_max( radius, fb->radius );

	mov	edx, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR _radius$[ebp]
	comiss	xmm0, DWORD PTR [edx+20]
	jbe	SHORT $LN14@Mod_Create
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR tv456[ebp], xmm0
	jmp	SHORT $LN15@Mod_Create
$LN14@Mod_Create:
	mov	eax, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	movss	DWORD PTR tv456[ebp], xmm0
$LN15@Mod_Create:
	mov	ecx, DWORD PTR _fb$[ebp]
	movss	xmm0, DWORD PTR tv456[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 1180 : 	}

	jmp	$LN5@Mod_Create
$LN6@Mod_Create:

; 1181 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CreateFaceBevels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv196 = -16						; size = 4
_v$ = -12						; size = 4
_i$ = -8						; size = 4
_e$ = -4						; size = 4
_surf$ = 8						; size = 4
_Mod_CalcSurfaceBounds PROC

; 1102 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 1103 : 	int	i, e;
; 1104 : 	mvertex_t	*v;
; 1105 : 
; 1106 : 	ClearBounds( surf->info->mins, surf->info->maxs );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	call	_ClearBounds
	add	esp, 8

; 1107 : 
; 1108 : 	for( i = 0; i < surf->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CalcSu
$LN2@Mod_CalcSu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Mod_CalcSu:
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	$LN3@Mod_CalcSu

; 1109 : 	{
; 1110 : 		e = loadmodel->surfedges[surf->firstedge + i];

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _e$[ebp], edx

; 1111 : 
; 1112 : 		if( e >= loadmodel->numedges || e <= -loadmodel->numedges )

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR [eax+152]
	jge	SHORT $LN6@Mod_CalcSu
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+152]
	neg	eax
	cmp	DWORD PTR _e$[ebp], eax
	jg	SHORT $LN5@Mod_CalcSu
$LN6@Mod_CalcSu:

; 1113 : 			Host_Error( "Mod_CalcSurfaceBounds: bad edge\n" );

	push	OFFSET $SG145775
	call	_Host_Error
	add	esp, 4
$LN5@Mod_CalcSu:

; 1114 : 
; 1115 : 		if( e >= 0 ) v = &loadmodel->vertexes[loadmodel->edges[e].v[0]];

	cmp	DWORD PTR _e$[ebp], 0
	jl	SHORT $LN7@Mod_CalcSu
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _e$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, 2
	imul	eax, edx, 0
	movzx	ecx, WORD PTR [ecx+eax]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+148]
	mov	DWORD PTR _v$[ebp], edx
	jmp	SHORT $LN8@Mod_CalcSu
$LN7@Mod_CalcSu:

; 1116 : 		else v = &loadmodel->vertexes[loadmodel->edges[-e].v[1]];

	mov	ecx, DWORD PTR _e$[ebp]
	neg	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+156]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, 2
	shl	edx, 0
	movzx	eax, WORD PTR [ecx+edx]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR _v$[ebp], ecx
$LN8@Mod_CalcSu:

; 1117 : 		AddPointToBounds( v->position, surf->info->mins, surf->info->maxs );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 1118 : 	}

	jmp	$LN2@Mod_CalcSu
$LN3@Mod_CalcSu:

; 1119 : 
; 1120 : 	VectorAverage( surf->info->mins, surf->info->maxs, surf->info->origin );

	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi+12]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+edx+24], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [eax+80]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR [eax+esi+12]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+eax+24], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR [ecx+esi+12]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv196[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	movss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR [ecx+edx+24], xmm0

; 1121 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CalcSurfaceBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_bmaxs$ = -100						; size = 8
_bmins$ = -92						; size = 8
_maxs$ = -84						; size = 8
_mins$ = -76						; size = 8
_lmmaxs$ = -68						; size = 8
_lmmins$ = -60						; size = 8
_facenum$ = -52						; size = 4
tv277 = -48						; size = 4
tv267 = -44						; size = 4
tv219 = -40						; size = 4
tv209 = -36						; size = 4
_tex$ = -32						; size = 4
_sample_size$ = -28					; size = 4
_e$ = -24						; size = 4
_v$ = -20						; size = 4
_info$ = -16						; size = 4
_val$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_surf$ = 8						; size = 4
_Mod_CalcSurfaceExtents PROC

; 1023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi

; 1024 : 	float		mins[2], maxs[2], val;
; 1025 : 	float		lmmins[2], lmmaxs[2];
; 1026 : 	int		bmins[2], bmaxs[2];
; 1027 : 	int		i, j, e, sample_size;
; 1028 : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 1029 : 	int		facenum = surf - loadmodel->surfaces;

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _surf$[ebp]
	sub	eax, DWORD PTR [edx+180]
	cdq
	mov	ecx, 92					; 0000005cH
	idiv	ecx
	mov	DWORD PTR _facenum$[ebp], eax

; 1030 : 	mtexinfo_t	*tex;
; 1031 : 	mvertex_t		*v;
; 1032 : 
; 1033 : 	sample_size = Mod_SampleSizeForFace( surf );

	mov	edx, DWORD PTR _surf$[ebp]
	push	edx
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$[ebp], eax

; 1034 : 	tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 1035 : 
; 1036 : 	Mod_LightMatrixFromTexMatrix( tex, info->lmvecs ); 

	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_Mod_LightMatrixFromTexMatrix
	add	esp, 8

; 1037 : 
; 1038 : 	mins[0] = lmmins[0] = mins[1] = lmmins[1] = 999999;

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _lmmins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _lmmins$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _mins$[ebp+eax], xmm0

; 1039 : 	maxs[0] = lmmaxs[0] = maxs[1] = lmmaxs[1] =-999999;

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _lmmaxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _lmmaxs$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 1040 : 
; 1041 : 	for( i = 0; i < surf->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CalcSu
$LN2@Mod_CalcSu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Mod_CalcSu:
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	$LN3@Mod_CalcSu

; 1042 : 	{
; 1043 : 		e = loadmodel->surfedges[surf->firstedge + i];

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _e$[ebp], edx

; 1044 : 
; 1045 : 		if( e >= loadmodel->numedges || e <= -loadmodel->numedges )

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR [eax+152]
	jge	SHORT $LN15@Mod_CalcSu
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+152]
	neg	eax
	cmp	DWORD PTR _e$[ebp], eax
	jg	SHORT $LN14@Mod_CalcSu
$LN15@Mod_CalcSu:

; 1046 : 			Host_Error( "Mod_CalcSurfaceExtents: bad edge\n" );

	push	OFFSET $SG145756
	call	_Host_Error
	add	esp, 4
$LN14@Mod_CalcSu:

; 1047 : 
; 1048 : 		if( e >= 0 ) v = &loadmodel->vertexes[loadmodel->edges[e].v[0]];

	cmp	DWORD PTR _e$[ebp], 0
	jl	SHORT $LN16@Mod_CalcSu
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _e$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, 2
	imul	eax, edx, 0
	movzx	ecx, WORD PTR [ecx+eax]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+148]
	mov	DWORD PTR _v$[ebp], edx
	jmp	SHORT $LN17@Mod_CalcSu
$LN16@Mod_CalcSu:

; 1049 : 		else v = &loadmodel->vertexes[loadmodel->edges[-e].v[1]];

	mov	ecx, DWORD PTR _e$[ebp]
	neg	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+156]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, 2
	shl	edx, 0
	movzx	eax, WORD PTR [ecx+edx]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR _v$[ebp], ecx
$LN17@Mod_CalcSu:

; 1050 : 
; 1051 : 		for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_CalcSu
$LN5@Mod_CalcSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_CalcSu:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$LN6@Mod_CalcSu

; 1052 : 		{
; 1053 : 			val = DotProduct( v->position, surf->texinfo->vecs[j] ) + surf->texinfo->vecs[j][3];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	add	ecx, eax
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	add	eax, edx
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	add	eax, ecx
	mov	edx, 4
	imul	ecx, edx, 3
	addss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _val$[ebp], xmm0

; 1054 : 			mins[j] = Q_min( val, mins[j] );

	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+edx*4]
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN22@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv209[ebp], xmm0
	jmp	SHORT $LN23@Mod_CalcSu
$LN22@Mod_CalcSu:
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+eax*4]
	movss	DWORD PTR tv209[ebp], xmm0
$LN23@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR _mins$[ebp+ecx*4], xmm0

; 1055 : 			maxs[j] = Q_max( val, maxs[j] );

	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	comiss	xmm0, DWORD PTR _maxs$[ebp+edx*4]
	jbe	SHORT $LN24@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv219[ebp], xmm0
	jmp	SHORT $LN25@Mod_CalcSu
$LN24@Mod_CalcSu:
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _maxs$[ebp+eax*4]
	movss	DWORD PTR tv219[ebp], xmm0
$LN25@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR _maxs$[ebp+ecx*4], xmm0

; 1056 : 		}

	jmp	$LN5@Mod_CalcSu
$LN6@Mod_CalcSu:

; 1057 : 
; 1058 : 		for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_CalcSu
$LN8@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN10@Mod_CalcSu:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$LN9@Mod_CalcSu

; 1059 : 		{
; 1060 : 			val = DotProduct( v->position, info->lmvecs[j] ) + info->lmvecs[j][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _val$[ebp], xmm0

; 1061 : 			lmmins[j] = Q_min( val, lmmins[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmmins$[ebp+eax*4]
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN26@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv267[ebp], xmm0
	jmp	SHORT $LN27@Mod_CalcSu
$LN26@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmmins$[ebp+ecx*4]
	movss	DWORD PTR tv267[ebp], xmm0
$LN27@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv267[ebp]
	movss	DWORD PTR _lmmins$[ebp+edx*4], xmm0

; 1062 : 			lmmaxs[j] = Q_max( val, lmmaxs[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	comiss	xmm0, DWORD PTR _lmmaxs$[ebp+eax*4]
	jbe	SHORT $LN28@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv277[ebp], xmm0
	jmp	SHORT $LN29@Mod_CalcSu
$LN28@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmmaxs$[ebp+ecx*4]
	movss	DWORD PTR tv277[ebp], xmm0
$LN29@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR _lmmaxs$[ebp+edx*4], xmm0

; 1063 : 		}

	jmp	$LN8@Mod_CalcSu
$LN9@Mod_CalcSu:

; 1064 : 	}

	jmp	$LN2@Mod_CalcSu
$LN3@Mod_CalcSu:

; 1065 : 
; 1066 : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Mod_CalcSu
$LN11@Mod_CalcSu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Mod_CalcSu:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN12@Mod_CalcSu

; 1067 : 	{
; 1068 : 		bmins[i] = floor( mins[i] / sample_size );

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR _mins$[ebp+ecx*4]
	divss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bmins$[ebp+edx*4], eax

; 1069 : 		bmaxs[i] = ceil( maxs[i] / sample_size );

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR _maxs$[ebp+eax*4]
	divss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bmaxs$[ebp+ecx*4], eax

; 1070 : 
; 1071 : 		surf->texturemins[i] = bmins[i] * sample_size;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bmins$[ebp+edx*4]
	imul	eax, DWORD PTR _sample_size$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	WORD PTR [edx+ecx*2+20], ax

; 1072 : 		surf->extents[i] = (bmaxs[i] - bmins[i]) * sample_size;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _bmaxs$[ebp+eax*4]
	sub	edx, DWORD PTR _bmins$[ebp+ecx*4]
	imul	edx, DWORD PTR _sample_size$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	WORD PTR [ecx+eax*2+24], dx

; 1073 : 
; 1074 : 		if( FBitSet( tex->flags, TEX_WORLD_LUXELS ))

	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 2
	je	SHORT $LN18@Mod_CalcSu

; 1075 : 		{
; 1076 : 			lmmins[i] = floor( lmmins[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	cvtss2sd xmm0, DWORD PTR _lmmins$[ebp+ecx*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	mov	edx, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _lmmins$[ebp+edx*4]

; 1077 : 			lmmaxs[i] = ceil( lmmaxs[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cvtss2sd xmm0, DWORD PTR _lmmaxs$[ebp+eax*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _lmmaxs$[ebp+ecx*4]

; 1078 : 
; 1079 : 			info->lightmapmins[i] = lmmins[i];

	mov	edx, DWORD PTR _i$[ebp]
	cvttss2si eax, DWORD PTR _lmmins$[ebp+edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	WORD PTR [edx+ecx*2+48], ax

; 1080 : 			info->lightextents[i] = (lmmaxs[i] - lmmins[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _lmmaxs$[ebp+eax*4]
	subss	xmm0, DWORD PTR _lmmins$[ebp+ecx*4]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	WORD PTR [ecx+eax*2+52], dx

; 1081 : 		}

	jmp	SHORT $LN19@Mod_CalcSu
$LN18@Mod_CalcSu:

; 1082 : 		else
; 1083 : 		{
; 1084 : 			// just copy texturemins
; 1085 : 			info->lightmapmins[i] = surf->texturemins[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _surf$[ebp]
	mov	cx, WORD PTR [esi+ecx*2+20]
	mov	WORD PTR [eax+edx*2+48], cx

; 1086 : 			info->lightextents[i] = surf->extents[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _surf$[ebp]
	mov	cx, WORD PTR [esi+ecx*2+24]
	mov	WORD PTR [eax+edx*2+52], cx
$LN19@Mod_CalcSu:

; 1087 : 		}
; 1088 : 
; 1089 : 		if( !FBitSet( tex->flags, TEX_SPECIAL ) && ( surf->extents[i] > 16384 ) && ( tr.block_size == BLOCK_SIZE_DEFAULT ))

	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 1
	jne	SHORT $LN20@Mod_CalcSu
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _surf$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+24]
	cmp	eax, 16384				; 00004000H
	jle	SHORT $LN20@Mod_CalcSu
	cmp	DWORD PTR _tr+66964, 128		; 00000080H
	jne	SHORT $LN20@Mod_CalcSu

; 1090 : 			Con_Reportf( S_ERROR "Bad surface extents %i\n", surf->extents[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _surf$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+24]
	push	eax
	push	OFFSET $SG145762
	call	_Con_Reportf
	add	esp, 8
$LN20@Mod_CalcSu:

; 1091 : 	}

	jmp	$LN11@Mod_CalcSu
$LN12@Mod_CalcSu:

; 1092 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CalcSurfaceExtents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv348 = -28						; size = 4
tv300 = -24						; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_ilength$1 = -12					; size = 4
_ilength$2 = -8						; size = 4
_lmscale$ = -4						; size = 4
_tx$ = 8						; size = 4
_lmvecs$ = 12						; size = 4
_Mod_LightMatrixFromTexMatrix PROC

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 976  : 	float	lmscale = LM_SAMPLE_SIZE;

	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR _lmscale$[ebp], xmm0

; 977  : 	int	i, j;
; 978  : 
; 979  : 	// this is can't be possible but who knews
; 980  : 	if( FBitSet( tx->flags, TEX_EXTRA_LIGHTMAP ))

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 8
	je	SHORT $LN8@Mod_LightM

; 981  : 		lmscale = LM_SAMPLE_EXTRASIZE;

	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _lmscale$[ebp], xmm0
$LN8@Mod_LightM:

; 982  : 
; 983  : 	if( tx->faceinfo )

	mov	edx, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN9@Mod_LightM

; 984  : 		lmscale = tx->faceinfo->texture_step;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movzx	edx, WORD PTR [ecx+16]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _lmscale$[ebp], xmm0
$LN9@Mod_LightM:

; 985  : 
; 986  : 	// copy texmatrix into lightmap matrix fisrt
; 987  : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LightM
$LN2@Mod_LightM:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LightM:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@Mod_LightM

; 988  : 	{
; 989  : 		for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LightM
$LN5@Mod_LightM:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@Mod_LightM:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_LightM

; 990  : 		{
; 991  : 			lmvecs[i][j] = tx->vecs[i][j];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 992  : 		}

	jmp	SHORT $LN5@Mod_LightM
$LN6@Mod_LightM:

; 993  : 	}

	jmp	SHORT $LN2@Mod_LightM
$LN3@Mod_LightM:

; 994  : 
; 995  : 	if( !FBitSet( tx->flags, TEX_WORLD_LUXELS ))

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 2
	jne	SHORT $LN10@Mod_LightM

; 996  : 		return; // just use texmatrix

	jmp	$LN1@Mod_LightM
$LN10@Mod_LightM:

; 997  : 
; 998  : 	VectorNormalize( lmvecs[0] );

	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@Mod_LightM
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN11@Mod_LightM:
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+eax], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+eax], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 999  : 	VectorNormalize( lmvecs[1] );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@Mod_LightM
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN12@Mod_LightM:
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1000 : 
; 1001 : 	if( FBitSet( tx->flags, TEX_AXIAL_LUXELS ))

	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 4
	je	SHORT $LN13@Mod_LightM

; 1002 : 	{
; 1003 : 		Mod_MakeNormalAxial( lmvecs[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	push	ecx
	call	_Mod_MakeNormalAxial
	add	esp, 4

; 1004 : 		Mod_MakeNormalAxial( lmvecs[1] );

	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	push	edx
	call	_Mod_MakeNormalAxial
	add	esp, 4
$LN13@Mod_LightM:

; 1005 : 	}
; 1006 : 
; 1007 : 	// put the lighting origin at center the of poly
; 1008 : 	VectorScale( lmvecs[0], (1.0 / lmscale), lmvecs[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv300[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	movss	xmm0, DWORD PTR tv300[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 1009 : 	VectorScale( lmvecs[1], -(1.0 / lmscale), lmvecs[1] );

	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR [edx+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	xorps	xmm2, QWORD PTR __xmm@80000000000000008000000000000000
	mulsd	xmm0, xmm2
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 0
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	xorps	xmm2, QWORD PTR __xmm@80000000000000008000000000000000
	mulsd	xmm0, xmm2
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	xorps	xmm2, QWORD PTR __xmm@80000000000000008000000000000000
	mulsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv348[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	movss	xmm0, DWORD PTR tv348[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1010 : 
; 1011 : 	lmvecs[0][3] = lmscale * 0.5;

	cvtss2sd xmm0, DWORD PTR _lmscale$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0

; 1012 : 	lmvecs[1][3] = -lmscale * 0.5;

	movss	xmm0, DWORD PTR _lmscale$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
$LN1@Mod_LightM:

; 1013 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LightMatrixFromTexMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv87 = -16						; size = 8
_i$ = -8						; size = 4
_type$ = -4						; size = 4
_normal$ = 8						; size = 4
_Mod_MakeNormalAxial PROC

; 949  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 950  : 	int	i, type;
; 951  : 
; 952  : 	for( type = 0; type < 3; type++ )

	mov	DWORD PTR _type$[ebp], 0
	jmp	SHORT $LN4@Mod_MakeNo
$LN2@Mod_MakeNo:
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, 1
	mov	DWORD PTR _type$[ebp], eax
$LN4@Mod_MakeNo:
	cmp	DWORD PTR _type$[ebp], 3
	jge	SHORT $LN3@Mod_MakeNo

; 953  : 	{
; 954  : 		if( fabs( normal[type] ) > 0.9999f )

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _normal$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv87[ebp]
	movsd	xmm0, QWORD PTR tv87[ebp]
	comisd	xmm0, QWORD PTR __real@3fefff2e40000000
	jbe	SHORT $LN8@Mod_MakeNo

; 955  : 			break;

	jmp	SHORT $LN3@Mod_MakeNo
$LN8@Mod_MakeNo:

; 956  : 	}

	jmp	SHORT $LN2@Mod_MakeNo
$LN3@Mod_MakeNo:

; 957  : 
; 958  : 	// make positive and pure axial
; 959  : 	for( i = 0; i < 3 && type != 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_MakeNo
$LN5@Mod_MakeNo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_MakeNo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@Mod_MakeNo
	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN6@Mod_MakeNo

; 960  : 	{
; 961  : 		if( i == type )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _type$[ebp]
	jne	SHORT $LN9@Mod_MakeNo

; 962  : 			normal[i] = 1.0f;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx*4], xmm0
	jmp	SHORT $LN10@Mod_MakeNo
$LN9@Mod_MakeNo:

; 963  : 		else normal[i] = 0.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _normal$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx*4], xmm0
$LN10@Mod_MakeNo:

; 964  : 	}

	jmp	SHORT $LN5@Mod_MakeNo
$LN6@Mod_MakeNo:

; 965  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_MakeNormalAxial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_edge$ = -8						; size = 4
_lindex$ = -4						; size = 4
_mod$ = 8						; size = 4
_surfedge$ = 12						; size = 4
_Mod_GetVertexByNumber PROC

; 923  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 924  : 	int	lindex;
; 925  : 	medge_t	*edge;
; 926  : 
; 927  : 	lindex = mod->surfedges[surfedge];

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR _surfedge$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lindex$[ebp], eax

; 928  : 
; 929  : 	if( lindex > 0 )

	cmp	DWORD PTR _lindex$[ebp], 0
	jle	SHORT $LN2@Mod_GetVer

; 930  : 	{
; 931  : 		edge = &mod->edges[lindex];

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _lindex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _edge$[ebp], ecx

; 932  : 		return &mod->vertexes[edge->v[0]];

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _edge$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _mod$[ebp]
	add	eax, DWORD PTR [ecx+148]
	jmp	SHORT $LN1@Mod_GetVer

; 933  : 	}

	jmp	SHORT $LN1@Mod_GetVer
$LN2@Mod_GetVer:

; 934  : 	else
; 935  : 	{
; 936  : 		edge = &mod->edges[-lindex];

	mov	edx, DWORD PTR _lindex$[ebp]
	neg	edx
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _edge$[ebp], edx

; 937  : 		return &mod->vertexes[edge->v[1]];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _edge$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _mod$[ebp]
	add	eax, DWORD PTR [ecx+148]
$LN1@Mod_GetVer:

; 938  : 	}
; 939  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetVertexByNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Mod_GetFaceContents PROC

; 896  : {

	push	ebp
	mov	ebp, esp

; 897  : 	if( !Q_strnicmp( name, "SKY", 3 ))

	push	3
	push	OFFSET $SG145663
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Mod_GetFac

; 898  : 		return CONTENTS_SKY;

	mov	eax, -6					; fffffffaH
	jmp	$LN1@Mod_GetFac
$LN2@Mod_GetFac:

; 899  : 
; 900  : 	if( name[0] == '!' || name[0] == '*' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN4@Mod_GetFac
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN3@Mod_GetFac
$LN4@Mod_GetFac:

; 901  : 	{
; 902  : 		if( !Q_strnicmp( name + 1, "lava", 4 ))

	push	4
	push	OFFSET $SG145668
	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 1
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@Mod_GetFac

; 903  : 			return CONTENTS_LAVA;

	mov	eax, -5					; fffffffbH
	jmp	SHORT $LN1@Mod_GetFac
	jmp	SHORT $LN6@Mod_GetFac
$LN5@Mod_GetFac:

; 904  : 		else if( !Q_strnicmp( name + 1, "slime", 5 ))

	push	5
	push	OFFSET $SG145670
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, 1
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@Mod_GetFac

; 905  : 			return CONTENTS_SLIME;

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN1@Mod_GetFac
$LN6@Mod_GetFac:

; 906  : 		return CONTENTS_WATER; // otherwise it's water

	mov	eax, -3					; fffffffdH
	jmp	SHORT $LN1@Mod_GetFac
$LN3@Mod_GetFac:

; 907  : 	}
; 908  : 
; 909  : 	if( !Q_strnicmp( name, "water", 5 ))

	push	5
	push	OFFSET $SG145672
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Mod_GetFac

; 910  : 		return CONTENTS_WATER;

	mov	eax, -3					; fffffffdH
	jmp	SHORT $LN1@Mod_GetFac
$LN8@Mod_GetFac:

; 911  : 
; 912  : 	return CONTENTS_SOLID;

	mov	eax, -2					; fffffffeH
$LN1@Mod_GetFac:

; 913  : }

	pop	ebp
	ret	0
_Mod_GetFaceContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_pvs$ = -20						; size = 4
tv138 = -16						; size = 4
_i$ = -12						; size = 4
_leaf$ = -8						; size = 4
_j$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_CheckWaterAlphaSupport PROC

; 836  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 837  : 	mleaf_t		*leaf;
; 838  : 	int		i, j;
; 839  : 	const byte	*pvs;
; 840  : 
; 841  : 	if( bmod->visdatasize <= 0 )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+100], 0
	ja	SHORT $LN8@Mod_CheckW

; 842  : 		return true;

	mov	eax, 1
	jmp	$LN1@Mod_CheckW
$LN8@Mod_CheckW:

; 843  : 
; 844  : 	// check all liquid leafs to see if they can see into empty leafs, if any
; 845  : 	// can we can assume this map supports r_wateralpha
; 846  : 	for( i = 0, leaf = loadmodel->leafs; i < loadmodel->numleafs; i++, leaf++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR _leaf$[ebp], edx
	jmp	SHORT $LN4@Mod_CheckW
$LN2@Mod_CheckW:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _leaf$[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR _leaf$[ebp], ecx
$LN4@Mod_CheckW:
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+136]
	jge	$LN3@Mod_CheckW

; 847  : 	{
; 848  : 		if(( leaf->contents == CONTENTS_WATER || leaf->contents == CONTENTS_SLIME ) && leaf->cluster >= 0 )

	mov	ecx, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [ecx], -3			; fffffffdH
	je	SHORT $LN10@Mod_CheckW
	mov	edx, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [edx], -4			; fffffffcH
	jne	$LN9@Mod_CheckW
$LN10@Mod_CheckW:
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	$LN9@Mod_CheckW

; 849  : 		{
; 850  : 			pvs = Mod_DecompressPVS( leaf->compressed_vis, world.visbytes );

	mov	ecx, DWORD PTR _world+2592
	push	ecx
	mov	edx, DWORD PTR _leaf$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_Mod_DecompressPVS
	add	esp, 8
	mov	DWORD PTR _pvs$[ebp], eax

; 851  : 
; 852  : 			for( j = 0; j < loadmodel->numleafs; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_CheckW
$LN5@Mod_CheckW:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@Mod_CheckW:
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+136]
	jge	$LN9@Mod_CheckW

; 853  : 			{
; 854  : 				if( CHECKVISBIT( pvs, loadmodel->leafs[j].cluster ) && loadmodel->leafs[j].contents == CONTENTS_EMPTY )

	imul	ecx, DWORD PTR _j$[ebp], 60
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+140]
	cmp	DWORD PTR [eax+ecx+52], 0
	jl	SHORT $LN13@Mod_CheckW
	imul	ecx, DWORD PTR _j$[ebp], 60
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+ecx+52]
	sar	ecx, 3
	mov	edx, DWORD PTR _pvs$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	ecx, DWORD PTR _j$[ebp], 60
	mov	edx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [edx+ecx+52]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN14@Mod_CheckW
$LN13@Mod_CheckW:
	mov	DWORD PTR tv138[ebp], 0
$LN14@Mod_CheckW:
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN11@Mod_CheckW
	imul	ecx, DWORD PTR _j$[ebp], 60
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+140]
	cmp	DWORD PTR [eax+ecx], -1
	jne	SHORT $LN11@Mod_CheckW

; 855  : 					return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_CheckW
$LN11@Mod_CheckW:

; 856  : 			}

	jmp	$LN5@Mod_CheckW
$LN9@Mod_CheckW:

; 857  : 		}
; 858  : 	}

	jmp	$LN2@Mod_CheckW
$LN3@Mod_CheckW:

; 859  : 
; 860  : 	return false;

	xor	eax, eax
$LN1@Mod_CheckW:

; 861  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CheckWaterAlphaSupport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_model_found$ = -2320					; size = 4
_origin_found$ = -2316					; size = 4
_pfile$ = -2312						; size = 4
_token$ = -2308						; size = 2048
_keyname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_entities$ = 8						; size = 4
_modelname$ = 12					; size = 4
_origin$ = 16						; size = 4
_Mod_FindModelOrigin PROC

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2320				; 00000910H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 775  : 	char	*pfile;
; 776  : 	string	keyname;
; 777  : 	char	token[2048];
; 778  : 	qboolean	model_found;
; 779  : 	qboolean	origin_found;
; 780  : 
; 781  : 	if( !entities || !modelname || !*modelname )

	cmp	DWORD PTR _entities$[ebp], 0
	je	SHORT $LN7@Mod_FindMo
	cmp	DWORD PTR _modelname$[ebp], 0
	je	SHORT $LN7@Mod_FindMo
	mov	eax, DWORD PTR _modelname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@Mod_FindMo
$LN7@Mod_FindMo:

; 782  : 		return;

	jmp	$LN3@Mod_FindMo
$LN6@Mod_FindMo:

; 783  : 
; 784  : 	if( !origin || !VectorIsNull( origin ))

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN10@Mod_FindMo
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@Mod_FindMo
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@Mod_FindMo
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@Mod_FindMo
$LN10@Mod_FindMo:

; 785  : 		return;

	jmp	$LN3@Mod_FindMo
$LN8@Mod_FindMo:

; 786  : 
; 787  : 	pfile = (char *)entities;

	mov	eax, DWORD PTR _entities$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN2@Mod_FindMo:

; 788  : 
; 789  : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@Mod_FindMo

; 790  : 	{
; 791  : 		if( token[0] != '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN11@Mod_FindMo

; 792  : 			Host_Error( "Mod_FindModelOrigin: found %s when expecting {\n", token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET $SG145617
	call	_Host_Error
	add	esp, 8
$LN11@Mod_FindMo:

; 793  : 
; 794  : 		model_found = origin_found = false;

	mov	DWORD PTR _origin_found$[ebp], 0
	mov	ecx, DWORD PTR _origin_found$[ebp]
	mov	DWORD PTR _model_found$[ebp], ecx

; 795  : 		VectorClear( origin );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _origin$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _origin$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
$LN4@Mod_FindMo:

; 796  : 
; 797  : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN5@Mod_FindMo

; 798  : 		{
; 799  : 			// parse key
; 800  : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN12@Mod_FindMo

; 801  : 				Host_Error( "Mod_FindModelOrigin: EOF without closing brace\n" );

	push	OFFSET $SG145619
	call	_Host_Error
	add	esp, 4
$LN12@Mod_FindMo:

; 802  : 			if( token[0] == '}' ) break; // end of desc

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN13@Mod_FindMo
	jmp	$LN5@Mod_FindMo
$LN13@Mod_FindMo:

; 803  : 
; 804  : 			Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 805  : 
; 806  : 			// parse value	
; 807  : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL ) 

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN14@Mod_FindMo

; 808  : 				Host_Error( "Mod_FindModelOrigin: EOF without closing brace\n" );

	push	OFFSET $SG145622
	call	_Host_Error
	add	esp, 4
$LN14@Mod_FindMo:

; 809  : 
; 810  : 			if( token[0] == '}' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _token$[ebp+edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN15@Mod_FindMo

; 811  : 				Host_Error( "Mod_FindModelOrigin: closing brace without data\n" );

	push	OFFSET $SG145624
	call	_Host_Error
	add	esp, 4
$LN15@Mod_FindMo:

; 812  : 
; 813  : 			if( !Q_stricmp( keyname, "model" ) && !Q_stricmp( modelname, token ))

	push	99999					; 0001869fH
	push	OFFSET $SG145626
	lea	ecx, DWORD PTR _keyname$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Mod_FindMo
	push	99999					; 0001869fH
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Mod_FindMo

; 814  : 				model_found = true;

	mov	DWORD PTR _model_found$[ebp], 1
$LN16@Mod_FindMo:

; 815  : 
; 816  : 			if( !Q_stricmp( keyname, "origin" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145628
	lea	ecx, DWORD PTR _keyname$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@Mod_FindMo

; 817  : 			{
; 818  : 				Q_atov( origin, token, 3 );

	push	3
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	call	_Q_atov
	add	esp, 12					; 0000000cH

; 819  : 				origin_found = true;

	mov	DWORD PTR _origin_found$[ebp], 1
$LN17@Mod_FindMo:

; 820  : 			}
; 821  : 		}

	jmp	$LN4@Mod_FindMo
$LN5@Mod_FindMo:

; 822  : 
; 823  : 		if( model_found ) break;

	cmp	DWORD PTR _model_found$[ebp], 0
	je	SHORT $LN18@Mod_FindMo
	jmp	SHORT $LN3@Mod_FindMo
$LN18@Mod_FindMo:

; 824  : 	}	

	jmp	$LN2@Mod_FindMo
$LN3@Mod_FindMo:

; 825  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FindModelOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_ll$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_list$ = 16						; size = 4
_listsize$ = 20						; size = 4
_topnode$ = 24						; size = 4
_Mod_BoxLeafnums PROC

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 674  : 	leaflist_t	ll;
; 675  : 
; 676  : 	if( !worldmodel ) return 0;

	cmp	DWORD PTR _worldmodel, 0
	jne	SHORT $LN2@Mod_BoxLea
	xor	eax, eax
	jmp	$LN1@Mod_BoxLea
$LN2@Mod_BoxLea:

; 677  : 
; 678  : 	VectorCopy( mins, ll.mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _ll$[ebp+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _ll$[ebp+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _ll$[ebp+ecx+16], eax

; 679  : 	VectorCopy( maxs, ll.maxs );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _ll$[ebp+ecx+28], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _ll$[ebp+ecx+28], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _ll$[ebp+edx+28], ecx

; 680  : 
; 681  : 	ll.maxcount = listsize;

	mov	edx, DWORD PTR _listsize$[ebp]
	mov	DWORD PTR _ll$[ebp+4], edx

; 682  : 	ll.overflowed = false;

	mov	DWORD PTR _ll$[ebp+8], 0

; 683  : 	ll.topnode = -1;

	mov	DWORD PTR _ll$[ebp+40], -1

; 684  : 	ll.list = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _ll$[ebp+12], eax

; 685  : 	ll.count = 0;

	mov	DWORD PTR _ll$[ebp], 0

; 686  : 
; 687  : 	Mod_BoxLeafnums_r( &ll, worldmodel->nodes );

	mov	ecx, DWORD PTR _worldmodel
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	lea	eax, DWORD PTR _ll$[ebp]
	push	eax
	call	_Mod_BoxLeafnums_r
	add	esp, 8

; 688  : 
; 689  : 	if( topnode ) *topnode = ll.topnode;

	cmp	DWORD PTR _topnode$[ebp], 0
	je	SHORT $LN3@Mod_BoxLea
	mov	ecx, DWORD PTR _topnode$[ebp]
	mov	edx, DWORD PTR _ll$[ebp+40]
	mov	DWORD PTR [ecx], edx
$LN3@Mod_BoxLea:

; 690  : 	return ll.count;

	mov	eax, DWORD PTR _ll$[ebp]
$LN1@Mod_BoxLea:

; 691  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_BoxLeafnums ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_leaf$1 = -20						; size = 4
_sides$ = -16						; size = 4
tv144 = -12						; size = 4
tv136 = -8						; size = 4
tv135 = -4						; size = 4
_ll$ = 8						; size = 4
_node$ = 12						; size = 4
_Mod_BoxLeafnums_r PROC

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
$LN2@Mod_BoxLea:

; 624  : 	int	sides;
; 625  : 
; 626  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Mod_BoxLea

; 627  : 	{
; 628  : 		if( node->contents == CONTENTS_SOLID )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], -2			; fffffffeH
	jne	SHORT $LN4@Mod_BoxLea

; 629  : 			return;

	jmp	$LN3@Mod_BoxLea
$LN4@Mod_BoxLea:

; 630  : 
; 631  : 		if( node->contents < 0 )

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], 0
	jge	SHORT $LN5@Mod_BoxLea

; 632  : 		{
; 633  : 			mleaf_t	*leaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$1[ebp], eax

; 634  : 
; 635  : 			// it's a leaf!
; 636  : 			if( ll->count >= ll->maxcount )

	mov	ecx, DWORD PTR _ll$[ebp]
	mov	edx, DWORD PTR _ll$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+4]
	jl	SHORT $LN6@Mod_BoxLea

; 637  : 			{
; 638  : 				ll->overflowed = true;

	mov	ecx, DWORD PTR _ll$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 639  : 				return;

	jmp	$LN3@Mod_BoxLea
$LN6@Mod_BoxLea:

; 640  : 			}
; 641  : 
; 642  : 			ll->list[ll->count++] = leaf->cluster;

	mov	edx, DWORD PTR _ll$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ll$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _leaf$1[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _ll$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ll$[ebp]
	mov	DWORD PTR [ecx], eax

; 643  : 			return;

	jmp	$LN3@Mod_BoxLea
$LN5@Mod_BoxLea:

; 644  : 		}
; 645  : 	
; 646  : 		sides = BOX_ON_PLANE_SIDE( ll->mins, ll->maxs, node->plane );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN17@Mod_BoxLea
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	ecx, BYTE PTR [edx+16]
	mov	edx, DWORD PTR _ll$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+16]
	comiss	xmm0, DWORD PTR [eax+12]
	jb	SHORT $LN15@Mod_BoxLea
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN16@Mod_BoxLea
$LN15@Mod_BoxLea:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	edx, BYTE PTR [eax+16]
	mov	eax, DWORD PTR _ll$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [eax+edx*4+28]
	jb	SHORT $LN13@Mod_BoxLea
	mov	DWORD PTR tv135[ebp], 2
	jmp	SHORT $LN14@Mod_BoxLea
$LN13@Mod_BoxLea:
	mov	DWORD PTR tv135[ebp], 3
$LN14@Mod_BoxLea:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], ecx
$LN16@Mod_BoxLea:
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN18@Mod_BoxLea
$LN17@Mod_BoxLea:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _ll$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _ll$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_BoxOnPlaneSide
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv144[ebp], eax
$LN18@Mod_BoxLea:
	mov	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _sides$[ebp], ecx

; 647  : 
; 648  : 		if( sides == 1 )

	cmp	DWORD PTR _sides$[ebp], 1
	jne	SHORT $LN7@Mod_BoxLea

; 649  : 		{
; 650  : 			node = node->children[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx

; 651  : 		}

	jmp	SHORT $LN10@Mod_BoxLea
$LN7@Mod_BoxLea:

; 652  : 		else if( sides == 2 )

	cmp	DWORD PTR _sides$[ebp], 2
	jne	SHORT $LN9@Mod_BoxLea

; 653  : 		{
; 654  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx

; 655  : 		}

	jmp	SHORT $LN10@Mod_BoxLea
$LN9@Mod_BoxLea:

; 656  : 		else
; 657  : 		{
; 658  : 			// go down both
; 659  : 			if( ll->topnode == -1 )

	mov	eax, DWORD PTR _ll$[ebp]
	cmp	DWORD PTR [eax+40], -1
	jne	SHORT $LN11@Mod_BoxLea

; 660  : 				ll->topnode = node - worldmodel->nodes;

	mov	ecx, DWORD PTR _worldmodel
	mov	eax, DWORD PTR _node$[ebp]
	sub	eax, DWORD PTR [ecx+164]
	cdq
	mov	ecx, 52					; 00000034H
	idiv	ecx
	mov	edx, DWORD PTR _ll$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN11@Mod_BoxLea:

; 661  : 			Mod_BoxLeafnums_r( ll, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _ll$[ebp]
	push	ecx
	call	_Mod_BoxLeafnums_r
	add	esp, 8

; 662  : 			node = node->children[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	mov	DWORD PTR _node$[ebp], ecx
$LN10@Mod_BoxLea:

; 663  : 		}
; 664  : 	}

	jmp	$LN2@Mod_BoxLea
$LN3@Mod_BoxLea:

; 665  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_BoxLeafnums_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_vis$1 = -16						; size = 4
_d$2 = -12						; size = 4
tv131 = -8						; size = 4
_i$ = -4						; size = 4
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_visbuffer$ = 16					; size = 4
_visbytes$ = 20						; size = 4
_node$ = 24						; size = 4
_Mod_FatPVS_RecursiveBSPNode PROC

; 554  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
$LN2@Mod_FatPVS:

; 555  : 	int	i;
; 556  : 
; 557  : 	while( node->contents >= 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	$LN3@Mod_FatPVS

; 558  : 	{
; 559  : 		float d = PlaneDiff( org, node->plane );

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	eax, BYTE PTR [edx+16]
	cmp	eax, 3
	jge	SHORT $LN13@Mod_FatPVS
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN14@Mod_FatPVS
$LN13@Mod_FatPVS:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv131[ebp], xmm0
$LN14@Mod_FatPVS:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR tv131[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d$2[ebp], xmm0

; 560  : 
; 561  : 		if( d > radius )

	movss	xmm0, DWORD PTR _d$2[ebp]
	comiss	xmm0, DWORD PTR _radius$[ebp]
	jbe	SHORT $LN7@Mod_FatPVS

; 562  : 			node = node->children[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx
	jmp	SHORT $LN10@Mod_FatPVS
$LN7@Mod_FatPVS:

; 563  : 		else if( d < -radius )

	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _d$2[ebp]
	jbe	SHORT $LN9@Mod_FatPVS

; 564  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx
	jmp	SHORT $LN10@Mod_FatPVS
$LN9@Mod_FatPVS:

; 565  : 		else
; 566  : 		{
; 567  : 			// go down both sides
; 568  : 			Mod_FatPVS_RecursiveBSPNode( org, radius, visbuffer, visbytes, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _visbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _visbuffer$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_Mod_FatPVS_RecursiveBSPNode
	add	esp, 20					; 00000014H

; 569  : 			node = node->children[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax
$LN10@Mod_FatPVS:

; 570  : 		}
; 571  : 	}

	jmp	$LN2@Mod_FatPVS
$LN3@Mod_FatPVS:

; 572  : 
; 573  : 	// if this leaf is in a cluster, accumulate the vis bits
; 574  : 	if(((mleaf_t *)node)->cluster >= 0 )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jl	SHORT $LN5@Mod_FatPVS

; 575  : 	{
; 576  : 		byte	*vis = Mod_DecompressPVS( ((mleaf_t *)node)->compressed_vis, world.visbytes );

	mov	edx, DWORD PTR _world+2592
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_Mod_DecompressPVS
	add	esp, 8
	mov	DWORD PTR _vis$1[ebp], eax

; 577  : 
; 578  : 		for( i = 0; i < visbytes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_FatPVS
$LN4@Mod_FatPVS:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@Mod_FatPVS:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _visbytes$[ebp]
	jge	SHORT $LN5@Mod_FatPVS

; 579  : 			visbuffer[i] |= vis[i];

	mov	ecx, DWORD PTR _vis$1[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _visbuffer$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _visbuffer$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN4@Mod_FatPVS
$LN5@Mod_FatPVS:

; 580  : 	}
; 581  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FatPVS_RecursiveBSPNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_c$ = -8						; size = 4
_out$ = -4						; size = 4
_in$ = 8						; size = 4
_visbytes$ = 12						; size = 4
_Mod_DecompressPVS PROC

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 457  : 	byte	*out;
; 458  : 	int	c;
; 459  : 
; 460  : 	out = g_visdata;

	mov	DWORD PTR _out$[ebp], OFFSET _g_visdata

; 461  : 
; 462  : 	if( !in )

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN6@Mod_Decomp
$LN2@Mod_Decomp:

; 463  : 	{	
; 464  : 		// no vis info, so make all visible
; 465  : 		while( visbytes )

	cmp	DWORD PTR _visbytes$[ebp], 0
	je	SHORT $LN3@Mod_Decomp

; 466  : 		{
; 467  : 			*out++ = 0xff;

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 468  : 			visbytes--;

	mov	edx, DWORD PTR _visbytes$[ebp]
	sub	edx, 1
	mov	DWORD PTR _visbytes$[ebp], edx

; 469  : 		}

	jmp	SHORT $LN2@Mod_Decomp
$LN3@Mod_Decomp:

; 470  : 		return g_visdata;

	mov	eax, OFFSET _g_visdata
	jmp	SHORT $LN1@Mod_Decomp
$LN6@Mod_Decomp:

; 471  : 	}
; 472  : 
; 473  : 	do
; 474  : 	{
; 475  : 		if( *in )

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN10@Mod_Decomp

; 476  : 		{
; 477  : 			*out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 478  : 			continue;

	jmp	SHORT $LN4@Mod_Decomp
$LN10@Mod_Decomp:

; 479  : 		}
; 480  : 
; 481  : 		c = in[1];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _c$[ebp], eax

; 482  : 		in += 2;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx
$LN7@Mod_Decomp:

; 483  : 
; 484  : 		while( c )

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN4@Mod_Decomp

; 485  : 		{
; 486  : 			*out++ = 0;

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 487  : 			c--;

	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx

; 488  : 		}

	jmp	SHORT $LN7@Mod_Decomp
$LN4@Mod_Decomp:

; 489  : 	} while( out - g_visdata < visbytes );

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, OFFSET _g_visdata
	cmp	edx, DWORD PTR _visbytes$[ebp]
	jl	SHORT $LN6@Mod_Decomp

; 490  : 
; 491  : 	return g_visdata;

	mov	eax, OFFSET _g_visdata
$LN1@Mod_Decomp:

; 492  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_DecompressPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv70 = -8						; size = 4
_percentage$ = -4					; size = 4
_szItem$ = 8						; size = 4
_itemstorage$ = 12					; size = 4
_maxstorage$ = 16					; size = 4
_Mod_GlobUsage PROC

; 382  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 383  : 	float	percentage = maxstorage ? (itemstorage * 100.0f / maxstorage) : 0.0f;

	cmp	DWORD PTR _maxstorage$[ebp], 0
	je	SHORT $LN9@Mod_GlobUs
	cvtsi2ss xmm0, DWORD PTR _itemstorage$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _maxstorage$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN10@Mod_GlobUs
$LN9@Mod_GlobUs:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
$LN10@Mod_GlobUs:
	movss	xmm0, DWORD PTR tv70[ebp]
	movss	DWORD PTR _percentage$[ebp], xmm0

; 384  : 
; 385  : 	Con_Printf( "%-15s  %-12s  %8i/%-8i  (%4.1f%%) ", szItem, "[variable]", itemstorage, maxstorage, percentage );

	cvtss2sd xmm0, DWORD PTR _percentage$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _maxstorage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _itemstorage$[ebp]
	push	ecx
	push	OFFSET $SG145359
	mov	edx, DWORD PTR _szItem$[ebp]
	push	edx
	push	OFFSET $SG145360
	call	_Con_Printf
	add	esp, 28					; 0000001cH

; 386  : 
; 387  : 	if( percentage > 99.99f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42c7fae1
	jbe	SHORT $LN2@Mod_GlobUs

; 388  : 		Con_Printf( "^1SIZE OVERFLOW!!!^7\n" );

	push	OFFSET $SG145363
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_GlobUs
$LN2@Mod_GlobUs:

; 389  : 	else if( percentage > 95.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42be0000
	jbe	SHORT $LN4@Mod_GlobUs

; 390  : 		Con_Printf( "^3SIZE DANGER!^7\n" );

	push	OFFSET $SG145366
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_GlobUs
$LN4@Mod_GlobUs:

; 391  : 	else if( percentage > 80.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN6@Mod_GlobUs

; 392  : 		Con_Printf( "^2VERY FULL!^7\n" );

	push	OFFSET $SG145369
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_GlobUs
$LN6@Mod_GlobUs:

; 393  : 	else Con_Printf( "\n" );

	push	OFFSET $SG145370
	call	_Con_Printf
	add	esp, 4
$LN7@Mod_GlobUs:

; 394  : 
; 395  : 	return itemstorage;

	mov	eax, DWORD PTR _itemstorage$[ebp]

; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GlobUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv70 = -8						; size = 4
_percentage$ = -4					; size = 4
_szItem$ = 8						; size = 4
_items$ = 12						; size = 4
_maxitems$ = 16						; size = 4
_itemsize$ = 20						; size = 4
_Mod_ArrayUsage PROC

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 361  : 	float	percentage = maxitems ? (items * 100.0f / maxitems) : 0.0f;

	cmp	DWORD PTR _maxitems$[ebp], 0
	je	SHORT $LN9@Mod_ArrayU
	cvtsi2ss xmm0, DWORD PTR _items$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _maxitems$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN10@Mod_ArrayU
$LN9@Mod_ArrayU:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
$LN10@Mod_ArrayU:
	movss	xmm0, DWORD PTR tv70[ebp]
	movss	DWORD PTR _percentage$[ebp], xmm0

; 362  : 
; 363  : 	Con_Printf( "%-12s  %7i/%-7i  %8i/%-8i  (%4.1f%%) ", szItem, items, maxitems, items * itemsize, maxitems * itemsize, percentage );

	cvtss2sd xmm0, DWORD PTR _percentage$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _maxitems$[ebp]
	imul	eax, DWORD PTR _itemsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _items$[ebp]
	imul	ecx, DWORD PTR _itemsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxitems$[ebp]
	push	edx
	mov	eax, DWORD PTR _items$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szItem$[ebp]
	push	ecx
	push	OFFSET $SG145339
	call	_Con_Printf
	add	esp, 32					; 00000020H

; 364  : 
; 365  : 	if( percentage > 99.99f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42c7fae1
	jbe	SHORT $LN2@Mod_ArrayU

; 366  : 		Con_Printf( "^1SIZE OVERFLOW!!!^7\n" );

	push	OFFSET $SG145342
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_ArrayU
$LN2@Mod_ArrayU:

; 367  : 	else if( percentage > 95.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42be0000
	jbe	SHORT $LN4@Mod_ArrayU

; 368  : 		Con_Printf( "^3SIZE DANGER!^7\n" );

	push	OFFSET $SG145345
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_ArrayU
$LN4@Mod_ArrayU:

; 369  : 	else if( percentage > 80.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN6@Mod_ArrayU

; 370  : 		Con_Printf( "^2VERY FULL!^7\n" );

	push	OFFSET $SG145348
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_ArrayU
$LN6@Mod_ArrayU:

; 371  : 	else Con_Printf( "\n" );

	push	OFFSET $SG145349
	call	_Con_Printf
	add	esp, 4
$LN7@Mod_ArrayU:

; 372  : 
; 373  : 	return items * itemsize;

	mov	eax, DWORD PTR _items$[ebp]
	imul	eax, DWORD PTR _itemsize$[ebp]

; 374  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ArrayUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_header$1 = -92						; size = 4
_version$ = -88						; size = 4
_numelems$ = -84					; size = 4
_header$2 = -80						; size = 4
_real_entrysize$ = -76					; size = 4
_l$ = -72						; size = 4
_msg2$ = -68						; size = 32
_msg1$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_info$ = 12						; size = 4
_stat$ = 16						; size = 4
_flags$ = 20						; size = 4
_Mod_LoadLump PROC

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int	version = ((dheader_t *)in)->version;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _version$[ebp], ecx

; 226  : 	size_t	numelems, real_entrysize;
; 227  : 	char	msg1[32], msg2[32];
; 228  : 	dlump_t	*l = NULL;

	mov	DWORD PTR _l$[ebp], 0

; 229  : 
; 230  : 	if( FBitSet( info->flags, USE_EXTRAHEADER ))

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 2
	je	SHORT $LN2@Mod_LoadLu

; 231  : 	{
; 232  : 		dextrahdr_t *header = (dextrahdr_t *)((byte *)in + sizeof( dheader_t ));

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 124				; 0000007cH
	mov	DWORD PTR _header$2[ebp], ecx

; 233  : 		if( header->id != IDEXTRAHEADER || header->version != EXTRA_VERSION )

	mov	edx, DWORD PTR _header$2[ebp]
	cmp	DWORD PTR [edx], 1213415768		; 48534158H
	jne	SHORT $LN5@Mod_LoadLu
	mov	eax, DWORD PTR _header$2[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN4@Mod_LoadLu
$LN5@Mod_LoadLu:

; 234  : 			return;

	jmp	$LN1@Mod_LoadLu
$LN4@Mod_LoadLu:

; 235  : 		l = &header->lumps[info->lumpnumber];

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _header$2[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+8]
	mov	DWORD PTR _l$[ebp], ecx

; 236  : 	}

	jmp	SHORT $LN3@Mod_LoadLu
$LN2@Mod_LoadLu:

; 237  : 	else
; 238  : 	{
; 239  : 		dheader_t	*header = (dheader_t *)in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _header$1[ebp], edx

; 240  : 		l = &header->lumps[info->lumpnumber];

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _header$1[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR _l$[ebp], eax
$LN3@Mod_LoadLu:

; 241  : 	}
; 242  : 
; 243  : 	// lump is unused by engine for some reasons ?
; 244  : 	if( !l || info->entrysize <= 0 || info->maxcount <= 0 )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $LN7@Mod_LoadLu
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN7@Mod_LoadLu
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 0
	ja	SHORT $LN6@Mod_LoadLu
$LN7@Mod_LoadLu:

; 245  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN6@Mod_LoadLu:

; 246  : 
; 247  : 	real_entrysize = info->entrysize; // default

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _real_entrysize$[ebp], ecx

; 248  : 
; 249  : 	// analyze real entrysize
; 250  : 	if( version == QBSP2_VERSION && info->entrysize32 > 0 )

	cmp	DWORD PTR _version$[ebp], 844124994	; 32505342H
	jne	SHORT $LN8@Mod_LoadLu
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN8@Mod_LoadLu

; 251  : 	{
; 252  : 		// always use alternate entrysize for BSP2
; 253  : 		real_entrysize = info->entrysize32;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _real_entrysize$[ebp], ecx

; 254  : 	}

	jmp	SHORT $LN9@Mod_LoadLu
$LN8@Mod_LoadLu:

; 255  : 	else if( info->lumpnumber == LUMP_CLIPNODES && version != Q1BSP_VERSION )

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx], 9
	jne	SHORT $LN9@Mod_LoadLu
	cmp	DWORD PTR _version$[ebp], 29		; 0000001dH
	je	SHORT $LN9@Mod_LoadLu

; 256  : 	{
; 257  : 		// never run this check for BSP29 because Arguire QBSP 'broken' clipnodes!
; 258  : 		if(( l->filelen % info->entrysize ) || ( l->filelen / info->entrysize ) >= MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cdq
	idiv	DWORD PTR [ecx+12]
	test	edx, edx
	jne	SHORT $LN12@Mod_LoadLu
	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cdq
	idiv	DWORD PTR [ecx+12]
	cmp	eax, 32767				; 00007fffH
	jl	SHORT $LN9@Mod_LoadLu
$LN12@Mod_LoadLu:

; 259  : 		{
; 260  : 			real_entrysize = info->entrysize32;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _real_entrysize$[ebp], eax

; 261  : 			SetBits( flags, LUMP_SILENT ); // shut up warning

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 4
	mov	DWORD PTR _flags$[ebp], ecx
$LN9@Mod_LoadLu:

; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : 	// bmodels not required the visibility
; 266  : 	if( !FBitSet( flags, LUMP_TESTONLY ) && !world.loading && info->lumpnumber == LUMP_VISIBILITY )

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	jne	SHORT $LN13@Mod_LoadLu
	cmp	DWORD PTR _world, 0
	jne	SHORT $LN13@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN13@Mod_LoadLu

; 267  : 		SetBits( flags, LUMP_SILENT ); // shut up warning

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 4
	mov	DWORD PTR _flags$[ebp], ecx
$LN13@Mod_LoadLu:

; 268  : 
; 269  : 	// fill the stats for world
; 270  : 	if( FBitSet( flags, LUMP_SAVESTATS ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	je	SHORT $LN14@Mod_LoadLu

; 271  : 	{
; 272  : 		stat->lumpname = info->loadname;

	mov	eax, DWORD PTR _stat$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 273  : 		stat->entrysize = real_entrysize;

	mov	eax, DWORD PTR _stat$[ebp]
	mov	ecx, DWORD PTR _real_entrysize$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 274  : 		stat->maxcount = info->maxcount;

	mov	edx, DWORD PTR _stat$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 275  : 		if( real_entrysize != 0 )

	cmp	DWORD PTR _real_entrysize$[ebp], 0
	je	SHORT $LN14@Mod_LoadLu

; 276  : 			stat->count = l->filelen / real_entrysize;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	edx, edx
	div	DWORD PTR _real_entrysize$[ebp]
	mov	ecx, DWORD PTR _stat$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN14@Mod_LoadLu:

; 277  : 	}
; 278  : 
; 279  : 	Q_strncpy( msg1, info->loadname, sizeof( msg1 ));

	push	32					; 00000020H
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	lea	ecx, DWORD PTR _msg1$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 280  : 	Q_strncpy( msg2, info->loadname, sizeof( msg2 ));

	push	32					; 00000020H
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	lea	ecx, DWORD PTR _msg2$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 281  : 	msg2[0] = Q_toupper( msg2[0] ); // first letter in cap

	mov	edx, 1
	imul	eax, edx, 0
	movzx	ecx, BYTE PTR _msg2$[ebp+eax]
	push	ecx
	call	_Q_toupper
	add	esp, 4
	mov	edx, 1
	imul	ecx, edx, 0
	mov	BYTE PTR _msg2$[ebp+ecx], al

; 282  : 
; 283  : 	// lump is not present
; 284  : 	if( l->filelen <= 0 )

	mov	edx, DWORD PTR _l$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jg	SHORT $LN16@Mod_LoadLu

; 285  : 	{
; 286  : 		// don't warn about extra lumps - it's optional
; 287  : 		if( !FBitSet( info->flags, USE_EXTRAHEADER ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 2
	jne	SHORT $LN17@Mod_LoadLu

; 288  : 		{
; 289  : 			// some data array that may be optional
; 290  : 			if( real_entrysize == sizeof( byte ))

	cmp	DWORD PTR _real_entrysize$[ebp], 1
	jne	SHORT $LN18@Mod_LoadLu

; 291  : 			{
; 292  : 				if( !FBitSet( flags, LUMP_SILENT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN20@Mod_LoadLu

; 293  : 				{
; 294  : 					Con_DPrintf( S_WARN "map ^2%s^7 has no %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET $SG145308
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 295  : 					loadstat.numwarnings++;

	mov	ecx, DWORD PTR _loadstat+68
	add	ecx, 1
	mov	DWORD PTR _loadstat+68, ecx
$LN20@Mod_LoadLu:

; 296  : 				}
; 297  : 			}

	jmp	SHORT $LN17@Mod_LoadLu
$LN18@Mod_LoadLu:

; 298  : 			else if( info->mincount > 0 )

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jbe	SHORT $LN17@Mod_LoadLu

; 299  : 			{
; 300  : 				// it has the mincount and the lump is completely missed!
; 301  : 				if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN22@Mod_LoadLu

; 302  : 					Con_DPrintf( S_ERROR "map ^2%s^7 has no %s\n", loadstat.name, msg1 );

	lea	ecx, DWORD PTR _msg1$[ebp]
	push	ecx
	push	OFFSET _loadstat
	push	OFFSET $SG145311
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN22@Mod_LoadLu:

; 303  : 				loadstat.numerrors++;

	mov	edx, DWORD PTR _loadstat+64
	add	edx, 1
	mov	DWORD PTR _loadstat+64, edx
$LN17@Mod_LoadLu:

; 304  : 			}
; 305  : 		}
; 306  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN16@Mod_LoadLu:

; 307  : 	}
; 308  : 
; 309  : 	if( l->filelen % real_entrysize )

	mov	eax, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	edx, edx
	div	DWORD PTR _real_entrysize$[ebp]
	test	edx, edx
	je	SHORT $LN23@Mod_LoadLu

; 310  : 	{
; 311  : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN24@Mod_LoadLu

; 312  : 			Con_DPrintf( S_ERROR "Mod_Load%s: funny lump size\n", msg2 );

	lea	edx, DWORD PTR _msg2$[ebp]
	push	edx
	push	OFFSET $SG145314
	call	_Con_DPrintf
	add	esp, 8
$LN24@Mod_LoadLu:

; 313  : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 314  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN23@Mod_LoadLu:

; 315  : 	}
; 316  : 
; 317  : 	numelems = l->filelen / real_entrysize;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	div	DWORD PTR _real_entrysize$[ebp]
	mov	DWORD PTR _numelems$[ebp], eax

; 318  : 
; 319  : 	if( numelems < info->mincount )

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _numelems$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN25@Mod_LoadLu

; 320  : 	{
; 321  : 		// it has the mincount and it's smaller than this limit
; 322  : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN26@Mod_LoadLu

; 323  : 			Con_DPrintf( S_ERROR "map ^2%s^7 has no %s\n", loadstat.name, msg1 );

	lea	edx, DWORD PTR _msg1$[ebp]
	push	edx
	push	OFFSET _loadstat
	push	OFFSET $SG145317
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN26@Mod_LoadLu:

; 324  : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 325  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN25@Mod_LoadLu:

; 326  : 	}
; 327  : 
; 328  : 	if( numelems > info->maxcount )

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _numelems$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jbe	SHORT $LN27@Mod_LoadLu

; 329  : 	{
; 330  : 		// it has the maxcount and it's overflowed
; 331  : 		if( FBitSet( info->flags, CHECK_OVERFLOW ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	SHORT $LN28@Mod_LoadLu

; 332  : 		{
; 333  : 			if( !FBitSet( flags, LUMP_SILENT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN30@Mod_LoadLu

; 334  : 				Con_DPrintf( S_ERROR "map ^2%s^7 has too many %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET $SG145322
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN30@Mod_LoadLu:

; 335  : 			loadstat.numerrors++;

	mov	ecx, DWORD PTR _loadstat+64
	add	ecx, 1
	mov	DWORD PTR _loadstat+64, ecx

; 336  : 			return;

	jmp	SHORT $LN1@Mod_LoadLu

; 337  : 		}

	jmp	SHORT $LN27@Mod_LoadLu
$LN28@Mod_LoadLu:

; 338  : 		else if( !FBitSet( flags, LUMP_SILENT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN27@Mod_LoadLu

; 339  : 		{
; 340  : 			// just throw warning
; 341  : 			Con_DPrintf( S_WARN "map ^2%s^7 has too many %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET $SG145324
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 342  : 			loadstat.numwarnings++;

	mov	ecx, DWORD PTR _loadstat+68
	add	ecx, 1
	mov	DWORD PTR _loadstat+68, ecx
$LN27@Mod_LoadLu:

; 343  : 		}
; 344  : 	}
; 345  : 
; 346  : 	if( FBitSet( flags, LUMP_TESTONLY ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN32@Mod_LoadLu

; 347  : 		return; // don't fill the intermediate struct

	jmp	SHORT $LN1@Mod_LoadLu
$LN32@Mod_LoadLu:

; 348  : 
; 349  : 	// all checks are passed, store pointers
; 350  : 	if( info->dataptr ) *info->dataptr = (void *)(in + l->fileofs);

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN33@Mod_LoadLu
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx], edx
$LN33@Mod_LoadLu:

; 351  : 	if( info->count ) *info->count = numelems;

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN1@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _numelems$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@Mod_LoadLu:

; 352  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv197 = -36						; size = 4
tv187 = -32						; size = 4
tv177 = -28						; size = 4
tv160 = -24						; size = 4
tv154 = -20						; size = 4
_w$ = -16						; size = 4
_i$ = -12						; size = 4
_totalmemory$ = -8					; size = 4
_stat$1 = -4						; size = 4
_Mod_PrintWorldStats_f PROC

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 407  : 	int	i, totalmemory = 0;

	mov	DWORD PTR _totalmemory$[ebp], 0

; 408  : 	model_t	*w = worldmodel;

	mov	eax, DWORD PTR _worldmodel
	mov	DWORD PTR _w$[ebp], eax

; 409  : 
; 410  : 	if( !w || !w->numsubmodels )

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN6@Mod_PrintW
	mov	ecx, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [ecx+120], 0
	jne	SHORT $LN5@Mod_PrintW
$LN6@Mod_PrintW:

; 411  : 	{
; 412  : 		Con_Printf( "No map loaded\n" );

	push	OFFSET $SG145383
	call	_Con_Printf
	add	esp, 4

; 413  : 		return;

	jmp	$LN1@Mod_PrintW
$LN5@Mod_PrintW:

; 414  : 	}
; 415  : 
; 416  : 	Con_Printf( "\n" );

	push	OFFSET $SG145384
	call	_Con_Printf
	add	esp, 4

; 417  : 	Con_Printf( "Object names  Objects/Maxobjs  Memory / Maxmem  Fullness\n" );

	push	OFFSET $SG145385
	call	_Con_Printf
	add	esp, 4

; 418  : 	Con_Printf( "------------  ---------------  ---------------  --------\n" );

	push	OFFSET $SG145386
	call	_Con_Printf
	add	esp, 4

; 419  : 
; 420  : 	for( i = 0; i < ARRAYSIZE_XASH( worldstats ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_PrintW
$LN2@Mod_PrintW:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Mod_PrintW:
	cmp	DWORD PTR _i$[ebp], 27			; 0000001bH
	jae	$LN3@Mod_PrintW

; 421  : 	{
; 422  : 		mlumpstat_t *stat = &worldstats[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _worldstats
	mov	DWORD PTR _stat$1[ebp], eax

; 423  : 
; 424  : 		if( !stat->lumpname || !stat->maxcount || !stat->count )

	mov	ecx, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN8@Mod_PrintW
	mov	edx, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN8@Mod_PrintW
	mov	eax, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN7@Mod_PrintW
$LN8@Mod_PrintW:

; 425  : 			continue; // unused or lump is empty

	jmp	SHORT $LN2@Mod_PrintW
$LN7@Mod_PrintW:

; 426  : 
; 427  : 		if( stat->entrysize == sizeof( byte ))

	mov	ecx, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN9@Mod_PrintW

; 428  : 			totalmemory += Mod_GlobUsage( stat->lumpname, stat->count, stat->maxcount );

	mov	edx, DWORD PTR _stat$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _stat$1[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _stat$1[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_Mod_GlobUsage
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _totalmemory$[ebp]
	mov	DWORD PTR _totalmemory$[ebp], eax
	jmp	SHORT $LN10@Mod_PrintW
$LN9@Mod_PrintW:

; 429  : 		else totalmemory += Mod_ArrayUsage( stat->lumpname, stat->count, stat->maxcount, stat->entrysize );

	mov	edx, DWORD PTR _stat$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _stat$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _stat$1[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _stat$1[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Mod_ArrayUsage
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _totalmemory$[ebp]
	mov	DWORD PTR _totalmemory$[ebp], eax
$LN10@Mod_PrintW:

; 430  : 	}

	jmp	$LN2@Mod_PrintW
$LN3@Mod_PrintW:

; 431  : 
; 432  : 	Con_Printf( "=== Total BSP file data space used: %s ===\n", Q_memprint( totalmemory ));

	push	2
	cvtsi2ss xmm0, DWORD PTR _totalmemory$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG145391
	call	_Con_Printf
	add	esp, 8

; 433  : 	Con_Printf( "World size ( %g %g %g ) units\n", world.size[0], world.size[1], world.size[2] );

	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR _world[ecx+2624]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _world[edx+2624]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _world[ecx+2624]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG145392
	call	_Con_Printf
	add	esp, 28					; 0000001cH

; 434  : 	Con_Printf( "Supports transparency world water: %s\n", FBitSet( world.flags, FWORLD_WATERALPHA ) ? "Yes" : "No" );

	mov	edx, DWORD PTR _world+4
	and	edx, 4
	je	SHORT $LN12@Mod_PrintW
	mov	DWORD PTR tv154[ebp], OFFSET $SG145393
	jmp	SHORT $LN13@Mod_PrintW
$LN12@Mod_PrintW:
	mov	DWORD PTR tv154[ebp], OFFSET $SG145394
$LN13@Mod_PrintW:
	mov	eax, DWORD PTR tv154[ebp]
	push	eax
	push	OFFSET $SG145395
	call	_Con_Printf
	add	esp, 8

; 435  : 	Con_Printf( "Lighting: %s\n", FBitSet( w->flags, MODEL_COLORED_LIGHTING ) ? "colored" : "monochrome" );

	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 16					; 00000010H
	je	SHORT $LN14@Mod_PrintW
	mov	DWORD PTR tv160[ebp], OFFSET $SG145396
	jmp	SHORT $LN15@Mod_PrintW
$LN14@Mod_PrintW:
	mov	DWORD PTR tv160[ebp], OFFSET $SG145397
$LN15@Mod_PrintW:
	mov	eax, DWORD PTR tv160[ebp]
	push	eax
	push	OFFSET $SG145398
	call	_Con_Printf
	add	esp, 8

; 436  : 	Con_Printf( "World total leafs: %d\n", worldmodel->numleafs + 1 );

	mov	ecx, DWORD PTR _worldmodel
	mov	edx, DWORD PTR [ecx+136]
	add	edx, 1
	push	edx
	push	OFFSET $SG145399
	call	_Con_Printf
	add	esp, 8

; 437  : 	Con_Printf( "original name: ^1%s\n", worldmodel->name );

	mov	eax, DWORD PTR _worldmodel
	push	eax
	push	OFFSET $SG145400
	call	_Con_Printf
	add	esp, 8

; 438  : 	Con_Printf( "internal name: %s\n", (world.message[0]) ? va( "^2%s", world.message ) : "none" );

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _world[edx+8]
	test	eax, eax
	je	SHORT $LN16@Mod_PrintW
	push	OFFSET _world+8
	push	OFFSET $SG145401
	call	_va
	add	esp, 8
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN17@Mod_PrintW
$LN16@Mod_PrintW:
	mov	DWORD PTR tv177[ebp], OFFSET $SG145402
$LN17@Mod_PrintW:
	mov	ecx, DWORD PTR tv177[ebp]
	push	ecx
	push	OFFSET $SG145403
	call	_Con_Printf
	add	esp, 8

; 439  : 	Con_Printf( "map compiler: %s\n", (world.compiler[0]) ? va( "^3%s", world.compiler ) : "unknown" );

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _world[eax+2056]
	test	ecx, ecx
	je	SHORT $LN18@Mod_PrintW
	push	OFFSET _world+2056
	push	OFFSET $SG145404
	call	_va
	add	esp, 8
	mov	DWORD PTR tv187[ebp], eax
	jmp	SHORT $LN19@Mod_PrintW
$LN18@Mod_PrintW:
	mov	DWORD PTR tv187[ebp], OFFSET $SG145405
$LN19@Mod_PrintW:
	mov	edx, DWORD PTR tv187[ebp]
	push	edx
	push	OFFSET $SG145406
	call	_Con_Printf
	add	esp, 8

; 440  : 	Con_Printf( "map editor: %s\n", (world.generator[0]) ? va( "^2%s", world.generator ) : "unknown" );

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _world[ecx+2312]
	test	edx, edx
	je	SHORT $LN20@Mod_PrintW
	push	OFFSET _world+2312
	push	OFFSET $SG145407
	call	_va
	add	esp, 8
	mov	DWORD PTR tv197[ebp], eax
	jmp	SHORT $LN21@Mod_PrintW
$LN20@Mod_PrintW:
	mov	DWORD PTR tv197[ebp], OFFSET $SG145408
$LN21@Mod_PrintW:
	mov	eax, DWORD PTR tv197[ebp]
	push	eax
	push	OFFSET $SG145409
	call	_Con_Printf
	add	esp, 8
$LN1@Mod_PrintW:

; 441  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_PrintWorldStats_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv69 = -12						; size = 4
_tx$ = -8						; size = 4
_i$ = -4						; size = 4
_mod$ = 8						; size = 4
_Mod_UnloadBrushModel PROC

; 2918 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2919 : 	texture_t	*tx;
; 2920 : 	int	i;
; 2921 : 
; 2922 : 	Assert( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN11@Mod_Unload
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN12@Mod_Unload
$LN11@Mod_Unload:
	mov	DWORD PTR tv69[ebp], 0
$LN12@Mod_Unload:
	push	0
	push	2922					; 00000b6aH
	push	OFFSET $SG146705
	push	OFFSET $SG146706
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2923 : 
; 2924 : 	if( mod->type != mod_brush )

	mov	ecx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN5@Mod_Unload

; 2925 : 		return; // not a bmodel

	jmp	$LN1@Mod_Unload
$LN5@Mod_Unload:

; 2926 : 
; 2927 : 	// invalidate pointers
; 2928 : 	if( FBitSet( mod->flags, MODEL_WORLD ))

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 536870912				; 20000000H
	je	SHORT $LN6@Mod_Unload

; 2929 : 	{
; 2930 : 		world.deluxedata = NULL;

	mov	DWORD PTR _world+2584, 0

; 2931 : 		world.shadowdata = NULL;

	mov	DWORD PTR _world+2588, 0
$LN6@Mod_Unload:

; 2932 : 	}
; 2933 : 
; 2934 : 	if( mod->name[0] != '*' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mod$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	je	$LN7@Mod_Unload

; 2935 : 	{
; 2936 : 		for( i = 0; i < mod->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Unload
$LN2@Mod_Unload:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Mod_Unload:
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN3@Mod_Unload

; 2937 : 		{
; 2938 : 			tx = mod->textures[i];

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+372]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tx$[ebp], edx

; 2939 : 			if( !tx || tx->gl_texturenum == tr.defaultTexture )

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN9@Mod_Unload
	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _tr
	jne	SHORT $LN8@Mod_Unload
$LN9@Mod_Unload:

; 2940 : 				continue;	// free slot

	jmp	SHORT $LN2@Mod_Unload
$LN8@Mod_Unload:

; 2941 : 
; 2942 : 			GL_FreeTexture( tx->gl_texturenum );	// main texture

	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_GL_FreeTexture
	add	esp, 4

; 2943 : 			GL_FreeTexture( tx->fb_texturenum );	// luma texture

	mov	ecx, DWORD PTR _tx$[ebp]
	movzx	edx, WORD PTR [ecx+52]
	push	edx
	call	_GL_FreeTexture
	add	esp, 4

; 2944 : 		}

	jmp	SHORT $LN2@Mod_Unload
$LN3@Mod_Unload:

; 2945 : 		Mem_FreePool( &mod->mempool );

	push	2945					; 00000b81H
	push	OFFSET $SG146712
	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH
$LN7@Mod_Unload:

; 2946 : 	}
; 2947 : 
; 2948 : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Mod_Unload:

; 2949 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_UnloadBrushModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv144 = -16						; size = 4
tv138 = -12						; size = 4
_leaf$ = -8						; size = 4
_node$ = -4						; size = 4
_p$ = 8							; size = 4
_Mod_GetPVSForPoint PROC

; 524  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 525  : 	mnode_t	*node;
; 526  : 	mleaf_t	*leaf = NULL;

	mov	DWORD PTR _leaf$[ebp], 0

; 527  : 
; 528  : 	ASSERT( worldmodel != NULL );

	cmp	DWORD PTR _worldmodel, 0
	jne	SHORT $LN4@Mod_GetPVS
	push	528					; 00000210H
	push	OFFSET $SG145453
	push	OFFSET $SG145454
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mod_GetPVS:

; 529  : 
; 530  : 	node = worldmodel->nodes;

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR _node$[ebp], ecx
$LN2@Mod_GetPVS:

; 531  : 
; 532  : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN3@Mod_GetPVS

; 533  : 	{
; 534  : 		if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN5@Mod_GetPVS

; 535  : 		{
; 536  : 			leaf = (mleaf_t *)node;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$[ebp], ecx

; 537  : 			break; // we found a leaf

	jmp	$LN3@Mod_GetPVS
$LN5@Mod_GetPVS:

; 538  : 		}
; 539  : 		node = node->children[PlaneDiff( p, node->plane ) <= 0];

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN8@Mod_GetPVS
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR tv138[ebp], xmm0
	jmp	SHORT $LN9@Mod_GetPVS
$LN8@Mod_GetPVS:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv138[ebp], xmm0
$LN9@Mod_GetPVS:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR tv138[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jb	SHORT $LN10@Mod_GetPVS
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN11@Mod_GetPVS
$LN10@Mod_GetPVS:
	mov	DWORD PTR tv144[ebp], 0
$LN11@Mod_GetPVS:
	mov	eax, DWORD PTR tv144[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	mov	DWORD PTR _node$[ebp], edx

; 540  : 	}

	jmp	$LN2@Mod_GetPVS
$LN3@Mod_GetPVS:

; 541  : 
; 542  : 	if( leaf && leaf->cluster >= 0 )

	cmp	DWORD PTR _leaf$[ebp], 0
	je	SHORT $LN6@Mod_GetPVS
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN6@Mod_GetPVS

; 543  : 		return Mod_DecompressPVS( leaf->compressed_vis, world.visbytes );

	mov	ecx, DWORD PTR _world+2592
	push	ecx
	mov	edx, DWORD PTR _leaf$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_Mod_DecompressPVS
	add	esp, 8
	jmp	SHORT $LN1@Mod_GetPVS
$LN6@Mod_GetPVS:

; 544  : 	return NULL;

	xor	eax, eax
$LN1@Mod_GetPVS:

; 545  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetPVSForPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_surf$ = 8						; size = 4
_Mod_SampleSizeForFace PROC

; 871  : {

	push	ebp
	mov	ebp, esp

; 872  : 	if( !surf || !surf->texinfo )

	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN3@Mod_Sample
	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN2@Mod_Sample
$LN3@Mod_Sample:

; 873  : 		return LM_SAMPLE_SIZE;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN1@Mod_Sample
$LN2@Mod_Sample:

; 874  : 
; 875  : 	// world luxels has more priority
; 876  : 	if( FBitSet( surf->texinfo->flags, TEX_WORLD_LUXELS ))

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 2
	je	SHORT $LN4@Mod_Sample

; 877  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Sample
$LN4@Mod_Sample:

; 878  : 
; 879  : 	if( FBitSet( surf->texinfo->flags, TEX_EXTRA_LIGHTMAP ))

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 8
	je	SHORT $LN5@Mod_Sample

; 880  : 		return LM_SAMPLE_EXTRASIZE;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_Sample
$LN5@Mod_Sample:

; 881  : 
; 882  : 	if( surf->texinfo->faceinfo )

	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN6@Mod_Sample

; 883  : 		return surf->texinfo->faceinfo->texture_step;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+32]
	movzx	eax, WORD PTR [edx+16]
	jmp	SHORT $LN1@Mod_Sample
$LN6@Mod_Sample:

; 884  : 
; 885  : 	return LM_SAMPLE_SIZE;

	mov	eax, 16					; 00000010H
$LN1@Mod_Sample:

; 886  : }

	pop	ebp
	ret	0
_Mod_SampleSizeForFace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_leaf$ = -4						; size = 4
_p$ = 8							; size = 4
_pvolumes$ = 12						; size = 4
_Mod_AmbientLevels PROC

; 756  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 757  : 	mleaf_t	*leaf;
; 758  : 
; 759  : 	if( !worldmodel || !p || !pvolumes )

	cmp	DWORD PTR _worldmodel, 0
	je	SHORT $LN3@Mod_Ambien
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Mod_Ambien
	cmp	DWORD PTR _pvolumes$[ebp], 0
	jne	SHORT $LN2@Mod_Ambien
$LN3@Mod_Ambien:

; 760  : 		return;	

	jmp	SHORT $LN1@Mod_Ambien
$LN2@Mod_Ambien:

; 761  : 
; 762  : 	leaf = Mod_PointInLeaf( p, worldmodel->nodes );

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 763  : 	*(int *)pvolumes = *(int *)leaf->ambient_sound_level;

	mov	eax, DWORD PTR _pvolumes$[ebp]
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax], edx
$LN1@Mod_Ambien:

; 764  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_AmbientLevels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv146 = -12						; size = 4
tv140 = -8						; size = 4
tv69 = -4						; size = 4
_p$ = 8							; size = 4
_node$ = 12						; size = 4
_Mod_PointInLeaf PROC

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 502  : 	Assert( node != NULL );

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN6@Mod_PointI
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@Mod_PointI
$LN6@Mod_PointI:
	mov	DWORD PTR tv69[ebp], 0
$LN7@Mod_PointI:
	push	0
	push	502					; 000001f6H
	push	OFFSET $SG145438
	push	OFFSET $SG145439
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H
$LN2@Mod_PointI:

; 503  : 
; 504  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@Mod_PointI

; 505  : 	{
; 506  : 		if( node->contents < 0 )

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], 0
	jge	SHORT $LN4@Mod_PointI

; 507  : 			return (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@Mod_PointI
$LN4@Mod_PointI:

; 508  : 		node = node->children[PlaneDiff( p, node->plane ) <= 0];

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN8@Mod_PointI
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv140[ebp], xmm0
	jmp	SHORT $LN9@Mod_PointI
$LN8@Mod_PointI:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv140[ebp], xmm0
$LN9@Mod_PointI:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv140[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jb	SHORT $LN10@Mod_PointI
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN11@Mod_PointI
$LN10@Mod_PointI:
	mov	DWORD PTR tv146[ebp], 0
$LN11@Mod_PointI:
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _node$[ebp], eax

; 509  : 	}

	jmp	$LN2@Mod_PointI
$LN3@Mod_PointI:

; 510  : 
; 511  : 	// never reached
; 512  : 	return NULL;

	xor	eax, eax
$LN1@Mod_PointI:

; 513  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_PointInLeaf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_header$ = -256						; size = 4
_dummy$ = -252						; size = 4
_prefetch_size$ = -248					; size = 4
_result$ = -244						; size = 4
_extrahdr$ = -240					; size = 4
_f$ = -236						; size = 4
_buffer$ = -232						; size = 228
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpdata$ = 16						; size = 4
_lumpsize$ = 20						; size = 4
_Mod_SaveLump PROC

; 3100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3101 : 	byte		buffer[sizeof( dheader_t ) + sizeof( dextrahdr_t )];
; 3102 : 	size_t		prefetch_size = sizeof( buffer );

	mov	DWORD PTR _prefetch_size$[ebp], 228	; 000000e4H

; 3103 : 	int		result, dummy = lumpsize;

	mov	eax, DWORD PTR _lumpsize$[ebp]
	mov	DWORD PTR _dummy$[ebp], eax

; 3104 : 	dextrahdr_t	*extrahdr;
; 3105 : 	dheader_t		*header;
; 3106 : 	file_t		*f;
; 3107 : 
; 3108 : 	if( !lumpdata || lumpsize <= 0 )

	cmp	DWORD PTR _lumpdata$[ebp], 0
	je	SHORT $LN3@Mod_SaveLu
	cmp	DWORD PTR _lumpsize$[ebp], 0
	jg	SHORT $LN2@Mod_SaveLu
$LN3@Mod_SaveLu:

; 3109 : 		return LUMP_SAVE_NO_DATA;

	mov	eax, 7
	jmp	$LN1@Mod_SaveLu
$LN2@Mod_SaveLu:

; 3110 : 
; 3111 : 	// make sure what .bsp is placed into gamedir and not in pak
; 3112 : 	if( !FS_GetDiskPath( filename, true ))

	push	1
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_GetDiskPath
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@Mod_SaveLu

; 3113 : 		return LUMP_SAVE_COULDNT_OPEN;

	mov	eax, 1
	jmp	$LN1@Mod_SaveLu
$LN4@Mod_SaveLu:

; 3114 : 
; 3115 : 	// first we should sure what we allow to rewrite this .bsp
; 3116 : 	result = Mod_CheckLump( filename, lump, &dummy );

	lea	edx, DWORD PTR _dummy$[ebp]
	push	edx
	mov	eax, DWORD PTR _lump$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Mod_CheckLump
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 3117 : 
; 3118 : 	if( result != LUMP_LOAD_NOT_EXIST )

	cmp	DWORD PTR _result$[ebp], 6
	je	SHORT $LN5@Mod_SaveLu

; 3119 : 		return result;

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@Mod_SaveLu
$LN5@Mod_SaveLu:

; 3120 : 
; 3121 : 	f = FS_Open( filename, "e+b", true );

	push	1
	push	OFFSET $SG146804
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 3122 : 
; 3123 : 	if( !f ) return LUMP_SAVE_COULDNT_OPEN;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN6@Mod_SaveLu
	mov	eax, 1
	jmp	$LN1@Mod_SaveLu
$LN6@Mod_SaveLu:

; 3124 : 
; 3125 : 	if( FS_Read( f, buffer, prefetch_size ) != prefetch_size )

	mov	eax, DWORD PTR _prefetch_size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _prefetch_size$[ebp]
	je	SHORT $LN7@Mod_SaveLu

; 3126 : 	{
; 3127 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3128 : 		return LUMP_SAVE_BAD_HEADER;

	mov	eax, 2
	jmp	$LN1@Mod_SaveLu
$LN7@Mod_SaveLu:

; 3129 : 	}
; 3130 : 
; 3131 : 	header = (dheader_t *)buffer;

	lea	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _header$[ebp], ecx

; 3132 : 
; 3133 : 	// these checks below are redundant
; 3134 : 	if( header->version != HLBSP_VERSION )

	mov	edx, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [edx], 30			; 0000001eH
	je	SHORT $LN8@Mod_SaveLu

; 3135 : 	{
; 3136 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3137 : 		return LUMP_SAVE_BAD_VERSION;

	mov	eax, 3
	jmp	$LN1@Mod_SaveLu
$LN8@Mod_SaveLu:

; 3138 : 	}
; 3139 : 
; 3140 : 	extrahdr = (dextrahdr_t *)((byte *)buffer + sizeof( dheader_t ));

	lea	ecx, DWORD PTR _buffer$[ebp+124]
	mov	DWORD PTR _extrahdr$[ebp], ecx

; 3141 : 
; 3142 : 	if( extrahdr->id != IDEXTRAHEADER || extrahdr->version != EXTRA_VERSION )

	mov	edx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [edx], 1213415768		; 48534158H
	jne	SHORT $LN10@Mod_SaveLu
	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN9@Mod_SaveLu
$LN10@Mod_SaveLu:

; 3143 : 	{
; 3144 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 3145 : 		return LUMP_SAVE_NO_EXTRADATA;

	mov	eax, 4
	jmp	$LN1@Mod_SaveLu
$LN9@Mod_SaveLu:

; 3146 : 	}
; 3147 : 
; 3148 : 	if( lump < 0 || lump >= EXTRA_LUMPS )

	cmp	DWORD PTR _lump$[ebp], 0
	jl	SHORT $LN12@Mod_SaveLu
	cmp	DWORD PTR _lump$[ebp], 12		; 0000000cH
	jl	SHORT $LN11@Mod_SaveLu
$LN12@Mod_SaveLu:

; 3149 : 	{
; 3150 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 3151 : 		return LUMP_SAVE_INVALID_NUM;

	mov	eax, 5
	jmp	$LN1@Mod_SaveLu
$LN11@Mod_SaveLu:

; 3152 : 	}
; 3153 : 
; 3154 : 	if( extrahdr->lumps[lump].filelen != 0 )

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [ecx+eax*8+12], 0
	je	SHORT $LN13@Mod_SaveLu

; 3155 : 	{
; 3156 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 3157 : 		return LUMP_SAVE_ALREADY_EXIST;

	mov	eax, 6
	jmp	$LN1@Mod_SaveLu
$LN13@Mod_SaveLu:

; 3158 : 	}
; 3159 : 
; 3160 : 	FS_Seek( f, 0, SEEK_END );

	push	2
	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 3161 : 
; 3162 : 	// will be saved later
; 3163 : 	extrahdr->lumps[lump].fileofs = FS_Tell( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Tell
	add	esp, 4
	mov	edx, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	mov	DWORD PTR [ecx+edx*8+8], eax

; 3164 : 	extrahdr->lumps[lump].filelen = lumpsize;

	mov	edx, DWORD PTR _lump$[ebp]
	mov	eax, DWORD PTR _extrahdr$[ebp]
	mov	ecx, DWORD PTR _lumpsize$[ebp]
	mov	DWORD PTR [eax+edx*8+12], ecx

; 3165 : 
; 3166 : 	if( FS_Write( f, lumpdata, lumpsize ) != lumpsize )

	mov	edx, DWORD PTR _lumpsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _lumpdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _lumpsize$[ebp]
	je	SHORT $LN14@Mod_SaveLu

; 3167 : 	{
; 3168 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 3169 : 		return LUMP_SAVE_CORRUPTED;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_SaveLu
$LN14@Mod_SaveLu:

; 3170 : 	}
; 3171 : 
; 3172 : 	// update the header
; 3173 : 	FS_Seek( f, sizeof( dheader_t ), SEEK_SET );

	push	0
	push	124					; 0000007cH
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 3174 : 
; 3175 : 	if( FS_Write( f, extrahdr, sizeof( dextrahdr_t )) != sizeof( dextrahdr_t ))

	push	104					; 00000068H
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
	cmp	eax, 104				; 00000068H
	je	SHORT $LN15@Mod_SaveLu

; 3176 : 	{
; 3177 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3178 : 		return LUMP_SAVE_CORRUPTED;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_SaveLu
$LN15@Mod_SaveLu:

; 3179 : 	}
; 3180 : 
; 3181 : 	FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 3182 : 	return LUMP_SAVE_OK;

	xor	eax, eax
$LN1@Mod_SaveLu:

; 3183 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SaveLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_header$ = -256						; size = 4
_prefetch_size$ = -252					; size = 4
_length$ = -248						; size = 4
_data$ = -244						; size = 4
_extrahdr$ = -240					; size = 4
_f$ = -236						; size = 4
_buffer$ = -232						; size = 228
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpdata$ = 16						; size = 4
_lumpsize$ = 20						; size = 4
_Mod_ReadLump PROC

; 3018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3019 : 	file_t		*f = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET $SG146763
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 3020 : 	byte		buffer[sizeof( dheader_t ) + sizeof( dextrahdr_t )];
; 3021 : 	size_t		prefetch_size = sizeof( buffer );

	mov	DWORD PTR _prefetch_size$[ebp], 228	; 000000e4H

; 3022 : 	dextrahdr_t	*extrahdr;
; 3023 : 	dheader_t		*header;
; 3024 : 	byte		*data;
; 3025 : 	int		length;
; 3026 : 
; 3027 : 	if( !f ) return LUMP_LOAD_COULDNT_OPEN;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@Mod_ReadLu
	mov	eax, 1
	jmp	$LN1@Mod_ReadLu
$LN2@Mod_ReadLu:

; 3028 : 
; 3029 : 	if( FS_Read( f, buffer, prefetch_size ) != prefetch_size )

	mov	ecx, DWORD PTR _prefetch_size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _prefetch_size$[ebp]
	je	SHORT $LN3@Mod_ReadLu

; 3030 : 	{
; 3031 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 3032 : 		return LUMP_LOAD_BAD_HEADER;

	mov	eax, 2
	jmp	$LN1@Mod_ReadLu
$LN3@Mod_ReadLu:

; 3033 : 	}
; 3034 : 
; 3035 : 	header = (dheader_t *)buffer;

	lea	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _header$[ebp], edx

; 3036 : 
; 3037 : 	if( header->version != HLBSP_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 30			; 0000001eH
	je	SHORT $LN4@Mod_ReadLu

; 3038 : 	{
; 3039 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 3040 : 		return LUMP_LOAD_BAD_VERSION;

	mov	eax, 3
	jmp	$LN1@Mod_ReadLu
$LN4@Mod_ReadLu:

; 3041 : 	}
; 3042 : 
; 3043 : 	extrahdr = (dextrahdr_t *)((byte *)buffer + sizeof( dheader_t ));

	lea	edx, DWORD PTR _buffer$[ebp+124]
	mov	DWORD PTR _extrahdr$[ebp], edx

; 3044 : 
; 3045 : 	if( extrahdr->id != IDEXTRAHEADER || extrahdr->version != EXTRA_VERSION )

	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax], 1213415768		; 48534158H
	jne	SHORT $LN6@Mod_ReadLu
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [ecx+4], 4
	je	SHORT $LN5@Mod_ReadLu
$LN6@Mod_ReadLu:

; 3046 : 	{
; 3047 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 3048 : 		return LUMP_LOAD_NO_EXTRADATA;

	mov	eax, 4
	jmp	$LN1@Mod_ReadLu
$LN5@Mod_ReadLu:

; 3049 : 	}
; 3050 : 
; 3051 : 	if( lump < 0 || lump >= EXTRA_LUMPS )

	cmp	DWORD PTR _lump$[ebp], 0
	jl	SHORT $LN8@Mod_ReadLu
	cmp	DWORD PTR _lump$[ebp], 12		; 0000000cH
	jl	SHORT $LN7@Mod_ReadLu
$LN8@Mod_ReadLu:

; 3052 : 	{
; 3053 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3054 : 		return LUMP_LOAD_INVALID_NUM;

	mov	eax, 5
	jmp	$LN1@Mod_ReadLu
$LN7@Mod_ReadLu:

; 3055 : 	}
; 3056 : 
; 3057 : 	if( extrahdr->lumps[lump].filelen <= 0 )

	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [edx+ecx*8+12], 0
	jg	SHORT $LN9@Mod_ReadLu

; 3058 : 	{
; 3059 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3060 : 		return LUMP_LOAD_NOT_EXIST;

	mov	eax, 6
	jmp	$LN1@Mod_ReadLu
$LN9@Mod_ReadLu:

; 3061 : 	}
; 3062 : 
; 3063 : 	data = malloc( extrahdr->lumps[lump].filelen + 1 );

	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR _extrahdr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+12]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 3064 : 	length = extrahdr->lumps[lump].filelen;

	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR _extrahdr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+12]
	mov	DWORD PTR _length$[ebp], eax

; 3065 : 
; 3066 : 	if( !data )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN10@Mod_ReadLu

; 3067 : 	{
; 3068 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 3069 : 		return LUMP_LOAD_MEM_FAILED;

	mov	eax, 7
	jmp	$LN1@Mod_ReadLu
$LN10@Mod_ReadLu:

; 3070 : 	}
; 3071 : 
; 3072 : 	FS_Seek( f, extrahdr->lumps[lump].fileofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _lump$[ebp]
	mov	eax, DWORD PTR _extrahdr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+8]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 3073 : 
; 3074 : 	if( FS_Read( f, data, length ) != length )

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _length$[ebp]
	je	SHORT $LN11@Mod_ReadLu

; 3075 : 	{
; 3076 : 		free( data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 3077 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 3078 : 		return LUMP_LOAD_CORRUPTED;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_ReadLu
$LN11@Mod_ReadLu:

; 3079 : 	}
; 3080 : 
; 3081 : 	data[length] = 0; // write term

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _length$[ebp]
	mov	BYTE PTR [edx], 0

; 3082 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3083 : 
; 3084 : 	if( lumpsize )

	cmp	DWORD PTR _lumpsize$[ebp], 0
	je	SHORT $LN12@Mod_ReadLu

; 3085 : 		*lumpsize = length;

	mov	ecx, DWORD PTR _lumpsize$[ebp]
	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [ecx], edx
$LN12@Mod_ReadLu:

; 3086 : 	*lumpdata = data;

	mov	eax, DWORD PTR _lumpdata$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax], ecx

; 3087 : 
; 3088 : 	return LUMP_LOAD_OK;

	xor	eax, eax
$LN1@Mod_ReadLu:

; 3089 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ReadLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_header$ = -248						; size = 4
_prefetch_size$ = -244					; size = 4
_extrahdr$ = -240					; size = 4
_f$ = -236						; size = 4
_buffer$ = -232						; size = 228
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpsize$ = 16						; size = 4
_Mod_CheckLump PROC

; 2959 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2960 : 	file_t		*f = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET $SG146731
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 2961 : 	byte		buffer[sizeof( dheader_t ) + sizeof( dextrahdr_t )];
; 2962 : 	size_t		prefetch_size = sizeof( buffer );

	mov	DWORD PTR _prefetch_size$[ebp], 228	; 000000e4H

; 2963 : 	dextrahdr_t	*extrahdr;
; 2964 : 	dheader_t		*header;
; 2965 : 
; 2966 : 	if( !f ) return LUMP_LOAD_COULDNT_OPEN;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@Mod_CheckL
	mov	eax, 1
	jmp	$LN1@Mod_CheckL
$LN2@Mod_CheckL:

; 2967 : 
; 2968 : 	if( FS_Read( f, buffer, prefetch_size ) != prefetch_size )

	mov	ecx, DWORD PTR _prefetch_size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _prefetch_size$[ebp]
	je	SHORT $LN3@Mod_CheckL

; 2969 : 	{
; 2970 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 2971 : 		return LUMP_LOAD_BAD_HEADER;

	mov	eax, 2
	jmp	$LN1@Mod_CheckL
$LN3@Mod_CheckL:

; 2972 : 	}
; 2973 : 
; 2974 : 	header = (dheader_t *)buffer;

	lea	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _header$[ebp], edx

; 2975 : 
; 2976 : 	if( header->version != HLBSP_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 30			; 0000001eH
	je	SHORT $LN4@Mod_CheckL

; 2977 : 	{
; 2978 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 2979 : 		return LUMP_LOAD_BAD_VERSION;

	mov	eax, 3
	jmp	$LN1@Mod_CheckL
$LN4@Mod_CheckL:

; 2980 : 	}
; 2981 : 
; 2982 : 	extrahdr = (dextrahdr_t *)((byte *)buffer + sizeof( dheader_t ));

	lea	edx, DWORD PTR _buffer$[ebp+124]
	mov	DWORD PTR _extrahdr$[ebp], edx

; 2983 : 
; 2984 : 	if( extrahdr->id != IDEXTRAHEADER || extrahdr->version != EXTRA_VERSION )

	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax], 1213415768		; 48534158H
	jne	SHORT $LN6@Mod_CheckL
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [ecx+4], 4
	je	SHORT $LN5@Mod_CheckL
$LN6@Mod_CheckL:

; 2985 : 	{
; 2986 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 2987 : 		return LUMP_LOAD_NO_EXTRADATA;

	mov	eax, 4
	jmp	SHORT $LN1@Mod_CheckL
$LN5@Mod_CheckL:

; 2988 : 	}
; 2989 : 
; 2990 : 	if( lump < 0 || lump >= EXTRA_LUMPS )

	cmp	DWORD PTR _lump$[ebp], 0
	jl	SHORT $LN8@Mod_CheckL
	cmp	DWORD PTR _lump$[ebp], 12		; 0000000cH
	jl	SHORT $LN7@Mod_CheckL
$LN8@Mod_CheckL:

; 2991 : 	{
; 2992 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2993 : 		return LUMP_LOAD_INVALID_NUM;

	mov	eax, 5
	jmp	SHORT $LN1@Mod_CheckL
$LN7@Mod_CheckL:

; 2994 : 	}
; 2995 : 
; 2996 : 	if( extrahdr->lumps[lump].filelen <= 0 )

	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [edx+ecx*8+12], 0
	jg	SHORT $LN9@Mod_CheckL

; 2997 : 	{
; 2998 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2999 : 		return LUMP_LOAD_NOT_EXIST;

	mov	eax, 6
	jmp	SHORT $LN1@Mod_CheckL
$LN9@Mod_CheckL:

; 3000 : 	}
; 3001 : 
; 3002 : 	if( lumpsize )

	cmp	DWORD PTR _lumpsize$[ebp], 0
	je	SHORT $LN10@Mod_CheckL

; 3003 : 		*lumpsize = extrahdr->lumps[lump].filelen;

	mov	ecx, DWORD PTR _lumpsize$[ebp]
	mov	edx, DWORD PTR _lump$[ebp]
	mov	eax, DWORD PTR _extrahdr$[ebp]
	mov	edx, DWORD PTR [eax+edx*8+12]
	mov	DWORD PTR [ecx], edx
$LN10@Mod_CheckL:

; 3004 : 
; 3005 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3006 : 
; 3007 : 	return LUMP_LOAD_OK;

	xor	eax, eax
$LN1@Mod_CheckL:

; 3008 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CheckLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_count$ = -1040						; size = 4
tv91 = -1036						; size = 4
_i$ = -1032						; size = 4
_leafList$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_visbits$ = 16						; size = 4
_Mod_BoxVisible PROC

; 702  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1040				; 00000410H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 703  : 	int	leafList[MAX_BOX_LEAFS];
; 704  : 	int	i, count;
; 705  : 
; 706  : 	if( !visbits || !mins || !maxs )

	cmp	DWORD PTR _visbits$[ebp], 0
	je	SHORT $LN6@Mod_BoxVis
	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN6@Mod_BoxVis
	cmp	DWORD PTR _maxs$[ebp], 0
	jne	SHORT $LN5@Mod_BoxVis
$LN6@Mod_BoxVis:

; 707  : 		return true;

	mov	eax, 1
	jmp	$LN1@Mod_BoxVis
$LN5@Mod_BoxVis:

; 708  : 
; 709  : 	count = Mod_BoxLeafnums( mins, maxs, leafList, MAX_BOX_LEAFS, NULL );

	push	0
	push	256					; 00000100H
	lea	eax, DWORD PTR _leafList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	_Mod_BoxLeafnums
	add	esp, 20					; 00000014H
	mov	DWORD PTR _count$[ebp], eax

; 710  : 
; 711  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_BoxVis
$LN2@Mod_BoxVis:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_BoxVis:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@Mod_BoxVis

; 712  : 	{
; 713  : 		if( CHECKVISBIT( visbits, leafList[i] ))

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _leafList$[ebp+edx*4], 0
	jl	SHORT $LN9@Mod_BoxVis
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _leafList$[ebp+eax*4]
	sar	ecx, 3
	mov	edx, DWORD PTR _visbits$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _leafList$[ebp+ecx*4]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN10@Mod_BoxVis
$LN9@Mod_BoxVis:
	mov	DWORD PTR tv91[ebp], 0
$LN10@Mod_BoxVis:
	cmp	DWORD PTR tv91[ebp], 0
	je	SHORT $LN7@Mod_BoxVis

; 714  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_BoxVis
$LN7@Mod_BoxVis:

; 715  : 	}

	jmp	$LN2@Mod_BoxVis
$LN3@Mod_BoxVis:

; 716  : 	return false;

	xor	eax, eax
$LN1@Mod_BoxVis:

; 717  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_BoxVisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv73 = -12						; size = 4
_leaf$ = -8						; size = 4
_bytes$ = -4						; size = 4
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_visbuffer$ = 16					; size = 4
_visbytes$ = 20						; size = 4
_merge$ = 24						; size = 4
_fullvis$ = 28						; size = 4
_Mod_FatPVS PROC

; 592  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 593  : 	int	bytes = world.visbytes;

	mov	eax, DWORD PTR _world+2592
	mov	DWORD PTR _bytes$[ebp], eax

; 594  : 	mleaf_t	*leaf = NULL;

	mov	DWORD PTR _leaf$[ebp], 0

; 595  : 
; 596  : 	ASSERT( worldmodel != NULL );

	cmp	DWORD PTR _worldmodel, 0
	jne	SHORT $LN2@Mod_FatPVS
	push	596					; 00000254H
	push	OFFSET $SG145502
	push	OFFSET $SG145503
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mod_FatPVS:

; 597  : 
; 598  : 	leaf = Mod_PointInLeaf( org, worldmodel->nodes );

	mov	ecx, DWORD PTR _worldmodel
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 599  : 	bytes = Q_min( bytes, visbytes );

	mov	ecx, DWORD PTR _bytes$[ebp]
	cmp	ecx, DWORD PTR _visbytes$[ebp]
	jge	SHORT $LN7@Mod_FatPVS
	mov	edx, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR tv73[ebp], edx
	jmp	SHORT $LN8@Mod_FatPVS
$LN7@Mod_FatPVS:
	mov	eax, DWORD PTR _visbytes$[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN8@Mod_FatPVS:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _bytes$[ebp], ecx

; 600  : 
; 601  : 	// enable full visibility for some reasons
; 602  : 	if( fullvis || !worldmodel->visdata || !leaf || leaf->cluster < 0 )

	cmp	DWORD PTR _fullvis$[ebp], 0
	jne	SHORT $LN4@Mod_FatPVS
	mov	edx, DWORD PTR _worldmodel
	cmp	DWORD PTR [edx+376], 0
	je	SHORT $LN4@Mod_FatPVS
	cmp	DWORD PTR _leaf$[ebp], 0
	je	SHORT $LN4@Mod_FatPVS
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jge	SHORT $LN3@Mod_FatPVS
$LN4@Mod_FatPVS:

; 603  : 	{
; 604  : 		memset( visbuffer, 0xFF, bytes );

	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	push	255					; 000000ffH
	mov	edx, DWORD PTR _visbuffer$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 605  : 		return bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
	jmp	SHORT $LN1@Mod_FatPVS
$LN3@Mod_FatPVS:

; 606  : 	}
; 607  : 
; 608  : 	if( !merge ) memset( visbuffer, 0x00, bytes );

	cmp	DWORD PTR _merge$[ebp], 0
	jne	SHORT $LN5@Mod_FatPVS
	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _visbuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN5@Mod_FatPVS:

; 609  : 
; 610  : 	Mod_FatPVS_RecursiveBSPNode( org, radius, visbuffer, bytes, worldmodel->nodes );

	mov	edx, DWORD PTR _worldmodel
	mov	eax, DWORD PTR [edx+164]
	push	eax
	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _visbuffer$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_Mod_FatPVS_RecursiveBSPNode
	add	esp, 20					; 00000014H

; 611  : 
; 612  : 	return bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
$LN1@Mod_FatPVS:

; 613  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FatPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
tv82 = -4						; size = 4
_node$ = 8						; size = 4
_visbits$ = 12						; size = 4
_lastleaf$ = 16						; size = 4
_Mod_HeadnodeVisible PROC

; 725  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 726  : 	if( !node || node->contents == CONTENTS_SOLID )

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN3@Mod_Headno
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN2@Mod_Headno
$LN3@Mod_Headno:

; 727  : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_Headno
$LN2@Mod_Headno:

; 728  : 
; 729  : 	if( node->contents < 0 )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN4@Mod_Headno

; 730  : 	{
; 731  : 		if( !CHECKVISBIT( visbits, ((mleaf_t *)node)->cluster ))

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jl	SHORT $LN10@Mod_Headno
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	sar	ecx, 3
	mov	edx, DWORD PTR _visbits$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN11@Mod_Headno
$LN10@Mod_Headno:
	mov	DWORD PTR tv82[ebp], 0
$LN11@Mod_Headno:
	cmp	DWORD PTR tv82[ebp], 0
	jne	SHORT $LN5@Mod_Headno

; 732  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Mod_Headno
$LN5@Mod_Headno:

; 733  : 
; 734  : 		if( lastleaf )

	cmp	DWORD PTR _lastleaf$[ebp], 0
	je	SHORT $LN6@Mod_Headno

; 735  : 			*lastleaf = ((mleaf_t *)node)->cluster;

	mov	ecx, DWORD PTR _lastleaf$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx], eax
$LN6@Mod_Headno:

; 736  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Headno
$LN4@Mod_Headno:

; 737  : 	}
; 738  : 
; 739  : 	if( Mod_HeadnodeVisible( node->children[0], visbits, lastleaf ))

	mov	ecx, DWORD PTR _lastleaf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _visbits$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_Mod_HeadnodeVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@Mod_Headno

; 740  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Headno
$LN7@Mod_Headno:

; 741  : 
; 742  : 	if( Mod_HeadnodeVisible( node->children[1], visbits, lastleaf ))

	mov	ecx, DWORD PTR _lastleaf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _visbits$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_Mod_HeadnodeVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@Mod_Headno

; 743  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Headno
$LN8@Mod_Headno:

; 744  : 
; 745  : 	return false;

	xor	eax, eax
$LN1@Mod_Headno:

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_HeadnodeVisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_header$ = -16						; size = 4
tv79 = -12						; size = 4
_flags$ = -8						; size = 4
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_mod_base$ = 12						; size = 4
_silent$ = 16						; size = 4
_Mod_TestBmodelLumps PROC

; 2833 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2834 : 	dheader_t	*header = (dheader_t *)mod_base;

	mov	eax, DWORD PTR _mod_base$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 2835 : 	int	i, flags = LUMP_TESTONLY;

	mov	DWORD PTR _flags$[ebp], 2

; 2836 : 
; 2837 : 	// always reset the intermediate struct
; 2838 : 	memset( &loadstat, 0, sizeof( loadstat_t ));

	push	72					; 00000048H
	push	0
	push	OFFSET _loadstat
	call	_memset
	add	esp, 12					; 0000000cH

; 2839 : 
; 2840 : 	// store the name to correct show errors and warnings
; 2841 : 	Q_strncpy( loadstat.name, name, sizeof( loadstat.name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET _loadstat
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2842 : 	if( silent ) SetBits( flags, LUMP_SILENT );

	cmp	DWORD PTR _silent$[ebp], 0
	je	SHORT $LN10@Mod_TestBm
	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 4
	mov	DWORD PTR _flags$[ebp], edx
$LN10@Mod_TestBm:

; 2843 : 
; 2844 : #ifndef SUPPORT_BSP2_FORMAT
; 2845 : 	if( header->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 844124994		; 32505342H
	jne	SHORT $LN11@Mod_TestBm

; 2846 : 	{
; 2847 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN12@Mod_TestBm

; 2848 : 			Con_Printf( S_ERROR DEFAULT_BSP_BUILD_ERROR, name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG146668
	call	_Con_Printf
	add	esp, 8
$LN12@Mod_TestBm:

; 2849 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_TestBm
$LN11@Mod_TestBm:

; 2850 : 	}
; 2851 : #endif
; 2852 : 	switch( header->version )

	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 29			; 0000001dH
	jl	SHORT $LN14@Mod_TestBm
	cmp	DWORD PTR tv79[ebp], 30			; 0000001eH
	jle	SHORT $LN13@Mod_TestBm
	cmp	DWORD PTR tv79[ebp], 844124994		; 32505342H
	je	SHORT $LN13@Mod_TestBm
	jmp	SHORT $LN14@Mod_TestBm
$LN13@Mod_TestBm:

; 2853 : 	{
; 2854 : 	case Q1BSP_VERSION:
; 2855 : 	case HLBSP_VERSION:
; 2856 : 	case QBSP2_VERSION:
; 2857 : 		break;

	jmp	SHORT $LN2@Mod_TestBm
$LN14@Mod_TestBm:

; 2858 : 	default:
; 2859 : 		// don't early out: let me analyze errors
; 2860 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN15@Mod_TestBm

; 2861 : 			Con_Printf( S_ERROR "%s has wrong version number (%i should be %i)\n", name, header->version, HLBSP_VERSION );

	push	30					; 0000001eH
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG146672
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN15@Mod_TestBm:

; 2862 : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax
$LN2@Mod_TestBm:

; 2863 : 		break;
; 2864 : 	}
; 2865 : 
; 2866 : 	// loading base lumps
; 2867 : 	for( i = 0; i < ARRAYSIZE_XASH( srclumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_TestBm
$LN4@Mod_TestBm:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@Mod_TestBm:
	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	jae	SHORT $LN5@Mod_TestBm

; 2868 : 		Mod_LoadLump( mod_base, &srclumps[i], &worldstats[i], flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _worldstats
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 36
	add	ecx, OFFSET _srclumps
	push	ecx
	mov	edx, DWORD PTR _mod_base$[ebp]
	push	edx
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN4@Mod_TestBm
$LN5@Mod_TestBm:

; 2869 : 
; 2870 : 	// loading extralumps
; 2871 : 	for( i = 0; i < ARRAYSIZE_XASH( extlumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_TestBm
$LN7@Mod_TestBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Mod_TestBm:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jae	SHORT $LN8@Mod_TestBm

; 2872 : 		Mod_LoadLump( mod_base, &extlumps[i], &worldstats[ARRAYSIZE_XASH( srclumps ) + i], flags );

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 15					; 0000000fH
	shl	edx, 4
	add	edx, OFFSET _worldstats
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 36
	add	eax, OFFSET _extlumps
	push	eax
	mov	ecx, DWORD PTR _mod_base$[ebp]
	push	ecx
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN7@Mod_TestBm
$LN8@Mod_TestBm:

; 2873 : 
; 2874 : 	if( loadstat.numerrors )

	cmp	DWORD PTR _loadstat+64, 0
	je	SHORT $LN16@Mod_TestBm

; 2875 : 	{
; 2876 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN18@Mod_TestBm

; 2877 : 			Con_Printf( "Mod_LoadWorld: %i error(s), %i warning(s)\n", loadstat.numerrors, loadstat.numwarnings );

	mov	eax, DWORD PTR _loadstat+68
	push	eax
	mov	ecx, DWORD PTR _loadstat+64
	push	ecx
	push	OFFSET $SG146676
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN18@Mod_TestBm:

; 2878 : 		return false; // there were errors, we can't load this map

	xor	eax, eax
	jmp	SHORT $LN1@Mod_TestBm

; 2879 : 	}	

	jmp	SHORT $LN17@Mod_TestBm
$LN16@Mod_TestBm:

; 2880 : 	else if( loadstat.numwarnings )

	cmp	DWORD PTR _loadstat+68, 0
	je	SHORT $LN17@Mod_TestBm

; 2881 : 	{
; 2882 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN17@Mod_TestBm

; 2883 : 			Con_Printf( "Mod_LoadWorld: %i warning(s)\n", loadstat.numwarnings );

	mov	eax, DWORD PTR _loadstat+68
	push	eax
	push	OFFSET $SG146679
	call	_Con_Printf
	add	esp, 8
$LN17@Mod_TestBm:

; 2884 : 	}
; 2885 : 
; 2886 : 	return true;

	mov	eax, 1
$LN1@Mod_TestBm:

; 2887 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_TestBmodelLumps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\mod_bmodel.c
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_loaded$ = 16						; size = 4
_Mod_LoadBrushModel PROC

; 2895 : {

	push	ebp
	mov	ebp, esp

; 2896 : 	if( loaded ) *loaded = false;	

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN2@Mod_LoadBr
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Mod_LoadBr:

; 2897 : 
; 2898 : 	loadmodel->mempool = Mem_AllocPool( va( "^2%s^7", loadmodel->name ));

	push	2898					; 00000b52H
	push	OFFSET $SG146688
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET $SG146689
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+76], eax

; 2899 : 	loadmodel->type = mod_brush;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+68], 0

; 2900 : 
; 2901 : 	// loading all the lumps into heap
; 2902 : 	if( !Mod_LoadBmodelLumps( buffer, world.loading ))

	mov	ecx, DWORD PTR _world
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_Mod_LoadBmodelLumps
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@Mod_LoadBr

; 2903 : 		return; // there were errors

	jmp	SHORT $LN1@Mod_LoadBr
$LN3@Mod_LoadBr:

; 2904 : 
; 2905 : 	if( world.loading ) worldmodel = mod;

	cmp	DWORD PTR _world, 0
	je	SHORT $LN4@Mod_LoadBr
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _worldmodel, eax
$LN4@Mod_LoadBr:

; 2906 : 
; 2907 : 	if( loaded ) *loaded = true;	// all done

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN1@Mod_LoadBr
	mov	ecx, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [ecx], 1
$LN1@Mod_LoadBr:

; 2908 : }

	pop	ebp
	ret	0
_Mod_LoadBrushModel ENDP
_TEXT	ENDS
END
