; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\mod_studio.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

EXTRN	_Mod_Calloc:PROC
EXTRN	_Mod_CacheCheck:PROC
EXTRN	_Mod_LoadCacheFile:PROC
EXTRN	_Mod_StudioExtradata:PROC
PUBLIC	_Mod_InitStudioAPI
PUBLIC	_Mod_InitStudioHull
PUBLIC	_Mod_ResetStudioAPI
PUBLIC	_Mod_StudioTexName
PUBLIC	_Mod_GetStudioBounds
PUBLIC	_Mod_StudioGetAttachment
PUBLIC	_Mod_GetBonePosition
PUBLIC	_Mod_HullForStudio
PUBLIC	_Mod_StudioComputeBounds
PUBLIC	_Mod_HitgroupForStudioHull
PUBLIC	_Mod_ClearStudioCache
PUBLIC	_Mod_AddToStudioCache
PUBLIC	_Mod_CheckStudioCache
PUBLIC	_Mod_SetStudioHullPlane
PUBLIC	_Mod_StudioBoundVertex
PUBLIC	_Mod_StudioAccumulateBoneVerts
PUBLIC	_R_StudioLoadHeader
PUBLIC	_Mod_LoadStudioModel
PUBLIC	_Mod_UnloadStudioModel
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fb40000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@bc23d70a
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_fabs:PROC
EXTRN	_RoundUpHullSize:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_Matrix3x4_ConcatTransforms:PROC
EXTRN	_Matrix3x4_FromOriginQuat:PROC
EXTRN	_Matrix3x4_CreateFromEntity:PROC
EXTRN	_Matrix3x4_SetOrigin:PROC
EXTRN	_Matrix3x4_OriginFromMatrix:PROC
EXTRN	_Matrix3x4_AnglesFromMatrix:PROC
EXTRN	_R_StudioSlerpBones:PROC
EXTRN	_R_StudioCalcBoneQuaternion:PROC
EXTRN	_R_StudioCalcBonePosition:PROC
EXTRN	_R_StudioGetAnim:PROC
EXTRN	_Mod_StudioLoadTextures:PROC
EXTRN	_Mod_StudioUnloadTextures:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_matrix3x4_identity:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_mod_studiocache:DWORD
EXTRN	_svgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_pBlendAPI DD	01H DUP (?)
_mod_studiohdr DD 01H DUP (?)
_studio_transform DD 0cH DUP (?)
_cache_hull DB	01400H DUP (?)
_studio_hull DB	01400H DUP (?)
_studio_bones DD 0600H DUP (?)
_studio_hull_hitgroup DD 080H DUP (?)
_cache_hull_hitgroup DD 080H DUP (?)
_cache_studio DB 0440H DUP (?)
_studio_clipnodes DQ 06H DUP (?)
_studio_planes DB 03c00H DUP (?)
_cache_planes DB 03c00H DUP (?)
_cache_current DD 01H DUP (?)
_cache_current_hull DD 01H DUP (?)
_cache_current_plane DD 01H DUP (?)
?pos@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos
?q@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q
?pos2@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos2
?q2@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q2
?pos3@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos3
?q3@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q3
?pos4@?1??SV_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `SV_StudioSetupBones'::`2'::pos4
?q4@?1??SV_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `SV_StudioSetupBones'::`2'::q4
?texname@?1??Mod_StudioTexName@@9@9 DB 040H DUP (?)	; `Mod_StudioTexName'::`2'::texname
?pBlendIface@?1??Mod_InitStudioAPI@@9@9 DD 01H DUP (?)	; `Mod_InitStudioAPI'::`2'::pBlendIface
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bc23d70a
CONST	SEGMENT
__real@bc23d70a DD 0bc23d70ar			; -0.01
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG136877 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137005 DB	'^3Warning:^7 SV_StudioSetupBones: sequence %i/%i out of '
	DB	'range for model %s', 0aH, 00H
$SG137164 DB	'models', 00H
	ORG $+1
$SG137165 DB	'.mdl', 00H
	ORG $+7
$SG137168 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137174 DB	'T.mdl', 00H
	ORG $+2
$SG137206 DB	'^1Error:^7 %s has wrong version number (%i should be %i)'
	DB	0aH, 00H
	ORG $+6
$SG137232 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137233 DB	'^2%s^7', 00H
	ORG $+1
$SG137239 DB	'^3Warning:^7 Mod_LoadStudioModel: %s missing textures fi'
	DB	'le', 0aH, 00H
	ORG $+4
$SG137241 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137242 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137243 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137244 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137245 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137259 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
$SG137260 DB	'mod != NULL', 00H
	ORG $+4
$SG137262 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\mod_studio.c', 00H
	ORG $+2
_gBlendAPI DD	01H
	DD	FLAT:_SV_StudioSetupBones
_gStudioAPI DD	FLAT:_Mod_Calloc
	DD	FLAT:_Mod_CacheCheck
	DD	FLAT:_Mod_LoadCacheFile
	DD	FLAT:_Mod_StudioExtradata
$SG137270 DB	'Server_GetBlendingInterface', 00H
	ORG $+4
$SG137272 DB	'SV_LoadProgs: ^2initailized Server Blending interface ^7'
	DB	'ver. %i', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_mod$ = 8						; size = 4
_Mod_UnloadStudioModel PROC

; 893  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 894  : 	Assert( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN4@Mod_Unload
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN5@Mod_Unload
$LN4@Mod_Unload:
	mov	DWORD PTR tv69[ebp], 0
$LN5@Mod_Unload:
	push	0
	push	894					; 0000037eH
	push	OFFSET $SG137259
	push	OFFSET $SG137260
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 895  : 
; 896  : 	if( mod->type != mod_studio )

	mov	ecx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $LN2@Mod_Unload

; 897  : 		return; // not a studio

	jmp	SHORT $LN1@Mod_Unload
$LN2@Mod_Unload:

; 898  : 
; 899  : 	Mod_StudioUnloadTextures( mod->cache.data );

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+388]
	push	eax
	call	_Mod_StudioUnloadTextures
	add	esp, 4

; 900  : 	Mem_FreePool( &mod->mempool );

	push	900					; 00000384H
	push	OFFSET $SG137262
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 901  : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Mod_Unload:

; 902  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_UnloadStudioModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_out$1 = -28						; size = 4
_in$2 = -24						; size = 4
_size2$3 = -20						; size = 4
_size1$4 = -16						; size = 4
_buffer2$5 = -12					; size = 4
_thdr$6 = -8						; size = 4
_phdr$ = -4						; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_loaded$ = 16						; size = 4
_Mod_LoadStudioModel PROC

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 798  : 	studiohdr_t	*phdr;
; 799  : 
; 800  : 	if( loaded ) *loaded = false;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN2@Mod_LoadSt
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Mod_LoadSt:

; 801  : 	loadmodel->mempool = Mem_AllocPool( va( "^2%s^7", loadmodel->name ));

	push	801					; 00000321H
	push	OFFSET $SG137232
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET $SG137233
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+76], eax

; 802  : 	loadmodel->type = mod_studio;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+68], 3

; 803  : 
; 804  : 	phdr = R_StudioLoadHeader( mod, buffer );

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_R_StudioLoadHeader
	add	esp, 8
	mov	DWORD PTR _phdr$[ebp], eax

; 805  : 	if( !phdr ) return;	// bad model

	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $LN3@Mod_LoadSt
	jmp	$LN15@Mod_LoadSt
$LN3@Mod_LoadSt:

; 806  : 
; 807  : 	if( phdr->numtextures == 0 )

	mov	eax, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [eax+180], 0
	jne	$LN4@Mod_LoadSt

; 808  : 	{
; 809  : 		studiohdr_t	*thdr;
; 810  : 		byte		*in, *out;
; 811  : 		void		*buffer2 = NULL;

	mov	DWORD PTR _buffer2$5[ebp], 0

; 812  : 		size_t		size1, size2;
; 813  : 
; 814  : 		buffer2 = FS_LoadFile( Mod_StudioTexName( mod->name ), NULL, false );

	push	0
	push	0
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_StudioTexName
	add	esp, 4
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer2$5[ebp], eax

; 815  : 		thdr = R_StudioLoadHeader( mod, buffer2 );

	mov	edx, DWORD PTR _buffer2$5[ebp]
	push	edx
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_R_StudioLoadHeader
	add	esp, 8
	mov	DWORD PTR _thdr$6[ebp], eax

; 816  : 
; 817  : 		if( !thdr )

	cmp	DWORD PTR _thdr$6[ebp], 0
	jne	SHORT $LN6@Mod_LoadSt

; 818  : 		{
; 819  : 			Con_Printf( S_WARN "Mod_LoadStudioModel: %s missing textures file\n", mod->name ); 

	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET $SG137239
	call	_Con_Printf
	add	esp, 8

; 820  : 			if( buffer2 ) Mem_Free( buffer2 );

	cmp	DWORD PTR _buffer2$5[ebp], 0
	je	SHORT $LN8@Mod_LoadSt
	push	820					; 00000334H
	push	OFFSET $SG137241
	mov	edx, DWORD PTR _buffer2$5[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@Mod_LoadSt:

; 821  : 		}

	jmp	$LN7@Mod_LoadSt
$LN6@Mod_LoadSt:

; 822  :                     else
; 823  :                     {
; 824  : 			Mod_StudioLoadTextures( mod, thdr );

	mov	eax, DWORD PTR _thdr$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_StudioLoadTextures
	add	esp, 8

; 825  : 
; 826  : 			// give space for textures and skinrefs
; 827  : 			size1 = thdr->numtextures * sizeof( mstudiotexture_t );

	mov	edx, DWORD PTR _thdr$6[ebp]
	imul	eax, DWORD PTR [edx+180], 80
	mov	DWORD PTR _size1$4[ebp], eax

; 828  : 			size2 = thdr->numskinfamilies * thdr->numskinref * sizeof( short );

	mov	ecx, DWORD PTR _thdr$6[ebp]
	mov	edx, DWORD PTR _thdr$6[ebp]
	mov	eax, DWORD PTR [ecx+196]
	imul	eax, DWORD PTR [edx+192]
	shl	eax, 1
	mov	DWORD PTR _size2$3[ebp], eax

; 829  : 			mod->cache.data = Mem_Calloc( loadmodel->mempool, phdr->length + size1 + size2 );

	push	829					; 0000033dH
	push	OFFSET $SG137242
	push	1
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	add	edx, DWORD PTR _size1$4[ebp]
	add	edx, DWORD PTR _size2$3[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+388], eax

; 830  : 			memcpy( loadmodel->cache.data, buffer, phdr->length ); // copy main mdl buffer

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 831  : 			phdr = (studiohdr_t *)loadmodel->cache.data; // get the new pointer on studiohdr

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR _phdr$[ebp], eax

; 832  : 			phdr->numskinfamilies = thdr->numskinfamilies;

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _thdr$6[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [ecx+196], eax

; 833  : 			phdr->numtextures = thdr->numtextures;

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _thdr$6[ebp]
	mov	eax, DWORD PTR [edx+180]
	mov	DWORD PTR [ecx+180], eax

; 834  : 			phdr->numskinref = thdr->numskinref;

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _thdr$6[ebp]
	mov	eax, DWORD PTR [edx+192]
	mov	DWORD PTR [ecx+192], eax

; 835  : 			phdr->textureindex = phdr->length;

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx+184], eax

; 836  : 			phdr->skinindex = phdr->textureindex + size1;

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	add	edx, DWORD PTR _size1$4[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	DWORD PTR [eax+200], edx

; 837  : 
; 838  : 			in = (byte *)thdr + thdr->textureindex;

	mov	ecx, DWORD PTR _thdr$6[ebp]
	mov	edx, DWORD PTR _thdr$6[ebp]
	add	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR _in$2[ebp], edx

; 839  : 			out = (byte *)phdr + phdr->textureindex;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _out$1[ebp], ecx

; 840  : 			memcpy( out, in, size1 + size2 );	// copy textures + skinrefs

	mov	edx, DWORD PTR _size1$4[ebp]
	add	edx, DWORD PTR _size2$3[ebp]
	push	edx
	mov	eax, DWORD PTR _in$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$1[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 841  : 			phdr->length += size1 + size2;

	mov	edx, DWORD PTR _size1$4[ebp]
	add	edx, DWORD PTR _size2$3[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 842  : 			Mem_Free( buffer2 ); // release T.mdl

	push	842					; 0000034aH
	push	OFFSET $SG137243
	mov	edx, DWORD PTR _buffer2$5[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@Mod_LoadSt:

; 843  : 		}
; 844  : 	}

	jmp	$LN5@Mod_LoadSt
$LN4@Mod_LoadSt:

; 845  : 	else
; 846  : 	{
; 847  : 		// NOTE: don't modify source buffer because it's used for CRC computing
; 848  : 		loadmodel->cache.data = Mem_Calloc( loadmodel->mempool, phdr->length );

	push	848					; 00000350H
	push	OFFSET $SG137244
	push	1
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+388], eax

; 849  : 		memcpy( loadmodel->cache.data, buffer, phdr->length );

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+388]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 850  : 		phdr = (studiohdr_t *)loadmodel->cache.data; // get the new pointer on studiohdr

	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR _phdr$[ebp], edx

; 851  : 		Mod_StudioLoadTextures( mod, phdr );

	mov	eax, DWORD PTR _phdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_StudioLoadTextures
	add	esp, 8

; 852  : 
; 853  : 		// NOTE: we wan't keep raw textures in memory. just cutoff model pointer above texture base
; 854  : 		loadmodel->cache.data = Mem_Realloc( loadmodel->mempool, loadmodel->cache.data, phdr->texturedataindex );

	push	854					; 00000356H
	push	OFFSET $SG137245
	push	1
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [edx+188]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+388]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+388], eax

; 855  : 		phdr = (studiohdr_t *)loadmodel->cache.data; // get the new pointer on studiohdr

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _phdr$[ebp], ecx

; 856  : 		phdr->length = phdr->texturedataindex;	// update model size

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR [edx+72], ecx
$LN5@Mod_LoadSt:

; 857  : 	}
; 858  : 
; 859  : 	// setup bounding box
; 860  : 	if( !VectorCompare( vec3_origin, phdr->bbmin ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [ecx+edx+112]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_LoadSt
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[edx]
	ucomiss	xmm0, DWORD PTR [ecx+eax+112]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_LoadSt
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[edx]
	ucomiss	xmm0, DWORD PTR [ecx+eax+112]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN9@Mod_LoadSt
$LN11@Mod_LoadSt:

; 861  : 	{
; 862  : 		// clipping bounding box
; 863  : 		VectorCopy( phdr->bbmin, loadmodel->mins );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+112]
	mov	DWORD PTR [ecx+edx+84], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+112]
	mov	DWORD PTR [eax+edx+84], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+112]
	mov	DWORD PTR [ecx+eax+84], edx

; 864  : 		VectorCopy( phdr->bbmax, loadmodel->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+124]
	mov	DWORD PTR [edx+eax+96], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+124]
	mov	DWORD PTR [ecx+eax+96], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+124]
	mov	DWORD PTR [edx+ecx+96], eax

; 865  : 	}

	jmp	$LN13@Mod_LoadSt
$LN9@Mod_LoadSt:

; 866  : 	else if( !VectorCompare( vec3_origin, phdr->min ))

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[edx]
	ucomiss	xmm0, DWORD PTR [eax+ecx+88]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@Mod_LoadSt
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[ecx]
	ucomiss	xmm0, DWORD PTR [eax+edx+88]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@Mod_LoadSt
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _phdr$[ebp]
	movss	xmm0, DWORD PTR _vec3_origin[ecx]
	ucomiss	xmm0, DWORD PTR [eax+edx+88]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN12@Mod_LoadSt
$LN14@Mod_LoadSt:

; 867  : 	{
; 868  : 		// movement bounding box
; 869  : 		VectorCopy( phdr->min, loadmodel->mins );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+88]
	mov	DWORD PTR [eax+ecx+84], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+88]
	mov	DWORD PTR [edx+ecx+84], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+88]
	mov	DWORD PTR [eax+edx+84], ecx

; 870  : 		VectorCopy( phdr->max, loadmodel->maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [esi+eax+100]
	mov	DWORD PTR [ecx+edx+96], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+100]
	mov	DWORD PTR [eax+edx+96], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _loadmodel
	mov	esi, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR [esi+edx+100]
	mov	DWORD PTR [ecx+eax+96], edx

; 871  : 	}

	jmp	SHORT $LN13@Mod_LoadSt
$LN12@Mod_LoadSt:

; 872  : 	else
; 873  : 	{
; 874  : 		// well compute bounds from vertices and round to nearest even values
; 875  : 		Mod_StudioComputeBounds( phdr, loadmodel->mins, loadmodel->maxs, true );

	push	1
	mov	eax, DWORD PTR _loadmodel
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _phdr$[ebp]
	push	edx
	call	_Mod_StudioComputeBounds
	add	esp, 16					; 00000010H

; 876  : 		RoundUpHullSize( loadmodel->mins );

	mov	eax, DWORD PTR _loadmodel
	add	eax, 84					; 00000054H
	push	eax
	call	_RoundUpHullSize
	add	esp, 4

; 877  : 		RoundUpHullSize( loadmodel->maxs );

	mov	ecx, DWORD PTR _loadmodel
	add	ecx, 96					; 00000060H
	push	ecx
	call	_RoundUpHullSize
	add	esp, 4
$LN13@Mod_LoadSt:

; 878  : 	}
; 879  : 
; 880  : 	loadmodel->numframes = Mod_StudioBodyVariations( loadmodel );

	mov	edx, DWORD PTR _loadmodel
	push	edx
	call	_Mod_StudioBodyVariations
	add	esp, 4
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+72], eax

; 881  : 	loadmodel->radius = RadiusFromBounds( loadmodel->mins, loadmodel->maxs );

	mov	edx, DWORD PTR _loadmodel
	add	edx, 96					; 00000060H
	push	edx
	mov	eax, DWORD PTR _loadmodel
	add	eax, 84					; 00000054H
	push	eax
	call	_RadiusFromBounds
	add	esp, 8
	mov	ecx, DWORD PTR _loadmodel
	fstp	DWORD PTR [ecx+108]

; 882  : 	loadmodel->flags = phdr->flags; // copy header flags

	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR [edx+80], ecx

; 883  : 
; 884  : 	if( loaded ) *loaded = true;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN15@Mod_LoadSt
	mov	edx, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [edx], 1
$LN15@Mod_LoadSt:

; 885  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadStudioModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_phdr$ = -12						; size = 4
_pin$ = -8						; size = 4
_i$ = -4						; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_R_StudioLoadHeader PROC

; 771  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 772  : 	byte		*pin;
; 773  : 	studiohdr_t	*phdr;
; 774  : 	int		i;
; 775  : 
; 776  : 	if( !buffer ) return NULL;

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@R_StudioLo
	xor	eax, eax
	jmp	SHORT $LN1@R_StudioLo
$LN2@R_StudioLo:

; 777  : 
; 778  : 	pin = (byte *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pin$[ebp], eax

; 779  : 	phdr = (studiohdr_t *)pin;

	mov	ecx, DWORD PTR _pin$[ebp]
	mov	DWORD PTR _phdr$[ebp], ecx

; 780  : 	i = phdr->version;

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _i$[ebp], eax

; 781  : 
; 782  : 	if( i != STUDIO_VERSION )

	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	je	SHORT $LN3@R_StudioLo

; 783  : 	{
; 784  : 		Con_Printf( S_ERROR "%s has wrong version number (%i should be %i)\n", mod->name, i, STUDIO_VERSION );

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	push	OFFSET $SG137206
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 785  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@R_StudioLo
$LN3@R_StudioLo:

; 786  : 	}	
; 787  : 
; 788  : 	return (studiohdr_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
$LN1@R_StudioLo:

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioLoadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_pbodypart$ = -16					; size = 4
_count$ = -12						; size = 4
_i$ = -8						; size = 4
_pstudiohdr$ = -4					; size = 4
_mod$ = 8						; size = 4
_Mod_StudioBodyVariations PROC

; 747  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 748  : 	studiohdr_t	*pstudiohdr;
; 749  : 	mstudiobodyparts_t	*pbodypart;
; 750  : 	int		i, count = 1;

	mov	DWORD PTR _count$[ebp], 1

; 751  : 
; 752  : 	pstudiohdr = (studiohdr_t *)Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _pstudiohdr$[ebp], eax

; 753  : 	if( !pstudiohdr ) return 0;

	cmp	DWORD PTR _pstudiohdr$[ebp], 0
	jne	SHORT $LN5@Mod_Studio
	xor	eax, eax
	jmp	SHORT $LN1@Mod_Studio
$LN5@Mod_Studio:

; 754  : 
; 755  : 	pbodypart = (mstudiobodyparts_t *)((byte *)pstudiohdr + pstudiohdr->bodypartindex);

	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	mov	edx, DWORD PTR _pstudiohdr$[ebp]
	add	edx, DWORD PTR [ecx+208]
	mov	DWORD PTR _pbodypart$[ebp], edx

; 756  : 
; 757  : 	// each body part has nummodels variations so there are as many total variations as there
; 758  : 	// are in a matrix of each part by each other part
; 759  : 	for( i = 0; i < pstudiohdr->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Studio:
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+204]
	jge	SHORT $LN3@Mod_Studio

; 760  : 		count = count * pbodypart[i].nummodels;

	imul	eax, DWORD PTR _i$[ebp], 76
	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR _count$[ebp]
	imul	edx, DWORD PTR [ecx+eax+64]
	mov	DWORD PTR _count$[ebp], edx
	jmp	SHORT $LN2@Mod_Studio
$LN3@Mod_Studio:

; 761  : 
; 762  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@Mod_Studio:

; 763  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioBodyVariations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
tv132 = -36						; size = 4
tv85 = -32						; size = 4
_point$ = -28						; size = 12
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_numverts$ = 16						; size = 4
_bone_mins$ = 20					; size = 4
_bone_maxs$ = 24					; size = 4
_numbones$ = 28						; size = 4
_Mod_StudioAccumulateBoneVerts PROC

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 600  : 	vec3_t	delta;
; 601  : 	vec3_t	point;
; 602  : 
; 603  : 	if( *numbones <= 0 )

	mov	eax, DWORD PTR _numbones$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN2@Mod_Studio

; 604  : 		return;

	jmp	$LN1@Mod_Studio
$LN2@Mod_Studio:

; 605  : 
; 606  : 	// calculate the midpoint of the second vertex,
; 607  : 	VectorSubtract( bone_maxs, bone_mins, delta );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _bone_maxs$[ebp]
	mov	esi, DWORD PTR _bone_mins$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _bone_maxs$[ebp]
	mov	esi, DWORD PTR _bone_mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _bone_maxs$[ebp]
	mov	esi, DWORD PTR _bone_mins$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx]
	movss	DWORD PTR tv85[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv85[ebp]
	movss	DWORD PTR _delta$[ebp+ecx], xmm0

; 608  : 
; 609  : 	VectorScale( delta, 0.5f, point );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _delta$[ebp+edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv132[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 610  : 	Mod_StudioBoundVertex( mins, maxs, numverts, point );

	lea	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _numverts$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_Mod_StudioBoundVertex
	add	esp, 16					; 00000010H

; 611  : 
; 612  : 	VectorClear( bone_mins );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _bone_mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _bone_mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _bone_mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0

; 613  : 	VectorClear( bone_maxs );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bone_maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _bone_maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _bone_maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 614  : 	*numbones = 0;

	mov	ecx, DWORD PTR _numbones$[ebp]
	mov	DWORD PTR [ecx], 0
$LN1@Mod_Studio:

; 615  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioAccumulateBoneVerts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_numverts$ = 16						; size = 4
_vertex$ = 20						; size = 4
_Mod_StudioBoundVertex PROC

; 585  : {

	push	ebp
	mov	ebp, esp

; 586  : 	if((*numverts) == 0 )

	mov	eax, DWORD PTR _numverts$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@Mod_Studio

; 587  : 		ClearBounds( mins, maxs );

	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	_ClearBounds
	add	esp, 8
$LN2@Mod_Studio:

; 588  : 
; 589  : 	AddPointToBounds( vertex, mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vertex$[ebp]
	push	edx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 590  : 	(*numverts)++;

	mov	eax, DWORD PTR _numverts$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _numverts$[ebp]
	mov	DWORD PTR [edx], ecx

; 591  : }

	pop	ebp
	ret	0
_Mod_StudioBoundVertex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_pbones$ = -596						; size = 4
_j$ = -592						; size = 4
_s$1 = -588						; size = 4
_f$ = -584						; size = 4
_pseqdesc$ = -580					; size = 4
_numbones$ = -576					; size = 4
_panim$ = -572						; size = 4
_i$ = -568						; size = 4
_boneused$ = -564					; size = 512
_bonematrix$ = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_pModel$ = 8						; size = 4
_frame$ = 12						; size = 4
_sequence$ = 16						; size = 4
_angles$ = 20						; size = 4
_origin$ = 24						; size = 4
_pcontroller$ = 28					; size = 4
_pblending$ = 32					; size = 4
_iBone$ = 36						; size = 4
_pEdict$ = 40						; size = 4
_SV_StudioSetupBones PROC

; 408  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 409  : 	int		i, j, numbones = 0;

	mov	DWORD PTR _numbones$[ebp], 0

; 410  : 	int		boneused[MAXSTUDIOBONES];
; 411  : 	float		f = 0.0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 412  : 
; 413  : 	mstudiobone_t	*pbones;
; 414  : 	mstudioseqdesc_t	*pseqdesc;
; 415  : 	mstudioanim_t	*panim;
; 416  : 
; 417  : 	static float	pos[MAXSTUDIOBONES][3];
; 418  : 	static vec4_t	q[MAXSTUDIOBONES];
; 419  : 	matrix3x4		bonematrix;
; 420  : 
; 421  : 	static float	pos2[MAXSTUDIOBONES][3];
; 422  : 	static vec4_t	q2[MAXSTUDIOBONES];
; 423  : 	static float	pos3[MAXSTUDIOBONES][3];
; 424  : 	static vec4_t	q3[MAXSTUDIOBONES];
; 425  : 	static float	pos4[MAXSTUDIOBONES][3];
; 426  : 	static vec4_t	q4[MAXSTUDIOBONES];
; 427  : 
; 428  : 	if( sequence < 0 || sequence >= mod_studiohdr->numseq )

	cmp	DWORD PTR _sequence$[ebp], 0
	jl	SHORT $LN12@SV_StudioS
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+164]
	jl	SHORT $LN11@SV_StudioS
$LN12@SV_StudioS:

; 429  : 	{
; 430  : 		// only show warn if sequence that out of range was specified intentionally
; 431  : 		if( sequence > mod_studiohdr->numseq )

	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR _sequence$[ebp]
	cmp	eax, DWORD PTR [edx+164]
	jle	SHORT $LN13@SV_StudioS

; 432  : 			Con_Reportf( S_WARN "SV_StudioSetupBones: sequence %i/%i out of range for model %s\n", sequence, mod_studiohdr->numseq, pModel->name );

	mov	ecx, DWORD PTR _pModel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR [edx+164]
	push	eax
	mov	ecx, DWORD PTR _sequence$[ebp]
	push	ecx
	push	OFFSET $SG137005
	call	_Con_Reportf
	add	esp, 16					; 00000010H
$LN13@SV_StudioS:

; 433  : 		sequence = 0;

	mov	DWORD PTR _sequence$[ebp], 0
$LN11@SV_StudioS:

; 434  : 	}
; 435  : 
; 436  : 	pseqdesc = (mstudioseqdesc_t *)((byte *)mod_studiohdr + mod_studiohdr->seqindex) + sequence;

	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR _mod_studiohdr
	add	eax, DWORD PTR [edx+168]
	imul	ecx, DWORD PTR _sequence$[ebp], 176
	add	eax, ecx
	mov	DWORD PTR _pseqdesc$[ebp], eax

; 437  : 	pbones = (mstudiobone_t *)((byte *)mod_studiohdr + mod_studiohdr->boneindex);

	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR _mod_studiohdr
	add	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _pbones$[ebp], eax

; 438  : 	panim = R_StudioGetAnim( mod_studiohdr, pModel, pseqdesc );

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pModel$[ebp]
	push	edx
	mov	eax, DWORD PTR _mod_studiohdr
	push	eax
	call	_R_StudioGetAnim
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], eax

; 439  : 
; 440  : 	if( iBone < -1 || iBone >= mod_studiohdr->numbones )

	cmp	DWORD PTR _iBone$[ebp], -1
	jl	SHORT $LN15@SV_StudioS
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR _iBone$[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jl	SHORT $LN14@SV_StudioS
$LN15@SV_StudioS:

; 441  : 		iBone = 0;

	mov	DWORD PTR _iBone$[ebp], 0
$LN14@SV_StudioS:

; 442  : 
; 443  : 	if( iBone == -1 )

	cmp	DWORD PTR _iBone$[ebp], -1
	jne	SHORT $LN16@SV_StudioS

; 444  : 	{
; 445  : 		numbones = mod_studiohdr->numbones;

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _numbones$[ebp], ecx

; 446  : 		for( i = 0; i < mod_studiohdr->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_StudioS
$LN2@SV_StudioS:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_StudioS:
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN3@SV_StudioS

; 447  : 			boneused[(numbones - i) - 1] = i;

	mov	edx, DWORD PTR _numbones$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _boneused$[ebp+edx*4-4], eax
	jmp	SHORT $LN2@SV_StudioS
$LN3@SV_StudioS:

; 448  : 	}

	jmp	SHORT $LN6@SV_StudioS
$LN16@SV_StudioS:

; 449  : 	else
; 450  : 	{
; 451  : 		// only the parent bones
; 452  : 		for( i = iBone; i != -1; i = pbones[i].parent )

	mov	ecx, DWORD PTR _iBone$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN7@SV_StudioS
$LN5@SV_StudioS:
	imul	edx, DWORD PTR _i$[ebp], 112
	mov	eax, DWORD PTR _pbones$[ebp]
	mov	ecx, DWORD PTR [eax+edx+32]
	mov	DWORD PTR _i$[ebp], ecx
$LN7@SV_StudioS:
	cmp	DWORD PTR _i$[ebp], -1
	je	SHORT $LN6@SV_StudioS

; 453  : 			boneused[numbones++] = i;

	mov	edx, DWORD PTR _numbones$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _boneused$[ebp+edx*4], eax
	mov	ecx, DWORD PTR _numbones$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numbones$[ebp], ecx
	jmp	SHORT $LN5@SV_StudioS
$LN6@SV_StudioS:

; 454  : 	}
; 455  : 
; 456  : 	if( pseqdesc->numframes > 1 )

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [edx+56], 1
	jle	SHORT $LN18@SV_StudioS

; 457  : 		f = ( frame * ( pseqdesc->numframes - 1 )) / 256.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _frame$[ebp]
	divss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR _f$[ebp], xmm0
$LN18@SV_StudioS:

; 458  : 
; 459  : 	Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos, q, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _panim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	push	OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	mov	ecx, DWORD PTR _pcontroller$[ebp]
	push	ecx
	mov	edx, DWORD PTR _numbones$[ebp]
	push	edx
	lea	eax, DWORD PTR _boneused$[ebp]
	push	eax
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 460  : 
; 461  : 	if( pseqdesc->numblends > 1 )

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [ecx+120], 1
	jle	$LN20@SV_StudioS

; 462  : 	{
; 463  : 		float	s;
; 464  : 
; 465  : 		panim += mod_studiohdr->numbones;

	mov	edx, DWORD PTR _mod_studiohdr
	imul	eax, DWORD PTR [edx+140], 12
	add	eax, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], eax

; 466  : 		Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos2, q2, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q2@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos2@?1??SV_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _pcontroller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numbones$[ebp]
	push	ecx
	lea	edx, DWORD PTR _boneused$[ebp]
	push	edx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 467  : 
; 468  : 		s = (float)pblending[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pblending$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$1[ebp], xmm0

; 469  : 
; 470  : 		R_StudioSlerpBones( mod_studiohdr->numbones, q, pos, q2, pos2, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos2@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q2@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 471  : 
; 472  : 		if( pseqdesc->numblends == 4 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 4
	jne	$LN20@SV_StudioS

; 473  : 		{
; 474  : 			panim += mod_studiohdr->numbones;

	mov	ecx, DWORD PTR _mod_studiohdr
	imul	edx, DWORD PTR [ecx+140], 12
	add	edx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], edx

; 475  : 			Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos3, q3, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??SV_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _numbones$[ebp]
	push	eax
	lea	ecx, DWORD PTR _boneused$[ebp]
	push	ecx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 476  : 
; 477  : 			panim += mod_studiohdr->numbones;

	mov	edx, DWORD PTR _mod_studiohdr
	imul	eax, DWORD PTR [edx+140], 12
	add	eax, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], eax

; 478  : 			Mod_StudioCalcRotations( boneused, numbones, pcontroller, pos4, q4, pseqdesc, panim, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q4@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos4@?1??SV_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _pcontroller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numbones$[ebp]
	push	ecx
	lea	edx, DWORD PTR _boneused$[ebp]
	push	edx
	call	_Mod_StudioCalcRotations
	add	esp, 32					; 00000020H

; 479  : 
; 480  : 			s = (float)pblending[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pblending$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$1[ebp], xmm0

; 481  : 			R_StudioSlerpBones( mod_studiohdr->numbones, q3, pos3, q4, pos4, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos4@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q4@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??SV_StudioSetupBones@@9@9
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 482  : 
; 483  : 			s = (float)pblending[1] / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pblending$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$1[ebp], xmm0

; 484  : 			R_StudioSlerpBones( mod_studiohdr->numbones, q, pos, q3, pos3, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H
$LN20@SV_StudioS:

; 485  : 		}
; 486  : 	}
; 487  : 
; 488  : 	Matrix3x4_CreateFromEntity( studio_transform, angles, origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	push	OFFSET _studio_transform
	call	_Matrix3x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 489  : 
; 490  : 	for( j = numbones - 1; j >= 0; j-- )

	mov	ecx, DWORD PTR _numbones$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN10@SV_StudioS
$LN8@SV_StudioS:
	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN10@SV_StudioS:
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN9@SV_StudioS

; 491  : 	{
; 492  : 		i = boneused[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _boneused$[ebp+eax*4]
	mov	DWORD PTR _i$[ebp], ecx

; 493  : 
; 494  : 		Matrix3x4_FromOriginQuat( bonematrix, q[i], pos[i] );

	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, OFFSET ?pos@?1??SV_StudioSetupBones@@9@9
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET ?q@?1??SV_StudioSetupBones@@9@9
	push	eax
	lea	ecx, DWORD PTR _bonematrix$[ebp]
	push	ecx
	call	_Matrix3x4_FromOriginQuat
	add	esp, 12					; 0000000cH

; 495  : 		if( pbones[i].parent == -1 ) 

	imul	edx, DWORD PTR _i$[ebp], 112
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	jne	SHORT $LN21@SV_StudioS

; 496  : 			Matrix3x4_ConcatTransforms( studio_bones[i], studio_transform, bonematrix );

	lea	ecx, DWORD PTR _bonematrix$[ebp]
	push	ecx
	push	OFFSET _studio_transform
	imul	edx, DWORD PTR _i$[ebp], 48
	add	edx, OFFSET _studio_bones
	push	edx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@SV_StudioS
$LN21@SV_StudioS:

; 497  : 		else Matrix3x4_ConcatTransforms( studio_bones[i], studio_bones[pbones[i].parent], bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _studio_bones
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _studio_bones
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
$LN22@SV_StudioS:

; 498  : 	}

	jmp	$LN8@SV_StudioS
$LN9@SV_StudioS:

; 499  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StudioSetupBones ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_s$ = -56						; size = 4
_pbone$ = -52						; size = 4
_frame$ = -48						; size = 4
_j$ = -44						; size = 4
_i$ = -40						; size = 4
_adj$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_boneused$ = 8						; size = 4
_numbones$ = 12						; size = 4
_pcontroller$ = 16					; size = 4
_pos$ = 20						; size = 4
_q$ = 24						; size = 4
_pseqdesc$ = 28						; size = 4
_panim$ = 32						; size = 4
_f$ = 36						; size = 4
_Mod_StudioCalcRotations PROC

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 361  : 	int		i, j, frame;
; 362  : 	mstudiobone_t	*pbone;
; 363  : 	float		adj[MAXSTUDIOCONTROLLERS];
; 364  : 	float		s;
; 365  : 
; 366  : 	// bah, fix this bug with changing sequences too fast
; 367  : 	if( f > pseqdesc->numframes - 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _f$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@Mod_Studio

; 368  : 	{
; 369  : 		f = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 370  : 	}

	jmp	SHORT $LN7@Mod_Studio
$LN5@Mod_Studio:

; 371  : 	else if( f < -0.01f )

	movss	xmm0, DWORD PTR __real@bc23d70a
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN7@Mod_Studio

; 372  : 	{
; 373  : 		// BUG ( somewhere else ) but this code should validate this data.
; 374  : 		// This could cause a crash if the frame # is negative, so we'll go ahead
; 375  : 		// and clamp it here
; 376  : 		f = -0.01f;

	movss	xmm0, DWORD PTR __real@bc23d70a
	movss	DWORD PTR _f$[ebp], xmm0
$LN7@Mod_Studio:

; 377  : 	}
; 378  : 
; 379  : 	frame = (int)f;

	cvttss2si edx, DWORD PTR _f$[ebp]
	mov	DWORD PTR _frame$[ebp], edx

; 380  : 	s = (f - frame);

	cvtsi2ss xmm0, DWORD PTR _frame$[ebp]
	movss	xmm1, DWORD PTR _f$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 381  : 
; 382  : 	// add in programtic controllers
; 383  : 	pbone = (mstudiobone_t *)((byte *)mod_studiohdr + mod_studiohdr->boneindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbone$[ebp], ecx

; 384  : 
; 385  : 	Mod_StudioCalcBoneAdj( adj, pcontroller );

	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	lea	eax, DWORD PTR _adj$[ebp]
	push	eax
	call	_Mod_StudioCalcBoneAdj
	add	esp, 8

; 386  : 
; 387  : 	for( j = numbones - 1; j >= 0; j-- )

	mov	ecx, DWORD PTR _numbones$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@Mod_Studio:
	cmp	DWORD PTR _j$[ebp], 0
	jl	SHORT $LN3@Mod_Studio

; 388  : 	{
; 389  : 		i = boneused[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _boneused$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _i$[ebp], edx

; 390  : 		R_StudioCalcBoneQuaternion( frame, s, &pbone[i], &panim[i], adj, q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _panim$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 112
	add	eax, DWORD PTR _pbone$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_R_StudioCalcBoneQuaternion
	add	esp, 24					; 00000018H

; 391  : 		R_StudioCalcBonePosition( frame, s, &pbone[i], &panim[i], adj, pos[i] );

	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _pos$[ebp]
	push	edx
	lea	eax, DWORD PTR _adj$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 112
	add	edx, DWORD PTR _pbone$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	call	_R_StudioCalcBonePosition
	add	esp, 24					; 00000018H

; 392  : 	}

	jmp	$LN2@Mod_Studio
$LN3@Mod_Studio:

; 393  : 
; 394  : 	if( pseqdesc->motiontype & STUDIO_X ) pos[pseqdesc->motionbone][0] = 0.0f;

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	and	edx, 1
	je	SHORT $LN8@Mod_Studio
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
$LN8@Mod_Studio:

; 395  : 	if( pseqdesc->motiontype & STUDIO_Y ) pos[pseqdesc->motionbone][1] = 0.0f;

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	and	edx, 2
	je	SHORT $LN9@Mod_Studio
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+edx], xmm0
$LN9@Mod_Studio:

; 396  : 	if( pseqdesc->motiontype & STUDIO_Z ) pos[pseqdesc->motionbone][2] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 4
	je	SHORT $LN10@Mod_Studio
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	imul	eax, DWORD PTR [edx+72], 12
	add	eax, DWORD PTR _pos$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0
$LN10@Mod_Studio:

; 397  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioCalcRotations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
tv128 = -28						; size = 4
tv95 = -24						; size = 4
tv144 = -20						; size = 4
_i$ = -16						; size = 4
_pbonecontroller$ = -12					; size = 4
_value$ = -8						; size = 4
_j$ = -4						; size = 4
_adj$ = 8						; size = 4
_pcontroller$ = 12					; size = 4
_Mod_StudioCalcBoneAdj PROC

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 309  : 	int			i, j;
; 310  : 	float			value;
; 311  : 	mstudiobonecontroller_t	*pbonecontroller;
; 312  : 	
; 313  : 	pbonecontroller = (mstudiobonecontroller_t *)((byte *)mod_studiohdr + mod_studiohdr->bonecontrollerindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR _pbonecontroller$[ebp], ecx

; 314  : 
; 315  : 	for( j = 0; j < mod_studiohdr->numbonecontrollers; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+148]
	jge	$LN3@Mod_Studio

; 316  : 	{
; 317  : 		i = pbonecontroller[j].index;

	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	mov	ecx, DWORD PTR [eax+edx+20]
	mov	DWORD PTR _i$[ebp], ecx

; 318  : 
; 319  : 		if( i == STUDIO_MOUTH )

	cmp	DWORD PTR _i$[ebp], 4
	jne	SHORT $LN7@Mod_Studio

; 320  : 			continue; // ignore mouth

	jmp	SHORT $LN2@Mod_Studio
$LN7@Mod_Studio:

; 321  : 
; 322  : 		if( i <= MAXSTUDIOCONTROLLERS )

	cmp	DWORD PTR _i$[ebp], 8
	jg	$LN10@Mod_Studio

; 323  : 		{
; 324  : 			// check for 360% wrapping
; 325  : 			if( pbonecontroller[j].type & STUDIO_RLOOP )

	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN9@Mod_Studio

; 326  : 			{
; 327  : 				value = pcontroller[i] * (360.0f / 256.0f) + pbonecontroller[j].start;

	mov	edx, DWORD PTR _pcontroller$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	imul	ecx, DWORD PTR _j$[ebp], 24
	mov	edx, DWORD PTR _pbonecontroller$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+8]
	movss	DWORD PTR _value$[ebp], xmm0

; 328  : 			}

	jmp	$LN10@Mod_Studio
$LN9@Mod_Studio:

; 329  : 			else 
; 330  : 			{
; 331  : 				value = pcontroller[i] / 255.0f;

	mov	eax, DWORD PTR _pcontroller$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _value$[ebp], xmm0

; 332  : 				value = bound( 0.0f, value, 1.0f );

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN16@Mod_Studio
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _value$[ebp]
	jbe	SHORT $LN14@Mod_Studio
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN15@Mod_Studio
$LN14@Mod_Studio:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv95[ebp], xmm0
$LN15@Mod_Studio:
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN17@Mod_Studio
$LN16@Mod_Studio:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv128[ebp], xmm0
$LN17@Mod_Studio:
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 333  : 				value = (1.0f - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _value$[ebp]
	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+8]
	imul	ecx, DWORD PTR _j$[ebp], 24
	mov	edx, DWORD PTR _pbonecontroller$[ebp]
	movss	xmm1, DWORD PTR _value$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _value$[ebp], xmm0
$LN10@Mod_Studio:

; 334  : 			}
; 335  : 		}
; 336  : 
; 337  : 		switch( pbonecontroller[j].type & STUDIO_TYPES )

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 32767				; 00007fffH
	mov	DWORD PTR tv144[ebp], edx
	mov	eax, DWORD PTR tv144[ebp]
	sub	eax, 1
	mov	DWORD PTR tv144[ebp], eax
	cmp	DWORD PTR tv144[ebp], 31		; 0000001fH
	ja	SHORT $LN5@Mod_Studio
	mov	ecx, DWORD PTR tv144[ebp]
	movzx	edx, BYTE PTR $LN18@Mod_Studio[ecx]
	jmp	DWORD PTR $LN19@Mod_Studio[edx*4]
$LN11@Mod_Studio:

; 338  : 		{
; 339  : 		case STUDIO_XR:
; 340  : 		case STUDIO_YR:
; 341  : 		case STUDIO_ZR:
; 342  : 			adj[j] = value * (M_PI / 180.0f);

	movss	xmm0, DWORD PTR _value$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 343  : 			break;

	jmp	SHORT $LN5@Mod_Studio
$LN12@Mod_Studio:

; 344  : 		case STUDIO_X:
; 345  : 		case STUDIO_Y:
; 346  : 		case STUDIO_Z:
; 347  : 			adj[j] = value;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
$LN5@Mod_Studio:

; 348  : 			break;
; 349  : 		}
; 350  : 	}

	jmp	$LN2@Mod_Studio
$LN3@Mod_Studio:

; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@Mod_Studio:
	DD	$LN12@Mod_Studio
	DD	$LN11@Mod_Studio
	DD	$LN5@Mod_Studio
$LN18@Mod_Studio:
	DB	0
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_Mod_StudioCalcBoneAdj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
tv334 = -84						; size = 8
tv344 = -76						; size = 8
tv324 = -68						; size = 8
tv342 = -60						; size = 8
tv314 = -52						; size = 8
tv302 = -44						; size = 8
tv340 = -36						; size = 8
tv292 = -28						; size = 8
tv338 = -20						; size = 8
tv282 = -12						; size = 8
_pl$ = -4						; size = 4
_planenum$ = 8						; size = 4
_bone$ = 12						; size = 4
_axis$ = 16						; size = 4
_offset$ = 20						; size = 4
_size$ = 24						; size = 4
_Mod_SetStudioHullPlane PROC

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi

; 208  : 	mplane_t	*pl = &studio_planes[planenum];

	imul	eax, DWORD PTR _planenum$[ebp], 20
	add	eax, OFFSET _studio_planes
	mov	DWORD PTR _pl$[ebp], eax

; 209  : 
; 210  : 	pl->type = 5;

	mov	ecx, DWORD PTR _pl$[ebp]
	mov	BYTE PTR [ecx+16], 5

; 211  : 
; 212  : 	pl->normal[0] = studio_bones[bone][0][axis];

	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _studio_bones[edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _axis$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [eax+ecx], edx

; 213  : 	pl->normal[1] = studio_bones[bone][1][axis];

	imul	eax, DWORD PTR _bone$[ebp], 48
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _studio_bones[eax+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _axis$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax], edx

; 214  : 	pl->normal[2] = studio_bones[bone][2][axis];

	imul	eax, DWORD PTR _bone$[ebp], 48
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _studio_bones[eax+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _axis$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax], edx

; 215  : 
; 216  : 	pl->dist = (pl->normal[0] * studio_bones[bone][0][3]) + (pl->normal[1] * studio_bones[bone][1][3]) + (pl->normal[2] * studio_bones[bone][2][3]) + offset;

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	lea	edx, DWORD PTR _studio_bones[edx+eax]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _pl$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	edx, DWORD PTR _studio_bones[edx+eax]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _pl$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	edx, DWORD PTR _studio_bones[edx+eax]
	mov	eax, 4
	imul	eax, eax, 3
	mov	esi, DWORD PTR _pl$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _pl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 217  : 
; 218  : 	if( planenum & 1 ) pl->dist -= DotProductFabs( pl->normal, size );

	mov	edx, DWORD PTR _planenum$[ebp]
	and	edx, 1
	je	$LN2@Mod_SetStu
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv282[ebp]
	movsd	xmm0, QWORD PTR tv282[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv338[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv292[ebp]
	movsd	xmm0, QWORD PTR tv338[ebp]
	addsd	xmm0, QWORD PTR tv292[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv340[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv302[ebp]
	movsd	xmm0, QWORD PTR tv340[ebp]
	addsd	xmm0, QWORD PTR tv302[ebp]
	mov	eax, DWORD PTR _pl$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+12]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	ecx, DWORD PTR _pl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	jmp	$LN3@Mod_SetStu
$LN2@Mod_SetStu:

; 219  : 	else pl->dist += DotProductFabs( pl->normal, size );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv314[ebp]
	movsd	xmm0, QWORD PTR tv314[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv342[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv324[ebp]
	movsd	xmm0, QWORD PTR tv342[ebp]
	addsd	xmm0, QWORD PTR tv324[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv344[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv334[ebp]
	movsd	xmm0, QWORD PTR tv344[ebp]
	addsd	xmm0, QWORD PTR tv334[ebp]
	mov	edx, DWORD PTR _pl$[ebp]
	cvtss2sd xmm1, DWORD PTR [edx+12]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	eax, DWORD PTR _pl$[ebp]
	movss	DWORD PTR [eax+12], xmm0
$LN3@Mod_SetStu:

; 220  : 
; 221  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetStudioHullPlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pCached$ = -4						; size = 4
_model$ = 8						; size = 4
_frame$ = 12						; size = 4
_sequence$ = 16						; size = 4
_angles$ = 20						; size = 4
_origin$ = 24						; size = 4
_size$ = 28						; size = 4
_controller$ = 32					; size = 4
_blending$ = 36						; size = 4
_Mod_CheckStudioCache PROC

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 157  : 	mstudiocache_t	*pCached;
; 158  : 	int		i;
; 159  : 
; 160  : 	for( i = 0; i < STUDIO_CACHESIZE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CheckS
$LN2@Mod_CheckS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_CheckS:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN3@Mod_CheckS

; 161  : 	{
; 162  : 		pCached = &cache_studio[(cache_current - i) & STUDIO_CACHEMASK];

	mov	ecx, DWORD PTR _cache_current
	sub	ecx, DWORD PTR _i$[ebp]
	and	ecx, 15					; 0000000fH
	imul	edx, ecx, 68
	add	edx, OFFSET _cache_studio
	mov	DWORD PTR _pCached$[ebp], edx

; 163  : 
; 164  : 		if( pCached->model != model )

	mov	eax, DWORD PTR _pCached$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR _model$[ebp]
	je	SHORT $LN5@Mod_CheckS

; 165  : 			continue;

	jmp	SHORT $LN2@Mod_CheckS
$LN5@Mod_CheckS:

; 166  : 
; 167  : 		if( pCached->frame != frame )

	mov	edx, DWORD PTR _pCached$[ebp]
	movss	xmm0, DWORD PTR [edx]
	ucomiss	xmm0, DWORD PTR _frame$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@Mod_CheckS

; 168  : 			continue;

	jmp	SHORT $LN2@Mod_CheckS
$LN6@Mod_CheckS:

; 169  : 
; 170  : 		if( pCached->sequence != sequence )

	mov	eax, DWORD PTR _pCached$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _sequence$[ebp]
	je	SHORT $LN7@Mod_CheckS

; 171  : 			continue;

	jmp	SHORT $LN2@Mod_CheckS
$LN7@Mod_CheckS:

; 172  : 
; 173  : 		if( !VectorCompare( pCached->angles, angles ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+8]
	ucomiss	xmm0, DWORD PTR [esi+edx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@Mod_CheckS
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+8]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@Mod_CheckS
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+8]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@Mod_CheckS
$LN9@Mod_CheckS:

; 174  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN8@Mod_CheckS:

; 175  : 
; 176  : 		if( !VectorCompare( pCached->origin, origin ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+20]
	ucomiss	xmm0, DWORD PTR [esi+edx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_CheckS
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+20]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_CheckS
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+20]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@Mod_CheckS
$LN11@Mod_CheckS:

; 177  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN10@Mod_CheckS:

; 178  : 
; 179  : 		if( !VectorCompare( pCached->size, size ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+32]
	ucomiss	xmm0, DWORD PTR [esi+edx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Mod_CheckS
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+32]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Mod_CheckS
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pCached$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+32]
	ucomiss	xmm0, DWORD PTR [esi+eax]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@Mod_CheckS
$LN13@Mod_CheckS:

; 180  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN12@Mod_CheckS:

; 181  : 
; 182  : 		if( memcmp( pCached->controller, controller, 4 ) != 0 )

	push	4
	mov	edx, DWORD PTR _controller$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCached$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@Mod_CheckS

; 183  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN14@Mod_CheckS:

; 184  : 
; 185  : 		if( memcmp( pCached->blending, blending, 2 ) != 0 )

	push	2
	mov	ecx, DWORD PTR _blending$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCached$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@Mod_CheckS

; 186  : 			continue;

	jmp	$LN2@Mod_CheckS
$LN15@Mod_CheckS:

; 187  : 
; 188  : 		return pCached;

	mov	eax, DWORD PTR _pCached$[ebp]
	jmp	SHORT $LN1@Mod_CheckS

; 189  : 	}

	jmp	$LN2@Mod_CheckS
$LN3@Mod_CheckS:

; 190  : 
; 191  : 	return NULL;

	xor	eax, eax
$LN1@Mod_CheckS:

; 192  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CheckStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_pCache$ = -4						; size = 4
_frame$ = 8						; size = 4
_sequence$ = 12						; size = 4
_angles$ = 16						; size = 4
_origin$ = 20						; size = 4
_size$ = 24						; size = 4
_pcontroller$ = 28					; size = 4
_pblending$ = 32					; size = 4
_model$ = 36						; size = 4
_hull$ = 40						; size = 4
_numhitboxes$ = 44					; size = 4
_Mod_AddToStudioCache PROC

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 120  : 	mstudiocache_t *pCache;
; 121  : 
; 122  : 	if( numhitboxes + cache_current_hull >= MAXSTUDIOBONES )

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	add	eax, DWORD PTR _cache_current_hull
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN2@Mod_AddToS

; 123  : 		Mod_ClearStudioCache();

	call	_Mod_ClearStudioCache
$LN2@Mod_AddToS:

; 124  : 
; 125  : 	cache_current++;

	mov	ecx, DWORD PTR _cache_current
	add	ecx, 1
	mov	DWORD PTR _cache_current, ecx

; 126  : 	pCache = &cache_studio[cache_current & STUDIO_CACHEMASK];

	mov	edx, DWORD PTR _cache_current
	and	edx, 15					; 0000000fH
	imul	eax, edx, 68
	add	eax, OFFSET _cache_studio
	mov	DWORD PTR _pCache$[ebp], eax

; 127  : 
; 128  : 	pCache->frame = frame;

	mov	ecx, DWORD PTR _pCache$[ebp]
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 129  : 	pCache->sequence = sequence;

	mov	edx, DWORD PTR _pCache$[ebp]
	mov	eax, DWORD PTR _sequence$[ebp]
	mov	DWORD PTR [edx+4], eax

; 130  : 	VectorCopy( angles, pCache->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+8], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+8], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+8], ecx

; 131  : 	VectorCopy( origin, pCache->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+20], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+20], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+20], edx

; 132  : 	VectorCopy( size, pCache->size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pCache$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+32], eax

; 133  : 
; 134  : 	memcpy( pCache->controller, pcontroller, 4 );

	push	4
	mov	ecx, DWORD PTR _pcontroller$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCache$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 135  : 	memcpy( pCache->blending, pblending, 2 );

	push	2
	mov	eax, DWORD PTR _pblending$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCache$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 136  : 
; 137  : 	pCache->model = model;

	mov	edx, DWORD PTR _pCache$[ebp]
	mov	eax, DWORD PTR _model$[ebp]
	mov	DWORD PTR [edx+52], eax

; 138  : 	pCache->current_hull = cache_current_hull;

	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	edx, DWORD PTR _cache_current_hull
	mov	DWORD PTR [ecx+56], edx

; 139  : 	pCache->current_plane = cache_current_plane;

	mov	eax, DWORD PTR _pCache$[ebp]
	mov	ecx, DWORD PTR _cache_current_plane
	mov	DWORD PTR [eax+60], ecx

; 140  : 
; 141  : 	memcpy( &cache_hull[cache_current_hull], hull, numhitboxes * sizeof( hull_t ));

	imul	edx, DWORD PTR _numhitboxes$[ebp], 40
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	imul	ecx, DWORD PTR _cache_current_hull, 40
	add	ecx, OFFSET _cache_hull
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 142  : 	memcpy( &cache_planes[cache_current_plane], studio_planes, numhitboxes * sizeof( mplane_t ) * 6 );

	imul	edx, DWORD PTR _numhitboxes$[ebp], 20
	imul	eax, edx, 6
	push	eax
	push	OFFSET _studio_planes
	imul	ecx, DWORD PTR _cache_current_plane, 20
	add	ecx, OFFSET _cache_planes
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 143  : 	memcpy( &cache_hull_hitgroup[cache_current_hull], studio_hull_hitgroup, numhitboxes * sizeof( uint ));

	mov	edx, DWORD PTR _numhitboxes$[ebp]
	shl	edx, 2
	push	edx
	push	OFFSET _studio_hull_hitgroup
	mov	eax, DWORD PTR _cache_current_hull
	lea	ecx, DWORD PTR _cache_hull_hitgroup[eax*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 144  : 
; 145  : 	cache_current_hull += numhitboxes;

	mov	edx, DWORD PTR _cache_current_hull
	add	edx, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR _cache_current_hull, edx

; 146  : 	cache_current_plane += numhitboxes * 6;

	imul	eax, DWORD PTR _numhitboxes$[ebp], 6
	add	eax, DWORD PTR _cache_current_plane
	mov	DWORD PTR _cache_current_plane, eax

; 147  : 	pCache->numhitboxes = numhitboxes;

	mov	ecx, DWORD PTR _pCache$[ebp]
	mov	edx, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 148  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_AddToStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_Mod_ClearStudioCache PROC

; 106  : {

	push	ebp
	mov	ebp, esp

; 107  : 	memset( cache_studio, 0, sizeof( cache_studio ));

	push	1088					; 00000440H
	push	0
	push	OFFSET _cache_studio
	call	_memset
	add	esp, 12					; 0000000cH

; 108  : 	cache_current_hull = cache_current_plane = 0;

	mov	DWORD PTR _cache_current_plane, 0
	mov	eax, DWORD PTR _cache_current_plane
	mov	DWORD PTR _cache_current_hull, eax

; 109  : 
; 110  : 	cache_current = 0;

	mov	DWORD PTR _cache_current, 0

; 111  : }

	pop	ebp
	ret	0
_Mod_ClearStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_index$ = 8						; size = 4
_Mod_HitgroupForStudioHull PROC

; 575  : {

	push	ebp
	mov	ebp, esp

; 576  : 	return studio_hull_hitgroup[index];

	mov	eax, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _studio_hull_hitgroup[eax*4]

; 577  : }

	pop	ebp
	ret	0
_Mod_HitgroupForStudioHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_pbones$ = -128						; size = 4
_panim$ = -124						; size = 4
_pseqgroup$ = -120					; size = 4
_numseq$ = -116						; size = 4
_pverts$ = -112						; size = 4
_vert_count$ = -108					; size = 4
tv153 = -104						; size = 4
_m_pSubModel$ = -100					; size = 4
_pbodypart$ = -96					; size = 4
_bone_count$ = -92					; size = 4
_bodyCount$ = -88					; size = 4
_k$ = -84						; size = 4
_pseqdesc$ = -80					; size = 4
_j$ = -76						; size = 4
_pstudiohdr$ = -72					; size = 4
_i$ = -68						; size = 4
_pos$ = -64						; size = 12
_vert_mins$ = -52					; size = 12
_vert_maxs$ = -40					; size = 12
_bone_maxs$ = -28					; size = 12
_bone_mins$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_ignore_sequences$ = 20					; size = 4
_Mod_StudioComputeBounds PROC

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 624  : 	int		i, j, k, numseq;
; 625  : 	studiohdr_t	*pstudiohdr;
; 626  : 	mstudiobodyparts_t	*pbodypart;
; 627  : 	mstudiomodel_t	*m_pSubModel;
; 628  : 	mstudioseqgroup_t	*pseqgroup;
; 629  : 	mstudioseqdesc_t	*pseqdesc;
; 630  : 	mstudiobone_t	*pbones;
; 631  : 	mstudioanim_t	*panim;
; 632  : 	vec3_t		bone_mins, bone_maxs;
; 633  : 	vec3_t		vert_mins, vert_maxs;
; 634  : 	int		vert_count, bone_count;
; 635  : 	int		bodyCount = 0;

	mov	DWORD PTR _bodyCount$[ebp], 0

; 636  : 	vec3_t		pos, *pverts;
; 637  : 
; 638  : 	vert_count = bone_count = 0;

	mov	DWORD PTR _bone_count$[ebp], 0
	mov	eax, DWORD PTR _bone_count$[ebp]
	mov	DWORD PTR _vert_count$[ebp], eax

; 639  : 	VectorClear( bone_mins );

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_mins$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_mins$[ebp+ecx], xmm0

; 640  : 	VectorClear( bone_maxs );

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_maxs$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _bone_maxs$[ebp+edx], xmm0

; 641  : 	VectorClear( vert_mins );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_mins$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_mins$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_mins$[ebp+eax], xmm0

; 642  : 	VectorClear( vert_maxs );

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_maxs$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vert_maxs$[ebp+ecx], xmm0

; 643  : 
; 644  : 	// Get the body part portion of the model
; 645  : 	pstudiohdr = (studiohdr_t *)buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pstudiohdr$[ebp], edx

; 646  : 	pbodypart = (mstudiobodyparts_t *)((byte *)pstudiohdr + pstudiohdr->bodypartindex);

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _pbodypart$[ebp], ecx

; 647  : 
; 648  : 	// each body part has nummodels variations so there are as many total variations as there
; 649  : 	// are in a matrix of each part by each other part
; 650  : 	for( i = 0; i < pstudiohdr->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+204]
	jge	SHORT $LN3@Mod_Studio

; 651  : 		bodyCount += pbodypart[i].nummodels;

	imul	edx, DWORD PTR _i$[ebp], 76
	mov	eax, DWORD PTR _pbodypart$[ebp]
	mov	ecx, DWORD PTR _bodyCount$[ebp]
	add	ecx, DWORD PTR [eax+edx+64]
	mov	DWORD PTR _bodyCount$[ebp], ecx
	jmp	SHORT $LN2@Mod_Studio
$LN3@Mod_Studio:

; 652  : 
; 653  : 	// The studio models we want are vec3_t mins, vec3_t maxsight after the bodyparts (still need to
; 654  : 	// find a detailed breakdown of the mdl format).  Move pointer there.
; 655  : 	m_pSubModel = (mstudiomodel_t *)(&pbodypart[pstudiohdr->numbodyparts]);

	mov	edx, DWORD PTR _pstudiohdr$[ebp]
	imul	eax, DWORD PTR [edx+204], 76
	add	eax, DWORD PTR _pbodypart$[ebp]
	mov	DWORD PTR _m_pSubModel$[ebp], eax

; 656  : 
; 657  : 	for( i = 0; i < bodyCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_Studio
$LN5@Mod_Studio:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@Mod_Studio:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _bodyCount$[ebp]
	jge	SHORT $LN6@Mod_Studio

; 658  : 	{
; 659  : 		pverts = (vec3_t *)((byte *)pstudiohdr + m_pSubModel[i].vertindex);

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	mov	edx, DWORD PTR _pstudiohdr$[ebp]
	add	edx, DWORD PTR [ecx+eax+88]
	mov	DWORD PTR _pverts$[ebp], edx

; 660  : 
; 661  : 		for( j = 0; j < m_pSubModel[i].numverts; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_Studio
$LN8@Mod_Studio:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_Studio:
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _m_pSubModel$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+80]
	jge	SHORT $LN9@Mod_Studio

; 662  : 			Mod_StudioBoundVertex( bone_mins, bone_maxs, &vert_count, pverts[j] );

	imul	ecx, DWORD PTR _j$[ebp], 12
	add	ecx, DWORD PTR _pverts$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vert_count$[ebp]
	push	edx
	lea	eax, DWORD PTR _bone_maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bone_mins$[ebp]
	push	ecx
	call	_Mod_StudioBoundVertex
	add	esp, 16					; 00000010H
	jmp	SHORT $LN8@Mod_Studio
$LN9@Mod_Studio:

; 663  : 	}

	jmp	SHORT $LN5@Mod_Studio
$LN6@Mod_Studio:

; 664  : 
; 665  : 	pbones = (mstudiobone_t *)((byte *)pstudiohdr + pstudiohdr->boneindex);

	mov	edx, DWORD PTR _pstudiohdr$[ebp]
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	add	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _pbones$[ebp], eax

; 666  : 	numseq = (ignore_sequences) ? 1 : pstudiohdr->numseq;

	cmp	DWORD PTR _ignore_sequences$[ebp], 0
	je	SHORT $LN23@Mod_Studio
	mov	DWORD PTR tv153[ebp], 1
	jmp	SHORT $LN24@Mod_Studio
$LN23@Mod_Studio:
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR tv153[ebp], edx
$LN24@Mod_Studio:
	mov	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR _numseq$[ebp], eax

; 667  : 
; 668  : 	for( i = 0; i < numseq; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Mod_Studio
$LN11@Mod_Studio:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@Mod_Studio:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numseq$[ebp]
	jge	$LN12@Mod_Studio

; 669  : 	{
; 670  : 		pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + i;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _i$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 671  : 		pseqgroup = (mstudioseqgroup_t *)((byte *)pstudiohdr + pstudiohdr->seqgroupindex) + pseqdesc->seqgroup;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	imul	eax, DWORD PTR [edx+156], 104
	add	ecx, eax
	mov	DWORD PTR _pseqgroup$[ebp], ecx

; 672  : 
; 673  : 		if( pseqdesc->seqgroup == 0 )

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [ecx+156], 0
	jne	SHORT $LN20@Mod_Studio

; 674  : 			panim = (mstudioanim_t *)((byte *)pstudiohdr + pseqgroup->data + pseqdesc->animindex);

	mov	edx, DWORD PTR _pseqgroup$[ebp]
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	add	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [ecx+124]
	mov	DWORD PTR _panim$[ebp], eax
	jmp	SHORT $LN21@Mod_Studio
$LN20@Mod_Studio:

; 675  : 		else continue;

	jmp	SHORT $LN11@Mod_Studio
$LN21@Mod_Studio:

; 676  : 
; 677  : 		for( j = 0; j < pstudiohdr->numbones; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@Mod_Studio
$LN14@Mod_Studio:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN16@Mod_Studio:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN15@Mod_Studio

; 678  : 		{
; 679  : 			for( k = 0; k < pseqdesc->numframes; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN19@Mod_Studio
$LN17@Mod_Studio:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN19@Mod_Studio:
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $LN18@Mod_Studio

; 680  : 			{
; 681  : 				R_StudioCalcBonePosition( k, 0, &pbones[j], panim, NULL, pos );

	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 112
	add	ecx, DWORD PTR _pbones$[ebp]
	push	ecx
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_R_StudioCalcBonePosition
	add	esp, 24					; 00000018H

; 682  : 				Mod_StudioBoundVertex( vert_mins, vert_maxs, &bone_count, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bone_count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vert_maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _vert_mins$[ebp]
	push	eax
	call	_Mod_StudioBoundVertex
	add	esp, 16					; 00000010H

; 683  : 			}

	jmp	SHORT $LN17@Mod_Studio
$LN18@Mod_Studio:

; 684  : 		}

	jmp	SHORT $LN14@Mod_Studio
$LN15@Mod_Studio:

; 685  : 
; 686  : 		Mod_StudioAccumulateBoneVerts( bone_mins, bone_maxs, &vert_count, vert_mins, vert_maxs, &bone_count );

	lea	ecx, DWORD PTR _bone_count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vert_maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _vert_mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vert_count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bone_maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _bone_mins$[ebp]
	push	eax
	call	_Mod_StudioAccumulateBoneVerts
	add	esp, 24					; 00000018H

; 687  : 	}

	jmp	$LN11@Mod_Studio
$LN12@Mod_Studio:

; 688  : 
; 689  : 	VectorCopy( bone_mins, mins );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _bone_mins$[ebp+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR _bone_mins$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR _bone_mins$[ebp+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 690  : 	VectorCopy( bone_maxs, maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR _bone_maxs$[ebp+eax]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR _bone_maxs$[ebp+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR _bone_maxs$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx

; 691  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioComputeBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
tv273 = -40						; size = 4
_bSkipShield$ = -36					; size = 4
_bonecache$ = -32					; size = 4
_j$ = -28						; size = 4
_phitbox$ = -24						; size = 4
_i$ = -20						; size = 4
_angles2$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_model$ = 8						; size = 4
_frame$ = 12						; size = 4
_sequence$ = 16						; size = 4
_angles$ = 20						; size = 4
_origin$ = 24						; size = 4
_size$ = 28						; size = 4
_pcontroller$ = 32					; size = 4
_pblending$ = 36					; size = 4
_numhitboxes$ = 40					; size = 4
_pEdict$ = 44						; size = 4
_Mod_HullForStudio PROC

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 232  : 	vec3_t		angles2;
; 233  : 	mstudiocache_t	*bonecache;
; 234  : 	mstudiobbox_t	*phitbox;
; 235  : 	qboolean		bSkipShield;
; 236  : 	int		i, j;
; 237  : 
; 238  : 	bSkipShield = false;

	mov	DWORD PTR _bSkipShield$[ebp], 0

; 239  : 	*numhitboxes = 0; // assume error

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR [eax], 0

; 240  : 
; 241  : 	if( mod_studiocache->value )

	mov	ecx, DWORD PTR _mod_studiocache
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@Mod_HullFo

; 242  : 	{
; 243  : 		bonecache = Mod_CheckStudioCache( model, frame, sequence, angles, origin, size, pcontroller, pblending );

	mov	edx, DWORD PTR _pblending$[ebp]
	push	edx
	mov	eax, DWORD PTR _pcontroller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sequence$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_Mod_CheckStudioCache
	add	esp, 32					; 00000020H
	mov	DWORD PTR _bonecache$[ebp], eax

; 244  : 
; 245  : 		if( bonecache != NULL )

	cmp	DWORD PTR _bonecache$[ebp], 0
	je	$LN6@Mod_HullFo

; 246  : 		{
; 247  : 			memcpy( studio_planes, &cache_planes[bonecache->current_plane], bonecache->numhitboxes * sizeof( mplane_t ) * 6 );

	mov	eax, DWORD PTR _bonecache$[ebp]
	imul	ecx, DWORD PTR [eax+64], 20
	imul	edx, ecx, 6
	push	edx
	mov	eax, DWORD PTR _bonecache$[ebp]
	imul	ecx, DWORD PTR [eax+60], 20
	add	ecx, OFFSET _cache_planes
	push	ecx
	push	OFFSET _studio_planes
	call	_memcpy
	add	esp, 12					; 0000000cH

; 248  : 			memcpy( studio_hull_hitgroup, &cache_hull_hitgroup[bonecache->current_hull], bonecache->numhitboxes * sizeof( uint ));

	mov	edx, DWORD PTR _bonecache$[ebp]
	mov	eax, DWORD PTR [edx+64]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _bonecache$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	lea	eax, DWORD PTR _cache_hull_hitgroup[edx*4]
	push	eax
	push	OFFSET _studio_hull_hitgroup
	call	_memcpy
	add	esp, 12					; 0000000cH

; 249  : 			memcpy( studio_hull, &cache_hull[bonecache->current_hull], bonecache->numhitboxes * sizeof( hull_t ));

	mov	ecx, DWORD PTR _bonecache$[ebp]
	imul	edx, DWORD PTR [ecx+64], 40
	push	edx
	mov	eax, DWORD PTR _bonecache$[ebp]
	imul	ecx, DWORD PTR [eax+56], 40
	add	ecx, OFFSET _cache_hull
	push	ecx
	push	OFFSET _studio_hull
	call	_memcpy
	add	esp, 12					; 0000000cH

; 250  : 
; 251  : 			*numhitboxes = bonecache->numhitboxes;

	mov	edx, DWORD PTR _numhitboxes$[ebp]
	mov	eax, DWORD PTR _bonecache$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edx], ecx

; 252  : 			return studio_hull;

	mov	eax, OFFSET _studio_hull
	jmp	$LN1@Mod_HullFo
$LN6@Mod_HullFo:

; 253  : 		}
; 254  : 	}
; 255  : 
; 256  : 	mod_studiohdr = Mod_StudioExtradata( model );

	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _mod_studiohdr, eax

; 257  : 	if( !mod_studiohdr ) return NULL; // probably not a studiomodel

	cmp	DWORD PTR _mod_studiohdr, 0
	jne	SHORT $LN7@Mod_HullFo
	xor	eax, eax
	jmp	$LN1@Mod_HullFo
$LN7@Mod_HullFo:

; 258  : 
; 259  : 	VectorCopy( angles, angles2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _angles2$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _angles2$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _angles2$[ebp+ecx], eax

; 260  : 
; 261  : 	if( !FBitSet( host.features, ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	ecx, DWORD PTR _host+34748
	and	ecx, 32					; 00000020H
	jne	SHORT $LN8@Mod_HullFo

; 262  : 		angles2[PITCH] = -angles2[PITCH]; // stupid quake bug

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _angles2$[ebp+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _angles2$[ebp+edx], xmm0
$LN8@Mod_HullFo:

; 263  : 
; 264  : 	pBlendAPI->SV_StudioSetupBones( model, frame, sequence, angles2, origin, pcontroller, pblending, -1, pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _pblending$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sequence$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlendAPI
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 36					; 00000024H

; 265  : 	phitbox = (mstudiobbox_t *)((byte *)mod_studiohdr + mod_studiohdr->hitboxindex);

	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR _mod_studiohdr
	add	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _phitbox$[ebp], ecx

; 266  : 
; 267  : 	if( SV_IsValidEdict( pEdict ) && pEdict->v.gamestate == 1 )

	push	267					; 0000010bH
	push	OFFSET $SG136877
	mov	edx, DWORD PTR _pEdict$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@Mod_HullFo
	mov	eax, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [eax+696], 1
	jne	SHORT $LN9@Mod_HullFo

; 268  : 		bSkipShield = 1;

	mov	DWORD PTR _bSkipShield$[ebp], 1
$LN9@Mod_HullFo:

; 269  : 	
; 270  : 	for( i = j = 0; i < mod_studiohdr->numhitboxes; i++, j += 6 )

	mov	DWORD PTR _j$[ebp], 0
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@Mod_HullFo
$LN2@Mod_HullFo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 6
	mov	DWORD PTR _j$[ebp], eax
$LN4@Mod_HullFo:
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+156]
	jge	$LN3@Mod_HullFo

; 271  : 	{
; 272  : 		if( bSkipShield && i == 21 )

	cmp	DWORD PTR _bSkipShield$[ebp], 0
	je	SHORT $LN10@Mod_HullFo
	cmp	DWORD PTR _i$[ebp], 21			; 00000015H
	jne	SHORT $LN10@Mod_HullFo

; 273  : 			continue;	// CS stuff

	jmp	SHORT $LN2@Mod_HullFo
$LN10@Mod_HullFo:

; 274  : 
; 275  : 		studio_hull_hitgroup[i] = phitbox[i].group;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _studio_hull_hitgroup[ecx*4], eax

; 276  : 
; 277  : 		Mod_SetStudioHullPlane( j + 0, phitbox[i].bone, 0, phitbox[i].bbmax[0], size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+20]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _phitbox$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 278  : 		Mod_SetStudioHullPlane( j + 1, phitbox[i].bone, 0, phitbox[i].bbmin[0], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	push	ecx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 279  : 		Mod_SetStudioHullPlane( j + 2, phitbox[i].bone, 1, phitbox[i].bbmax[1], size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _phitbox$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx+20]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _phitbox$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 2
	push	edx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 280  : 		Mod_SetStudioHullPlane( j + 3, phitbox[i].bone, 1, phitbox[i].bbmin[1], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx+8]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _phitbox$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 3
	push	eax
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 281  : 		Mod_SetStudioHullPlane( j + 4, phitbox[i].bone, 2, phitbox[i].bbmax[2], size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax+20]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _phitbox$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 4
	push	ecx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 282  : 		Mod_SetStudioHullPlane( j + 5, phitbox[i].bone, 2, phitbox[i].bbmin[2], size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _phitbox$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx+8]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _phitbox$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 5
	push	edx
	call	_Mod_SetStudioHullPlane
	add	esp, 20					; 00000014H

; 283  : 	}

	jmp	$LN2@Mod_HullFo
$LN3@Mod_HullFo:

; 284  : 
; 285  : 	// tell trace code about hitbox count
; 286  : 	*numhitboxes = (bSkipShield) ? (mod_studiohdr->numhitboxes - 1) : (mod_studiohdr->numhitboxes);

	cmp	DWORD PTR _bSkipShield$[ebp], 0
	je	SHORT $LN13@Mod_HullFo
	mov	eax, DWORD PTR _mod_studiohdr
	mov	ecx, DWORD PTR [eax+156]
	sub	ecx, 1
	mov	DWORD PTR tv273[ebp], ecx
	jmp	SHORT $LN14@Mod_HullFo
$LN13@Mod_HullFo:
	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR tv273[ebp], eax
$LN14@Mod_HullFo:
	mov	ecx, DWORD PTR _numhitboxes$[ebp]
	mov	edx, DWORD PTR tv273[ebp]
	mov	DWORD PTR [ecx], edx

; 287  : 
; 288  : 	if( mod_studiocache->value )

	mov	eax, DWORD PTR _mod_studiocache
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@Mod_HullFo

; 289  : 		Mod_AddToStudioCache( frame, sequence, angles, origin, size, pcontroller, pblending, model, studio_hull, *numhitboxes );

	mov	ecx, DWORD PTR _numhitboxes$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET _studio_hull
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pblending$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcontroller$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	eax, DWORD PTR _sequence$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_Mod_AddToStudioCache
	add	esp, 40					; 00000028H
$LN11@Mod_HullFo:

; 290  : 
; 291  : 	return studio_hull;

	mov	eax, OFFSET _studio_hull
$LN1@Mod_HullFo:

; 292  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_HullForStudio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_mod$ = -4						; size = 4
_e$ = 8							; size = 4
_iBone$ = 12						; size = 4
_origin$ = 16						; size = 4
_angles$ = 20						; size = 4
_Mod_GetBonePosition PROC

; 556  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 557  : 	model_t	*mod;
; 558  : 
; 559  : 	mod = SV_ModelHandle( e->v.modelindex );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 560  : 	mod_studiohdr = (studiohdr_t *)Mod_StudioExtradata( mod );

	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _mod_studiohdr, eax

; 561  : 	if( !mod_studiohdr ) return;

	cmp	DWORD PTR _mod_studiohdr, 0
	jne	SHORT $LN2@Mod_GetBon
	jmp	$LN4@Mod_GetBon
$LN2@Mod_GetBon:

; 562  : 
; 563  : 	pBlendAPI->SV_StudioSetupBones( mod, e->v.frame, e->v.sequence, e->v.angles, e->v.origin, e->v.controller, e->v.blending, iBone, e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBone$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 448				; 000001c0H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 444				; 000001bcH
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 208				; 000000d0H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+424]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+432]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlendAPI
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 36					; 00000024H

; 564  : 
; 565  : 	if( origin ) Matrix3x4_OriginFromMatrix( studio_bones[iBone], origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN3@Mod_GetBon
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	imul	ecx, DWORD PTR _iBone$[ebp], 48
	add	ecx, OFFSET _studio_bones
	push	ecx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8
$LN3@Mod_GetBon:

; 566  : 	if( angles ) Matrix3x4_AnglesFromMatrix( studio_bones[iBone], angles );

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN4@Mod_GetBon
	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	imul	eax, DWORD PTR _iBone$[ebp], 48
	add	eax, OFFSET _studio_bones
	push	eax
	call	_Matrix3x4_AnglesFromMatrix
	add	esp, 8
$LN4@Mod_GetBon:

; 567  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetBonePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_mod$ = -128						; size = 4
tv145 = -124						; size = 4
tv144 = -120						; size = 4
_pAtt$ = -116						; size = 4
_worldPose$ = -112					; size = 48
_localPose$ = -64					; size = 48
_angles2$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_iAtt$ = 12						; size = 4
_origin$ = 16						; size = 4
_angles$ = 20						; size = 4
_Mod_StudioGetAttachment PROC

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 508  : 	mstudioattachment_t		*pAtt;
; 509  : 	vec3_t			angles2;
; 510  : 	matrix3x4			localPose;
; 511  : 	matrix3x4			worldPose;
; 512  : 	model_t			*mod;
; 513  : 
; 514  : 	mod = SV_ModelHandle( e->v.modelindex );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 515  : 	mod_studiohdr = (studiohdr_t *)Mod_StudioExtradata( mod );

	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _mod_studiohdr, eax

; 516  : 	if( !mod_studiohdr ) return;

	cmp	DWORD PTR _mod_studiohdr, 0
	jne	SHORT $LN2@Mod_Studio
	jmp	$LN8@Mod_Studio
$LN2@Mod_Studio:

; 517  : 
; 518  : 	if( mod_studiohdr->numattachments <= 0 )

	mov	eax, DWORD PTR _mod_studiohdr
	cmp	DWORD PTR [eax+212], 0
	jg	$LN3@Mod_Studio

; 519  : 	{
; 520  : 		if( origin ) VectorCopy( e->v.origin, origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN4@Mod_Studio
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _origin$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _origin$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [eax+edx], ecx
$LN4@Mod_Studio:

; 521  : 
; 522  : 		if( FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP ) && angles )

	mov	edx, DWORD PTR _host+34748
	and	edx, 128				; 00000080H
	je	SHORT $LN5@Mod_Studio
	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN5@Mod_Studio

; 523  : 			VectorCopy( e->v.angles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx], eax
$LN5@Mod_Studio:

; 524  : 		return;

	jmp	$LN8@Mod_Studio
$LN3@Mod_Studio:

; 525  : 	}
; 526  : 
; 527  : 	iAtt = bound( 0, iAtt, mod_studiohdr->numattachments - 1 );

	cmp	DWORD PTR _iAtt$[ebp], 0
	jl	SHORT $LN12@Mod_Studio
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR [ecx+212]
	sub	edx, 1
	cmp	DWORD PTR _iAtt$[ebp], edx
	jge	SHORT $LN10@Mod_Studio
	mov	eax, DWORD PTR _iAtt$[ebp]
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN11@Mod_Studio
$LN10@Mod_Studio:
	mov	ecx, DWORD PTR _mod_studiohdr
	mov	edx, DWORD PTR [ecx+212]
	sub	edx, 1
	mov	DWORD PTR tv144[ebp], edx
$LN11@Mod_Studio:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN13@Mod_Studio
$LN12@Mod_Studio:
	mov	DWORD PTR tv145[ebp], 0
$LN13@Mod_Studio:
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR _iAtt$[ebp], ecx

; 528  : 
; 529  : 	// calculate attachment origin and angles
; 530  : 	pAtt = (mstudioattachment_t *)((byte *)mod_studiohdr + mod_studiohdr->attachmentindex) + iAtt;

	mov	edx, DWORD PTR _mod_studiohdr
	mov	eax, DWORD PTR _mod_studiohdr
	add	eax, DWORD PTR [edx+216]
	imul	ecx, DWORD PTR _iAtt$[ebp], 88
	add	eax, ecx
	mov	DWORD PTR _pAtt$[ebp], eax

; 531  : 
; 532  : 	VectorCopy( e->v.angles, angles2 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _angles2$[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+208]
	mov	DWORD PTR _angles2$[ebp+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _angles2$[ebp+eax], edx

; 533  : 
; 534  : 	if( !FBitSet( host.features, ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 32					; 00000020H
	jne	SHORT $LN6@Mod_Studio

; 535  : 		angles2[PITCH] = -angles2[PITCH];

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _angles2$[ebp+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _angles2$[ebp+ecx], xmm0
$LN6@Mod_Studio:

; 536  : 
; 537  : 	pBlendAPI->SV_StudioSetupBones( mod, e->v.frame, e->v.sequence, angles2, e->v.origin, e->v.controller, e->v.blending, pAtt->bone, e );

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _pAtt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 448				; 000001c0H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 444				; 000001bcH
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	lea	edx, DWORD PTR _angles2$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+424]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+432]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlendAPI
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 36					; 00000024H

; 538  : 
; 539  : 	Matrix3x4_LoadIdentity( localPose );

	push	48					; 00000030H
	push	OFFSET _matrix3x4_identity
	lea	eax, DWORD PTR _localPose$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 540  : 	Matrix3x4_SetOrigin( localPose, pAtt->org[0], pAtt->org[1], pAtt->org[2] );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pAtt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pAtt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pAtt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+40]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _localPose$[ebp]
	push	edx
	call	_Matrix3x4_SetOrigin
	add	esp, 16					; 00000010H

; 541  : 	Matrix3x4_ConcatTransforms( worldPose, studio_bones[pAtt->bone], localPose );

	lea	eax, DWORD PTR _localPose$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAtt$[ebp]
	imul	edx, DWORD PTR [ecx+36], 48
	add	edx, OFFSET _studio_bones
	push	edx
	lea	eax, DWORD PTR _worldPose$[ebp]
	push	eax
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 542  : 
; 543  : 	if( origin != NULL ) // origin is used always

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN7@Mod_Studio

; 544  : 		Matrix3x4_OriginFromMatrix( worldPose, origin );

	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _worldPose$[ebp]
	push	edx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8
$LN7@Mod_Studio:

; 545  : 
; 546  : 	if( FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP ) && angles != NULL )

	mov	eax, DWORD PTR _host+34748
	and	eax, 128				; 00000080H
	je	SHORT $LN8@Mod_Studio
	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN8@Mod_Studio

; 547  : 		Matrix3x4_AnglesFromMatrix( worldPose, angles );

	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	lea	edx, DWORD PTR _worldPose$[ebp]
	push	edx
	call	_Matrix3x4_AnglesFromMatrix
	add	esp, 8
$LN8@Mod_Studio:

; 548  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioGetAttachment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_result$ = -8						; size = 4
_f$ = -4						; size = 4
_name$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_Mod_GetStudioBounds PROC

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 700  : 	int	result = false;

	mov	DWORD PTR _result$[ebp], 0

; 701  : 	byte	*f;
; 702  : 
; 703  : 	if( !Q_strstr( name, "models" ) || !Q_strstr( name, ".mdl" ))

	push	OFFSET $SG137164
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@Mod_GetStu
	push	OFFSET $SG137165
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@Mod_GetStu
$LN3@Mod_GetStu:

; 704  : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_GetStu
$LN2@Mod_GetStu:

; 705  : 
; 706  : 	f = FS_LoadFile( name, NULL, false );

	push	0
	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 707  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN4@Mod_GetStu
	xor	eax, eax
	jmp	$LN1@Mod_GetStu
$LN4@Mod_GetStu:

; 708  : 
; 709  : 	if( *(uint *)f == IDSTUDIOHEADER )

	mov	eax, DWORD PTR _f$[ebp]
	cmp	DWORD PTR [eax], 1414743113		; 54534449H
	jne	$LN5@Mod_GetStu

; 710  : 	{
; 711  : 		VectorClear( mins );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0

; 712  : 		VectorClear( maxs );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0

; 713  : 		Mod_StudioComputeBounds( f, mins, maxs, false );

	push	0
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_Mod_StudioComputeBounds
	add	esp, 16					; 00000010H

; 714  : 		result = true;

	mov	DWORD PTR _result$[ebp], 1
$LN5@Mod_GetStu:

; 715  : 	}
; 716  : 	Mem_Free( f );

	push	716					; 000002ccH
	push	OFFSET $SG137168
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 717  : 
; 718  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@Mod_GetStu:

; 719  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetStudioBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_modname$ = 8						; size = 4
_Mod_StudioTexName PROC

; 729  : {

	push	ebp
	mov	ebp, esp

; 730  : 	static char	texname[MAX_QPATH];
; 731  : 
; 732  : 	Q_strncpy( texname, modname, sizeof( texname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _modname$[ebp]
	push	eax
	push	OFFSET ?texname@?1??Mod_StudioTexName@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 733  : 	COM_StripExtension( texname );

	push	OFFSET ?texname@?1??Mod_StudioTexName@@9@9
	call	_COM_StripExtension
	add	esp, 4

; 734  : 	Q_strncat( texname, "T.mdl", sizeof( texname ));

	push	64					; 00000040H
	push	OFFSET $SG137174
	push	OFFSET ?texname@?1??Mod_StudioTexName@@9@9
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 735  : 
; 736  : 	return texname;

	mov	eax, OFFSET ?texname@?1??Mod_StudioTexName@@9@9

; 737  : }

	pop	ebp
	ret	0
_Mod_StudioTexName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_Mod_ResetStudioAPI PROC

; 950  : {

	push	ebp
	mov	ebp, esp

; 951  : 	pBlendAPI = &gBlendAPI;

	mov	DWORD PTR _pBlendAPI, OFFSET _gBlendAPI

; 952  : }

	pop	ebp
	ret	0
_Mod_ResetStudioAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_side$ = -8						; size = 4
_i$ = -4						; size = 4
_Mod_InitStudioHull PROC

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 68   : 	int	i, side;
; 69   : 
; 70   : 	if( studio_hull[0].planes != NULL )

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	cmp	DWORD PTR _studio_hull[ecx+4], 0
	je	SHORT $LN8@Mod_InitSt

; 71   : 		return;	// already initailized

	jmp	$LN1@Mod_InitSt
$LN8@Mod_InitSt:

; 72   : 
; 73   : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_InitSt
$LN2@Mod_InitSt:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Mod_InitSt:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@Mod_InitSt

; 74   : 	{
; 75   : 		studio_clipnodes[i].planenum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _studio_clipnodes[eax*8], ecx

; 76   : 
; 77   : 		side = i & 1;

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 1
	mov	DWORD PTR _side$[ebp], edx

; 78   : 
; 79   : 		studio_clipnodes[i].children[side] = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _side$[ebp]
	shl	eax, 1
	or	ecx, -1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _studio_clipnodes[eax+edx*8+4], cx

; 80   : 		if( i != 5 ) studio_clipnodes[i].children[side^1] = i + 1;

	cmp	DWORD PTR _i$[ebp], 5
	je	SHORT $LN9@Mod_InitSt
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _studio_clipnodes[ecx+edx*8+4], ax
	jmp	SHORT $LN10@Mod_InitSt
$LN9@Mod_InitSt:

; 81   : 		else studio_clipnodes[i].children[side^1] = CONTENTS_SOLID;

	mov	eax, DWORD PTR _side$[ebp]
	xor	eax, 1
	shl	eax, 1
	mov	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _studio_clipnodes[eax+edx*8+4], cx
$LN10@Mod_InitSt:

; 82   : 	}

	jmp	SHORT $LN2@Mod_InitSt
$LN3@Mod_InitSt:

; 83   : 
; 84   : 	for( i = 0; i < MAXSTUDIOBONES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_InitSt
$LN5@Mod_InitSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_InitSt:
	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jge	SHORT $LN1@Mod_InitSt

; 85   : 	{
; 86   : 		studio_hull[i].clipnodes = studio_clipnodes;

	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[ecx], OFFSET _studio_clipnodes

; 87   : 		studio_hull[i].planes = &studio_planes[i*6];

	imul	edx, DWORD PTR _i$[ebp], 6
	imul	eax, edx, 20
	add	eax, OFFSET _studio_planes
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[ecx+4], eax

; 88   : 		studio_hull[i].firstclipnode = 0;

	imul	edx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[edx+8], 0

; 89   : 		studio_hull[i].lastclipnode = 5;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _studio_hull[eax+12], 5

; 90   : 	}

	jmp	SHORT $LN5@Mod_InitSt
$LN1@Mod_InitSt:

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_InitStudioHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\mod_studio.c
_TEXT	SEGMENT
_Mod_InitStudioAPI PROC

; 926  : {

	push	ebp
	mov	ebp, esp

; 927  : 	static STUDIOAPI	pBlendIface;
; 928  : 
; 929  : 	pBlendAPI = &gBlendAPI;

	mov	DWORD PTR _pBlendAPI, OFFSET _gBlendAPI

; 930  : 
; 931  : 	pBlendIface = (STUDIOAPI)COM_GetProcAddress( svgame.hInstance, "Server_GetBlendingInterface" );

	push	OFFSET $SG137270
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?pBlendIface@?1??Mod_InitStudioAPI@@9@9, eax

; 932  : 	if( pBlendIface && pBlendIface( SV_BLENDING_INTERFACE_VERSION, &pBlendAPI, &gStudioAPI, &studio_transform, &studio_bones ))

	cmp	DWORD PTR ?pBlendIface@?1??Mod_InitStudioAPI@@9@9, 0
	je	SHORT $LN2@Mod_InitSt
	push	OFFSET _studio_bones
	push	OFFSET _studio_transform
	push	OFFSET _gStudioAPI
	push	OFFSET _pBlendAPI
	push	1
	call	DWORD PTR ?pBlendIface@?1??Mod_InitStudioAPI@@9@9
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@Mod_InitSt

; 933  : 	{
; 934  : 		Con_Reportf( "SV_LoadProgs: ^2initailized Server Blending interface ^7ver. %i\n", SV_BLENDING_INTERFACE_VERSION );

	push	1
	push	OFFSET $SG137272
	call	_Con_Reportf
	add	esp, 8

; 935  : 		return;

	jmp	SHORT $LN1@Mod_InitSt
$LN2@Mod_InitSt:

; 936  : 	}
; 937  : 
; 938  : 	// just restore pointer to builtin function
; 939  : 	pBlendAPI = &gBlendAPI;

	mov	DWORD PTR _pBlendAPI, OFFSET _gBlendAPI
$LN1@Mod_InitSt:

; 940  : }

	pop	ebp
	ret	0
_Mod_InitStudioAPI ENDP
_TEXT	ENDS
END
