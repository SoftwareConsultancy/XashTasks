; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\pm_trace.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_pm_hullmins DD	0c1800000r			; -16
	DD	0c1800000r			; -16
	DD	0c2100000r			; -36
	DD	0c1800000r			; -16
	DD	0c1800000r			; -16
	DD	0c1900000r			; -18
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2000000r			; -32
	DD	0c2000000r			; -32
	DD	0c2000000r			; -32
_pm_hullmaxs DD	041800000r			; 16
	DD	041800000r			; 16
	DD	042100000r			; 36
	DD	041800000r			; 16
	DD	041800000r			; 16
	DD	041900000r			; 18
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042000000r			; 32
	DD	042000000r			; 32
CONST	ENDS
PUBLIC	_Pmove_Init
PUBLIC	_PM_InitBoxHull
PUBLIC	_PM_HullForBsp
PUBLIC	_PM_RecursiveHullCheck
PUBLIC	_PM_PlayerTraceExt
PUBLIC	_PM_TestPlayerPosition
PUBLIC	_PM_HullPointContents
PUBLIC	_PM_TruePointContents
PUBLIC	_PM_PointContents
PUBLIC	_PM_ConvertTrace
PUBLIC	_PM_HullForBox
PUBLIC	_PM_HullForStudio
PUBLIC	__real@00000000
PUBLIC	__real@3d000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_Host_IsLocalClient:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_SV_ClipPMoveToEntity:PROC
EXTRN	_CL_ClipPMoveToEntity:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_Mod_HullForStudio:PROC
EXTRN	_Mod_HitgroupForStudioHull:PROC
EXTRN	_World_TransformAABB:PROC
EXTRN	_RankForContents:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_pm_boxplanes DB 078H DUP (?)
_pm_boxclipnodes DQ 06H DUP (?)
_pm_boxhull DB	028H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d000000
CONST	SEGMENT
__real@3d000000 DD 03d000000r			; 0.03125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG134331 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\pm_trace.c', 00H
	ORG $+3
$SG134332 DB	'pe != NULL', 00H
	ORG $+5
$SG134333 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\pm_trace.c', 00H
	ORG $+3
$SG134334 DB	'pe->model != NULL', 00H
	ORG $+6
$SG134339 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\pm_trace.c', 00H
	ORG $+3
$SG134340 DB	'hull != NULL', 00H
	ORG $+3
$SG134385 DB	'PM_RecursiveHullCheck: bad node number %i', 0aH, 00H
	ORG $+1
$SG134398 DB	'^3Warning:^7 trace backed up past 0.0', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
tv155 = -24						; size = 4
tv140 = -20						; size = 4
_size$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_pmove$ = 12						; size = 4
_numhitboxes$ = 16					; size = 4
_PM_HullForStudio PROC

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 188  : 	vec3_t	size;
; 189  : 
; 190  : 	VectorSubtract( pmove->player_maxs[pmove->usehull], pmove->player_mins[pmove->usehull], size );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [ecx+188], 12
	mov	esi, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+324852]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _size$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324900]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [eax+188], 12
	mov	esi, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [esi+eax+324852]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _size$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324900]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [ecx+188], 12
	mov	esi, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+324852]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [ecx+esi]
	movss	DWORD PTR tv140[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _size$[ebp+edx], xmm0

; 191  : 	VectorScale( size, 0.5f, size );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _size$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _size$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv155[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv155[ebp]
	movss	DWORD PTR _size$[ebp+ecx], xmm0

; 192  : 
; 193  : 	return Mod_HullForStudio( pe->studiomodel, pe->frame, pe->sequence, pe->angles, pe->origin, size, pe->controller, pe->blending, numhitboxes, NULL );

	push	0
	mov	edx, DWORD PTR _numhitboxes$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+108]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_Mod_HullForStudio
	add	esp, 40					; 00000028H

; 194  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullForStudio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_PM_HullForBox PROC

; 101  : {

	push	ebp
	mov	ebp, esp

; 102  : 	pm_boxplanes[0].dist = maxs[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pm_boxplanes[eax+12], ecx

; 103  : 	pm_boxplanes[1].dist = mins[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 20					; 00000014H
	shl	ecx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pm_boxplanes[ecx+12], eax

; 104  : 	pm_boxplanes[2].dist = maxs[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 20					; 00000014H
	shl	edx, 1
	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _pm_boxplanes[edx+12], ecx

; 105  : 	pm_boxplanes[3].dist = mins[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _pm_boxplanes[ecx+12], edx

; 106  : 	pm_boxplanes[4].dist = maxs[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 20					; 00000014H
	shl	ecx, 2
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pm_boxplanes[ecx+12], eax

; 107  : 	pm_boxplanes[5].dist = mins[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 20					; 00000014H
	imul	eax, edx, 5
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pm_boxplanes[eax+12], ecx

; 108  : 
; 109  : 	return &pm_boxhull;

	mov	eax, OFFSET _pm_boxhull

; 110  : }

	pop	ebp
	ret	0
_PM_HullForBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_ent$ = 16						; size = 4
_PM_ConvertTrace PROC

; 113  : {

	push	ebp
	mov	ebp, esp

; 114  : 	memcpy( out, in, 48 ); // matched

	push	48					; 00000030H
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 115  : 	out->hitgroup = in->hitgroup;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edx+52], ecx

; 116  : 	out->ent = ent;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+48], eax

; 117  : }

	pop	ebp
	ret	0
_PM_ConvertTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
tv175 = -100						; size = 4
_hull$ = -96						; size = 4
_contents$ = -92					; size = 4
_i$ = -88						; size = 4
_pe$ = -84						; size = 4
_matrix$1 = -80						; size = 64
_test$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_p$ = 12						; size = 4
_PM_PointContents PROC

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 683  : 	int	i, contents;
; 684  : 	hull_t	*hull;
; 685  : 	vec3_t	test;
; 686  : 	physent_t	*pe;
; 687  : 
; 688  : 	// sanity check
; 689  : 	if( !p || !pmove->physents[0].model )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN6@PM_PointCo
	mov	eax, 224				; 000000e0H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [edx+ecx+640], 0
	jne	SHORT $LN5@PM_PointCo
$LN6@PM_PointCo:

; 690  : 		return CONTENTS_NONE;

	xor	eax, eax
	jmp	$LN1@PM_PointCo
$LN5@PM_PointCo:

; 691  : 
; 692  : 	// get base contents from world
; 693  : 	contents = PM_HullPointContents( &pmove->physents[0].model->hulls[0], 0, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	0
	mov	ecx, 224				; 000000e0H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+edx+640]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+208]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _contents$[ebp], eax

; 694  : 
; 695  : 	for( i = 1; i < pmove->numphysent; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@PM_PointCo
$LN2@PM_PointCo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@PM_PointCo:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	$LN3@PM_PointCo

; 696  : 	{
; 697  : 		pe = &pmove->physents[i];

	imul	edx, DWORD PTR _i$[ebp], 224
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 698  : 
; 699  : 		if( pe->solid != SOLID_NOT ) // disabled ?

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN7@PM_PointCo

; 700  : 			continue;

	jmp	SHORT $LN2@PM_PointCo
$LN7@PM_PointCo:

; 701  : 
; 702  : 		// only brushes can have special contents
; 703  : 		if( !pe->model ) continue;

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN8@PM_PointCo
	jmp	SHORT $LN2@PM_PointCo
$LN8@PM_PointCo:

; 704  : 
; 705  : 		// check water brushes accuracy
; 706  : 		hull = &pe->model->hulls[0];

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], edx

; 707  : 
; 708  : 		if( FBitSet( pe->model->flags, MODEL_HAS_ORIGIN ) && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 2
	je	$LN9@PM_PointCo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PM_PointCo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PM_PointCo
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@PM_PointCo
$LN11@PM_PointCo:

; 709  : 		{
; 710  : 			matrix4x4	matrix;
; 711  : 	
; 712  : 			Matrix4x4_CreateFromEntity( matrix, pe->angles, pe->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	lea	eax, DWORD PTR _matrix$1[ebp]
	push	eax
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 713  : 			Matrix4x4_VectorITransform( matrix, p, test );

	lea	ecx, DWORD PTR _test$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$1[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 714  : 		}

	jmp	$LN10@PM_PointCo
$LN9@PM_PointCo:

; 715  : 		else
; 716  : 		{
; 717  : 			// offset the test point appropriately for this hull.
; 718  : 			VectorSubtract( p, pe->origin, test );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [esi+ecx+36]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+36]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _test$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx+36]
	movss	DWORD PTR tv175[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv175[ebp]
	movss	DWORD PTR _test$[ebp+ecx], xmm0
$LN10@PM_PointCo:

; 719  : 		}
; 720  : 
; 721  : 		// test hull for intersection with this model
; 722  : 		if( PM_HullPointContents( hull, hull->firstclipnode, test ) == CONTENTS_EMPTY )

	lea	edx, DWORD PTR _test$[ebp]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN12@PM_PointCo

; 723  : 			continue;

	jmp	$LN2@PM_PointCo
$LN12@PM_PointCo:

; 724  : 
; 725  : 		// compare contents ranking
; 726  : 		if( RankForContents( pe->skin ) > RankForContents( contents ))

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	call	_RankForContents
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _contents$[ebp]
	push	edx
	call	_RankForContents
	add	esp, 4
	cmp	esi, eax
	jle	SHORT $LN13@PM_PointCo

; 727  : 			contents = pe->skin; // new content has more priority

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _contents$[ebp], ecx
$LN13@PM_PointCo:

; 728  : 	}

	jmp	$LN2@PM_PointCo
$LN3@PM_PointCo:

; 729  : 
; 730  : 	return contents;

	mov	eax, DWORD PTR _contents$[ebp]
$LN1@PM_PointCo:

; 731  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_PointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
_hull$ = -4						; size = 4
_pmove$ = 8						; size = 4
_p$ = 12						; size = 4
_PM_TruePointContents PROC

; 662  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 663  : 	hull_t	*hull = &pmove->physents[0].model->hulls[0];

	mov	eax, 224				; 000000e0H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [edx+ecx+640]
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 664  : 
; 665  : 	if( hull )

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN2@PM_TruePoi

; 666  : 	{
; 667  : 		return PM_HullPointContents( hull, hull->firstclipnode, p );

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@PM_TruePoi

; 668  : 	}

	jmp	SHORT $LN1@PM_TruePoi
$LN2@PM_TruePoi:

; 669  : 	else
; 670  : 	{
; 671  : 		return CONTENTS_EMPTY;

	or	eax, -1
$LN1@PM_TruePoi:

; 672  : 	}
; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
tv144 = -12						; size = 4
tv139 = -8						; size = 4
_plane$ = -4						; size = 4
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p$ = 16						; size = 4
_PM_HullPointContents PROC

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 127  : 	mplane_t		*plane;
; 128  : 
; 129  : 	if( !hull || !hull->planes )	// fantom bmodels?

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN5@PM_HullPoi
	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@PM_HullPoi
$LN5@PM_HullPoi:

; 130  : 		return CONTENTS_NONE;

	xor	eax, eax
	jmp	$LN1@PM_HullPoi
$LN4@PM_HullPoi:

; 131  : 
; 132  : 	while( num >= 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jl	$LN3@PM_HullPoi

; 133  : 	{
; 134  : 		plane = &hull->planes[hull->clipnodes[num].planenum];

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _num$[ebp]
	imul	ecx, DWORD PTR [edx+eax*8], 20
	mov	edx, DWORD PTR _hull$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _plane$[ebp], ecx

; 135  : 		num = hull->clipnodes[num].children[PlaneDiff( p, plane ) < 0];

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN7@PM_HullPoi
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN8@PM_HullPoi
$LN7@PM_HullPoi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv139[ebp], xmm0
$LN8@PM_HullPoi:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv139[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN9@PM_HullPoi
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN10@PM_HullPoi
$LN9@PM_HullPoi:
	mov	DWORD PTR tv144[ebp], 0
$LN10@PM_HullPoi:
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _num$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR tv144[ebp]
	movsx	edx, WORD PTR [eax+ecx*2+4]
	mov	DWORD PTR _num$[ebp], edx

; 136  : 	}

	jmp	$LN4@PM_HullPoi
$LN3@PM_HullPoi:

; 137  : 	return num;

	mov	eax, DWORD PTR _num$[ebp]
$LN1@PM_HullPoi:

; 138  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
$T1 = -360						; size = 68
tv471 = -292						; size = 4
tv431 = -288						; size = 4
tv282 = -284						; size = 4
tv246 = -280						; size = 4
_hullcount$ = -276					; size = 4
_transform_bbox$2 = -272				; size = 4
_i$ = -268						; size = 4
_hull$ = -264						; size = 4
_j$ = -260						; size = 4
_pe$ = -256						; size = 4
_trace$ = -252						; size = 68
_trace$3 = -184						; size = 68
_matrix$4 = -116					; size = 64
_maxs$ = -52						; size = 12
_pos_l$ = -40						; size = 12
_mins$ = -28						; size = 12
_offset$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_pos$ = 12						; size = 4
_ptrace$ = 16						; size = 4
_pmFilter$ = 20						; size = 4
_PM_TestPlayerPosition PROC

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 532  : 	int	i, j, hullcount;
; 533  : 	vec3_t	pos_l, offset;
; 534  : 	hull_t	*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 535  : 	vec3_t	mins, maxs;
; 536  : 	pmtrace_t trace;
; 537  : 	physent_t *pe;
; 538  : 
; 539  : 	trace = PM_PlayerTraceExt( pmove, pmove->origin, pmove->origin, 0, pmove->numphysent, pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _pmove$[ebp]
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pmove$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 540  : 	if( ptrace ) *ptrace = trace;

	cmp	DWORD PTR _ptrace$[ebp], 0
	je	SHORT $LN11@PM_TestPla
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace$[ebp]
	mov	edi, DWORD PTR _ptrace$[ebp]
	rep movsd
$LN11@PM_TestPla:

; 541  : 
; 542  : 	for( i = 0; i < pmove->numphysent; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_TestPla
$LN2@PM_TestPla:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@PM_TestPla:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	$LN3@PM_TestPla

; 543  : 	{
; 544  : 		pe = &pmove->physents[i];

	imul	edx, DWORD PTR _i$[ebp], 224
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 545  : 
; 546  : 		// run custom user filter
; 547  : 		if( pmFilter != NULL )

	cmp	DWORD PTR _pmFilter$[ebp], 0
	je	SHORT $LN13@PM_TestPla

; 548  : 		{
; 549  : 			if( pmFilter( pe ))

	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	DWORD PTR _pmFilter$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@PM_TestPla

; 550  : 				continue;

	jmp	SHORT $LN2@PM_TestPla
$LN13@PM_TestPla:

; 551  : 		}
; 552  : 
; 553  : 		if( pe->model != NULL && pe->solid == SOLID_NOT && pe->skin != CONTENTS_NONE )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN14@PM_TestPla
	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+96], 0
	jne	SHORT $LN14@PM_TestPla
	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+100], 0
	je	SHORT $LN14@PM_TestPla

; 554  : 			continue;

	jmp	SHORT $LN2@PM_TestPla
$LN14@PM_TestPla:

; 555  : 
; 556  : 		hullcount = 1;

	mov	DWORD PTR _hullcount$[ebp], 1

; 557  : 
; 558  : 		if( pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	$LN15@PM_TestPla

; 559  : 		{
; 560  : 			VectorCopy( pmove->player_mins[pmove->usehull], mins );

	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _mins$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _mins$[ebp+eax], ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR _mins$[ebp+ecx], edx

; 561  : 			VectorCopy( pmove->player_maxs[pmove->usehull], maxs );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _maxs$[ebp+ecx], edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _maxs$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324900]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _maxs$[ebp+eax], ecx

; 562  : 			VectorClear( offset );

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0

; 563  : 		}

	jmp	$LN20@PM_TestPla
$LN15@PM_TestPla:

; 564  : 		else if( pe->model )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN17@PM_TestPla

; 565  : 		{
; 566  : 			hull = PM_HullForBsp( pe, pmove, offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 567  : 		}

	jmp	$LN20@PM_TestPla
$LN17@PM_TestPla:

; 568  : 		else if( PM_AllowHitBoxTrace( pe->studiomodel, pmove->usehull ))

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	$LN19@PM_TestPla
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN19@PM_TestPla
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 512				; 00000200H
	jne	SHORT $LN21@PM_TestPla
	mov	ecx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [ecx+188], 2
	jne	SHORT $LN19@PM_TestPla
$LN21@PM_TestPla:

; 569  : 		{
; 570  : 			hull = PM_HullForStudio( pe, pmove, &hullcount );

	lea	edx, DWORD PTR _hullcount$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_HullForStudio
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 571  : 			VectorClear( offset );

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0

; 572  : 		}

	jmp	$LN20@PM_TestPla
$LN19@PM_TestPla:

; 573  : 		else
; 574  : 		{
; 575  : 			VectorSubtract( pe->mins, pmove->player_maxs[pmove->usehull], mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324900]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+56]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324900]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324900]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv246[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR _mins$[ebp+ecx], xmm0

; 576  : 			VectorSubtract( pe->maxs, pmove->player_mins[pmove->usehull], maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+edx+324852]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+68]
	subss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _maxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _maxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv282[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv282[ebp]
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 577  : 
; 578  : 			hull = PM_HullForBox( mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	_PM_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 579  : 			VectorCopy( pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _offset$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR _offset$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _offset$[ebp+ecx], eax
$LN20@PM_TestPla:

; 580  : 		}
; 581  : 
; 582  : 		// CM_TransformedPointContents :-)
; 583  : 		if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+96], 4
	jne	$LN22@PM_TestPla
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@PM_TestPla
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN22@PM_TestPla
$LN24@PM_TestPla:

; 584  : 		{
; 585  : 			qboolean	transform_bbox = false;

	mov	DWORD PTR _transform_bbox$2[ebp], 0

; 586  : 			matrix4x4	matrix;
; 587  : 
; 588  : 			if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 8
	je	$LN26@PM_TestPla

; 589  : 			{
; 590  : 				if(( check_angles( pe->angles[0] ) || check_angles( pe->angles[2] )) && pmove->usehull != 2 )

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, 90					; 0000005aH
	je	$LN28@PM_TestPla
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 180				; 000000b4H
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 270				; 0000010eH
	je	$LN28@PM_TestPla
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, -90				; ffffffa6H
	je	$LN28@PM_TestPla
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -180				; ffffff4cH
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -270				; fffffef2H
	je	$LN28@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 90					; 0000005aH
	je	$LN28@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 180				; 000000b4H
	je	SHORT $LN28@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 270				; 0000010eH
	je	SHORT $LN28@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -90				; ffffffa6H
	je	SHORT $LN28@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -180				; ffffff4cH
	je	SHORT $LN28@PM_TestPla
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -270				; fffffef2H
	jne	SHORT $LN26@PM_TestPla
$LN28@PM_TestPla:
	mov	ecx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [ecx+188], 2
	je	SHORT $LN26@PM_TestPla

; 591  : 					transform_bbox = true;

	mov	DWORD PTR _transform_bbox$2[ebp], 1
$LN26@PM_TestPla:

; 592  :                               }
; 593  : 
; 594  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$2[ebp], 0
	je	SHORT $LN29@PM_TestPla

; 595  : 				Matrix4x4_CreateFromEntity( matrix, pe->angles, pe->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _matrix$4[ebp]
	push	ecx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN30@PM_TestPla
$LN29@PM_TestPla:

; 596  : 			else Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _matrix$4[ebp]
	push	ecx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN30@PM_TestPla:

; 597  : 
; 598  : 			Matrix4x4_VectorITransform( matrix, pos, pos_l );

	lea	edx, DWORD PTR _pos_l$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$4[ebp]
	push	ecx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 599  :                               
; 600  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$2[ebp], 0
	je	$LN6@PM_TestPla

; 601  : 			{
; 602  : 				World_TransformAABB( matrix, pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], mins, maxs );

	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324900]
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324852]
	push	edx
	lea	eax, DWORD PTR _matrix$4[ebp]
	push	eax
	call	_World_TransformAABB
	add	esp, 20					; 00000014H

; 603  : 				VectorSubtract( hull->clip_mins, mins, offset );	// calc new local offset

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _mins$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+edx]
	movss	DWORD PTR tv431[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv431[ebp]
	movss	DWORD PTR _offset$[ebp+ecx], xmm0

; 604  : 
; 605  : 				for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@PM_TestPla
$LN5@PM_TestPla:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@PM_TestPla:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@PM_TestPla

; 606  : 				{
; 607  : 					if( pos_l[j] >= 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _pos_l$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN32@PM_TestPla

; 608  : 						pos_l[j] -= offset[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _pos_l$[ebp+ecx*4]
	subss	xmm0, DWORD PTR _offset$[ebp+edx*4]
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _pos_l$[ebp+eax*4], xmm0
	jmp	SHORT $LN33@PM_TestPla
$LN32@PM_TestPla:

; 609  : 					else pos_l[j] += offset[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _pos_l$[ebp+ecx*4]
	addss	xmm0, DWORD PTR _offset$[ebp+edx*4]
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _pos_l$[ebp+eax*4], xmm0
$LN33@PM_TestPla:

; 610  : 				}

	jmp	SHORT $LN5@PM_TestPla
$LN6@PM_TestPla:

; 611  : 			}
; 612  : 		}

	jmp	$LN23@PM_TestPla
$LN22@PM_TestPla:

; 613  : 		else
; 614  : 		{
; 615  : 			// offset the test point appropriately for this hull.
; 616  : 			VectorSubtract( pos, offset, pos_l );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _pos_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _pos_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	movss	DWORD PTR tv471[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv471[ebp]
	movss	DWORD PTR _pos_l$[ebp+ecx], xmm0
$LN23@PM_TestPla:

; 617  : 		}
; 618  : 
; 619  : 		if( pe->solid == SOLID_CUSTOM )

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 5
	jne	$LN34@PM_TestPla

; 620  : 		{
; 621  : 			pmtrace_t	trace;
; 622  : 
; 623  : 			memset( &trace, 0, sizeof( trace ));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _trace$3[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 624  : 			VectorCopy( pos, trace.endpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _trace$3[ebp+ecx+20], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace$3[ebp+ecx+20], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _trace$3[ebp+edx+20], ecx

; 625  : 			trace.allsolid = true;

	mov	DWORD PTR _trace$3[ebp], 1

; 626  : 			trace.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace$3[ebp+16], xmm0

; 627  : 
; 628  : 			// run custom sweep callback
; 629  : 			if( pmove->server || Host_IsLocalClient( ))

	mov	edx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN38@PM_TestPla
	call	_Host_IsLocalClient
	test	eax, eax
	je	SHORT $LN36@PM_TestPla
$LN38@PM_TestPla:

; 630  : 				SV_ClipPMoveToEntity( pe, pos, mins, maxs, pos, &trace );

	lea	eax, DWORD PTR _trace$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_SV_ClipPMoveToEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN37@PM_TestPla
$LN36@PM_TestPla:

; 631  : 			else CL_ClipPMoveToEntity( pe, pos, mins, maxs, pos, &trace );

	lea	eax, DWORD PTR _trace$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_CL_ClipPMoveToEntity
	add	esp, 24					; 00000018H
$LN37@PM_TestPla:

; 632  : 
; 633  : 			// if we inside the custom hull
; 634  : 			if( trace.allsolid )

	cmp	DWORD PTR _trace$3[ebp], 0
	je	SHORT $LN39@PM_TestPla

; 635  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	$LN1@PM_TestPla
$LN39@PM_TestPla:

; 636  : 		}

	jmp	$LN9@PM_TestPla
$LN34@PM_TestPla:

; 637  : 		else if( hullcount == 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jne	SHORT $LN40@PM_TestPla

; 638  : 		{
; 639  : 			if( PM_HullPointContents( hull, hull->firstclipnode, pos_l ) == CONTENTS_SOLID )

	lea	eax, DWORD PTR _pos_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN42@PM_TestPla

; 640  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@PM_TestPla
$LN42@PM_TestPla:

; 641  : 		}

	jmp	SHORT $LN9@PM_TestPla
$LN40@PM_TestPla:

; 642  : 		else
; 643  : 		{
; 644  : 			for( j = 0; j < hullcount; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@PM_TestPla
$LN8@PM_TestPla:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@PM_TestPla:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _hullcount$[ebp]
	jge	SHORT $LN9@PM_TestPla

; 645  : 			{
; 646  : 				if( PM_HullPointContents( &hull[j], hull[j].firstclipnode, pos_l ) == CONTENTS_SOLID )

	lea	eax, DWORD PTR _pos_l$[ebp]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 40
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 40
	add	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN43@PM_TestPla

; 647  : 					return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@PM_TestPla
$LN43@PM_TestPla:

; 648  : 			}

	jmp	SHORT $LN8@PM_TestPla
$LN9@PM_TestPla:

; 649  : 		}
; 650  : 	}

	jmp	$LN2@PM_TestPla
$LN3@PM_TestPla:

; 651  : 
; 652  : 	return -1; // didn't hit anything

	or	eax, -1
$LN1@PM_TestPla:

; 653  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TestPlayerPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
tv769 = -408						; size = 4
tv619 = -404						; size = 4
tv598 = -400						; size = 4
tv541 = -396						; size = 4
tv388 = -392						; size = 4
tv352 = -388						; size = 4
tv298 = -384						; size = 4
tv262 = -380						; size = 4
_last_hitgroup$1 = -376					; size = 4
_rotated$ = -372					; size = 4
_hullcount$ = -368					; size = 4
_transform_bbox$ = -364					; size = 4
_i$ = -360						; size = 4
_hull$ = -356						; size = 4
_j$ = -352						; size = 4
_pe$ = -348						; size = 4
_trace_total$ = -344					; size = 68
_trace_hitbox$ = -276					; size = 68
_trace_bbox$ = -208					; size = 68
_matrix$ = -140						; size = 64
_temp$ = -76						; size = 12
_start_l$ = -64						; size = 12
_end_l$ = -52						; size = 12
_maxs$ = -40						; size = 12
_mins$ = -28						; size = 12
_offset$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_pmove$ = 12						; size = 4
_start$ = 16						; size = 4
_end$ = 20						; size = 4
_flags$ = 24						; size = 4
_numents$ = 28						; size = 4
_ents$ = 32						; size = 4
_ignore_pe$ = 36					; size = 4
_pmFilter$ = 40						; size = 4
_PM_PlayerTraceExt PROC

; 317  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 318  : 	physent_t	*pe;
; 319  : 	matrix4x4	matrix;
; 320  : 	pmtrace_t	trace_bbox;
; 321  : 	pmtrace_t	trace_hitbox;
; 322  : 	pmtrace_t	trace_total;
; 323  : 	vec3_t	offset, start_l, end_l;
; 324  : 	vec3_t	temp, mins, maxs;
; 325  : 	int	i, j, hullcount;
; 326  : 	qboolean	rotated, transform_bbox;
; 327  : 	hull_t	*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 328  : 
; 329  : 	memset( &trace_total, 0, sizeof( trace_total ));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _trace_total$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 330  : 	VectorCopy( end, trace_total.endpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _trace_total$[ebp+ecx+20], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_total$[ebp+ecx+20], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _trace_total$[ebp+edx+20], ecx

; 331  : 	trace_total.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_total$[ebp+16], xmm0

; 332  : 	trace_total.ent = -1;

	mov	DWORD PTR _trace_total$[ebp+48], -1

; 333  : 
; 334  : 	for( i = 0; i < numents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_PlayerT
$LN2@PM_PlayerT:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@PM_PlayerT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numents$[ebp]
	jge	$LN3@PM_PlayerT

; 335  : 	{
; 336  : 		pe = &ents[i];

	imul	ecx, DWORD PTR _i$[ebp], 224
	add	ecx, DWORD PTR _ents$[ebp]
	mov	DWORD PTR _pe$[ebp], ecx

; 337  : 
; 338  : 		if( i != 0 && ( flags & PM_WORLD_ONLY ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN11@PM_PlayerT
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8
	je	SHORT $LN11@PM_PlayerT

; 339  : 			break;

	jmp	$LN3@PM_PlayerT
$LN11@PM_PlayerT:

; 340  : 
; 341  : 		// run custom user filter
; 342  : 		if( pmFilter != NULL )

	cmp	DWORD PTR _pmFilter$[ebp], 0
	je	SHORT $LN12@PM_PlayerT

; 343  : 		{
; 344  : 			if( pmFilter( pe ))

	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	DWORD PTR _pmFilter$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@PM_PlayerT

; 345  : 				continue;

	jmp	SHORT $LN2@PM_PlayerT
$LN14@PM_PlayerT:

; 346  : 		}

	jmp	SHORT $LN16@PM_PlayerT
$LN12@PM_PlayerT:

; 347  : 		else if( ignore_pe != -1 )

	cmp	DWORD PTR _ignore_pe$[ebp], -1
	je	SHORT $LN16@PM_PlayerT

; 348  : 		{
; 349  : 			if( i == ignore_pe )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _ignore_pe$[ebp]
	jne	SHORT $LN16@PM_PlayerT

; 350  : 				continue;

	jmp	SHORT $LN2@PM_PlayerT
$LN16@PM_PlayerT:

; 351  : 		}
; 352  : 
; 353  : 		if( pe->model != NULL && pe->solid == SOLID_NOT && pe->skin != CONTENTS_NONE )

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN17@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN17@PM_PlayerT
	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	je	SHORT $LN17@PM_PlayerT

; 354  : 			continue;

	jmp	$LN2@PM_PlayerT
$LN17@PM_PlayerT:

; 355  : 
; 356  : 		if(( flags & PM_GLASS_IGNORE ) && pe->rendermode != kRenderNormal )

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	je	SHORT $LN18@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN18@PM_PlayerT

; 357  : 			continue;

	jmp	$LN2@PM_PlayerT
$LN18@PM_PlayerT:

; 358  : 
; 359  : 		if(( flags & PM_CUSTOM_IGNORE ) && pe->solid == SOLID_CUSTOM )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN19@PM_PlayerT
	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 5
	jne	SHORT $LN19@PM_PlayerT

; 360  : 			continue;

	jmp	$LN2@PM_PlayerT
$LN19@PM_PlayerT:

; 361  : 
; 362  : 		hullcount = 1;

	mov	DWORD PTR _hullcount$[ebp], 1

; 363  : 
; 364  : 		if( pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	$LN20@PM_PlayerT

; 365  : 		{
; 366  : 			VectorCopy( pmove->player_mins[pmove->usehull], mins );

	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _mins$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _mins$[ebp+eax], ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR _mins$[ebp+ecx], edx

; 367  : 			VectorCopy( pmove->player_maxs[pmove->usehull], maxs );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _maxs$[ebp+ecx], edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _maxs$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324900]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _maxs$[ebp+eax], ecx

; 368  : 			VectorClear( offset );

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0

; 369  : 		}

	jmp	$LN25@PM_PlayerT
$LN20@PM_PlayerT:

; 370  : 		else if( pe->model )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN22@PM_PlayerT

; 371  : 		{
; 372  : 			hull = PM_HullForBsp( pe, pmove, offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 373  : 		}

	jmp	$LN25@PM_PlayerT
$LN22@PM_PlayerT:

; 374  : 		else
; 375  : 		{
; 376  : 			if( pe->studiomodel )

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	$LN24@PM_PlayerT

; 377  : 			{
; 378  : 				if( FBitSet( flags, PM_STUDIO_IGNORE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	je	SHORT $LN26@PM_PlayerT

; 379  : 					continue;

	jmp	$LN2@PM_PlayerT
$LN26@PM_PlayerT:

; 380  : 
; 381  : 				if( PM_AllowHitBoxTrace( pe->studiomodel, pmove->usehull ) && !FBitSet( flags, PM_STUDIO_BOX ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN27@PM_PlayerT
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx+68], 3
	jne	SHORT $LN27@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 512				; 00000200H
	jne	SHORT $LN29@PM_PlayerT
	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+188], 2
	jne	SHORT $LN27@PM_PlayerT
$LN29@PM_PlayerT:
	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 2
	jne	SHORT $LN27@PM_PlayerT

; 382  : 				{
; 383  : 					hull = PM_HullForStudio( pe, pmove, &hullcount );

	lea	edx, DWORD PTR _hullcount$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_HullForStudio
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 384  : 					VectorClear( offset );

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+edx], xmm0

; 385  : 				}

	jmp	$LN28@PM_PlayerT
$LN27@PM_PlayerT:

; 386  : 				else
; 387  : 				{
; 388  : 					VectorSubtract( pe->mins, pmove->player_maxs[pmove->usehull], mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324900]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+56]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324900]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324900]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv262[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv262[ebp]
	movss	DWORD PTR _mins$[ebp+ecx], xmm0

; 389  : 					VectorSubtract( pe->maxs, pmove->player_mins[pmove->usehull], maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+edx+324852]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+68]
	subss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _maxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _maxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv298[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv298[ebp]
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 390  : 
; 391  : 					hull = PM_HullForBox( mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	_PM_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 392  : 					VectorCopy( pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _offset$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR _offset$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _offset$[ebp+ecx], eax
$LN28@PM_PlayerT:

; 393  : 				}
; 394  : 			}			

	jmp	$LN25@PM_PlayerT
$LN24@PM_PlayerT:

; 395  : 			else
; 396  : 			{
; 397  : 				VectorSubtract( pe->mins, pmove->player_maxs[pmove->usehull], mins );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324900]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+edx+324900]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+56]
	subss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+edx+324900]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+56]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv352[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv352[ebp]
	movss	DWORD PTR _mins$[ebp+edx], xmm0

; 398  : 				VectorSubtract( pe->maxs, pmove->player_mins[pmove->usehull], maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324852]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324852]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv388[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv388[ebp]
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0

; 399  : 
; 400  : 				hull = PM_HullForBox( mins, maxs );

	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	call	_PM_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 401  : 				VectorCopy( pe->origin, offset );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [eax+edx+36]
	mov	DWORD PTR _offset$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _offset$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+36]
	mov	DWORD PTR _offset$[ebp+edx], ecx
$LN25@PM_PlayerT:

; 402  : 			}
; 403  : 
; 404  : 		}
; 405  : 
; 406  : 		if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 4
	jne	SHORT $LN30@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@PM_PlayerT
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@PM_PlayerT
$LN32@PM_PlayerT:

; 407  : 			rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN31@PM_PlayerT
$LN30@PM_PlayerT:

; 408  : 		else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN31@PM_PlayerT:

; 409  : 
; 410  : 		if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ))

	mov	ecx, DWORD PTR _host+34748
	and	ecx, 8
	je	$LN33@PM_PlayerT

; 411  : 		{
; 412  : 			if(( check_angles( pe->angles[0] ) || check_angles( pe->angles[2] )) && pmove->usehull != 2 )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 90					; 0000005aH
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 180				; 000000b4H
	je	$LN38@PM_PlayerT
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, 270				; 0000010eH
	je	$LN38@PM_PlayerT
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -90				; ffffffa6H
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -180				; ffffff4cH
	je	$LN38@PM_PlayerT
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, -270				; fffffef2H
	je	$LN38@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, 90					; 0000005aH
	je	$LN38@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, 180				; 000000b4H
	je	SHORT $LN38@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, 270				; 0000010eH
	je	SHORT $LN38@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, -90				; ffffffa6H
	je	SHORT $LN38@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, -180				; ffffff4cH
	je	SHORT $LN38@PM_PlayerT
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+84]
	cmp	ecx, -270				; fffffef2H
	jne	SHORT $LN35@PM_PlayerT
$LN38@PM_PlayerT:
	mov	edx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [edx+188], 2
	je	SHORT $LN35@PM_PlayerT

; 413  : 				transform_bbox = true;

	mov	DWORD PTR _transform_bbox$[ebp], 1
	jmp	SHORT $LN36@PM_PlayerT
$LN35@PM_PlayerT:

; 414  : 			else transform_bbox = false;

	mov	DWORD PTR _transform_bbox$[ebp], 0
$LN36@PM_PlayerT:

; 415  : 		}

	jmp	SHORT $LN34@PM_PlayerT
$LN33@PM_PlayerT:

; 416  : 		else transform_bbox = false;

	mov	DWORD PTR _transform_bbox$[ebp], 0
$LN34@PM_PlayerT:

; 417  : 
; 418  : 		if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	$LN39@PM_PlayerT

; 419  : 		{
; 420  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$[ebp], 0
	je	SHORT $LN41@PM_PlayerT

; 421  : 				Matrix4x4_CreateFromEntity( matrix, pe->angles, pe->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN42@PM_PlayerT
$LN41@PM_PlayerT:

; 422  : 			else Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN42@PM_PlayerT:

; 423  : 
; 424  : 			Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 425  : 			Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 426  :                               
; 427  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$[ebp], 0
	je	$LN6@PM_PlayerT

; 428  : 			{
; 429  : 				World_TransformAABB( matrix, pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324900]
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324852]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_World_TransformAABB
	add	esp, 20					; 00000014H

; 430  : 				VectorSubtract( hull->clip_mins, mins, offset );	// calc new local offset

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+16]
	subss	xmm0, DWORD PTR _mins$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+eax]
	movss	DWORD PTR tv541[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv541[ebp]
	movss	DWORD PTR _offset$[ebp+edx], xmm0

; 431  : 
; 432  : 				for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@PM_PlayerT
$LN5@PM_PlayerT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@PM_PlayerT:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@PM_PlayerT

; 433  : 				{
; 434  : 					if( start_l[j] >= 0.0f )

	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+ecx*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN44@PM_PlayerT

; 435  : 						start_l[j] -= offset[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+edx*4]
	subss	xmm0, DWORD PTR _offset$[ebp+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _start_l$[ebp+ecx*4], xmm0
	jmp	SHORT $LN45@PM_PlayerT
$LN44@PM_PlayerT:

; 436  : 					else start_l[j] += offset[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+edx*4]
	addss	xmm0, DWORD PTR _offset$[ebp+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _start_l$[ebp+ecx*4], xmm0
$LN45@PM_PlayerT:

; 437  : 					if( end_l[j] >= 0.0f )

	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+edx*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN46@PM_PlayerT

; 438  : 						end_l[j] -= offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end_l$[ebp+edx*4], xmm0
	jmp	SHORT $LN47@PM_PlayerT
$LN46@PM_PlayerT:

; 439  : 					else end_l[j] += offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	addss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end_l$[ebp+edx*4], xmm0
$LN47@PM_PlayerT:

; 440  : 				}

	jmp	$LN5@PM_PlayerT
$LN6@PM_PlayerT:

; 441  : 			}
; 442  : 		}

	jmp	$LN40@PM_PlayerT
$LN39@PM_PlayerT:

; 443  : 		else
; 444  : 		{
; 445  : 			VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv598[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv598[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 446  : 			VectorSubtract( end, offset, end_l );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	movss	DWORD PTR tv619[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv619[ebp]
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
$LN40@PM_PlayerT:

; 447  : 		}
; 448  : 
; 449  : 		memset( &trace_bbox, 0, sizeof( trace_bbox ));

	push	68					; 00000044H
	push	0
	lea	edx, DWORD PTR _trace_bbox$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 450  : 		VectorCopy( end, trace_bbox.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace_bbox$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace_bbox$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_bbox$[ebp+ecx+20], eax

; 451  : 		trace_bbox.allsolid = true;

	mov	DWORD PTR _trace_bbox$[ebp], 1

; 452  : 		trace_bbox.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_bbox$[ebp+16], xmm0

; 453  : 
; 454  : 		if( hullcount < 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jge	SHORT $LN48@PM_PlayerT

; 455  : 		{
; 456  : 			// g-cont. probably this never happens
; 457  : 			trace_bbox.allsolid = false;

	mov	DWORD PTR _trace_bbox$[ebp], 0

; 458  : 		}

	jmp	$LN56@PM_PlayerT
$LN48@PM_PlayerT:

; 459  : 		else if( pe->solid == SOLID_CUSTOM )

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+96], 5
	jne	SHORT $LN50@PM_PlayerT

; 460  : 		{
; 461  : 			// run custom sweep callback
; 462  : 			if( pmove->server || Host_IsLocalClient( ))

	mov	edx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN54@PM_PlayerT
	call	_Host_IsLocalClient
	test	eax, eax
	je	SHORT $LN52@PM_PlayerT
$LN54@PM_PlayerT:

; 463  : 				SV_ClipPMoveToEntity( pe, start, mins, maxs, end, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_SV_ClipPMoveToEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN53@PM_PlayerT
$LN52@PM_PlayerT:

; 464  : 			else CL_ClipPMoveToEntity( pe, start, mins, maxs, end, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_CL_ClipPMoveToEntity
	add	esp, 24					; 00000018H
$LN53@PM_PlayerT:

; 465  : 		}

	jmp	$LN56@PM_PlayerT
$LN50@PM_PlayerT:

; 466  : 		else if( hullcount == 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jne	SHORT $LN55@PM_PlayerT

; 467  : 		{
; 468  : 			PM_RecursiveHullCheck( hull, hull->firstclipnode, 0, 1, start_l, end_l, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 469  : 		}

	jmp	$LN56@PM_PlayerT
$LN55@PM_PlayerT:

; 470  : 		else
; 471  : 		{
; 472  : 			int	last_hitgroup;
; 473  : 
; 474  : 			for( last_hitgroup = 0, j = 0; j < hullcount; j++ )

	mov	DWORD PTR _last_hitgroup$1[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@PM_PlayerT
$LN8@PM_PlayerT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@PM_PlayerT:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _hullcount$[ebp]
	jge	$LN9@PM_PlayerT

; 475  : 			{
; 476  : 				memset( &trace_hitbox, 0, sizeof( trace_hitbox ));

	push	68					; 00000044H
	push	0
	lea	edx, DWORD PTR _trace_hitbox$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 477  : 				VectorCopy( end, trace_hitbox.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace_hitbox$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace_hitbox$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_hitbox$[ebp+ecx+20], eax

; 478  : 				trace_hitbox.allsolid = true;

	mov	DWORD PTR _trace_hitbox$[ebp], 1

; 479  : 				trace_hitbox.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_hitbox$[ebp+16], xmm0

; 480  : 
; 481  : 				PM_RecursiveHullCheck( &hull[j], hull[j].firstclipnode, 0, 1, start_l, end_l, &trace_hitbox );

	lea	ecx, DWORD PTR _trace_hitbox$[ebp]
	push	ecx
	lea	edx, DWORD PTR _end_l$[ebp]
	push	edx
	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _j$[ebp], 40
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 40
	add	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 482  : 
; 483  : 				if( j == 0 || trace_hitbox.allsolid || trace_hitbox.startsolid || trace_hitbox.fraction < trace_bbox.fraction )

	cmp	DWORD PTR _j$[ebp], 0
	je	SHORT $LN58@PM_PlayerT
	cmp	DWORD PTR _trace_hitbox$[ebp], 0
	jne	SHORT $LN58@PM_PlayerT
	cmp	DWORD PTR _trace_hitbox$[ebp+4], 0
	jne	SHORT $LN58@PM_PlayerT
	movss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	comiss	xmm0, DWORD PTR _trace_hitbox$[ebp+16]
	jbe	SHORT $LN57@PM_PlayerT
$LN58@PM_PlayerT:

; 484  : 				{
; 485  : 					if( trace_bbox.startsolid )

	cmp	DWORD PTR _trace_bbox$[ebp+4], 0
	je	SHORT $LN59@PM_PlayerT

; 486  : 					{
; 487  : 						trace_bbox = trace_hitbox;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_hitbox$[ebp]
	lea	edi, DWORD PTR _trace_bbox$[ebp]
	rep movsd

; 488  : 						trace_bbox.startsolid = true;

	mov	DWORD PTR _trace_bbox$[ebp+4], 1

; 489  : 					}

	jmp	SHORT $LN60@PM_PlayerT
$LN59@PM_PlayerT:

; 490  : 					else trace_bbox = trace_hitbox;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_hitbox$[ebp]
	lea	edi, DWORD PTR _trace_bbox$[ebp]
	rep movsd
$LN60@PM_PlayerT:

; 491  : 
; 492  : 					last_hitgroup = j;

	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _last_hitgroup$1[ebp], edx
$LN57@PM_PlayerT:

; 493  : 				}
; 494  : 			}

	jmp	$LN8@PM_PlayerT
$LN9@PM_PlayerT:

; 495  : 
; 496  : 			trace_bbox.hitgroup = Mod_HitgroupForStudioHull( last_hitgroup );

	mov	eax, DWORD PTR _last_hitgroup$1[ebp]
	push	eax
	call	_Mod_HitgroupForStudioHull
	add	esp, 4
	mov	DWORD PTR _trace_bbox$[ebp+64], eax
$LN56@PM_PlayerT:

; 497  : 		}
; 498  : 
; 499  : 		if( trace_bbox.allsolid )

	cmp	DWORD PTR _trace_bbox$[ebp], 0
	je	SHORT $LN61@PM_PlayerT

; 500  : 			trace_bbox.startsolid = true;

	mov	DWORD PTR _trace_bbox$[ebp+4], 1
$LN61@PM_PlayerT:

; 501  : 
; 502  : 		if( trace_bbox.startsolid )

	cmp	DWORD PTR _trace_bbox$[ebp+4], 0
	je	SHORT $LN62@PM_PlayerT

; 503  : 			trace_bbox.fraction = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _trace_bbox$[ebp+16], xmm0
$LN62@PM_PlayerT:

; 504  : 
; 505  : 		if( !trace_bbox.startsolid )

	cmp	DWORD PTR _trace_bbox$[ebp+4], 0
	jne	$LN65@PM_PlayerT

; 506  : 		{
; 507  : 			VectorLerp( start, trace_bbox.fraction, end, trace_bbox.endpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _trace_bbox$[ebp+eax+20], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _trace_bbox$[ebp+eax+20], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv769[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv769[ebp]
	movss	DWORD PTR _trace_bbox$[ebp+eax+20], xmm0

; 508  : 
; 509  : 			if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	$LN64@PM_PlayerT

; 510  : 			{
; 511  : 				VectorCopy( trace_bbox.plane.normal, temp );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace_bbox$[ebp+edx+32]
	mov	DWORD PTR _temp$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace_bbox$[ebp+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace_bbox$[ebp+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], edx

; 512  : 				Matrix4x4_TransformPositivePlane( matrix, temp, trace_bbox.plane.dist, trace_bbox.plane.normal, &trace_bbox.plane.dist );

	lea	eax, DWORD PTR _trace_bbox$[ebp+44]
	push	eax
	lea	ecx, DWORD PTR _trace_bbox$[ebp+32]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _trace_bbox$[ebp+44]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H

; 513  : 			}

	jmp	SHORT $LN65@PM_PlayerT
$LN64@PM_PlayerT:

; 514  : 			else
; 515  : 			{
; 516  : 				trace_bbox.plane.dist = DotProduct( trace_bbox.endpos, trace_bbox.plane.normal );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _trace_bbox$[ebp+edx+20]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+ecx+32]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _trace_bbox$[ebp+edx+20]
	mulss	xmm1, DWORD PTR _trace_bbox$[ebp+eax+32]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _trace_bbox$[ebp+ecx+20]
	mulss	xmm1, DWORD PTR _trace_bbox$[ebp+edx+32]
	addss	xmm0, xmm1
	movss	DWORD PTR _trace_bbox$[ebp+44], xmm0
$LN65@PM_PlayerT:

; 517  : 			}
; 518  : 		}
; 519  : 
; 520  : 		if( trace_bbox.fraction < trace_total.fraction )

	movss	xmm0, DWORD PTR _trace_total$[ebp+16]
	comiss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	jbe	SHORT $LN66@PM_PlayerT

; 521  : 		{
; 522  : 			trace_total = trace_bbox;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_bbox$[ebp]
	lea	edi, DWORD PTR _trace_total$[ebp]
	rep movsd

; 523  : 			trace_total.ent = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _trace_total$[ebp+48], eax
$LN66@PM_PlayerT:

; 524  : 		}
; 525  : 	}

	jmp	$LN2@PM_PlayerT
$LN3@PM_PlayerT:

; 526  : 
; 527  : 	return trace_total;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_total$[ebp]
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]

; 528  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_PlayerTraceExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
tv399 = -68						; size = 4
tv331 = -64						; size = 4
tv251 = -60						; size = 4
tv198 = -56						; size = 4
tv181 = -52						; size = 4
tv149 = -48						; size = 4
_t2$ = -44						; size = 4
_midf$ = -40						; size = 4
_side$ = -36						; size = 4
_node$ = -32						; size = 4
_t1$ = -28						; size = 4
_frac$ = -24						; size = 4
_plane$ = -20						; size = 4
_mid$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p1f$ = 16						; size = 4
_p2f$ = 20						; size = 4
_p1$ = 24						; size = 4
_p2$ = 28						; size = 4
_trace$ = 32						; size = 4
_PM_RecursiveHullCheck PROC

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
$loc0$32:

; 203  : 	mclipnode_t	*node;
; 204  : 	mplane_t		*plane;
; 205  : 	float		t1, t2;
; 206  : 	float		frac, midf;
; 207  : 	int		side;
; 208  : 	vec3_t		mid;
; 209  : loc0:
; 210  : 	// check for empty
; 211  : 	if( num < 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jge	SHORT $LN4@PM_Recursi

; 212  : 	{
; 213  : 		if( num != CONTENTS_SOLID )

	cmp	DWORD PTR _num$[ebp], -2		; fffffffeH
	je	SHORT $LN5@PM_Recursi

; 214  : 		{
; 215  : 			trace->allsolid = false;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 0

; 216  : 			if( num == CONTENTS_EMPTY )

	cmp	DWORD PTR _num$[ebp], -1
	jne	SHORT $LN7@PM_Recursi

; 217  : 				trace->inopen = true;

	mov	ecx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [ecx+8], 1
	jmp	SHORT $LN8@PM_Recursi
$LN7@PM_Recursi:

; 218  : 			else trace->inwater = true;

	mov	edx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [edx+12], 1
$LN8@PM_Recursi:

; 219  : 		}

	jmp	SHORT $LN6@PM_Recursi
$LN5@PM_Recursi:

; 220  : 		else trace->startsolid = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+4], 1
$LN6@PM_Recursi:

; 221  : 		return true; // empty

	mov	eax, 1
	jmp	$LN1@PM_Recursi
$LN4@PM_Recursi:

; 222  : 	}
; 223  : 
; 224  : 	if( hull->firstclipnode >= hull->lastclipnode )

	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LN9@PM_Recursi

; 225  : 	{
; 226  : 		// empty hull?
; 227  : 		trace->allsolid = false;

	mov	ecx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [ecx], 0

; 228  : 		trace->inopen = true;

	mov	edx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [edx+8], 1

; 229  : 		return true;

	mov	eax, 1
	jmp	$LN1@PM_Recursi
$LN9@PM_Recursi:

; 230  : 	}
; 231  : 
; 232  : 	if( num < hull->firstclipnode || num > hull->lastclipnode )

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LN11@PM_Recursi
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _num$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jle	SHORT $LN10@PM_Recursi
$LN11@PM_Recursi:

; 233  : 		Host_Error( "PM_RecursiveHullCheck: bad node number %i\n", num );

	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	push	OFFSET $SG134385
	call	_Host_Error
	add	esp, 8
$LN10@PM_Recursi:

; 234  : 		
; 235  : 	// find the point distances
; 236  : 	node = hull->clipnodes + num;

	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _num$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _node$[ebp], edx

; 237  : 	plane = hull->planes + node->planenum;

	mov	eax, DWORD PTR _node$[ebp]
	imul	ecx, DWORD PTR [eax], 20
	mov	edx, DWORD PTR _hull$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _plane$[ebp], ecx

; 238  : 
; 239  : 	t1 = PlaneDiff( p1, plane );

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN25@PM_Recursi
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN26@PM_Recursi
$LN25@PM_Recursi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv149[ebp], xmm0
$LN26@PM_Recursi:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv149[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _t1$[ebp], xmm0

; 240  : 	t2 = PlaneDiff( p2, plane );

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN27@PM_Recursi
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p2$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv181[ebp], xmm0
	jmp	SHORT $LN28@PM_Recursi
$LN27@PM_Recursi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv181[ebp], xmm0
$LN28@PM_Recursi:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv181[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _t2$[ebp], xmm0

; 241  : 
; 242  : 	if( t1 >= 0.0f && t2 >= 0.0f )

	movss	xmm0, DWORD PTR _t1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@PM_Recursi
	movss	xmm0, DWORD PTR _t2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@PM_Recursi

; 243  : 	{
; 244  : 		num = node->children[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+ecx+4]
	mov	DWORD PTR _num$[ebp], eax

; 245  : 		goto loc0;

	jmp	$loc0$32
$LN12@PM_Recursi:

; 246  : 	}
; 247  : 
; 248  : 	if( t1 < 0.0f && t2 < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN13@PM_Recursi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t2$[ebp]
	jbe	SHORT $LN13@PM_Recursi

; 249  : 	{
; 250  : 		num = node->children[1];

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+ecx+4]
	mov	DWORD PTR _num$[ebp], eax

; 251  : 		goto loc0;

	jmp	$loc0$32
$LN13@PM_Recursi:

; 252  : 	}
; 253  : 
; 254  : 	// put the crosspoint DIST_EPSILON pixels on the near side
; 255  : 	side = (t1 < 0.0f);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN29@PM_Recursi
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN30@PM_Recursi
$LN29@PM_Recursi:
	mov	DWORD PTR tv198[ebp], 0
$LN30@PM_Recursi:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR _side$[ebp], ecx

; 256  : 
; 257  : 	if( side ) frac = ( t1 + DIST_EPSILON ) / ( t1 - t2 );

	cmp	DWORD PTR _side$[ebp], 0
	je	SHORT $LN14@PM_Recursi
	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR __real@3d000000
	movss	xmm1, DWORD PTR _t1$[ebp]
	subss	xmm1, DWORD PTR _t2$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0
	jmp	SHORT $LN15@PM_Recursi
$LN14@PM_Recursi:

; 258  : 	else frac = ( t1 - DIST_EPSILON ) / ( t1 - t2 );

	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR __real@3d000000
	movss	xmm1, DWORD PTR _t1$[ebp]
	subss	xmm1, DWORD PTR _t2$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0
$LN15@PM_Recursi:

; 259  : 
; 260  : 	if( frac < 0.0f ) frac = 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN16@PM_Recursi
	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0
$LN16@PM_Recursi:

; 261  : 	if( frac > 1.0f ) frac = 1.0f;

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN17@PM_Recursi
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN17@PM_Recursi:

; 262  : 		
; 263  : 	midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 264  : 	VectorLerp( p1, frac, p2, mid );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	edx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv251[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv251[ebp]
	movss	DWORD PTR _mid$[ebp+ecx], xmm0

; 265  : 
; 266  : 	// move up to the node
; 267  : 	if( !PM_RecursiveHullCheck( hull, node->children[side], p1f, midf, p1, mid, trace ))

	mov	edx, DWORD PTR _trace$[ebp]
	push	edx
	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+4]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN18@PM_Recursi

; 268  : 		return false;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN18@PM_Recursi:

; 269  : 
; 270  : 	// this recursion can not be optimized because mid would need to be duplicated on a stack
; 271  : 	if( PM_HullPointContents( hull, node->children[side^1], mid ) != CONTENTS_SOLID )

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+4]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN19@PM_Recursi

; 272  : 	{
; 273  : 		// go past the node
; 274  : 		return PM_RecursiveHullCheck( hull, node->children[side^1], midf, p2f, mid, p2, trace );

	mov	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _p2f$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _side$[ebp]
	xor	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+4]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH
	jmp	$LN1@PM_Recursi
$LN19@PM_Recursi:

; 275  : 	}	
; 276  : 
; 277  : 	// never got out of the solid area
; 278  : 	if( trace->allsolid )

	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@PM_Recursi

; 279  : 		return false;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN20@PM_Recursi:

; 280  : 		
; 281  : 	// the other side of the node is solid, this is the impact point
; 282  : 	if( !side )

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN21@PM_Recursi

; 283  : 	{
; 284  : 		VectorCopy( plane->normal, trace->plane.normal );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+32], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+32], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+32], ecx

; 285  : 		trace->plane.dist = plane->dist;

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+44], ecx

; 286  : 	}

	jmp	$LN22@PM_Recursi
$LN21@PM_Recursi:

; 287  : 	else
; 288  : 	{
; 289  : 		VectorNegate( plane->normal, trace->plane.normal );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [ecx+eax+32], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+32], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv331[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv331[ebp]
	movss	DWORD PTR [eax+edx+32], xmm0

; 290  : 		trace->plane.dist = -plane->dist;

	mov	ecx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+44], xmm0
$LN22@PM_Recursi:

; 291  : 	}
; 292  : 
; 293  : 	while( PM_HullPointContents( hull, hull->firstclipnode, mid ) == CONTENTS_SOLID )

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	jne	$LN3@PM_Recursi

; 294  : 	{
; 295  : 		// shouldn't really happen, but does occasionally
; 296  : 		frac -= 0.1f;

	movss	xmm0, DWORD PTR _frac$[ebp]
	subss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _frac$[ebp], xmm0

; 297  : 
; 298  : 		if( frac < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN23@PM_Recursi

; 299  : 		{
; 300  : 			trace->fraction = midf;

	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 301  : 			VectorCopy( mid, trace->endpos );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _mid$[ebp+eax]
	mov	DWORD PTR [ecx+edx+20], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _mid$[ebp+ecx]
	mov	DWORD PTR [eax+edx+20], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR _mid$[ebp+edx]
	mov	DWORD PTR [ecx+eax+20], edx

; 302  : 			Con_Reportf( S_WARN "trace backed up past 0.0\n" );

	push	OFFSET $SG134398
	call	_Con_Reportf
	add	esp, 4

; 303  : 			return false;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN23@PM_Recursi:

; 304  : 		}
; 305  : 
; 306  : 		midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 307  : 		VectorLerp( p1, frac, p2, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv399[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv399[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 308  : 	}

	jmp	$LN22@PM_Recursi
$LN3@PM_Recursi:

; 309  : 
; 310  : 	trace->fraction = midf;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 311  : 	VectorCopy( mid, trace->endpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR _mid$[ebp+edx]
	mov	DWORD PTR [eax+ecx+20], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _mid$[ebp+eax]
	mov	DWORD PTR [edx+ecx+20], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _mid$[ebp+ecx]
	mov	DWORD PTR [eax+edx+20], ecx

; 312  : 
; 313  : 	return false;

	xor	eax, eax
$LN1@PM_Recursi:

; 314  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_RecursiveHullCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
tv198 = -28						; size = 4
tv174 = -24						; size = 4
tv137 = -20						; size = 4
tv77 = -16						; size = 4
tv69 = -12						; size = 4
tv80 = -8						; size = 4
_hull$ = -4						; size = 4
_pe$ = 8						; size = 4
_pmove$ = 12						; size = 4
_offset$ = 16						; size = 4
_PM_HullForBsp PROC

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 149  : 	hull_t	*hull;
; 150  : 
; 151  : 	Assert( pe != NULL );

	cmp	DWORD PTR _pe$[ebp], 0
	je	SHORT $LN9@PM_HullFor
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN10@PM_HullFor
$LN9@PM_HullFor:
	mov	DWORD PTR tv69[ebp], 0
$LN10@PM_HullFor:
	push	0
	push	151					; 00000097H
	push	OFFSET $SG134331
	push	OFFSET $SG134332
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 152  : 	Assert( pe->model != NULL );

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN11@PM_HullFor
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN12@PM_HullFor
$LN11@PM_HullFor:
	mov	DWORD PTR tv77[ebp], 0
$LN12@PM_HullFor:
	push	0
	push	152					; 00000098H
	push	OFFSET $SG134333
	push	OFFSET $SG134334
	mov	edx, DWORD PTR tv77[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 153  : 
; 154  : 	switch( pmove->usehull )

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 1
	je	SHORT $LN4@PM_HullFor
	cmp	DWORD PTR tv80[ebp], 2
	je	SHORT $LN5@PM_HullFor
	cmp	DWORD PTR tv80[ebp], 3
	je	SHORT $LN6@PM_HullFor
	jmp	SHORT $LN7@PM_HullFor
$LN4@PM_HullFor:

; 155  : 	{
; 156  : 	case 1:
; 157  : 		hull = &pe->model->hulls[3];

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR [eax+edx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 158  : 		break;

	jmp	SHORT $LN2@PM_HullFor
$LN5@PM_HullFor:

; 159  : 	case 2:
; 160  : 		hull = &pe->model->hulls[0];

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], edx

; 161  : 		break;

	jmp	SHORT $LN2@PM_HullFor
$LN6@PM_HullFor:

; 162  : 	case 3:
; 163  : 		hull = &pe->model->hulls[2];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 164  : 		break;

	jmp	SHORT $LN2@PM_HullFor
$LN7@PM_HullFor:

; 165  : 	default:
; 166  : 		hull = &pe->model->hulls[1];

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, 40					; 00000028H
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+208]
	mov	DWORD PTR _hull$[ebp], ecx
$LN2@PM_HullFor:

; 167  : 		break;
; 168  : 	}
; 169  : 
; 170  : 	Assert( hull != NULL );

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN13@PM_HullFor
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN14@PM_HullFor
$LN13@PM_HullFor:
	mov	DWORD PTR tv137[ebp], 0
$LN14@PM_HullFor:
	push	0
	push	170					; 000000aaH
	push	OFFSET $SG134339
	push	OFFSET $SG134340
	mov	edx, DWORD PTR tv137[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 171  : 
; 172  : 	// calculate an offset value to center the origin
; 173  : 	VectorSubtract( hull->clip_mins, pmove->player_mins[pmove->usehull], offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+16]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+edx+324852]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+16]
	subss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324852]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+16]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv174[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 174  : 	VectorAdd( offset, pe->origin, offset );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [esi+edx+36]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR [esi+eax+36]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR [esi+edx+36]
	movss	DWORD PTR tv198[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv198[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 175  : 
; 176  : 	return hull;

	mov	eax, DWORD PTR _hull$[ebp]

; 177  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
_side$ = -8						; size = 4
_i$ = -4						; size = 4
_PM_InitBoxHull PROC

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 68   : 	int	i, side;
; 69   : 
; 70   : 	pm_boxhull.clipnodes = pm_boxclipnodes;

	mov	DWORD PTR _pm_boxhull, OFFSET _pm_boxclipnodes

; 71   : 	pm_boxhull.planes = pm_boxplanes;

	mov	DWORD PTR _pm_boxhull+4, OFFSET _pm_boxplanes

; 72   : 	pm_boxhull.firstclipnode = 0;

	mov	DWORD PTR _pm_boxhull+8, 0

; 73   : 	pm_boxhull.lastclipnode = 5;

	mov	DWORD PTR _pm_boxhull+12, 5

; 74   : 
; 75   : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_InitBox
$LN2@PM_InitBox:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_InitBox:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@PM_InitBox

; 76   : 	{
; 77   : 		pm_boxclipnodes[i].planenum = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _pm_boxclipnodes[ecx*8], edx

; 78   : 		
; 79   : 		side = i & 1;

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	mov	DWORD PTR _side$[ebp], eax

; 80   : 		
; 81   : 		pm_boxclipnodes[i].children[side] = CONTENTS_EMPTY;

	mov	ecx, DWORD PTR _side$[ebp]
	shl	ecx, 1
	or	edx, -1
	mov	eax, DWORD PTR _i$[ebp]
	mov	WORD PTR _pm_boxclipnodes[ecx+eax*8+4], dx

; 82   : 		if( i != 5 ) pm_boxclipnodes[i].children[side^1] = i + 1;

	cmp	DWORD PTR _i$[ebp], 5
	je	SHORT $LN5@PM_InitBox
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _side$[ebp]
	xor	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	mov	WORD PTR _pm_boxclipnodes[edx+eax*8+4], cx
	jmp	SHORT $LN6@PM_InitBox
$LN5@PM_InitBox:

; 83   : 		else pm_boxclipnodes[i].children[side^1] = CONTENTS_SOLID;

	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	shl	ecx, 1
	mov	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _i$[ebp]
	mov	WORD PTR _pm_boxclipnodes[ecx+eax*8+4], dx
$LN6@PM_InitBox:

; 84   : 		
; 85   : 		pm_boxplanes[i].type = i>>1;

	mov	ecx, DWORD PTR _i$[ebp]
	sar	ecx, 1
	imul	edx, DWORD PTR _i$[ebp], 20
	mov	BYTE PTR _pm_boxplanes[edx+16], cl

; 86   : 		pm_boxplanes[i].normal[i>>1] = 1.0f;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _i$[ebp]
	sar	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _pm_boxplanes[eax+ecx*4], xmm0

; 87   : 		pm_boxplanes[i].signbits = 0;

	imul	edx, DWORD PTR _i$[ebp], 20
	mov	BYTE PTR _pm_boxplanes[edx+17], 0

; 88   : 	}

	jmp	$LN2@PM_InitBox
$LN3@PM_InitBox:

; 89   : 	
; 90   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PM_InitBoxHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_trace.c
_TEXT	SEGMENT
_Pmove_Init PROC

; 50   : {

	push	ebp
	mov	ebp, esp

; 51   : 	PM_InitBoxHull ();

	call	_PM_InitBoxHull

; 52   : 
; 53   : 	// init default hull sizes
; 54   : 	memcpy( host.player_mins, pm_hullmins, sizeof( pm_hullmins ));

	push	48					; 00000030H
	push	OFFSET _pm_hullmins
	push	OFFSET _host+34236
	call	_memcpy
	add	esp, 12					; 0000000cH

; 55   : 	memcpy( host.player_maxs, pm_hullmaxs, sizeof( pm_hullmaxs ));

	push	48					; 00000030H
	push	OFFSET _pm_hullmaxs
	push	OFFSET _host+34284
	call	_memcpy
	add	esp, 12					; 0000000cH

; 56   : }

	pop	ebp
	ret	0
_Pmove_Init ENDP
_TEXT	ENDS
END
