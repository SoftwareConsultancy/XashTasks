; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\cl_tent.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_cl_sprite_dot
PUBLIC	_cl_sprite_shell
PUBLIC	_cl_tempents
PUBLIC	_cl_sprite_ricochet
PUBLIC	_cl_sprite_glow
PUBLIC	_cl_default_sprites
PUBLIC	_cl_player_shell_sounds
PUBLIC	_cl_weapon_shell_sounds
PUBLIC	_cl_ricochet_sounds
PUBLIC	_cl_explode_sounds
_BSS	SEGMENT
_cl_sprite_dot DD 01H DUP (?)
_cl_sprite_shell DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_cl_dlights:BYTE:0500H
COMM	_cl_elights:BYTE:0a00H
COMM	_cl_active_tents:DWORD
COMM	_cl_free_tents:DWORD
_DATA	ENDS
_BSS	SEGMENT
_cl_tempents DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_cl_sprite_muzzleflash:DWORD:03H
_DATA	ENDS
_BSS	SEGMENT
_cl_sprite_ricochet DD 01H DUP (?)
_cl_sprite_glow DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_cl_efrags:BYTE:020000H
_DATA	ENDS
_DATA	SEGMENT
_cl_default_sprites DD FLAT:$SG145976
	DD	FLAT:$SG145977
	DD	FLAT:$SG145978
	DD	FLAT:$SG145979
	DD	FLAT:$SG145980
	DD	FLAT:$SG145981
	DD	FLAT:$SG145982
$SG145976 DB	'sprites/muzzleflash1.spr', 00H
	ORG $+3
$SG145977 DB	'sprites/muzzleflash2.spr', 00H
	ORG $+3
$SG145978 DB	'sprites/muzzleflash3.spr', 00H
	ORG $+3
$SG145979 DB	'sprites/dot.spr', 00H
$SG145980 DB	'sprites/animglow01.spr', 00H
	ORG $+1
$SG145981 DB	'sprites/richo1.spr', 00H
	ORG $+1
$SG145982 DB	'sprites/shellchrome.spr', 00H
_cl_player_shell_sounds DD FLAT:$SG145984
	DD	FLAT:$SG145985
	DD	FLAT:$SG145986
$SG145984 DB	'player/pl_shell1.wav', 00H
	ORG $+3
$SG145985 DB	'player/pl_shell2.wav', 00H
	ORG $+3
$SG145986 DB	'player/pl_shell3.wav', 00H
	ORG $+3
_cl_weapon_shell_sounds DD FLAT:$SG145988
	DD	FLAT:$SG145989
	DD	FLAT:$SG145990
$SG145988 DB	'weapons/sshell1.wav', 00H
$SG145989 DB	'weapons/sshell2.wav', 00H
$SG145990 DB	'weapons/sshell3.wav', 00H
_cl_ricochet_sounds DD FLAT:$SG145992
	DD	FLAT:$SG145993
	DD	FLAT:$SG145994
	DD	FLAT:$SG145995
	DD	FLAT:$SG145996
$SG145992 DB	'weapons/ric1.wav', 00H
	ORG $+3
$SG145993 DB	'weapons/ric2.wav', 00H
	ORG $+3
$SG145994 DB	'weapons/ric3.wav', 00H
	ORG $+3
$SG145995 DB	'weapons/ric4.wav', 00H
	ORG $+3
$SG145996 DB	'weapons/ric5.wav', 00H
	ORG $+3
_cl_explode_sounds DD FLAT:$SG145998
	DD	FLAT:$SG145999
	DD	FLAT:$SG146000
$SG145998 DB	'weapons/explode3.wav', 00H
	ORG $+3
$SG145999 DB	'weapons/explode4.wav', 00H
	ORG $+3
$SG146000 DB	'weapons/explode5.wav', 00H
_DATA	ENDS
PUBLIC	_CL_SetLightstyle
PUBLIC	_CL_DecayLights
PUBLIC	_CL_ParseTempEntity
PUBLIC	_CL_ClearEffects
PUBLIC	_CL_ClearEfrags
PUBLIC	_CL_TestLights
PUBLIC	_CL_FireCustomDecal
PUBLIC	_CL_DecalShoot
PUBLIC	_CL_PlayerDecal
PUBLIC	_CL_AddClientResource
PUBLIC	_CL_AddClientResources
PUBLIC	_CL_FxBlend
PUBLIC	_CL_InitTempEnts
PUBLIC	_CL_ClearTempEnts
PUBLIC	_CL_FreeTempEnts
PUBLIC	_CL_TempEntUpdate
PUBLIC	_CL_LoadClientSprites
PUBLIC	_R_Explosion
PUBLIC	_R_SparkShower
PUBLIC	_CL_TempEntAlloc
PUBLIC	_CL_TempEntAllocHigh
PUBLIC	_CL_TempEntAllocNoModel
PUBLIC	_CL_TempEntAllocCustom
PUBLIC	_R_FizzEffect
PUBLIC	_R_Bubbles
PUBLIC	_R_BubbleTrail
PUBLIC	_R_AttachTentToPlayer
PUBLIC	_R_KillAttachedTents
PUBLIC	_R_RicochetSprite
PUBLIC	_R_RocketFlare
PUBLIC	_R_MuzzleFlash
PUBLIC	_R_BloodSprite
PUBLIC	_R_BreakModel
PUBLIC	_R_TempModel
PUBLIC	_R_TempSprite
PUBLIC	_R_DefaultSprite
PUBLIC	_R_Sprite_Explode
PUBLIC	_R_Sprite_Smoke
PUBLIC	_R_Spray
PUBLIC	_R_Sprite_Spray
PUBLIC	_R_Sprite_Trail
PUBLIC	_R_FunnelSprite
PUBLIC	_R_SparkEffect
PUBLIC	_R_Projectile
PUBLIC	_R_TempSphereModel
PUBLIC	_R_MultiGunshot
PUBLIC	_R_FireField
PUBLIC	_R_PlayerSprites
PUBLIC	_R_Sprite_WallPuff
PUBLIC	_R_RicochetSound
PUBLIC	_CL_AllocDlight
PUBLIC	_CL_AllocElight
PUBLIC	_CL_UpdateFlashlight
PUBLIC	_CL_AddEntityEffects
PUBLIC	_CL_AddModelEffects
PUBLIC	_CL_DecalRemoveAll
PUBLIC	_CL_DecalIndexFromName
PUBLIC	_CL_DecalIndex
PUBLIC	_CL_PrepareTEnt
PUBLIC	_CL_TempEntPlaySound
PUBLIC	_CL_TempEntAddEntity
PUBLIC	_CL_FreeLowPriorityTempEnt
PUBLIC	_CL_ClearLightStyles
PUBLIC	_CL_ClearDlights
PUBLIC	__real@00000000
PUBLIC	__real@3b23d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3f847ae147ae147b
PUBLIC	__real@3f99999a
PUBLIC	__real@3fa00000
PUBLIC	__real@3fb40000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fd6666660000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@4031000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@4037000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4042000000000000
PUBLIC	__real@40490fdb
PUBLIC	__real@4050000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41700000
PUBLIC	__real@41800000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41e00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@420c0000
PUBLIC	__real@42100000
PUBLIC	__real@42340000
PUBLIC	__real@42700000
PUBLIC	__real@42800000
PUBLIC	__real@42a00000
PUBLIC	__real@42be0000
PUBLIC	__real@42c80000
PUBLIC	__real@43000000
PUBLIC	__real@43160000
PUBLIC	__real@43480000
PUBLIC	__real@43670000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43960000
PUBLIC	__real@43af0000
PUBLIC	__real@43b40000
PUBLIC	__real@43b58000
PUBLIC	__real@43c80000
PUBLIC	__real@43d78000
PUBLIC	__real@43d80000
PUBLIC	__real@43e10000
PUBLIC	__real@43fa0000
PUBLIC	__real@43ff8000
PUBLIC	__real@44480000
PUBLIC	__real@44fa0000
PUBLIC	__real@45800000
PUBLIC	__real@be800000
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__real@c0490fdb
PUBLIC	__real@c1200000
PUBLIC	__real@c1a00000
PUBLIC	__real@c2000000
PUBLIC	__real@c2c00000
PUBLIC	__real@c2c80000
PUBLIC	__real@c2fe0000
PUBLIC	__real@c3480000
PUBLIC	__real@c37f0000
PUBLIC	__real@c3800000
PUBLIC	__real@c3960000
PUBLIC	__real@c4000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	_abs:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Image_SetForceFlags:PROC
EXTRN	_Image_ClearForceFlags:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_CL_PointContents:PROC
EXTRN	_R_DecalRemoveAll:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_SinCos:PROC
EXTRN	_VectorNormalizeLength2:PROC
EXTRN	_VectorVectors:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_Mod_AliasExtradata:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_ReadChar:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadCoord:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_CL_AddToResourceList:PROC
EXTRN	_CL_ParseTextMessage:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_LoadClientSprite:PROC
EXTRN	_CL_VisTraceLine:PROC
EXTRN	_CL_TraceLine:PROC
EXTRN	_CL_AddVisibleEntity:PROC
EXTRN	_CL_ClearParticles:PROC
EXTRN	_CL_ClearViewBeams:PROC
EXTRN	_CL_ParseViewBeam:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_R_ParticleExplosion2:PROC
EXTRN	_R_Implosion:PROC
EXTRN	_R_Blood:PROC
EXTRN	_R_BloodStream:PROC
EXTRN	_R_BlobExplosion:PROC
EXTRN	_R_EntityParticles:PROC
EXTRN	_R_FlickerParticles:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_R_ParticleBurst:PROC
EXTRN	_R_LavaSplash:PROC
EXTRN	_R_TeleportSplash:PROC
EXTRN	_R_RocketTrail:PROC
EXTRN	_R_TracerEffect:PROC
EXTRN	_R_UserTracerParticle:PROC
EXTRN	_R_ParticleLine:PROC
EXTRN	_R_ParticleBox:PROC
EXTRN	_R_ShowLine:PROC
EXTRN	_R_BulletImpactParticles:PROC
EXTRN	_R_LargeFunnel:PROC
EXTRN	_R_StreakSplash:PROC
EXTRN	_R_SparkStreaks:PROC
EXTRN	_TriBoxInPVS:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_R_DecalShoot:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_testlights:DWORD
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c4000000
CONST	SEGMENT
__real@c4000000 DD 0c4000000r			; -512
CONST	ENDS
;	COMDAT __real@c3960000
CONST	SEGMENT
__real@c3960000 DD 0c3960000r			; -300
CONST	ENDS
;	COMDAT __real@c3800000
CONST	SEGMENT
__real@c3800000 DD 0c3800000r			; -256
CONST	ENDS
;	COMDAT __real@c37f0000
CONST	SEGMENT
__real@c37f0000 DD 0c37f0000r			; -255
CONST	ENDS
;	COMDAT __real@c3480000
CONST	SEGMENT
__real@c3480000 DD 0c3480000r			; -200
CONST	ENDS
;	COMDAT __real@c2fe0000
CONST	SEGMENT
__real@c2fe0000 DD 0c2fe0000r			; -127
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2c00000
CONST	SEGMENT
__real@c2c00000 DD 0c2c00000r			; -96
CONST	ENDS
;	COMDAT __real@c2000000
CONST	SEGMENT
__real@c2000000 DD 0c2000000r			; -32
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be800000
CONST	SEGMENT
__real@be800000 DD 0be800000r			; -0.25
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@43ff8000
CONST	SEGMENT
__real@43ff8000 DD 043ff8000r			; 511
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43e10000
CONST	SEGMENT
__real@43e10000 DD 043e10000r			; 450
CONST	ENDS
;	COMDAT __real@43d80000
CONST	SEGMENT
__real@43d80000 DD 043d80000r			; 432
CONST	ENDS
;	COMDAT __real@43d78000
CONST	SEGMENT
__real@43d78000 DD 043d78000r			; 431
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43b58000
CONST	SEGMENT
__real@43b58000 DD 043b58000r			; 363
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43af0000
CONST	SEGMENT
__real@43af0000 DD 043af0000r			; 350
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43670000
CONST	SEGMENT
__real@43670000 DD 043670000r			; 231
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42be0000
CONST	SEGMENT
__real@42be0000 DD 042be0000r			; 95
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@42100000
CONST	SEGMENT
__real@42100000 DD 042100000r			; 36
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41e00000
CONST	SEGMENT
__real@41e00000 DD 041e00000r			; 28
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4050000000000000
CONST	SEGMENT
__real@4050000000000000 DQ 04050000000000000r	; 64
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@4042000000000000
CONST	SEGMENT
__real@4042000000000000 DQ 04042000000000000r	; 36
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4037000000000000
CONST	SEGMENT
__real@4037000000000000 DQ 04037000000000000r	; 23
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@4031000000000000
CONST	SEGMENT
__real@4031000000000000 DQ 04031000000000000r	; 17
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd6666660000000
CONST	SEGMENT
__real@3fd6666660000000 DQ 03fd6666660000000r	; 0.35
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f847ae147ae147b
CONST	SEGMENT
__real@3f847ae147ae147b DQ 03f847ae147ae147br	; 0.01
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b23d70a
CONST	SEGMENT
__real@3b23d70a DD 03b23d70ar			; 0.0025
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+7
$SG146016 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG146036 DB	'sound/', 00H
	ORG $+1
$SG146037 DB	'%s%s', 00H
	ORG $+3
$SG146039 DB	'sound/', 00H
	ORG $+1
$SG146040 DB	'%s%s', 00H
	ORG $+3
$SG146042 DB	'sound/', 00H
	ORG $+1
$SG146043 DB	'%s%s', 00H
	ORG $+3
$SG146149 DB	'pTemp != NULL', 00H
	ORG $+2
$SG146151 DB	'debris/glass%i.wav', 00H
	ORG $+1
$SG146101 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG146153 DB	'debris/metal%i.wav', 00H
	ORG $+1
$SG146115 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG146155 DB	'debris/flesh%i.wav', 00H
	ORG $+1
$SG146148 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG146157 DB	'debris/wood%i.wav', 00H
	ORG $+2
$SG146159 DB	'%s', 00H
	ORG $+1
$SG146161 DB	'%s', 00H
	ORG $+1
$SG146163 DB	'%s', 00H
	ORG $+1
$SG146165 DB	'debris/concrete%i.wav', 00H
	ORG $+2
$SG146185 DB	'pEntity != NULL', 00H
$SG146551 DB	'^1Error:^7 No model %d!', 0aH, 00H
	ORG $+3
$SG146184 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG146212 DB	'Overflow %d temporary ents!', 0aH, 00H
	ORG $+3
$SG146223 DB	'Couldn''t alloc a high priority TENT!', 0aH, 00H
	ORG $+2
$SG146518 DB	'No Sprite %d!', 0aH, 00H
	ORG $+1
$SG146601 DB	'No model %d!', 0aH, 00H
	ORG $+2
$SG146682 DB	'^1Error:^7 no model %d!', 0aH, 00H
	ORG $+3
$SG146704 DB	'%s', 00H
	ORG $+1
$SG146774 DB	'%s', 00H
	ORG $+1
$SG146957 DB	'TempEntity', 00H
	ORG $+1
$SG147019 DB	'^1Error:^7 ParseTempEntity: illegible TE message %i', 0aH
	DB	00H
	ORG $+3
$SG147021 DB	'^3Warning:^7 ParseTempEntity: overflow TE message', 0aH, 00H
	ORG $+1
$SG147048 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG147049 DB	's != NULL', 00H
	ORG $+2
$SG147050 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_tent.c', 00H
	ORG $+1
$SG147051 DB	'style >= 0 && style < MAX_LIGHTSTYLES', 00H
	ORG $+2
$SG147053 DB	'Yes', 00H
$SG147054 DB	'No', 00H
	ORG $+1
$SG147055 DB	'Lightstyle %i (%s), interp %s', 0aH, 00H
	ORG $+1
$SG147236 DB	'player%dlogo%d', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_CL_ClearDlights PROC

; 2588 : {

	push	ebp
	mov	ebp, esp

; 2589 : 	memset( cl_dlights, 0, sizeof( cl_dlights ));

	push	1280					; 00000500H
	push	0
	push	OFFSET _cl_dlights
	call	_memset
	add	esp, 12					; 0000000cH

; 2590 : 	memset( cl_elights, 0, sizeof( cl_elights ));

	push	2560					; 00000a00H
	push	0
	push	OFFSET _cl_elights
	call	_memset
	add	esp, 12					; 0000000cH

; 2591 : }

	pop	ebp
	ret	0
_CL_ClearDlights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_CL_ClearLightStyles PROC

; 2530 : {

	push	ebp
	mov	ebp, esp

; 2531 : 	memset( cl.lightstyles, 0, sizeof( cl.lightstyles ));

	push	82944					; 00014400H
	push	0
	push	OFFSET _cl+1852744
	call	_memset
	add	esp, 12					; 0000000cH

; 2532 : }

	pop	ebp
	ret	0
_CL_ClearLightStyles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pPrev$ = -8						; size = 4
_pActive$ = -4						; size = 4
_CL_FreeLowPriorityTempEnt PROC

; 557  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 558  : 	TEMPENTITY	*pActive = cl_active_tents;

	mov	eax, DWORD PTR _cl_active_tents
	mov	DWORD PTR _pActive$[ebp], eax

; 559  : 	TEMPENTITY	*pPrev = NULL;

	mov	DWORD PTR _pPrev$[ebp], 0
$LN2@CL_FreeLow:

; 560  : 
; 561  : 	while( pActive )

	cmp	DWORD PTR _pActive$[ebp], 0
	je	SHORT $LN3@CL_FreeLow

; 562  : 	{
; 563  : 		if( pActive->priority == TENTPRIORITY_LOW )

	mov	ecx, DWORD PTR _pActive$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN4@CL_FreeLow

; 564  : 		{
; 565  : 			// remove from the active list.
; 566  : 			if( pPrev ) pPrev->next = pActive->next;

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $LN5@CL_FreeLow
	mov	edx, DWORD PTR _pPrev$[ebp]
	mov	eax, DWORD PTR _pActive$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	jmp	SHORT $LN6@CL_FreeLow
$LN5@CL_FreeLow:

; 567  : 			else cl_active_tents = pActive->next;

	mov	edx, DWORD PTR _pActive$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _cl_active_tents, eax
$LN6@CL_FreeLow:

; 568  : 
; 569  : 			// add to the free list.
; 570  : 			pActive->next = cl_free_tents;

	mov	ecx, DWORD PTR _pActive$[ebp]
	mov	edx, DWORD PTR _cl_free_tents
	mov	DWORD PTR [ecx+44], edx

; 571  : 			cl_free_tents = pActive;

	mov	eax, DWORD PTR _pActive$[ebp]
	mov	DWORD PTR _cl_free_tents, eax

; 572  : 
; 573  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_FreeLow
$LN4@CL_FreeLow:

; 574  : 		}
; 575  : 
; 576  : 		pPrev = pActive;

	mov	ecx, DWORD PTR _pActive$[ebp]
	mov	DWORD PTR _pPrev$[ebp], ecx

; 577  : 		pActive = pActive->next;

	mov	edx, DWORD PTR _pActive$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _pActive$[ebp], eax

; 578  : 	}

	jmp	SHORT $LN2@CL_FreeLow
$LN3@CL_FreeLow:

; 579  : 
; 580  : 	return false;

	xor	eax, eax
$LN1@CL_FreeLow:

; 581  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeLowPriorityTempEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv164 = -40						; size = 4
tv134 = -36						; size = 4
tv69 = -32						; size = 4
_mins$ = -28						; size = 12
_maxs$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pEntity$ = 8						; size = 4
_CL_TempEntAddEntity PROC

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 505  : 	vec3_t mins, maxs;
; 506  : 
; 507  : 	Assert( pEntity != NULL );

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $LN6@CL_TempEnt
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@CL_TempEnt
$LN6@CL_TempEnt:
	mov	DWORD PTR tv69[ebp], 0
$LN7@CL_TempEnt:
	push	0
	push	507					; 000001fbH
	push	OFFSET $SG146184
	push	OFFSET $SG146185
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 508  : 
; 509  : 	if( !pEntity->model )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	jne	SHORT $LN2@CL_TempEnt

; 510  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_TempEnt
$LN2@CL_TempEnt:

; 511  : 
; 512  : 	VectorAdd( pEntity->origin, pEntity->model->mins, mins );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+2888]
	addss	xmm0, DWORD PTR [edx+ecx+84]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _mins$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+2888]
	addss	xmm0, DWORD PTR [eax+edx+84]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _mins$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+2888]
	addss	xmm0, DWORD PTR [eax+edx+84]
	movss	DWORD PTR tv134[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _mins$[ebp+eax], xmm0

; 513  : 	VectorAdd( pEntity->origin, pEntity->model->maxs, maxs );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+2888]
	addss	xmm0, DWORD PTR [ecx+eax+96]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+2888]
	addss	xmm0, DWORD PTR [edx+ecx+96]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+2888]
	addss	xmm0, DWORD PTR [edx+ecx+96]
	movss	DWORD PTR tv164[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _maxs$[ebp+edx], xmm0

; 514  : 
; 515  : 	// g-cont. just use PVS from previous frame
; 516  : 	if( TriBoxInPVS( mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_TriBoxInPVS
	add	esp, 8
	test	eax, eax
	je	$LN3@CL_TempEnt

; 517  : 	{
; 518  : 		VectorCopy( pEntity->angles, pEntity->curstate.angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+2900]
	mov	DWORD PTR [ecx+edx+716], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2900]
	mov	DWORD PTR [eax+edx+716], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+2900]
	mov	DWORD PTR [ecx+eax+716], edx

; 519  : 		VectorCopy( pEntity->origin, pEntity->curstate.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax+704], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax+704], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx+704], eax

; 520  : 		VectorCopy( pEntity->angles, pEntity->latched.prevangles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+2900]
	mov	DWORD PTR [eax+ecx+2856], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+2900]
	mov	DWORD PTR [edx+ecx+2856], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2900]
	mov	DWORD PTR [eax+edx+2856], ecx

; 521  : 		VectorCopy( pEntity->origin, pEntity->latched.prevorigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx+2844], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx+2844], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax+2844], edx

; 522  : 	
; 523  : 		// add to list
; 524  : 		if( CL_AddVisibleEntity( pEntity, ET_TEMPENTITY ))

	push	2
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@CL_TempEnt

; 525  : 			r_stats.c_active_tents_count++;

	mov	ecx, DWORD PTR _r_stats+24
	add	ecx, 1
	mov	DWORD PTR _r_stats+24, ecx
$LN4@CL_TempEnt:

; 526  : 
; 527  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@CL_TempEnt
$LN3@CL_TempEnt:

; 528  : 	}
; 529  : 
; 530  : 	return 0;

	xor	eax, eax
$LN1@CL_TempEnt:

; 531  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_handle$1 = -72						; size = 4
_pitch$2 = -68						; size = 4
tv207 = -64						; size = 4
tv196 = -60						; size = 4
tv69 = -56						; size = 4
tv72 = -52						; size = 4
_isshellcasing$ = -48					; size = 4
_zvel$ = -44						; size = 4
_fvol$ = -40						; size = 4
_soundname$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_pTemp$ = 8						; size = 4
_damp$ = 12						; size = 4
_CL_TempEntPlaySound PROC

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 421  : 	float	fvol;
; 422  : 	char	soundname[32];
; 423  : 	qboolean	isshellcasing = false;

	mov	DWORD PTR _isshellcasing$[ebp], 0

; 424  : 	int	zvel;
; 425  : 
; 426  : 	Assert( pTemp != NULL );

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN23@CL_TempEnt
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN24@CL_TempEnt
$LN23@CL_TempEnt:
	mov	DWORD PTR tv69[ebp], 0
$LN24@CL_TempEnt:
	push	0
	push	426					; 000001aaH
	push	OFFSET $SG146148
	push	OFFSET $SG146149
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 427  : 
; 428  : 	fvol = 0.8f;

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _fvol$[ebp], xmm0

; 429  : 
; 430  : 	switch( pTemp->hitSound )

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	sub	eax, 1
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 127		; 0000007fH
	ja	$LN12@CL_TempEnt
	mov	ecx, DWORD PTR tv72[ebp]
	movzx	edx, BYTE PTR $LN29@CL_TempEnt[ecx]
	jmp	DWORD PTR $LN30@CL_TempEnt[edx*4]
$LN4@CL_TempEnt:

; 431  : 	{
; 432  : 	case BOUNCE_GLASS:
; 433  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/glass%i.wav", COM_RandomLong( 1, 4 ));

	push	4
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET $SG146151
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 434  : 		break;

	jmp	$LN2@CL_TempEnt
$LN5@CL_TempEnt:

; 435  : 	case BOUNCE_METAL:
; 436  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/metal%i.wav", COM_RandomLong( 1, 6 ));

	push	6
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET $SG146153
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 437  : 		break;

	jmp	$LN2@CL_TempEnt
$LN6@CL_TempEnt:

; 438  : 	case BOUNCE_FLESH:
; 439  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/flesh%i.wav", COM_RandomLong( 1, 7 ));

	push	7
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET $SG146155
	push	32					; 00000020H
	lea	edx, DWORD PTR _soundname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 440  : 		break;

	jmp	$LN2@CL_TempEnt
$LN7@CL_TempEnt:

; 441  : 	case BOUNCE_WOOD:
; 442  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/wood%i.wav", COM_RandomLong( 1, 4 ));

	push	4
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET $SG146157
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 443  : 		break;

	jmp	$LN2@CL_TempEnt
$LN8@CL_TempEnt:

; 444  : 	case BOUNCE_SHRAP:
; 445  : 		Q_snprintf( soundname, sizeof( soundname ), "%s", cl_ricochet_sounds[COM_RandomLong( 0, 4 )] );

	push	4
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _cl_ricochet_sounds[eax*4]
	push	ecx
	push	OFFSET $SG146159
	push	32					; 00000020H
	lea	edx, DWORD PTR _soundname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 446  : 		break;

	jmp	$LN2@CL_TempEnt
$LN9@CL_TempEnt:

; 447  : 	case BOUNCE_SHOTSHELL:
; 448  : 		Q_snprintf( soundname, sizeof( soundname ), "%s", cl_weapon_shell_sounds[COM_RandomLong( 0, 2 )] );

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_weapon_shell_sounds[eax*4]
	push	eax
	push	OFFSET $SG146161
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 449  : 		isshellcasing = true; // shell casings have different playback parameters

	mov	DWORD PTR _isshellcasing$[ebp], 1

; 450  : 		fvol = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _fvol$[ebp], xmm0

; 451  : 		break;

	jmp	SHORT $LN2@CL_TempEnt
$LN10@CL_TempEnt:

; 452  : 	case BOUNCE_SHELL:
; 453  : 		Q_snprintf( soundname, sizeof( soundname ), "%s", cl_player_shell_sounds[COM_RandomLong( 0, 2 )] );

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, DWORD PTR _cl_player_shell_sounds[eax*4]
	push	edx
	push	OFFSET $SG146163
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 454  : 		isshellcasing = true; // shell casings have different playback parameters

	mov	DWORD PTR _isshellcasing$[ebp], 1

; 455  : 		break;

	jmp	SHORT $LN2@CL_TempEnt
$LN11@CL_TempEnt:

; 456  : 	case BOUNCE_CONCRETE:
; 457  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/concrete%i.wav", COM_RandomLong( 1, 3 ));

	push	3
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET $SG146165
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 458  : 		break;

	jmp	SHORT $LN2@CL_TempEnt
$LN12@CL_TempEnt:

; 459  : 	default:	// null sound
; 460  : 		return;

	jmp	$LN17@CL_TempEnt
$LN2@CL_TempEnt:

; 461  : 	}
; 462  : 
; 463  : 	zvel = abs( pTemp->entity.baseline.origin[2] );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx+92]
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _zvel$[ebp], eax

; 464  : 		
; 465  : 	// only play one out of every n
; 466  : 	if( isshellcasing )

	cmp	DWORD PTR _isshellcasing$[ebp], 0
	je	SHORT $LN13@CL_TempEnt

; 467  : 	{	
; 468  : 		// play first bounce, then 1 out of 3		
; 469  : 		if( zvel < 200 && COM_RandomLong( 0, 3 ))

	cmp	DWORD PTR _zvel$[ebp], 200		; 000000c8H
	jge	SHORT $LN15@CL_TempEnt
	push	3
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@CL_TempEnt

; 470  : 			return;

	jmp	$LN17@CL_TempEnt
$LN15@CL_TempEnt:

; 471  : 	}

	jmp	SHORT $LN16@CL_TempEnt
$LN13@CL_TempEnt:

; 472  : 	else
; 473  : 	{
; 474  : 		if( COM_RandomLong( 0, 5 )) 

	push	5
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@CL_TempEnt

; 475  : 			return;

	jmp	$LN17@CL_TempEnt
$LN16@CL_TempEnt:

; 476  : 	}
; 477  : 
; 478  : 	if( damp > 0.0f )

	movss	xmm0, DWORD PTR _damp$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN17@CL_TempEnt

; 479  : 	{
; 480  : 		int	pitch;
; 481  : 		sound_t	handle;
; 482  : 		
; 483  : 		if( isshellcasing )

	cmp	DWORD PTR _isshellcasing$[ebp], 0
	je	SHORT $LN18@CL_TempEnt

; 484  : 			fvol *= min ( 1.0f, ((float)zvel) / 350.0f ); 

	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43af0000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN25@CL_TempEnt
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv196[ebp], xmm0
	jmp	SHORT $LN26@CL_TempEnt
$LN25@CL_TempEnt:
	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43af0000
	movss	DWORD PTR tv196[ebp], xmm0
$LN26@CL_TempEnt:
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0
	jmp	SHORT $LN19@CL_TempEnt
$LN18@CL_TempEnt:

; 485  : 		else fvol *= min ( 1.0f, ((float)zvel) / 450.0f ); 

	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN27@CL_TempEnt
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv207[ebp], xmm0
	jmp	SHORT $LN28@CL_TempEnt
$LN27@CL_TempEnt:
	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	movss	DWORD PTR tv207[ebp], xmm0
$LN28@CL_TempEnt:
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR tv207[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0
$LN19@CL_TempEnt:

; 486  : 		
; 487  : 		if( !COM_RandomLong( 0, 3 ) && !isshellcasing )

	push	3
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@CL_TempEnt
	cmp	DWORD PTR _isshellcasing$[ebp], 0
	jne	SHORT $LN20@CL_TempEnt

; 488  : 			pitch = COM_RandomLong( 95, 105 );

	push	105					; 00000069H
	push	95					; 0000005fH
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _pitch$2[ebp], eax
	jmp	SHORT $LN21@CL_TempEnt
$LN20@CL_TempEnt:

; 489  : 		else pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$2[ebp], 100		; 00000064H
$LN21@CL_TempEnt:

; 490  : 
; 491  : 		handle = S_RegisterSound( soundname );

	lea	edx, DWORD PTR _soundname$[ebp]
	push	edx
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$1[ebp], eax

; 492  : 		S_StartSound( pTemp->entity.origin, -(pTemp - cl_tempents), CHAN_BODY, handle, fvol, ATTN_NORM, pitch, SND_STOP_LOOPING );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _pitch$2[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _handle$1[ebp]
	push	ecx
	push	4
	mov	eax, DWORD PTR _pTemp$[ebp]
	sub	eax, DWORD PTR _cl_tempents
	cdq
	mov	ecx, 3068				; 00000bfcH
	idiv	ecx
	neg	eax
	push	eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	add	edx, 2956				; 00000b8cH
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN17@CL_TempEnt:

; 493  : 	}
; 494  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN30@CL_TempEnt:
	DD	$LN4@CL_TempEnt
	DD	$LN5@CL_TempEnt
	DD	$LN6@CL_TempEnt
	DD	$LN7@CL_TempEnt
	DD	$LN8@CL_TempEnt
	DD	$LN10@CL_TempEnt
	DD	$LN11@CL_TempEnt
	DD	$LN9@CL_TempEnt
	DD	$LN12@CL_TempEnt
$LN29@CL_TempEnt:
	DB	0
	DB	1
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
_CL_TempEntPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_modelIndex$ = -16					; size = 4
_modelHandle$ = -12					; size = 4
tv88 = -8						; size = 4
_frameCount$ = -4					; size = 4
_pTemp$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_CL_PrepareTEnt PROC

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 380  : 	int	frameCount = 0;

	mov	DWORD PTR _frameCount$[ebp], 0

; 381  : 	int	modelIndex = 0;

	mov	DWORD PTR _modelIndex$[ebp], 0

; 382  : 	int	modelHandle = pTemp->entity.trivial_accept;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+3028]
	mov	DWORD PTR _modelHandle$[ebp], ecx

; 383  : 
; 384  : 	memset( pTemp, 0, sizeof( *pTemp ));

	push	3068					; 00000bfcH
	push	0
	mov	edx, DWORD PTR _pTemp$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 385  : 
; 386  : 	// use these to set per-frame and termination conditions / actions
; 387  : 	pTemp->entity.trivial_accept = modelHandle; // keep unchanged

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _modelHandle$[ebp]
	mov	DWORD PTR [eax+3028], ecx

; 388  : 	pTemp->flags = FTENT_NONE;		

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], 0

; 389  : 	pTemp->die = cl.time + 0.75f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fe8000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 390  : 
; 391  : 	if( pmodel ) frameCount = pmodel->numframes;

	cmp	DWORD PTR _pmodel$[ebp], 0
	je	SHORT $LN2@CL_Prepare
	mov	ecx, DWORD PTR _pmodel$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _frameCount$[ebp], edx
	jmp	SHORT $LN3@CL_Prepare
$LN2@CL_Prepare:

; 392  : 	else pTemp->flags |= FTENT_NOMODEL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 262144				; 00040000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@CL_Prepare:

; 393  : 
; 394  : 	pTemp->entity.curstate.modelindex = modelIndex;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	mov	DWORD PTR [eax+796], ecx

; 395  : 	pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 0

; 396  : 	pTemp->entity.curstate.renderfx = kRenderFxNone;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 0

; 397  : 	pTemp->entity.curstate.rendercolor.r = 255;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	BYTE PTR [ecx+836], 255			; 000000ffH

; 398  : 	pTemp->entity.curstate.rendercolor.g = 255;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	BYTE PTR [edx+837], 255			; 000000ffH

; 399  : 	pTemp->entity.curstate.rendercolor.b = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	BYTE PTR [eax+838], 255			; 000000ffH

; 400  : 	pTemp->frameMax = Q_max( 0, frameCount - 1 );

	mov	ecx, DWORD PTR _frameCount$[ebp]
	sub	ecx, 1
	jns	SHORT $LN5@CL_Prepare
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN6@CL_Prepare
$LN5@CL_Prepare:
	mov	edx, DWORD PTR _frameCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR tv88[ebp], edx
$LN6@CL_Prepare:
	cvtsi2ss xmm0, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 401  : 	pTemp->entity.curstate.renderamt = 255;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 255		; 000000ffH

; 402  : 	pTemp->entity.curstate.body = 0;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+856], 0

; 403  : 	pTemp->entity.curstate.skin = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	WORD PTR [ecx+812], ax

; 404  : 	pTemp->entity.model = pmodel;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _pmodel$[ebp]
	mov	DWORD PTR [edx+3032], eax

; 405  : 	pTemp->fadeSpeed = 0.5f;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+24], xmm0

; 406  : 	pTemp->hitSound = 0;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+32], 0

; 407  : 	pTemp->clientIndex = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	WORD PTR [ecx+52], ax

; 408  : 	pTemp->bounceFactor = 1;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+28], xmm0

; 409  : 	pTemp->entity.curstate.scale = 1.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+820], xmm0

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PrepareTEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_id$ = 8						; size = 4
_CL_DecalIndex PROC

; 3063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3064 : 	id = bound( 0, id, MAX_DECALS - 1 );

	cmp	DWORD PTR _id$[ebp], 0
	jl	SHORT $LN6@CL_DecalIn
	cmp	DWORD PTR _id$[ebp], 511		; 000001ffH
	jge	SHORT $LN4@CL_DecalIn
	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN5@CL_DecalIn
$LN4@CL_DecalIn:
	mov	DWORD PTR tv66[ebp], 511		; 000001ffH
$LN5@CL_DecalIn:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN7@CL_DecalIn
$LN6@CL_DecalIn:
	mov	DWORD PTR tv67[ebp], 0
$LN7@CL_DecalIn:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _id$[ebp], edx

; 3065 : 
; 3066 : 	if( cl.decal_index[id] == 0 )

	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+2685552]
	test	ecx, ecx
	jne	SHORT $LN2@CL_DecalIn

; 3067 : 	{
; 3068 : 		Image_SetForceFlags( IL_LOAD_DECAL );

	push	32					; 00000020H
	call	_Image_SetForceFlags
	add	esp, 4

; 3069 : 		cl.decal_index[id] = GL_LoadTexture( host.draw_decals[id], NULL, 0, TF_DECAL );

	push	2048					; 00000800H
	push	0
	push	0
	mov	edx, DWORD PTR _id$[ebp]
	shl	edx, 6
	add	edx, OFFSET _host+1468
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _id$[ebp]
	mov	WORD PTR _cl[ecx*2+2685552], ax

; 3070 : 		Image_ClearForceFlags();

	call	_Image_ClearForceFlags
$LN2@CL_DecalIn:

; 3071 : 	}
; 3072 : 
; 3073 : 	return cl.decal_index[id];

	mov	edx, DWORD PTR _id$[ebp]
	movsx	eax, WORD PTR _cl[edx*2+2685552]

; 3074 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_CL_DecalIndexFromName PROC

; 3040 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3041 : 	int	i;
; 3042 : 
; 3043 : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_DecalIn

; 3044 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DecalIn
$LN5@CL_DecalIn:

; 3045 : 
; 3046 : 	// look through the loaded sprite name list for SpriteName
; 3047 : 	for( i = 1; i < MAX_DECALS && host.draw_decals[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_DecalIn
$LN2@CL_DecalIn:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_DecalIn:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@CL_DecalIn
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _host[edx+ecx+1468]
	test	edx, edx
	je	SHORT $LN3@CL_DecalIn

; 3048 : 	{
; 3049 : 		if( !Q_stricmp( name, host.draw_decals[i] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _host+1468
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_DecalIn

; 3050 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@CL_DecalIn
$LN6@CL_DecalIn:

; 3051 : 	}

	jmp	SHORT $LN2@CL_DecalIn
$LN3@CL_DecalIn:

; 3052 : 	return 0; // invalid decal

	xor	eax, eax
$LN1@CL_DecalIn:

; 3053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalIndexFromName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_id$ = -12						; size = 4
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_textureIndex$ = 8					; size = 4
_CL_DecalRemoveAll PROC

; 3084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3085 : 	int id = bound( 0, textureIndex, MAX_DECALS - 1 );	

	cmp	DWORD PTR _textureIndex$[ebp], 0
	jl	SHORT $LN5@CL_DecalRe
	cmp	DWORD PTR _textureIndex$[ebp], 511	; 000001ffH
	jge	SHORT $LN3@CL_DecalRe
	mov	eax, DWORD PTR _textureIndex$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_DecalRe
$LN3@CL_DecalRe:
	mov	DWORD PTR tv66[ebp], 511		; 000001ffH
$LN4@CL_DecalRe:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_DecalRe
$LN5@CL_DecalRe:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_DecalRe:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _id$[ebp], edx

; 3086 : 	R_DecalRemoveAll( cl.decal_index[id] );

	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+2685552]
	push	ecx
	call	_R_DecalRemoveAll
	add	esp, 4

; 3087 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalRemoveAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv257 = -40						; size = 4
tv68 = -36						; size = 4
_dl$1 = -32						; size = 4
_oldorigin$ = -28					; size = 12
_neworigin$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_AddModelEffects PROC

; 2866 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2867 : 	vec3_t	neworigin;
; 2868 : 	vec3_t	oldorigin;
; 2869 : 
; 2870 : 	if( !ent->model ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	jne	SHORT $LN4@CL_AddMode
	jmp	$LN18@CL_AddMode
$LN4@CL_AddMode:

; 2871 : 
; 2872 : 	switch( ent->model->type )

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 2
	jl	SHORT $LN6@CL_AddMode
	cmp	DWORD PTR tv68[ebp], 3
	jle	SHORT $LN5@CL_AddMode
	jmp	SHORT $LN6@CL_AddMode
$LN5@CL_AddMode:

; 2873 : 	{
; 2874 : 	case mod_alias:
; 2875 : 	case mod_studio:
; 2876 : 		break;

	jmp	SHORT $LN2@CL_AddMode
$LN6@CL_AddMode:

; 2877 : 	default:	return;

	jmp	$LN18@CL_AddMode
$LN2@CL_AddMode:

; 2878 : 	}
; 2879 : 
; 2880 : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	$LN7@CL_AddMode

; 2881 : 	{
; 2882 : 		VectorCopy( ent->baseline.vuser1, oldorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+edx+300]
	mov	DWORD PTR _oldorigin$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+300]
	mov	DWORD PTR _oldorigin$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+300]
	mov	DWORD PTR _oldorigin$[ebp+edx], ecx

; 2883 : 		VectorCopy( ent->origin, ent->baseline.vuser1 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx+300], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx+300], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax+300], edx

; 2884 : 		VectorCopy( ent->origin, neworigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+2888]
	mov	DWORD PTR _neworigin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+2888]
	mov	DWORD PTR _neworigin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+2888]
	mov	DWORD PTR _neworigin$[ebp+ecx], eax

; 2885 : 	}

	jmp	$LN8@CL_AddMode
$LN7@CL_AddMode:

; 2886 : 	else
; 2887 : 	{
; 2888 : 		VectorCopy( ent->prevstate.origin, oldorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+edx+364]
	mov	DWORD PTR _oldorigin$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+364]
	mov	DWORD PTR _oldorigin$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+364]
	mov	DWORD PTR _oldorigin$[ebp+edx], ecx

; 2889 : 		VectorCopy( ent->curstate.origin, neworigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+eax+704]
	mov	DWORD PTR _neworigin$[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+704]
	mov	DWORD PTR _neworigin$[ebp+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+704]
	mov	DWORD PTR _neworigin$[ebp+eax], edx
$LN8@CL_AddMode:

; 2890 : 	}
; 2891 : 
; 2892 : 	// NOTE: this completely over control about angles and don't broke interpolation
; 2893 : 	if( FBitSet( ent->model->flags, STUDIO_ROTATE ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN9@CL_AddMode

; 2894 : 		ent->angles[1] = anglemod( 100.0f * cl.time );

	movsd	xmm0, QWORD PTR __real@4059000000000000
	mulsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [ecx+eax+2900]
$LN9@CL_AddMode:

; 2895 : 
; 2896 : 	if( FBitSet( ent->model->flags, STUDIO_GIB ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 4
	je	SHORT $LN10@CL_AddMode

; 2897 : 		R_RocketTrail( oldorigin, neworigin, 2 );

	push	2
	lea	edx, DWORD PTR _neworigin$[ebp]
	push	edx
	lea	eax, DWORD PTR _oldorigin$[ebp]
	push	eax
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN10@CL_AddMode:

; 2898 : 
; 2899 : 	if( FBitSet( ent->model->flags, STUDIO_ZOMGIB ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 32					; 00000020H
	je	SHORT $LN11@CL_AddMode

; 2900 : 		R_RocketTrail( oldorigin, neworigin, 4 );

	push	4
	lea	ecx, DWORD PTR _neworigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _oldorigin$[ebp]
	push	edx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN11@CL_AddMode:

; 2901 : 
; 2902 : 	if( FBitSet( ent->model->flags, STUDIO_TRACER ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 16					; 00000010H
	je	SHORT $LN12@CL_AddMode

; 2903 : 		R_RocketTrail( oldorigin, neworigin, 3 );

	push	3
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN12@CL_AddMode:

; 2904 : 
; 2905 : 	if( FBitSet( ent->model->flags, STUDIO_TRACER2 ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 64					; 00000040H
	je	SHORT $LN13@CL_AddMode

; 2906 : 		R_RocketTrail( oldorigin, neworigin, 5 );

	push	5
	lea	edx, DWORD PTR _neworigin$[ebp]
	push	edx
	lea	eax, DWORD PTR _oldorigin$[ebp]
	push	eax
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN13@CL_AddMode:

; 2907 : 
; 2908 : 	if( FBitSet( ent->model->flags, STUDIO_ROCKET ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 1
	je	$LN14@CL_AddMode

; 2909 : 	{
; 2910 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 2911 : 
; 2912 : 		dl->color.r = dl->color.g = dl->color.b = 200;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+18], 200			; 000000c8H
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [ecx+17], 200			; 000000c8H
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [edx+16], 200			; 000000c8H

; 2913 : 		VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax

; 2914 : 
; 2915 : 		// XASH SPECIFIC: get radius from head entity
; 2916 : 		if( ent->curstate.rendermode != kRenderNormal )

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+760], 0
	je	SHORT $LN15@CL_AddMode

; 2917 : 			dl->radius = Q_max( 0, ent->curstate.renderamt - 55 );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+764]
	sub	eax, 55					; 00000037H
	jns	SHORT $LN20@CL_AddMode
	mov	DWORD PTR tv257[ebp], 0
	jmp	SHORT $LN21@CL_AddMode
$LN20@CL_AddMode:
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	sub	edx, 55					; 00000037H
	mov	DWORD PTR tv257[ebp], edx
$LN21@CL_AddMode:
	cvtsi2ss xmm0, DWORD PTR tv257[ebp]
	mov	eax, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [eax+12], xmm0
	jmp	SHORT $LN16@CL_AddMode
$LN15@CL_AddMode:

; 2918 : 		else dl->radius = 200;

	mov	ecx, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [ecx+12], xmm0
$LN16@CL_AddMode:

; 2919 : 
; 2920 : 		dl->die = cl.time + 0.01f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [edx+20], xmm0

; 2921 : 
; 2922 : 		R_RocketTrail( oldorigin, neworigin, 0 );

	push	0
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN14@CL_AddMode:

; 2923 : 	}
; 2924 : 
; 2925 : 	if( FBitSet( ent->model->flags, STUDIO_GRENADE ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	je	SHORT $LN17@CL_AddMode

; 2926 : 		R_RocketTrail( oldorigin, neworigin, 1 );

	push	1
	lea	edx, DWORD PTR _neworigin$[ebp]
	push	edx
	lea	eax, DWORD PTR _oldorigin$[ebp]
	push	eax
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN17@CL_AddMode:

; 2927 : 
; 2928 : 	if( FBitSet( ent->model->flags, STUDIO_TRACER3 ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 128				; 00000080H
	je	SHORT $LN18@CL_AddMode

; 2929 : 		R_RocketTrail( oldorigin, neworigin, 6 );

	push	6
	lea	ecx, DWORD PTR _neworigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _oldorigin$[ebp]
	push	edx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN18@CL_AddMode:

; 2930 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddModelEffects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv291 = -36						; size = 4
_dl$1 = -32						; size = 4
_dl$2 = -28						; size = 4
_dl$3 = -24						; size = 4
_dl$4 = -20						; size = 4
_fv$5 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_AddEntityEffects PROC

; 2797 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2798 : 	// yellow flies effect 'monster stuck in the wall'
; 2799 : 	if( FBitSet( ent->curstate.effects, EF_BRIGHTFIELD ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, 1
	je	SHORT $LN2@CL_AddEnti

; 2800 : 		R_EntityParticles( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_R_EntityParticles
	add	esp, 4
$LN2@CL_AddEnti:

; 2801 : 
; 2802 : 	if( FBitSet( ent->curstate.effects, EF_DIMLIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, 8
	je	$LN5@CL_AddEnti

; 2803 : 	{
; 2804 : 		if( ent->player && !CL_IsQuakeCompatible( ))

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN4@CL_AddEnti
	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN4@CL_AddEnti

; 2805 : 		{
; 2806 : 			CL_UpdateFlashlight( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_UpdateFlashlight
	add	esp, 4

; 2807 : 		}

	jmp	$LN5@CL_AddEnti
$LN4@CL_AddEnti:

; 2808 : 		else
; 2809 : 		{
; 2810 : 			dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$2[ebp], eax

; 2811 : 			dl->color.r = dl->color.g = dl->color.b = 100;

	mov	eax, DWORD PTR _dl$2[ebp]
	mov	BYTE PTR [eax+18], 100			; 00000064H
	mov	ecx, DWORD PTR _dl$2[ebp]
	mov	BYTE PTR [ecx+17], 100			; 00000064H
	mov	edx, DWORD PTR _dl$2[ebp]
	mov	BYTE PTR [edx+16], 100			; 00000064H

; 2812 : 			dl->radius = COM_RandomFloat( 200, 231 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43670000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _dl$2[ebp]
	fstp	DWORD PTR [eax+12]

; 2813 : 			VectorCopy( ent->origin, dl->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _dl$2[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$2[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$2[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx

; 2814 : 			dl->die = cl.time + 0.001;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _dl$2[ebp]
	movss	DWORD PTR [edx+20], xmm0
$LN5@CL_AddEnti:

; 2815 : 		}
; 2816 : 	}	
; 2817 : 
; 2818 : 	if( FBitSet( ent->curstate.effects, EF_BRIGHTLIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, 4
	je	$LN6@CL_AddEnti

; 2819 : 	{			
; 2820 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$3[ebp], eax

; 2821 : 		dl->color.r = dl->color.g = dl->color.b = 250;

	mov	ecx, DWORD PTR _dl$3[ebp]
	mov	BYTE PTR [ecx+18], 250			; 000000faH
	mov	edx, DWORD PTR _dl$3[ebp]
	mov	BYTE PTR [edx+17], 250			; 000000faH
	mov	eax, DWORD PTR _dl$3[ebp]
	mov	BYTE PTR [eax+16], 250			; 000000faH

; 2822 : 		if( ent->player ) dl->radius = 400; // don't flickering

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN7@CL_AddEnti
	mov	edx, DWORD PTR _dl$3[ebp]
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [edx+12], xmm0
	jmp	SHORT $LN8@CL_AddEnti
$LN7@CL_AddEnti:

; 2823 : 		else dl->radius = COM_RandomFloat( 400, 431 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43d78000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _dl$3[ebp]
	fstp	DWORD PTR [eax+12]
$LN8@CL_AddEnti:

; 2824 : 		VectorCopy( ent->origin, dl->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _dl$3[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$3[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$3[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx

; 2825 : 		dl->die = cl.time + 0.001;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _dl$3[ebp]
	movss	DWORD PTR [edx+20], xmm0

; 2826 : 		dl->origin[2] += 16.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$3[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$3[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN6@CL_AddEnti:

; 2827 : 	}
; 2828 : 
; 2829 : 	// add light effect
; 2830 : 	if( FBitSet( ent->curstate.effects, EF_LIGHT ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+748]
	and	edx, 64					; 00000040H
	je	$LN9@CL_AddEnti

; 2831 : 	{
; 2832 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 2833 : 		dl->color.r = dl->color.g = dl->color.b = 100;

	mov	edx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [edx+18], 100			; 00000064H
	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+17], 100			; 00000064H
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [ecx+16], 100			; 00000064H

; 2834 : 		VectorCopy( ent->origin, dl->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx

; 2835 : 		R_RocketFlare( ent->origin );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 2888				; 00000b48H
	push	eax
	call	_R_RocketFlare
	add	esp, 4

; 2836 : 		dl->die = cl.time + 0.001;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 2837 : 		dl->radius = 200;

	mov	edx, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [edx+12], xmm0
$LN9@CL_AddEnti:

; 2838 : 	}
; 2839 : 
; 2840 : 	// studio models are handle muzzleflashes difference
; 2841 : 	if( FBitSet( ent->curstate.effects, EF_MUZZLEFLASH ) && Mod_AliasExtradata( ent->model ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, 2
	je	$LN10@CL_AddEnti
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	push	eax
	call	_Mod_AliasExtradata
	add	esp, 4
	test	eax, eax
	je	$LN10@CL_AddEnti

; 2842 : 	{
; 2843 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$4[ebp], eax

; 2844 : 		vec3_t	fv;
; 2845 : 
; 2846 : 		ClearBits( ent->curstate.effects, EF_MUZZLEFLASH );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+748], ecx

; 2847 : 		dl->color.r = dl->color.g = dl->color.b = 100;

	mov	eax, DWORD PTR _dl$4[ebp]
	mov	BYTE PTR [eax+18], 100			; 00000064H
	mov	ecx, DWORD PTR _dl$4[ebp]
	mov	BYTE PTR [ecx+17], 100			; 00000064H
	mov	edx, DWORD PTR _dl$4[ebp]
	mov	BYTE PTR [edx+16], 100			; 00000064H

; 2848 : 		VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$4[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$4[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$4[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax

; 2849 : 		AngleVectors( ent->angles, fv, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _fv$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 2900				; 00000b54H
	push	edx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2850 : 		dl->origin[2] += 16.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$4[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$4[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 2851 : 		VectorMA( dl->origin, 18, fv, dl->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@41900000
	mulss	xmm0, DWORD PTR _fv$5[ebp+ecx]
	mov	eax, DWORD PTR _dl$4[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dl$4[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@41900000
	mulss	xmm0, DWORD PTR _fv$5[ebp+edx]
	mov	eax, DWORD PTR _dl$4[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$4[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@41900000
	mulss	xmm0, DWORD PTR _fv$5[ebp+ecx]
	mov	edx, DWORD PTR _dl$4[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv291[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$4[ebp]
	movss	xmm0, DWORD PTR tv291[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 2852 : 		dl->radius = COM_RandomFloat( 200, 231 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43670000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, DWORD PTR _dl$4[ebp]
	fstp	DWORD PTR [edx+12]

; 2853 : 		dl->die = cl.time + 0.1;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fb999999999999a
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$4[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2854 : 		dl->minlight = 32;

	mov	ecx, DWORD PTR _dl$4[ebp]
	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR [ecx+28], xmm0
$LN10@CL_AddEnti:

; 2855 : 	}
; 2856 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddEntityEffects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv189 = -112						; size = 4
tv165 = -108						; size = 4
tv288 = -104						; size = 4
tv287 = -100						; size = 4
tv276 = -96						; size = 4
tv275 = -92						; size = 4
tv264 = -88						; size = 4
tv263 = -84						; size = 4
_trace$ = -80						; size = 4
_hit$ = -76						; size = 4
_dl$ = -72						; size = 4
_falloff$ = -68						; size = 4
_vecEnd$ = -64						; size = 12
_v_angle$1 = -52					; size = 12
_forward$ = -40						; size = 12
_vecSrc$ = -28						; size = 12
_view_ofs$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_UpdateFlashlight PROC

; 2728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2729 : 	vec3_t		forward, view_ofs;
; 2730 : 	vec3_t		vecSrc, vecEnd;
; 2731 : 	float		falloff;
; 2732 : 	pmtrace_t		*trace;
; 2733 : 	cl_entity_t	*hit;
; 2734 : 	dlight_t		*dl;
; 2735 : 
; 2736 : 	if( ent->index == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _cl+1568828
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN2@CL_UpdateF

; 2737 : 	{
; 2738 : 		// local player case
; 2739 : 		AngleVectors( cl.viewangles, forward, NULL, NULL );

	push	0
	push	0
	lea	edx, DWORD PTR _forward$[ebp]
	push	edx
	push	OFFSET _cl+1568612
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2740 : 		VectorCopy( cl.viewheight, view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+1568624]
	mov	DWORD PTR _view_ofs$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+1568624]
	mov	DWORD PTR _view_ofs$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+1568624]
	mov	DWORD PTR _view_ofs$[ebp+eax], ecx

; 2741 : 	}

	jmp	$LN5@CL_UpdateF
$LN2@CL_UpdateF:

; 2742 : 	else	// non-local player case
; 2743 : 	{
; 2744 : 		vec3_t	v_angle;
; 2745 : 
; 2746 : 		// NOTE: pitch divided by 3.0 twice. So we need apply 3^2 = 9
; 2747 : 		v_angle[PITCH] = ent->curstate.angles[PITCH] * 9.0f;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+716]
	mulss	xmm0, DWORD PTR __real@41100000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v_angle$1[ebp+eax], xmm0

; 2748 : 		v_angle[YAW] = ent->angles[YAW];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+2900]
	mov	DWORD PTR _v_angle$1[ebp+edx], ecx

; 2749 : 		v_angle[ROLL] = 0.0f; // roll not used

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_angle$1[ebp+edx], xmm0

; 2750 : 
; 2751 : 		AngleVectors( v_angle, forward, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _forward$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_angle$1[ebp]
	push	ecx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2752 : 		view_ofs[0] = view_ofs[1] = 0.0f;

	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _view_ofs$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _view_ofs$[ebp+ecx], xmm0

; 2753 : 
; 2754 : 		// FIXME: these values are hardcoded ...
; 2755 : 		if( ent->curstate.usehull == 1 )

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+888], 1
	jne	SHORT $LN4@CL_UpdateF

; 2756 : 			view_ofs[2] = 12.0f;	// VEC_DUCK_VIEW;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR _view_ofs$[ebp+eax], xmm0
	jmp	SHORT $LN5@CL_UpdateF
$LN4@CL_UpdateF:

; 2757 : 		else view_ofs[2] = 28.0f;		// DEFAULT_VIEWHEIGHT

	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@41e00000
	movss	DWORD PTR _view_ofs$[ebp+ecx], xmm0
$LN5@CL_UpdateF:

; 2758 : 	}
; 2759 : 
; 2760 : 	VectorAdd( ent->origin, view_ofs, vecSrc );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+2888]
	addss	xmm0, DWORD PTR _view_ofs$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+2888]
	addss	xmm0, DWORD PTR _view_ofs$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecSrc$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+2888]
	addss	xmm0, DWORD PTR _view_ofs$[ebp+eax]
	movss	DWORD PTR tv165[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _vecSrc$[ebp+edx], xmm0

; 2761 : 	VectorMA( vecSrc, FLASHLIGHT_DISTANCE, forward, vecEnd );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _forward$[ebp+eax]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _forward$[ebp+ecx]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _forward$[ebp+ecx]
	movss	xmm1, DWORD PTR _vecSrc$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv189[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv189[ebp]
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0

; 2762 : 
; 2763 : 	trace = CL_VisTraceLine( vecSrc, vecEnd, PM_STUDIO_BOX );

	push	2
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	call	_CL_VisTraceLine
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _trace$[ebp], eax

; 2764 : 
; 2765 : 	// update flashlight endpos
; 2766 : 	dl = CL_AllocDlight( ent->index );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$[ebp], eax

; 2767 : #if 1
; 2768 : 	hit = CL_GetEntityByIndex( clgame.pmove->visents[trace->ent].info );

	mov	ecx, DWORD PTR _trace$[ebp]
	imul	edx, DWORD PTR [ecx+48], 224
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+edx+149416]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _hit$[ebp], eax

; 2769 : 	if( hit && hit->model && ( hit->model->type == mod_alias || hit->model->type == mod_studio ))

	cmp	DWORD PTR _hit$[ebp], 0
	je	$LN6@CL_UpdateF
	mov	edx, DWORD PTR _hit$[ebp]
	cmp	DWORD PTR [edx+2964], 0
	je	SHORT $LN6@CL_UpdateF
	mov	eax, DWORD PTR _hit$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 2
	je	SHORT $LN8@CL_UpdateF
	mov	edx, DWORD PTR _hit$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN6@CL_UpdateF
$LN8@CL_UpdateF:

; 2770 : 		VectorCopy( hit->origin, dl->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _hit$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _hit$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _hit$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx
	jmp	SHORT $LN7@CL_UpdateF
$LN6@CL_UpdateF:

; 2771 : 	else VectorCopy( trace->endpos, dl->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [esi+edx+20]
	mov	DWORD PTR [ecx+eax], edx
$LN7@CL_UpdateF:

; 2772 : #else
; 2773 : 	VectorCopy( trace->endpos, dl->origin );
; 2774 : #endif
; 2775 : 	// compute falloff
; 2776 : 	falloff = trace->fraction * FLASHLIGHT_DISTANCE;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR _falloff$[ebp], xmm0

; 2777 : 	if( falloff < 500.0f ) falloff = 1.0f;

	movss	xmm0, DWORD PTR __real@43fa0000
	comiss	xmm0, DWORD PTR _falloff$[ebp]
	jbe	SHORT $LN9@CL_UpdateF
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _falloff$[ebp], xmm0
	jmp	SHORT $LN10@CL_UpdateF
$LN9@CL_UpdateF:

; 2778 : 	else falloff = 500.0f / falloff;

	movss	xmm0, DWORD PTR __real@43fa0000
	divss	xmm0, DWORD PTR _falloff$[ebp]
	movss	DWORD PTR _falloff$[ebp], xmm0
$LN10@CL_UpdateF:

; 2779 : 	falloff *= falloff;

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR _falloff$[ebp]
	movss	DWORD PTR _falloff$[ebp], xmm0

; 2780 : 
; 2781 : 	// apply brigthness to dlight			
; 2782 : 	dl->color.r = bound( 0, falloff * 255, 255 );

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN14@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv263[ebp], xmm0
	jmp	SHORT $LN13@CL_UpdateF
$LN12@CL_UpdateF:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv263[ebp], xmm0
$LN13@CL_UpdateF:
	movss	xmm0, DWORD PTR tv263[ebp]
	movss	DWORD PTR tv264[ebp], xmm0
	jmp	SHORT $LN15@CL_UpdateF
$LN14@CL_UpdateF:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv264[ebp], xmm0
$LN15@CL_UpdateF:
	cvttss2si ecx, DWORD PTR tv264[ebp]
	mov	edx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [edx+16], cl

; 2783 : 	dl->color.g = bound( 0, falloff * 255, 255 );

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN18@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv275[ebp], xmm0
	jmp	SHORT $LN17@CL_UpdateF
$LN16@CL_UpdateF:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv275[ebp], xmm0
$LN17@CL_UpdateF:
	movss	xmm0, DWORD PTR tv275[ebp]
	movss	DWORD PTR tv276[ebp], xmm0
	jmp	SHORT $LN19@CL_UpdateF
$LN18@CL_UpdateF:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv276[ebp], xmm0
$LN19@CL_UpdateF:
	cvttss2si eax, DWORD PTR tv276[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+17], al

; 2784 : 	dl->color.b = bound( 0, falloff * 255, 255 );

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN22@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv287[ebp], xmm0
	jmp	SHORT $LN21@CL_UpdateF
$LN20@CL_UpdateF:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv287[ebp], xmm0
$LN21@CL_UpdateF:
	movss	xmm0, DWORD PTR tv287[ebp]
	movss	DWORD PTR tv288[ebp], xmm0
	jmp	SHORT $LN23@CL_UpdateF
$LN22@CL_UpdateF:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv288[ebp], xmm0
$LN23@CL_UpdateF:
	cvttss2si edx, DWORD PTR tv288[ebp]
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+18], dl

; 2785 : 	dl->die = cl.time + 0.01f; // die on next frame

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 2786 : 	dl->radius = 80;

	mov	edx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [edx+12], xmm0

; 2787 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateFlashlight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_dl$ = -4						; size = 4
_key$ = 8						; size = 4
_CL_AllocElight PROC

; 2645 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2646 : 	dlight_t	*dl;
; 2647 : 	int	i;
; 2648 : 
; 2649 : 	// first look for an exact key match
; 2650 : 	if( key )

	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN3@CL_AllocEl

; 2651 : 	{
; 2652 : 		for( i = 0, dl = cl_elights; i < MAX_ELIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN4@CL_AllocEl
$LN2@CL_AllocEl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@CL_AllocEl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_AllocEl

; 2653 : 		{
; 2654 : 			if( dl->key == key )

	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR _key$[ebp]
	jne	SHORT $LN9@CL_AllocEl

; 2655 : 			{
; 2656 : 				// reuse this light
; 2657 : 				memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	ecx, DWORD PTR _dl$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2658 : 				dl->key = key;

	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx+32], eax

; 2659 : 				return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	$LN1@CL_AllocEl
$LN9@CL_AllocEl:

; 2660 : 			}
; 2661 : 		}

	jmp	SHORT $LN2@CL_AllocEl
$LN3@CL_AllocEl:

; 2662 : 	}
; 2663 : 
; 2664 : 	// then look for anything else
; 2665 : 	for( i = 0, dl = cl_elights; i < MAX_ELIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN7@CL_AllocEl
$LN5@CL_AllocEl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _dl$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], edx
$LN7@CL_AllocEl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@CL_AllocEl

; 2666 : 	{
; 2667 : 		if( dl->die < cl.time && dl->key == 0 )

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	jbe	SHORT $LN10@CL_AllocEl
	mov	ecx, DWORD PTR _dl$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN10@CL_AllocEl

; 2668 : 		{
; 2669 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	edx, DWORD PTR _dl$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2670 : 			dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2671 : 			return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	SHORT $LN1@CL_AllocEl
$LN10@CL_AllocEl:

; 2672 : 		}
; 2673 : 	}

	jmp	SHORT $LN5@CL_AllocEl
$LN6@CL_AllocEl:

; 2674 : 
; 2675 : 	// otherwise grab first dlight
; 2676 : 	dl = &cl_elights[0];

	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	add	eax, OFFSET _cl_elights
	mov	DWORD PTR _dl$[ebp], eax

; 2677 : 	memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	ecx, DWORD PTR _dl$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2678 : 	dl->key = key;

	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx+32], eax

; 2679 : 
; 2680 : 	return dl;

	mov	eax, DWORD PTR _dl$[ebp]
$LN1@CL_AllocEl:

; 2681 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AllocElight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_dl$ = -4						; size = 4
_key$ = 8						; size = 4
_CL_AllocDlight PROC

; 2600 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2601 : 	dlight_t	*dl;
; 2602 : 	int	i;
; 2603 : 
; 2604 : 	// first look for an exact key match
; 2605 : 	if( key )

	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN3@CL_AllocDl

; 2606 : 	{
; 2607 : 		for( i = 0, dl = cl_dlights; i < MAX_DLIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@CL_AllocDl
$LN2@CL_AllocDl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@CL_AllocDl:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@CL_AllocDl

; 2608 : 		{
; 2609 : 			if( dl->key == key )

	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR _key$[ebp]
	jne	SHORT $LN9@CL_AllocDl

; 2610 : 			{
; 2611 : 				// reuse this light
; 2612 : 				memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	ecx, DWORD PTR _dl$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2613 : 				dl->key = key;

	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx+32], eax

; 2614 : 				return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	$LN1@CL_AllocDl
$LN9@CL_AllocDl:

; 2615 : 			}
; 2616 : 		}

	jmp	SHORT $LN2@CL_AllocDl
$LN3@CL_AllocDl:

; 2617 : 	}
; 2618 : 
; 2619 : 	// then look for anything else
; 2620 : 	for( i = 0, dl = cl_dlights; i < MAX_DLIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN7@CL_AllocDl
$LN5@CL_AllocDl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _dl$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], edx
$LN7@CL_AllocDl:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN6@CL_AllocDl

; 2621 : 	{
; 2622 : 		if( dl->die < cl.time && dl->key == 0 )

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	jbe	SHORT $LN10@CL_AllocDl
	mov	ecx, DWORD PTR _dl$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN10@CL_AllocDl

; 2623 : 		{
; 2624 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	edx, DWORD PTR _dl$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2625 : 			dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2626 : 			return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	SHORT $LN1@CL_AllocDl
$LN10@CL_AllocDl:

; 2627 : 		}
; 2628 : 	}

	jmp	SHORT $LN5@CL_AllocDl
$LN6@CL_AllocDl:

; 2629 : 
; 2630 : 	// otherwise grab first dlight
; 2631 : 	dl = &cl_dlights[0];

	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	add	eax, OFFSET _cl_dlights
	mov	DWORD PTR _dl$[ebp], eax

; 2632 : 	memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	ecx, DWORD PTR _dl$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2633 : 	dl->key = key;

	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx+32], eax

; 2634 : 
; 2635 : 	return dl;

	mov	eax, DWORD PTR _dl$[ebp]
$LN1@CL_AllocDl:

; 2636 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AllocDlight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_handle$ = -48						; size = 4
_fvol$ = -44						; size = 4
_iPitch$ = -40						; size = 4
_soundpath$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_R_RicochetSound PROC

; 1640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1641 : 	int	iPitch = COM_RandomLong( 90, 105 );

	push	105					; 00000069H
	push	90					; 0000005aH
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _iPitch$[ebp], eax

; 1642 : 	float	fvol = COM_RandomFloat( 0.7f, 0.9f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _fvol$[ebp]

; 1643 : 	char	soundpath[32];
; 1644 : 	sound_t	handle;
; 1645 : 
; 1646 : 	Q_snprintf( soundpath, sizeof( soundpath ), "%s", cl_ricochet_sounds[COM_RandomLong( 0, 4 )] );

	push	4
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_ricochet_sounds[eax*4]
	push	eax
	push	OFFSET $SG146704
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundpath$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1647 : 	handle = S_RegisterSound( soundpath );

	lea	edx, DWORD PTR _soundpath$[ebp]
	push	edx
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$[ebp], eax

; 1648 : 
; 1649 : 	S_StartSound( pos, 0, CHAN_AUTO, handle, fvol, ATTN_NORM, iPitch, 0 );

	push	0
	mov	eax, DWORD PTR _iPitch$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 1650 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RicochetSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = 8						; size = 4
_scale$ = 12						; size = 4
_R_Sprite_WallPuff PROC

; 2005 : {

	push	ebp
	mov	ebp, esp

; 2006 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Sprite_W
	jmp	$LN1@R_Sprite_W
$LN2@R_Sprite_W:

; 2007 : 
; 2008 : 	pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+832], 255		; 000000ffH

; 2009 : 	pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 4

; 2010 : 	pTemp->entity.angles[ROLL] = COM_RandomLong( 0, 359 );

	push	359					; 00000167H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+2968], xmm0

; 2011 : 	pTemp->entity.baseline.origin[2] = 30;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [edx+ecx+92], xmm0

; 2012 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 2013 : 	pTemp->die = cl.time + 0.01f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
$LN1@R_Sprite_W:

; 2014 : }

	pop	ebp
	ret	0
_R_Sprite_WallPuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_vel$ = -72						; size = 4
tv260 = -68						; size = 4
tv206 = -64						; size = 4
tv177 = -60						; size = 4
tv360 = -56						; size = 4
tv349 = -52						; size = 4
tv338 = -48						; size = 4
_i$ = -44						; size = 4
_ilength$1 = -40					; size = 4
_pEnt$ = -36						; size = 4
_pTemp$ = -32						; size = 4
_position$ = -28					; size = 12
_dir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_client$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_count$ = 16						; size = 4
_size$ = 20						; size = 4
_R_PlayerSprites PROC

; 1809 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1810 : 	TEMPENTITY	*pTemp;
; 1811 : 	cl_entity_t	*pEnt;
; 1812 : 	vec3_t		position;
; 1813 : 	vec3_t		dir;
; 1814 : 	float		vel;
; 1815 : 	int		i;
; 1816 : 
; 1817 : 	pEnt = CL_GetEntityByIndex( client );

	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 1818 : 
; 1819 : 	if( !pEnt || !pEnt->player )

	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $LN6@R_PlayerSp
	mov	ecx, DWORD PTR _pEnt$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN5@R_PlayerSp
$LN6@R_PlayerSp:

; 1820 : 		return;

	jmp	$LN3@R_PlayerSp
$LN5@R_PlayerSp:

; 1821 : 
; 1822 : 	vel = 128;

	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR _vel$[ebp], xmm0

; 1823 : 
; 1824 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_PlayerSp
$LN2@R_PlayerSp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@R_PlayerSp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_PlayerSp

; 1825 : 	{
; 1826 : 		VectorCopy( pEnt->origin, position );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [eax+edx+2888]
	mov	DWORD PTR _position$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	eax, DWORD PTR [edx+eax+2888]
	mov	DWORD PTR _position$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+2888]
	mov	DWORD PTR _position$[ebp+edx], ecx

; 1827 : 		position[0] += COM_RandomFloat( -10.0f, 10.0f );

	mov	edx, 4
	imul	esi, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv338[ebp]
	movss	xmm0, DWORD PTR tv338[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+esi]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _position$[ebp+ecx], xmm0

; 1828 : 		position[1] += COM_RandomFloat( -10.0f, 10.0f );

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv349[ebp]
	movss	xmm0, DWORD PTR tv349[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+esi]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _position$[ebp+edx], xmm0

; 1829 : 		position[2] += COM_RandomFloat( -20.0f, 36.0f );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@42100000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv360[ebp]
	movss	xmm0, DWORD PTR tv360[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _position$[ebp+eax], xmm0

; 1830 : 
; 1831 : 		pTemp = CL_TempEntAlloc( position, CL_ModelHandle( modelIndex ));

	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _position$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1832 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN7@R_PlayerSp
	jmp	$LN3@R_PlayerSp
$LN7@R_PlayerSp:

; 1833 : 
; 1834 : 		VectorSubtract( pTemp->entity.origin, pEnt->origin, pTemp->tentOffset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+2956]
	subss	xmm0, DWORD PTR [esi+eax+2888]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+56], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+2956]
	subss	xmm0, DWORD PTR [esi+ecx+2888]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+56], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+2956]
	subss	xmm0, DWORD PTR [esi+eax+2888]
	movss	DWORD PTR tv177[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv177[ebp]
	movss	DWORD PTR [eax+edx+56], xmm0

; 1835 : 
; 1836 : 		if ( i != 0 )

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN8@R_PlayerSp

; 1837 : 		{
; 1838 : 			pTemp->flags |= FTENT_PLYRATTACHMENT;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx

; 1839 : 			pTemp->clientIndex = client;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	dx, WORD PTR _client$[ebp]
	mov	WORD PTR [ecx+52], dx

; 1840 : 		}

	jmp	$LN9@R_PlayerSp
$LN8@R_PlayerSp:

; 1841 : 		else
; 1842 : 		{
; 1843 : 			VectorSubtract( position, pEnt->origin, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax+2888]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+2888]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+2888]
	movss	DWORD PTR tv206[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR _dir$[ebp+eax], xmm0

; 1844 : 			VectorNormalize( dir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _dir$[ebp+edx]
	mulss	xmm1, DWORD PTR _dir$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _dir$[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@R_PlayerSp
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN10@R_PlayerSp:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 1845 : 			VectorScale( dir, 60, dir );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@42700000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@42700000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR tv260[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv260[ebp]
	movss	DWORD PTR _dir$[ebp+eax], xmm0

; 1846 : 			VectorCopy( dir, pTemp->entity.baseline.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _dir$[ebp+edx]
	mov	DWORD PTR [eax+ecx+92], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _dir$[ebp+eax]
	mov	DWORD PTR [edx+ecx+92], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR [eax+edx+92], ecx

; 1847 : 			pTemp->entity.baseline.origin[1] = COM_RandomFloat( 20.0f, 60.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+92]
$LN9@R_PlayerSp:

; 1848 : 		}
; 1849 : 
; 1850 : 		pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+840], 14			; 0000000eH

; 1851 : 		pTemp->entity.curstate.framerate = COM_RandomFloat( 1.0f - (size / 100.0f ), 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+852]

; 1852 : 
; 1853 : 		if( pTemp->frameMax > 1 )

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN11@R_PlayerSp

; 1854 : 		{
; 1855 : 			pTemp->flags |= FTENT_SPRANIMATE;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx

; 1856 : 			pTemp->entity.curstate.framerate = 20.0f;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [ecx+852], xmm0

; 1857 : 			pTemp->die = cl.time + (pTemp->frameMax * 0.05f);

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1858 : 		}

	jmp	SHORT $LN12@R_PlayerSp
$LN11@R_PlayerSp:

; 1859 : 		else
; 1860 : 		{
; 1861 : 			pTemp->die = cl.time + 0.35f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fd6666660000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
$LN12@R_PlayerSp:

; 1862 : 		}
; 1863 : 	}

	jmp	$LN2@R_PlayerSp
$LN3@R_PlayerSp:

; 1864 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_PlayerSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv285 = -48						; size = 4
tv253 = -44						; size = 4
tv242 = -40						; size = 4
tv232 = -36						; size = 4
_time$ = -32						; size = 4
_pmodel$ = -28						; size = 4
_i$ = -24						; size = 4
_pTemp$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_count$ = 20						; size = 4
_flags$ = 24						; size = 4
_life$ = 28						; size = 4
_R_FireField PROC

; 1874 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1875 : 	TEMPENTITY	*pTemp;
; 1876 : 	model_t		*pmodel;
; 1877 : 	float		time;
; 1878 : 	vec3_t		pos;
; 1879 : 	int		i;
; 1880 : 
; 1881 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN5@R_FireFiel

; 1882 : 		return;

	jmp	$LN3@R_FireFiel
$LN5@R_FireFiel:

; 1883 : 
; 1884 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_FireFiel
$LN2@R_FireFiel:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@R_FireFiel:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	$LN3@R_FireFiel

; 1885 : 	{
; 1886 : 		VectorCopy( org, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pos$[ebp+ecx], eax

; 1887 : 		pos[0] += COM_RandomFloat( -radius, radius );

	mov	ecx, 4
	imul	esi, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _radius$[ebp]
	neg	edx
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _pos$[ebp+ecx], xmm0

; 1888 : 		pos[1] += COM_RandomFloat( -radius, radius );

	mov	esi, 4
	shl	esi, 0
	cvtsi2ss xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _radius$[ebp]
	neg	edx
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv242[ebp]
	movss	xmm0, DWORD PTR tv242[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _pos$[ebp+eax], xmm0

; 1889 : 
; 1890 : 		if( !FBitSet( flags, TEFIRE_FLAG_PLANAR ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN6@R_FireFiel

; 1891 : 			pos[2] += COM_RandomFloat( -radius, radius );

	mov	esi, 4
	shl	esi, 1
	cvtsi2ss xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _radius$[ebp]
	neg	edx
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv253[ebp]
	movss	xmm0, DWORD PTR tv253[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _pos$[ebp+eax], xmm0
$LN6@R_FireFiel:

; 1892 : 
; 1893 : 		pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1894 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN7@R_FireFiel
	jmp	$LN3@R_FireFiel
$LN7@R_FireFiel:

; 1895 : 
; 1896 : 		if( FBitSet( flags, TEFIRE_FLAG_ALPHA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN8@R_FireFiel

; 1897 : 		{
; 1898 : 			pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 4

; 1899 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+840], 14			; 0000000eH

; 1900 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 128;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+832], 128		; 00000080H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 128		; 00000080H

; 1901 : 		}

	jmp	SHORT $LN11@R_FireFiel
$LN8@R_FireFiel:

; 1902 : 		else if( FBitSet( flags, TEFIRE_FLAG_ADDITIVE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN10@R_FireFiel

; 1903 : 		{
; 1904 : 			pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 5

; 1905 : 			pTemp->entity.curstate.renderamt = 80;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 80			; 00000050H

; 1906 : 		}

	jmp	SHORT $LN11@R_FireFiel
$LN10@R_FireFiel:

; 1907 : 		else
; 1908 : 		{
; 1909 : 			pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 0

; 1910 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 14			; 0000000eH

; 1911 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 255;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 255		; 000000ffH
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+152], 255		; 000000ffH
$LN11@R_FireFiel:

; 1912 : 		}
; 1913 : 
; 1914 : 		pTemp->entity.curstate.framerate = COM_RandomFloat( 0.75f, 1.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3fa00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+852]

; 1915 : 		time = life + COM_RandomFloat( -0.25f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv285[ebp]
	movss	xmm0, DWORD PTR tv285[ebp]
	addss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR _time$[ebp], xmm0

; 1916 : 		pTemp->die = cl.time + time;

	cvtss2sd xmm0, DWORD PTR _time$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1917 : 
; 1918 : 		if( pTemp->frameMax > 1 )

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@R_FireFiel

; 1919 : 		{
; 1920 : 			pTemp->flags |= FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1921 : 
; 1922 : 			if( FBitSet( flags, TEFIRE_FLAG_LOOP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN13@R_FireFiel

; 1923 : 			{
; 1924 : 				pTemp->entity.curstate.framerate = 15.0f;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [ecx+852], xmm0

; 1925 : 				pTemp->flags |= FTENT_SPRANIMATELOOP;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1926 : 			}

	jmp	SHORT $LN14@R_FireFiel
$LN13@R_FireFiel:

; 1927 : 			else
; 1928 : 			{
; 1929 : 				pTemp->entity.curstate.framerate = pTemp->frameMax / time;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	divss	xmm0, DWORD PTR _time$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+852], xmm0
$LN14@R_FireFiel:

; 1930 : 			}
; 1931 : 		}
; 1932 : 
; 1933 : 		if( FBitSet( flags, TEFIRE_FLAG_ALLFLOAT ) || ( FBitSet( flags, TEFIRE_FLAG_SOMEFLOAT ) && !COM_RandomLong( 0, 1 )))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	jne	SHORT $LN16@R_FireFiel
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN15@R_FireFiel
	push	1
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@R_FireFiel
$LN16@R_FireFiel:

; 1934 : 		{
; 1935 : 			// drift sprite upward
; 1936 : 			pTemp->entity.baseline.origin[2] = COM_RandomFloat( 10.0f, 30.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]
$LN15@R_FireFiel:

; 1937 : 		}
; 1938 : 	}

	jmp	$LN2@R_FireFiel
$LN3@R_FireFiel:

; 1939 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FireField ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
$T1 = -256						; size = 68
_decalIndex$ = -188					; size = 4
_e$2 = -184						; size = 4
_z$3 = -180						; size = 4
tv249 = -176						; size = 4
tv304 = -172						; size = 4
tv241 = -168						; size = 4
tv233 = -164						; size = 4
tv302 = -160						; size = 4
tv225 = -156						; size = 4
_y$4 = -152						; size = 4
_x$5 = -148						; size = 4
_i$ = -144						; size = 4
_pe$6 = -140						; size = 4
_j$ = -136						; size = 4
_trace$ = -132						; size = 68
_vecEnd$ = -64						; size = 12
_vecDir$ = -52						; size = 12
_up$ = -40						; size = 12
_right$ = -28						; size = 12
_vecSrc$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_dir$ = 12						; size = 4
_noise$ = 16						; size = 4
_count$ = 20						; size = 4
_decalCount$ = 24					; size = 4
_decalIndices$ = 28					; size = 4
_R_MultiGunshot PROC

; 1949 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1950 : 	pmtrace_t	trace;
; 1951 : 	vec3_t	right, up;
; 1952 : 	vec3_t	vecSrc, vecDir, vecEnd;
; 1953 : 	int	i, j, decalIndex;
; 1954 : 
; 1955 : 	VectorVectors( dir, right, up );

	lea	eax, DWORD PTR _up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dir$[ebp]
	push	edx
	call	_VectorVectors
	add	esp, 12					; 0000000cH

; 1956 : 	VectorCopy( org, vecSrc );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _vecSrc$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _vecSrc$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _vecSrc$[ebp+ecx], eax

; 1957 : 
; 1958 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_MultiGun
$LN2@R_MultiGun:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@R_MultiGun:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	$LN3@R_MultiGun
$LN7@R_MultiGun:

; 1959 : 	{
; 1960 : 		// get circular gaussian spread
; 1961 : 		float x, y, z;
; 1962 : 		do {
; 1963 : 			x = COM_RandomFloat( -0.5f, 0.5f ) + COM_RandomFloat( -0.5f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv225[ebp]
	movss	xmm0, DWORD PTR tv225[ebp]
	push	ecx
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm1, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv302[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv233[ebp]
	movss	xmm0, DWORD PTR tv302[ebp]
	addss	xmm0, DWORD PTR tv233[ebp]
	movss	DWORD PTR _x$5[ebp], xmm0

; 1964 : 			y = COM_RandomFloat( -0.5f, 0.5f ) + COM_RandomFloat( -0.5f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	push	ecx
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm1, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv304[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv249[ebp]
	movss	xmm0, DWORD PTR tv304[ebp]
	addss	xmm0, DWORD PTR tv249[ebp]
	movss	DWORD PTR _y$4[ebp], xmm0

; 1965 : 			z = x * x + y * y;

	movss	xmm0, DWORD PTR _x$5[ebp]
	mulss	xmm0, DWORD PTR _x$5[ebp]
	movss	xmm1, DWORD PTR _y$4[ebp]
	mulss	xmm1, DWORD PTR _y$4[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _z$3[ebp], xmm0

; 1966 : 		} while( z > 1.0f );

	movss	xmm0, DWORD PTR _z$3[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	ja	$LN7@R_MultiGun

; 1967 : 
; 1968 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@R_MultiGun
$LN8@R_MultiGun:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@R_MultiGun:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN9@R_MultiGun

; 1969 : 		{
; 1970 : 			vecDir[j] = dir[j] + x * noise[0] * right[j] + y * noise[1] * up[j];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _noise$[ebp]
	movss	xmm0, DWORD PTR _x$5[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR _j$[ebp]
	mulss	xmm0, DWORD PTR _right$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _noise$[ebp]
	movss	xmm1, DWORD PTR _y$4[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _j$[ebp]
	mulss	xmm1, DWORD PTR _up$[ebp+eax*4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _vecDir$[ebp+ecx*4], xmm0

; 1971 : 			vecEnd[j] = vecSrc[j] + 4096.0f * vecDir[j];

	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR __real@45800000
	mulss	xmm0, DWORD PTR _vecDir$[ebp+edx*4]
	mov	eax, DWORD PTR _j$[ebp]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _vecEnd$[ebp+ecx*4], xmm0

; 1972 : 		}

	jmp	$LN8@R_MultiGun
$LN9@R_MultiGun:

; 1973 : 
; 1974 : 		trace = CL_TraceLine( vecSrc, vecEnd, PM_STUDIO_IGNORE );

	push	1
	lea	edx, DWORD PTR _vecEnd$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecSrc$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1975 : 
; 1976 : 		// paint decals
; 1977 : 		if( trace.fraction != 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN14@R_MultiGun

; 1978 : 		{
; 1979 : 			physent_t	*pe = NULL;

	mov	DWORD PTR _pe$6[ebp], 0

; 1980 : 
; 1981 : 			if( i & 2 ) R_RicochetSound( trace.endpos );

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 2
	je	SHORT $LN12@R_MultiGun
	lea	eax, DWORD PTR _trace$[ebp+20]
	push	eax
	call	_R_RicochetSound
	add	esp, 4
$LN12@R_MultiGun:

; 1982 : 			R_BulletImpactParticles( trace.endpos );

	lea	ecx, DWORD PTR _trace$[ebp+20]
	push	ecx
	call	_R_BulletImpactParticles
	add	esp, 4

; 1983 : 
; 1984 : 			if( trace.ent >= 0 && trace.ent < clgame.pmove->numphysent )

	cmp	DWORD PTR _trace$[ebp+48], 0
	jl	SHORT $LN13@R_MultiGun
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	eax, DWORD PTR [edx+588]
	jge	SHORT $LN13@R_MultiGun

; 1985 : 				pe = &clgame.pmove->physents[trace.ent];

	imul	ecx, DWORD PTR _trace$[ebp+48], 224
	mov	edx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [edx+ecx+592]
	mov	DWORD PTR _pe$6[ebp], eax
$LN13@R_MultiGun:

; 1986 : 
; 1987 : 			if( pe && ( pe->solid == SOLID_BSP || pe->movetype == MOVETYPE_PUSHSTEP ))

	cmp	DWORD PTR _pe$6[ebp], 0
	je	SHORT $LN14@R_MultiGun
	mov	ecx, DWORD PTR _pe$6[ebp]
	cmp	DWORD PTR [ecx+96], 4
	je	SHORT $LN15@R_MultiGun
	mov	edx, DWORD PTR _pe$6[ebp]
	cmp	DWORD PTR [edx+124], 13			; 0000000dH
	jne	SHORT $LN14@R_MultiGun
$LN15@R_MultiGun:

; 1988 : 			{
; 1989 : 				cl_entity_t *e = CL_GetEntityByIndex( pe->info );

	mov	eax, DWORD PTR _pe$6[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _e$2[ebp], eax

; 1990 : 				decalIndex = CL_DecalIndex( decalIndices[COM_RandomLong( 0, decalCount-1 )] );

	mov	edx, DWORD PTR _decalCount$[ebp]
	sub	edx, 1
	push	edx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _decalIndices$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_DecalIndex
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 1991 : 				CL_DecalShoot( decalIndex, e->index, 0, trace.endpos, 0 );

	push	0
	lea	eax, DWORD PTR _trace$[ebp+20]
	push	eax
	push	0
	mov	ecx, DWORD PTR _e$2[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H
$LN14@R_MultiGun:

; 1992 : 			}
; 1993 : 		}
; 1994 : 	}

	jmp	$LN2@R_MultiGun
$LN3@R_MultiGun:

; 1995 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_MultiGunshot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv247 = -16						; size = 4
_i$ = -12						; size = 4
_ilength$1 = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_speed$ = 12						; size = 4
_life$ = 16						; size = 4
_count$ = 20						; size = 4
_modelIndex$ = 24					; size = 4
_R_TempSphereModel PROC

; 1709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 1710 : 	TEMPENTITY	*pTemp;
; 1711 : 	int		i;
; 1712 : 
; 1713 : 	// create temp models
; 1714 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_TempSphe
$LN2@R_TempSphe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_TempSphe:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	$LN3@R_TempSphe

; 1715 : 	{
; 1716 : 		pTemp = CL_TempEntAlloc( pos, CL_ModelHandle( modelIndex ));

	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1717 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN5@R_TempSphe
	jmp	$LN3@R_TempSphe
$LN5@R_TempSphe:

; 1718 : 
; 1719 : 		pTemp->entity.curstate.body = COM_RandomLong( 0, pTemp->frameMax );

	mov	ecx, DWORD PTR _pTemp$[ebp]
	cvttss2si edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+856], eax

; 1720 : 
; 1721 : 		if( COM_RandomLong( 0, 255 ) < 10 )

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN6@R_TempSphe

; 1722 : 			pTemp->flags |= FTENT_SLOWGRAVITY;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 8
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN7@R_TempSphe
$LN6@R_TempSphe:

; 1723 : 		else pTemp->flags |= FTENT_GRAVITY;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 2
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@R_TempSphe:

; 1724 : 
; 1725 : 		if( COM_RandomLong( 0, 255 ) < 200 )

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 200				; 000000c8H
	jge	$LN8@R_TempSphe

; 1726 : 		{
; 1727 : 			pTemp->flags |= FTENT_ROTATE;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 4
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1728 : 			pTemp->entity.baseline.angles[0] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1729 : 			pTemp->entity.baseline.angles[1] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+104]

; 1730 : 			pTemp->entity.baseline.angles[2] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]
$LN8@R_TempSphe:

; 1731 : 		}
; 1732 : 
; 1733 : 		if( COM_RandomLong( 0, 255 ) < 100 )

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 100				; 00000064H
	jge	SHORT $LN9@R_TempSphe

; 1734 : 			pTemp->flags |= FTENT_SMOKETRAIL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN9@R_TempSphe:

; 1735 : 
; 1736 : 		pTemp->flags |= FTENT_FLICKER | FTENT_COLLIDEWORLD;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1737 : 		pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 0

; 1738 : 		pTemp->entity.curstate.effects = i & 31;

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+816], ecx

; 1739 : 		pTemp->entity.baseline.origin[0] = COM_RandomFloat( -1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+92]

; 1740 : 		pTemp->entity.baseline.origin[1] = COM_RandomFloat( -1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1741 : 		pTemp->entity.baseline.origin[2] = COM_RandomFloat( -1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+92]

; 1742 : 
; 1743 : 		VectorNormalize( pTemp->entity.baseline.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+92]
	mulss	xmm0, DWORD PTR [esi+ecx+92]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+92]
	mulss	xmm1, DWORD PTR [esi+edx+92]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+92]
	mulss	xmm1, DWORD PTR [esi+edx+92]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@R_TempSphe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN10@R_TempSphe:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+92]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+92]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1744 : 		VectorScale( pTemp->entity.baseline.origin, speed, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+92]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv247[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv247[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1745 : 		pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 1746 : 	}

	jmp	$LN2@R_TempSphe
$LN3@R_TempSphe:

; 1747 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TempSphereModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv183 = -36						; size = 4
tv182 = -32						; size = 4
_pmodel$ = -28						; size = 4
_ilength$1 = -24					; size = 4
_pTemp$ = -20						; size = 4
_dir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_velocity$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_life$ = 20						; size = 4
_owner$ = 24						; size = 4
_hitcallback$ = 28					; size = 4
_R_Projectile PROC

; 1660 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1661 : 	TEMPENTITY	*pTemp;
; 1662 : 	model_t		*pmodel;
; 1663 : 	vec3_t		dir;
; 1664 : 
; 1665 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN2@R_Projecti

; 1666 : 		return;

	jmp	$LN1@R_Projecti
$LN2@R_Projecti:

; 1667 : 
; 1668 : 	pTemp = CL_TempEntAllocHigh( origin, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1669 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN3@R_Projecti
	jmp	$LN1@R_Projecti
$LN3@R_Projecti:

; 1670 : 
; 1671 : 	VectorCopy( velocity, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+92], eax

; 1672 : 
; 1673 : 	if( pmodel->type == mod_sprite )

	mov	ecx, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [ecx+68], 1
	jne	SHORT $LN4@R_Projecti

; 1674 : 	{
; 1675 : 		SetBits( pTemp->flags, FTENT_SPRANIMATE );

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1676 : 
; 1677 : 		if( pTemp->frameMax < 10 )

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR [edx+8]
	jbe	SHORT $LN6@R_Projecti

; 1678 : 		{
; 1679 : 			SetBits( pTemp->flags, FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP );

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 65792				; 00010100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1680 : 			pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+852], xmm0

; 1681 : 		}

	jmp	SHORT $LN7@R_Projecti
$LN6@R_Projecti:

; 1682 : 		else
; 1683 : 		{
; 1684 : 			pTemp->entity.curstate.framerate = pTemp->frameMax / life;

	cvtsi2ss xmm0, DWORD PTR _life$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	divss	xmm1, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+852], xmm1
$LN7@R_Projecti:

; 1685 : 		}
; 1686 : 	}

	jmp	$LN5@R_Projecti
$LN4@R_Projecti:

; 1687 : 	else
; 1688 : 	{
; 1689 : 		pTemp->frameMax = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0

; 1690 : 		VectorNormalize2( velocity, dir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@R_Projecti
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN8@R_Projecti:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 1691 : 		VectorAngles( dir, pTemp->entity.angles );

	mov	eax, DWORD PTR _pTemp$[ebp]
	add	eax, 2968				; 00000b98H
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	_VectorAngles
	add	esp, 8
$LN5@R_Projecti:

; 1692 : 	}
; 1693 : 
; 1694 : 	pTemp->flags |= FTENT_COLLIDEALL|FTENT_PERSIST|FTENT_COLLIDEKILL;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 28672				; 00007000H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1695 : 	pTemp->clientIndex = bound( 1, owner, cl.maxclients );

	cmp	DWORD PTR _owner$[ebp], 1
	jl	SHORT $LN12@R_Projecti
	mov	edx, DWORD PTR _owner$[ebp]
	cmp	edx, DWORD PTR _cl+1568832
	jge	SHORT $LN10@R_Projecti
	mov	eax, DWORD PTR _owner$[ebp]
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN11@R_Projecti
$LN10@R_Projecti:
	mov	ecx, DWORD PTR _cl+1568832
	mov	DWORD PTR tv182[ebp], ecx
$LN11@R_Projecti:
	mov	edx, DWORD PTR tv182[ebp]
	mov	DWORD PTR tv183[ebp], edx
	jmp	SHORT $LN13@R_Projecti
$LN12@R_Projecti:
	mov	DWORD PTR tv183[ebp], 1
$LN13@R_Projecti:
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cx, WORD PTR tv183[ebp]
	mov	WORD PTR [eax+52], cx

; 1696 : 	pTemp->entity.baseline.renderamt = 255;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+152], 255		; 000000ffH

; 1697 : 	pTemp->hitcallback = hitcallback;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _hitcallback$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1698 : 	pTemp->die = cl.time + life;

	cvtsi2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0
$LN1@R_Projecti:

; 1699 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Projectile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_count$ = 12						; size = 4
_velocityMin$ = 16					; size = 4
_velocityMax$ = 20					; size = 4
_R_SparkEffect PROC

; 1627 : {

	push	ebp
	mov	ebp, esp

; 1628 : 	R_RicochetSprite( pos, cl_sprite_ricochet, 0.1f, COM_RandomFloat( 0.5f, 1.0f ));

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cl_sprite_ricochet
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_RicochetSprite
	add	esp, 16					; 00000010H

; 1629 : 	R_SparkStreaks( pos, count, velocityMin, velocityMax );

	mov	edx, DWORD PTR _velocityMax$[ebp]
	push	edx
	mov	eax, DWORD PTR _velocityMin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_SparkStreaks
	add	esp, 16					; 00000010H

; 1630 : }

	pop	ebp
	ret	0
_R_SparkEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_dist$ = -72						; size = 4
tv256 = -68						; size = 4
tv398 = -64						; size = 4
tv211 = -60						; size = 4
tv172 = -56						; size = 4
tv291 = -52						; size = 4
_pmodel$ = -48						; size = 4
_j$ = -44						; size = 4
_i$ = -40						; size = 4
_vel$ = -36						; size = 4
_pTemp$ = -32						; size = 4
_dest$ = -28						; size = 12
_dir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_reverse$ = 16						; size = 4
_R_FunnelSprite PROC

; 1565 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1566 : 	TEMPENTITY	*pTemp;
; 1567 : 	vec3_t		dir, dest;
; 1568 : 	float		dist, vel;
; 1569 : 	model_t		*pmodel;
; 1570 : 	int		i, j;
; 1571 : 
; 1572 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN8@R_FunnelSp

; 1573 : 	{
; 1574 : 		Con_Reportf( S_ERROR "no model %d!\n", modelIndex );

	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	OFFSET $SG146682
	call	_Con_Reportf
	add	esp, 8

; 1575 : 		return;

	jmp	$LN3@R_FunnelSp
$LN8@R_FunnelSp:

; 1576 : 	}
; 1577 : 
; 1578 : 	for( i = -8; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], -8			; fffffff8H
	jmp	SHORT $LN4@R_FunnelSp
$LN2@R_FunnelSp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@R_FunnelSp:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN3@R_FunnelSp

; 1579 : 	{
; 1580 : 		for( j = -8; j < 8; j++ )

	mov	DWORD PTR _j$[ebp], -8			; fffffff8H
	jmp	SHORT $LN7@R_FunnelSp
$LN5@R_FunnelSp:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@R_FunnelSp:
	cmp	DWORD PTR _j$[ebp], 8
	jge	$LN6@R_FunnelSp

; 1581 : 		{
; 1582 : 			pTemp = CL_TempEntAlloc( org, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1583 : 			if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN9@R_FunnelSp
	jmp	$LN3@R_FunnelSp
$LN9@R_FunnelSp:

; 1584 : 
; 1585 : 			dest[0] = (i * 32.0f) + org[0];

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR __real@42000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dest$[ebp+ecx], xmm0

; 1586 : 			dest[1] = (j * 32.0f) + org[1];

	cvtsi2ss xmm0, DWORD PTR _j$[ebp]
	mulss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dest$[ebp+ecx], xmm0

; 1587 : 			dest[2] = org[2] + COM_RandomFloat( 100.0f, 800.0f );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv291[ebp]
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR tv291[ebp]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _dest$[ebp+eax], xmm0

; 1588 : 
; 1589 : 			if( reverse )

	cmp	DWORD PTR _reverse$[ebp], 0
	je	$LN10@R_FunnelSp

; 1590 : 			{
; 1591 : 				VectorCopy( org, pTemp->entity.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+2956], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+2956], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+2956], ecx

; 1592 : 				VectorSubtract( dest, pTemp->entity.origin, dir );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _dest$[ebp+eax]
	subss	xmm0, DWORD PTR [ecx+edx+2956]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _dest$[ebp+ecx]
	subss	xmm0, DWORD PTR [eax+edx+2956]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _dest$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+2956]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 1593 : 			}

	jmp	$LN11@R_FunnelSp
$LN10@R_FunnelSp:

; 1594 : 			else
; 1595 : 			{
; 1596 : 				VectorCopy( dest, pTemp->entity.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp+ecx]
	mov	DWORD PTR [edx+eax+2956], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _dest$[ebp+edx]
	mov	DWORD PTR [ecx+eax+2956], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _dest$[ebp+eax]
	mov	DWORD PTR [edx+ecx+2956], eax

; 1597 : 				VectorSubtract( org, pTemp->entity.origin, dir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _org$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [esi+ecx+2956]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+2956]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _org$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx+2956]
	movss	DWORD PTR tv211[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
$LN11@R_FunnelSp:

; 1598 : 			}
; 1599 : 
; 1600 : 			pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 3

; 1601 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 14			; 0000000eH

; 1602 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 200;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 200		; 000000c8H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+152], 200		; 000000c8H

; 1603 : 			pTemp->entity.baseline.angles[2] = COM_RandomFloat( -100.0f, 100.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c80000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1604 : 			pTemp->entity.curstate.framerate = COM_RandomFloat( 0.1f, 0.4f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+852]

; 1605 : 			pTemp->flags = FTENT_ROTATE|FTENT_FADEOUT;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 132			; 00000084H

; 1606 : 			pTemp->entity.curstate.framerate = 10;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+852], xmm0

; 1607 : 
; 1608 : 			vel = dest[2] / 8.0f;

	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _dest$[ebp+edx]
	divss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vel$[ebp], xmm0

; 1609 : 			if( vel < 64.0f ) vel = 64.0f;

	movss	xmm0, DWORD PTR __real@42800000
	comiss	xmm0, DWORD PTR _vel$[ebp]
	jbe	SHORT $LN12@R_FunnelSp
	movss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _vel$[ebp], xmm0
$LN12@R_FunnelSp:

; 1610 : 			dist = VectorNormalizeLength( dir );

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 1611 : 			vel += COM_RandomFloat( 64.0f, 128.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv398[ebp]
	movss	xmm0, DWORD PTR tv398[ebp]
	addss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR _vel$[ebp], xmm0

; 1612 : 			VectorScale( dir, vel, pTemp->entity.baseline.origin );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _vel$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vel$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR tv256[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv256[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0

; 1613 : 			pTemp->die = cl.time + (dist / vel) - 0.5f;

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR _vel$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1614 : 			pTemp->fadeSpeed = 2.0f;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [edx+24], xmm0

; 1615 : 		}

	jmp	$LN5@R_FunnelSp
$LN6@R_FunnelSp:

; 1616 : 	}

	jmp	$LN2@R_FunnelSp
$LN3@R_FunnelSp:

; 1617 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FunnelSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv499 = -108						; size = 8
tv502 = -100						; size = 8
tv452 = -92						; size = 4
tv441 = -88						; size = 4
tv430 = -84						; size = 4
tv239 = -80						; size = 4
tv219 = -76						; size = 4
tv87 = -72						; size = 4
_pmodel$ = -68						; size = 4
_ilength$1 = -64					; size = 4
_i$ = -60						; size = 4
_pTemp$ = -56						; size = 4
_dir$ = -52						; size = 12
_pos$2 = -40						; size = 12
_vel$3 = -28						; size = 12
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_count$ = 24						; size = 4
_life$ = 28						; size = 4
_size$ = 32						; size = 4
_amp$ = 36						; size = 4
_renderamt$ = 40					; size = 4
_speed$ = 44						; size = 4
_R_Sprite_Trail PROC

; 1513 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1514 : 	TEMPENTITY	*pTemp;
; 1515 : 	vec3_t		delta, dir;
; 1516 : 	model_t		*pmodel;
; 1517 : 	int		i;
; 1518 : 
; 1519 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN5@R_Sprite_T

; 1520 : 		return;

	jmp	$LN3@R_Sprite_T
$LN5@R_Sprite_T:

; 1521 : 
; 1522 : 	VectorSubtract( end, start, delta );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx]
	movss	DWORD PTR tv87[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR _delta$[ebp+ecx], xmm0

; 1523 : 	VectorNormalize2( delta, dir );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_Sprite_T
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN6@R_Sprite_T:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 1524 : 
; 1525 : 	amp /= 256.0f;

	movss	xmm0, DWORD PTR _amp$[ebp]
	divss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR _amp$[ebp], xmm0

; 1526 : 
; 1527 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Sprite_T
$LN2@R_Sprite_T:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Sprite_T:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	$LN3@R_Sprite_T

; 1528 : 	{
; 1529 : 		vec3_t	pos, vel;
; 1530 : 
; 1531 : 		// Be careful of divide by 0 when using 'count' here...
; 1532 : 		if( i == 0 ) VectorCopy( start, pos );

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN7@R_Sprite_T
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _pos$2[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _pos$2[ebp+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$2[ebp+eax], edx
	jmp	$LN8@R_Sprite_T
$LN7@R_Sprite_T:

; 1533 : 		else VectorMA( start, ( i / ( count - 1.0f )), delta, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _pos$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _pos$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv219[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR _pos$2[ebp+eax], xmm0
$LN8@R_Sprite_T:

; 1534 : 
; 1535 : 		pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$2[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1536 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN9@R_Sprite_T
	jmp	$LN3@R_Sprite_T
$LN9@R_Sprite_T:

; 1537 : 
; 1538 : 		pTemp->flags = (FTENT_COLLIDEWORLD|FTENT_SPRCYCLE|FTENT_FADEOUT|FTENT_SLOWGRAVITY);

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 2216			; 000008a8H

; 1539 : 
; 1540 : 		VectorScale( dir, speed, vel );

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vel$3[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vel$3[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv239[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv239[ebp]
	movss	DWORD PTR _vel$3[ebp+edx], xmm0

; 1541 : 		vel[0] += COM_RandomFloat( -127.0f, 128.0f ) * amp;

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2fe0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv430[ebp]
	movss	xmm0, DWORD PTR tv430[ebp]
	mulss	xmm0, DWORD PTR _amp$[ebp]
	addss	xmm0, DWORD PTR _vel$3[ebp+esi]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vel$3[ebp+edx], xmm0

; 1542 : 		vel[1] += COM_RandomFloat( -127.0f, 128.0f ) * amp;

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2fe0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv441[ebp]
	movss	xmm0, DWORD PTR tv441[ebp]
	mulss	xmm0, DWORD PTR _amp$[ebp]
	addss	xmm0, DWORD PTR _vel$3[ebp+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vel$3[ebp+eax], xmm0

; 1543 : 		vel[2] += COM_RandomFloat( -127.0f, 128.0f ) * amp;

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2fe0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv452[ebp]
	movss	xmm0, DWORD PTR tv452[ebp]
	mulss	xmm0, DWORD PTR _amp$[ebp]
	addss	xmm0, DWORD PTR _vel$3[ebp+esi]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vel$3[ebp+ecx], xmm0

; 1544 : 		VectorCopy( vel, pTemp->entity.baseline.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _vel$3[ebp+eax]
	mov	DWORD PTR [ecx+edx+92], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _vel$3[ebp+ecx]
	mov	DWORD PTR [eax+edx+92], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _vel$3[ebp+edx]
	mov	DWORD PTR [ecx+eax+92], edx

; 1545 : 		VectorCopy( pos, pTemp->entity.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _pos$2[ebp+ecx]
	mov	DWORD PTR [edx+eax+2956], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _pos$2[ebp+edx]
	mov	DWORD PTR [ecx+eax+2956], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _pos$2[ebp+eax]
	mov	DWORD PTR [edx+ecx+2956], eax

; 1546 : 
; 1547 : 		pTemp->entity.curstate.scale = size;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [ecx+820], xmm0

; 1548 : 		pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 3

; 1549 : 		pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 14			; 0000000eH

; 1550 : 		pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = renderamt;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _renderamt$[ebp]
	mov	DWORD PTR [ecx+152], edx
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _renderamt$[ebp]
	mov	DWORD PTR [eax+832], ecx

; 1551 : 
; 1552 : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	edx, DWORD PTR _pTemp$[ebp]
	cvttss2si eax, DWORD PTR [edx+8]
	push	eax
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+804], xmm0

; 1553 : 		pTemp->die = cl.time + life + COM_RandomFloat( 0.0f, 4.0f );

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	push	ecx
	movss	xmm1, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	xorps	xmm1, xmm1
	movss	DWORD PTR [esp], xmm1
	movsd	QWORD PTR tv502[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	QWORD PTR tv499[ebp]
	movsd	xmm0, QWORD PTR tv502[ebp]
	addsd	xmm0, QWORD PTR tv499[ebp]
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 1554 : 	}

	jmp	$LN2@R_Sprite_T
$LN3@R_Sprite_T:

; 1555 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_Trail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_count$ = 20						; size = 4
_speed$ = 24						; size = 4
_spread$ = 28						; size = 4
_R_Sprite_Spray PROC

; 1500 : {

	push	ebp
	mov	ebp, esp

; 1501 : 	R_Spray( pos, dir, modelIndex, count, speed, spread, kRenderGlow );

	push	3
	mov	eax, DWORD PTR _spread$[ebp]
	push	eax
	mov	ecx, DWORD PTR _speed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_Spray
	add	esp, 28					; 0000001cH

; 1502 : }

	pop	ebp
	ret	0
_R_Sprite_Spray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv233 = -52						; size = 4
tv356 = -48						; size = 4
tv344 = -44						; size = 4
tv332 = -40						; size = 4
tv320 = -36						; size = 4
_znoise$ = -32						; size = 4
tv307 = -28						; size = 4
tv294 = -24						; size = 4
_pmodel$ = -20						; size = 4
tv76 = -16						; size = 4
_i$ = -12						; size = 4
_noise$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_count$ = 20						; size = 4
_speed$ = 24						; size = 4
_spread$ = 28						; size = 4
_rendermode$ = 32					; size = 4
_R_Spray PROC

; 1434 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 1435 : 	TEMPENTITY	*pTemp;
; 1436 : 	float		noise;
; 1437 : 	float		znoise;
; 1438 : 	model_t		*pmodel;
; 1439 : 	int		i;
; 1440 : 
; 1441 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN5@R_Spray

; 1442 : 	{
; 1443 : 		Con_Reportf( "No model %d!\n", modelIndex );

	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	OFFSET $SG146601
	call	_Con_Reportf
	add	esp, 8

; 1444 : 		return;

	jmp	$LN3@R_Spray
$LN5@R_Spray:

; 1445 : 	}
; 1446 : 
; 1447 : 	noise = (float)spread / 100.0f;

	cvtsi2ss xmm0, DWORD PTR _spread$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _noise$[ebp], xmm0

; 1448 : 
; 1449 : 	// more vertical displacement
; 1450 : 	znoise = Q_min( 1.0f, noise * 1.5f );

	movss	xmm0, DWORD PTR _noise$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN12@R_Spray
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN13@R_Spray
$LN12@R_Spray:
	movss	xmm0, DWORD PTR _noise$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv76[ebp], xmm0
$LN13@R_Spray:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR _znoise$[ebp], xmm0

; 1451 : 
; 1452 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Spray
$LN2@R_Spray:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@R_Spray:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_Spray

; 1453 : 	{
; 1454 : 		pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1455 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN6@R_Spray
	jmp	$LN3@R_Spray
$LN6@R_Spray:

; 1456 : 
; 1457 : 		pTemp->entity.curstate.rendermode = rendermode;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR [eax+828], ecx

; 1458 : 		pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 255;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 255		; 000000ffH
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 255		; 000000ffH

; 1459 : 		pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+840], 14			; 0000000eH

; 1460 : 
; 1461 : 		if( rendermode != kRenderGlow )

	cmp	DWORD PTR _rendermode$[ebp], 3
	je	$LN7@R_Spray

; 1462 : 		{
; 1463 : 			// spray
; 1464 : 			pTemp->flags |= FTENT_COLLIDEWORLD | FTENT_SLOWGRAVITY;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1465 : 
; 1466 : 			if( pTemp->frameMax > 1 )

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN9@R_Spray

; 1467 : 			{
; 1468 : 				pTemp->flags |= FTENT_COLLIDEWORLD | FTENT_SLOWGRAVITY | FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 296				; 00000128H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1469 : 				pTemp->die = cl.time + (pTemp->frameMax * 0.1f);

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1470 : 				pTemp->entity.curstate.framerate = 10;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [edx+852], xmm0

; 1471 : 			}

	jmp	SHORT $LN10@R_Spray
$LN9@R_Spray:

; 1472 : 			else pTemp->die = cl.time + 0.35f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fd6666660000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN10@R_Spray:

; 1473 : 		}

	jmp	SHORT $LN8@R_Spray
$LN7@R_Spray:

; 1474 : 		else
; 1475 : 		{
; 1476 : 			// sprite spray
; 1477 : 			pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	ecx, DWORD PTR _pTemp$[ebp]
	cvttss2si edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+804], xmm0

; 1478 : 			pTemp->flags |= FTENT_FADEOUT | FTENT_SLOWGRAVITY;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 136				; 00000088H
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx

; 1479 : 			pTemp->entity.curstate.framerate = 0.5;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+852], xmm0

; 1480 : 			pTemp->die = cl.time + 0.35f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fd6666660000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 1481 : 			pTemp->fadeSpeed = 2.0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [eax+24], xmm0
$LN8@R_Spray:

; 1482 : 		}
; 1483 : 
; 1484 : 		// make the spittle fly the direction indicated, but mix in some noise.
; 1485 : 		pTemp->entity.baseline.origin[0] = dir[0] + COM_RandomFloat( -noise, noise );

	mov	ecx, 4
	imul	esi, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _noise$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _noise$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv294[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv294[ebp]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1486 : 		pTemp->entity.baseline.origin[1] = dir[1] + COM_RandomFloat( -noise, noise );

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR _noise$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _noise$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv307[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv307[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1487 : 		pTemp->entity.baseline.origin[2] = dir[2] + COM_RandomFloat( 0, znoise );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR _znoise$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv320[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv320[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1488 : 		VectorScale( pTemp->entity.baseline.origin, COM_RandomFloat(( speed * 0.8f ), ( speed * 1.2f )), pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	esi, eax, 0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv332[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv332[ebp]
	mulss	xmm0, DWORD PTR [ecx+esi+92]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	esi, 4
	shl	esi, 0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv344[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv344[ebp]
	mulss	xmm0, DWORD PTR [edx+esi+92]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	esi, 4
	shl	esi, 1
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv356[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+esi+92]
	mulss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR tv233[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv233[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1489 : 	}

	jmp	$LN2@R_Spray
$LN3@R_Spray:

; 1490 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Spray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_iColor$ = -4						; size = 4
_pTemp$ = 8						; size = 4
_scale$ = 12						; size = 4
_R_Sprite_Smoke PROC

; 1410 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1411 : 	int	iColor;
; 1412 : 
; 1413 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Sprite_S
	jmp	$LN1@R_Sprite_S
$LN2@R_Sprite_S:

; 1414 : 
; 1415 : 	iColor = COM_RandomLong( 20, 35 );

	push	35					; 00000023H
	push	20					; 00000014H
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _iColor$[ebp], eax

; 1416 : 	pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 4

; 1417 : 	pTemp->entity.curstate.renderfx = kRenderFxNone;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+840], 0

; 1418 : 	pTemp->entity.baseline.origin[2] = 30;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [eax+edx+92], xmm0

; 1419 : 	pTemp->entity.curstate.rendercolor.r = iColor;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	dl, BYTE PTR _iColor$[ebp]
	mov	BYTE PTR [ecx+836], dl

; 1420 : 	pTemp->entity.curstate.rendercolor.g = iColor;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cl, BYTE PTR _iColor$[ebp]
	mov	BYTE PTR [eax+837], cl

; 1421 : 	pTemp->entity.curstate.rendercolor.b = iColor;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	al, BYTE PTR _iColor$[ebp]
	mov	BYTE PTR [edx+838], al

; 1422 : 	pTemp->entity.origin[2] += 20;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+2956]
	addss	xmm0, DWORD PTR __real@41a00000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+2956], xmm0

; 1423 : 	pTemp->entity.curstate.scale = scale;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [edx+820], xmm0
$LN1@R_Sprite_S:

; 1424 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_Smoke ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = 8						; size = 4
_scale$ = 12						; size = 4
_flags$ = 16						; size = 4
_R_Sprite_Explode PROC

; 1368 : {

	push	ebp
	mov	ebp, esp

; 1369 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Sprite_E
	jmp	$LN1@R_Sprite_E
$LN2@R_Sprite_E:

; 1370 : 
; 1371 : 	if( FBitSet( flags, TE_EXPLFLAG_NOADDITIVE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN3@R_Sprite_E

; 1372 : 	{
; 1373 : 		// solid sprite
; 1374 : 		pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 0

; 1375 : 		pTemp->entity.curstate.renderamt = 255; 

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 255		; 000000ffH

; 1376 : 	}

	jmp	SHORT $LN6@R_Sprite_E
$LN3@R_Sprite_E:

; 1377 : 	else if( FBitSet( flags, TE_EXPLFLAG_DRAWALPHA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN5@R_Sprite_E

; 1378 : 	{
; 1379 : 		// alpha sprite (came from hl2)
; 1380 : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 4

; 1381 : 		pTemp->entity.curstate.renderamt = 180;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 180		; 000000b4H

; 1382 : 	}

	jmp	SHORT $LN6@R_Sprite_E
$LN5@R_Sprite_E:

; 1383 : 	else
; 1384 : 	{
; 1385 : 		// additive sprite
; 1386 : 		pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 5

; 1387 : 		pTemp->entity.curstate.renderamt = 180;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 180		; 000000b4H
$LN6@R_Sprite_E:

; 1388 : 	}
; 1389 : 
; 1390 : 	if( FBitSet( flags, TE_EXPLFLAG_ROTATE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN7@R_Sprite_E

; 1391 : 	{
; 1392 : 		// came from hl2
; 1393 : 		pTemp->entity.angles[2] = COM_RandomLong( 0, 360 );

	push	360					; 00000168H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+2968], xmm0
$LN7@R_Sprite_E:

; 1394 : 	}
; 1395 : 
; 1396 : 	pTemp->entity.curstate.renderfx = kRenderFxNone;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 0

; 1397 : 	pTemp->entity.baseline.origin[2] = 8;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1398 : 	pTemp->entity.origin[2] += 10;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+2956]
	addss	xmm0, DWORD PTR __real@41200000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+2956], xmm0

; 1399 : 	pTemp->entity.curstate.scale = scale;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [ecx+820], xmm0
$LN1@R_Sprite_E:

; 1400 : }

	pop	ebp
	ret	0
_R_Sprite_Explode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_psprite$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_spriteIndex$ = 12					; size = 4
_framerate$ = 16					; size = 4
_R_DefaultSprite PROC

; 1269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1270 : 	TEMPENTITY	*pTemp;
; 1271 : 	model_t		*psprite;
; 1272 : 
; 1273 : 	// don't spawn while paused
; 1274 : 	if( cl.time == cl.oldtime )

	movsd	xmm0, QWORD PTR _cl+1525848
	ucomisd	xmm0, QWORD PTR _cl+1525856
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_DefaultS

; 1275 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_DefaultS
$LN2@R_DefaultS:

; 1276 : 
; 1277 : 	if(( psprite = CL_ModelHandle( spriteIndex )) == NULL || psprite->type != mod_sprite )

	mov	eax, DWORD PTR _spriteIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _psprite$[ebp], eax
	cmp	DWORD PTR _psprite$[ebp], 0
	je	SHORT $LN4@R_DefaultS
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+68], 1
	je	SHORT $LN3@R_DefaultS
$LN4@R_DefaultS:

; 1278 : 	{
; 1279 : 		Con_Reportf( "No Sprite %d!\n", spriteIndex );

	mov	edx, DWORD PTR _spriteIndex$[ebp]
	push	edx
	push	OFFSET $SG146518
	call	_Con_Reportf
	add	esp, 8

; 1280 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_DefaultS
$LN3@R_DefaultS:

; 1281 : 	}
; 1282 : 
; 1283 : 	pTemp = CL_TempEntAlloc( pos, psprite );

	mov	eax, DWORD PTR _psprite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1284 : 	if( !pTemp ) return NULL;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN5@R_DefaultS
	xor	eax, eax
	jmp	$LN1@R_DefaultS
$LN5@R_DefaultS:

; 1285 : 
; 1286 : 	pTemp->entity.curstate.scale = 1.0f;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+820], xmm0

; 1287 : 	pTemp->flags |= FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1288 : 	if( framerate == 0 ) framerate = 10;

	movss	xmm0, DWORD PTR _framerate$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DefaultS
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _framerate$[ebp], xmm0
$LN6@R_DefaultS:

; 1289 : 
; 1290 : 	pTemp->entity.curstate.framerate = framerate;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _framerate$[ebp]
	movss	DWORD PTR [eax+852], xmm0

; 1291 : 	pTemp->die = cl.time + (float)pTemp->frameMax / framerate;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	divss	xmm0, DWORD PTR _framerate$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 1292 : 	pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+804], xmm0

; 1293 : 
; 1294 : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@R_DefaultS:

; 1295 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_DefaultSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pmodel$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_scale$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_rendermode$ = 24					; size = 4
_renderfx$ = 28						; size = 4
_a$ = 32						; size = 4
_life$ = 36						; size = 4
_flags$ = 40						; size = 4
_R_TempSprite PROC

; 1330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 1331 : 	TEMPENTITY	*pTemp;
; 1332 : 	model_t		*pmodel;
; 1333 : 
; 1334 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN2@R_TempSpri

; 1335 : 	{
; 1336 : 		Con_Reportf( S_ERROR "No model %d!\n", modelIndex );

	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	OFFSET $SG146551
	call	_Con_Reportf
	add	esp, 8

; 1337 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_TempSpri
$LN2@R_TempSpri:

; 1338 : 	}
; 1339 : 
; 1340 : 	pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	edx, DWORD PTR _pmodel$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1341 : 	if( !pTemp ) return NULL;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN3@R_TempSpri
	xor	eax, eax
	jmp	$LN1@R_TempSpri
$LN3@R_TempSpri:

; 1342 : 
; 1343 : 	pTemp->entity.curstate.framerate = 10;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+852], xmm0

; 1344 : 	pTemp->entity.curstate.rendermode = rendermode;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR [edx+828], eax

; 1345 : 	pTemp->entity.curstate.renderfx = renderfx;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _renderfx$[ebp]
	mov	DWORD PTR [ecx+840], edx

; 1346 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 1347 : 	pTemp->entity.baseline.renderamt = a * 255;

	movss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+152], ecx

; 1348 : 	pTemp->entity.curstate.renderamt = a * 255;

	movss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], eax

; 1349 : 	pTemp->flags |= flags;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, DWORD PTR _flags$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1350 : 
; 1351 : 	VectorCopy( dir, pTemp->entity.baseline.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+92], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+92], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+92], edx

; 1352 : 
; 1353 : 	if( life ) pTemp->die = cl.time + life;

	movss	xmm0, DWORD PTR _life$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@R_TempSpri
	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	jmp	SHORT $LN5@R_TempSpri
$LN4@R_TempSpri:

; 1354 : 	else pTemp->die = cl.time + ( pTemp->frameMax * 0.1f ) + 1.0f;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0
$LN5@R_TempSpri:

; 1355 : 	pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+804], xmm0

; 1356 : 
; 1357 : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@R_TempSpri:

; 1358 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TempSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv135 = -12						; size = 4
_pmodel$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_angles$ = 16						; size = 4
_life$ = 20						; size = 4
_modelIndex$ = 24					; size = 4
_soundtype$ = 28					; size = 4
_R_TempModel PROC

; 1218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 1219 : 	// alloc a new tempent
; 1220 : 	TEMPENTITY	*pTemp;
; 1221 : 	model_t		*pmodel;
; 1222 : 
; 1223 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN4@R_TempMode

; 1224 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_TempMode
$LN4@R_TempMode:

; 1225 : 
; 1226 : 	pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1227 : 	if( !pTemp ) return NULL;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN5@R_TempMode
	xor	eax, eax
	jmp	$LN1@R_TempMode
$LN5@R_TempMode:

; 1228 : 
; 1229 : 	pTemp->flags = (FTENT_COLLIDEWORLD|FTENT_GRAVITY);

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 34			; 00000022H

; 1230 : 	VectorCopy( dir, pTemp->entity.baseline.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+92], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+92], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+92], ecx

; 1231 : 	VectorCopy( angles, pTemp->entity.angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+2968], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+2968], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+2968], edx

; 1232 : 
; 1233 : 	// keep track of shell type
; 1234 : 	switch( soundtype )

	mov	eax, DWORD PTR _soundtype$[ebp]
	mov	DWORD PTR tv135[ebp], eax
	cmp	DWORD PTR tv135[ebp], 1
	je	SHORT $LN6@R_TempMode
	cmp	DWORD PTR tv135[ebp], 2
	je	$LN7@R_TempMode
	jmp	$LN2@R_TempMode
$LN6@R_TempMode:

; 1235 : 	{
; 1236 : 	case TE_BOUNCE_SHELL:
; 1237 : 		pTemp->hitSound = BOUNCE_SHELL;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+32], 32			; 00000020H

; 1238 : 		pTemp->entity.baseline.angles[0] = COM_RandomFloat( -512, 511 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43ff8000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c4000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1239 : 		pTemp->entity.baseline.angles[1] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+104]

; 1240 : 		pTemp->entity.baseline.angles[2] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1241 : 		pTemp->flags |= FTENT_ROTATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1242 : 		break;

	jmp	$LN2@R_TempMode
$LN7@R_TempMode:

; 1243 : 	case TE_BOUNCE_SHOTSHELL:
; 1244 : 		pTemp->hitSound = BOUNCE_SHOTSHELL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+32], 128			; 00000080H

; 1245 : 		pTemp->entity.baseline.angles[0] = COM_RandomFloat( -512, 511 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43ff8000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c4000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+104]

; 1246 : 		pTemp->entity.baseline.angles[1] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1247 : 		pTemp->entity.baseline.angles[2] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1248 : 		pTemp->flags |= FTENT_ROTATE|FTENT_SLOWGRAVITY;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@R_TempMode:

; 1249 : 		break;
; 1250 : 	}
; 1251 : 
; 1252 : 	if( pmodel->type == mod_sprite )

	mov	edx, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [edx+68], 1
	jne	SHORT $LN8@R_TempMode

; 1253 : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+804], xmm0
	jmp	SHORT $LN9@R_TempMode
$LN8@R_TempMode:

; 1254 : 	else pTemp->entity.curstate.body = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+856], eax
$LN9@R_TempMode:

; 1255 : 
; 1256 : 	pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1257 : 
; 1258 : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@R_TempMode:

; 1259 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TempModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv446 = -76						; size = 8
tv449 = -68						; size = 8
tv432 = -60						; size = 4
tv419 = -56						; size = 4
tv406 = -52						; size = 4
tv337 = -48						; size = 4
tv323 = -44						; size = 4
tv309 = -40						; size = 4
_i$ = -36						; size = 4
_pmodel$ = -32						; size = 4
_j$ = -28						; size = 4
_type$ = -21						; size = 1
_pTemp$ = -20						; size = 4
_vecSpot$1 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_size$ = 12						; size = 4
_dir$ = 16						; size = 4
_random$ = 20						; size = 4
_life$ = 24						; size = 4
_count$ = 28						; size = 4
_modelIndex$ = 32					; size = 4
_flags$ = 36						; size = 1
_R_BreakModel PROC

; 1130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1131 : 	TEMPENTITY	*pTemp;
; 1132 : 	model_t		*pmodel;
; 1133 : 	char		type;
; 1134 : 	int		i, j;
; 1135 : 
; 1136 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN8@R_BreakMod

; 1137 : 		return;

	jmp	$LN3@R_BreakMod
$LN8@R_BreakMod:

; 1138 : 
; 1139 : 	type = flags & BREAK_TYPEMASK;

	movsx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 79					; 0000004fH
	mov	BYTE PTR _type$[ebp], cl

; 1140 : 
; 1141 : 	if( count == 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN9@R_BreakMod

; 1142 : 	{
; 1143 : 		// assume surface (not volume)
; 1144 : 		count = (size[0] * size[1] + size[1] * size[2] + size[2] * size[0]) / (3 * SHARD_VOLUME * SHARD_VOLUME);

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@43d80000
	cvttss2si edx, xmm0
	mov	DWORD PTR _count$[ebp], edx
$LN9@R_BreakMod:

; 1145 : 	}
; 1146 : 
; 1147 : 	// limit to 100 pieces
; 1148 : 	if( count > 100 ) count = 100;

	cmp	DWORD PTR _count$[ebp], 100		; 00000064H
	jle	SHORT $LN10@R_BreakMod
	mov	DWORD PTR _count$[ebp], 100		; 00000064H
$LN10@R_BreakMod:

; 1149 : 
; 1150 : 	for( i = 0; i < count; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BreakMod
$LN2@R_BreakMod:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_BreakMod:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	$LN3@R_BreakMod

; 1151 : 	{
; 1152 : 		vec3_t	vecSpot;
; 1153 : 
; 1154 : 		for( j = 0; j < 32; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@R_BreakMod
$LN5@R_BreakMod:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@R_BreakMod:
	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jge	$LN6@R_BreakMod

; 1155 : 		{
; 1156 : 			// fill up the box with stuff
; 1157 : 			vecSpot[0] = pos[0] + COM_RandomFloat( -0.5f, 0.5f ) * size[0];

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv309[ebp]
	movss	xmm0, DWORD PTR tv309[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR _pos$[ebp]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSpot$1[ebp+eax], xmm0

; 1158 : 			vecSpot[1] = pos[1] + COM_RandomFloat( -0.5f, 0.5f ) * size[1];

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv323[ebp]
	movss	xmm0, DWORD PTR tv323[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _pos$[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecSpot$1[ebp+ecx], xmm0

; 1159 : 			vecSpot[2] = pos[2] + COM_RandomFloat( -0.5f, 0.5f ) * size[2];

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv337[ebp]
	movss	xmm0, DWORD PTR tv337[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR _pos$[ebp]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vecSpot$1[ebp+edx], xmm0

; 1160 : 
; 1161 : 			if( CL_PointContents( vecSpot ) != CONTENTS_SOLID )

	lea	eax, DWORD PTR _vecSpot$1[ebp]
	push	eax
	call	_CL_PointContents
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN11@R_BreakMod

; 1162 : 				break; // valid spot

	jmp	SHORT $LN6@R_BreakMod
$LN11@R_BreakMod:

; 1163 : 		}

	jmp	$LN5@R_BreakMod
$LN6@R_BreakMod:

; 1164 : 
; 1165 : 		if( j == 32 ) continue; // a piece completely stuck in the wall, ignore it

	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jne	SHORT $LN12@R_BreakMod
	jmp	$LN2@R_BreakMod
$LN12@R_BreakMod:

; 1166 : 
; 1167 : 		pTemp = CL_TempEntAlloc( vecSpot, pmodel );

	mov	ecx, DWORD PTR _pmodel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecSpot$1[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1168 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN13@R_BreakMod
	jmp	$LN3@R_BreakMod
$LN13@R_BreakMod:

; 1169 : 
; 1170 : 		// keep track of break_type, so we know how to play sound on collision
; 1171 : 		pTemp->hitSound = type;

	movsx	eax, BYTE PTR _type$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1172 : 		
; 1173 : 		if( pmodel->type == mod_sprite )

	mov	edx, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [edx+68], 1
	jne	SHORT $LN14@R_BreakMod

; 1174 : 			pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+804], xmm0
	jmp	SHORT $LN16@R_BreakMod
$LN14@R_BreakMod:

; 1175 : 		else if( pmodel->type == mod_studio )

	mov	eax, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN16@R_BreakMod

; 1176 : 			pTemp->entity.curstate.body = COM_RandomLong( 0, pTemp->frameMax );

	mov	ecx, DWORD PTR _pTemp$[ebp]
	cvttss2si edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+856], eax
$LN16@R_BreakMod:

; 1177 : 
; 1178 : 		pTemp->flags |= FTENT_COLLIDEWORLD | FTENT_FADEOUT | FTENT_SLOWGRAVITY;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1179 : 
; 1180 : 		if( COM_RandomLong( 0, 255 ) < 200 ) 

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 200				; 000000c8H
	jge	$LN17@R_BreakMod

; 1181 : 		{
; 1182 : 			pTemp->flags |= FTENT_ROTATE;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 4
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1183 : 			pTemp->entity.baseline.angles[0] = COM_RandomFloat( -256, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1184 : 			pTemp->entity.baseline.angles[1] = COM_RandomFloat( -256, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+104]

; 1185 : 			pTemp->entity.baseline.angles[2] = COM_RandomFloat( -256, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]
$LN17@R_BreakMod:

; 1186 : 		}
; 1187 : 
; 1188 : 		if (( COM_RandomLong( 0, 255 ) < 100 ) && FBitSet( flags, BREAK_SMOKE ))

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 100				; 00000064H
	jge	SHORT $LN18@R_BreakMod
	movsx	eax, BYTE PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN18@R_BreakMod

; 1189 : 			pTemp->flags |= FTENT_SMOKETRAIL;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx
$LN18@R_BreakMod:

; 1190 : 
; 1191 : 		if(( type == BREAK_GLASS ) || FBitSet( flags, BREAK_TRANS ))

	movsx	ecx, BYTE PTR _type$[ebp]
	cmp	ecx, 1
	je	SHORT $LN21@R_BreakMod
	movsx	edx, BYTE PTR _flags$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN19@R_BreakMod
$LN21@R_BreakMod:

; 1192 : 		{
; 1193 : 			pTemp->entity.curstate.rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 2

; 1194 : 			pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = 128;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 128		; 00000080H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 128		; 00000080H

; 1195 : 		}

	jmp	SHORT $LN20@R_BreakMod
$LN19@R_BreakMod:

; 1196 : 		else
; 1197 : 		{
; 1198 : 			pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 0

; 1199 : 			pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = 255; // set this for fadeout

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 255		; 000000ffH
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 255		; 000000ffH
$LN20@R_BreakMod:

; 1200 : 		}
; 1201 : 
; 1202 : 		pTemp->entity.baseline.origin[0] = dir[0] + COM_RandomFloat( -random, random );

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _random$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv406[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv406[ebp]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1203 : 		pTemp->entity.baseline.origin[1] = dir[1] + COM_RandomFloat( -random, random );

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _random$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv419[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv419[ebp]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1204 : 		pTemp->entity.baseline.origin[2] = dir[2] + COM_RandomFloat( 0, random );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv432[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv432[ebp]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1205 : 
; 1206 : 		pTemp->die = cl.time + life + COM_RandomFloat( 0.0f, 1.0f ); // Add an extra 0-1 secs of life

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	push	ecx
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	xorps	xmm1, xmm1
	movss	DWORD PTR [esp], xmm1
	movsd	QWORD PTR tv449[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	QWORD PTR tv446[ebp]
	movsd	xmm0, QWORD PTR tv449[ebp]
	addsd	xmm0, QWORD PTR tv446[ebp]
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 1207 : 	}

	jmp	$LN2@R_BreakMod
$LN3@R_BreakMod:

; 1208 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BreakModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv423 = -60						; size = 8
tv442 = -52						; size = 4
_spatterindex$ = -48					; size = 4
_splatter$ = -44					; size = 4
_impactindex$ = -40					; size = 4
tv296 = -36						; size = 4
_pModel2$ = -32						; size = 4
_pModel$ = -28						; size = 4
_i$ = -24						; size = 4
_pTemp$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_colorIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_modelIndex2$ = 20					; size = 4
_size$ = 24						; size = 4
_R_BloodSprite PROC

; 1044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1045 : 	model_t		*pModel, *pModel2;
; 1046 : 	int		impactindex;
; 1047 : 	int		spatterindex;
; 1048 : 	int		i, splatter;
; 1049 : 	TEMPENTITY	*pTemp;
; 1050 : 	vec3_t		pos;
; 1051 : 
; 1052 : 	colorIndex += COM_RandomLong( 1, 3 );

	push	3
	push	1
	call	_COM_RandomLong
	add	esp, 8
	add	eax, DWORD PTR _colorIndex$[ebp]
	mov	DWORD PTR _colorIndex$[ebp], eax

; 1053 : 	impactindex = colorIndex;

	mov	eax, DWORD PTR _colorIndex$[ebp]
	mov	DWORD PTR _impactindex$[ebp], eax

; 1054 : 	spatterindex = colorIndex - 1;

	mov	ecx, DWORD PTR _colorIndex$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _spatterindex$[ebp], ecx

; 1055 : 
; 1056 : 	// validate the model first
; 1057 : 	if(( pModel = CL_ModelHandle( modelIndex )) != NULL )

	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pModel$[ebp], eax
	cmp	DWORD PTR _pModel$[ebp], 0
	je	$LN6@R_BloodSpr

; 1058 : 	{
; 1059 : 		VectorCopy( org, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pos$[ebp+ecx], eax

; 1060 : 		pos[2] += COM_RandomFloat( 2.0f, 4.0f ); // make offset from ground (snarks issues)

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv296[ebp]
	movss	xmm0, DWORD PTR tv296[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _pos$[ebp+ecx], xmm0

; 1061 : 
; 1062 : 		// large, single blood sprite is a high-priority tent
; 1063 : 		if(( pTemp = CL_TempEntAllocHigh( pos, pModel )) != NULL )

	mov	edx, DWORD PTR _pModel$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN6@R_BloodSpr

; 1064 : 		{
; 1065 : 			pTemp->entity.curstate.rendermode = kRenderTransTexture;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 2

; 1066 : 			pTemp->entity.curstate.renderfx = kRenderFxClampMinScale;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+840], 20			; 00000014H

; 1067 : 			pTemp->entity.curstate.scale = COM_RandomFloat( size / 25.0f, size / 35.0f );

	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@420c0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@41c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+820]

; 1068 : 			pTemp->flags = FTENT_SPRANIMATE;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], 256			; 00000100H

; 1069 : 
; 1070 : 			pTemp->entity.curstate.rendercolor = clgame.palette[impactindex];

	imul	edx, DWORD PTR _impactindex$[ebp], 3
	add	edx, OFFSET _clgame+125460
	mov	eax, DWORD PTR _pTemp$[ebp]
	add	eax, 836				; 00000344H
	mov	cx, WORD PTR [edx]
	mov	WORD PTR [eax], cx
	mov	dl, BYTE PTR [edx+2]
	mov	BYTE PTR [eax+2], dl

; 1071 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 250;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+832], 250		; 000000faH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 250		; 000000faH

; 1072 : 
; 1073 : 			pTemp->entity.curstate.framerate = pTemp->frameMax * 4.0f; // Finish in 0.250 seconds

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+852], xmm0

; 1074 : 			pTemp->die = cl.time + (pTemp->frameMax / pTemp->entity.curstate.framerate ); // play the whole thing once

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	divss	xmm0, DWORD PTR [edx+852]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1075 : 
; 1076 : 			pTemp->entity.curstate.frame = 0;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+804], xmm0

; 1077 : 			pTemp->bounceFactor = 0;

	mov	edx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+28], xmm0

; 1078 : 			pTemp->entity.angles[2] = COM_RandomLong( 0, 360 );

	push	360					; 00000168H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+2968], xmm0
$LN6@R_BloodSpr:

; 1079 : 		}
; 1080 : 	}
; 1081 : 
; 1082 : 	// validate the model first
; 1083 : 	if(( pModel2 = CL_ModelHandle( modelIndex2 )) != NULL )

	mov	eax, DWORD PTR _modelIndex2$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pModel2$[ebp], eax
	cmp	DWORD PTR _pModel2$[ebp], 0
	je	$LN3@R_BloodSpr

; 1084 : 	{
; 1085 : 		splatter = size + ( COM_RandomLong( 1, 8 ) + COM_RandomLong( 1, 8 ));

	push	8
	push	1
	call	_COM_RandomLong
	add	esp, 8
	mov	esi, eax
	push	8
	push	1
	call	_COM_RandomLong
	add	esp, 8
	add	esi, eax
	cvtsi2ss xmm0, esi
	addss	xmm0, DWORD PTR _size$[ebp]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _splatter$[ebp], ecx

; 1086 : 
; 1087 : 		for( i = 0; i < splatter; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BloodSpr
$LN2@R_BloodSpr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@R_BloodSpr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _splatter$[ebp]
	jge	$LN3@R_BloodSpr

; 1088 : 		{
; 1089 : 			// create blood drips
; 1090 : 			if(( pTemp = CL_TempEntAlloc( org, pModel2 )) != NULL )

	mov	ecx, DWORD PTR _pModel2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN8@R_BloodSpr

; 1091 : 			{
; 1092 : 				pTemp->entity.curstate.rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 2

; 1093 : 				pTemp->entity.curstate.renderfx = kRenderFxClampMinScale;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+840], 20			; 00000014H

; 1094 : 				pTemp->entity.curstate.scale = COM_RandomFloat( size / 15.0f, size / 25.0f );

	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@41c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@41700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+820]

; 1095 : 				pTemp->flags = FTENT_ROTATE | FTENT_SLOWGRAVITY | FTENT_COLLIDEWORLD;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 1096 : 
; 1097 : 				pTemp->entity.curstate.rendercolor = clgame.palette[spatterindex];

	imul	ecx, DWORD PTR _spatterindex$[ebp], 3
	add	ecx, OFFSET _clgame+125460
	mov	edx, DWORD PTR _pTemp$[ebp]
	add	edx, 836				; 00000344H
	mov	ax, WORD PTR [ecx]
	mov	WORD PTR [edx], ax
	mov	cl, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx+2], cl

; 1098 : 				pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 250;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 250		; 000000faH
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 250		; 000000faH

; 1099 : 
; 1100 : 				pTemp->entity.baseline.origin[0] = COM_RandomFloat( -96.0f, 95.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42be0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+92]

; 1101 : 				pTemp->entity.baseline.origin[1] = COM_RandomFloat( -96.0f, 95.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42be0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+92]

; 1102 : 				pTemp->entity.baseline.origin[2] = COM_RandomFloat( -32.0f, 95.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42be0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1103 : 				pTemp->entity.baseline.angles[0] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1104 : 				pTemp->entity.baseline.angles[1] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+104]

; 1105 : 				pTemp->entity.baseline.angles[2] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1106 : 
; 1107 : 				pTemp->die = cl.time + COM_RandomFloat( 1.0f, 3.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	QWORD PTR tv423[ebp]
	movsd	xmm0, QWORD PTR tv423[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1108 : 
; 1109 : 				pTemp->entity.curstate.frame = COM_RandomLong( 1, pTemp->frameMax );

	mov	ecx, DWORD PTR _pTemp$[ebp]
	cvttss2si edx, DWORD PTR [ecx+8]
	push	edx
	push	1
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+804], xmm0

; 1110 : 
; 1111 : 				if( pTemp->entity.curstate.frame > 8.0f )

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+804]
	comiss	xmm0, DWORD PTR __real@41000000
	jbe	SHORT $LN9@R_BloodSpr

; 1112 : 					pTemp->entity.curstate.frame = pTemp->frameMax;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+804], ecx
$LN9@R_BloodSpr:

; 1113 : 
; 1114 : 				pTemp->entity.baseline.origin[2] += COM_RandomFloat( 4.0f, 16.0f ) * size;

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv442[ebp]
	movss	xmm0, DWORD PTR tv442[ebp]
	mulss	xmm0, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	addss	xmm0, DWORD PTR [edx+esi+92]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1115 : 				pTemp->entity.angles[2] = COM_RandomFloat( 0.0f, 360.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+2968]

; 1116 : 				pTemp->bounceFactor	= 0.0f;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+28], xmm0
$LN8@R_BloodSpr:

; 1117 : 			}
; 1118 : 		}

	jmp	$LN2@R_BloodSpr
$LN3@R_BloodSpr:

; 1119 : 	}
; 1120 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BloodSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_index$ = -12						; size = 4
_scale$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_type$ = 12						; size = 4
_R_MuzzleFlash PROC

; 1005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1006 : 	TEMPENTITY	*pTemp;
; 1007 : 	int		index;
; 1008 : 	float		scale;
; 1009 : 
; 1010 : 	index = ( type % 10 ) % MAX_MUZZLEFLASH;

	mov	eax, DWORD PTR _type$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	eax, edx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _index$[ebp], edx

; 1011 : 	scale = ( type / 10 ) * 0.1f;

	mov	eax, DWORD PTR _type$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 1012 : 	if( scale == 0.0f ) scale = 0.5f;

	movss	xmm0, DWORD PTR _scale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_MuzzleFl
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _scale$[ebp], xmm0
$LN2@R_MuzzleFl:

; 1013 : 
; 1014 : 	if( !cl_sprite_muzzleflash[index] )

	mov	edx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _cl_sprite_muzzleflash[edx*4], 0
	jne	SHORT $LN3@R_MuzzleFl

; 1015 : 		return;

	jmp	$LN1@R_MuzzleFl
$LN3@R_MuzzleFl:

; 1016 : 
; 1017 : 	// must set position for right culling on render
; 1018 : 	pTemp = CL_TempEntAllocHigh( pos, cl_sprite_muzzleflash[index] );

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _cl_sprite_muzzleflash[eax*4]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1019 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN4@R_MuzzleFl
	jmp	$LN1@R_MuzzleFl
$LN4@R_MuzzleFl:

; 1020 : 	pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+828], 5

; 1021 : 	pTemp->entity.curstate.renderamt = 255;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 255		; 000000ffH

; 1022 : 	pTemp->entity.curstate.framerate = 10;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [edx+852], xmm0

; 1023 : 	pTemp->entity.curstate.renderfx = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 0

; 1024 : 	pTemp->die = cl.time + 0.01; // die at next frame

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f847ae147ae147b
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1025 : 	pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	edx, DWORD PTR _pTemp$[ebp]
	cvttss2si eax, DWORD PTR [edx+8]
	push	eax
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+804], xmm0

; 1026 : 	pTemp->flags |= FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 65792				; 00010100H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1027 : 	pTemp->entity.curstate.scale = scale;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [edx+820], xmm0

; 1028 : 
; 1029 : 	if( index == 0 ) pTemp->entity.angles[2] = COM_RandomLong( 0, 20 ); // rifle flash

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN5@R_MuzzleFl
	push	20					; 00000014H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+2968], xmm0
	jmp	SHORT $LN6@R_MuzzleFl
$LN5@R_MuzzleFl:

; 1030 : 	else pTemp->entity.angles[2] = COM_RandomLong( 0, 359 );

	push	359					; 00000167H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+2968], xmm0
$LN6@R_MuzzleFl:

; 1031 : 
; 1032 : 	CL_TempEntAddEntity( &pTemp->entity );

	mov	eax, DWORD PTR _pTemp$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	call	_CL_TempEntAddEntity
	add	esp, 4
$LN1@R_MuzzleFl:

; 1033 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_MuzzleFlash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_R_RocketFlare PROC

; 979  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 980  : 	TEMPENTITY	*pTemp;
; 981  : 
; 982  : 	if( !cl_sprite_glow ) return;

	cmp	DWORD PTR _cl_sprite_glow, 0
	jne	SHORT $LN2@R_RocketFl
	jmp	$LN1@R_RocketFl
$LN2@R_RocketFl:

; 983  : 
; 984  : 	pTemp = CL_TempEntAlloc( pos, cl_sprite_glow );

	mov	eax, DWORD PTR _cl_sprite_glow
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 985  : 	if ( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN3@R_RocketFl
	jmp	$LN1@R_RocketFl
$LN3@R_RocketFl:

; 986  : 
; 987  : 	pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 3

; 988  : 	pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 14			; 0000000eH

; 989  : 	pTemp->entity.curstate.renderamt = 200;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 200		; 000000c8H

; 990  : 	pTemp->entity.curstate.framerate = 1.0;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+852], xmm0

; 991  : 	pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+804], xmm0

; 992  : 	pTemp->entity.curstate.scale = 1.0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+820], xmm0

; 993  : 	pTemp->die = cl.time + 0.01f;	// when 100 fps die at next frame

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 994  : 	pTemp->entity.curstate.effects = EF_NOINTERP;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+816], 32			; 00000020H
$LN1@R_RocketFl:

; 995  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RocketFlare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_duration$ = 16						; size = 4
_scale$ = 20						; size = 4
_R_RicochetSprite PROC

; 953  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 954  : 	TEMPENTITY	*pTemp;
; 955  : 
; 956  : 	pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 957  : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Ricochet
	jmp	$LN1@R_Ricochet
$LN2@R_Ricochet:

; 958  : 
; 959  : 	pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 3

; 960  : 	pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = 200;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 200		; 000000c8H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], 200		; 000000c8H

; 961  : 	pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+840], 14			; 0000000eH

; 962  : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 963  : 	pTemp->die = cl.time + duration;

	cvtss2sd xmm0, DWORD PTR _duration$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 964  : 	pTemp->flags = FTENT_FADEOUT;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], 128			; 00000080H

; 965  : 	pTemp->fadeSpeed = 8;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [eax+24], xmm0

; 966  : 
; 967  : 	pTemp->entity.curstate.frame = 0;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+804], xmm0

; 968  : 	pTemp->entity.angles[ROLL] = 45.0f * COM_RandomLong( 0, 7 );

	push	7
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@42340000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+2968], xmm0
$LN1@R_Ricochet:

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RicochetSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$1 = -8						; size = 4
_i$ = -4						; size = 4
_client$ = 8						; size = 4
_R_KillAttachedTents PROC

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 923  : 	int	i;
; 924  : 
; 925  : 	if( client <= 0 || client > cl.maxclients )

	cmp	DWORD PTR _client$[ebp], 0
	jle	SHORT $LN6@R_KillAtta
	mov	eax, DWORD PTR _client$[ebp]
	cmp	eax, DWORD PTR _cl+1568832
	jle	SHORT $LN5@R_KillAtta
$LN6@R_KillAtta:

; 926  : 		return;

	jmp	SHORT $LN3@R_KillAtta
$LN5@R_KillAtta:

; 927  : 
; 928  : 	for( i = 0; i < GI->max_tents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_KillAtta
$LN2@R_KillAtta:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@R_KillAtta:
	mov	edx, DWORD PTR _SI+768
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+1660]
	jge	SHORT $LN3@R_KillAtta

; 929  : 	{
; 930  : 		TEMPENTITY *pTemp = &cl_tempents[i];

	imul	ecx, DWORD PTR _i$[ebp], 3068
	add	ecx, DWORD PTR _cl_tempents
	mov	DWORD PTR _pTemp$1[ebp], ecx

; 931  : 
; 932  : 		if( !FBitSet( pTemp->flags, FTENT_PLYRATTACHMENT ))

	mov	edx, DWORD PTR _pTemp$1[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 32768				; 00008000H
	jne	SHORT $LN7@R_KillAtta

; 933  : 			continue;

	jmp	SHORT $LN2@R_KillAtta
$LN7@R_KillAtta:

; 934  : 
; 935  : 		// this TEMPENTITY is player attached.
; 936  : 		// if it is attached to this client, set it to die instantly.
; 937  : 		if( pTemp->clientIndex == client )

	mov	ecx, DWORD PTR _pTemp$1[ebp]
	movsx	edx, WORD PTR [ecx+52]
	cmp	edx, DWORD PTR _client$[ebp]
	jne	SHORT $LN8@R_KillAtta

; 938  : 		{
; 939  : 			// good enough, it will die on next tent update. 
; 940  : 			pTemp->die = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	mov	eax, DWORD PTR _pTemp$1[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN8@R_KillAtta:

; 941  : 		}
; 942  : 	}

	jmp	SHORT $LN2@R_KillAtta
$LN3@R_KillAtta:

; 943  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_KillAttachedTents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pModel$ = -28						; size = 4
_pClient$ = -24						; size = 4
_pTemp$ = -20						; size = 4
_position$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_client$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_zoffset$ = 16						; size = 4
_life$ = 20						; size = 4
_R_AttachTentToPlayer PROC

; 866  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 867  : 	TEMPENTITY	*pTemp;
; 868  : 	vec3_t		position;
; 869  : 	cl_entity_t	*pClient;
; 870  : 	model_t		*pModel;
; 871  : 
; 872  : 	if( client <= 0 || client > cl.maxclients )

	cmp	DWORD PTR _client$[ebp], 0
	jle	SHORT $LN3@R_AttachTe
	mov	eax, DWORD PTR _client$[ebp]
	cmp	eax, DWORD PTR _cl+1568832
	jle	SHORT $LN2@R_AttachTe
$LN3@R_AttachTe:

; 873  : 		return;

	jmp	$LN1@R_AttachTe
$LN2@R_AttachTe:

; 874  : 
; 875  : 	pClient = CL_GetEntityByIndex( client );

	mov	ecx, DWORD PTR _client$[ebp]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pClient$[ebp], eax

; 876  : 
; 877  : 	if( !pClient || pClient->curstate.messagenum != cl.parsecount )

	cmp	DWORD PTR _pClient$[ebp], 0
	je	SHORT $LN5@R_AttachTe
	mov	edx, DWORD PTR _pClient$[ebp]
	mov	eax, DWORD PTR [edx+700]
	cmp	eax, DWORD PTR _cl+8
	je	SHORT $LN4@R_AttachTe
$LN5@R_AttachTe:

; 878  : 		return;

	jmp	$LN1@R_AttachTe
$LN4@R_AttachTe:

; 879  : 
; 880  : 	if(( pModel = CL_ModelHandle( modelIndex )) == NULL )

	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pModel$[ebp], eax
	cmp	DWORD PTR _pModel$[ebp], 0
	jne	SHORT $LN6@R_AttachTe

; 881  : 		return;

	jmp	$LN1@R_AttachTe
$LN6@R_AttachTe:

; 882  : 
; 883  : 	VectorCopy( pClient->origin, position );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pClient$[ebp]
	mov	eax, DWORD PTR [ecx+eax+2888]
	mov	DWORD PTR _position$[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pClient$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+2888]
	mov	DWORD PTR _position$[ebp+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pClient$[ebp]
	mov	edx, DWORD PTR [ecx+edx+2888]
	mov	DWORD PTR _position$[ebp+eax], edx

; 884  : 	position[2] += zoffset;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _position$[ebp+eax]
	addss	xmm0, DWORD PTR _zoffset$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _position$[ebp+ecx], xmm0

; 885  : 
; 886  : 	pTemp = CL_TempEntAllocHigh( position, pModel );

	mov	edx, DWORD PTR _pModel$[ebp]
	push	edx
	lea	eax, DWORD PTR _position$[ebp]
	push	eax
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 887  : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN7@R_AttachTe
	jmp	$LN1@R_AttachTe
$LN7@R_AttachTe:

; 888  : 
; 889  : 	pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+840], 14			; 0000000eH

; 890  : 	pTemp->entity.curstate.framerate = 1;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+852], xmm0

; 891  : 	
; 892  : 	pTemp->clientIndex = client;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+52], cx

; 893  : 	pTemp->tentOffset[0] = 0;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+56], xmm0

; 894  : 	pTemp->tentOffset[1] = 0;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+56], xmm0

; 895  : 	pTemp->tentOffset[2] = zoffset;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zoffset$[ebp]
	movss	DWORD PTR [edx+ecx+56], xmm0

; 896  : 	pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 897  : 	pTemp->flags |= FTENT_PLYRATTACHMENT|FTENT_PERSIST;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 40960				; 0000a000H
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx

; 898  : 
; 899  : 	// is the model a sprite?
; 900  : 	if( pModel->type == mod_sprite )

	mov	ecx, DWORD PTR _pModel$[ebp]
	cmp	DWORD PTR [ecx+68], 1
	jne	SHORT $LN8@R_AttachTe

; 901  : 	{
; 902  : 		pTemp->flags |= FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 65792				; 00010100H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 903  : 		pTemp->entity.curstate.framerate = 10;

	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [edx+852], xmm0

; 904  : 	}

	jmp	SHORT $LN9@R_AttachTe
$LN8@R_AttachTe:

; 905  : 	else
; 906  : 	{
; 907  : 		// no animation support for attached clientside studio models.
; 908  : 		pTemp->frameMax = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0
$LN9@R_AttachTe:

; 909  : 	}
; 910  : 
; 911  : 	pTemp->entity.curstate.frame = 0;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+804], xmm0
$LN1@R_AttachTe:

; 912  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AttachTentToPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv298 = -56						; size = 4
_sine$ = -52						; size = 4
_cosine$ = -48						; size = 4
_angle$ = -44						; size = 4
tv139 = -40						; size = 4
_zspeed$ = -36						; size = 4
_mod$ = -32						; size = 4
_dist$ = -28						; size = 4
_i$ = -24						; size = 4
_pTemp$ = -20						; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_height$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_count$ = 24						; size = 4
_speed$ = 28						; size = 4
_R_BubbleTrail PROC

; 821  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 822  : 	TEMPENTITY	*pTemp;
; 823  : 	float		sine, cosine, zspeed;
; 824  : 	float		dist, angle;
; 825  : 	vec3_t		origin;
; 826  : 	model_t		*mod;
; 827  : 	int		i;
; 828  : 
; 829  : 	if(( mod = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN5@R_BubbleTr

; 830  : 		return;

	jmp	$LN3@R_BubbleTr
$LN5@R_BubbleTr:

; 831  : 
; 832  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BubbleTr
$LN2@R_BubbleTr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@R_BubbleTr:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	$LN3@R_BubbleTr

; 833  : 	{
; 834  : 		dist = COM_RandomFloat( 0, 1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 835  : 		VectorLerp( start, dist, end, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv139[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv139[ebp]
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 836  : 		pTemp = CL_TempEntAlloc( origin, mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 837  : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN6@R_BubbleTr
	jmp	$LN3@R_BubbleTr
$LN6@R_BubbleTr:

; 838  : 
; 839  : 		pTemp->flags |= FTENT_SINEWAVE;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 840  : 
; 841  : 		pTemp->x = origin[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+12], edx

; 842  : 		pTemp->y = origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+16], edx

; 843  : 		angle = COM_RandomFloat( -M_PI, M_PI );

	push	ecx
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c0490fdb
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _angle$[ebp]

; 844  : 		SinCos( angle, &sine, &cosine );

	lea	eax, DWORD PTR _cosine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sine$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 845  : 
; 846  : 		zspeed = COM_RandomLong( 80, 140 );

	push	140					; 0000008cH
	push	80					; 00000050H
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _zspeed$[ebp], xmm0

; 847  : 		VectorSet( pTemp->entity.baseline.origin, speed * cosine, speed * sine, zspeed );

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _cosine$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _sine$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zspeed$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 848  : 		pTemp->die = cl.time + ((height - (origin[2] - start[2])) / zspeed) - 0.1f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR _height$[ebp]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR _zspeed$[ebp]
	cvtss2sd xmm0, xmm1
	addsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 849  : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	ecx, DWORD PTR _pTemp$[ebp]
	cvttss2si edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+804], xmm0

; 850  : 
; 851  : 		// Set sprite scale
; 852  : 		pTemp->entity.curstate.scale = 1.0f / COM_RandomFloat( 2.0f, 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv298[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv298[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+820], xmm0

; 853  : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 4

; 854  : 		pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+832], 255		; 000000ffH

; 855  : 	}

	jmp	$LN2@R_BubbleTr
$LN3@R_BubbleTr:

; 856  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BubbleTrail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv273 = -48						; size = 4
_sine$ = -44						; size = 4
_cosine$ = -40						; size = 4
_angle$ = -36						; size = 4
_zspeed$ = -32						; size = 4
_mod$ = -28						; size = 4
_i$ = -24						; size = 4
_pTemp$ = -20						; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_height$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_count$ = 24						; size = 4
_speed$ = 28						; size = 4
_R_Bubbles PROC

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 776  : 	TEMPENTITY	*pTemp;
; 777  : 	float		sine, cosine;
; 778  : 	float		angle, zspeed;
; 779  : 	vec3_t		origin;
; 780  : 	model_t		*mod;
; 781  : 	int		i;
; 782  : 
; 783  : 	if(( mod = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN5@R_Bubbles

; 784  : 		return;

	jmp	$LN3@R_Bubbles
$LN5@R_Bubbles:

; 785  : 
; 786  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Bubbles
$LN2@R_Bubbles:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@R_Bubbles:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	$LN3@R_Bubbles

; 787  : 	{
; 788  : 		origin[0] = COM_RandomLong( mins[0], maxs[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, 4
	imul	ecx, edx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 789  : 		origin[1] = COM_RandomLong( mins[1], maxs[1] );

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 790  : 		origin[2] = COM_RandomLong( mins[2], maxs[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax]
	push	edx
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 791  : 		pTemp = CL_TempEntAlloc( origin, mod );

	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 792  : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN6@R_Bubbles
	jmp	$LN3@R_Bubbles
$LN6@R_Bubbles:

; 793  : 
; 794  : 		pTemp->flags |= FTENT_SINEWAVE;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx

; 795  : 
; 796  : 		pTemp->x = origin[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR [eax+12], ecx

; 797  : 		pTemp->y = origin[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR [eax+16], ecx

; 798  : 		angle = COM_RandomFloat( -M_PI, M_PI );

	push	ecx
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c0490fdb
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _angle$[ebp]

; 799  : 		SinCos( angle, &sine, &cosine );

	lea	edx, DWORD PTR _cosine$[ebp]
	push	edx
	lea	eax, DWORD PTR _sine$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 800  : 		
; 801  : 		zspeed = COM_RandomLong( 80, 140 );

	push	140					; 0000008cH
	push	80					; 00000050H
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _zspeed$[ebp], xmm0

; 802  : 		VectorSet( pTemp->entity.baseline.origin, speed * cosine, speed * sine, zspeed );

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _cosine$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _sine$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zspeed$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 803  : 		pTemp->die = cl.time + ((height - (origin[2] - mins[2])) / zspeed) - 0.1f;

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	xmm1, DWORD PTR _height$[ebp]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR _zspeed$[ebp]
	cvtss2sd xmm0, xmm1
	addsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 804  : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+804], xmm0

; 805  : 		
; 806  : 		// Set sprite scale
; 807  : 		pTemp->entity.curstate.scale = 1.0f / COM_RandomFloat( 2.0f, 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv273[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv273[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 808  : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 4

; 809  : 		pTemp->entity.curstate.renderamt = 255;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 255		; 000000ffH

; 810  : 	}

	jmp	$LN2@R_Bubbles
$LN3@R_Bubbles:

; 811  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Bubbles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv315 = -68						; size = 4
_maxHeight$ = -64					; size = 4
_depth$ = -60						; size = 4
_width$ = -56						; size = 4
_angle$ = -52						; size = 4
_zspeed$ = -48						; size = 4
_count$ = -44						; size = 4
_yspeed$ = -40						; size = 4
_xspeed$ = -36						; size = 4
_i$ = -32						; size = 4
_speed$ = -28						; size = 4
_mod$ = -24						; size = 4
_pTemp$ = -20						; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pent$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_density$ = 16						; size = 4
_R_FizzEffect PROC

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 713  : 	TEMPENTITY	*pTemp;
; 714  : 	int		i, width, depth, count;
; 715  : 	float		angle, maxHeight, speed;
; 716  : 	float		xspeed, yspeed, zspeed;
; 717  : 	vec3_t		origin;
; 718  : 	model_t		*mod;
; 719  : 
; 720  : 	if( !pent || pent->curstate.modelindex <= 0 )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN6@R_FizzEffe
	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+728], 0
	jg	SHORT $LN5@R_FizzEffe
$LN6@R_FizzEffe:

; 721  : 		return;

	jmp	$LN3@R_FizzEffe
$LN5@R_FizzEffe:

; 722  : 
; 723  : 	if(( mod = CL_ModelHandle( pent->curstate.modelindex )) == NULL )

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	push	edx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN7@R_FizzEffe

; 724  : 		return;

	jmp	$LN3@R_FizzEffe
$LN7@R_FizzEffe:

; 725  : 
; 726  : 	count = density + 1;

	mov	eax, DWORD PTR _density$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 727  : 	density = count * 3 + 6;

	imul	ecx, DWORD PTR _count$[ebp], 3
	add	ecx, 6
	mov	DWORD PTR _density$[ebp], ecx

; 728  : 	maxHeight = mod->maxs[2] - mod->mins[2];

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+96]
	subss	xmm0, DWORD PTR [esi+eax+84]
	movss	DWORD PTR _maxHeight$[ebp], xmm0

; 729  : 	width = mod->maxs[0] - mod->mins[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+96]
	subss	xmm0, DWORD PTR [esi+edx+84]
	cvttss2si edx, xmm0
	mov	DWORD PTR _width$[ebp], edx

; 730  : 	depth = mod->maxs[1] - mod->mins[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+96]
	subss	xmm0, DWORD PTR [esi+ecx+84]
	cvttss2si eax, xmm0
	mov	DWORD PTR _depth$[ebp], eax

; 731  : 
; 732  : 	speed = ( pent->curstate.rendercolor.r<<8 | pent->curstate.rendercolor.g );

	mov	ecx, DWORD PTR _pent$[ebp]
	movzx	edx, BYTE PTR [ecx+768]
	shl	edx, 8
	mov	eax, DWORD PTR _pent$[ebp]
	movzx	ecx, BYTE PTR [eax+769]
	or	edx, ecx
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _speed$[ebp], xmm0

; 733  : 	if( pent->curstate.rendercolor.b )

	mov	edx, DWORD PTR _pent$[ebp]
	movzx	eax, BYTE PTR [edx+770]
	test	eax, eax
	je	SHORT $LN8@R_FizzEffe

; 734  : 		speed = -speed;

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _speed$[ebp], xmm0
$LN8@R_FizzEffe:

; 735  : 
; 736  : 	angle = DEG2RAD( pent->angles[YAW] );

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+2900]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	movss	DWORD PTR _angle$[ebp], xmm0

; 737  : 	SinCos( angle, &yspeed, &xspeed );

	lea	eax, DWORD PTR _xspeed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _yspeed$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 738  : 
; 739  : 	xspeed *= speed;

	movss	xmm0, DWORD PTR _xspeed$[ebp]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _xspeed$[ebp], xmm0

; 740  : 	yspeed *= speed;

	movss	xmm0, DWORD PTR _yspeed$[ebp]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _yspeed$[ebp], xmm0

; 741  : 
; 742  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_FizzEffe
$LN2@R_FizzEffe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@R_FizzEffe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_FizzEffe

; 743  : 	{
; 744  : 		origin[0] = mod->mins[0] + COM_RandomLong( 0, width - 1 );

	mov	ecx, 4
	imul	esi, ecx, 0
	mov	edx, DWORD PTR _width$[ebp]
	sub	edx, 1
	push	edx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _mod$[ebp]
	addss	xmm0, DWORD PTR [eax+esi+84]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 745  : 		origin[1] = mod->mins[1] + COM_RandomLong( 0, depth - 1 );

	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR _depth$[ebp]
	sub	eax, 1
	push	eax
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _mod$[ebp]
	addss	xmm0, DWORD PTR [ecx+esi+84]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 746  : 		origin[2] = mod->mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+eax+84]
	mov	DWORD PTR _origin$[ebp+ecx], eax

; 747  : 		pTemp = CL_TempEntAlloc( origin, CL_ModelHandle( modelIndex ));

	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 748  : 
; 749  : 		if ( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN9@R_FizzEffe
	jmp	$LN3@R_FizzEffe
$LN9@R_FizzEffe:

; 750  : 
; 751  : 		pTemp->flags |= FTENT_SINEWAVE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 752  : 
; 753  : 		pTemp->x = origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+12], eax

; 754  : 		pTemp->y = origin[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+16], eax

; 755  : 
; 756  : 		zspeed = COM_RandomLong( 80, 140 );

	push	140					; 0000008cH
	push	80					; 00000050H
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _zspeed$[ebp], xmm0

; 757  : 		VectorSet( pTemp->entity.baseline.origin, xspeed, yspeed, zspeed );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _xspeed$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _yspeed$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zspeed$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 758  : 		pTemp->die = cl.time + ( maxHeight / zspeed ) - 0.1f;

	movss	xmm0, DWORD PTR _maxHeight$[ebp]
	divss	xmm0, DWORD PTR _zspeed$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 759  : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+804], xmm0

; 760  : 		// Set sprite scale
; 761  : 		pTemp->entity.curstate.scale = 1.0f / COM_RandomFloat( 2.0f, 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv315[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv315[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 762  : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+828], 4

; 763  : 		pTemp->entity.curstate.renderamt = 255;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+832], 255		; 000000ffH

; 764  : 	}

	jmp	$LN2@R_FizzEffe
$LN3@R_FizzEffe:

; 765  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FizzEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_org$ = 8						; size = 4
_model$ = 12						; size = 4
_high$ = 16						; size = 4
_pfn$ = 20						; size = 4
_CL_TempEntAllocCustom PROC

; 675  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 676  : 	TEMPENTITY	*pTemp;
; 677  : 
; 678  : 	if( high )

	cmp	DWORD PTR _high$[ebp], 0
	je	SHORT $LN2@CL_TempEnt

; 679  : 	{
; 680  : 		pTemp = CL_TempEntAllocHigh( org, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 681  : 	}

	jmp	SHORT $LN3@CL_TempEnt
$LN2@CL_TempEnt:

; 682  : 	else
; 683  : 	{
; 684  : 		pTemp = CL_TempEntAlloc( org, model );

	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax
$LN3@CL_TempEnt:

; 685  : 	}
; 686  : 
; 687  : 	if( pTemp && pfn )

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN4@CL_TempEnt
	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $LN4@CL_TempEnt

; 688  : 	{
; 689  : 		pTemp->flags |= FTENT_CLIENTCUSTOM;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 524288				; 00080000H
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], edx

; 690  : 		pTemp->callback = pfn;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _pfn$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 691  : 		pTemp->die = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN4@CL_TempEnt:

; 692  : 	}
; 693  : 
; 694  : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]

; 695  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAllocCustom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_org$ = 8						; size = 4
_CL_TempEntAllocNoModel PROC

; 663  : {

	push	ebp
	mov	ebp, esp

; 664  : 	return CL_TempEntAlloc( org, NULL );

	push	0
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_CL_TempEntAlloc
	add	esp, 8

; 665  : }

	pop	ebp
	ret	0
_CL_TempEntAllocNoModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_org$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_CL_TempEntAllocHigh PROC

; 622  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 623  : 	TEMPENTITY	*pTemp;
; 624  : 
; 625  : 	if( !cl_free_tents )

	cmp	DWORD PTR _cl_free_tents, 0
	jne	SHORT $LN2@CL_TempEnt

; 626  : 	{
; 627  : 		// no temporary ents free, so find the first active low-priority temp ent 
; 628  : 		// and overwrite it.
; 629  : 		CL_FreeLowPriorityTempEnt();

	call	_CL_FreeLowPriorityTempEnt
$LN2@CL_TempEnt:

; 630  : 	}
; 631  : 
; 632  : 	if( !cl_free_tents )

	cmp	DWORD PTR _cl_free_tents, 0
	jne	SHORT $LN3@CL_TempEnt

; 633  : 	{
; 634  : 		// didn't find anything? The tent list is either full of high-priority tents
; 635  : 		// or all tents in the list are still due to live for > 10 seconds. 
; 636  : 		Con_DPrintf( "Couldn't alloc a high priority TENT!\n" );

	push	OFFSET $SG146223
	call	_Con_DPrintf
	add	esp, 4

; 637  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@CL_TempEnt
$LN3@CL_TempEnt:

; 638  : 	}
; 639  : 
; 640  : 	// Move out of the free list and into the active list.
; 641  : 	pTemp = cl_free_tents;

	mov	eax, DWORD PTR _cl_free_tents
	mov	DWORD PTR _pTemp$[ebp], eax

; 642  : 	cl_free_tents = pTemp->next;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _cl_free_tents, edx

; 643  : 
; 644  : 	CL_PrepareTEnt( pTemp, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_CL_PrepareTEnt
	add	esp, 8

; 645  : 
; 646  : 	pTemp->priority = TENTPRIORITY_HIGH;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+48], 1

; 647  : 	if( org ) VectorCopy( org, pTemp->entity.origin );

	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN4@CL_TempEnt
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+2956], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+2956], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+2956], eax
$LN4@CL_TempEnt:

; 648  : 
; 649  : 	pTemp->next = cl_active_tents;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _cl_active_tents
	mov	DWORD PTR [ecx+44], edx

; 650  : 	cl_active_tents = pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR _cl_active_tents, eax

; 651  : 
; 652  : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@CL_TempEnt:

; 653  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAllocHigh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_org$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_CL_TempEntAlloc PROC

; 591  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 592  : 	TEMPENTITY	*pTemp;
; 593  : 
; 594  : 	if( !cl_free_tents )

	cmp	DWORD PTR _cl_free_tents, 0
	jne	SHORT $LN2@CL_TempEnt

; 595  : 	{
; 596  : 		Con_DPrintf( "Overflow %d temporary ents!\n", GI->max_tents );

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1660]
	push	ecx
	push	OFFSET $SG146212
	call	_Con_DPrintf
	add	esp, 8

; 597  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@CL_TempEnt
$LN2@CL_TempEnt:

; 598  : 	}
; 599  : 
; 600  : 	pTemp = cl_free_tents;

	mov	edx, DWORD PTR _cl_free_tents
	mov	DWORD PTR _pTemp$[ebp], edx

; 601  : 	cl_free_tents = pTemp->next;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _cl_free_tents, ecx

; 602  : 
; 603  : 	CL_PrepareTEnt( pTemp, pmodel );

	mov	edx, DWORD PTR _pmodel$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_CL_PrepareTEnt
	add	esp, 8

; 604  : 
; 605  : 	pTemp->priority = TENTPRIORITY_LOW;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 606  : 	if( org ) VectorCopy( org, pTemp->entity.origin );

	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN3@CL_TempEnt
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+2956], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+2956], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+2956], edx
$LN3@CL_TempEnt:

; 607  : 
; 608  : 	pTemp->next = cl_active_tents;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _cl_active_tents
	mov	DWORD PTR [eax+44], ecx

; 609  : 	cl_active_tents = pTemp;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR _cl_active_tents, edx

; 610  : 
; 611  : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@CL_TempEnt:

; 612  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_R_SparkShower PROC

; 1305 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1306 : 	TEMPENTITY	*pTemp;
; 1307 : 
; 1308 : 	pTemp = CL_TempEntAllocNoModel( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_CL_TempEntAllocNoModel
	add	esp, 4
	mov	DWORD PTR _pTemp$[ebp], eax

; 1309 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_SparkSho
	jmp	$LN1@R_SparkSho
$LN2@R_SparkSho:

; 1310 : 
; 1311 : 	pTemp->entity.baseline.origin[0] = COM_RandomFloat( -300.0f, 300.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3960000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+edx+92]

; 1312 : 	pTemp->entity.baseline.origin[1] = COM_RandomFloat( -300.0f, 300.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3960000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+92]

; 1313 : 	pTemp->entity.baseline.origin[2] = COM_RandomFloat( -200.0f, 200.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3480000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1314 : 
; 1315 : 	pTemp->flags |= FTENT_SLOWGRAVITY | FTENT_COLLIDEWORLD | FTENT_SPARKSHOWER;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 131112				; 00020028H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], eax

; 1316 : 
; 1317 : 	pTemp->entity.curstate.framerate = COM_RandomFloat( 0.5f, 1.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+852]

; 1318 : 	pTemp->entity.curstate.scale = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 1319 : 	pTemp->die = cl.time + 0.5;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
$LN1@R_SparkSho:

; 1320 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_SparkShower ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_hSound$ = -8						; size = 4
_dl$1 = -4						; size = 4
_pos$ = 8						; size = 4
_model$ = 12						; size = 4
_scale$ = 16						; size = 4
_framerate$ = 20					; size = 4
_flags$ = 24						; size = 4
_R_Explosion PROC

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 1758 : 	sound_t	hSound;
; 1759 : 
; 1760 : 	if( scale != 0.0f )

	movss	xmm0, DWORD PTR _scale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@R_Explosio

; 1761 : 	{
; 1762 : 		// create explosion sprite
; 1763 : 		R_Sprite_Explode( R_DefaultSprite( pos, model, framerate ), scale, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _framerate$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	push	eax
	call	_R_Sprite_Explode
	add	esp, 12					; 0000000cH

; 1764 : 
; 1765 : 		if( !FBitSet( flags, TE_EXPLFLAG_NOPARTICLES ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	jne	SHORT $LN3@R_Explosio

; 1766 : 			R_FlickerParticles( pos );

	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_FlickerParticles
	add	esp, 4
$LN3@R_Explosio:

; 1767 : 
; 1768 : 		if( !FBitSet( flags, TE_EXPLFLAG_NODLIGHTS ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	jne	$LN4@R_Explosio

; 1769 : 		{
; 1770 : 			dlight_t	*dl;
; 1771 : 
; 1772 : 			// big flash
; 1773 : 			dl = CL_AllocDlight( 0 );

	push	0
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 1774 : 			VectorCopy( pos, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1775 : 			dl->radius = 200;

	mov	ecx, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [ecx+12], xmm0

; 1776 : 			dl->color.r = 250;

	mov	edx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [edx+16], 250			; 000000faH

; 1777 : 			dl->color.g = 250;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+17], 250			; 000000faH

; 1778 : 			dl->color.b = 150;

	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [ecx+18], 150			; 00000096H

; 1779 : 			dl->die = cl.time + 0.01f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [edx+20], xmm0

; 1780 : 			dl->decay = 80;

	mov	eax, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [eax+24], xmm0

; 1781 : 
; 1782 : 			// red glow
; 1783 : 			dl = CL_AllocDlight( 0 );

	push	0
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 1784 : 			VectorCopy( pos, dl->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1785 : 			dl->radius = 150;

	mov	edx, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR [edx+12], xmm0

; 1786 : 			dl->color.r = 255;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+16], 255			; 000000ffH

; 1787 : 			dl->color.g = 190;

	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [ecx+17], 190			; 000000beH

; 1788 : 			dl->color.b = 40;

	mov	edx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [edx+18], 40			; 00000028H

; 1789 : 			dl->die = cl.time + 1.0f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 1790 : 			dl->decay = 200;

	mov	ecx, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [ecx+24], xmm0
$LN4@R_Explosio:

; 1791 : 		}
; 1792 : 	}
; 1793 : 
; 1794 : 	if( !FBitSet( flags, TE_EXPLFLAG_NOSOUND ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	jne	SHORT $LN5@R_Explosio

; 1795 : 	{
; 1796 : 		hSound = S_RegisterSound( va( "%s", cl_explode_sounds[COM_RandomLong( 0, 2 )] ));

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_explode_sounds[eax*4]
	push	eax
	push	OFFSET $SG146774
	call	_va
	add	esp, 8
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _hSound$[ebp], eax

; 1797 : 		S_StartSound( pos, 0, CHAN_STATIC, hSound, VOL_NORM, 0.3f, PITCH_NORM, 0 );

	push	0
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _hSound$[ebp]
	push	ecx
	push	6
	push	0
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN5@R_Explosio:

; 1798 : 	}
; 1799 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Explosion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_CL_LoadClientSprites PROC

; 99   : {

	push	ebp
	mov	ebp, esp

; 100  : 	cl_sprite_muzzleflash[0] = CL_LoadClientSprite( cl_default_sprites[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl_default_sprites[ecx]
	push	edx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _cl_sprite_muzzleflash[edx], eax

; 101  : 	cl_sprite_muzzleflash[1] = CL_LoadClientSprite( cl_default_sprites[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _cl_sprite_muzzleflash[edx], eax

; 102  : 	cl_sprite_muzzleflash[2] = CL_LoadClientSprite( cl_default_sprites[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _cl_sprite_muzzleflash[edx], eax

; 103  : 
; 104  : 	cl_sprite_dot = CL_LoadClientSprite( cl_default_sprites[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cl_default_sprites[ecx]
	push	edx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_dot, eax

; 105  : 	cl_sprite_glow = CL_LoadClientSprite( cl_default_sprites[4] );

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_glow, eax

; 106  : 	cl_sprite_ricochet = CL_LoadClientSprite( cl_default_sprites[5] );

	mov	edx, 4
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_ricochet, eax

; 107  : 	cl_sprite_shell = CL_LoadClientSprite( cl_default_sprites[6] );

	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_shell, eax

; 108  : }

	pop	ebp
	ret	0
_CL_LoadClientSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_ft$ = -12						; size = 8
_gravity$ = -4						; size = 4
_CL_TempEntUpdate PROC

; 542  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 543  : 	double	ft = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR _cl+1525856
	movsd	QWORD PTR _ft$[ebp], xmm0

; 544  : 	float	gravity = clgame.movevars.gravity;

	movss	xmm0, DWORD PTR _clgame+1028
	movss	DWORD PTR _gravity$[ebp], xmm0

; 545  : 
; 546  : 	clgame.dllFuncs.pfnTempEntUpdate( ft, cl.time, gravity, &cl_free_tents, &cl_active_tents, CL_TempEntAddEntity, CL_TempEntPlaySound );

	push	OFFSET _CL_TempEntPlaySound
	push	OFFSET _CL_TempEntAddEntity
	push	OFFSET _cl_active_tents
	push	OFFSET _cl_free_tents
	cvtss2sd xmm0, DWORD PTR _gravity$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _ft$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+144
	add	esp, 40					; 00000028H

; 547  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_CL_FreeTempEnts PROC

; 365  : {

	push	ebp
	mov	ebp, esp

; 366  : 	if( cl_tempents )

	cmp	DWORD PTR _cl_tempents, 0
	je	SHORT $LN2@CL_FreeTem

; 367  : 		Mem_Free( cl_tempents );

	push	367					; 0000016fH
	push	OFFSET $SG146115
	mov	eax, DWORD PTR _cl_tempents
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@CL_FreeTem:

; 368  : 	cl_tempents = NULL;

	mov	DWORD PTR _cl_tempents, 0

; 369  : }

	pop	ebp
	ret	0
_CL_FreeTempEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearTempEnts PROC

; 342  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 343  : 	int	i;
; 344  : 
; 345  : 	if( !cl_tempents ) return;

	cmp	DWORD PTR _cl_tempents, 0
	jne	SHORT $LN5@CL_ClearTe
	jmp	$LN1@CL_ClearTe
$LN5@CL_ClearTe:

; 346  : 
; 347  : 	for( i = 0; i < GI->max_tents - 1; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearTe
$LN2@CL_ClearTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearTe:
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [ecx+1660]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN3@CL_ClearTe

; 348  : 	{
; 349  : 		cl_tempents[i].next = &cl_tempents[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	ecx, eax, 3068
	add	ecx, DWORD PTR _cl_tempents
	imul	edx, DWORD PTR _i$[ebp], 3068
	mov	eax, DWORD PTR _cl_tempents
	mov	DWORD PTR [eax+edx+44], ecx

; 350  : 		cl_tempents[i].entity.trivial_accept = INVALID_HANDLE;

	imul	ecx, DWORD PTR _i$[ebp], 3068
	mov	edx, DWORD PTR _cl_tempents
	mov	DWORD PTR [edx+ecx+3028], 65535		; 0000ffffH

; 351  : 	}

	jmp	SHORT $LN2@CL_ClearTe
$LN3@CL_ClearTe:

; 352  : 
; 353  : 	cl_tempents[GI->max_tents-1].next = NULL;

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1660]
	sub	ecx, 1
	imul	edx, ecx, 3068
	mov	eax, DWORD PTR _cl_tempents
	mov	DWORD PTR [eax+edx+44], 0

; 354  : 	cl_free_tents = cl_tempents;

	mov	ecx, DWORD PTR _cl_tempents
	mov	DWORD PTR _cl_free_tents, ecx

; 355  : 	cl_active_tents = NULL;

	mov	DWORD PTR _cl_active_tents, 0
$LN1@CL_ClearTe:

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearTempEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_CL_InitTempEnts PROC

; 327  : {

	push	ebp
	mov	ebp, esp

; 328  : 	cl_tempents = Mem_Calloc( cls.mempool, sizeof( TEMPENTITY ) * GI->max_tents );

	push	328					; 00000148H
	push	OFFSET $SG146101
	push	1
	mov	eax, DWORD PTR _SI+768
	imul	ecx, DWORD PTR [eax+1660], 3068
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cl_tempents, eax

; 329  : 	CL_ClearTempEnts();

	call	_CL_ClearTempEnts

; 330  : 
; 331  : 	// load tempent sprites (glowshell, muzzleflashes etc)
; 332  : 	CL_LoadClientSprites ();

	call	_CL_LoadClientSprites

; 333  : }

	pop	ebp
	ret	0
_CL_InitTempEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv446 = -180						; size = 8
tv546 = -172						; size = 8
tv440 = -164						; size = 8
tv431 = -156						; size = 8
tv544 = -148						; size = 8
tv425 = -140						; size = 8
tv416 = -132						; size = 8
tv407 = -124						; size = 8
tv398 = -116						; size = 8
tv510 = -108						; size = 8
tv363 = -100						; size = 8
tv508 = -92						; size = 8
tv355 = -84						; size = 8
tv506 = -76						; size = 8
tv347 = -68						; size = 8
tv504 = -60						; size = 8
tv339 = -52						; size = 8
tv267 = -44						; size = 4
tv312 = -40						; size = 4
tv311 = -36						; size = 4
_dist$ = -32						; size = 4
tv68 = -28						; size = 4
_offset$ = -24						; size = 4
_blend$ = -20						; size = 4
_tmp$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_CL_FxBlend PROC

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 207  : 	int	blend = 0;

	mov	DWORD PTR _blend$[ebp], 0

; 208  : 	float	offset, dist;
; 209  : 	vec3_t	tmp;
; 210  : 
; 211  : 	offset = ((int)e->index ) * 363.0f; // Use ent index to de-sync these fx

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@43b58000
	movss	DWORD PTR _offset$[ebp], xmm0

; 212  : 
; 213  : 	switch( e->curstate.renderfx ) 

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+772]
	mov	DWORD PTR tv68[ebp], edx
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 15			; 0000000fH
	ja	$LN45@CL_FxBlend
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN51@CL_FxBlend[ecx*4]
$LN4@CL_FxBlend:

; 214  : 	{
; 215  : 	case kRenderFxPulseSlowWide:
; 216  : 		blend = e->curstate.renderamt + 0x40 * sin( cl.time * 2 + offset );	

	mov	edx, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [edx+764]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@4000000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv504[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv339[ebp]
	movsd	xmm0, QWORD PTR tv339[ebp]
	mulsd	xmm0, QWORD PTR __real@4050000000000000
	movsd	xmm1, QWORD PTR tv504[ebp]
	addsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	mov	DWORD PTR _blend$[ebp], eax

; 217  : 		break;

	jmp	$LN2@CL_FxBlend
$LN5@CL_FxBlend:

; 218  : 	case kRenderFxPulseFastWide:
; 219  : 		blend = e->curstate.renderamt + 0x40 * sin( cl.time * 8 + offset );

	mov	ecx, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [ecx+764]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@4020000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv506[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv347[ebp]
	movsd	xmm0, QWORD PTR tv347[ebp]
	mulsd	xmm0, QWORD PTR __real@4050000000000000
	movsd	xmm1, QWORD PTR tv506[ebp]
	addsd	xmm1, xmm0
	cvttsd2si edx, xmm1
	mov	DWORD PTR _blend$[ebp], edx

; 220  : 		break;

	jmp	$LN2@CL_FxBlend
$LN6@CL_FxBlend:

; 221  : 	case kRenderFxPulseSlow:
; 222  : 		blend = e->curstate.renderamt + 0x10 * sin( cl.time * 2 + offset );

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+764]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@4000000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv508[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv355[ebp]
	movsd	xmm0, QWORD PTR tv355[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	movsd	xmm1, QWORD PTR tv508[ebp]
	addsd	xmm1, xmm0
	cvttsd2si ecx, xmm1
	mov	DWORD PTR _blend$[ebp], ecx

; 223  : 		break;

	jmp	$LN2@CL_FxBlend
$LN7@CL_FxBlend:

; 224  : 	case kRenderFxPulseFast:
; 225  : 		blend = e->curstate.renderamt + 0x10 * sin( cl.time * 8 + offset );

	mov	edx, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [edx+764]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@4020000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv510[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv363[ebp]
	movsd	xmm0, QWORD PTR tv363[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	movsd	xmm1, QWORD PTR tv510[ebp]
	addsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	mov	DWORD PTR _blend$[ebp], eax

; 226  : 		break;

	jmp	$LN2@CL_FxBlend
$LN8@CL_FxBlend:

; 227  : 	case kRenderFxFadeSlow:			
; 228  : 		if( RP_NORMALPASS( ))

	mov	ecx, DWORD PTR _RI
	and	ecx, 1
	jne	SHORT $LN11@CL_FxBlend

; 229  : 		{
; 230  : 			if( e->curstate.renderamt > 0 ) 

	mov	edx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [edx+764], 0
	jle	SHORT $LN10@CL_FxBlend

; 231  : 				e->curstate.renderamt -= 1;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+764]
	sub	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+764], ecx
	jmp	SHORT $LN11@CL_FxBlend
$LN10@CL_FxBlend:

; 232  : 			else e->curstate.renderamt = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+764], 0
$LN11@CL_FxBlend:

; 233  : 		}
; 234  : 		blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx

; 235  : 		break;

	jmp	$LN2@CL_FxBlend
$LN12@CL_FxBlend:

; 236  : 	case kRenderFxFadeFast:
; 237  : 		if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 1
	jne	SHORT $LN15@CL_FxBlend

; 238  : 		{
; 239  : 			if( e->curstate.renderamt > 3 ) 

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx+764], 3
	jle	SHORT $LN14@CL_FxBlend

; 240  : 				e->curstate.renderamt -= 4;

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+764]
	sub	eax, 4
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+764], eax
	jmp	SHORT $LN15@CL_FxBlend
$LN14@CL_FxBlend:

; 241  : 			else e->curstate.renderamt = 0;

	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+764], 0
$LN15@CL_FxBlend:

; 242  : 		}
; 243  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+764]
	mov	DWORD PTR _blend$[ebp], ecx

; 244  : 		break;

	jmp	$LN2@CL_FxBlend
$LN16@CL_FxBlend:

; 245  : 	case kRenderFxSolidSlow:
; 246  : 		if( RP_NORMALPASS( ))

	mov	edx, DWORD PTR _RI
	and	edx, 1
	jne	SHORT $LN19@CL_FxBlend

; 247  : 		{
; 248  : 			if( e->curstate.renderamt < 255 ) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+764], 255		; 000000ffH
	jge	SHORT $LN18@CL_FxBlend

; 249  : 				e->curstate.renderamt += 1;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	add	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+764], edx
	jmp	SHORT $LN19@CL_FxBlend
$LN18@CL_FxBlend:

; 250  : 			else e->curstate.renderamt = 255;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+764], 255		; 000000ffH
$LN19@CL_FxBlend:

; 251  : 		}
; 252  : 		blend = e->curstate.renderamt;

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+764]
	mov	DWORD PTR _blend$[ebp], eax

; 253  : 		break;

	jmp	$LN2@CL_FxBlend
$LN20@CL_FxBlend:

; 254  : 	case kRenderFxSolidFast:
; 255  : 		if( RP_NORMALPASS( ))

	mov	ecx, DWORD PTR _RI
	and	ecx, 1
	jne	SHORT $LN23@CL_FxBlend

; 256  : 		{
; 257  : 			if( e->curstate.renderamt < 252 ) 

	mov	edx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [edx+764], 252		; 000000fcH
	jge	SHORT $LN22@CL_FxBlend

; 258  : 				e->curstate.renderamt += 4;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+764]
	add	ecx, 4
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+764], ecx
	jmp	SHORT $LN23@CL_FxBlend
$LN22@CL_FxBlend:

; 259  : 			else e->curstate.renderamt = 255;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+764], 255		; 000000ffH
$LN23@CL_FxBlend:

; 260  : 		}
; 261  : 		blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx

; 262  : 		break;

	jmp	$LN2@CL_FxBlend
$LN24@CL_FxBlend:

; 263  : 	case kRenderFxStrobeSlow:
; 264  : 		blend = 20 * sin( cl.time * 4 + offset );

	movsd	xmm0, QWORD PTR _cl+1525848
	mulsd	xmm0, QWORD PTR __real@4010000000000000
	cvtss2sd xmm1, DWORD PTR _offset$[ebp]
	addsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv398[ebp]
	movsd	xmm0, QWORD PTR tv398[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 265  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN25@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN26@CL_FxBlend
$LN25@CL_FxBlend:

; 266  : 		else blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx
$LN26@CL_FxBlend:

; 267  : 		break;

	jmp	$LN2@CL_FxBlend
$LN27@CL_FxBlend:

; 268  : 	case kRenderFxStrobeFast:
; 269  : 		blend = 20 * sin( cl.time * 16 + offset );

	movsd	xmm0, QWORD PTR _cl+1525848
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtss2sd xmm1, DWORD PTR _offset$[ebp]
	addsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv407[ebp]
	movsd	xmm0, QWORD PTR tv407[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 270  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN28@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN29@CL_FxBlend
$LN28@CL_FxBlend:

; 271  : 		else blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx
$LN29@CL_FxBlend:

; 272  : 		break;

	jmp	$LN2@CL_FxBlend
$LN30@CL_FxBlend:

; 273  : 	case kRenderFxStrobeFaster:
; 274  : 		blend = 20 * sin( cl.time * 36 + offset );

	movsd	xmm0, QWORD PTR _cl+1525848
	mulsd	xmm0, QWORD PTR __real@4042000000000000
	cvtss2sd xmm1, DWORD PTR _offset$[ebp]
	addsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv416[ebp]
	movsd	xmm0, QWORD PTR tv416[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 275  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN31@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN32@CL_FxBlend
$LN31@CL_FxBlend:

; 276  : 		else blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx
$LN32@CL_FxBlend:

; 277  : 		break;

	jmp	$LN2@CL_FxBlend
$LN33@CL_FxBlend:

; 278  : 	case kRenderFxFlickerSlow:
; 279  : 		blend = 20 * (sin( cl.time * 2 ) + sin( cl.time * 17 + offset ));

	movsd	xmm0, QWORD PTR _cl+1525848
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv425[ebp]
	movsd	xmm0, QWORD PTR tv425[ebp]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@4031000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv544[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv431[ebp]
	movsd	xmm0, QWORD PTR tv544[ebp]
	addsd	xmm0, QWORD PTR tv431[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 280  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN34@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN35@CL_FxBlend
$LN34@CL_FxBlend:

; 281  : 		else blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx
$LN35@CL_FxBlend:

; 282  : 		break;

	jmp	$LN2@CL_FxBlend
$LN36@CL_FxBlend:

; 283  : 	case kRenderFxFlickerFast:
; 284  : 		blend = 20 * (sin( cl.time * 16 ) + sin( cl.time * 23 + offset ));

	movsd	xmm0, QWORD PTR _cl+1525848
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv440[ebp]
	movsd	xmm0, QWORD PTR tv440[ebp]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@4037000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv546[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv446[ebp]
	movsd	xmm0, QWORD PTR tv546[ebp]
	addsd	xmm0, QWORD PTR tv446[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 285  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN37@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN38@CL_FxBlend
$LN37@CL_FxBlend:

; 286  : 		else blend = e->curstate.renderamt;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+764]
	mov	DWORD PTR _blend$[ebp], edx
$LN38@CL_FxBlend:

; 287  : 		break;

	jmp	$LN2@CL_FxBlend
$LN39@CL_FxBlend:

; 288  : 	case kRenderFxHologram:
; 289  : 	case kRenderFxDistort:
; 290  : 		VectorCopy( e->origin, tmp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+2888]
	mov	DWORD PTR _tmp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+2888]
	mov	DWORD PTR _tmp$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+2888]
	mov	DWORD PTR _tmp$[ebp+ecx], eax

; 291  : 		VectorSubtract( tmp, RI.vieworg, tmp );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+edx]
	subss	xmm0, DWORD PTR _RI[ecx+200]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _tmp$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+ecx]
	subss	xmm0, DWORD PTR _RI[edx+200]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _tmp$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _tmp$[ebp+ecx]
	subss	xmm0, DWORD PTR _RI[edx+200]
	movss	DWORD PTR tv267[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv267[ebp]
	movss	DWORD PTR _tmp$[ebp+eax], xmm0

; 292  : 		dist = DotProduct( tmp, RI.vforward );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+edx]
	mulss	xmm0, DWORD PTR _RI[ecx+224]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _tmp$[ebp+edx]
	mulss	xmm1, DWORD PTR _RI[eax+224]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _tmp$[ebp+ecx]
	mulss	xmm1, DWORD PTR _RI[edx+224]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 293  : 			
; 294  : 		// turn off distance fade
; 295  : 		if( e->curstate.renderfx == kRenderFxDistort )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+772], 15			; 0000000fH
	jne	SHORT $LN40@CL_FxBlend

; 296  : 			dist = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dist$[ebp], xmm0
$LN40@CL_FxBlend:

; 297  : 
; 298  : 		if( dist <= 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jb	SHORT $LN41@CL_FxBlend

; 299  : 		{
; 300  : 			blend = 0;

	mov	DWORD PTR _blend$[ebp], 0

; 301  : 		}

	jmp	SHORT $LN42@CL_FxBlend
$LN41@CL_FxBlend:

; 302  : 		else 
; 303  : 		{
; 304  : 			e->curstate.renderamt = 180;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+764], 180		; 000000b4H

; 305  : 			if( dist <= 100 ) blend = e->curstate.renderamt;

	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jb	SHORT $LN43@CL_FxBlend
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+764]
	mov	DWORD PTR _blend$[ebp], eax
	jmp	SHORT $LN44@CL_FxBlend
$LN43@CL_FxBlend:

; 306  : 			else blend = (int) ((1.0f - ( dist - 100 ) * ( 1.0f / 400.0f )) * e->curstate.renderamt );

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR __real@3b23d70a
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+764]
	mulss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	DWORD PTR _blend$[ebp], edx
$LN44@CL_FxBlend:

; 307  : 			blend += COM_RandomLong( -32, 31 );

	push	31					; 0000001fH
	push	-32					; ffffffe0H
	call	_COM_RandomLong
	add	esp, 8
	add	eax, DWORD PTR _blend$[ebp]
	mov	DWORD PTR _blend$[ebp], eax
$LN42@CL_FxBlend:

; 308  : 		}
; 309  : 		break;

	jmp	SHORT $LN2@CL_FxBlend
$LN45@CL_FxBlend:

; 310  : 	default:
; 311  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+764]
	mov	DWORD PTR _blend$[ebp], ecx
$LN2@CL_FxBlend:

; 312  : 		break;
; 313  : 	}
; 314  : 
; 315  : 	blend = bound( 0, blend, 255 );

	cmp	DWORD PTR _blend$[ebp], 0
	jl	SHORT $LN49@CL_FxBlend
	cmp	DWORD PTR _blend$[ebp], 255		; 000000ffH
	jge	SHORT $LN47@CL_FxBlend
	mov	edx, DWORD PTR _blend$[ebp]
	mov	DWORD PTR tv311[ebp], edx
	jmp	SHORT $LN48@CL_FxBlend
$LN47@CL_FxBlend:
	mov	DWORD PTR tv311[ebp], 255		; 000000ffH
$LN48@CL_FxBlend:
	mov	eax, DWORD PTR tv311[ebp]
	mov	DWORD PTR tv312[ebp], eax
	jmp	SHORT $LN50@CL_FxBlend
$LN49@CL_FxBlend:
	mov	DWORD PTR tv312[ebp], 0
$LN50@CL_FxBlend:
	mov	ecx, DWORD PTR tv312[ebp]
	mov	DWORD PTR _blend$[ebp], ecx

; 316  : 
; 317  : 	return blend;

	mov	eax, DWORD PTR _blend$[ebp]

; 318  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN51@CL_FxBlend:
	DD	$LN6@CL_FxBlend
	DD	$LN7@CL_FxBlend
	DD	$LN4@CL_FxBlend
	DD	$LN5@CL_FxBlend
	DD	$LN8@CL_FxBlend
	DD	$LN12@CL_FxBlend
	DD	$LN16@CL_FxBlend
	DD	$LN20@CL_FxBlend
	DD	$LN24@CL_FxBlend
	DD	$LN27@CL_FxBlend
	DD	$LN30@CL_FxBlend
	DD	$LN33@CL_FxBlend
	DD	$LN36@CL_FxBlend
	DD	$LN45@CL_FxBlend
	DD	$LN39@CL_FxBlend
	DD	$LN39@CL_FxBlend
_CL_FxBlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_filepath$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_CL_AddClientResources PROC

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 	char	filepath[MAX_QPATH];
; 151  : 	int	i;
; 152  : 
; 153  : 	// don't request resources from localhost or in quake-compatibility mode
; 154  : 	if( cl.maxclients <= 1 || CL_IsQuakeCompatible( ))

	cmp	DWORD PTR _cl+1568832, 1
	jle	SHORT $LN15@CL_AddClie
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN14@CL_AddClie
$LN15@CL_AddClie:

; 155  : 		return;

	jmp	$LN1@CL_AddClie
$LN14@CL_AddClie:

; 156  : 
; 157  : 	// check sprites first
; 158  : 	for( i = 0; i < ARRAYSIZE_XASH( cl_default_sprites ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_AddClie
$LN2@CL_AddClie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 7
	jae	SHORT $LN3@CL_AddClie

; 159  : 	{
; 160  : 		if( !FS_FileExists( cl_default_sprites[i], false ))

	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cl_default_sprites[ecx*4]
	push	edx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@CL_AddClie

; 161  : 			CL_AddClientResource( cl_default_sprites[i], t_model );

	push	2
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_default_sprites[eax*4]
	push	ecx
	call	_CL_AddClientResource
	add	esp, 8
$LN16@CL_AddClie:

; 162  : 	}

	jmp	SHORT $LN2@CL_AddClie
$LN3@CL_AddClie:

; 163  : 
; 164  : 	// then check sounds
; 165  : 	for( i = 0; i < ARRAYSIZE_XASH( cl_player_shell_sounds ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_AddClie
$LN5@CL_AddClie:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN6@CL_AddClie

; 166  : 	{
; 167  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_player_shell_sounds[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_player_shell_sounds[eax*4]
	push	ecx
	push	OFFSET $SG146036
	push	OFFSET $SG146037
	push	64					; 00000040H
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 168  : 
; 169  : 		if( !FS_FileExists( filepath, false ))

	push	0
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@CL_AddClie

; 170  : 			CL_AddClientResource( cl_player_shell_sounds[i], t_sound );

	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cl_player_shell_sounds[ecx*4]
	push	edx
	call	_CL_AddClientResource
	add	esp, 8
$LN17@CL_AddClie:

; 171  : 	}

	jmp	SHORT $LN5@CL_AddClie
$LN6@CL_AddClie:

; 172  : 
; 173  : 	for( i = 0; i < ARRAYSIZE_XASH( cl_weapon_shell_sounds ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@CL_AddClie
$LN8@CL_AddClie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN9@CL_AddClie

; 174  : 	{
; 175  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_weapon_shell_sounds[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cl_weapon_shell_sounds[ecx*4]
	push	edx
	push	OFFSET $SG146039
	push	OFFSET $SG146040
	push	64					; 00000040H
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 176  : 
; 177  : 		if( !FS_FileExists( filepath, false ))

	push	0
	lea	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@CL_AddClie

; 178  : 			CL_AddClientResource( cl_weapon_shell_sounds[i], t_sound );

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cl_weapon_shell_sounds[edx*4]
	push	eax
	call	_CL_AddClientResource
	add	esp, 8
$LN18@CL_AddClie:

; 179  : 	}

	jmp	SHORT $LN8@CL_AddClie
$LN9@CL_AddClie:

; 180  : 
; 181  : 	for( i = 0; i < ARRAYSIZE_XASH( cl_explode_sounds ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@CL_AddClie
$LN11@CL_AddClie:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN1@CL_AddClie

; 182  : 	{
; 183  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_explode_sounds[i] );

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cl_explode_sounds[edx*4]
	push	eax
	push	OFFSET $SG146042
	push	OFFSET $SG146043
	push	64					; 00000040H
	lea	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 184  : 
; 185  : 		if( !FS_FileExists( filepath, false ))

	push	0
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@CL_AddClie

; 186  : 			CL_AddClientResource( cl_explode_sounds[i], t_sound );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_explode_sounds[eax*4]
	push	ecx
	call	_CL_AddClientResource
	add	esp, 8
$LN19@CL_AddClie:

; 187  : 	}

	jmp	SHORT $LN11@CL_AddClie
$LN1@CL_AddClie:

; 188  : 
; 189  : #if 0	// ric sounds was precached by server-side
; 190  : 	for( i = 0; i < ARRAYSIZE_XASH( cl_ricochet_sounds ); i++ )
; 191  : 	{
; 192  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_ricochet_sounds[i] );
; 193  : 
; 194  : 		if( !FS_FileExists( filepath, false ))
; 195  : 			CL_AddClientResource( cl_ricochet_sounds[i], t_sound );
; 196  : 	}
; 197  : #endif
; 198  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddClientResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_p$ = -8						; size = 4
_pResource$ = -4					; size = 4
_filename$ = 8						; size = 4
_type$ = 12						; size = 4
_CL_AddClientResource PROC

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 119  : 	resource_t	*p, *pResource;
; 120  : 
; 121  : 	for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl+1985124
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@CL_AddClie
$LN2@CL_AddClie:
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _p$[ebp], edx
$LN4@CL_AddClie:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	SHORT $LN3@CL_AddClie

; 122  : 	{
; 123  : 		if( !Q_stricmp( p->szFileName, filename ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@CL_AddClie

; 124  : 			break;

	jmp	SHORT $LN3@CL_AddClie
$LN5@CL_AddClie:

; 125  : 	}

	jmp	SHORT $LN2@CL_AddClie
$LN3@CL_AddClie:

; 126  : 
; 127  : 	if( p != &cl.resourcesneeded )

	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	SHORT $LN6@CL_AddClie

; 128  : 		return; // already in list?

	jmp	SHORT $LN1@CL_AddClie
$LN6@CL_AddClie:

; 129  : 
; 130  : 	pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	push	130					; 00000082H
	push	OFFSET $SG146016
	push	1
	push	136					; 00000088H
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 131  : 
; 132  : 	Q_strncpy( pResource->szFileName, filename, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 133  : 	pResource->type = type;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+64], eax

; 134  : 	pResource->nIndex = -1; // client resource marker

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+68], -1

; 135  : 	pResource->nDownloadSize = 1;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [edx+72], 1

; 136  : 	pResource->ucFlags |= RES_WASMISSING;

	mov	eax, DWORD PTR _pResource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [edx+76], cl

; 137  : 
; 138  : 	CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+1984996
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8
$LN1@CL_AddClie:

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddClientResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_decalname$1 = -12					; size = 4
_textureIndex$ = -8					; size = 4
_pCust$ = -4						; size = 4
_playernum$ = 8						; size = 4
_customIndex$ = 12					; size = 4
_entityIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_CL_PlayerDecal PROC

; 3009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3010 : 	int		textureIndex = 0;

	mov	DWORD PTR _textureIndex$[ebp], 0

; 3011 : 	customization_t	*pCust = NULL;

	mov	DWORD PTR _pCust$[ebp], 0

; 3012 : 
; 3013 : 	if( playernum < MAX_CLIENTS )

	cmp	DWORD PTR _playernum$[ebp], 32		; 00000020H
	jge	SHORT $LN2@CL_PlayerD

; 3014 : 		pCust = cl.players[playernum].customdata.pNext;

	imul	eax, DWORD PTR _playernum$[ebp], 584
	mov	ecx, DWORD PTR _cl[eax+1543712]
	mov	DWORD PTR _pCust$[ebp], ecx
$LN2@CL_PlayerD:

; 3015 : 
; 3016 : 	if( pCust != NULL && pCust->pBuffer != NULL && pCust->pInfo != NULL )

	cmp	DWORD PTR _pCust$[ebp], 0
	je	$LN4@CL_PlayerD
	mov	edx, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	$LN4@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	$LN4@CL_PlayerD

; 3017 : 	{
; 3018 : 		if( FBitSet( pCust->resource.ucFlags, RES_CUSTOM ) && pCust->resource.type == t_decal && pCust->bTranslated )

	mov	ecx, DWORD PTR _pCust$[ebp]
	movzx	edx, BYTE PTR [ecx+80]
	and	edx, 4
	je	SHORT $LN4@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN4@CL_PlayerD
	mov	ecx, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [ecx+140], 0
	je	SHORT $LN4@CL_PlayerD

; 3019 : 		{
; 3020 : 			if( !pCust->nUserData1 && pCust->pInfo != NULL )

	mov	edx, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [edx+144], 0
	jne	SHORT $LN5@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN5@CL_PlayerD

; 3021 : 			{
; 3022 : 				const char *decalname = va( "player%dlogo%d", playernum, customIndex );

	mov	ecx, DWORD PTR _customIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _playernum$[ebp]
	push	edx
	push	OFFSET $SG147236
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _decalname$1[ebp], eax

; 3023 : 				pCust->nUserData1 = GL_LoadTextureInternal( decalname, pCust->pInfo, TF_DECAL );

	push	0
	push	2048					; 00000800H
	mov	eax, DWORD PTR _pCust$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	push	ecx
	mov	edx, DWORD PTR _decalname$1[ebp]
	push	edx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _pCust$[ebp]
	mov	DWORD PTR [ecx+144], eax
$LN5@CL_PlayerD:

; 3024 : 			}
; 3025 : 			textureIndex = pCust->nUserData1;

	mov	edx, DWORD PTR _pCust$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _textureIndex$[ebp], eax
$LN4@CL_PlayerD:

; 3026 : 		}
; 3027 : 	}
; 3028 : 
; 3029 : 	R_DecalShoot( textureIndex, entityIndex, 0, pos, FDECAL_CUSTOM, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _textureIndex$[ebp]
	push	eax
	call	_R_DecalShoot
	add	esp, 24					; 00000018H

; 3030 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_textureIndex$ = 8					; size = 4
_entityIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_flags$ = 24						; size = 4
_CL_DecalShoot PROC

; 2985 : {

	push	ebp
	mov	ebp, esp

; 2986 : 	R_DecalShoot( textureIndex, entityIndex, modelIndex, pos, flags, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _textureIndex$[ebp]
	push	ecx
	call	_R_DecalShoot
	add	esp, 24					; 00000018H

; 2987 : }

	pop	ebp
	ret	0
_CL_DecalShoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_textureIndex$ = 8					; size = 4
_entityIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_flags$ = 24						; size = 4
_scale$ = 28						; size = 4
_CL_FireCustomDecal PROC

; 2997 : {

	push	ebp
	mov	ebp, esp

; 2998 : 	R_DecalShoot( textureIndex, entityIndex, modelIndex, pos, flags, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _textureIndex$[ebp]
	push	ecx
	call	_R_DecalShoot
	add	esp, 24					; 00000018H

; 2999 : }

	pop	ebp
	ret	0
_CL_FireCustomDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_r$ = -68						; size = 4
_f$ = -64						; size = 4
tv170 = -60						; size = 4
tv78 = -56						; size = 4
tv77 = -52						; size = 4
tv67 = -48						; size = 4
_numLights$ = -44					; size = 4
_dl$ = -40						; size = 4
_j$ = -36						; size = 4
_i$ = -32						; size = 4
_right$ = -28						; size = 12
_forward$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_CL_TestLights PROC

; 2940 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2941 : 	int	i, j, numLights;
; 2942 : 	vec3_t	forward, right;
; 2943 : 	float	f, r;
; 2944 : 	dlight_t	*dl;
; 2945 : 
; 2946 : 	if( !CVAR_TO_BOOL( cl_testlights ))

	cmp	DWORD PTR _cl_testlights, 0
	je	SHORT $LN10@CL_TestLig
	mov	eax, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@CL_TestLig
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN11@CL_TestLig
$LN10@CL_TestLig:
	mov	DWORD PTR tv67[ebp], 0
$LN11@CL_TestLig:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN8@CL_TestLig

; 2947 : 		return;

	jmp	$LN3@CL_TestLig
$LN8@CL_TestLig:

; 2948 : 
; 2949 : 	numLights = bound( 1, cl_testlights->value, MAX_DLIGHTS );

	mov	ecx, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN14@CL_TestLig
	mov	edx, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR __real@42000000
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN12@CL_TestLig
	mov	eax, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN13@CL_TestLig
$LN12@CL_TestLig:
	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR tv77[ebp], xmm0
$LN13@CL_TestLig:
	movss	xmm0, DWORD PTR tv77[ebp]
	movss	DWORD PTR tv78[ebp], xmm0
	jmp	SHORT $LN15@CL_TestLig
$LN14@CL_TestLig:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv78[ebp], xmm0
$LN15@CL_TestLig:
	cvttss2si ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _numLights$[ebp], ecx

; 2950 : 	AngleVectors( cl.viewangles, forward, right, NULL );

	push	0
	lea	edx, DWORD PTR _right$[ebp]
	push	edx
	lea	eax, DWORD PTR _forward$[ebp]
	push	eax
	push	OFFSET _cl+1568612
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2951 : 	
; 2952 : 	for( i = 0; i < numLights; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_TestLig
$LN2@CL_TestLig:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_TestLig:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numLights$[ebp]
	jge	$LN3@CL_TestLig

; 2953 : 	{
; 2954 : 		dl = &cl_dlights[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _cl_dlights
	mov	DWORD PTR _dl$[ebp], eax

; 2955 : 
; 2956 : 		r = 64 * ((i % 4) - 1.5f );

	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN18@CL_TestLig
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN18@CL_TestLig:
	cvtsi2ss xmm0, ecx
	subss	xmm0, DWORD PTR __real@3fc00000
	mulss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _r$[ebp], xmm0

; 2957 : 		f = 64 * ( i / 4) + 128;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	shl	eax, 6
	add	eax, 128				; 00000080H
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _f$[ebp], xmm0

; 2958 : 
; 2959 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@CL_TestLig
$LN5@CL_TestLig:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@CL_TestLig:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@CL_TestLig

; 2960 : 			dl->origin[j] = cl.simorg[j] + forward[j] * f + right[j] * r;

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _forward$[ebp+eax*4]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	addss	xmm0, DWORD PTR _cl[ecx*4+1568804]
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm1, DWORD PTR _right$[ebp+edx*4]
	mulss	xmm1, DWORD PTR _r$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
	jmp	SHORT $LN5@CL_TestLig
$LN6@CL_TestLig:

; 2961 : 
; 2962 : 		dl->color.r = ((((i % 6) + 1) & 1)>>0) * 255;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 1
	and	edx, 1
	imul	edx, edx, 255
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+16], dl

; 2963 : 		dl->color.g = ((((i % 6) + 1) & 2)>>1) * 255;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 1
	and	edx, 2
	sar	edx, 1
	imul	edx, edx, 255
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+17], dl

; 2964 : 		dl->color.b = ((((i % 6) + 1) & 4)>>2) * 255;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 1
	and	edx, 4
	sar	edx, 2
	imul	edx, edx, 255
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+18], dl

; 2965 : 		dl->radius = Q_max( 64, 200 - 5 * numLights );

	imul	ecx, DWORD PTR _numLights$[ebp], 5
	mov	edx, 200				; 000000c8H
	sub	edx, ecx
	cmp	edx, 64					; 00000040H
	jge	SHORT $LN16@CL_TestLig
	mov	DWORD PTR tv170[ebp], 64		; 00000040H
	jmp	SHORT $LN17@CL_TestLig
$LN16@CL_TestLig:
	imul	eax, DWORD PTR _numLights$[ebp], 5
	mov	ecx, 200				; 000000c8H
	sub	ecx, eax
	mov	DWORD PTR tv170[ebp], ecx
$LN17@CL_TestLig:
	cvtsi2ss xmm0, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [edx+12], xmm0

; 2966 : 		dl->die = cl.time + host.frametime;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR _host+1448
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2967 : 	}

	jmp	$LN2@CL_TestLig
$LN3@CL_TestLig:

; 2968 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TestLights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearEfrags PROC

; 3104 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3105 : 	int	i;
; 3106 : 
; 3107 : 	memset( cl_efrags, 0, sizeof( cl_efrags ));

	push	131072					; 00020000H
	push	0
	push	OFFSET _cl_efrags
	call	_memset
	add	esp, 12					; 0000000cH

; 3108 : 
; 3109 : 	// allocate the efrags and chain together into a free list
; 3110 : 	clgame.free_efrags = cl_efrags;

	mov	DWORD PTR _clgame+149796, OFFSET _cl_efrags

; 3111 : 	for( i = 0; i < MAX_EFRAGS - 1; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearEf
$LN2@CL_ClearEf:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearEf:
	cmp	DWORD PTR _i$[ebp], 8191		; 00001fffH
	jge	SHORT $LN3@CL_ClearEf

; 3112 : 		clgame.free_efrags[i].entnext = &clgame.free_efrags[i+1];

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	shl	ecx, 4
	add	ecx, DWORD PTR _clgame+149796
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _clgame+149796
	mov	DWORD PTR [eax+edx+12], ecx
	jmp	SHORT $LN2@CL_ClearEf
$LN3@CL_ClearEf:

; 3113 : 	clgame.free_efrags[i].entnext = NULL;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _clgame+149796
	mov	DWORD PTR [edx+ecx+12], 0

; 3114 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearEfrags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_CL_ClearEffects PROC

; 3122 : {

	push	ebp
	mov	ebp, esp

; 3123 : 	CL_ClearEfrags ();

	call	_CL_ClearEfrags

; 3124 : 	CL_ClearDlights ();

	call	_CL_ClearDlights

; 3125 : 	CL_ClearTempEnts ();

	call	_CL_ClearTempEnts

; 3126 : 	CL_ClearViewBeams ();

	call	_CL_ClearViewBeams

; 3127 : 	CL_ClearParticles ();

	call	_CL_ClearParticles

; 3128 : 	CL_ClearLightStyles ();

	call	_CL_ClearLightStyles

; 3129 : }

	pop	ebp
	ret	0
_CL_ClearEffects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_decalIndices$ = -424					; size = 4
tv2508 = -420						; size = 4
tv2502 = -416						; size = 4
tv2496 = -412						; size = 4
tv2490 = -408						; size = 4
tv2484 = -404						; size = 4
_r$ = -400						; size = 4
_g$ = -396						; size = 4
_b$ = -392						; size = 4
tv76 = -388						; size = 4
_iSize$ = -384						; size = 4
_frameRate$ = -380					; size = 4
_pEnt$ = -376						; size = 4
_brightness$ = -372					; size = 4
_random$ = -368						; size = 4
_vel$ = -364						; size = 4
_type$ = -360						; size = 4
_flags$ = -356						; size = 4
_decalIndex$ = -352					; size = 4
_entityIndex$ = -348					; size = 4
_pTemp$ = -344						; size = 4
_dl$ = -340						; size = 4
_color$ = -336						; size = 4
_count$ = -332						; size = 4
_life$ = -328						; size = 4
_scale$ = -324						; size = 4
_modelIndex$ = -320					; size = 4
_buf$ = -316						; size = 20
_ang$ = -296						; size = 12
_pos2$ = -284						; size = 12
_pos$ = -272						; size = 12
_pbuf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseTempEntity PROC

; 2024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2025 : 	sizebuf_t		buf;
; 2026 : 	byte		pbuf[256];
; 2027 : 	int		iSize = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax

; 2028 : 	int		type, color, count, flags;
; 2029 : 	int		decalIndex, modelIndex, entityIndex;
; 2030 : 	float		scale, life, frameRate, vel, random;
; 2031 : 	float		brightness, r, g, b;
; 2032 : 	vec3_t		pos, pos2, ang;
; 2033 : 	int		decalIndices[1];	// just stub
; 2034 : 	TEMPENTITY	*pTemp;
; 2035 : 	cl_entity_t	*pEnt;
; 2036 : 	dlight_t		*dl;
; 2037 : 
; 2038 : 	decalIndex = modelIndex = entityIndex = 0;

	mov	DWORD PTR _entityIndex$[ebp], 0
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	mov	DWORD PTR _modelIndex$[ebp], ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	mov	DWORD PTR _decalIndex$[ebp], edx

; 2039 : 
; 2040 : 	// parse user message into buffer
; 2041 : 	MSG_ReadBytes( msg, pbuf, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 2042 : 
; 2043 : 	// init a safe tempbuffer
; 2044 : 	MSG_Init( &buf, "TempEntity", pbuf, iSize );

	push	-1
	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	push	OFFSET $SG146957
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2045 : 
; 2046 : 	type = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 2047 : 
; 2048 : 	switch( type )

	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 127		; 0000007fH
	ja	$LN64@CL_ParseTe
	mov	edx, DWORD PTR tv76[ebp]
	movzx	eax, BYTE PTR $LN67@CL_ParseTe[edx]
	jmp	DWORD PTR $LN68@CL_ParseTe[eax*4]
$LN4@CL_ParseTe:

; 2049 : 	{
; 2050 : 	case TE_BEAMPOINTS:
; 2051 : 	case TE_BEAMENTPOINT:
; 2052 : 	case TE_LIGHTNING:
; 2053 : 	case TE_BEAMENTS:
; 2054 : 	case TE_BEAM:
; 2055 : 	case TE_BEAMSPRITE:
; 2056 : 	case TE_BEAMTORUS:
; 2057 : 	case TE_BEAMDISK:
; 2058 : 	case TE_BEAMCYLINDER:
; 2059 : 	case TE_BEAMFOLLOW:
; 2060 : 	case TE_BEAMRING:
; 2061 : 	case TE_BEAMHOSE:
; 2062 : 	case TE_KILLBEAM:
; 2063 : 		CL_ParseViewBeam( &buf, type );

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_CL_ParseViewBeam
	add	esp, 8

; 2064 : 		break;

	jmp	$LN2@CL_ParseTe
$LN5@CL_ParseTe:

; 2065 : 	case TE_GUNSHOT:
; 2066 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2067 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2068 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2069 : 		R_RicochetSound( pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_RicochetSound
	add	esp, 4

; 2070 : 		R_RunParticleEffect( pos, vec3_origin, 0, 20 );

	push	20					; 00000014H
	push	0
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_RunParticleEffect
	add	esp, 16					; 00000010H

; 2071 : 		break;

	jmp	$LN2@CL_ParseTe
$LN6@CL_ParseTe:

; 2072 : 	case TE_EXPLOSION:
; 2073 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2074 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2075 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2076 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2077 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2078 : 		frameRate = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _frameRate$[ebp], xmm0

; 2079 : 		flags = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2080 : 		R_Explosion( pos, modelIndex, scale, frameRate, flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _frameRate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_Explosion
	add	esp, 20					; 00000014H

; 2081 : 		break;

	jmp	$LN2@CL_ParseTe
$LN7@CL_ParseTe:

; 2082 : 	case TE_TAREXPLOSION:
; 2083 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2084 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2085 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2086 : 		R_BlobExplosion( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BlobExplosion
	add	esp, 4

; 2087 : 		break;

	jmp	$LN2@CL_ParseTe
$LN8@CL_ParseTe:

; 2088 : 	case TE_SMOKE:
; 2089 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2090 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2091 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2092 : 		modelIndex = MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2093 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2094 : 		frameRate = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _frameRate$[ebp], xmm0

; 2095 : 		pTemp = R_DefaultSprite( pos, modelIndex, frameRate );

	push	ecx
	movss	xmm0, DWORD PTR _frameRate$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTemp$[ebp], eax

; 2096 : 		R_Sprite_Smoke( pTemp, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_R_Sprite_Smoke
	add	esp, 8

; 2097 : 		break;

	jmp	$LN2@CL_ParseTe
$LN9@CL_ParseTe:

; 2098 : 	case TE_TRACER:
; 2099 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2100 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2101 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2102 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2103 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2104 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2105 : 		R_TracerEffect( pos, pos2 );

	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_TracerEffect
	add	esp, 8

; 2106 : 		break;

	jmp	$LN2@CL_ParseTe
$LN10@CL_ParseTe:

; 2107 : 	case TE_SPARKS:
; 2108 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2109 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2110 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2111 : 		R_SparkShower( pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_SparkShower
	add	esp, 4

; 2112 : 		break;

	jmp	$LN2@CL_ParseTe
$LN11@CL_ParseTe:

; 2113 : 	case TE_LAVASPLASH:
; 2114 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2115 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2116 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2117 : 		R_LavaSplash( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_LavaSplash
	add	esp, 4

; 2118 : 		break;

	jmp	$LN2@CL_ParseTe
$LN12@CL_ParseTe:

; 2119 : 	case TE_TELEPORT:
; 2120 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2121 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2122 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2123 : 		R_TeleportSplash( pos );

	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_TeleportSplash
	add	esp, 4

; 2124 : 		break;

	jmp	$LN2@CL_ParseTe
$LN13@CL_ParseTe:

; 2125 : 	case TE_EXPLOSION2:
; 2126 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2127 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2128 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2129 : 		color = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2130 : 		count = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2131 : 		R_ParticleExplosion2( pos, color, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_ParticleExplosion2
	add	esp, 12					; 0000000cH

; 2132 : 		break;

	jmp	$LN2@CL_ParseTe
$LN14@CL_ParseTe:

; 2133 : 	case TE_BSPDECAL:
; 2134 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2135 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2136 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2137 : 		decalIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2138 : 		entityIndex = MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2139 : 		if( entityIndex ) modelIndex = MSG_ReadShort( &buf );

	cmp	DWORD PTR _entityIndex$[ebp], 0
	je	SHORT $LN15@CL_ParseTe
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax
$LN15@CL_ParseTe:

; 2140 : 		CL_DecalShoot( CL_DecalIndex( decalIndex ), entityIndex, modelIndex, pos, FDECAL_PERMANENT );

	push	1
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalIndex$[ebp]
	push	ecx
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H

; 2141 : 		break;

	jmp	$LN2@CL_ParseTe
$LN16@CL_ParseTe:

; 2142 : 	case TE_IMPLOSION:
; 2143 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2144 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2145 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2146 : 		scale = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2147 : 		count = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2148 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2149 : 		R_Implosion( pos, scale, count, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_Implosion
	add	esp, 16					; 00000010H

; 2150 : 		break;

	jmp	$LN2@CL_ParseTe
$LN17@CL_ParseTe:

; 2151 : 	case TE_SPRITETRAIL:
; 2152 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2153 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2154 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2155 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2156 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2157 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2158 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2159 : 		count = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2160 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2161 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2162 : 		vel = (float)MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vel$[ebp], xmm0

; 2163 : 		random = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2164 : 		R_Sprite_Trail( type, pos, pos2, modelIndex, count, life, scale, random, 255, vel );

	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	255					; 000000ffH
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	_R_Sprite_Trail
	add	esp, 40					; 00000028H

; 2165 : 		break;

	jmp	$LN2@CL_ParseTe
$LN18@CL_ParseTe:

; 2166 : 	case TE_SPRITE:
; 2167 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2168 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2169 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2170 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2171 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2172 : 		brightness = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _brightness$[ebp], xmm0

; 2173 : 
; 2174 : 		if(( pTemp = R_DefaultSprite( pos, modelIndex, 0 )) != NULL )

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN19@CL_ParseTe

; 2175 : 		{
; 2176 : 			pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+820], xmm0

; 2177 : 			pTemp->entity.baseline.renderamt = brightness;

	cvttss2si ecx, DWORD PTR _brightness$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+152], ecx

; 2178 : 			pTemp->entity.curstate.renderamt = brightness;

	cvttss2si eax, DWORD PTR _brightness$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], eax

; 2179 : 			pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 5
$LN19@CL_ParseTe:

; 2180 : 		}
; 2181 : 		break;

	jmp	$LN2@CL_ParseTe
$LN20@CL_ParseTe:

; 2182 : 	case TE_GLOWSPRITE:
; 2183 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2184 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2185 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2186 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2187 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2188 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2189 : 		brightness = (float)MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _brightness$[ebp], xmm0

; 2190 : 
; 2191 : 		if(( pTemp = R_DefaultSprite( pos, modelIndex, 0 )) != NULL )

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN21@CL_ParseTe

; 2192 : 		{
; 2193 : 			pTemp->entity.curstate.scale = scale;

	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [ecx+820], xmm0

; 2194 : 			pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+828], 3

; 2195 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+840], 14			; 0000000eH

; 2196 : 			pTemp->entity.baseline.renderamt = brightness;

	cvttss2si ecx, DWORD PTR _brightness$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+152], ecx

; 2197 : 			pTemp->entity.curstate.renderamt = brightness;

	cvttss2si eax, DWORD PTR _brightness$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+832], eax

; 2198 : 			pTemp->flags = FTENT_FADEOUT;

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], 128			; 00000080H

; 2199 : 			pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN21@CL_ParseTe:

; 2200 : 		}
; 2201 : 		break;

	jmp	$LN2@CL_ParseTe
$LN22@CL_ParseTe:

; 2202 : 	case TE_STREAK_SPLASH:
; 2203 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2204 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2205 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2206 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2207 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2208 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2209 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2210 : 		count = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2211 : 		vel = (float)MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vel$[ebp], xmm0

; 2212 : 		random = (float)MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2213 : 		R_StreakSplash( pos, pos2, color, count, vel, -random, random );

	cvttss2si ecx, DWORD PTR _random$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvttss2si edx, xmm0
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_StreakSplash
	add	esp, 28					; 0000001cH

; 2214 : 		break;

	jmp	$LN2@CL_ParseTe
$LN23@CL_ParseTe:

; 2215 : 	case TE_DLIGHT:
; 2216 : 		dl = CL_AllocDlight( 0 );

	push	0
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$[ebp], eax

; 2217 : 		dl->origin[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 2218 : 		dl->origin[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 2219 : 		dl->origin[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 2220 : 		dl->radius = (float)(MSG_ReadByte( &buf ) * 10.0f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 2221 : 		dl->color.r = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	edx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [edx+16], al

; 2222 : 		dl->color.g = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+17], al

; 2223 : 		dl->color.b = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+18], al

; 2224 : 		dl->die = cl.time + (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2225 : 		dl->decay = (float)(MSG_ReadByte( &buf ) * 10.0f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [edx+24], xmm0

; 2226 : 		break;

	jmp	$LN2@CL_ParseTe
$LN24@CL_ParseTe:

; 2227 : 	case TE_ELIGHT:
; 2228 : 		dl = CL_AllocElight( MSG_ReadShort( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	push	eax
	call	_CL_AllocElight
	add	esp, 4
	mov	DWORD PTR _dl$[ebp], eax

; 2229 : 		dl->origin[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 2230 : 		dl->origin[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 2231 : 		dl->origin[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 2232 : 		dl->radius = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [eax+12]

; 2233 : 		dl->color.r = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	edx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [edx+16], al

; 2234 : 		dl->color.g = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+17], al

; 2235 : 		dl->color.b = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+18], al

; 2236 : 		life = (float)MSG_ReadByte( &buf ) * 0.1f;

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2237 : 		dl->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2238 : 		dl->decay = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [edx+24]

; 2239 : 		if( life != 0 ) dl->decay /= life;

	movss	xmm0, DWORD PTR _life$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN25@CL_ParseTe
	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	divss	xmm0, DWORD PTR _life$[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+24], xmm0
$LN25@CL_ParseTe:

; 2240 : 		break;

	jmp	$LN2@CL_ParseTe
$LN26@CL_ParseTe:

; 2241 : 	case TE_TEXTMESSAGE:
; 2242 : 		CL_ParseTextMessage( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_CL_ParseTextMessage
	add	esp, 4

; 2243 : 		break;

	jmp	$LN2@CL_ParseTe
$LN27@CL_ParseTe:

; 2244 : 	case TE_LINE:
; 2245 : 	case TE_BOX:
; 2246 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2247 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2248 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2249 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2250 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2251 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2252 : 		life = (float)(MSG_ReadShort( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2253 : 		r = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _r$[ebp], xmm0

; 2254 : 		g = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _g$[ebp], xmm0

; 2255 : 		b = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _b$[ebp], xmm0

; 2256 : 		if( type == TE_LINE ) R_ParticleLine( pos, pos2, r, g, b, life );

	cmp	DWORD PTR _type$[ebp], 30		; 0000001eH
	jne	SHORT $LN28@CL_ParseTe
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvttss2si eax, DWORD PTR _b$[ebp]
	movzx	ecx, al
	push	ecx
	cvttss2si edx, DWORD PTR _g$[ebp]
	movzx	eax, dl
	push	eax
	cvttss2si ecx, DWORD PTR _r$[ebp]
	movzx	edx, cl
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_ParticleLine
	add	esp, 24					; 00000018H
	jmp	SHORT $LN29@CL_ParseTe
$LN28@CL_ParseTe:

; 2257 : 		else R_ParticleBox( pos, pos2, r, g, b, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvttss2si edx, DWORD PTR _b$[ebp]
	movzx	eax, dl
	push	eax
	cvttss2si ecx, DWORD PTR _g$[ebp]
	movzx	edx, cl
	push	edx
	cvttss2si eax, DWORD PTR _r$[ebp]
	movzx	ecx, al
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_ParticleBox
	add	esp, 24					; 00000018H
$LN29@CL_ParseTe:

; 2258 : 		break;

	jmp	$LN2@CL_ParseTe
$LN30@CL_ParseTe:

; 2259 : 	case TE_LARGEFUNNEL:
; 2260 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2261 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2262 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2263 : 		modelIndex = MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2264 : 		flags = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2265 : 		R_LargeFunnel( pos, flags );

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_LargeFunnel
	add	esp, 8

; 2266 : 		R_FunnelSprite( pos, modelIndex, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_FunnelSprite
	add	esp, 12					; 0000000cH

; 2267 : 		break;

	jmp	$LN2@CL_ParseTe
$LN31@CL_ParseTe:

; 2268 : 	case TE_BLOODSTREAM:
; 2269 : 	case TE_BLOOD:
; 2270 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2271 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2272 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2273 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2274 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2275 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2276 : 		color = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2277 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2278 : 		if( type == TE_BLOOD ) R_Blood( pos, pos2, color, count );

	cmp	DWORD PTR _type$[ebp], 103		; 00000067H
	jne	SHORT $LN32@CL_ParseTe
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_Blood
	add	esp, 16					; 00000010H
	jmp	SHORT $LN33@CL_ParseTe
$LN32@CL_ParseTe:

; 2279 : 		else R_BloodStream( pos, pos2, color, count );

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_BloodStream
	add	esp, 16					; 00000010H
$LN33@CL_ParseTe:

; 2280 : 		break;

	jmp	$LN2@CL_ParseTe
$LN34@CL_ParseTe:

; 2281 : 	case TE_SHOWLINE:
; 2282 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2283 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2284 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2285 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2286 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2287 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2288 : 		R_ShowLine( pos, pos2 );

	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_ShowLine
	add	esp, 8

; 2289 : 		break;

	jmp	$LN2@CL_ParseTe
$LN35@CL_ParseTe:

; 2290 : 	case TE_DECAL:
; 2291 : 	case TE_DECALHIGH:
; 2292 : 	case TE_WORLDDECAL:
; 2293 : 	case TE_WORLDDECALHIGH:
; 2294 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2295 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2296 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2297 : 		decalIndex = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2298 : 		if( type == TE_DECAL || type == TE_DECALHIGH )

	cmp	DWORD PTR _type$[ebp], 104		; 00000068H
	je	SHORT $LN38@CL_ParseTe
	cmp	DWORD PTR _type$[ebp], 118		; 00000076H
	jne	SHORT $LN36@CL_ParseTe
$LN38@CL_ParseTe:

; 2299 : 			entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax
	jmp	SHORT $LN37@CL_ParseTe
$LN36@CL_ParseTe:

; 2300 : 		else entityIndex = 0;

	mov	DWORD PTR _entityIndex$[ebp], 0
$LN37@CL_ParseTe:

; 2301 : 		if( type == TE_DECALHIGH || type == TE_WORLDDECALHIGH )

	cmp	DWORD PTR _type$[ebp], 118		; 00000076H
	je	SHORT $LN40@CL_ParseTe
	cmp	DWORD PTR _type$[ebp], 117		; 00000075H
	jne	SHORT $LN39@CL_ParseTe
$LN40@CL_ParseTe:

; 2302 : 			decalIndex += 256;

	mov	ecx, DWORD PTR _decalIndex$[ebp]
	add	ecx, 256				; 00000100H
	mov	DWORD PTR _decalIndex$[ebp], ecx
$LN39@CL_ParseTe:

; 2303 : 		pEnt = CL_GetEntityByIndex( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 2304 : 		if( pEnt ) modelIndex = pEnt->curstate.modelindex;

	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $LN41@CL_ParseTe
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	mov	DWORD PTR _modelIndex$[ebp], ecx
$LN41@CL_ParseTe:

; 2305 : 		CL_DecalShoot( CL_DecalIndex( decalIndex ), entityIndex, modelIndex, pos, 0 );

	push	0
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H

; 2306 : 		break;

	jmp	$LN2@CL_ParseTe
$LN42@CL_ParseTe:

; 2307 : 	case TE_FIZZ:
; 2308 : 		entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2309 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2310 : 		scale = MSG_ReadByte( &buf );	// same as density

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2311 : 		pEnt = CL_GetEntityByIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 2312 : 		R_FizzEffect( pEnt, modelIndex, scale );

	cvttss2si ecx, DWORD PTR _scale$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEnt$[ebp]
	push	eax
	call	_R_FizzEffect
	add	esp, 12					; 0000000cH

; 2313 : 		break;

	jmp	$LN2@CL_ParseTe
$LN43@CL_ParseTe:

; 2314 : 	case TE_MODEL:
; 2315 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2316 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2317 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2318 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2319 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2320 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2321 : 		ang[0] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2322 : 		ang[1] = MSG_ReadAngle( &buf ); // yaw angle

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _ang$[ebp+eax], xmm0

; 2323 : 		ang[2] = 0.0f;

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2324 : 		modelIndex = MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2325 : 		flags = MSG_ReadByte( &buf );	// sound flags

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2326 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2327 : 		R_TempModel( pos, pos2, ang, life, modelIndex, flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _ang$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_TempModel
	add	esp, 24					; 00000018H

; 2328 : 		break;

	jmp	$LN2@CL_ParseTe
$LN44@CL_ParseTe:

; 2329 : 	case TE_EXPLODEMODEL:
; 2330 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2331 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2332 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2333 : 		vel = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _vel$[ebp]

; 2334 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2335 : 		count = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2336 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2337 : 		R_TempSphereModel( pos, vel, life, count, modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_TempSphereModel
	add	esp, 20					; 00000014H

; 2338 : 		break;

	jmp	$LN2@CL_ParseTe
$LN45@CL_ParseTe:

; 2339 : 	case TE_BREAKMODEL:
; 2340 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2341 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2342 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2343 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2344 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2345 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2346 : 		ang[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _ang$[ebp+ecx]

; 2347 : 		ang[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _ang$[ebp+eax]

; 2348 : 		ang[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _ang$[ebp+edx]

; 2349 : 		random = (float)MSG_ReadByte( &buf ) * 10.0f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _random$[ebp], xmm0

; 2350 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2351 : 		count = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2352 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2353 : 		flags = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2354 : 		R_BreakModel( pos, pos2, ang, random, life, count, modelIndex, (char)flags );

	movzx	edx, BYTE PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _ang$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_BreakModel
	add	esp, 32					; 00000020H

; 2355 : 		break;

	jmp	$LN2@CL_ParseTe
$LN46@CL_ParseTe:

; 2356 : 	case TE_GUNSHOTDECAL:
; 2357 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2358 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2359 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2360 : 		entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2361 : 		decalIndex = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2362 : 		pEnt = CL_GetEntityByIndex( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 2363 : 		CL_DecalShoot( CL_DecalIndex( decalIndex ), entityIndex, 0, pos, 0 );

	push	0
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H

; 2364 : 		R_BulletImpactParticles( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BulletImpactParticles
	add	esp, 4

; 2365 : 		R_RicochetSound( pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_RicochetSound
	add	esp, 4

; 2366 : 		break;

	jmp	$LN2@CL_ParseTe
$LN47@CL_ParseTe:

; 2367 : 	case TE_SPRAY:
; 2368 : 	case TE_SPRITE_SPRAY:
; 2369 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2370 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2371 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2372 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2373 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2374 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2375 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2376 : 		count = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2377 : 		vel = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vel$[ebp], xmm0

; 2378 : 		random = (float)MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2379 : 		if( type == TE_SPRAY )

	cmp	DWORD PTR _type$[ebp], 120		; 00000078H
	jne	SHORT $LN48@CL_ParseTe

; 2380 : 		{
; 2381 : 			flags = MSG_ReadByte( &buf );	// rendermode

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2382 : 			R_Spray( pos, pos2, modelIndex, count, vel, random, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _random$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _vel$[ebp]
	push	edx
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_Spray
	add	esp, 28					; 0000001cH

; 2383 : 		}

	jmp	SHORT $LN49@CL_ParseTe
$LN48@CL_ParseTe:

; 2384 : 		else R_Sprite_Spray( pos, pos2, modelIndex, count, vel * 2.0f, random );

	cvttss2si ecx, DWORD PTR _random$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	cvttss2si edx, xmm0
	push	edx
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_Sprite_Spray
	add	esp, 24					; 00000018H
$LN49@CL_ParseTe:

; 2385 : 		break;

	jmp	$LN2@CL_ParseTe
$LN50@CL_ParseTe:

; 2386 : 	case TE_ARMOR_RICOCHET:
; 2387 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2388 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2389 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2390 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2391 : 		R_RicochetSprite( pos, cl_sprite_ricochet, 0.1f, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cl_sprite_ricochet
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_RicochetSprite
	add	esp, 16					; 00000010H

; 2392 : 		R_RicochetSound( pos );

	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_RicochetSound
	add	esp, 4

; 2393 : 		break;

	jmp	$LN2@CL_ParseTe
$LN51@CL_ParseTe:

; 2394 : 	case TE_PLAYERDECAL:
; 2395 : 		color = MSG_ReadByte( &buf ) - 1; // playernum

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _color$[ebp], eax

; 2396 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2397 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2398 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2399 : 		entityIndex = MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2400 : 		decalIndex = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2401 : 		CL_PlayerDecal( color, decalIndex, entityIndex, pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	call	_CL_PlayerDecal
	add	esp, 16					; 00000010H

; 2402 : 		break;

	jmp	$LN2@CL_ParseTe
$LN52@CL_ParseTe:

; 2403 : 	case TE_BUBBLES:
; 2404 : 	case TE_BUBBLETRAIL:
; 2405 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2406 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2407 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2408 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2409 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2410 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2411 : 		scale = MSG_ReadCoord( &buf );	// water height

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _scale$[ebp]

; 2412 : 		modelIndex = MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2413 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2414 : 		vel = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _vel$[ebp]

; 2415 : 		if( type == TE_BUBBLES ) R_Bubbles( pos, pos2, scale, modelIndex, count, vel );

	cmp	DWORD PTR _type$[ebp], 113		; 00000071H
	jne	SHORT $LN53@CL_ParseTe
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_Bubbles
	add	esp, 24					; 00000018H
	jmp	SHORT $LN54@CL_ParseTe
$LN53@CL_ParseTe:

; 2416 : 		else R_BubbleTrail( pos, pos2, scale, modelIndex, count, vel );

	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BubbleTrail
	add	esp, 24					; 00000018H
$LN54@CL_ParseTe:

; 2417 : 		break;

	jmp	$LN2@CL_ParseTe
$LN55@CL_ParseTe:

; 2418 : 	case TE_BLOODSPRITE:
; 2419 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2420 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2421 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2422 : 		modelIndex = MSG_ReadShort( &buf );	// sprite #1

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2423 : 		decalIndex = MSG_ReadShort( &buf );	// sprite #2

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2424 : 		color = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2425 : 		scale = (float)MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2426 : 		R_BloodSprite( pos, color, modelIndex, decalIndex, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BloodSprite
	add	esp, 20					; 00000014H

; 2427 : 		break;

	jmp	$LN2@CL_ParseTe
$LN56@CL_ParseTe:

; 2428 : 	case TE_PROJECTILE:
; 2429 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2430 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2431 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2432 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2433 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2434 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2435 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2436 : 		life = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _life$[ebp], xmm0

; 2437 : 		color = MSG_ReadByte( &buf );	// playernum

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2438 : 		R_Projectile( pos, pos2, modelIndex, life, color, NULL );

	push	0
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _life$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_Projectile
	add	esp, 24					; 00000018H

; 2439 : 		break;

	jmp	$LN2@CL_ParseTe
$LN57@CL_ParseTe:

; 2440 : 	case TE_PLAYERSPRITES:
; 2441 : 		color = MSG_ReadShort( &buf );	// entitynum

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2442 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2443 : 		count = MSG_ReadByte( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2444 : 		random = (float)MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2445 : 		R_PlayerSprites( color, modelIndex, count, random );

	cvttss2si eax, DWORD PTR _random$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_R_PlayerSprites
	add	esp, 16					; 00000010H

; 2446 : 		break;

	jmp	$LN2@CL_ParseTe
$LN58@CL_ParseTe:

; 2447 : 	case TE_PARTICLEBURST:
; 2448 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2449 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2450 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2451 : 		scale = (float)MSG_ReadShort( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2452 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2453 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2454 : 		R_ParticleBurst( pos, scale, color, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _scale$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_ParticleBurst
	add	esp, 16					; 00000010H

; 2455 : 		break;

	jmp	$LN2@CL_ParseTe
$LN59@CL_ParseTe:

; 2456 : 	case TE_FIREFIELD:
; 2457 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2458 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2459 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2460 : 		scale = (float)MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2461 : 		modelIndex = MSG_ReadShort( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2462 : 		count = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2463 : 		flags = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2464 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2465 : 		R_FireField( pos, scale, modelIndex, count, flags, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _scale$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_FireField
	add	esp, 24					; 00000018H

; 2466 : 		break;

	jmp	$LN2@CL_ParseTe
$LN60@CL_ParseTe:

; 2467 : 	case TE_PLAYERATTACHMENT:
; 2468 : 		color = MSG_ReadByte( &buf );	// playernum

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2469 : 		scale = MSG_ReadCoord( &buf );	// height

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _scale$[ebp]

; 2470 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2471 : 		life = (float)(MSG_ReadShort( &buf ) * 0.1f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2472 : 		R_AttachTentToPlayer( color, modelIndex, scale, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_R_AttachTentToPlayer
	add	esp, 16					; 00000010H

; 2473 : 		break;

	jmp	$LN2@CL_ParseTe
$LN61@CL_ParseTe:

; 2474 : 	case TE_KILLPLAYERATTACHMENTS:
; 2475 : 		color = MSG_ReadByte( &buf );	// playernum

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2476 : 		R_KillAttachedTents( color );

	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	call	_R_KillAttachedTents
	add	esp, 4

; 2477 : 		break;

	jmp	$LN2@CL_ParseTe
$LN62@CL_ParseTe:

; 2478 : 	case TE_MULTIGUNSHOT:
; 2479 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2480 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2481 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos$[ebp+eax]

; 2482 : 		pos2[0] = MSG_ReadCoord( &buf ) * 0.1f;

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2484[ebp]
	movss	xmm0, DWORD PTR tv2484[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _pos2$[ebp+eax], xmm0

; 2483 : 		pos2[1] = MSG_ReadCoord( &buf ) * 0.1f;

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2490[ebp]
	movss	xmm0, DWORD PTR tv2490[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _pos2$[ebp+edx], xmm0

; 2484 : 		pos2[2] = MSG_ReadCoord( &buf ) * 0.1f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2496[ebp]
	movss	xmm0, DWORD PTR tv2496[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _pos2$[ebp+ecx], xmm0

; 2485 : 		ang[0] = MSG_ReadCoord( &buf ) * 0.01f;

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2502[ebp]
	movss	xmm0, DWORD PTR tv2502[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2486 : 		ang[1] = MSG_ReadCoord( &buf ) * 0.01f;

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2508[ebp]
	movss	xmm0, DWORD PTR tv2508[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _ang$[ebp+eax], xmm0

; 2487 : 		ang[2] = 0.0f;

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2488 : 		count = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2489 : 		decalIndices[0] = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _decalIndices$[ebp+edx], eax

; 2490 : 		R_MultiGunshot( pos, pos2, ang, count, 1, decalIndices );

	lea	eax, DWORD PTR _decalIndices$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ang$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_MultiGunshot
	add	esp, 24					; 00000018H

; 2491 : 		break;

	jmp	$LN2@CL_ParseTe
$LN63@CL_ParseTe:

; 2492 : 	case TE_USERTRACER:
; 2493 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2494 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _pos$[ebp+eax]

; 2495 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	fstp	DWORD PTR _pos$[ebp+edx]

; 2496 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2497 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2498 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _pos2$[ebp+eax]

; 2499 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2500 : 		color = MSG_ReadByte( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2501 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2502 : 		R_UserTracerParticle( pos, pos2, life, color, scale, 0, NULL );

	push	0
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_UserTracerParticle
	add	esp, 28					; 0000001cH

; 2503 : 		break;

	jmp	SHORT $LN2@CL_ParseTe
$LN64@CL_ParseTe:

; 2504 : 	default:
; 2505 : 		Con_DPrintf( S_ERROR "ParseTempEntity: illegible TE message %i\n", type );

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	OFFSET $SG147019
	call	_Con_DPrintf
	add	esp, 8
$LN2@CL_ParseTe:

; 2506 : 		break;
; 2507 : 	}
; 2508 : 
; 2509 : 	// throw warning
; 2510 : 	if( MSG_CheckOverflow( &buf ))

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN65@CL_ParseTe

; 2511 : 		Con_DPrintf( S_WARN "ParseTempEntity: overflow TE message\n" );

	push	OFFSET $SG147021
	call	_Con_DPrintf
	add	esp, 4
$LN65@CL_ParseTe:

; 2512 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@CL_ParseTe:
	DD	$LN4@CL_ParseTe
	DD	$LN5@CL_ParseTe
	DD	$LN6@CL_ParseTe
	DD	$LN7@CL_ParseTe
	DD	$LN8@CL_ParseTe
	DD	$LN9@CL_ParseTe
	DD	$LN10@CL_ParseTe
	DD	$LN11@CL_ParseTe
	DD	$LN12@CL_ParseTe
	DD	$LN13@CL_ParseTe
	DD	$LN14@CL_ParseTe
	DD	$LN16@CL_ParseTe
	DD	$LN17@CL_ParseTe
	DD	$LN18@CL_ParseTe
	DD	$LN20@CL_ParseTe
	DD	$LN22@CL_ParseTe
	DD	$LN23@CL_ParseTe
	DD	$LN24@CL_ParseTe
	DD	$LN26@CL_ParseTe
	DD	$LN27@CL_ParseTe
	DD	$LN30@CL_ParseTe
	DD	$LN31@CL_ParseTe
	DD	$LN34@CL_ParseTe
	DD	$LN35@CL_ParseTe
	DD	$LN42@CL_ParseTe
	DD	$LN43@CL_ParseTe
	DD	$LN44@CL_ParseTe
	DD	$LN45@CL_ParseTe
	DD	$LN46@CL_ParseTe
	DD	$LN47@CL_ParseTe
	DD	$LN50@CL_ParseTe
	DD	$LN51@CL_ParseTe
	DD	$LN52@CL_ParseTe
	DD	$LN55@CL_ParseTe
	DD	$LN56@CL_ParseTe
	DD	$LN57@CL_ParseTe
	DD	$LN58@CL_ParseTe
	DD	$LN59@CL_ParseTe
	DD	$LN60@CL_ParseTe
	DD	$LN61@CL_ParseTe
	DD	$LN62@CL_ParseTe
	DD	$LN63@CL_ParseTe
	DD	$LN64@CL_ParseTe
$LN67@CL_ParseTe:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	0
	DB	0
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	0
	DB	13					; 0000000dH
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	14					; 0000000eH
	DB	0
	DB	15					; 0000000fH
	DB	0
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	0
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	21					; 00000015H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	34					; 00000022H
	DB	29					; 0000001dH
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
_CL_ParseTempEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
_time$ = -12						; size = 4
_i$ = -8						; size = 4
_dl$ = -4						; size = 4
_CL_DecayLights PROC

; 2690 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2691 : 	dlight_t	*dl;
; 2692 : 	float	time;
; 2693 : 	int	i;
; 2694 : 	
; 2695 : 	time = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR _cl+1525856
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _time$[ebp], xmm0

; 2696 : 
; 2697 : 	for( i = 0, dl = cl_dlights; i < MAX_DLIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@CL_DecayLi
$LN2@CL_DecayLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@CL_DecayLi:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_DecayLi

; 2698 : 	{
; 2699 : 		if( !dl->radius ) continue;

	mov	edx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_DecayLi
	jmp	SHORT $LN2@CL_DecayLi
$LN8@CL_DecayLi:

; 2700 : 
; 2701 : 		dl->radius -= time * dl->decay;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _time$[ebp]
	mulss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [edx+12], xmm1

; 2702 : 		if( dl->radius < 0 ) dl->radius = 0;

	mov	eax, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN9@CL_DecayLi
	mov	ecx, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+12], xmm0
$LN9@CL_DecayLi:

; 2703 : 
; 2704 : 		if( dl->die < cl.time || !dl->radius ) 

	mov	edx, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+20]
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	ja	SHORT $LN11@CL_DecayLi
	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_DecayLi
$LN11@CL_DecayLi:

; 2705 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	ecx, DWORD PTR _dl$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN10@CL_DecayLi:

; 2706 : 	}

	jmp	$LN2@CL_DecayLi
$LN3@CL_DecayLi:

; 2707 : 
; 2708 : 	for( i = 0, dl = cl_elights; i < MAX_ELIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN7@CL_DecayLi
$LN5@CL_DecayLi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _dl$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], eax
$LN7@CL_DecayLi:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN6@CL_DecayLi

; 2709 : 	{
; 2710 : 		if( !dl->radius ) continue;

	mov	ecx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@CL_DecayLi
	jmp	SHORT $LN5@CL_DecayLi
$LN12@CL_DecayLi:

; 2711 : 
; 2712 : 		dl->radius -= time * dl->decay;

	mov	edx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _time$[ebp]
	mulss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+12], xmm1

; 2713 : 		if( dl->radius < 0 ) dl->radius = 0;

	mov	edx, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN13@CL_DecayLi
	mov	eax, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+12], xmm0
$LN13@CL_DecayLi:

; 2714 : 
; 2715 : 		if( dl->die < cl.time || !dl->radius ) 

	mov	ecx, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+20]
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	ja	SHORT $LN15@CL_DecayLi
	mov	edx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_DecayLi
$LN15@CL_DecayLi:

; 2716 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN14@CL_DecayLi:

; 2717 : 	}

	jmp	$LN5@CL_DecayLi
$LN6@CL_DecayLi:

; 2718 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecayLights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_tent.c
_TEXT	SEGMENT
tv206 = -44						; size = 8
_val2$ = -36						; size = 4
_val1$ = -32						; size = 4
tv160 = -28						; size = 4
tv135 = -24						; size = 4
tv77 = -20						; size = 4
tv69 = -16						; size = 4
_k$ = -12						; size = 4
_i$ = -8						; size = 4
_ls$ = -4						; size = 4
_style$ = 8						; size = 4
_s$ = 12						; size = 4
_f$ = 16						; size = 4
_CL_SetLightstyle PROC

; 2535 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2536 : 	int		i, k;
; 2537 : 	lightstyle_t	*ls;
; 2538 : 	float		val1, val2;
; 2539 : 
; 2540 : 	Assert( s != NULL );

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN10@CL_SetLigh
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN11@CL_SetLigh
$LN10@CL_SetLigh:
	mov	DWORD PTR tv69[ebp], 0
$LN11@CL_SetLigh:
	push	0
	push	2540					; 000009ecH
	push	OFFSET $SG147048
	push	OFFSET $SG147049
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2541 : 	Assert( style >= 0 && style < MAX_LIGHTSTYLES );

	cmp	DWORD PTR _style$[ebp], 0
	jl	SHORT $LN12@CL_SetLigh
	cmp	DWORD PTR _style$[ebp], 64		; 00000040H
	jge	SHORT $LN12@CL_SetLigh
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN13@CL_SetLigh
$LN12@CL_SetLigh:
	mov	DWORD PTR tv77[ebp], 0
$LN13@CL_SetLigh:
	push	0
	push	2541					; 000009edH
	push	OFFSET $SG147050
	push	OFFSET $SG147051
	mov	ecx, DWORD PTR tv77[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2542 : 
; 2543 : 	ls = &cl.lightstyles[style];

	imul	edx, DWORD PTR _style$[ebp], 1296
	add	edx, OFFSET _cl+1852744
	mov	DWORD PTR _ls$[ebp], edx

; 2544 : 
; 2545 : 	Q_strncpy( ls->pattern, s, sizeof( ls->pattern ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ls$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2546 : 
; 2547 : 	ls->length = Q_strlen( s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _ls$[ebp]
	mov	DWORD PTR [ecx+1280], eax

; 2548 : 	ls->time = f; // set local time

	mov	edx, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [edx+1292], xmm0

; 2549 : 
; 2550 : 	for( i = 0; i < ls->length; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetLigh
$LN2@CL_SetLigh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetLigh:
	mov	ecx, DWORD PTR _ls$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+1280]
	jge	SHORT $LN3@CL_SetLigh

; 2551 : 		ls->map[i] = (float)(s[i] - 'a');

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 97					; 00000061H
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	DWORD PTR [eax+edx*4+256], xmm0
	jmp	SHORT $LN2@CL_SetLigh
$LN3@CL_SetLigh:

; 2552 : 
; 2553 : 	ls->interp = (ls->length <= 1) ? false : true;

	mov	ecx, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [ecx+1280], 1
	jg	SHORT $LN14@CL_SetLigh
	mov	DWORD PTR tv135[ebp], 0
	jmp	SHORT $LN15@CL_SetLigh
$LN14@CL_SetLigh:
	mov	DWORD PTR tv135[ebp], 1
$LN15@CL_SetLigh:
	mov	edx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR [edx+1288], eax

; 2554 : 
; 2555 : 	// check for allow interpolate
; 2556 : 	// NOTE: fast flickering styles looks ugly when interpolation is running
; 2557 : 	for( k = 0; k < (ls->length - 1); k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@CL_SetLigh
$LN5@CL_SetLigh:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN7@CL_SetLigh:
	mov	edx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR [edx+1280]
	sub	eax, 1
	cmp	DWORD PTR _k$[ebp], eax
	jge	$LN6@CL_SetLigh

; 2558 : 	{
; 2559 : 		val1 = ls->map[(k+0) % ls->length];

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+256]
	movss	DWORD PTR _val1$[ebp], xmm0

; 2560 : 		val2 = ls->map[(k+1) % ls->length];

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _ls$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+256]
	movss	DWORD PTR _val2$[ebp], xmm0

; 2561 : 
; 2562 : 		if( fabs( val1 - val2 ) > STYLE_LERPING_THRESHOLD )

	movss	xmm0, DWORD PTR _val1$[ebp]
	subss	xmm0, DWORD PTR _val2$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv206[ebp]
	movsd	xmm0, QWORD PTR tv206[ebp]
	comisd	xmm0, QWORD PTR __real@4008000000000000
	jbe	SHORT $LN8@CL_SetLigh

; 2563 : 		{
; 2564 : 			ls->interp = false;

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	DWORD PTR [ecx+1288], 0

; 2565 : 			break;

	jmp	SHORT $LN6@CL_SetLigh
$LN8@CL_SetLigh:

; 2566 : 		}
; 2567 : 	}

	jmp	$LN5@CL_SetLigh
$LN6@CL_SetLigh:

; 2568 : 
; 2569 : 	Con_Reportf( "Lightstyle %i (%s), interp %s\n", style, ls->pattern, ls->interp ? "Yes" : "No" );

	mov	edx, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [edx+1288], 0
	je	SHORT $LN16@CL_SetLigh
	mov	DWORD PTR tv160[ebp], OFFSET $SG147053
	jmp	SHORT $LN17@CL_SetLigh
$LN16@CL_SetLigh:
	mov	DWORD PTR tv160[ebp], OFFSET $SG147054
$LN17@CL_SetLigh:
	mov	eax, DWORD PTR tv160[ebp]
	push	eax
	mov	ecx, DWORD PTR _ls$[ebp]
	push	ecx
	mov	edx, DWORD PTR _style$[ebp]
	push	edx
	push	OFFSET $SG147055
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 2570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetLightstyle ENDP
_TEXT	ENDS
END
