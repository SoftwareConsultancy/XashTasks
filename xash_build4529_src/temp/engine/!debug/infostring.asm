; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\infostring.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Info_ValueForKey
PUBLIC	_Info_RemovePrefixedKeys
PUBLIC	_Info_RemoveKey
PUBLIC	_Info_SetValueForKey
PUBLIC	_Info_SetValueForStarKey
PUBLIC	_Info_IsValid
PUBLIC	_Info_WriteVars
PUBLIC	_Info_Print
PUBLIC	_Info_IsKeyImportant
PUBLIC	_Info_FindLargestKey
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_Userinfo:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?value@?1??Info_WriteVars@@9@9 DB 0800H DUP (?)		; `Info_WriteVars'::`2'::value
?valueindex@?1??Info_WriteVars@@9@9 DD 01H DUP (?)	; `Info_WriteVars'::`2'::valueindex
?value@?1??Info_ValueForKey@@9@9 DB 0200H DUP (?)	; `Info_ValueForKey'::`2'::value
?valueindex@?1??Info_ValueForKey@@9@9 DD 01H DUP (?)	; `Info_ValueForKey'::`2'::valueindex
$SG129831 DB	01H DUP (?)
	ALIGN	4

$SG129833 DB	01H DUP (?)
	ALIGN	4

$SG129836 DB	01H DUP (?)
	ALIGN	4

?largest_key@?1??Info_FindLargestKey@@9@9 DB 080H DUP (?) ; `Info_FindLargestKey'::`2'::largest_key
_BSS	ENDS
_DATA	SEGMENT
$SG129766 DB	'%s', 00H
	ORG $+1
$SG129768 DB	'(null)', 0aH, 00H
$SG129770 DB	'%s', 0aH, 00H
$SG129809 DB	'setinfo "%s" "%s"', 0aH, 00H
	ORG $+1
$SG129856 DB	'\', 00H
	ORG $+2
$SG129889 DB	'name', 00H
	ORG $+3
$SG129891 DB	'model', 00H
	ORG $+2
$SG129893 DB	'rate', 00H
	ORG $+3
$SG129895 DB	'topcolor', 00H
	ORG $+3
$SG129897 DB	'bottomcolor', 00H
$SG129899 DB	'cl_updaterate', 00H
	ORG $+2
$SG129901 DB	'cl_lw', 00H
	ORG $+2
$SG129903 DB	'cl_lc', 00H
	ORG $+2
$SG129905 DB	'cl_nopred', 00H
	ORG $+2
$SG129952 DB	'\', 00H
	ORG $+2
$SG129953 DB	'\', 00H
	ORG $+2
$SG129954 DB	'^1Error:^7 SetValueForKey: can''t use keys or values wit'
	DB	'h a \', 0aH, 00H
	ORG $+2
$SG129957 DB	'..', 00H
	ORG $+1
$SG129958 DB	'..', 00H
	ORG $+1
$SG129961 DB	'"', 00H
	ORG $+2
$SG129962 DB	'"', 00H
	ORG $+2
$SG129963 DB	'^1Error:^7 SetValueForKey: can''t use keys or values wit'
	DB	'h a "', 0aH, 00H
	ORG $+2
$SG129968 DB	'\%s\%s', 00H
	ORG $+1
$SG129974 DB	'team', 00H
	ORG $+3
$SG129987 DB	'^1Error:^7 Can''t set *keys', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_l$ = -284						; size = 4
_largest_size$ = -280					; size = 4
$T1 = -276						; size = 4
_size$2 = -272						; size = 4
_count$ = -268						; size = 4
_o$ = -264						; size = 4
_value$ = -260						; size = 128
_key$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_Info_FindLargestKey PROC

; 357  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 358  : 	char	key[MAX_KV_SIZE];
; 359  : 	char	value[MAX_KV_SIZE];
; 360  : 	static	char largest_key[128];
; 361  : 	int	largest_size = 0;

	mov	DWORD PTR _largest_size$[ebp], 0

; 362  : 	int	l, count;
; 363  : 	char	*o;
; 364  : 
; 365  : 	*largest_key = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 128			; 00000080H
	jae	SHORT $LN13@Info_FindL
	jmp	SHORT $LN14@Info_FindL
$LN13@Info_FindL:
	call	___report_rangecheckfailure
$LN14@Info_FindL:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?largest_key@?1??Info_FindLargestKey@@9@9[edx], 0

; 366  : 
; 367  : 	if( *s == '\\' ) s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@Info_FindL
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN2@Info_FindL:

; 368  : 
; 369  : 	while( *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Info_FindL

; 370  : 	{
; 371  : 		int	size = 0;

	mov	DWORD PTR _size$2[ebp], 0

; 372  : 
; 373  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 374  : 		o = key;

	lea	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN4@Info_FindL:

; 375  : 
; 376  : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN5@Info_FindL
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Info_FindL
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN5@Info_FindL

; 377  : 		{
; 378  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 379  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 380  : 		}

	jmp	SHORT $LN4@Info_FindL
$LN5@Info_FindL:

; 381  : 
; 382  : 		l = o - key;

	mov	ecx, DWORD PTR _o$[ebp]
	lea	edx, DWORD PTR _key$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _l$[ebp], ecx

; 383  : 		*o = 0;

	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 0

; 384  : 		size = Q_strlen( key );

	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _size$2[ebp], eax

; 385  : 
; 386  : 		if( !*s ) return largest_key;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@Info_FindL
	mov	eax, OFFSET ?largest_key@?1??Info_FindLargestKey@@9@9
	jmp	$LN12@Info_FindL
$LN9@Info_FindL:

; 387  : 
; 388  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 389  : 		o = value;

	lea	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _o$[ebp], ecx

; 390  : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN6@Info_FindL:

; 391  : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN7@Info_FindL
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@Info_FindL
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN7@Info_FindL

; 392  : 		{
; 393  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 394  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 395  : 		}

	jmp	SHORT $LN6@Info_FindL
$LN7@Info_FindL:

; 396  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 397  : 
; 398  : 		if( *s ) s++;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN10@Info_FindL
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN10@Info_FindL:

; 399  : 
; 400  : 		size += Q_strlen( value );

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, DWORD PTR _size$2[ebp]
	mov	DWORD PTR _size$2[ebp], eax

; 401  : 
; 402  : 		if(( size > largest_size ) && !Info_IsKeyImportant( key ))

	mov	eax, DWORD PTR _size$2[ebp]
	cmp	eax, DWORD PTR _largest_size$[ebp]
	jle	SHORT $LN11@Info_FindL
	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Info_IsKeyImportant
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@Info_FindL

; 403  : 		{
; 404  : 			Q_strncpy( largest_key, key, sizeof( largest_key ));

	push	128					; 00000080H
	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	push	OFFSET ?largest_key@?1??Info_FindLargestKey@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 405  : 			largest_size = size;

	mov	eax, DWORD PTR _size$2[ebp]
	mov	DWORD PTR _largest_size$[ebp], eax
$LN11@Info_FindL:

; 406  : 		}
; 407  : 	}

	jmp	$LN2@Info_FindL
$LN3@Info_FindL:

; 408  : 
; 409  : 	return largest_key;

	mov	eax, OFFSET ?largest_key@?1??Info_FindLargestKey@@9@9
$LN12@Info_FindL:

; 410  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_FindLargestKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_key$ = 8						; size = 4
_Info_IsKeyImportant PROC

; 332  : {

	push	ebp
	mov	ebp, esp

; 333  : 	if( key[0] == '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _key$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN2@Info_IsKey

; 334  : 		return true;

	mov	eax, 1
	jmp	$LN1@Info_IsKey
$LN2@Info_IsKey:

; 335  : 	if( !Q_strcmp( key, "name" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129889
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Info_IsKey

; 336  : 		return true;

	mov	eax, 1
	jmp	$LN1@Info_IsKey
$LN3@Info_IsKey:

; 337  : 	if( !Q_strcmp( key, "model" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129891
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@Info_IsKey

; 338  : 		return true;

	mov	eax, 1
	jmp	$LN1@Info_IsKey
$LN4@Info_IsKey:

; 339  : 	if( !Q_strcmp( key, "rate" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129893
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@Info_IsKey

; 340  : 		return true;

	mov	eax, 1
	jmp	$LN1@Info_IsKey
$LN5@Info_IsKey:

; 341  : 	if( !Q_strcmp( key, "topcolor" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129895
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@Info_IsKey

; 342  : 		return true;

	mov	eax, 1
	jmp	$LN1@Info_IsKey
$LN6@Info_IsKey:

; 343  : 	if( !Q_strcmp( key, "bottomcolor" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129897
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@Info_IsKey

; 344  : 		return true;

	mov	eax, 1
	jmp	$LN1@Info_IsKey
$LN7@Info_IsKey:

; 345  : 	if( !Q_strcmp( key, "cl_updaterate" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129899
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Info_IsKey

; 346  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Info_IsKey
$LN8@Info_IsKey:

; 347  : 	if( !Q_strcmp( key, "cl_lw" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129901
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Info_IsKey

; 348  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Info_IsKey
$LN9@Info_IsKey:

; 349  : 	if( !Q_strcmp( key, "cl_lc" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129903
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@Info_IsKey

; 350  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Info_IsKey
$LN10@Info_IsKey:

; 351  : 	if( !Q_strcmp( key, "cl_nopred" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129905
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Info_IsKey

; 352  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Info_IsKey
$LN11@Info_IsKey:

; 353  : 	return false;

	xor	eax, eax
$LN1@Info_IsKey:

; 354  : }

	pop	ebp
	ret	0
_Info_IsKeyImportant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
$T1 = -276						; size = 4
_l$ = -272						; size = 4
_count$ = -268						; size = 4
_o$ = -264						; size = 4
_value$ = -260						; size = 128
_key$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_Info_Print PROC

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 35   : 	char	key[MAX_KV_SIZE];
; 36   : 	char	value[MAX_KV_SIZE];
; 37   : 	int	l, count;
; 38   : 	char	*o;
; 39   : 
; 40   : 	if( *s == '\\' ) s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@Info_Print
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN2@Info_Print:

; 41   : 
; 42   : 	while( *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN13@Info_Print

; 43   : 	{
; 44   : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 45   : 		o = key;

	lea	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN4@Info_Print:

; 46   : 
; 47   : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN5@Info_Print
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Info_Print
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN5@Info_Print

; 48   : 		{
; 49   : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 50   : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 51   : 		}

	jmp	SHORT $LN4@Info_Print
$LN5@Info_Print:

; 52   : 
; 53   : 		l = o - key;

	mov	ecx, DWORD PTR _o$[ebp]
	lea	edx, DWORD PTR _key$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _l$[ebp], ecx

; 54   : 		if( l < 20 )

	cmp	DWORD PTR _l$[ebp], 20			; 00000014H
	jge	SHORT $LN9@Info_Print

; 55   : 		{
; 56   : 			memset( o, ' ', 20 - l );

	mov	eax, 20					; 00000014H
	sub	eax, DWORD PTR _l$[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _o$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 57   : 			key[20] = 0;

	mov	edx, 1
	imul	eax, edx, 20
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 128			; 00000080H
	jae	SHORT $LN14@Info_Print
	jmp	SHORT $LN15@Info_Print
$LN14@Info_Print:
	call	___report_rangecheckfailure
$LN15@Info_Print:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _key$[ebp+ecx], 0

; 58   : 		}

	jmp	SHORT $LN10@Info_Print
$LN9@Info_Print:

; 59   : 		else *o = 0;

	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx], 0
$LN10@Info_Print:

; 60   : 
; 61   : 		Con_Printf( "%s", key );

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET $SG129766
	call	_Con_Printf
	add	esp, 8

; 62   : 
; 63   : 		if( !*s )

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN11@Info_Print

; 64   : 		{
; 65   : 			Con_Printf( "(null)\n" );

	push	OFFSET $SG129768
	call	_Con_Printf
	add	esp, 4

; 66   : 			return;

	jmp	$LN13@Info_Print
$LN11@Info_Print:

; 67   : 		}
; 68   : 
; 69   : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 70   : 		o = value;

	lea	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _o$[ebp], eax

; 71   : 		s++;

	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN6@Info_Print:

; 72   : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN7@Info_Print
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN7@Info_Print
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN7@Info_Print

; 73   : 		{
; 74   : 			*o++ = *s++;

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 75   : 			count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 76   : 		}

	jmp	SHORT $LN6@Info_Print
$LN7@Info_Print:

; 77   : 		*o = 0;

	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 0

; 78   : 
; 79   : 		if( *s ) s++;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN12@Info_Print
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN12@Info_Print:

; 80   : 		Con_Printf( "%s\n", value );

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET $SG129770
	call	_Con_Printf
	add	esp, 8

; 81   : 	}

	jmp	$LN2@Info_Print
$LN13@Info_Print:

; 82   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_pcvar$ = -528						; size = 4
_o$ = -524						; size = 4
_s$ = -520						; size = 4
_pkey$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_Info_WriteVars PROC

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 141  : 	char	*s = CL_Userinfo();

	call	_CL_Userinfo
	mov	DWORD PTR _s$[ebp], eax

; 142  : 	char	pkey[MAX_SERVERINFO_STRING];
; 143  : 	static	char value[4][MAX_SERVERINFO_STRING]; // use two buffers so compares work without stomping on each other
; 144  : 	static	int valueindex;
; 145  : 	convar_t	*pcvar;
; 146  : 	char	*o;
; 147  : 
; 148  : 	valueindex = (valueindex + 1) % 4;

	mov	eax, DWORD PTR ?valueindex@?1??Info_WriteVars@@9@9
	add	eax, 1
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN14@Info_Write
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN14@Info_Write:
	mov	DWORD PTR ?valueindex@?1??Info_WriteVars@@9@9, eax

; 149  : 	if( *s == '\\' ) s++;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN2@Info_Write
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN2@Info_Write:

; 150  : 
; 151  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN1@Info_Write

; 152  : 	{
; 153  : 		o = pkey;

	lea	edx, DWORD PTR _pkey$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN4@Info_Write:

; 154  : 		while( *s != '\\' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@Info_Write

; 155  : 		{
; 156  : 			if( !*s ) return;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@Info_Write
	jmp	$LN1@Info_Write
$LN9@Info_Write:

; 157  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 158  : 		}

	jmp	SHORT $LN4@Info_Write
$LN5@Info_Write:

; 159  : 		*o = 0;

	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 0

; 160  : 		s++;

	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 161  : 
; 162  : 		o = value[valueindex];

	mov	edx, DWORD PTR ?valueindex@?1??Info_WriteVars@@9@9
	shl	edx, 9
	add	edx, OFFSET ?value@?1??Info_WriteVars@@9@9
	mov	DWORD PTR _o$[ebp], edx
$LN6@Info_Write:

; 163  : 
; 164  : 		while( *s != '\\' && *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN7@Info_Write
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN7@Info_Write

; 165  : 		{
; 166  : 			if( !*s ) return;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN10@Info_Write
	jmp	$LN1@Info_Write
$LN10@Info_Write:

; 167  : 			*o++ = *s++;

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 168  : 		}

	jmp	SHORT $LN6@Info_Write
$LN7@Info_Write:

; 169  : 		*o = 0;

	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx], 0

; 170  : 
; 171  : 		pcvar = Cvar_FindVar( pkey );

	push	0
	lea	eax, DWORD PTR _pkey$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _pcvar$[ebp], eax

; 172  : 
; 173  : 		if( !pcvar && pkey[0] != '*' )  // don't store out star keys

	cmp	DWORD PTR _pcvar$[ebp], 0
	jne	SHORT $LN11@Info_Write
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _pkey$[ebp+edx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN11@Info_Write

; 174  : 			FS_Printf( f, "setinfo \"%s\" \"%s\"\n", pkey, value[valueindex] );

	mov	ecx, DWORD PTR ?valueindex@?1??Info_WriteVars@@9@9
	shl	ecx, 9
	add	ecx, OFFSET ?value@?1??Info_WriteVars@@9@9
	push	ecx
	lea	edx, DWORD PTR _pkey$[ebp]
	push	edx
	push	OFFSET $SG129809
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN11@Info_Write:

; 175  : 
; 176  : 		if( !*s ) return;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN12@Info_Write
	jmp	SHORT $LN1@Info_Write
$LN12@Info_Write:

; 177  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 178  : 	}

	jmp	$LN2@Info_Write
$LN1@Info_Write:

; 179  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_WriteVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_count$ = -268						; size = 4
_o$ = -264						; size = 4
_key$ = -260						; size = 128
_value$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_Info_IsValid PROC

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 93   : 	char	key[MAX_KV_SIZE];
; 94   : 	char	value[MAX_KV_SIZE];
; 95   : 	int	count;
; 96   : 	char	*o;
; 97   : 
; 98   : 	if( *s == '\\' ) s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@Info_IsVal
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN2@Info_IsVal:

; 99   : 
; 100  : 	while( *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Info_IsVal

; 101  : 	{
; 102  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 103  : 		o = key;

	lea	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN4@Info_IsVal:

; 104  : 
; 105  : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN5@Info_IsVal
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Info_IsVal
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN5@Info_IsVal

; 106  : 		{
; 107  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 108  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 109  : 		}

	jmp	SHORT $LN4@Info_IsVal
$LN5@Info_IsVal:

; 110  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 111  : 
; 112  : 		if( !*s ) return false;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@Info_IsVal
	xor	eax, eax
	jmp	$LN1@Info_IsVal
$LN9@Info_IsVal:

; 113  : 
; 114  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 115  : 		o = value;

	lea	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _o$[ebp], ecx

; 116  : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN6@Info_IsVal:

; 117  : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN7@Info_IsVal
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@Info_IsVal
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN7@Info_IsVal

; 118  : 		{
; 119  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 120  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 121  : 		}

	jmp	SHORT $LN6@Info_IsVal
$LN7@Info_IsVal:

; 122  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 123  : 
; 124  : 		if( !Q_strlen( value ))

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@Info_IsVal

; 125  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Info_IsVal
$LN10@Info_IsVal:

; 126  : 
; 127  : 		if( *s ) s++;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN11@Info_IsVal
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN11@Info_IsVal:

; 128  : 	}

	jmp	$LN2@Info_IsVal
$LN3@Info_IsVal:

; 129  : 
; 130  : 	return true;

	mov	eax, 1
$LN1@Info_IsVal:

; 131  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_IsValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_team$ = -1048						; size = 4
tv172 = -1044						; size = 4
_largekey$1 = -1040					; size = 4
_c$ = -1036						; size = 4
_v$ = -1032						; size = 4
_new$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_maxsize$ = 20						; size = 4
_Info_SetValueForStarKey PROC

; 413  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1048				; 00000418H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 414  : 	char	new[1024], *v;
; 415  : 	int	c, team;
; 416  : 
; 417  : 	if( Q_strstr( key, "\\" ) || Q_strstr( value, "\\" ))

	push	OFFSET $SG129952
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@Info_SetVa
	push	OFFSET $SG129953
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@Info_SetVa
$LN8@Info_SetVa:

; 418  : 	{
; 419  : 		Con_Printf( S_ERROR "SetValueForKey: can't use keys or values with a \\\n" );

	push	OFFSET $SG129954
	call	_Con_Printf
	add	esp, 4

; 420  : 		return false;

	xor	eax, eax
	jmp	$LN1@Info_SetVa
$LN7@Info_SetVa:

; 421  : 	}
; 422  : 
; 423  : 	if( Q_strstr( key, ".." ) || Q_strstr( value, ".." ))

	push	OFFSET $SG129957
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@Info_SetVa
	push	OFFSET $SG129958
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@Info_SetVa
$LN10@Info_SetVa:

; 424  : 		return false;

	xor	eax, eax
	jmp	$LN1@Info_SetVa
$LN9@Info_SetVa:

; 425  : 
; 426  : 	if( Q_strstr( key, "\"" ) || Q_strstr( value, "\"" ))

	push	OFFSET $SG129961
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@Info_SetVa
	push	OFFSET $SG129962
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@Info_SetVa
$LN12@Info_SetVa:

; 427  : 	{
; 428  : 		Con_Printf( S_ERROR "SetValueForKey: can't use keys or values with a \"\n" );

	push	OFFSET $SG129963
	call	_Con_Printf
	add	esp, 4

; 429  : 		return false;

	xor	eax, eax
	jmp	$LN1@Info_SetVa
$LN11@Info_SetVa:

; 430  : 	}
; 431  : 
; 432  : 	if( Q_strlen( key ) > ( MAX_KV_SIZE - 1 ) || Q_strlen( value ) > ( MAX_KV_SIZE - 1 ))

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 127				; 0000007fH
	jg	SHORT $LN14@Info_SetVa
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN13@Info_SetVa
$LN14@Info_SetVa:

; 433  : 		return false;

	xor	eax, eax
	jmp	$LN1@Info_SetVa
$LN13@Info_SetVa:

; 434  : 
; 435  : 	Info_RemoveKey( s, key );

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_RemoveKey
	add	esp, 8

; 436  : 
; 437  : 	if( !value || !Q_strlen( value ))

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN16@Info_SetVa
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@Info_SetVa
$LN16@Info_SetVa:

; 438  : 		return true; // just clear variable

	mov	eax, 1
	jmp	$LN1@Info_SetVa
$LN15@Info_SetVa:

; 439  : 
; 440  : 	Q_snprintf( new, sizeof( new ), "\\%s\\%s", key, value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET $SG129968
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _new$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 441  : 	if( Q_strlen( new ) + Q_strlen( s ) > maxsize )

	lea	edx, DWORD PTR _new$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, DWORD PTR _maxsize$[ebp]
	jle	$LN17@Info_SetVa

; 442  : 	{
; 443  : 		// no more room in buffer to add key/value
; 444  : 		if( Info_IsKeyImportant( key ))

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Info_IsKeyImportant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@Info_SetVa
$LN4@Info_SetVa:

; 445  : 		{
; 446  : 			// keep removing the largest key/values until we have room
; 447  : 			char	*largekey;
; 448  : 
; 449  : 			do
; 450  : 			{
; 451  : 				largekey = Info_FindLargestKey( s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Info_FindLargestKey
	add	esp, 4
	mov	DWORD PTR _largekey$1[ebp], eax

; 452  : 				Info_RemoveKey( s, largekey );

	mov	eax, DWORD PTR _largekey$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_RemoveKey
	add	esp, 8

; 453  : 			} while((( Q_strlen( new ) + Q_strlen( s )) >= maxsize ) && *largekey != 0 );

	lea	edx, DWORD PTR _new$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	esi, eax
	cmp	esi, DWORD PTR _maxsize$[ebp]
	jl	SHORT $LN3@Info_SetVa
	mov	ecx, DWORD PTR _largekey$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN4@Info_SetVa
$LN3@Info_SetVa:

; 454  : 
; 455  : 			if( largekey[0] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _largekey$1[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN21@Info_SetVa

; 456  : 			{
; 457  : 				// no room to add setting
; 458  : 				return true; // info changed, new value can't saved

	mov	eax, 1
	jmp	$LN1@Info_SetVa
$LN21@Info_SetVa:

; 459  : 			}
; 460  : 		}

	jmp	SHORT $LN17@Info_SetVa
$LN18@Info_SetVa:

; 461  : 		else
; 462  : 		{
; 463  : 			// no room to add setting
; 464  : 			return true; // info changed, new value can't saved

	mov	eax, 1
	jmp	$LN1@Info_SetVa
$LN17@Info_SetVa:

; 465  : 		}
; 466  : 	}
; 467  : 
; 468  : 	// only copy ascii values
; 469  : 	s += Q_strlen( s );

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	add	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 470  : 	v = new;

	lea	edx, DWORD PTR _new$[ebp]
	mov	DWORD PTR _v$[ebp], edx

; 471  : 
; 472  : 	team = ( Q_stricmp( key, "team" ) == 0 ) ? true : false;

	push	99999					; 0001869fH
	push	OFFSET $SG129974
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@Info_SetVa
	mov	DWORD PTR tv172[ebp], 1
	jmp	SHORT $LN26@Info_SetVa
$LN25@Info_SetVa:
	mov	DWORD PTR tv172[ebp], 0
$LN26@Info_SetVa:
	mov	ecx, DWORD PTR tv172[ebp]
	mov	DWORD PTR _team$[ebp], ecx
$LN5@Info_SetVa:

; 473  : 
; 474  : 	while( *v )

	mov	edx, DWORD PTR _v$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@Info_SetVa

; 475  : 	{
; 476  : 		c = (byte)*v++;

	mov	ecx, DWORD PTR _v$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 1
	mov	DWORD PTR _v$[ebp], eax

; 477  : 		if( team ) c = Q_tolower( c );

	cmp	DWORD PTR _team$[ebp], 0
	je	SHORT $LN22@Info_SetVa
	movzx	ecx, BYTE PTR _c$[ebp]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR _c$[ebp], edx
$LN22@Info_SetVa:

; 478  : 		if( c > 13 ) *s++ = c;

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	jle	SHORT $LN23@Info_SetVa
	mov	eax, DWORD PTR _s$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN23@Info_SetVa:

; 479  : 	}

	jmp	SHORT $LN5@Info_SetVa
$LN6@Info_SetVa:

; 480  : 	*s = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	BYTE PTR [eax], 0

; 481  : 
; 482  : 	// all done
; 483  : 	return true;

	mov	eax, 1
$LN1@Info_SetVa:

; 484  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_SetValueForStarKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_maxsize$ = 20						; size = 4
_Info_SetValueForKey PROC

; 487  : {

	push	ebp
	mov	ebp, esp

; 488  : 	if( key[0] == '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _key$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN2@Info_SetVa

; 489  : 	{
; 490  : 		Con_Printf( S_ERROR "Can't set *keys\n" );

	push	OFFSET $SG129987
	call	_Con_Printf
	add	esp, 4

; 491  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Info_SetVa
$LN2@Info_SetVa:

; 492  : 	}
; 493  : 
; 494  : 	return Info_SetValueForStarKey( s, key, value, maxsize );

	mov	ecx, DWORD PTR _maxsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
$LN1@Info_SetVa:

; 495  : }

	pop	ebp
	ret	0
_Info_SetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_start$ = -276						; size = 4
_cmpsize$ = -272					; size = 4
_count$ = -268						; size = 4
_o$ = -264						; size = 4
_value$ = -260						; size = 128
_pkey$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_Info_RemoveKey PROC

; 234  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 235  : 	char	*start;
; 236  : 	char	pkey[MAX_KV_SIZE];
; 237  : 	char	value[MAX_KV_SIZE];
; 238  : 	int	cmpsize = Q_strlen( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _cmpsize$[ebp], eax

; 239  : 	int	count;
; 240  : 	char	*o;
; 241  : 
; 242  : 	if( cmpsize > ( MAX_KV_SIZE - 1 ))

	cmp	DWORD PTR _cmpsize$[ebp], 127		; 0000007fH
	jle	SHORT $LN8@Info_Remov

; 243  : 		cmpsize = MAX_KV_SIZE - 1;

	mov	DWORD PTR _cmpsize$[ebp], 127		; 0000007fH
$LN8@Info_Remov:

; 244  : 
; 245  : 	if( Q_strstr( key, "\\" ))

	push	OFFSET $SG129856
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@Info_Remov

; 246  : 		return false;

	xor	eax, eax
	jmp	$LN1@Info_Remov
$LN2@Info_Remov:

; 247  : 
; 248  : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN1@Info_Remov

; 249  : 	{
; 250  : 		start = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 251  : 		if( *s == '\\' ) s++;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN10@Info_Remov
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN10@Info_Remov:

; 252  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 253  : 		o = pkey;

	lea	ecx, DWORD PTR _pkey$[ebp]
	mov	DWORD PTR _o$[ebp], ecx
$LN4@Info_Remov:

; 254  : 
; 255  : 		while( count < (MAX_KV_SIZE - 1) && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN5@Info_Remov
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN5@Info_Remov

; 256  : 		{
; 257  : 			if( !*s ) return false;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN11@Info_Remov
	xor	eax, eax
	jmp	$LN1@Info_Remov
$LN11@Info_Remov:

; 258  : 			*o++ = *s++;

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 259  : 			count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 260  : 		}

	jmp	SHORT $LN4@Info_Remov
$LN5@Info_Remov:

; 261  : 		*o = 0;

	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 0

; 262  : 		s++;

	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 263  : 
; 264  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 265  : 		o = value;

	lea	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN6@Info_Remov:

; 266  : 
; 267  : 		while( count < (MAX_KV_SIZE - 1) && *s != '\\' && *s )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN7@Info_Remov
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN7@Info_Remov
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN7@Info_Remov

; 268  : 		{
; 269  : 			if( !*s ) return false;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN12@Info_Remov
	xor	eax, eax
	jmp	$LN1@Info_Remov
$LN12@Info_Remov:

; 270  : 			*o++ = *s++;

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 271  : 			count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 272  : 		}

	jmp	SHORT $LN6@Info_Remov
$LN7@Info_Remov:

; 273  : 		*o = 0;

	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 0

; 274  : 
; 275  : 		if( !Q_strncmp( key, pkey, cmpsize ))

	mov	ecx, DWORD PTR _cmpsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pkey$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@Info_Remov

; 276  : 		{
; 277  : 			Q_strcpy( start, s ); // remove this part

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 278  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Info_Remov
$LN13@Info_Remov:

; 279  : 		}
; 280  : 
; 281  : 		if( !*s ) return false;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN14@Info_Remov
	xor	eax, eax
	jmp	SHORT $LN1@Info_Remov
$LN14@Info_Remov:

; 282  : 	}

	jmp	$LN2@Info_Remov
$LN1@Info_Remov:

; 283  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_RemoveKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_count$ = -272						; size = 4
_o$ = -268						; size = 4
_s$ = -264						; size = 4
_value$ = -260						; size = 128
_pkey$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_start$ = 8						; size = 4
_prefix$ = 12						; size = 1
_Info_RemovePrefixedKeys PROC

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 287  : 	char	*s, *o;
; 288  : 	char	pkey[MAX_KV_SIZE];
; 289  : 	char	value[MAX_KV_SIZE];
; 290  : 	int	count;
; 291  : 
; 292  : 	s = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN2@Info_Remov:

; 293  : 
; 294  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN1@Info_Remov

; 295  : 	{
; 296  : 		if( *s == '\\' ) s++;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN8@Info_Remov
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN8@Info_Remov:

; 297  : 
; 298  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 299  : 		o = pkey;

	lea	edx, DWORD PTR _pkey$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN4@Info_Remov:

; 300  : 
; 301  : 		while( count < (MAX_KV_SIZE - 1) && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN5@Info_Remov
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@Info_Remov

; 302  : 		{
; 303  : 			if( !*s ) return;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@Info_Remov
	jmp	$LN1@Info_Remov
$LN9@Info_Remov:

; 304  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 305  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 306  : 		}

	jmp	SHORT $LN4@Info_Remov
$LN5@Info_Remov:

; 307  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 308  : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 309  : 
; 310  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 311  : 		o = value;

	lea	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _o$[ebp], eax
$LN6@Info_Remov:

; 312  : 
; 313  : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN7@Info_Remov
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN7@Info_Remov
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN7@Info_Remov

; 314  : 		{
; 315  : 			if( !*s ) return;

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN10@Info_Remov
	jmp	$LN1@Info_Remov
$LN10@Info_Remov:

; 316  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 317  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 318  : 		}

	jmp	SHORT $LN6@Info_Remov
$LN7@Info_Remov:

; 319  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 320  : 
; 321  : 		if( pkey[0] == prefix )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _pkey$[ebp+eax]
	movsx	edx, BYTE PTR _prefix$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN11@Info_Remov

; 322  : 		{
; 323  : 			Info_RemoveKey( start, pkey );

	lea	eax, DWORD PTR _pkey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_Info_RemoveKey
	add	esp, 8

; 324  : 			s = start;

	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _s$[ebp], edx
$LN11@Info_Remov:

; 325  : 		}
; 326  : 
; 327  : 		if( !*s ) return;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@Info_Remov
	jmp	SHORT $LN1@Info_Remov
$LN12@Info_Remov:

; 328  : 	}

	jmp	$LN2@Info_Remov
$LN1@Info_Remov:

; 329  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_RemovePrefixedKeys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\infostring.c
_TEXT	SEGMENT
_count$ = -140						; size = 4
_o$ = -136						; size = 4
_pkey$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_Info_ValueForKey PROC

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 191  : 	char	pkey[MAX_KV_SIZE];
; 192  : 	static	char value[4][MAX_KV_SIZE]; // use two buffers so compares work without stomping on each other
; 193  : 	static	int valueindex;
; 194  : 	int	count;
; 195  : 	char	*o;
; 196  : 	
; 197  : 	valueindex = (valueindex + 1) % 4;

	mov	eax, DWORD PTR ?valueindex@?1??Info_ValueForKey@@9@9
	add	eax, 1
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN14@Info_Value
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN14@Info_Value:
	mov	DWORD PTR ?valueindex@?1??Info_ValueForKey@@9@9, eax

; 198  : 	if( *s == '\\' ) s++;

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN2@Info_Value
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN2@Info_Value:

; 199  : 
; 200  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN1@Info_Value

; 201  : 	{
; 202  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 203  : 		o = pkey;

	lea	edx, DWORD PTR _pkey$[ebp]
	mov	DWORD PTR _o$[ebp], edx
$LN4@Info_Value:

; 204  : 
; 205  : 		while( count < (MAX_KV_SIZE - 1) && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN5@Info_Value
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@Info_Value

; 206  : 		{
; 207  : 			if( !*s ) return "";

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@Info_Value
	mov	eax, OFFSET $SG129831
	jmp	$LN1@Info_Value
$LN9@Info_Value:

; 208  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 209  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 210  : 		}

	jmp	SHORT $LN4@Info_Value
$LN5@Info_Value:

; 211  : 
; 212  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 213  : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 214  : 
; 215  : 		o = value[valueindex];

	mov	eax, DWORD PTR ?valueindex@?1??Info_ValueForKey@@9@9
	shl	eax, 7
	add	eax, OFFSET ?value@?1??Info_ValueForKey@@9@9
	mov	DWORD PTR _o$[ebp], eax

; 216  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0
$LN6@Info_Value:

; 217  : 
; 218  : 		while( count < (MAX_KV_SIZE - 1) && *s && *s != '\\' )

	cmp	DWORD PTR _count$[ebp], 127		; 0000007fH
	jge	SHORT $LN7@Info_Value
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN7@Info_Value
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN7@Info_Value

; 219  : 		{
; 220  : 			if( !*s ) return "";

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN10@Info_Value
	mov	eax, OFFSET $SG129833
	jmp	$LN1@Info_Value
$LN10@Info_Value:

; 221  : 			*o++ = *s++;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 222  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 223  : 		}

	jmp	SHORT $LN6@Info_Value
$LN7@Info_Value:

; 224  : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 225  : 
; 226  : 		if( !Q_strcmp( key, pkey ))

	push	99999					; 0001869fH
	lea	edx, DWORD PTR _pkey$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Info_Value

; 227  : 			return value[valueindex];

	mov	eax, DWORD PTR ?valueindex@?1??Info_ValueForKey@@9@9
	shl	eax, 7
	add	eax, OFFSET ?value@?1??Info_ValueForKey@@9@9
	jmp	SHORT $LN1@Info_Value
$LN11@Info_Value:

; 228  : 		if( !*s ) return "";

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN12@Info_Value
	mov	eax, OFFSET $SG129836
	jmp	SHORT $LN1@Info_Value
$LN12@Info_Value:

; 229  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 230  : 	}

	jmp	$LN2@Info_Value
$LN1@Info_Value:

; 231  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Info_ValueForKey ENDP
_TEXT	ENDS
END
