; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_sound:BYTE:034H
_DATA	ENDS
PUBLIC	_FS_LoadSound
PUBLIC	_FS_FreeSound
PUBLIC	_FS_OpenStream
PUBLIC	_FS_StreamInfo
PUBLIC	_FS_ReadStream
PUBLIC	_FS_SetStreamPos
PUBLIC	_FS_GetStreamPos
PUBLIC	_FS_FreeStream
PUBLIC	_Sound_Reset
PUBLIC	_SoundPack
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
$SG129927 DB	01H DUP (?)
	ALIGN	4

$SG129932 DB	01H DUP (?)
	ALIGN	4

$SG129969 DB	01H DUP (?)
	ALIGN	4

$SG129973 DB	01H DUP (?)
	ALIGN	4

?info@?1??FS_StreamInfo@@9@9 DB 01cH DUP (?)		; `FS_StreamInfo'::`2'::info
_BSS	ENDS
_DATA	SEGMENT
$SG129900 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_main.c', 00H
	ORG $+3
$SG129936 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_main.c', 00H
	ORG $+3
$SG129937 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_main.c', 00H
	ORG $+3
$SG129943 DB	'^3Warning:^7 FS_LoadSound: couldn''t load "%s"', 0aH, 00H
	ORG $+1
$SG129949 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_main.c', 00H
	ORG $+3
$SG129950 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\soundlib\snd_main.c', 00H
	ORG $+3
$SG129975 DB	'FS_OpenStream: couldn''t open "%s"', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_pack$ = -4						; size = 4
_SoundPack PROC

; 34   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 35   : 	wavdata_t	*pack = Mem_Calloc( host.soundpool, sizeof( wavdata_t ));

	push	35					; 00000023H
	push	OFFSET $SG129900
	push	1
	push	28					; 0000001cH
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pack$[ebp], eax

; 36   : 
; 37   : 	pack->buffer = sound.wav;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR _sound+40
	mov	DWORD PTR [ecx+20], edx

; 38   : 	pack->width = sound.width;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _sound+16
	mov	BYTE PTR [eax+2], cl

; 39   : 	pack->rate = sound.rate;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	ax, WORD PTR _sound+12
	mov	WORD PTR [edx], ax

; 40   : 	pack->type = sound.type;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR _sound+8
	mov	DWORD PTR [ecx+12], edx

; 41   : 	pack->size = sound.size;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+36
	mov	DWORD PTR [eax+24], ecx

; 42   : 	pack->loopStart = sound.loopstart;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR _sound+24
	mov	DWORD PTR [edx+4], eax

; 43   : 	pack->samples = sound.samples;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR _sound+28
	mov	DWORD PTR [ecx+8], edx

; 44   : 	pack->channels = sound.channels;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _sound+20
	mov	BYTE PTR [eax+3], cl

; 45   : 	pack->flags = sound.flags;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR _sound+32
	mov	DWORD PTR [edx+16], eax

; 46   : 
; 47   : 	return pack;

	mov	eax, DWORD PTR _pack$[ebp]

; 48   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SoundPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_Sound_Reset PROC

; 22   : {

	push	ebp
	mov	ebp, esp

; 23   : 	// reset global variables
; 24   : 	sound.width = sound.rate = 0;

	mov	DWORD PTR _sound+12, 0
	mov	eax, DWORD PTR _sound+12
	mov	DWORD PTR _sound+16, eax

; 25   : 	sound.channels = sound.loopstart = 0;

	mov	DWORD PTR _sound+24, 0
	mov	ecx, DWORD PTR _sound+24
	mov	DWORD PTR _sound+20, ecx

; 26   : 	sound.samples = sound.flags = 0;

	mov	DWORD PTR _sound+32, 0
	mov	edx, DWORD PTR _sound+32
	mov	DWORD PTR _sound+28, edx

; 27   : 	sound.type = WF_UNKNOWN;

	mov	DWORD PTR _sound+8, 0

; 28   : 
; 29   : 	sound.wav = NULL;

	mov	DWORD PTR _sound+40, 0

; 30   : 	sound.size = 0;

	mov	DWORD PTR _sound+36, 0

; 31   : }

	pop	ebp
	ret	0
_Sound_Reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_FS_FreeStream PROC

; 275  : {

	push	ebp
	mov	ebp, esp

; 276  : 	if( !stream || !stream->format || !stream->format->freefunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_FreeStr
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_FreeStr
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN2@FS_FreeStr
$LN3@FS_FreeStr:

; 277  : 		return;

	jmp	SHORT $LN1@FS_FreeStr
$LN2@FS_FreeStr:

; 278  : 
; 279  : 	stream->format->freefunc( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	add	esp, 4
$LN1@FS_FreeStr:

; 280  : }

	pop	ebp
	ret	0
_FS_FreeStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_FS_GetStreamPos PROC

; 245  : {

	push	ebp
	mov	ebp, esp

; 246  : 	if( !stream || !stream->format || !stream->format->getposfunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_GetStre
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_GetStre
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN2@FS_GetStre
$LN3@FS_GetStre:

; 247  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_GetStre
$LN2@FS_GetStre:

; 248  : 
; 249  : 	return stream->format->getposfunc( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	add	esp, 4
$LN1@FS_GetStre:

; 250  : }

	pop	ebp
	ret	0
_FS_GetStreamPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_newpos$ = 12						; size = 4
_FS_SetStreamPos PROC

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  : 	if( !stream || !stream->format || !stream->format->setposfunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_SetStre
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_SetStre
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN2@FS_SetStre
$LN3@FS_SetStre:

; 262  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_SetStre
$LN2@FS_SetStre:

; 263  : 
; 264  : 	return stream->format->setposfunc( stream, newpos );

	mov	eax, DWORD PTR _newpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	add	esp, 8
$LN1@FS_SetStre:

; 265  : }

	pop	ebp
	ret	0
_FS_SetStreamPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_bytes$ = 12						; size = 4
_buffer$ = 16						; size = 4
_FS_ReadStream PROC

; 227  : {

	push	ebp
	mov	ebp, esp

; 228  : 	if( !stream || !stream->format || !stream->format->readfunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_ReadStr
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_ReadStr
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN2@FS_ReadStr
$LN3@FS_ReadStr:

; 229  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FS_ReadStr
$LN2@FS_ReadStr:

; 230  : 
; 231  : 	if( bytes <= 0 || buffer == NULL )

	cmp	DWORD PTR _bytes$[ebp], 0
	jle	SHORT $LN5@FS_ReadStr
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN4@FS_ReadStr
$LN5@FS_ReadStr:

; 232  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FS_ReadStr
$LN4@FS_ReadStr:

; 233  : 
; 234  : 	return stream->format->readfunc( stream, bytes, buffer );

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	add	esp, 12					; 0000000cH
$LN1@FS_ReadStr:

; 235  : }

	pop	ebp
	ret	0
_FS_ReadStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_FS_StreamInfo PROC

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  : 	static wavdata_t	info;
; 202  : 
; 203  : 	if( !stream ) return NULL;

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN2@FS_StreamI
	xor	eax, eax
	jmp	SHORT $LN1@FS_StreamI
$LN2@FS_StreamI:

; 204  : 
; 205  : 	// fill structure
; 206  : 	info.loopStart = -1;

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+4, -1

; 207  : 	info.rate = stream->rate;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	cx, WORD PTR [eax+12]
	mov	WORD PTR ?info@?1??FS_StreamInfo@@9@9, cx

; 208  : 	info.width = stream->width;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	al, BYTE PTR [edx+8]
	mov	BYTE PTR ?info@?1??FS_StreamInfo@@9@9+2, al

; 209  : 	info.channels = stream->channels;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR ?info@?1??FS_StreamInfo@@9@9+3, dl

; 210  : 	info.flags = SOUND_STREAM; 

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+16, 2

; 211  : 	info.size = stream->size;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+24, ecx

; 212  : 	info.buffer = NULL;

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+20, 0

; 213  : 	info.samples = 0;	// not actual for streams

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+8, 0

; 214  : 	info.type = stream->type;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+12, eax

; 215  : 
; 216  : 	return &info;

	mov	eax, OFFSET ?info@?1??FS_StreamInfo@@9@9
$LN1@FS_StreamI:

; 217  : }

	pop	ebp
	ret	0
_FS_StreamInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_anyformat$ = -532					; size = 4
_stream$ = -528						; size = 4
_ext$ = -524						; size = 4
_format$ = -520						; size = 4
_path$ = -516						; size = 256
_loadname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_FS_OpenStream PROC

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 532				; 00000214H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 149  : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 150  : 	string		path, loadname;
; 151  : 	qboolean		anyformat = true;

	mov	DWORD PTR _anyformat$[ebp], 1

; 152  : 	const streamfmt_t	*format;
; 153  : 	stream_t		*stream;
; 154  : 
; 155  : 	Sound_Reset(); // clear old streaminfo

	call	_Sound_Reset

; 156  : 	Q_strncpy( loadname, filename, sizeof( loadname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 157  : 
; 158  : 	if( Q_stricmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129969
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@FS_OpenStr

; 159  : 	{
; 160  : 		// we needs to compare file extension with list of supported formats
; 161  : 		// and be sure what is real extension, not a filename with dot
; 162  : 		for( format = sound.streamformat; format && format->formatstring; format++ )

	mov	ecx, DWORD PTR _sound+4
	mov	DWORD PTR _format$[ebp], ecx
	jmp	SHORT $LN4@FS_OpenStr
$LN2@FS_OpenStr:
	mov	edx, DWORD PTR _format$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR _format$[ebp], edx
$LN4@FS_OpenStr:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN8@FS_OpenStr
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@FS_OpenStr

; 163  : 		{
; 164  : 			if( !Q_stricmp( format->ext, ext ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@FS_OpenStr

; 165  : 			{
; 166  : 				COM_StripExtension( loadname );

	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	call	_COM_StripExtension
	add	esp, 4

; 167  : 				anyformat = false;

	mov	DWORD PTR _anyformat$[ebp], 0

; 168  : 				break;

	jmp	SHORT $LN8@FS_OpenStr
$LN9@FS_OpenStr:

; 169  : 			}
; 170  : 		}

	jmp	SHORT $LN2@FS_OpenStr
$LN8@FS_OpenStr:

; 171  : 	}
; 172  : 
; 173  : 	// now try all the formats in the selected list
; 174  : 	for( format = sound.streamformat; format && format->formatstring; format++)

	mov	edx, DWORD PTR _sound+4
	mov	DWORD PTR _format$[ebp], edx
	jmp	SHORT $LN7@FS_OpenStr
$LN5@FS_OpenStr:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _format$[ebp], eax
$LN7@FS_OpenStr:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN6@FS_OpenStr
	mov	ecx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN6@FS_OpenStr

; 175  : 	{
; 176  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN11@FS_OpenStr
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@FS_OpenStr
$LN11@FS_OpenStr:

; 177  : 		{
; 178  : 			Q_sprintf( path, format->formatstring, loadname, "", format->ext );

	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET $SG129973
	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 179  : 			if(( stream = format->openfunc( path )) != NULL )

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _stream$[ebp], eax
	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN10@FS_OpenStr

; 180  : 			{
; 181  : 				stream->format = format;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _format$[ebp]
	mov	DWORD PTR [edx], eax

; 182  : 				return stream; // done

	mov	eax, DWORD PTR _stream$[ebp]
	jmp	SHORT $LN1@FS_OpenStr
$LN10@FS_OpenStr:

; 183  : 			}
; 184  : 		}
; 185  : 	}

	jmp	$LN5@FS_OpenStr
$LN6@FS_OpenStr:

; 186  : 
; 187  : 	Con_Reportf( "FS_OpenStream: couldn't open \"%s\"\n", loadname );

	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	push	OFFSET $SG129975
	call	_Con_Reportf
	add	esp, 8

; 188  : 
; 189  : 	return NULL;

	xor	eax, eax
$LN1@FS_OpenStr:

; 190  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_OpenStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_pack$ = 8						; size = 4
_FS_FreeSound PROC

; 134  : {

	push	ebp
	mov	ebp, esp

; 135  : 	if( !pack ) return;

	cmp	DWORD PTR _pack$[ebp], 0
	jne	SHORT $LN2@FS_FreeSou
	jmp	SHORT $LN1@FS_FreeSou
$LN2@FS_FreeSou:

; 136  : 	if( pack->buffer ) Mem_Free( pack->buffer );

	mov	eax, DWORD PTR _pack$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@FS_FreeSou
	push	136					; 00000088H
	push	OFFSET $SG129949
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@FS_FreeSou:

; 137  : 	Mem_Free( pack );

	push	137					; 00000089H
	push	OFFSET $SG129950
	mov	eax, DWORD PTR _pack$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@FS_FreeSou:

; 138  : }

	pop	ebp
	ret	0
_FS_FreeSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\soundlib\snd_main.c
_TEXT	SEGMENT
_anyformat$ = -536					; size = 4
_filesize$ = -532					; size = 4
_ext$ = -528						; size = 4
_f$ = -524						; size = 4
_format$ = -520						; size = 4
_path$ = -516						; size = 256
_loadname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_FS_LoadSound PROC

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 59   : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 60   : 	string		path, loadname;
; 61   : 	qboolean		anyformat = true;

	mov	DWORD PTR _anyformat$[ebp], 1

; 62   : 	int		filesize = 0;

	mov	DWORD PTR _filesize$[ebp], 0

; 63   : 	const loadwavfmt_t	*format;
; 64   : 	byte		*f;
; 65   : 
; 66   : 	Sound_Reset(); // clear old sounddata

	call	_Sound_Reset

; 67   : 	Q_strncpy( loadname, filename, sizeof( loadname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 68   : 
; 69   : 	if( Q_stricmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET $SG129927
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@FS_LoadSou

; 70   : 	{
; 71   : 		// we needs to compare file extension with list of supported formats
; 72   : 		// and be sure what is real extension, not a filename with dot
; 73   : 		for( format = sound.loadformats; format && format->formatstring; format++ )

	mov	ecx, DWORD PTR _sound
	mov	DWORD PTR _format$[ebp], ecx
	jmp	SHORT $LN4@FS_LoadSou
$LN2@FS_LoadSou:
	mov	edx, DWORD PTR _format$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], edx
$LN4@FS_LoadSou:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN11@FS_LoadSou
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@FS_LoadSou

; 74   : 		{
; 75   : 			if( !Q_stricmp( format->ext, ext ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@FS_LoadSou

; 76   : 			{
; 77   : 				COM_StripExtension( loadname );

	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	call	_COM_StripExtension
	add	esp, 4

; 78   : 				anyformat = false;

	mov	DWORD PTR _anyformat$[ebp], 0

; 79   : 				break;

	jmp	SHORT $LN11@FS_LoadSou
$LN12@FS_LoadSou:

; 80   : 			}
; 81   : 		}

	jmp	SHORT $LN2@FS_LoadSou
$LN11@FS_LoadSou:

; 82   : 	}
; 83   : 
; 84   : 	// special mode: skip any checks, load file from buffer
; 85   : 	if( filename[0] == '#' && buffer && size )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	SHORT $LN13@FS_LoadSou
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN13@FS_LoadSou
	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN13@FS_LoadSou

; 86   : 		goto load_internal;

	jmp	$load_internal$25
$LN13@FS_LoadSou:

; 87   : 
; 88   : 	// now try all the formats in the selected list
; 89   : 	for( format = sound.loadformats; format && format->formatstring; format++)

	mov	eax, DWORD PTR _sound
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN7@FS_LoadSou
$LN5@FS_LoadSou:
	mov	ecx, DWORD PTR _format$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], ecx
$LN7@FS_LoadSou:
	cmp	DWORD PTR _format$[ebp], 0
	je	$load_internal$25
	mov	edx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$load_internal$25

; 90   : 	{
; 91   : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN15@FS_LoadSou
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN14@FS_LoadSou
$LN15@FS_LoadSou:

; 92   : 		{
; 93   : 			Q_sprintf( path, format->formatstring, loadname, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET $SG129932
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 94   : 			f = FS_LoadFile( path, &filesize, false );

	push	0
	lea	eax, DWORD PTR _filesize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 95   : 			if( f && filesize > 0 )

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN14@FS_LoadSou
	cmp	DWORD PTR _filesize$[ebp], 0
	jle	SHORT $LN14@FS_LoadSou

; 96   : 			{
; 97   : 				if( format->loadfunc( path, f, filesize ))

	mov	edx, DWORD PTR _filesize$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@FS_LoadSou

; 98   : 				{
; 99   : 					Mem_Free(f); // release buffer

	push	99					; 00000063H
	push	OFFSET $SG129936
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 100  : 					return SoundPack(); // loaded

	call	_SoundPack
	jmp	$LN1@FS_LoadSou

; 101  : 				}

	jmp	SHORT $LN14@FS_LoadSou
$LN17@FS_LoadSou:

; 102  : 				else Mem_Free(f); // release buffer 

	push	102					; 00000066H
	push	OFFSET $SG129937
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN14@FS_LoadSou:

; 103  : 			}
; 104  : 		}
; 105  : 	}

	jmp	$LN5@FS_LoadSou
$load_internal$25:

; 106  : 
; 107  : load_internal:
; 108  : 	for( format = sound.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _sound
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN10@FS_LoadSou
$LN8@FS_LoadSou:
	mov	ecx, DWORD PTR _format$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], ecx
$LN10@FS_LoadSou:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN9@FS_LoadSou
	mov	edx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN9@FS_LoadSou

; 109  : 	{
; 110  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN20@FS_LoadSou
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@FS_LoadSou
$LN20@FS_LoadSou:

; 111  : 		{
; 112  : 			if( buffer && size > 0  )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN19@FS_LoadSou
	cmp	DWORD PTR _size$[ebp], 0
	jbe	SHORT $LN19@FS_LoadSou

; 113  : 			{
; 114  : 				if( format->loadfunc( loadname, buffer, size ))

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@FS_LoadSou

; 115  : 					return SoundPack(); // loaded

	call	_SoundPack
	jmp	SHORT $LN1@FS_LoadSou
$LN19@FS_LoadSou:

; 116  : 			}
; 117  : 		}
; 118  : 	}

	jmp	$LN8@FS_LoadSou
$LN9@FS_LoadSou:

; 119  : 
; 120  : 	if( filename[0] != '#' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN23@FS_LoadSou

; 121  : 		Con_DPrintf( S_WARN "FS_LoadSound: couldn't load \"%s\"\n", loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	push	OFFSET $SG129943
	call	_Con_DPrintf
	add	esp, 8
$LN23@FS_LoadSou:

; 122  : 
; 123  : 	return NULL;

	xor	eax, eax
$LN1@FS_LoadSou:

; 124  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadSound ENDP
_TEXT	ENDS
END
