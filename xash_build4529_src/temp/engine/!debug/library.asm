; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\library.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_COM_LoadLibrary
PUBLIC	_COM_GetProcAddress
PUBLIC	_COM_NameForFunction
PUBLIC	_COM_FunctionFromName
PUBLIC	_COM_FreeLibrary
PUBLIC	_MemoryLoadLibrary
PUBLIC	_GetMSVCName
PUBLIC	_LibraryLoadSymbols
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualProtect@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__IsBadReadPtr@8:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_Getc:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_FS_FindLibrary:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?out_name@?1??GetMSVCName@@9@9 DB 0100H DUP (?)		; `GetMSVCName'::`2'::out_name
_BSS	ENDS
_DATA	SEGMENT
_ProtectionFlags DD 01H
	DD	08H
	DD	02H
	DD	04H
	DD	010H
	DD	080H
	DD	020H
	DD	040H
$SG129997 DB	'error protecting memory page', 0aH, 00H
	ORG $+2
$SG130037 DB	'^1Error:^7 PerformBaseRelocation: unknown relocation: %d'
	DB	0aH, 00H
	ORG $+2
$SG130123 DB	'^1Error:^7 couldn''t load library %s', 0aH, 00H
	ORG $+3
$SG130130 DB	'^1Error:^7 %s unable to find address: %s', 0aH, 00H
	ORG $+2
$SG130124 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130197 DB	'couldn''t load %s', 00H
	ORG $+3
$SG130154 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130199 DB	'%s it''s not a valid executable file', 00H
$SG130201 DB	'%s missing PE header', 00H
	ORG $+3
$SG130204 DB	'%s can''t reserve memory', 00H
$SG130207 DB	'%s failed to build import table', 00H
$SG130210 DB	'%s has no entry point', 00H
	ORG $+2
$SG130212 DB	'can''t attach library %s', 00H
$SG130213 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130216 DB	'^1Error:^7 LoadLibrary: %s', 0aH, 00H
$SG130215 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130256 DB	'@@', 00H
	ORG $+1
$SG130239 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130307 DB	'rb', 00H
	ORG $+1
$SG130241 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130309 DB	'couldn''t load %s', 00H
	ORG $+3
$SG130243 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130311 DB	'%s has corrupted EXE header', 00H
$SG130313 DB	'%s does not have a valid dll signature', 00H
	ORG $+1
$SG130315 DB	'%s error seeking for new exe header', 00H
$SG130317 DB	'%s has corrupted NT header', 00H
	ORG $+1
$SG130319 DB	'%s does not have a valid NT signature', 00H
	ORG $+2
$SG130321 DB	'%s does not have a valid PE header', 00H
	ORG $+1
$SG130323 DB	'%s does not have an optional header', 00H
$SG130325 DB	'%s optional header probably corrupted', 00H
	ORG $+2
$SG130327 DB	'%s error during reading section header', 00H
	ORG $+1
$SG130331 DB	'%s does not have a valid exports section', 00H
	ORG $+3
$SG130333 DB	'%s does not have a valid optional header', 00H
	ORG $+3
$SG130335 DB	'%s too many exports %i', 00H
	ORG $+1
$SG130337 DB	'%s does not have a valid ordinals section', 00H
	ORG $+2
$SG130340 DB	'%s error during reading ordinals table', 00H
	ORG $+1
$SG130342 DB	'%s does not have a valid export address section', 00H
$SG130347 DB	'%s file does not have a valid names section', 00H
$SG130338 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130350 DB	'%s error during reading names table', 00H
$SG130343 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130345 DB	'%s error during reading export address section', 00H
	ORG $+1
$SG130358 DB	'GiveFnptrsToDll', 00H
$SG130365 DB	'^1Error:^7 LoadLibrary: %s', 0aH, 00H
$SG130348 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130359 DB	'GiveFnptrsToDll', 00H
$SG130382 DB	'^1Error:^7 LoadLibrary: couldn''t load encrypted library'
	DB	' %s', 0aH, 00H
$SG130354 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130356 DB	'%s error during loading names section', 00H
	ORG $+2
$SG130384 DB	'LoadLibrary: Loading %s - failed', 0aH, 00H
	ORG $+2
$SG130361 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130387 DB	'LoadLibrary: Loading %s - failed', 0aH, 00H
	ORG $+2
$SG130364 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130388 DB	'LoadLibrary: Loading %s - ok', 0aH, 00H
	ORG $+2
$SG130412 DB	'Sys_FreeLibrary: hold %s for debugging', 0aH, 00H
$SG130413 DB	'Sys_FreeLibrary: Unloading %s', 0aH, 00H
	ORG $+1
$SG130451 DB	'Can''t find address: %08lx', 0aH, 00H
	ORG $+1
$SG130417 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\library.c', 00H
	ORG $+1
$SG130433 DB	'Can''t find proc: %s', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_fn_offset$1 = -952					; size = 4
_index$ = -948						; size = 4
_function_offset$ = -944				; size = 4
_ordinal_offset$ = -940					; size = 4
_exports_offset$ = -936					; size = 4
_nt_signature$ = -932					; size = 4
_rdata_found$ = -928					; size = 4
_name_offset$ = -924					; size = 4
_rdata_delta$ = -920					; size = 4
_p_Names$ = -916					; size = 4
_f$ = -912						; size = 4
_i$ = -908						; size = 4
_optional_header$ = -904				; size = 224
_dos_header$ = -680					; size = 64
_export_directory$ = -616				; size = 40
_section_header$ = -576					; size = 40
_pe_header$ = -536					; size = 20
_function_name$ = -516					; size = 256
_errorstring$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_hInst$ = 8						; size = 4
_LibraryLoadSymbols PROC

; 543  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 952				; 000003b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 544  : 	file_t		*f;
; 545  : 	string		errorstring;
; 546  : 	DOS_HEADER	dos_header;
; 547  : 	LONG		nt_signature;
; 548  : 	PE_HEADER		pe_header;
; 549  : 	SECTION_HEADER	section_header;
; 550  : 	qboolean		rdata_found;
; 551  : 	OPTIONAL_HEADER	optional_header;
; 552  : 	long		rdata_delta = 0;

	mov	DWORD PTR _rdata_delta$[ebp], 0

; 553  : 	EXPORT_DIRECTORY	export_directory;
; 554  : 	long		name_offset;
; 555  : 	long		exports_offset;
; 556  : 	long		ordinal_offset;
; 557  : 	long		function_offset;
; 558  : 	string		function_name;
; 559  : 	dword		*p_Names = NULL;

	mov	DWORD PTR _p_Names$[ebp], 0

; 560  : 	int		i, index;
; 561  : 
; 562  : 	// can only be done for loaded libraries
; 563  : 	if( !hInst ) return false;

	cmp	DWORD PTR _hInst$[ebp], 0
	jne	SHORT $LN14@LibraryLoa
	xor	eax, eax
	jmp	$LN1@LibraryLoa
$LN14@LibraryLoa:

; 564  : 
; 565  : 	for( i = 0; i < hInst->num_ordinals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LibraryLoa
$LN2@LibraryLoa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LibraryLoa:
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+16948]
	jge	SHORT $LN3@LibraryLoa

; 566  : 		hInst->names[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx+eax*4+564], 0
	jmp	SHORT $LN2@LibraryLoa
$LN3@LibraryLoa:

; 567  : 
; 568  : 	f = FS_Open( hInst->shortPath, "rb", false );

	push	0
	push	OFFSET $SG130307
	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 569  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN15@LibraryLoa

; 570  : 	{
; 571  : 		Q_sprintf( errorstring, "couldn't load %s", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130309
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 572  : 		goto table_error;

	jmp	$table_error$45
$LN15@LibraryLoa:

; 573  : 	}
; 574  : 
; 575  : 	if( FS_Read( f, &dos_header, sizeof( dos_header )) != sizeof( dos_header ))

	push	64					; 00000040H
	lea	edx, DWORD PTR _dos_header$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 64					; 00000040H
	je	SHORT $LN16@LibraryLoa

; 576  : 	{
; 577  : 		Q_sprintf( errorstring, "%s has corrupted EXE header", hInst->shortPath );

	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	push	OFFSET $SG130311
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 578  : 		goto table_error;

	jmp	$table_error$45
$LN16@LibraryLoa:

; 579  : 	}
; 580  : 
; 581  : 	if( dos_header.e_magic != DOS_SIGNATURE )

	movzx	eax, WORD PTR _dos_header$[ebp]
	cmp	eax, 23117				; 00005a4dH
	je	SHORT $LN17@LibraryLoa

; 582  : 	{
; 583  : 		Q_sprintf( errorstring, "%s does not have a valid dll signature", hInst->shortPath );

	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	push	OFFSET $SG130313
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 584  : 		goto table_error;

	jmp	$table_error$45
$LN17@LibraryLoa:

; 585  : 	}
; 586  : 
; 587  : 	if( FS_Seek( f, dos_header.e_lfanew, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _dos_header$[ebp+60]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN18@LibraryLoa

; 588  : 	{
; 589  : 		Q_sprintf( errorstring, "%s error seeking for new exe header", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130315
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 590  : 		goto table_error;

	jmp	$table_error$45
$LN18@LibraryLoa:

; 591  : 	}
; 592  : 
; 593  : 	if( FS_Read( f, &nt_signature, sizeof( nt_signature )) != sizeof( nt_signature ))

	push	4
	lea	ecx, DWORD PTR _nt_signature$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 4
	je	SHORT $LN19@LibraryLoa

; 594  : 	{
; 595  : 		Q_sprintf( errorstring, "%s has corrupted NT header", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130317
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 596  : 		goto table_error;

	jmp	$table_error$45
$LN19@LibraryLoa:

; 597  : 	}
; 598  : 
; 599  : 	if( nt_signature != NT_SIGNATURE )

	cmp	DWORD PTR _nt_signature$[ebp], 17744	; 00004550H
	je	SHORT $LN20@LibraryLoa

; 600  : 	{
; 601  : 		Q_sprintf( errorstring, "%s does not have a valid NT signature", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130319
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 602  : 		goto table_error;

	jmp	$table_error$45
$LN20@LibraryLoa:

; 603  : 	}
; 604  : 
; 605  : 	if( FS_Read( f, &pe_header, sizeof( pe_header )) != sizeof( pe_header ))

	push	20					; 00000014H
	lea	ecx, DWORD PTR _pe_header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 20					; 00000014H
	je	SHORT $LN21@LibraryLoa

; 606  : 	{
; 607  : 		Q_sprintf( errorstring, "%s does not have a valid PE header", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130321
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 608  : 		goto table_error;

	jmp	$table_error$45
$LN21@LibraryLoa:

; 609  : 	}
; 610  : 
; 611  : 	if( !pe_header.SizeOfOptionalHeader )

	movzx	edx, WORD PTR _pe_header$[ebp+16]
	test	edx, edx
	jne	SHORT $LN22@LibraryLoa

; 612  : 	{
; 613  : 		Q_sprintf( errorstring, "%s does not have an optional header", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130323
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 614  : 		goto table_error;

	jmp	$table_error$45
$LN22@LibraryLoa:

; 615  : 	}
; 616  : 
; 617  : 	if( FS_Read( f, &optional_header, sizeof( optional_header )) != sizeof( optional_header ))

	push	224					; 000000e0H
	lea	edx, DWORD PTR _optional_header$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 224				; 000000e0H
	je	SHORT $LN23@LibraryLoa

; 618  : 	{
; 619  : 		Q_sprintf( errorstring, "%s optional header probably corrupted", hInst->shortPath );

	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	push	OFFSET $SG130325
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 620  : 		goto table_error;

	jmp	$table_error$45
$LN23@LibraryLoa:

; 621  : 	}
; 622  : 
; 623  : 	rdata_found = false;

	mov	DWORD PTR _rdata_found$[ebp], 0

; 624  : 
; 625  : 	for( i = 0; i < pe_header.NumberOfSections; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@LibraryLoa
$LN5@LibraryLoa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@LibraryLoa:
	movzx	ecx, WORD PTR _pe_header$[ebp+2]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN6@LibraryLoa

; 626  : 	{
; 627  : 		if( FS_Read( f, &section_header, sizeof( section_header )) != sizeof( section_header ))

	push	40					; 00000028H
	lea	edx, DWORD PTR _section_header$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 40					; 00000028H
	je	SHORT $LN24@LibraryLoa

; 628  : 		{
; 629  : 			Q_sprintf( errorstring, "%s error during reading section header", hInst->shortPath );

	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	push	OFFSET $SG130327
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 630  : 			goto table_error;

	jmp	$table_error$45
$LN24@LibraryLoa:

; 631  : 		}
; 632  : 
; 633  : 		if((( optional_header.DataDirectory[0].VirtualAddress >= section_header.VirtualAddress ) && 

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _optional_header$[ebp+ecx+96]
	cmp	edx, DWORD PTR _section_header$[ebp+12]
	jb	SHORT $LN25@LibraryLoa
	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _section_header$[ebp+12]
	add	edx, DWORD PTR _section_header$[ebp+8]
	cmp	DWORD PTR _optional_header$[ebp+ecx+96], edx
	jae	SHORT $LN25@LibraryLoa

; 634  : 			(optional_header.DataDirectory[0].VirtualAddress < (section_header.VirtualAddress + section_header.Misc.VirtualSize))))
; 635  : 		{
; 636  : 			rdata_found = true;

	mov	DWORD PTR _rdata_found$[ebp], 1

; 637  : 			break;

	jmp	SHORT $LN6@LibraryLoa
$LN25@LibraryLoa:

; 638  : 		}
; 639  : 	}

	jmp	$LN5@LibraryLoa
$LN6@LibraryLoa:

; 640  : 
; 641  : 	if( rdata_found )

	cmp	DWORD PTR _rdata_found$[ebp], 0
	je	SHORT $LN26@LibraryLoa

; 642  : 	{
; 643  : 		rdata_delta = section_header.VirtualAddress - section_header.PointerToRawData; 

	mov	eax, DWORD PTR _section_header$[ebp+12]
	sub	eax, DWORD PTR _section_header$[ebp+20]
	mov	DWORD PTR _rdata_delta$[ebp], eax
$LN26@LibraryLoa:

; 644  : 	}
; 645  : 
; 646  : 	exports_offset = optional_header.DataDirectory[0].VirtualAddress - rdata_delta;

	mov	ecx, 8
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _optional_header$[ebp+edx+96]
	sub	eax, DWORD PTR _rdata_delta$[ebp]
	mov	DWORD PTR _exports_offset$[ebp], eax

; 647  : 
; 648  : 	if( FS_Seek( f, exports_offset, SEEK_SET ) == -1 )

	push	0
	mov	ecx, DWORD PTR _exports_offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN27@LibraryLoa

; 649  : 	{
; 650  : 		Q_sprintf( errorstring, "%s does not have a valid exports section", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130331
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 651  : 		goto table_error;

	jmp	$table_error$45
$LN27@LibraryLoa:

; 652  : 	}
; 653  : 
; 654  : 	if( FS_Read( f, &export_directory, sizeof( export_directory )) != sizeof( export_directory ))

	push	40					; 00000028H
	lea	edx, DWORD PTR _export_directory$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 40					; 00000028H
	je	SHORT $LN28@LibraryLoa

; 655  : 	{
; 656  : 		Q_sprintf( errorstring, "%s does not have a valid optional header", hInst->shortPath );

	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	push	OFFSET $SG130333
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 657  : 		goto table_error;

	jmp	$table_error$45
$LN28@LibraryLoa:

; 658  : 	}
; 659  : 
; 660  : 	hInst->num_ordinals = export_directory.NumberOfNames;	// also number of ordinals

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR _export_directory$[ebp+24]
	mov	DWORD PTR [eax+16948], ecx

; 661  : 
; 662  : 	if( hInst->num_ordinals > MAX_LIBRARY_EXPORTS )

	mov	edx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [edx+16948], 4096		; 00001000H
	jle	SHORT $LN29@LibraryLoa

; 663  : 	{
; 664  : 		Q_sprintf( errorstring, "%s too many exports %i", hInst->shortPath, hInst->num_ordinals );

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR [eax+16948]
	push	ecx
	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130335
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 665  : 		hInst->num_ordinals = 0;

	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx+16948], 0

; 666  : 		goto table_error;

	jmp	$table_error$45
$LN29@LibraryLoa:

; 667  : 	}
; 668  : 
; 669  : 	ordinal_offset = export_directory.AddressOfNameOrdinals - rdata_delta;

	mov	edx, DWORD PTR _export_directory$[ebp+36]
	sub	edx, DWORD PTR _rdata_delta$[ebp]
	mov	DWORD PTR _ordinal_offset$[ebp], edx

; 670  : 
; 671  : 	if( FS_Seek( f, ordinal_offset, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _ordinal_offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN30@LibraryLoa

; 672  : 	{
; 673  : 		Q_sprintf( errorstring, "%s does not have a valid ordinals section", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130337
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 674  : 		goto table_error;

	jmp	$table_error$45
$LN30@LibraryLoa:

; 675  : 	}
; 676  : 
; 677  : 	hInst->ordinals = Mem_Malloc( host.mempool, hInst->num_ordinals * sizeof( word ));

	push	677					; 000002a5H
	push	OFFSET $SG130338
	push	0
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+16948]
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx+556], eax

; 678  : 
; 679  : 	if( FS_Read( f, hInst->ordinals, hInst->num_ordinals * sizeof( word )) != (hInst->num_ordinals * sizeof( word )))

	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [edx+16948]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+16948]
	shl	edx, 1
	cmp	eax, edx
	je	SHORT $LN31@LibraryLoa

; 680  : 	{
; 681  : 		Q_sprintf( errorstring, "%s error during reading ordinals table", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130340
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 682  : 		goto table_error;

	jmp	$table_error$45
$LN31@LibraryLoa:

; 683  : 	}
; 684  : 
; 685  : 	function_offset = export_directory.AddressOfFunctions - rdata_delta;

	mov	edx, DWORD PTR _export_directory$[ebp+28]
	sub	edx, DWORD PTR _rdata_delta$[ebp]
	mov	DWORD PTR _function_offset$[ebp], edx

; 686  : 
; 687  : 	if( FS_Seek( f, function_offset, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _function_offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN32@LibraryLoa

; 688  : 	{
; 689  : 		Q_sprintf( errorstring, "%s does not have a valid export address section", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130342
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 690  : 		goto table_error;

	jmp	$table_error$45
$LN32@LibraryLoa:

; 691  : 	}
; 692  : 
; 693  : 	hInst->funcs = Mem_Malloc( host.mempool, hInst->num_ordinals * sizeof( dword ));

	push	693					; 000002b5H
	push	OFFSET $SG130343
	push	0
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+16948]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx+560], eax

; 694  : 
; 695  : 	if( FS_Read( f, hInst->funcs, hInst->num_ordinals * sizeof( dword )) != (hInst->num_ordinals * sizeof( dword )))

	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [edx+16948]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+560]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+16948]
	shl	edx, 2
	cmp	eax, edx
	je	SHORT $LN33@LibraryLoa

; 696  : 	{
; 697  : 		Q_sprintf( errorstring, "%s error during reading export address section", hInst->shortPath );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 300				; 0000012cH
	push	eax
	push	OFFSET $SG130345
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 698  : 		goto table_error;

	jmp	$table_error$45
$LN33@LibraryLoa:

; 699  : 	}
; 700  : 
; 701  : 	name_offset = export_directory.AddressOfNames - rdata_delta;

	mov	edx, DWORD PTR _export_directory$[ebp+32]
	sub	edx, DWORD PTR _rdata_delta$[ebp]
	mov	DWORD PTR _name_offset$[ebp], edx

; 702  : 
; 703  : 	if( FS_Seek( f, name_offset, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _name_offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN34@LibraryLoa

; 704  : 	{
; 705  : 		Q_sprintf( errorstring, "%s file does not have a valid names section", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130347
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 706  : 		goto table_error;

	jmp	$table_error$45
$LN34@LibraryLoa:

; 707  : 	}
; 708  : 
; 709  : 	p_Names = Mem_Malloc( host.mempool, hInst->num_ordinals * sizeof( dword ));

	push	709					; 000002c5H
	push	OFFSET $SG130348
	push	0
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+16948]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _p_Names$[ebp], eax

; 710  : 
; 711  : 	if( FS_Read( f, p_Names, hInst->num_ordinals * sizeof( dword )) != (hInst->num_ordinals * sizeof( dword )))

	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+16948]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _p_Names$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR [edx+16948]
	shl	ecx, 2
	cmp	eax, ecx
	je	SHORT $LN35@LibraryLoa

; 712  : 	{
; 713  : 		Q_sprintf( errorstring, "%s error during reading names table", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130350
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 714  : 		goto table_error;

	jmp	$table_error$45
$LN35@LibraryLoa:

; 715  : 	}
; 716  : 
; 717  : 	for( i = 0; i < hInst->num_ordinals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@LibraryLoa
$LN8@LibraryLoa:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@LibraryLoa:
	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+16948]
	jge	$LN9@LibraryLoa

; 718  : 	{
; 719  : 		name_offset = p_Names[i] - rdata_delta;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p_Names$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	sub	eax, DWORD PTR _rdata_delta$[ebp]
	mov	DWORD PTR _name_offset$[ebp], eax

; 720  : 
; 721  : 		if( name_offset != 0 )

	je	SHORT $LN36@LibraryLoa

; 722  : 		{
; 723  : 			if( FS_Seek( f, name_offset, SEEK_SET ) != -1 )

	push	0
	mov	ecx, DWORD PTR _name_offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	SHORT $LN37@LibraryLoa

; 724  : 			{
; 725  : 				FsGetString( f, function_name );

	lea	eax, DWORD PTR _function_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FsGetString
	add	esp, 8

; 726  : 				hInst->names[i] = copystring( GetMSVCName( function_name ));

	push	726					; 000002d6H
	push	OFFSET $SG130354
	lea	edx, DWORD PTR _function_name$[ebp]
	push	edx
	call	_GetMSVCName
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [edx+ecx*4+564], eax

; 727  : 			}

	jmp	SHORT $LN36@LibraryLoa
$LN37@LibraryLoa:

; 728  : 			else break;

	jmp	SHORT $LN9@LibraryLoa
$LN36@LibraryLoa:

; 729  : 		}
; 730  : 	}

	jmp	$LN8@LibraryLoa
$LN9@LibraryLoa:

; 731  : 
; 732  : 	if( i != hInst->num_ordinals )

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16948]
	je	SHORT $LN39@LibraryLoa

; 733  : 	{
; 734  : 		Q_sprintf( errorstring, "%s error during loading names section", hInst->shortPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	push	OFFSET $SG130356
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 735  : 		goto table_error;

	jmp	$table_error$45
$LN39@LibraryLoa:

; 736  : 	}
; 737  : 	FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 738  : 
; 739  : 	for( i = 0; i < hInst->num_ordinals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@LibraryLoa
$LN11@LibraryLoa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@LibraryLoa:
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16948]
	jge	SHORT $LN12@LibraryLoa

; 740  : 	{
; 741  : 		if( !Q_strcmp( "GiveFnptrsToDll", hInst->names[i] ))	// main entry point for user dlls

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+564]
	push	ecx
	push	OFFSET $SG130358
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN40@LibraryLoa

; 742  : 		{
; 743  : 			void	*fn_offset;
; 744  : 
; 745  : 			index = hInst->ordinals[i];

	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [edx+556]
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, WORD PTR [eax+ecx*2]
	mov	DWORD PTR _index$[ebp], edx

; 746  : 			fn_offset = (void *)COM_GetProcAddress( hInst, "GiveFnptrsToDll" );

	push	OFFSET $SG130359
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _fn_offset$1[ebp], eax

; 747  : 			hInst->funcBase = (dword)(fn_offset) - hInst->funcs[index];

	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+560]
	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _fn_offset$1[ebp]
	sub	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [edx+16952], ecx

; 748  : 			break;

	jmp	SHORT $LN12@LibraryLoa
$LN40@LibraryLoa:

; 749  : 		}
; 750  : 	}

	jmp	$LN11@LibraryLoa
$LN12@LibraryLoa:

; 751  : 
; 752  : 	if( p_Names ) Mem_Free( p_Names );

	cmp	DWORD PTR _p_Names$[ebp], 0
	je	SHORT $LN41@LibraryLoa
	push	752					; 000002f0H
	push	OFFSET $SG130361
	mov	eax, DWORD PTR _p_Names$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN41@LibraryLoa:

; 753  : 	return true;

	mov	eax, 1
	jmp	SHORT $LN1@LibraryLoa
$table_error$45:

; 754  : table_error:
; 755  : 	// cleanup
; 756  : 	if( f ) FS_Close( f );

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN42@LibraryLoa
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4
$LN42@LibraryLoa:

; 757  : 	if( p_Names ) Mem_Free( p_Names );

	cmp	DWORD PTR _p_Names$[ebp], 0
	je	SHORT $LN43@LibraryLoa
	push	757					; 000002f5H
	push	OFFSET $SG130364
	mov	edx, DWORD PTR _p_Names$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN43@LibraryLoa:

; 758  : 	FreeNameFuncGlobals( hInst );

	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	_FreeNameFuncGlobals
	add	esp, 4

; 759  : 	Con_Printf( S_ERROR "LoadLibrary: %s\n", errorstring );

	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	push	OFFSET $SG130365
	call	_Con_Printf
	add	esp, 8

; 760  : 
; 761  : 	return false;

	xor	eax, eax
$LN1@LibraryLoa:

; 762  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LibraryLoadSymbols ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_len$1 = -12						; size = 4
$T2 = -8						; size = 4
_pos$ = -4						; size = 4
_in_name$ = 8						; size = 4
_GetMSVCName PROC

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 521  : 	static string	out_name;
; 522  : 	char		*pos;
; 523  : 
; 524  : 	if( in_name[0] == '?' )  // is this a MSVC C++ mangled name?

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in_name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN2@GetMSVCNam

; 525  : 	{
; 526  : 		if(( pos = Q_strstr( in_name, "@@" )) != NULL )

	push	OFFSET $SG130256
	mov	ecx, DWORD PTR _in_name$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	mov	DWORD PTR _pos$[ebp], eax
	cmp	DWORD PTR _pos$[ebp], 0
	je	SHORT $LN2@GetMSVCNam

; 527  : 		{
; 528  : 			int	len = pos - in_name;

	mov	edx, DWORD PTR _pos$[ebp]
	sub	edx, DWORD PTR _in_name$[ebp]
	mov	DWORD PTR _len$1[ebp], edx

; 529  : 
; 530  : 			// strip off the leading '?'
; 531  : 			Q_strncpy( out_name, in_name + 1, sizeof( out_name ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _in_name$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET ?out_name@?1??GetMSVCName@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 532  : 			out_name[len-1] = 0; // terminate string at the "@@"

	mov	ecx, DWORD PTR _len$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN5@GetMSVCNam
	jmp	SHORT $LN6@GetMSVCNam
$LN5@GetMSVCNam:
	call	___report_rangecheckfailure
$LN6@GetMSVCNam:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR ?out_name@?1??GetMSVCName@@9@9[edx], 0

; 533  : 			return out_name;

	mov	eax, OFFSET ?out_name@?1??GetMSVCName@@9@9
	jmp	SHORT $LN4@GetMSVCNam
$LN2@GetMSVCNam:

; 534  : 		}
; 535  : 	}
; 536  : 
; 537  : 	Q_strncpy( out_name, in_name, sizeof( out_name ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _in_name$[ebp]
	push	eax
	push	OFFSET ?out_name@?1??GetMSVCName@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 538  : 
; 539  : 	return out_name;

	mov	eax, OFFSET ?out_name@?1??GetMSVCName@@9@9
$LN4@GetMSVCNam:

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GetMSVCName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hInst$ = 8						; size = 4
_FreeNameFuncGlobals PROC

; 500  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 501  : 	int	i;
; 502  : 
; 503  : 	if( !hInst ) return;

	cmp	DWORD PTR _hInst$[ebp], 0
	jne	SHORT $LN5@FreeNameFu
	jmp	$LN1@FreeNameFu
$LN5@FreeNameFu:

; 504  : 
; 505  : 	if( hInst->ordinals ) Mem_Free( hInst->ordinals );

	mov	eax, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [eax+556], 0
	je	SHORT $LN6@FreeNameFu
	push	505					; 000001f9H
	push	OFFSET $SG130239
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN6@FreeNameFu:

; 506  : 	if( hInst->funcs ) Mem_Free( hInst->funcs );

	mov	eax, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [eax+560], 0
	je	SHORT $LN7@FreeNameFu
	push	506					; 000001faH
	push	OFFSET $SG130241
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+560]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@FreeNameFu:

; 507  : 
; 508  : 	for( i = 0; i < hInst->num_ordinals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FreeNameFu
$LN2@FreeNameFu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FreeNameFu:
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+16948]
	jge	SHORT $LN3@FreeNameFu

; 509  : 	{
; 510  : 		if( hInst->names[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx+eax*4+564], 0
	je	SHORT $LN8@FreeNameFu

; 511  : 			Mem_Free( hInst->names[i] );

	push	511					; 000001ffH
	push	OFFSET $SG130243
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+564]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@FreeNameFu:

; 512  : 	}

	jmp	SHORT $LN2@FreeNameFu
$LN3@FreeNameFu:

; 513  : 
; 514  : 	hInst->num_ordinals = 0;

	mov	edx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [edx+16948], 0

; 515  : 	hInst->ordinals = NULL;

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [eax+556], 0

; 516  : 	hInst->funcs = NULL;

	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx+560], 0
$LN1@FreeNameFu:

; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FreeNameFuncGlobals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_ch$ = -1						; size = 1
_f$ = 8							; size = 4
_str$ = 12						; size = 4
_FsGetString PROC

; 489  : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@FsGetStrin:

; 490  : 	char	ch;
; 491  : 
; 492  : 	while(( ch = FS_Getc( f )) != EOF )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Getc
	add	esp, 4
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, -1
	je	SHORT $LN1@FsGetStrin

; 493  : 	{
; 494  : 		*str++ = ch;

	mov	edx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 495  : 		if( !ch ) break;

	movsx	edx, BYTE PTR _ch$[ebp]
	test	edx, edx
	jne	SHORT $LN4@FsGetStrin
	jmp	SHORT $LN1@FsGetStrin
$LN4@FsGetStrin:

; 496  : 	}

	jmp	SHORT $LN2@FsGetStrin
$LN1@FsGetStrin:

; 497  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FsGetString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_successfull$ = -296					; size = 4
_DllEntry$ = -292					; size = 4
_locationDelta$ = -288					; size = 4
_headers$ = -284					; size = 4
_dos_header$ = -280					; size = 4
_data$ = -276						; size = 4
_old_header$ = -272					; size = 4
_code$ = -268						; size = 4
_result$ = -264						; size = 4
_errorstring$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_MemoryLoadLibrary PROC

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 365  : 	MEMORYMODULE	*result = NULL;

	mov	DWORD PTR _result$[ebp], 0

; 366  : 	PIMAGE_DOS_HEADER	dos_header;
; 367  : 	PIMAGE_NT_HEADERS	old_header;
; 368  : 	byte		*code, *headers;
; 369  : 	DWORD		locationDelta;
; 370  : 	DllEntryProc	DllEntry;
; 371  : 	string		errorstring;
; 372  : 	qboolean		successfull;
; 373  : 	void		*data = NULL;

	mov	DWORD PTR _data$[ebp], 0

; 374  : 
; 375  : 	data = FS_LoadFile( name, NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _data$[ebp], eax

; 376  : 
; 377  : 	if( !data )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@MemoryLoad

; 378  : 	{
; 379  : 		Q_sprintf( errorstring, "couldn't load %s", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG130197
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 380  : 		goto library_error;

	jmp	$library_error$14
$LN2@MemoryLoad:

; 381  : 	}
; 382  : 
; 383  : 	dos_header = (PIMAGE_DOS_HEADER)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _dos_header$[ebp], eax

; 384  : 	if( dos_header->e_magic != IMAGE_DOS_SIGNATURE )

	mov	ecx, DWORD PTR _dos_header$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 23117				; 00005a4dH
	je	SHORT $LN3@MemoryLoad

; 385  : 	{
; 386  : 		Q_sprintf( errorstring, "%s it's not a valid executable file", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG130199
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 387  : 		goto library_error;

	jmp	$library_error$14
$LN3@MemoryLoad:

; 388  : 	}
; 389  : 
; 390  : 	old_header = (PIMAGE_NT_HEADERS)&((const byte *)(data))[dos_header->e_lfanew];

	mov	edx, DWORD PTR _dos_header$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _old_header$[ebp], eax

; 391  : 	if( old_header->Signature != IMAGE_NT_SIGNATURE )

	mov	ecx, DWORD PTR _old_header$[ebp]
	cmp	DWORD PTR [ecx], 17744			; 00004550H
	je	SHORT $LN4@MemoryLoad

; 392  : 	{
; 393  : 		Q_sprintf( errorstring, "%s missing PE header", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG130201
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 394  : 		goto library_error;

	jmp	$library_error$14
$LN4@MemoryLoad:

; 395  : 	}
; 396  : 
; 397  : 	// reserve memory for image of library
; 398  : 	code = (byte *)VirtualAlloc((LPVOID)(old_header->OptionalHeader.ImageBase), old_header->OptionalHeader.SizeOfImage, MEM_RESERVE, PAGE_READWRITE );

	push	4
	push	8192					; 00002000H
	mov	ecx, DWORD PTR _old_header$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _old_header$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _code$[ebp], eax

; 399  : 
; 400  : 	if( code == NULL )

	cmp	DWORD PTR _code$[ebp], 0
	jne	SHORT $LN5@MemoryLoad

; 401  : 	{
; 402  : 		// try to allocate memory at arbitrary position
; 403  : 		code = (byte *)VirtualAlloc( NULL, old_header->OptionalHeader.SizeOfImage, MEM_RESERVE, PAGE_READWRITE );

	push	4
	push	8192					; 00002000H
	mov	edx, DWORD PTR _old_header$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	push	0
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _code$[ebp], eax
$LN5@MemoryLoad:

; 404  : 	}    
; 405  : 
; 406  : 	if( code == NULL )

	cmp	DWORD PTR _code$[ebp], 0
	jne	SHORT $LN6@MemoryLoad

; 407  : 	{
; 408  : 		Q_sprintf( errorstring, "%s can't reserve memory", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG130204
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 409  : 		goto library_error;

	jmp	$library_error$14
$LN6@MemoryLoad:

; 410  : 	}
; 411  : 
; 412  : 	result = (MEMORYMODULE *)HeapAlloc( GetProcessHeap(), 0, sizeof( MEMORYMODULE ));

	push	20					; 00000014H
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	mov	DWORD PTR _result$[ebp], eax

; 413  : 	result->codeBase = code;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _code$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 414  : 	result->numModules = 0;

	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx+12], 0

; 415  : 	result->modules = NULL;

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax+8], 0

; 416  : 	result->initialized = 0;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 417  : 
; 418  : 	// XXX: is it correct to commit the complete memory region at once?
; 419  : 	// calling DllEntry raises an exception if we don't...
; 420  : 	VirtualAlloc( code, old_header->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_READWRITE );

	push	4
	push	4096					; 00001000H
	mov	edx, DWORD PTR _old_header$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _code$[ebp]
	push	ecx
	call	DWORD PTR __imp__VirtualAlloc@16

; 421  : 
; 422  : 	// commit memory for headers
; 423  : 	headers = (byte *)VirtualAlloc( code, old_header->OptionalHeader.SizeOfHeaders, MEM_COMMIT, PAGE_READWRITE );

	push	4
	push	4096					; 00001000H
	mov	edx, DWORD PTR _old_header$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _code$[ebp]
	push	ecx
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _headers$[ebp], eax

; 424  : 	
; 425  : 	// copy PE header to code
; 426  : 	memcpy( headers, dos_header, dos_header->e_lfanew + old_header->OptionalHeader.SizeOfHeaders );

	mov	edx, DWORD PTR _dos_header$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _old_header$[ebp]
	add	eax, DWORD PTR [ecx+84]
	push	eax
	mov	edx, DWORD PTR _dos_header$[ebp]
	push	edx
	mov	eax, DWORD PTR _headers$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 427  : 	result->headers = (PIMAGE_NT_HEADERS)&((const byte *)(headers))[dos_header->e_lfanew];

	mov	ecx, DWORD PTR _dos_header$[ebp]
	mov	edx, DWORD PTR _headers$[ebp]
	add	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], edx

; 428  : 
; 429  : 	// update position
; 430  : 	result->headers->OptionalHeader.ImageBase = (DWORD)code;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _code$[ebp]
	mov	DWORD PTR [edx+52], eax

; 431  : 
; 432  : 	// copy sections from DLL file block to new memory location
; 433  : 	CopySections( data, old_header, result );

	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	edx, DWORD PTR _old_header$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_CopySections
	add	esp, 12					; 0000000cH

; 434  : 
; 435  : 	// adjust base address of imported data
; 436  : 	locationDelta = (DWORD)(code - old_header->OptionalHeader.ImageBase);

	mov	ecx, DWORD PTR _old_header$[ebp]
	mov	edx, DWORD PTR _code$[ebp]
	sub	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _locationDelta$[ebp], edx

; 437  : 	if( locationDelta != 0 ) PerformBaseRelocation( result, locationDelta );

	je	SHORT $LN7@MemoryLoad
	mov	eax, DWORD PTR _locationDelta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_PerformBaseRelocation
	add	esp, 8
$LN7@MemoryLoad:

; 438  : 
; 439  : 	// load required dlls and adjust function table of imports
; 440  : 	if( !BuildImportTable( result ))

	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_BuildImportTable
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@MemoryLoad

; 441  : 	{
; 442  : 		Q_sprintf( errorstring, "%s failed to build import table", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG130207
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 443  : 		goto library_error;

	jmp	$library_error$14
$LN8@MemoryLoad:

; 444  : 	}
; 445  : 
; 446  : 	// mark memory pages depending on section headers and release
; 447  : 	// sections that are marked as "discardable"
; 448  : 	FinalizeSections( result );

	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_FinalizeSections
	add	esp, 4

; 449  : 
; 450  : 	// get entry point of loaded library
; 451  : 	if( result->headers->OptionalHeader.AddressOfEntryPoint != 0 )

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN9@MemoryLoad

; 452  : 	{
; 453  : 		DllEntry = (DllEntryProc)CALCULATE_ADDRESS( code, result->headers->OptionalHeader.AddressOfEntryPoint );

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _code$[ebp]
	add	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _DllEntry$[ebp], ecx

; 454  : 		if( DllEntry == 0 )

	jne	SHORT $LN10@MemoryLoad

; 455  : 		{
; 456  : 			Q_sprintf( errorstring, "%s has no entry point", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG130210
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 457  : 			goto library_error;

	jmp	SHORT $library_error$14
$LN10@MemoryLoad:

; 458  : 		}
; 459  : 
; 460  : 		// notify library about attaching to process
; 461  : 		successfull = (*DllEntry)((HINSTANCE)code, DLL_PROCESS_ATTACH, 0 );

	push	0
	push	1
	mov	ecx, DWORD PTR _code$[ebp]
	push	ecx
	call	DWORD PTR _DllEntry$[ebp]
	mov	DWORD PTR _successfull$[ebp], eax

; 462  : 		if( !successfull )

	cmp	DWORD PTR _successfull$[ebp], 0
	jne	SHORT $LN11@MemoryLoad

; 463  : 		{
; 464  : 			Q_sprintf( errorstring, "can't attach library %s", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG130212
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 465  : 			goto library_error;

	jmp	SHORT $library_error$14
$LN11@MemoryLoad:

; 466  : 		}
; 467  : 		result->initialized = 1;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+16], 1
$LN9@MemoryLoad:

; 468  : 	}
; 469  : 
; 470  : 	Mem_Free( data ); // release memory

	push	470					; 000001d6H
	push	OFFSET $SG130213
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 471  : 	return (void *)result;

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@MemoryLoad
$library_error$14:

; 472  : library_error:
; 473  : 	// cleanup
; 474  : 	if( data ) Mem_Free( data );

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN12@MemoryLoad
	push	474					; 000001daH
	push	OFFSET $SG130215
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN12@MemoryLoad:

; 475  : 	MemoryFreeLibrary( result );

	mov	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_MemoryFreeLibrary
	add	esp, 4

; 476  : 	Con_Printf( S_ERROR "LoadLibrary: %s\n", errorstring );

	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	push	OFFSET $SG130216
	call	_Con_Printf
	add	esp, 8

; 477  : 
; 478  : 	return NULL;

	xor	eax, eax
$LN1@MemoryLoad:

; 479  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_MemoryLoadLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_DllEntry$1 = -12					; size = 4
_i$2 = -8						; size = 4
_module$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_MemoryFreeLibrary PROC

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 326  : 	MEMORYMODULE	*module = (MEMORYMODULE *)hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _module$[ebp], eax

; 327  : 
; 328  : 	if( module != NULL )

	cmp	DWORD PTR _module$[ebp], 0
	je	$LN1@MemoryFree

; 329  : 	{
; 330  : 		int	i;
; 331  : 	
; 332  : 		if( module->initialized != 0 )

	mov	ecx, DWORD PTR _module$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN6@MemoryFree

; 333  : 		{
; 334  : 			// notify library about detaching from process
; 335  : 			DllEntryProc DllEntry = (DllEntryProc)CALCULATE_ADDRESS( module->codeBase, module->headers->OptionalHeader.AddressOfEntryPoint );

	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR [eax+40]
	mov	DWORD PTR _DllEntry$1[ebp], edx

; 336  : 			(*DllEntry)((HINSTANCE)module->codeBase, DLL_PROCESS_DETACH, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _DllEntry$1[ebp]

; 337  : 			module->initialized = 0;

	mov	edx, DWORD PTR _module$[ebp]
	mov	DWORD PTR [edx+16], 0
$LN6@MemoryFree:

; 338  : 		}
; 339  : 
; 340  : 		if( module->modules != NULL )

	mov	eax, DWORD PTR _module$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN7@MemoryFree

; 341  : 		{
; 342  : 			// free previously opened libraries
; 343  : 			for( i = 0; i < module->numModules; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@MemoryFree
$LN2@MemoryFree:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@MemoryFree:
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $LN3@MemoryFree

; 344  : 			{
; 345  : 				if( module->modules[i] != NULL )

	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN8@MemoryFree

; 346  : 					COM_FreeLibrary( module->modules[i] );

	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4
$LN8@MemoryFree:

; 347  : 			}

	jmp	SHORT $LN2@MemoryFree
$LN3@MemoryFree:

; 348  : 			Mem_Free( module->modules ); // Mem_Realloc end

	push	348					; 0000015cH
	push	OFFSET $SG130154
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@MemoryFree:

; 349  : 		}
; 350  : 
; 351  : 		FreeSections( module->headers, module );

	mov	ecx, DWORD PTR _module$[ebp]
	push	ecx
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_FreeSections
	add	esp, 8

; 352  : 
; 353  : 		if( module->codeBase != NULL )

	mov	ecx, DWORD PTR _module$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN9@MemoryFree

; 354  : 		{
; 355  : 			// release memory of library
; 356  : 			VirtualFree( module->codeBase, 0, MEM_RELEASE );

	push	32768					; 00008000H
	push	0
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__VirtualFree@12
$LN9@MemoryFree:

; 357  : 		}
; 358  : 
; 359  : 		HeapFree( GetProcessHeap(), 0, module );

	mov	ecx, DWORD PTR _module$[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
$LN1@MemoryFree:

; 360  : 	}
; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MemoryFreeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_thunkData$1 = -40					; size = 4
_directory$ = -36					; size = 4
_libname$2 = -32					; size = 4
_result$ = -28						; size = 4
_funcName$3 = -24					; size = 4
_handle$4 = -20						; size = 4
_funcRef$5 = -16					; size = 4
_codeBase$ = -12					; size = 4
_thunkRef$6 = -8					; size = 4
_importDesc$7 = -4					; size = 4
_module$ = 8						; size = 4
_BuildImportTable PROC

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 256  : 	PIMAGE_DATA_DIRECTORY	directory = GET_HEADER_DICTIONARY( module, IMAGE_DIRECTORY_ENTRY_IMPORT );

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+120]
	mov	DWORD PTR _directory$[ebp], eax

; 257  : 	byte			*codeBase = module->codeBase;

	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _codeBase$[ebp], edx

; 258  : 	int			result = 1;

	mov	DWORD PTR _result$[ebp], 1

; 259  : 
; 260  : 	if( directory->Size > 0 )

	mov	eax, DWORD PTR _directory$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jbe	$LN8@BuildImpor

; 261  : 	{
; 262  : 		PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)CALCULATE_ADDRESS( codeBase, directory->VirtualAddress );

	mov	ecx, DWORD PTR _directory$[ebp]
	mov	edx, DWORD PTR _codeBase$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _importDesc$7[ebp], edx

; 263  : 
; 264  : 		for( ; !IsBadReadPtr( importDesc, sizeof( IMAGE_IMPORT_DESCRIPTOR )) && importDesc->Name; importDesc++ )

	jmp	SHORT $LN4@BuildImpor
$LN2@BuildImpor:
	mov	eax, DWORD PTR _importDesc$7[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _importDesc$7[ebp], eax
$LN4@BuildImpor:
	push	20					; 00000014H
	mov	ecx, DWORD PTR _importDesc$7[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadReadPtr@8
	test	eax, eax
	jne	$LN8@BuildImpor
	mov	edx, DWORD PTR _importDesc$7[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN8@BuildImpor

; 265  : 		{
; 266  : 			DWORD	*thunkRef, *funcRef;
; 267  : 			LPCSTR	libname;
; 268  : 			void	*handle;
; 269  : 
; 270  : 			libname = (LPCSTR)CALCULATE_ADDRESS( codeBase, importDesc->Name );

	mov	eax, DWORD PTR _importDesc$7[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _libname$2[ebp], ecx

; 271  : 			handle = COM_LoadLibrary( libname, false, true );

	push	1
	push	0
	mov	edx, DWORD PTR _libname$2[ebp]
	push	edx
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _handle$4[ebp], eax

; 272  : 
; 273  : 			if( handle == NULL )

	cmp	DWORD PTR _handle$4[ebp], 0
	jne	SHORT $LN9@BuildImpor

; 274  : 			{
; 275  : 				Con_Printf( S_ERROR "couldn't load library %s\n", libname );

	mov	eax, DWORD PTR _libname$2[ebp]
	push	eax
	push	OFFSET $SG130123
	call	_Con_Printf
	add	esp, 8

; 276  : 				result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 277  : 				break;

	jmp	$LN8@BuildImpor
$LN9@BuildImpor:

; 278  : 			}
; 279  : 
; 280  : 			module->modules = (void *)Mem_Realloc( host.mempool, module->modules, (module->numModules + 1) * (sizeof( void* )));

	push	280					; 00000118H
	push	OFFSET $SG130124
	push	1
	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx*4+4]
	push	eax
	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _module$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 281  : 			module->modules[module->numModules++] = handle;

	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _handle$4[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _module$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 282  : 
; 283  : 			if( importDesc->OriginalFirstThunk )

	mov	edx, DWORD PTR _importDesc$7[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN10@BuildImpor

; 284  : 			{
; 285  : 				thunkRef = (DWORD *)CALCULATE_ADDRESS( codeBase, importDesc->OriginalFirstThunk );

	mov	eax, DWORD PTR _importDesc$7[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thunkRef$6[ebp], ecx

; 286  : 				funcRef = (DWORD *)CALCULATE_ADDRESS( codeBase, importDesc->FirstThunk );

	mov	edx, DWORD PTR _importDesc$7[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _funcRef$5[ebp], eax

; 287  : 			}

	jmp	SHORT $LN11@BuildImpor
$LN10@BuildImpor:

; 288  : 			else
; 289  : 			{
; 290  : 				// no hint table
; 291  : 				thunkRef = (DWORD *)CALCULATE_ADDRESS( codeBase, importDesc->FirstThunk );

	mov	ecx, DWORD PTR _importDesc$7[ebp]
	mov	edx, DWORD PTR _codeBase$[ebp]
	add	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _thunkRef$6[ebp], edx

; 292  : 				funcRef = (DWORD *)CALCULATE_ADDRESS( codeBase, importDesc->FirstThunk );

	mov	eax, DWORD PTR _importDesc$7[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _funcRef$5[ebp], ecx
$LN11@BuildImpor:

; 293  : 			}
; 294  : 
; 295  : 			for( ; *thunkRef; thunkRef++, funcRef++ )

	jmp	SHORT $LN7@BuildImpor
$LN5@BuildImpor:
	mov	edx, DWORD PTR _thunkRef$6[ebp]
	add	edx, 4
	mov	DWORD PTR _thunkRef$6[ebp], edx
	mov	eax, DWORD PTR _funcRef$5[ebp]
	add	eax, 4
	mov	DWORD PTR _funcRef$5[ebp], eax
$LN7@BuildImpor:
	mov	ecx, DWORD PTR _thunkRef$6[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN6@BuildImpor

; 296  : 			{
; 297  : 				LPCSTR	funcName;
; 298  : 
; 299  : 				if( IMAGE_SNAP_BY_ORDINAL( *thunkRef ))

	mov	edx, DWORD PTR _thunkRef$6[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN12@BuildImpor

; 300  : 				{
; 301  : 					funcName = (LPCSTR)IMAGE_ORDINAL( *thunkRef );

	mov	ecx, DWORD PTR _thunkRef$6[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _funcName$3[ebp], edx

; 302  : 					*funcRef = (DWORD)COM_GetProcAddress( handle, funcName );

	mov	eax, DWORD PTR _funcName$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$4[ebp]
	push	ecx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	edx, DWORD PTR _funcRef$5[ebp]
	mov	DWORD PTR [edx], eax

; 303  : 				}

	jmp	SHORT $LN13@BuildImpor
$LN12@BuildImpor:

; 304  : 				else
; 305  : 				{
; 306  : 					PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)CALCULATE_ADDRESS( codeBase, *thunkRef );

	mov	eax, DWORD PTR _thunkRef$6[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thunkData$1[ebp], ecx

; 307  : 					funcName = (LPCSTR)&thunkData->Name;

	mov	edx, DWORD PTR _thunkData$1[ebp]
	add	edx, 2
	mov	DWORD PTR _funcName$3[ebp], edx

; 308  : 					*funcRef = (DWORD)COM_GetProcAddress( handle, funcName );

	mov	eax, DWORD PTR _funcName$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$4[ebp]
	push	ecx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	edx, DWORD PTR _funcRef$5[ebp]
	mov	DWORD PTR [edx], eax
$LN13@BuildImpor:

; 309  : 				}
; 310  : 
; 311  : 				if( *funcRef == 0 )

	mov	eax, DWORD PTR _funcRef$5[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN14@BuildImpor

; 312  : 				{
; 313  : 					Con_Printf( S_ERROR "%s unable to find address: %s\n", libname, funcName );

	mov	ecx, DWORD PTR _funcName$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _libname$2[ebp]
	push	edx
	push	OFFSET $SG130130
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 314  : 					result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 315  : 					break;

	jmp	SHORT $LN6@BuildImpor
$LN14@BuildImpor:

; 316  : 				}
; 317  : 			}

	jmp	$LN5@BuildImpor
$LN6@BuildImpor:

; 318  : 			if( !result ) break;

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN15@BuildImpor
	jmp	SHORT $LN8@BuildImpor
$LN15@BuildImpor:

; 319  : 		}

	jmp	$LN2@BuildImpor
$LN8@BuildImpor:

; 320  : 	}
; 321  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 322  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildImportTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_directory$ = -28					; size = 4
_ordinal$ = -24						; size = 4
_nameRef$ = -20						; size = 4
_i$ = -16						; size = 4
_idx$ = -12						; size = 4
_codeBase$ = -8						; size = 4
_exports$ = -4						; size = 4
_module$ = 8						; size = 4
_name$ = 12						; size = 4
_MemoryGetProcAddress PROC

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 203  : 	PIMAGE_DATA_DIRECTORY	directory = GET_HEADER_DICTIONARY((MEMORYMODULE *)module, IMAGE_DIRECTORY_ENTRY_EXPORT );

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 8
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+120]
	mov	DWORD PTR _directory$[ebp], ecx

; 204  : 	byte			*codeBase = ((PMEMORYMODULE)module)->codeBase;

	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _codeBase$[ebp], eax

; 205  : 	PIMAGE_EXPORT_DIRECTORY	exports;
; 206  : 	int			idx = -1;

	mov	DWORD PTR _idx$[ebp], -1

; 207  : 	DWORD			i, *nameRef;
; 208  : 	WORD			*ordinal;
; 209  : 
; 210  : 	if( directory->Size == 0 )

	mov	ecx, DWORD PTR _directory$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN5@MemoryGetP

; 211  : 	{
; 212  : 		// no export table found
; 213  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@MemoryGetP
$LN5@MemoryGetP:

; 214  : 	}
; 215  : 
; 216  : 	exports = (PIMAGE_EXPORT_DIRECTORY)CALCULATE_ADDRESS( codeBase, directory->VirtualAddress );

	mov	edx, DWORD PTR _directory$[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _exports$[ebp], eax

; 217  : 
; 218  : 	if( exports->NumberOfNames == 0 || exports->NumberOfFunctions == 0 )

	mov	ecx, DWORD PTR _exports$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN7@MemoryGetP
	mov	edx, DWORD PTR _exports$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN6@MemoryGetP
$LN7@MemoryGetP:

; 219  : 	{
; 220  : 		// DLL doesn't export anything
; 221  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@MemoryGetP
$LN6@MemoryGetP:

; 222  : 	}
; 223  : 
; 224  : 	// search function name in list of exported names
; 225  : 	nameRef = (DWORD *)CALCULATE_ADDRESS( codeBase, exports->AddressOfNames );

	mov	eax, DWORD PTR _exports$[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nameRef$[ebp], ecx

; 226  : 	ordinal = (WORD *)CALCULATE_ADDRESS( codeBase, exports->AddressOfNameOrdinals );

	mov	edx, DWORD PTR _exports$[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _ordinal$[ebp], eax

; 227  : 
; 228  : 	for( i = 0; i < exports->NumberOfNames; i++, nameRef++, ordinal++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MemoryGetP
$LN2@MemoryGetP:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _nameRef$[ebp]
	add	edx, 4
	mov	DWORD PTR _nameRef$[ebp], edx
	mov	eax, DWORD PTR _ordinal$[ebp]
	add	eax, 2
	mov	DWORD PTR _ordinal$[ebp], eax
$LN4@MemoryGetP:
	mov	ecx, DWORD PTR _exports$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jae	SHORT $LN3@MemoryGetP

; 229  : 	{
; 230  : 		// GetProcAddress case insensative ?????
; 231  : 		if( !Q_stricmp( name, (const char *)CALCULATE_ADDRESS( codeBase, *nameRef )))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _nameRef$[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@MemoryGetP

; 232  : 		{
; 233  : 			idx = *ordinal;

	mov	eax, DWORD PTR _ordinal$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR _idx$[ebp], ecx

; 234  : 			break;

	jmp	SHORT $LN3@MemoryGetP
$LN8@MemoryGetP:

; 235  : 		}
; 236  : 	}

	jmp	SHORT $LN2@MemoryGetP
$LN3@MemoryGetP:

; 237  : 
; 238  : 	if( idx == -1 )

	cmp	DWORD PTR _idx$[ebp], -1
	jne	SHORT $LN9@MemoryGetP

; 239  : 	{
; 240  : 		// exported symbol not found
; 241  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@MemoryGetP
$LN9@MemoryGetP:

; 242  : 	}
; 243  : 
; 244  : 	if((DWORD)idx > exports->NumberOfFunctions )

	mov	edx, DWORD PTR _exports$[ebp]
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jbe	SHORT $LN10@MemoryGetP

; 245  : 	{
; 246  : 		// name <-> ordinal number don't match
; 247  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@MemoryGetP
$LN10@MemoryGetP:

; 248  : 	}
; 249  : 
; 250  : 	// addressOfFunctions contains the RVAs to the "real" functions
; 251  : 	return (FARPROC)CALCULATE_ADDRESS( codeBase, *(DWORD *)CALCULATE_ADDRESS( codeBase, exports->AddressOfFunctions + (idx * 4)));

	mov	ecx, DWORD PTR _exports$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _idx$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _codeBase$[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx+ecx]
$LN1@MemoryGetP:

; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MemoryGetProcAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_offset$1 = -40						; size = 4
_dest$2 = -36						; size = 4
_type$3 = -32						; size = 4
_patchAddrHL$4 = -28					; size = 4
tv88 = -24						; size = 4
_codeBase$ = -20					; size = 4
_directory$ = -16					; size = 4
_i$ = -12						; size = 4
_relInfo$5 = -8						; size = 4
_relocation$6 = -4					; size = 4
_module$ = 8						; size = 4
_delta$ = 12						; size = 4
_PerformBaseRelocation PROC

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 157  : 	PIMAGE_DATA_DIRECTORY	directory = GET_HEADER_DICTIONARY( module, IMAGE_DIRECTORY_ENTRY_BASERELOC );

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 8
	imul	eax, edx, 5
	lea	ecx, DWORD PTR [ecx+eax+120]
	mov	DWORD PTR _directory$[ebp], ecx

; 158  : 	byte			*codeBase = module->codeBase;

	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _codeBase$[ebp], eax

; 159  : 	DWORD			i;
; 160  : 
; 161  : 	if( directory->Size > 0 )

	mov	ecx, DWORD PTR _directory$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jbe	$LN1@PerformBas

; 162  : 	{
; 163  : 		PIMAGE_BASE_RELOCATION relocation = (PIMAGE_BASE_RELOCATION)CALCULATE_ADDRESS( codeBase, directory->VirtualAddress );

	mov	edx, DWORD PTR _directory$[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _relocation$6[ebp], eax
$LN4@PerformBas:

; 164  : 		for( ; relocation->VirtualAddress > 0; )

	mov	ecx, DWORD PTR _relocation$6[ebp]
	cmp	DWORD PTR [ecx], 0
	jbe	$LN1@PerformBas

; 165  : 		{
; 166  : 			byte	*dest = (byte *)CALCULATE_ADDRESS( codeBase, relocation->VirtualAddress );

	mov	edx, DWORD PTR _relocation$6[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _dest$2[ebp], eax

; 167  : 			word	*relInfo = (word *)((byte *)relocation + IMAGE_SIZEOF_BASE_RELOCATION );

	mov	ecx, DWORD PTR _relocation$6[ebp]
	add	ecx, 8
	mov	DWORD PTR _relInfo$5[ebp], ecx

; 168  : 
; 169  : 			for( i = 0; i<((relocation->SizeOfBlock-IMAGE_SIZEOF_BASE_RELOCATION) / 2); i++, relInfo++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@PerformBas
$LN5@PerformBas:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _relInfo$5[ebp]
	add	eax, 2
	mov	DWORD PTR _relInfo$5[ebp], eax
$LN7@PerformBas:
	mov	ecx, DWORD PTR _relocation$6[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 8
	shr	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jae	SHORT $LN6@PerformBas

; 170  : 			{
; 171  : 				DWORD	*patchAddrHL;
; 172  : 				int	type, offset;
; 173  : 
; 174  : 				// the upper 4 bits define the type of relocation
; 175  : 				type = *relInfo >> 12;

	mov	eax, DWORD PTR _relInfo$5[ebp]
	movzx	ecx, WORD PTR [eax]
	sar	ecx, 12					; 0000000cH
	mov	DWORD PTR _type$3[ebp], ecx

; 176  : 				// the lower 12 bits define the offset
; 177  : 				offset = *relInfo & 0xfff;

	mov	edx, DWORD PTR _relInfo$5[ebp]
	movzx	eax, WORD PTR [edx]
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR _offset$1[ebp], eax

; 178  : 				
; 179  : 				switch( type )

	mov	ecx, DWORD PTR _type$3[ebp]
	mov	DWORD PTR tv88[ebp], ecx
	cmp	DWORD PTR tv88[ebp], 0
	je	SHORT $LN11@PerformBas
	cmp	DWORD PTR tv88[ebp], 3
	je	SHORT $LN12@PerformBas
	jmp	SHORT $LN13@PerformBas
$LN11@PerformBas:

; 180  : 				{
; 181  : 				case IMAGE_REL_BASED_ABSOLUTE:
; 182  : 					// skip relocation
; 183  : 					break;

	jmp	SHORT $LN8@PerformBas
$LN12@PerformBas:

; 184  : 				case IMAGE_REL_BASED_HIGHLOW:
; 185  : 					// change complete 32 bit address
; 186  : 					patchAddrHL = (DWORD *)CALCULATE_ADDRESS( dest, offset );

	mov	edx, DWORD PTR _dest$2[ebp]
	add	edx, DWORD PTR _offset$1[ebp]
	mov	DWORD PTR _patchAddrHL$4[ebp], edx

; 187  : 					*patchAddrHL += delta;

	mov	eax, DWORD PTR _patchAddrHL$4[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _delta$[ebp]
	mov	edx, DWORD PTR _patchAddrHL$4[ebp]
	mov	DWORD PTR [edx], ecx

; 188  : 					break;

	jmp	SHORT $LN8@PerformBas
$LN13@PerformBas:

; 189  : 				default:
; 190  : 					Con_Reportf( S_ERROR "PerformBaseRelocation: unknown relocation: %d\n", type );

	mov	eax, DWORD PTR _type$3[ebp]
	push	eax
	push	OFFSET $SG130037
	call	_Con_Reportf
	add	esp, 8
$LN8@PerformBas:

; 191  : 					break;
; 192  : 				}
; 193  : 			}

	jmp	SHORT $LN5@PerformBas
$LN6@PerformBas:

; 194  : 
; 195  : 			// advance to next relocation block
; 196  : 			relocation = (PIMAGE_BASE_RELOCATION)CALCULATE_ADDRESS( relocation, relocation->SizeOfBlock );

	mov	ecx, DWORD PTR _relocation$6[ebp]
	mov	edx, DWORD PTR _relocation$6[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _relocation$6[ebp], edx

; 197  : 		}

	jmp	$LN4@PerformBas
$LN1@PerformBas:

; 198  : 	}
; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PerformBaseRelocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_oldProtect$1 = -44					; size = 4
_writeable$2 = -40					; size = 4
_readable$3 = -36					; size = 4
_executable$4 = -32					; size = 4
tv87 = -28						; size = 4
tv83 = -24						; size = 4
tv79 = -20						; size = 4
_protect$5 = -16					; size = 4
_i$ = -12						; size = 4
_size$6 = -8						; size = 4
_section$ = -4						; size = 4
_module$ = 8						; size = 4
_FinalizeSections PROC

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 112  : 	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION( module->headers );

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	edx, WORD PTR [eax+20]
	lea	eax, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _section$[ebp], eax

; 113  : 	int	i;
; 114  : 	
; 115  : 	// loop through all sections and change access flags
; 116  : 	for( i = 0; i < module->headers->FileHeader.NumberOfSections; i++, section++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FinalizeSe
$LN2@FinalizeSe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _section$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR _section$[ebp], edx
$LN4@FinalizeSe:
	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx+6]
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN1@FinalizeSe

; 117  : 	{
; 118  : 		DWORD	protect, oldProtect, size;
; 119  : 		int	executable = (section->Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;

	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 536870912				; 20000000H
	je	SHORT $LN14@FinalizeSe
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN15@FinalizeSe
$LN14@FinalizeSe:
	mov	DWORD PTR tv79[ebp], 0
$LN15@FinalizeSe:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _executable$4[ebp], edx

; 120  : 		int	readable = (section->Characteristics & IMAGE_SCN_MEM_READ) != 0;

	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN16@FinalizeSe
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN17@FinalizeSe
$LN16@FinalizeSe:
	mov	DWORD PTR tv83[ebp], 0
$LN17@FinalizeSe:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _readable$3[ebp], edx

; 121  : 		int	writeable = (section->Characteristics & IMAGE_SCN_MEM_WRITE) != 0;

	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN18@FinalizeSe
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN19@FinalizeSe
$LN18@FinalizeSe:
	mov	DWORD PTR tv87[ebp], 0
$LN19@FinalizeSe:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _writeable$2[ebp], edx

; 122  : 
; 123  : 		if( section->Characteristics & IMAGE_SCN_MEM_DISCARDABLE )

	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 33554432				; 02000000H
	je	SHORT $LN5@FinalizeSe

; 124  : 		{
; 125  : 			// section is not needed any more and can safely be freed
; 126  : 			VirtualFree((LPVOID)section->Misc.PhysicalAddress, section->SizeOfRawData, MEM_DECOMMIT);

	push	16384					; 00004000H
	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _section$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__VirtualFree@12

; 127  : 			continue;

	jmp	$LN2@FinalizeSe
$LN5@FinalizeSe:

; 128  : 		}
; 129  : 
; 130  : 		// determine protection flags based on characteristics
; 131  : 		protect = ProtectionFlags[executable][readable][writeable];

	mov	eax, DWORD PTR _executable$4[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _readable$3[ebp]
	lea	edx, DWORD PTR _ProtectionFlags[eax+ecx*8]
	mov	eax, DWORD PTR _writeable$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _protect$5[ebp], ecx

; 132  : 		if( section->Characteristics & IMAGE_SCN_MEM_NOT_CACHED )

	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 67108864				; 04000000H
	je	SHORT $LN6@FinalizeSe

; 133  : 			protect |= PAGE_NOCACHE;

	mov	ecx, DWORD PTR _protect$5[ebp]
	or	ecx, 512				; 00000200H
	mov	DWORD PTR _protect$5[ebp], ecx
$LN6@FinalizeSe:

; 134  : 
; 135  : 		// determine size of region
; 136  : 		size = section->SizeOfRawData;

	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _size$6[ebp], eax

; 137  : 
; 138  : 		if( size == 0 )

	cmp	DWORD PTR _size$6[ebp], 0
	jne	SHORT $LN7@FinalizeSe

; 139  : 		{
; 140  : 			if( section->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA )

	mov	ecx, DWORD PTR _section$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 64					; 00000040H
	je	SHORT $LN8@FinalizeSe

; 141  : 				size = module->headers->OptionalHeader.SizeOfInitializedData;

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _size$6[ebp], edx
	jmp	SHORT $LN7@FinalizeSe
$LN8@FinalizeSe:

; 142  : 			else if( section->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA )

	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 128				; 00000080H
	je	SHORT $LN7@FinalizeSe

; 143  : 				size = module->headers->OptionalHeader.SizeOfUninitializedData;

	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _size$6[ebp], ecx
$LN7@FinalizeSe:

; 144  : 		}
; 145  : 
; 146  : 		if( size > 0 )

	cmp	DWORD PTR _size$6[ebp], 0
	jbe	SHORT $LN11@FinalizeSe

; 147  : 		{         
; 148  : 			// change memory access flags
; 149  : 			if( !VirtualProtect((LPVOID)section->Misc.PhysicalAddress, size, protect, &oldProtect ))

	lea	edx, DWORD PTR _oldProtect$1[ebp]
	push	edx
	mov	eax, DWORD PTR _protect$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__VirtualProtect@16
	test	eax, eax
	jne	SHORT $LN11@FinalizeSe

; 150  : 				Sys_Error( "error protecting memory page\n" );

	push	OFFSET $SG129997
	call	_Sys_Error
	add	esp, 4
$LN11@FinalizeSe:

; 151  : 		}
; 152  : 	}

	jmp	$LN2@FinalizeSe
$LN1@FinalizeSe:

; 153  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeSections ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_codeBase$ = -16					; size = 4
_size$ = -12						; size = 4
_i$ = -8						; size = 4
_section$ = -4						; size = 4
_old_headers$ = 8					; size = 4
_module$ = 12						; size = 4
_FreeSections PROC

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 88   : 	PIMAGE_SECTION_HEADER	section = IMAGE_FIRST_SECTION(module->headers);

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	edx, WORD PTR [eax+20]
	lea	eax, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _section$[ebp], eax

; 89   : 	byte			*codeBase = module->codeBase;

	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _codeBase$[ebp], edx

; 90   : 	int			i, size;
; 91   : 
; 92   : 	for( i = 0; i < module->headers->FileHeader.NumberOfSections; i++, section++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FreeSectio
$LN2@FreeSectio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _section$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _section$[ebp], ecx
$LN4@FreeSectio:
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, WORD PTR [eax+6]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN1@FreeSectio

; 93   : 	{
; 94   : 		if( section->SizeOfRawData == 0 )

	mov	edx, DWORD PTR _section$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN5@FreeSectio

; 95   : 		{
; 96   : 			size = old_headers->OptionalHeader.SectionAlignment;

	mov	eax, DWORD PTR _old_headers$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _size$[ebp], ecx

; 97   : 			if( size > 0 )

	cmp	DWORD PTR _size$[ebp], 0
	jle	SHORT $LN6@FreeSectio

; 98   : 			{
; 99   : 				VirtualFree((byte *)CALCULATE_ADDRESS( codeBase, section->VirtualAddress ), size, MEM_DECOMMIT );

	push	16384					; 00004000H
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__VirtualFree@12

; 100  : 				section->Misc.PhysicalAddress = 0;

	mov	edx, DWORD PTR _section$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN6@FreeSectio:

; 101  : 			}
; 102  : 			continue;

	jmp	SHORT $LN2@FreeSectio
$LN5@FreeSectio:

; 103  : 		}
; 104  : 
; 105  : 		VirtualFree((byte *)CALCULATE_ADDRESS( codeBase, section->VirtualAddress ), section->SizeOfRawData, MEM_DECOMMIT );

	push	16384					; 00004000H
	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__VirtualFree@12

; 106  : 		section->Misc.PhysicalAddress = 0;

	mov	ecx, DWORD PTR _section$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 107  : 	}

	jmp	$LN2@FreeSectio
$LN1@FreeSectio:

; 108  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FreeSections ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_codeBase$ = -20					; size = 4
_size$ = -16						; size = 4
_i$ = -12						; size = 4
_dest$ = -8						; size = 4
_section$ = -4						; size = 4
_data$ = 8						; size = 4
_old_headers$ = 12					; size = 4
_module$ = 16						; size = 4
_CopySections PROC

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 56   : 	PIMAGE_SECTION_HEADER	section = IMAGE_FIRST_SECTION( module->headers );

	mov	eax, DWORD PTR _module$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	edx, WORD PTR [eax+20]
	lea	eax, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR _section$[ebp], eax

; 57   : 	byte			*codeBase = module->codeBase;

	mov	ecx, DWORD PTR _module$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _codeBase$[ebp], edx

; 58   : 	int			i, size;
; 59   : 	byte			*dest;
; 60   : 
; 61   : 	for( i = 0; i < module->headers->FileHeader.NumberOfSections; i++, section++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CopySectio
$LN2@CopySectio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _section$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _section$[ebp], ecx
$LN4@CopySectio:
	mov	edx, DWORD PTR _module$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, WORD PTR [eax+6]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN1@CopySectio

; 62   : 	{
; 63   : 		if( section->SizeOfRawData == 0 )

	mov	edx, DWORD PTR _section$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN5@CopySectio

; 64   : 		{
; 65   : 			// section doesn't contain data in the dll itself, but may define
; 66   : 			// uninitialized data
; 67   : 			size = old_headers->OptionalHeader.SectionAlignment;

	mov	eax, DWORD PTR _old_headers$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _size$[ebp], ecx

; 68   : 
; 69   : 			if( size > 0 )

	cmp	DWORD PTR _size$[ebp], 0
	jle	SHORT $LN6@CopySectio

; 70   : 			{
; 71   : 				dest = (byte *)VirtualAlloc((byte *)CALCULATE_ADDRESS(codeBase, section->VirtualAddress), size, MEM_COMMIT, PAGE_READWRITE );

	push	4
	push	4096					; 00001000H
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR _codeBase$[ebp]
	add	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _dest$[ebp], eax

; 72   : 				section->Misc.PhysicalAddress = (DWORD)dest;

	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+8], eax

; 73   : 				memset( dest, 0, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@CopySectio:

; 74   : 			}
; 75   : 			// section is empty
; 76   : 			continue;

	jmp	SHORT $LN2@CopySectio
$LN5@CopySectio:

; 77   : 		}
; 78   : 
; 79   : 		// commit memory block and copy data from dll
; 80   : 		dest = (byte *)VirtualAlloc((byte *)CALCULATE_ADDRESS(codeBase, section->VirtualAddress), section->SizeOfRawData, MEM_COMMIT, PAGE_READWRITE );

	push	4
	push	4096					; 00001000H
	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _section$[ebp]
	mov	eax, DWORD PTR _codeBase$[ebp]
	add	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _dest$[ebp], eax

; 81   : 		memcpy( dest, (byte *)CALCULATE_ADDRESS(data, section->PointerToRawData), section->SizeOfRawData );

	mov	ecx, DWORD PTR _section$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 82   : 		section->Misc.PhysicalAddress = (DWORD)dest;

	mov	eax, DWORD PTR _section$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 83   : 	}

	jmp	$LN2@CopySectio
$LN1@CopySectio:

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CopySections ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_hInst$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_COM_FreeLibrary PROC

; 826  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 827  : 	dll_user_t *hInst = (dll_user_t *)hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst$[ebp], eax

; 828  : 
; 829  : 	if( !hInst || !hInst->hInstance )

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $LN3@COM_FreeLi
	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN2@COM_FreeLi
$LN3@COM_FreeLi:

; 830  : 		return; // already freed

	jmp	$LN1@COM_FreeLi
$LN2@COM_FreeLi:

; 831  : 
; 832  : 	if( host.status == HOST_CRASHED )

	cmp	DWORD PTR _host+12, 6
	jne	SHORT $LN4@COM_FreeLi

; 833  : 	{
; 834  : 		// we need to hold down all modules, while MSVC can find error
; 835  : 		Con_Reportf( "Sys_FreeLibrary: hold %s for debugging\n", hInst->dllName );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	push	OFFSET $SG130412
	call	_Con_Reportf
	add	esp, 8

; 836  : 		return;

	jmp	SHORT $LN1@COM_FreeLi

; 837  : 	}

	jmp	SHORT $LN5@COM_FreeLi
$LN4@COM_FreeLi:

; 838  : 	else Con_Reportf( "Sys_FreeLibrary: Unloading %s\n", hInst->dllName );

	mov	eax, DWORD PTR _hInst$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET $SG130413
	call	_Con_Reportf
	add	esp, 8
$LN5@COM_FreeLi:

; 839  : 	
; 840  : 	if( hInst->custom_loader )

	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN6@COM_FreeLi

; 841  : 		MemoryFreeLibrary( hInst->hInstance );

	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_MemoryFreeLibrary
	add	esp, 4
	jmp	SHORT $LN7@COM_FreeLi
$LN6@COM_FreeLi:

; 842  : 	else FreeLibrary( hInst->hInstance );

	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4
$LN7@COM_FreeLi:

; 843  : 
; 844  : 	hInst->hInstance = NULL;

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [eax], 0

; 845  : 
; 846  : 	if( hInst->num_ordinals )

	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx+16948], 0
	je	SHORT $LN8@COM_FreeLi

; 847  : 		FreeNameFuncGlobals( hInst );

	mov	edx, DWORD PTR _hInst$[ebp]
	push	edx
	call	_FreeNameFuncGlobals
	add	esp, 4
$LN8@COM_FreeLi:

; 848  : 	Mem_Free( hInst );	// done

	push	848					; 00000350H
	push	OFFSET $SG130417
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@COM_FreeLi:

; 849  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FreeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_index$ = -12						; size = 4
_i$ = -8						; size = 4
_hInst$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_pName$ = 12						; size = 4
_COM_FunctionFromName PROC

; 852  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 853  : 	dll_user_t	*hInst = (dll_user_t *)hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst$[ebp], eax

; 854  : 	int		i, index;
; 855  : 
; 856  : 	if( !hInst || !hInst->hInstance )

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $LN6@COM_Functi
	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@COM_Functi
$LN6@COM_Functi:

; 857  : 		return 0;

	xor	eax, eax
	jmp	$LN1@COM_Functi
$LN5@COM_Functi:

; 858  : 
; 859  : 	for( i = 0; i < hInst->num_ordinals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_Functi
$LN2@COM_Functi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@COM_Functi:
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16948]
	jge	SHORT $LN3@COM_Functi

; 860  : 	{
; 861  : 		if( !Q_strcmp( pName, hInst->names[i] ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+564]
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@COM_Functi

; 862  : 		{
; 863  : 			index = hInst->ordinals[i];

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, WORD PTR [ecx+edx*2]
	mov	DWORD PTR _index$[ebp], eax

; 864  : 			return hInst->funcs[index] + hInst->funcBase;

	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx+560]
	mov	eax, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _hInst$[ebp]
	add	eax, DWORD PTR [ecx+16952]
	jmp	SHORT $LN1@COM_Functi
$LN7@COM_Functi:

; 865  : 		}
; 866  : 	}

	jmp	SHORT $LN2@COM_Functi
$LN3@COM_Functi:

; 867  : 
; 868  : 	// couldn't find the function name to return address
; 869  : 	Con_Printf( "Can't find proc: %s\n", pName );

	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG130433
	call	_Con_Printf
	add	esp, 8

; 870  : 
; 871  : 	return 0;

	xor	eax, eax
$LN1@COM_Functi:

; 872  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FunctionFromName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_index$ = -12						; size = 4
_i$ = -8						; size = 4
_hInst$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_function$ = 12						; size = 4
_COM_NameForFunction PROC

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 876  : 	dll_user_t	*hInst = (dll_user_t *)hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst$[ebp], eax

; 877  : 	int		i, index;
; 878  : 
; 879  : 	if( !hInst || !hInst->hInstance )

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $LN6@COM_NameFo
	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@COM_NameFo
$LN6@COM_NameFo:

; 880  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@COM_NameFo
$LN5@COM_NameFo:

; 881  : 
; 882  : 	for( i = 0; i < hInst->num_ordinals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_NameFo
$LN2@COM_NameFo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@COM_NameFo:
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16948]
	jge	SHORT $LN3@COM_NameFo

; 883  : 	{
; 884  : 		index = hInst->ordinals[i];

	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [edx+556]
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, WORD PTR [eax+ecx*2]
	mov	DWORD PTR _index$[ebp], edx

; 885  : 
; 886  : 		if(( function - hInst->funcBase ) == hInst->funcs[index] )

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR _function$[ebp]
	sub	ecx, DWORD PTR [eax+16952]
	mov	edx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [edx+560]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4]
	jne	SHORT $LN7@COM_NameFo

; 887  : 			return hInst->names[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+564]
	jmp	SHORT $LN1@COM_NameFo
$LN7@COM_NameFo:

; 888  : 	}

	jmp	SHORT $LN2@COM_NameFo
$LN3@COM_NameFo:

; 889  : 
; 890  : 	// couldn't find the function address to return name
; 891  : 	Con_Printf( "Can't find address: %08lx\n", function );

	mov	edx, DWORD PTR _function$[ebp]
	push	edx
	push	OFFSET $SG130451
	call	_Con_Printf
	add	esp, 8

; 892  : 
; 893  : 	return NULL;

	xor	eax, eax
$LN1@COM_NameFo:

; 894  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_COM_NameForFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_hInst$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_name$ = 12						; size = 4
_COM_GetProcAddress PROC

; 814  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 815  : 	dll_user_t *hInst = (dll_user_t *)hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst$[ebp], eax

; 816  : 
; 817  : 	if( !hInst || !hInst->hInstance )

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $LN3@COM_GetPro
	mov	ecx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN2@COM_GetPro
$LN3@COM_GetPro:

; 818  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@COM_GetPro
$LN2@COM_GetPro:

; 819  : 
; 820  : 	if( hInst->custom_loader )

	mov	edx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN4@COM_GetPro

; 821  : 		return (void *)MemoryGetProcAddress( hInst->hInstance, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_MemoryGetProcAddress
	add	esp, 8
	jmp	SHORT $LN1@COM_GetPro
$LN4@COM_GetPro:

; 822  : 	return (void *)GetProcAddress( hInst->hInstance, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
$LN1@COM_GetPro:

; 823  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_COM_GetProcAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\library.c
_TEXT	SEGMENT
_hInst$ = -4						; size = 4
_dllname$ = 8						; size = 4
_build_ordinals_table$ = 12				; size = 4
_directpath$ = 16					; size = 4
_COM_LoadLibrary PROC

; 772  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 773  : 	dll_user_t *hInst;
; 774  : 
; 775  : 	hInst = FS_FindLibrary( dllname, directpath );

	mov	eax, DWORD PTR _directpath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dllname$[ebp]
	push	ecx
	call	_FS_FindLibrary
	add	esp, 8
	mov	DWORD PTR _hInst$[ebp], eax

; 776  : 	if( !hInst ) return NULL; // nothing to load

	cmp	DWORD PTR _hInst$[ebp], 0
	jne	SHORT $LN2@COM_LoadLi
	xor	eax, eax
	jmp	$LN1@COM_LoadLi
$LN2@COM_LoadLi:

; 777  : 		
; 778  : 	if( hInst->custom_loader )

	mov	edx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN3@COM_LoadLi

; 779  : 	{
; 780  :           	if( hInst->encrypted )

	mov	eax, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@COM_LoadLi

; 781  : 		{
; 782  : 			Con_Printf( S_ERROR "LoadLibrary: couldn't load encrypted library %s\n", dllname );

	mov	ecx, DWORD PTR _dllname$[ebp]
	push	ecx
	push	OFFSET $SG130382
	call	_Con_Printf
	add	esp, 8

; 783  : 			return NULL;

	xor	eax, eax
	jmp	$LN1@COM_LoadLi
$LN5@COM_LoadLi:

; 784  : 		}
; 785  : 
; 786  : 		hInst->hInstance = MemoryLoadLibrary( hInst->fullPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	_MemoryLoadLibrary
	add	esp, 4
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx], eax

; 787  : 	}

	jmp	SHORT $LN4@COM_LoadLi
$LN3@COM_LoadLi:

; 788  : 	else hInst->hInstance = LoadLibrary( hInst->fullPath );

	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@COM_LoadLi:

; 789  : 
; 790  : 	if( !hInst->hInstance )

	mov	edx, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN6@COM_LoadLi

; 791  : 	{
; 792  : 		Con_Reportf( "LoadLibrary: Loading %s - failed\n", dllname );

	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	push	OFFSET $SG130384
	call	_Con_Reportf
	add	esp, 8

; 793  : 		COM_FreeLibrary( hInst );

	mov	ecx, DWORD PTR _hInst$[ebp]
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4

; 794  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@COM_LoadLi
$LN6@COM_LoadLi:

; 795  : 	}
; 796  : 
; 797  : 	// if not set - FunctionFromName and NameForFunction will not working
; 798  : 	if( build_ordinals_table )

	cmp	DWORD PTR _build_ordinals_table$[ebp], 0
	je	SHORT $LN7@COM_LoadLi

; 799  : 	{
; 800  : 		if( !LibraryLoadSymbols( hInst ))

	mov	edx, DWORD PTR _hInst$[ebp]
	push	edx
	call	_LibraryLoadSymbols
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@COM_LoadLi

; 801  : 		{
; 802  : 			Con_Reportf( "LoadLibrary: Loading %s - failed\n", dllname );

	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	push	OFFSET $SG130387
	call	_Con_Reportf
	add	esp, 8

; 803  : 			COM_FreeLibrary( hInst );

	mov	ecx, DWORD PTR _hInst$[ebp]
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4

; 804  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@COM_LoadLi
$LN7@COM_LoadLi:

; 805  : 		}
; 806  : 	}
; 807  : 
; 808  : 	Con_Reportf( "LoadLibrary: Loading %s - ok\n", dllname );

	mov	edx, DWORD PTR _dllname$[ebp]
	push	edx
	push	OFFSET $SG130388
	call	_Con_Reportf
	add	esp, 8

; 809  : 
; 810  : 	return hInst;

	mov	eax, DWORD PTR _hInst$[ebp]
$LN1@COM_LoadLi:

; 811  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_COM_LoadLibrary ENDP
_TEXT	ENDS
END
