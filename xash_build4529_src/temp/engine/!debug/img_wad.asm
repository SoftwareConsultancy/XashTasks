; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Image_LoadMIP
PUBLIC	_Image_LoadMDL
PUBLIC	_Image_LoadSPR
PUBLIC	_Image_LoadFNT
PUBLIC	_Image_LoadLMP
PUBLIC	_Image_LoadPAL
PUBLIC	__real@3b800000
EXTRN	_memcpy:PROC
EXTRN	_Q_strrchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_stristr:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Image_AddIndexedImageToPack:PROC
EXTRN	_Image_GetPaletteLMP:PROC
EXTRN	_Image_ComparePalette:PROC
EXTRN	_Image_CopyPalette32bit:PROC
EXTRN	_Image_GetPaletteQ1:PROC
EXTRN	_Image_ValidSize:PROC
EXTRN	_Image_LumpValidSize:PROC
EXTRN	_Image_CheckFlag:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3b800000
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
_DATA	SEGMENT
$SG132162 DB	'^1Error:^7 Image_LoadPAL: (%s) have invalid size (%d sho'
	DB	'uld be %d)', 0aH, 00H
$SG132166 DB	'normal', 00H
	ORG $+1
$SG132169 DB	'masked', 00H
	ORG $+1
$SG132172 DB	'gradient', 00H
	ORG $+3
$SG132175 DB	'valve', 00H
	ORG $+2
$SG132177 DB	'id', 00H
	ORG $+1
$SG132277 DB	'palette.lmp', 00H
$SG132247 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_wad.c', 00H
$SG132280 DB	'conchars', 00H
	ORG $+3
$SG132354 DB	'sky', 00H
$SG132358 DB	'water', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
_TEXT	SEGMENT
_rendermode$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadPAL PROC

; 29   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 30   : 	int	rendermode = LUMP_NORMAL; 

	mov	DWORD PTR _rendermode$[ebp], 0

; 31   : 
; 32   : 	if( filesize != 768 )

	cmp	DWORD PTR _filesize$[ebp], 768		; 00000300H
	je	SHORT $LN2@Image_Load

; 33   : 	{
; 34   : 		Con_DPrintf( S_ERROR "Image_LoadPAL: (%s) have invalid size (%d should be %d)\n", name, filesize, 768 );

	push	768					; 00000300H
	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG132162
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 35   : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN2@Image_Load:

; 36   : 	}
; 37   : 
; 38   : 	if( name[0] == '#' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	$LN3@Image_Load

; 39   : 	{
; 40   : 		// using palette name as rendermode
; 41   : 		if( Q_stristr( name, "normal" ))

	push	OFFSET $SG132166
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@Image_Load

; 42   : 			rendermode = LUMP_NORMAL;

	mov	DWORD PTR _rendermode$[ebp], 0
	jmp	$LN3@Image_Load
$LN4@Image_Load:

; 43   : 		else if( Q_stristr( name, "masked" ))

	push	OFFSET $SG132169
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Image_Load

; 44   : 			rendermode = LUMP_MASKED;

	mov	DWORD PTR _rendermode$[ebp], 1
	jmp	SHORT $LN3@Image_Load
$LN6@Image_Load:

; 45   : 		else if( Q_stristr( name, "gradient" ))

	push	OFFSET $SG132172
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@Image_Load

; 46   : 			rendermode = LUMP_GRADIENT;

	mov	DWORD PTR _rendermode$[ebp], 2
	jmp	SHORT $LN3@Image_Load
$LN8@Image_Load:

; 47   : 		else if( Q_stristr( name, "valve" ))

	push	OFFSET $SG132175
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@Image_Load

; 48   : 		{
; 49   : 			rendermode = LUMP_HALFLIFE;

	mov	DWORD PTR _rendermode$[ebp], 4

; 50   : 			buffer = NULL; // force to get HL palette

	mov	DWORD PTR _buffer$[ebp], 0

; 51   : 		}

	jmp	SHORT $LN3@Image_Load
$LN10@Image_Load:

; 52   : 		else if( Q_stristr( name, "id" ))

	push	OFFSET $SG132177
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@Image_Load

; 53   : 		{
; 54   : 			rendermode = LUMP_QUAKE1;

	mov	DWORD PTR _rendermode$[ebp], 5

; 55   : 			buffer = NULL; // force to get Q1 palette

	mov	DWORD PTR _buffer$[ebp], 0
$LN3@Image_Load:

; 56   : 		}
; 57   : 	}
; 58   : 
; 59   : 	// NOTE: image.d_currentpal not cleared with Image_Reset()
; 60   : 	// and stay valid any time before new call of Image_SetPalette
; 61   : 	Image_GetPaletteLMP( buffer, rendermode );

	mov	edx, DWORD PTR _rendermode$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8

; 62   : 	Image_CopyPalette32bit();

	call	_Image_CopyPalette32bit

; 63   : 
; 64   : 	image.rgba = NULL;	// only palette, not real image

	mov	DWORD PTR _image+40, 0

; 65   : 	image.size = 1024;	// expanded palette

	mov	DWORD PTR _image+28, 1024		; 00000400H

; 66   : 	image.width = image.height = 0;

	xor	ecx, ecx
	mov	WORD PTR _image+10, cx
	mov	dx, WORD PTR _image+10
	mov	WORD PTR _image+8, dx

; 67   : 	image.depth = 1;

	mov	eax, 1
	mov	WORD PTR _image+12, ax

; 68   : 	
; 69   : 	return true;

	mov	eax, 1
$LN1@Image_Load:

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadPAL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
_TEXT	SEGMENT
_lmp$ = -32						; size = 8
_numcolors$1 = -24					; size = 4
_rendermode$ = -20					; size = 4
_pixels$ = -16						; size = 4
_pal$ = -12						; size = 4
_fin$ = -8						; size = 4
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadLMP PROC

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 251  : 	lmp_t	lmp;
; 252  : 	byte	*fin, *pal;
; 253  : 	int	rendermode;
; 254  : 	int	i, pixels;
; 255  : 
; 256  : 	if( filesize < sizeof( lmp ))

	cmp	DWORD PTR _filesize$[ebp], 8
	jae	SHORT $LN8@Image_Load

; 257  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN8@Image_Load:

; 258  : 
; 259  : 	// valve software trick (particle palette)
; 260  : 	if( Q_stristr( name, "palette.lmp" ))

	push	OFFSET $SG132277
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@Image_Load

; 261  : 		return Image_LoadPAL( name, buffer, filesize );

	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_LoadPAL
	add	esp, 12					; 0000000cH
	jmp	$LN1@Image_Load
$LN9@Image_Load:

; 262  : 
; 263  : 	// id software trick (image without header)
; 264  : 	if( Q_stristr( name, "conchars" ) && filesize == 16384 )

	push	OFFSET $SG132280
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@Image_Load
	cmp	DWORD PTR _filesize$[ebp], 16384	; 00004000H
	jne	SHORT $LN10@Image_Load

; 265  : 	{
; 266  : 		image.width = image.height = 128;

	mov	edx, 128				; 00000080H
	mov	WORD PTR _image+10, dx
	mov	ax, WORD PTR _image+10
	mov	WORD PTR _image+8, ax

; 267  : 		rendermode = LUMP_QUAKE1;

	mov	DWORD PTR _rendermode$[ebp], 5

; 268  : 		filesize += sizeof( lmp );

	mov	ecx, DWORD PTR _filesize$[ebp]
	add	ecx, 8
	mov	DWORD PTR _filesize$[ebp], ecx

; 269  : 		fin = (byte *)buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _fin$[ebp], edx

; 270  : 
; 271  : 		// need to remap transparent color from first to last entry
; 272  : 		for( i = 0; i < 16384; i++ ) if( !fin[i] ) fin[i] = 0xFF;

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Load
$LN2@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Load:
	cmp	DWORD PTR _i$[ebp], 16384		; 00004000H
	jge	SHORT $LN3@Image_Load
	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN12@Image_Load
	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
$LN12@Image_Load:
	jmp	SHORT $LN2@Image_Load
$LN3@Image_Load:

; 273  : 	}

	jmp	SHORT $LN11@Image_Load
$LN10@Image_Load:

; 274  : 	else
; 275  : 	{
; 276  : 		fin = (byte *)buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _fin$[ebp], ecx

; 277  : 		memcpy( &lmp, fin, sizeof( lmp ));

	push	8
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	lea	eax, DWORD PTR _lmp$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 278  : 		image.width = lmp.width;

	mov	cx, WORD PTR _lmp$[ebp]
	mov	WORD PTR _image+8, cx

; 279  : 		image.height = lmp.height;

	mov	dx, WORD PTR _lmp$[ebp+4]
	mov	WORD PTR _image+10, dx

; 280  : 		rendermode = LUMP_NORMAL;

	mov	DWORD PTR _rendermode$[ebp], 0

; 281  : 		fin += sizeof( lmp );

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _fin$[ebp], eax
$LN11@Image_Load:

; 282  : 	}
; 283  : 
; 284  : 	pixels = image.width * image.height;

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	mov	DWORD PTR _pixels$[ebp], ecx

; 285  : 
; 286  : 	if( filesize < sizeof( lmp ) + pixels )

	mov	eax, DWORD PTR _pixels$[ebp]
	add	eax, 8
	cmp	DWORD PTR _filesize$[ebp], eax
	jae	SHORT $LN13@Image_Load

; 287  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN13@Image_Load:

; 288  : 
; 289  : 	if( !Image_ValidSize( name ))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@Image_Load

; 290  : 		return false;         

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN14@Image_Load:

; 291  : 
; 292  : 	if( image.hint != IL_HINT_Q1 && filesize > (int)sizeof(lmp) + pixels )

	cmp	DWORD PTR _image+80, 1
	je	SHORT $LN15@Image_Load
	mov	edx, DWORD PTR _pixels$[ebp]
	add	edx, 8
	cmp	DWORD PTR _filesize$[ebp], edx
	jbe	SHORT $LN15@Image_Load

; 293  : 	{
; 294  : 		int	numcolors;
; 295  : 
; 296  : 		for( i = 0; i < pixels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Load
$LN5@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Load:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _pixels$[ebp]
	jge	SHORT $LN6@Image_Load

; 297  : 		{
; 298  : 			if( fin[i] == 255 )

	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN17@Image_Load

; 299  : 			{
; 300  : 				image.flags |= IMAGE_HAS_ALPHA;

	mov	ecx, DWORD PTR _image+24
	or	ecx, 2
	mov	DWORD PTR _image+24, ecx

; 301  : 				rendermode = LUMP_MASKED;

	mov	DWORD PTR _rendermode$[ebp], 1

; 302  : 				break;

	jmp	SHORT $LN6@Image_Load
$LN17@Image_Load:

; 303  : 			}
; 304  : 		}

	jmp	SHORT $LN5@Image_Load
$LN6@Image_Load:

; 305  : 		pal = fin + pixels;

	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR _pal$[ebp], edx

; 306  : 		numcolors = *(short *)pal;

	mov	eax, DWORD PTR _pal$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _numcolors$1[ebp], ecx

; 307  : 		if( numcolors != 256 ) pal = NULL; // corrupted lump ?

	cmp	DWORD PTR _numcolors$1[ebp], 256	; 00000100H
	je	SHORT $LN18@Image_Load
	mov	DWORD PTR _pal$[ebp], 0
	jmp	SHORT $LN19@Image_Load
$LN18@Image_Load:

; 308  : 		else pal += sizeof( short );

	mov	edx, DWORD PTR _pal$[ebp]
	add	edx, 2
	mov	DWORD PTR _pal$[ebp], edx
$LN19@Image_Load:

; 309  : 	}

	jmp	SHORT $LN16@Image_Load
$LN15@Image_Load:

; 310  : 	else if( image.hint != IL_HINT_HL )

	cmp	DWORD PTR _image+80, 2
	je	SHORT $LN20@Image_Load

; 311  : 	{
; 312  : 		image.flags |= IMAGE_HAS_ALPHA;

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax

; 313  : 		rendermode = LUMP_QUAKE1;

	mov	DWORD PTR _rendermode$[ebp], 5

; 314  : 		pal = NULL;

	mov	DWORD PTR _pal$[ebp], 0

; 315  : 	}

	jmp	SHORT $LN16@Image_Load
$LN20@Image_Load:

; 316  : 	else
; 317  : 	{
; 318  : 		// unknown mode rejected
; 319  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Load
$LN16@Image_Load:

; 320  : 	}
; 321  : 
; 322  : 	Image_GetPaletteLMP( pal, rendermode );

	mov	ecx, DWORD PTR _rendermode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pal$[ebp]
	push	edx
	call	_Image_GetPaletteLMP
	add	esp, 8

; 323  : 	image.type = PF_INDEXED_32; // 32-bit palete

	mov	DWORD PTR _image+20, 2

; 324  : 	image.depth = 1;

	mov	eax, 1
	mov	WORD PTR _image+12, ax

; 325  : 
; 326  : 	return Image_AddIndexedImageToPack( fin, image.width, image.height );

	movzx	ecx, WORD PTR _image+10
	push	ecx
	movzx	edx, WORD PTR _image+8
	push	edx
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_Image_AddIndexedImageToPack
	add	esp, 12					; 0000000cH
$LN1@Image_Load:

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
_TEXT	SEGMENT
_size$ = -1064						; size = 4
_fin$ = -1060						; size = 4
_numcolors$ = -1056					; size = 4
_pal$ = -1052						; size = 4
_font$ = -1048						; size = 1044
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadFNT PROC

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1064				; 00000428H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 79   : 	qfont_t		font;
; 80   : 	const byte	*pal, *fin;
; 81   : 	size_t		size;
; 82   : 	int		numcolors;
; 83   : 
; 84   : 	if( image.hint == IL_HINT_Q1 )

	cmp	DWORD PTR _image+80, 1
	jne	SHORT $LN2@Image_Load

; 85   : 		return false; // Quake1 doesn't have qfonts

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN2@Image_Load:

; 86   : 
; 87   : 	if( filesize < sizeof( font ))

	cmp	DWORD PTR _filesize$[ebp], 1044		; 00000414H
	jae	SHORT $LN3@Image_Load

; 88   : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN3@Image_Load:

; 89   : 
; 90   : 	memcpy( &font, buffer, sizeof( font ));

	push	1044					; 00000414H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _font$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 91   : 	
; 92   : 	// last sixty four bytes - what the hell ????
; 93   : 	size = sizeof( qfont_t ) - 4 + ( font.height * font.width * QCHAR_WIDTH ) + sizeof( short ) + 768 + 64;

	mov	edx, DWORD PTR _font$[ebp+4]
	imul	edx, DWORD PTR _font$[ebp]
	shl	edx, 4
	add	edx, 1874				; 00000752H
	mov	DWORD PTR _size$[ebp], edx

; 94   : 
; 95   : 	if( size != filesize )

	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _filesize$[ebp]
	je	SHORT $LN4@Image_Load

; 96   : 	{
; 97   : 		// oldstyle font: "conchars" or "creditsfont"
; 98   : 		image.width = 256;		// hardcoded

	mov	ecx, 256				; 00000100H
	mov	WORD PTR _image+8, cx

; 99   : 		image.height = font.height;

	mov	dx, WORD PTR _font$[ebp+4]
	mov	WORD PTR _image+10, dx

; 100  : 	}

	jmp	SHORT $LN5@Image_Load
$LN4@Image_Load:

; 101  : 	else
; 102  : 	{
; 103  : 		// Half-Life 1.1.0.0 font style (qfont_t)
; 104  : 		image.width = font.width * QCHAR_WIDTH;

	mov	eax, DWORD PTR _font$[ebp]
	shl	eax, 4
	mov	WORD PTR _image+8, ax

; 105  : 		image.height = font.height;

	mov	cx, WORD PTR _font$[ebp+4]
	mov	WORD PTR _image+10, cx
$LN5@Image_Load:

; 106  : 	}
; 107  : 
; 108  : 	if( !Image_LumpValidSize( name ))

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Image_LumpValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@Image_Load

; 109  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN6@Image_Load:

; 110  : 
; 111  : 	fin = buffer + sizeof( font ) - 4;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, 1040				; 00000410H
	mov	DWORD PTR _fin$[ebp], eax

; 112  : 	pal = fin + (image.width * image.height);

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	add	ecx, DWORD PTR _fin$[ebp]
	mov	DWORD PTR _pal$[ebp], ecx

; 113  : 	numcolors = *(short *)pal, pal += sizeof( short );

	mov	eax, DWORD PTR _pal$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _numcolors$[ebp], ecx
	mov	edx, DWORD PTR _pal$[ebp]
	add	edx, 2
	mov	DWORD PTR _pal$[ebp], edx

; 114  : 
; 115  : 	if( numcolors == 768 || numcolors == 256 )

	cmp	DWORD PTR _numcolors$[ebp], 768		; 00000300H
	je	SHORT $LN9@Image_Load
	cmp	DWORD PTR _numcolors$[ebp], 256		; 00000100H
	jne	SHORT $LN7@Image_Load
$LN9@Image_Load:

; 116  : 	{
; 117  : 		// g-cont. make sure that is didn't hit anything
; 118  : 		Image_GetPaletteLMP( pal, LUMP_MASKED );

	push	1
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8

; 119  : 		image.flags |= IMAGE_HAS_ALPHA; // fonts always have transparency

	mov	ecx, DWORD PTR _image+24
	or	ecx, 2
	mov	DWORD PTR _image+24, ecx

; 120  : 	}

	jmp	SHORT $LN8@Image_Load
$LN7@Image_Load:

; 121  : 	else 
; 122  : 	{
; 123  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Load
$LN8@Image_Load:

; 124  : 	}
; 125  : 
; 126  : 	image.type = PF_INDEXED_32;	// 32-bit palette

	mov	DWORD PTR _image+20, 2

; 127  : 	image.depth = 1;

	mov	edx, 1
	mov	WORD PTR _image+12, dx

; 128  : 
; 129  : 	return Image_AddIndexedImageToPack( fin, image.width, image.height );

	movzx	eax, WORD PTR _image+10
	push	eax
	movzx	ecx, WORD PTR _image+8
	push	ecx
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	call	_Image_AddIndexedImageToPack
	add	esp, 12					; 0000000cH
$LN1@Image_Load:

; 130  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadFNT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
_TEXT	SEGMENT
tv82 = -16						; size = 4
_truecolor$ = -12					; size = 4
tv83 = -8						; size = 4
_pin$ = -4						; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadSPR PROC

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 	dspriteframe_t	*pin;	// identical for q1\hl sprites
; 188  : 	qboolean		truecolor = false;

	mov	DWORD PTR _truecolor$[ebp], 0

; 189  : 
; 190  : 	if( image.hint == IL_HINT_HL )

	cmp	DWORD PTR _image+80, 2
	jne	SHORT $LN4@Image_Load

; 191  : 	{
; 192  : 		if( !image.d_currentpal )

	cmp	DWORD PTR _image+64, 0
	jne	SHORT $LN6@Image_Load

; 193  : 			return false;		

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN6@Image_Load:

; 194  : 	}

	jmp	SHORT $LN5@Image_Load
$LN4@Image_Load:

; 195  : 	else if( image.hint == IL_HINT_Q1 )

	cmp	DWORD PTR _image+80, 1
	jne	SHORT $LN7@Image_Load

; 196  : 	{
; 197  : 		Image_GetPaletteQ1();

	call	_Image_GetPaletteQ1

; 198  : 	}

	jmp	SHORT $LN5@Image_Load
$LN7@Image_Load:

; 199  : 	else
; 200  : 	{
; 201  : 		// unknown mode rejected
; 202  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN5@Image_Load:

; 203  : 	}
; 204  : 
; 205  : 	pin = (dspriteframe_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pin$[ebp], eax

; 206  : 	image.width = pin->width;

	mov	ecx, DWORD PTR _pin$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR _image+8, dx

; 207  : 	image.height = pin->height;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	cx, WORD PTR [eax+12]
	mov	WORD PTR _image+10, cx

; 208  : 
; 209  : 	if( filesize < image.width * image.height )

	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cmp	DWORD PTR _filesize$[ebp], edx
	jae	SHORT $LN9@Image_Load

; 210  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN9@Image_Load:

; 211  : 
; 212  : 	if( filesize == ( image.width * image.height * 4 ))

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	shl	ecx, 2
	cmp	DWORD PTR _filesize$[ebp], ecx
	jne	SHORT $LN10@Image_Load

; 213  : 		truecolor = true;

	mov	DWORD PTR _truecolor$[ebp], 1
$LN10@Image_Load:

; 214  : 
; 215  : 	// sorry, can't validate palette rendermode
; 216  : 	if( !Image_LumpValidSize( name )) return false;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_LumpValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN11@Image_Load:

; 217  : 	image.type = (truecolor) ? PF_RGBA_32 : PF_INDEXED_32;	// 32-bit palete

	cmp	DWORD PTR _truecolor$[ebp], 0
	je	SHORT $LN16@Image_Load
	mov	DWORD PTR tv82[ebp], 3
	jmp	SHORT $LN17@Image_Load
$LN16@Image_Load:
	mov	DWORD PTR tv82[ebp], 2
$LN17@Image_Load:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _image+20, ecx

; 218  : 	image.depth = 1;

	mov	edx, 1
	mov	WORD PTR _image+12, dx

; 219  : 
; 220  : 	// detect alpha-channel by palette type
; 221  : 	switch( image.d_rendermode )

	mov	eax, DWORD PTR _image+68
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 1
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR tv83[ebp], 2
	je	SHORT $LN13@Image_Load
	cmp	DWORD PTR tv83[ebp], 5
	je	SHORT $LN13@Image_Load
	jmp	SHORT $LN2@Image_Load
$LN12@Image_Load:

; 222  : 	{
; 223  : 	case LUMP_MASKED:
; 224  : 		SetBits( image.flags, IMAGE_ONEBIT_ALPHA );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 512				; 00000200H
	mov	DWORD PTR _image+24, ecx
$LN13@Image_Load:

; 225  : 	case LUMP_GRADIENT:
; 226  : 	case LUMP_QUAKE1:
; 227  : 		SetBits( image.flags, IMAGE_HAS_ALPHA );

	mov	edx, DWORD PTR _image+24
	or	edx, 2
	mov	DWORD PTR _image+24, edx
$LN2@Image_Load:

; 228  : 		break;
; 229  : 	}
; 230  : 
; 231  : 	if( truecolor )

	cmp	DWORD PTR _truecolor$[ebp], 0
	je	SHORT $LN14@Image_Load

; 232  : 	{
; 233  : 		// spr32 support
; 234  : 		image.size = image.width * image.height * 4;

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _image+28, eax

; 235  : 		image.rgba = Mem_Malloc( host.imagepool, image.size );

	push	235					; 000000ebH
	push	OFFSET $SG132247
	push	0
	mov	edx, DWORD PTR _image+28
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax

; 236  : 		memcpy( image.rgba, (byte *)(pin + 1), image.size );

	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _pin$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _image+40
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 237  : 		SetBits( image.flags, IMAGE_HAS_COLOR ); // Color. True Color!

	mov	ecx, DWORD PTR _image+24
	or	ecx, 4
	mov	DWORD PTR _image+24, ecx

; 238  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Load
$LN14@Image_Load:

; 239  : 	}
; 240  : 
; 241  : 	return Image_AddIndexedImageToPack( (byte *)(pin + 1), image.width, image.height );

	movzx	edx, WORD PTR _image+10
	push	edx
	movzx	eax, WORD PTR _image+8
	push	eax
	mov	ecx, DWORD PTR _pin$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_Image_AddIndexedImageToPack
	add	esp, 12					; 0000000cH
$LN1@Image_Load:

; 242  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadSPR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
_TEXT	SEGMENT
_pal$1 = -20						; size = 4
_flags$ = -16						; size = 4
_fin$ = -12						; size = 4
_pixels$ = -8						; size = 4
_pin$ = -4						; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadMDL PROC

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 139  : 	byte		*fin;
; 140  : 	size_t		pixels;
; 141  : 	mstudiotexture_t	*pin;
; 142  : 	int		flags;
; 143  : 
; 144  : 	pin = (mstudiotexture_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pin$[ebp], eax

; 145  : 	flags = pin->flags;

	mov	ecx, DWORD PTR _pin$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _flags$[ebp], edx

; 146  : 
; 147  : 	image.width = pin->width;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	cx, WORD PTR [eax+68]
	mov	WORD PTR _image+8, cx

; 148  : 	image.height = pin->height;

	mov	edx, DWORD PTR _pin$[ebp]
	mov	ax, WORD PTR [edx+72]
	mov	WORD PTR _image+10, ax

; 149  : 	pixels = image.width * image.height;

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	mov	DWORD PTR _pixels$[ebp], ecx

; 150  : 	fin = (byte *)pin->index;	// setup buffer

	mov	eax, DWORD PTR _pin$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _fin$[ebp], ecx

; 151  : 
; 152  : 	if( !Image_ValidSize( name ))

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Image_Load

; 153  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN2@Image_Load:

; 154  : 
; 155  : 	if( image.hint == IL_HINT_HL )

	cmp	DWORD PTR _image+80, 2
	jne	SHORT $LN3@Image_Load

; 156  : 	{
; 157  : 		if( filesize < ( sizeof( *pin ) + pixels + 768 ))

	mov	eax, DWORD PTR _pixels$[ebp]
	add	eax, 848				; 00000350H
	cmp	DWORD PTR _filesize$[ebp], eax
	jae	SHORT $LN5@Image_Load

; 158  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Load
$LN5@Image_Load:

; 159  : 
; 160  : 		if( FBitSet( flags, STUDIO_NF_MASKED ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN6@Image_Load

; 161  : 		{
; 162  : 			byte	*pal = fin + pixels;

	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR _pal$1[ebp], edx

; 163  : 
; 164  : 			Image_GetPaletteLMP( pal, LUMP_MASKED );

	push	1
	mov	eax, DWORD PTR _pal$1[ebp]
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8

; 165  : 			image.flags |= IMAGE_HAS_ALPHA|IMAGE_ONEBIT_ALPHA;

	mov	ecx, DWORD PTR _image+24
	or	ecx, 514				; 00000202H
	mov	DWORD PTR _image+24, ecx

; 166  : 		}

	jmp	SHORT $LN7@Image_Load
$LN6@Image_Load:

; 167  : 		else Image_GetPaletteLMP( fin + pixels, LUMP_NORMAL );

	push	0
	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _pixels$[ebp]
	push	edx
	call	_Image_GetPaletteLMP
	add	esp, 8
$LN7@Image_Load:

; 168  : 	}

	jmp	SHORT $LN4@Image_Load
$LN3@Image_Load:

; 169  : 	else
; 170  : 	{
; 171  : 		return false; // unknown or unsupported mode rejected

	xor	eax, eax
	jmp	SHORT $LN1@Image_Load
$LN4@Image_Load:

; 172  : 	}
; 173  : 
; 174  : 	image.type = PF_INDEXED_32;	// 32-bit palete

	mov	DWORD PTR _image+20, 2

; 175  : 	image.depth = 1;

	mov	eax, 1
	mov	WORD PTR _image+12, ax

; 176  : 
; 177  : 	return Image_AddIndexedImageToPack( fin, image.width, image.height );

	movzx	ecx, WORD PTR _image+10
	push	ecx
	movzx	edx, WORD PTR _image+8
	push	edx
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_Image_AddIndexedImageToPack
	add	esp, 12					; 0000000cH
$LN1@Image_Load:

; 178  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadMDL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_wad.c
_TEXT	SEGMENT
_numcolors$ = -104					; size = 4
_pixels$ = -100						; size = 4
_pal_type$1 = -96					; size = 4
_hl_texture$ = -92					; size = 4
_rendermode$ = -88					; size = 4
_fin$ = -84						; size = 4
_pal$ = -80						; size = 4
_i$ = -76						; size = 4
_mip$ = -72						; size = 40
_ofs$ = -32						; size = 16
_reflectivity$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadMIP PROC

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 336  : 	mip_t	mip;
; 337  : 	qboolean	hl_texture;
; 338  : 	byte	*fin, *pal;
; 339  : 	int	ofs[4], rendermode;
; 340  : 	int	i, pixels, numcolors;
; 341  : 	int	reflectivity[3] = { 0, 0, 0 };

	mov	DWORD PTR _reflectivity$[ebp], 0
	mov	DWORD PTR _reflectivity$[ebp+4], 0
	mov	DWORD PTR _reflectivity$[ebp+8], 0

; 342  : 
; 343  : 	if( filesize < sizeof( mip ))

	cmp	DWORD PTR _filesize$[ebp], 40		; 00000028H
	jae	SHORT $LN14@Image_Load

; 344  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN14@Image_Load:

; 345  : 
; 346  : 	memcpy( &mip, buffer, sizeof( mip ));

	push	40					; 00000028H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mip$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 347  : 	image.width = mip.width;

	mov	dx, WORD PTR _mip$[ebp+16]
	mov	WORD PTR _image+8, dx

; 348  : 	image.height = mip.height;

	mov	ax, WORD PTR _mip$[ebp+20]
	mov	WORD PTR _image+10, ax

; 349  : 
; 350  : 	if( !Image_ValidSize( name ))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@Image_Load

; 351  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN15@Image_Load:

; 352  : 
; 353  : 	memcpy( ofs, mip.offsets, sizeof( ofs ));

	push	16					; 00000010H
	lea	edx, DWORD PTR _mip$[ebp+24]
	push	edx
	lea	eax, DWORD PTR _ofs$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 354  : 	pixels = image.width * image.height;

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	mov	DWORD PTR _pixels$[ebp], ecx

; 355  : 
; 356  : 	if( image.hint != IL_HINT_Q1 && filesize >= (int)sizeof(mip) + ((pixels * 85)>>6) + sizeof(short) + 768)

	cmp	DWORD PTR _image+80, 1
	je	$LN16@Image_Load
	imul	eax, DWORD PTR _pixels$[ebp], 85
	sar	eax, 6
	add	eax, 810				; 0000032aH
	cmp	DWORD PTR _filesize$[ebp], eax
	jb	$LN16@Image_Load

; 357  : 	{
; 358  : 		// half-life 1.0.0.1 mip version with palette
; 359  : 		fin = (byte *)buffer + mip.offsets[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _mip$[ebp+edx+24]
	mov	DWORD PTR _fin$[ebp], eax

; 360  : 		pal = (byte *)buffer + mip.offsets[0] + (((image.width * image.height) * 85)>>6);

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _mip$[ebp+edx+24]
	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	imul	ecx, ecx, 85
	sar	ecx, 6
	add	eax, ecx
	mov	DWORD PTR _pal$[ebp], eax

; 361  : 		numcolors = *(short *)pal;

	mov	edx, DWORD PTR _pal$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _numcolors$[ebp], eax

; 362  : 		if( numcolors != 256 ) pal = NULL; // corrupted mip ?

	cmp	DWORD PTR _numcolors$[ebp], 256		; 00000100H
	je	SHORT $LN18@Image_Load
	mov	DWORD PTR _pal$[ebp], 0
	jmp	SHORT $LN19@Image_Load
$LN18@Image_Load:

; 363  : 		else pal += sizeof( short ); // skip colorsize 

	mov	ecx, DWORD PTR _pal$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pal$[ebp], ecx
$LN19@Image_Load:

; 364  : 
; 365  : 		hl_texture = true;

	mov	DWORD PTR _hl_texture$[ebp], 1

; 366  : 
; 367  : 		// setup rendermode
; 368  : 		if( Q_strrchr( name, '{' ))

	push	123					; 0000007bH
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strrchr
	add	esp, 8
	test	eax, eax
	je	$LN20@Image_Load

; 369  : 		{
; 370  : 			// NOTE: decals with 'blue base' can be interpret as colored decals
; 371  : 			if( !Image_CheckFlag( IL_LOAD_DECAL ) || ( pal[765] == 0 && pal[766] == 0 && pal[767] == 255 ))

	push	32					; 00000020H
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@Image_Load
	mov	eax, 1
	imul	ecx, eax, 765
	mov	edx, DWORD PTR _pal$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN22@Image_Load
	mov	ecx, 1
	imul	edx, ecx, 766
	mov	eax, DWORD PTR _pal$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN22@Image_Load
	mov	edx, 1
	imul	eax, edx, 767
	mov	ecx, DWORD PTR _pal$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN22@Image_Load
$LN24@Image_Load:

; 372  : 			{
; 373  : 				SetBits( image.flags, IMAGE_ONEBIT_ALPHA );

	mov	eax, DWORD PTR _image+24
	or	eax, 512				; 00000200H
	mov	DWORD PTR _image+24, eax

; 374  : 				rendermode = LUMP_MASKED;

	mov	DWORD PTR _rendermode$[ebp], 1

; 375  : 			}

	jmp	SHORT $LN23@Image_Load
$LN22@Image_Load:

; 376  : 			else
; 377  : 			{
; 378  : 				// classic gradient decals
; 379  : 				SetBits( image.flags, IMAGE_COLORINDEX );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 8
	mov	DWORD PTR _image+24, ecx

; 380  : 				rendermode = LUMP_GRADIENT;

	mov	DWORD PTR _rendermode$[ebp], 2
$LN23@Image_Load:

; 381  : 			}
; 382  : 
; 383  : 			SetBits( image.flags, IMAGE_HAS_ALPHA );

	mov	edx, DWORD PTR _image+24
	or	edx, 2
	mov	DWORD PTR _image+24, edx

; 384  : 		}

	jmp	$LN21@Image_Load
$LN20@Image_Load:

; 385  : 		else
; 386  : 		{
; 387  : 			int	pal_type;
; 388  : 
; 389  : 			// NOTE: we can have luma-pixels if quake1 texture
; 390  : 			// converted into the hl texture but palette leave unchanged
; 391  : 			// this is a good reason for using fullbright pixels
; 392  : 			pal_type = Image_ComparePalette( pal );

	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	call	_Image_ComparePalette
	add	esp, 4
	mov	DWORD PTR _pal_type$1[ebp], eax

; 393  : 
; 394  : 			// check for luma pixels (but ignore liquid textures because they have no lightmap)
; 395  : 			if( mip.name[0] != '*' && mip.name[0] != '!' && pal_type == PAL_QUAKE1 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _mip$[ebp+edx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN3@Image_Load
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _mip$[ebp+edx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN3@Image_Load
	cmp	DWORD PTR _pal_type$1[ebp], 1
	jne	SHORT $LN3@Image_Load

; 396  : 			{
; 397  : 				for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Load
$LN2@Image_Load:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Image_Load:
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN3@Image_Load

; 398  : 				{
; 399  : 					if( fin[i] > 224 )

	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 224				; 000000e0H
	jle	SHORT $LN26@Image_Load

; 400  : 					{
; 401  : 						image.flags |= IMAGE_HAS_LUMA;

	mov	eax, DWORD PTR _image+24
	or	eax, 16					; 00000010H
	mov	DWORD PTR _image+24, eax

; 402  : 						break;

	jmp	SHORT $LN3@Image_Load
$LN26@Image_Load:

; 403  : 					}
; 404  : 				}

	jmp	SHORT $LN2@Image_Load
$LN3@Image_Load:

; 405  : 			}
; 406  : 
; 407  : 			if( pal_type == PAL_QUAKE1 )

	cmp	DWORD PTR _pal_type$1[ebp], 1
	jne	SHORT $LN27@Image_Load

; 408  : 				SetBits( image.flags, IMAGE_QUAKEPAL );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR _image+24, ecx
$LN27@Image_Load:

; 409  : 			rendermode = LUMP_NORMAL;

	mov	DWORD PTR _rendermode$[ebp], 0
$LN21@Image_Load:

; 410  : 		}
; 411  : 
; 412  : 		Image_GetPaletteLMP( pal, rendermode );

	mov	edx, DWORD PTR _rendermode$[ebp]
	push	edx
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8

; 413  : 		image.d_currentpal[255] &= 0xFFFFFF;

	mov	ecx, 4
	imul	edx, ecx, 255
	mov	eax, DWORD PTR _image+64
	mov	ecx, DWORD PTR [eax+edx]
	and	ecx, 16777215				; 00ffffffH
	mov	edx, 4
	imul	eax, edx, 255
	mov	edx, DWORD PTR _image+64
	mov	DWORD PTR [edx+eax], ecx

; 414  : 	}

	jmp	$LN29@Image_Load
$LN16@Image_Load:

; 415  : 	else if( image.hint != IL_HINT_HL && filesize >= (int)sizeof(mip) + ((pixels * 85)>>6))

	cmp	DWORD PTR _image+80, 2
	je	$LN28@Image_Load
	imul	eax, DWORD PTR _pixels$[ebp], 85
	sar	eax, 6
	add	eax, 40					; 00000028H
	cmp	DWORD PTR _filesize$[ebp], eax
	jb	$LN28@Image_Load

; 416  : 	{
; 417  : 		// quake1 1.01 mip version without palette
; 418  : 		fin = (byte *)buffer + mip.offsets[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _mip$[ebp+edx+24]
	mov	DWORD PTR _fin$[ebp], eax

; 419  : 		pal = NULL; // clear palette

	mov	DWORD PTR _pal$[ebp], 0

; 420  : 		rendermode = LUMP_NORMAL;

	mov	DWORD PTR _rendermode$[ebp], 0

; 421  : 
; 422  : 		hl_texture = false;

	mov	DWORD PTR _hl_texture$[ebp], 0

; 423  : 
; 424  : 		// check for luma and alpha pixels
; 425  : 		if( !image.custom_palette )

	cmp	DWORD PTR _image+96, 0
	jne	$LN6@Image_Load

; 426  : 		{
; 427  : 			for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Load
$LN5@Image_Load:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@Image_Load:
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN6@Image_Load

; 428  : 			{
; 429  : 				if( fin[i] > 224 && fin[i] != 255 )

	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 224				; 000000e0H
	jle	SHORT $LN31@Image_Load
	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN31@Image_Load

; 430  : 				{
; 431  : 					// don't apply luma to water surfaces because they have no lightmap
; 432  : 					if( mip.name[0] != '*' && mip.name[0] != '!' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _mip$[ebp+eax]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN32@Image_Load
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _mip$[ebp+eax]
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN32@Image_Load

; 433  : 						image.flags |= IMAGE_HAS_LUMA;

	mov	edx, DWORD PTR _image+24
	or	edx, 16					; 00000010H
	mov	DWORD PTR _image+24, edx
$LN32@Image_Load:

; 434  : 					break;

	jmp	SHORT $LN6@Image_Load
$LN31@Image_Load:

; 435  : 				}
; 436  : 			}

	jmp	SHORT $LN5@Image_Load
$LN6@Image_Load:

; 437  : 		}
; 438  : 
; 439  : 		// Arcane Dimensions has the transparent textures
; 440  : 		if( Q_strrchr( name, '{' ))

	push	123					; 0000007bH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@Image_Load

; 441  : 		{
; 442  : 			for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Image_Load
$LN8@Image_Load:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@Image_Load:
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN9@Image_Load

; 443  : 			{
; 444  : 				if( fin[i] == 255 )

	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN34@Image_Load

; 445  : 				{
; 446  : 					// don't set ONEBIT_ALPHA flag for some reasons
; 447  : 					image.flags |= IMAGE_HAS_ALPHA;

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax

; 448  : 					break;

	jmp	SHORT $LN9@Image_Load
$LN34@Image_Load:

; 449  : 				}
; 450  : 			}

	jmp	SHORT $LN8@Image_Load
$LN9@Image_Load:

; 451  : 		}
; 452  : 
; 453  : 		SetBits( image.flags, IMAGE_QUAKEPAL );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR _image+24, ecx

; 454  : 		Image_GetPaletteQ1();

	call	_Image_GetPaletteQ1

; 455  : 	}

	jmp	SHORT $LN29@Image_Load
$LN28@Image_Load:

; 456  : 	else
; 457  : 	{
; 458  : 		return false; // unknown or unsupported mode rejected

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN29@Image_Load:

; 459  : 	} 
; 460  : 
; 461  : 	// check for quake-sky texture
; 462  : 	if( !Q_strncmp( mip.name, "sky", 3 ) && image.width == ( image.height * 2 ))

	push	3
	push	OFFSET $SG132354
	lea	edx, DWORD PTR _mip$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@Image_Load
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	shl	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN35@Image_Load

; 463  : 	{
; 464  : 		// g-cont: we need to run additional checks for palette type and colors ?
; 465  : 		image.flags |= IMAGE_QUAKESKY;

	mov	edx, DWORD PTR _image+24
	or	edx, 64					; 00000040H
	mov	DWORD PTR _image+24, edx
$LN35@Image_Load:

; 466  : 	}
; 467  : 
; 468  : 	// check for half-life water texture
; 469  : 	if( hl_texture && ( mip.name[0] == '!' || !Q_strnicmp( mip.name, "water", 5 )))

	cmp	DWORD PTR _hl_texture$[ebp], 0
	je	$LN36@Image_Load
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _mip$[ebp+ecx]
	cmp	edx, 33					; 00000021H
	je	SHORT $LN38@Image_Load
	push	5
	push	OFFSET $SG132358
	lea	eax, DWORD PTR _mip$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN36@Image_Load
$LN38@Image_Load:

; 470  :           {
; 471  : 		// grab the fog color
; 472  : 		image.fogParams[0] = pal[3*3+0];

	mov	ecx, 1
	imul	edx, ecx, 9
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR _image[ecx+76], dl

; 473  : 		image.fogParams[1] = pal[3*3+1];

	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _image[edx+76], cl

; 474  : 		image.fogParams[2] = pal[3*3+2];

	mov	edx, 1
	imul	eax, edx, 11
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _image[ecx+76], al

; 475  : 
; 476  : 		// grab the fog density
; 477  : 		image.fogParams[3] = pal[4*3+0];

	mov	ecx, 1
	imul	edx, ecx, 12
	mov	eax, 1
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR _image[ecx+76], dl

; 478  :           }

	jmp	$LN41@Image_Load
$LN36@Image_Load:

; 479  :           else if( hl_texture && ( rendermode == LUMP_GRADIENT ))

	cmp	DWORD PTR _hl_texture$[ebp], 0
	je	$LN39@Image_Load
	cmp	DWORD PTR _rendermode$[ebp], 2
	jne	$LN39@Image_Load

; 480  :           {
; 481  : 		// grab the decal color
; 482  : 		image.fogParams[0] = pal[255*3+0];

	mov	eax, 1
	imul	ecx, eax, 765
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _image[eax+76], cl

; 483  : 		image.fogParams[1] = pal[255*3+1];

	mov	edx, 1
	imul	eax, edx, 766
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _image[ecx+76], al

; 484  : 		image.fogParams[2] = pal[255*3+2];

	mov	ecx, 1
	imul	edx, ecx, 767
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _image[eax+76], dl

; 485  : 
; 486  : 		// calc the decal reflectivity
; 487  : 		image.fogParams[3] = VectorAvg( image.fogParams );         

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	eax, BYTE PTR _image[ecx+76]
	mov	edx, 1
	shl	edx, 0
	movzx	ecx, BYTE PTR _image[edx+76]
	add	eax, ecx
	mov	edx, 1
	shl	edx, 1
	movzx	ecx, BYTE PTR _image[edx+76]
	add	eax, ecx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	edx, 1
	imul	ecx, edx, 3
	mov	BYTE PTR _image[ecx+76], al

; 488  : 	}

	jmp	$LN41@Image_Load
$LN39@Image_Load:

; 489  : 	else if( pal != NULL )

	cmp	DWORD PTR _pal$[ebp], 0
	je	$LN41@Image_Load

; 490  : 	{
; 491  : 		// calc texture reflectivity
; 492  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Load
$LN11@Image_Load:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@Image_Load:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN12@Image_Load

; 493  : 		{
; 494  : 			reflectivity[0] += pal[i*3+0];

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 3
	mov	eax, DWORD PTR _pal$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	add	edx, DWORD PTR _reflectivity$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _reflectivity$[ebp+ecx], edx

; 495  : 			reflectivity[1] += pal[i*3+1];

	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _pal$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+1]
	add	eax, DWORD PTR _reflectivity$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR _reflectivity$[ebp+ecx], eax

; 496  : 			reflectivity[2] += pal[i*3+2];

	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _pal$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+2]
	add	eax, DWORD PTR _reflectivity$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR _reflectivity$[ebp+ecx], eax

; 497  : 		}

	jmp	SHORT $LN11@Image_Load
$LN12@Image_Load:

; 498  :  
; 499  : 		VectorDivide( reflectivity, 256, image.fogParams );

	mov	edx, 4
	imul	eax, edx, 0
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3b800000
	mov	ecx, 1
	imul	edx, ecx, 0
	cvttss2si eax, xmm0
	mov	BYTE PTR _image[edx+76], al
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3b800000
	mov	edx, 1
	shl	edx, 0
	cvttss2si eax, xmm0
	mov	BYTE PTR _image[edx+76], al
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3b800000
	mov	edx, 1
	shl	edx, 1
	cvttss2si eax, xmm0
	mov	BYTE PTR _image[edx+76], al
$LN41@Image_Load:

; 500  : 	}
; 501  :  
; 502  : 	image.type = PF_INDEXED_32;	// 32-bit palete

	mov	DWORD PTR _image+20, 2

; 503  : 	image.depth = 1;

	mov	ecx, 1
	mov	WORD PTR _image+12, cx

; 504  : 
; 505  : 	return Image_AddIndexedImageToPack( fin, image.width, image.height );

	movzx	edx, WORD PTR _image+10
	push	edx
	movzx	eax, WORD PTR _image+8
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	call	_Image_AddIndexedImageToPack
	add	esp, 12					; 0000000cH
$LN1@Image_Load:

; 506  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadMIP ENDP
_TEXT	ENDS
END
