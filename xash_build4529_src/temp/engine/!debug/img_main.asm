; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\imagelib\img_main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_PFDesc
_DATA	SEGMENT
COMM	_image:BYTE:064H
_DATA	ENDS
_DATA	SEGMENT
$SG130118 DB	'ft', 00H
	ORG $+1
$SG130119 DB	'bk', 00H
	ORG $+1
$SG130120 DB	'up', 00H
	ORG $+1
$SG130121 DB	'dn', 00H
	ORG $+1
$SG130122 DB	'rt', 00H
	ORG $+1
$SG130123 DB	'lf', 00H
	ORG $+1
$SG130125 DB	'_ft', 00H
$SG130126 DB	'_bk', 00H
$SG130127 DB	'_up', 00H
$SG130128 DB	'_dn', 00H
$SG130129 DB	'_rt', 00H
$SG130130 DB	'_lf', 00H
$SG130132 DB	'px', 00H
	ORG $+1
$SG130133 DB	'nx', 00H
	ORG $+1
$SG130134 DB	'py', 00H
	ORG $+1
$SG130135 DB	'ny', 00H
	ORG $+1
$SG130136 DB	'pz', 00H
	ORG $+1
$SG130137 DB	'nz', 00H
	ORG $+1
$SG130145 DB	'3Ds Sky1', 00H
	ORG $+3
$SG130146 DB	'3Ds Sky2', 00H
	ORG $+3
$SG130147 DB	'3Ds Cube', 00H
_DATA	ENDS
CONST	SEGMENT
_PFDesc	DD	00H
	DB	'raw', 00H
	ORG $+12
	DD	01908H
	DD	00H
	DD	01H
	DB	'pal 24', 00H
	ORG $+9
	DD	01908H
	DD	01H
	DD	02H
	DB	'pal 32', 00H
	ORG $+9
	DD	01908H
	DD	01H
	DD	03H
	DB	'RGBA 32', 00H
	ORG $+8
	DD	01908H
	DD	04H
	DD	04H
	DB	'BGRA 32', 00H
	ORG $+8
	DD	080e1H
	DD	04H
	DD	05H
	DB	'RGB 24', 00H
	ORG $+9
	DD	01908H
	DD	03H
	DD	06H
	DB	'BGR 24', 00H
	ORG $+9
	DD	080e0H
	DD	03H
	DD	07H
	DB	'LUM 8', 00H
	ORG $+10
	DD	01909H
	DD	01H
	DD	08H
	DB	'DXT 1', 00H
	ORG $+10
	DD	083f1H
	DD	04H
	DD	09H
	DB	'DXT 3', 00H
	ORG $+10
	DD	083f2H
	DD	04H
	DD	0aH
	DB	'DXT 5', 00H
	ORG $+10
	DD	083f3H
	DD	04H
	DD	0bH
	DB	'ATI 2', 00H
	ORG $+10
	DD	08837H
	DD	04H
_skybox_qv1 DD	FLAT:$SG130118
	DD	010000H
	DD	01H
	DD	FLAT:$SG130119
	DD	020000H
	DD	02H
	DD	FLAT:$SG130120
	DD	040000H
	DD	03H
	DD	FLAT:$SG130121
	DD	040000H
	DD	04H
	DD	FLAT:$SG130122
	DD	040000H
	DD	05H
	DD	FLAT:$SG130123
	DD	070000H
	DD	06H
_skybox_qv2 DD	FLAT:$SG130125
	DD	010000H
	DD	01H
	DD	FLAT:$SG130126
	DD	020000H
	DD	02H
	DD	FLAT:$SG130127
	DD	040000H
	DD	03H
	DD	FLAT:$SG130128
	DD	040000H
	DD	04H
	DD	FLAT:$SG130129
	DD	040000H
	DD	05H
	DD	FLAT:$SG130130
	DD	070000H
	DD	06H
_cubemap_v1 DD	FLAT:$SG130132
	DD	00H
	DD	01H
	DD	FLAT:$SG130133
	DD	00H
	DD	02H
	DD	FLAT:$SG130134
	DD	00H
	DD	05H
	DD	FLAT:$SG130135
	DD	00H
	DD	06H
	DD	FLAT:$SG130136
	DD	00H
	DD	03H
	DD	FLAT:$SG130137
	DD	00H
	DD	04H
_load_cubemap DD FLAT:$SG130145
	DD	FLAT:_skybox_qv1
	DD	FLAT:$SG130146
	DD	FLAT:_skybox_qv2
	DD	FLAT:$SG130147
	DD	FLAT:_cubemap_v1
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	_FS_LoadImage
PUBLIC	_FS_SaveImage
PUBLIC	_FS_CopyImage
PUBLIC	_FS_FreeImage
PUBLIC	_Image_Reset
PUBLIC	_ImagePack
PUBLIC	_FS_AddSideToPack
EXTRN	_memcpy:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Image_ResampleInternal:PROC
EXTRN	_Image_FlipInternal:PROC
EXTRN	_Image_Copy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
$SG130218 DB	01H DUP (?)
$SG130223 DB	01H DUP (?)
$SG130274 DB	01H DUP (?)
$SG130286 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+7
$SG130158 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130178 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130179 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130227 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130228 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130233 DB	'%s%s.%s', 00H
$SG130235 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130236 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130239 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130243 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130250 DB	'^3Warning:^7 FS_LoadImage: couldn''t load "%s"', 0aH, 00H
	ORG $+1
$SG130293 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130295 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130296 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130307 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130311 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
	ORG $+3
$SG130313 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_main.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
_out$ = -12						; size = 4
_resampled$ = -8					; size = 4
_flipped$ = -4						; size = 4
_name$ = 8						; size = 4
_adjust_flags$ = 12					; size = 4
_FS_AddSideToPack PROC

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 167  : 	byte	*out, *flipped;
; 168  : 	qboolean	resampled = false;

	mov	DWORD PTR _resampled$[ebp], 0

; 169  : 	
; 170  : 	// first side set average size for all cubemap sides!
; 171  : 	if( !image.cubemap )

	cmp	DWORD PTR _image+60, 0
	jne	SHORT $LN2@FS_AddSide

; 172  : 	{
; 173  : 		image.source_width = image.width;

	movzx	eax, WORD PTR _image+8
	mov	DWORD PTR _image+44, eax

; 174  : 		image.source_height = image.height;

	movzx	ecx, WORD PTR _image+10
	mov	DWORD PTR _image+48, ecx

; 175  : 		image.source_type = image.type;

	mov	edx, DWORD PTR _image+20
	mov	DWORD PTR _image+52, edx
$LN2@FS_AddSide:

; 176  : 	}
; 177  : 
; 178  : 	// keep constant size, render.dll expecting it
; 179  : 	image.size = image.source_width * image.source_height * 4;

	mov	eax, DWORD PTR _image+44
	imul	eax, DWORD PTR _image+48
	shl	eax, 2
	mov	DWORD PTR _image+28, eax

; 180  :           
; 181  : 	// mixing dds format with any existing ?
; 182  : 	if( image.type != image.source_type )

	mov	ecx, DWORD PTR _image+20
	cmp	ecx, DWORD PTR _image+52
	je	SHORT $LN3@FS_AddSide

; 183  : 		return false;

	xor	eax, eax
	jmp	$LN1@FS_AddSide
$LN3@FS_AddSide:

; 184  : 
; 185  : 	// flip image if needed
; 186  : 	flipped = Image_FlipInternal( image.rgba, &image.width, &image.height, image.source_type, adjust_flags );

	mov	edx, DWORD PTR _adjust_flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+52
	push	eax
	push	OFFSET _image+10
	push	OFFSET _image+8
	mov	ecx, DWORD PTR _image+40
	push	ecx
	call	_Image_FlipInternal
	add	esp, 20					; 00000014H
	mov	DWORD PTR _flipped$[ebp], eax

; 187  : 	if( !flipped ) return false; // try to reasmple dxt?

	cmp	DWORD PTR _flipped$[ebp], 0
	jne	SHORT $LN4@FS_AddSide
	xor	eax, eax
	jmp	$LN1@FS_AddSide
$LN4@FS_AddSide:

; 188  : 	if( flipped != image.rgba ) image.rgba = Image_Copy( image.size );

	mov	edx, DWORD PTR _flipped$[ebp]
	cmp	edx, DWORD PTR _image+40
	je	SHORT $LN5@FS_AddSide
	mov	eax, DWORD PTR _image+28
	push	eax
	call	_Image_Copy
	add	esp, 4
	mov	DWORD PTR _image+40, eax
$LN5@FS_AddSide:

; 189  : 
; 190  : 	// resampling image if needed
; 191  : 	out = Image_ResampleInternal((uint *)image.rgba, image.width, image.height, image.source_width, image.source_height, image.source_type, &resampled );

	lea	ecx, DWORD PTR _resampled$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+52
	push	edx
	mov	eax, DWORD PTR _image+48
	push	eax
	mov	ecx, DWORD PTR _image+44
	push	ecx
	movzx	edx, WORD PTR _image+10
	push	edx
	movzx	eax, WORD PTR _image+8
	push	eax
	mov	ecx, DWORD PTR _image+40
	push	ecx
	call	_Image_ResampleInternal
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 192  : 	if( !out ) return false; // try to reasmple dxt?

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN6@FS_AddSide
	xor	eax, eax
	jmp	$LN1@FS_AddSide
$LN6@FS_AddSide:

; 193  : 	if( resampled ) image.rgba = Image_Copy( image.size );

	cmp	DWORD PTR _resampled$[ebp], 0
	je	SHORT $LN7@FS_AddSide
	mov	edx, DWORD PTR _image+28
	push	edx
	call	_Image_Copy
	add	esp, 4
	mov	DWORD PTR _image+40, eax
$LN7@FS_AddSide:

; 194  : 
; 195  : 	image.cubemap = Mem_Realloc( host.imagepool, image.cubemap, image.ptr + image.size );

	push	195					; 000000c3H
	push	OFFSET $SG130178
	push	1
	mov	eax, DWORD PTR _image+32
	add	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _image+60
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+60, eax

; 196  : 	memcpy( image.cubemap + image.ptr, image.rgba, image.size ); // add new side

	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _image+40
	push	ecx
	mov	edx, DWORD PTR _image+60
	add	edx, DWORD PTR _image+32
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 197  : 
; 198  : 	Mem_Free( image.rgba );	// release source buffer

	push	198					; 000000c6H
	push	OFFSET $SG130179
	mov	eax, DWORD PTR _image+40
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 199  : 	image.ptr += image.size; 	// move to next

	mov	ecx, DWORD PTR _image+32
	add	ecx, DWORD PTR _image+28
	mov	DWORD PTR _image+32, ecx

; 200  : 	image.num_sides++;		// bump sides count

	mov	edx, DWORD PTR _image+56
	add	edx, 1
	mov	DWORD PTR _image+56, edx

; 201  : 
; 202  : 	return true;

	mov	eax, 1
$LN1@FS_AddSide:

; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddSideToPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
_pack$ = -4						; size = 4
_ImagePack PROC

; 113  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 114  : 	rgbdata_t	*pack = Mem_Calloc( host.imagepool, sizeof( rgbdata_t ));

	push	114					; 00000072H
	push	OFFSET $SG130158
	push	1
	push	36					; 00000024H
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pack$[ebp], eax

; 115  : 
; 116  : 	// clear any force flags
; 117  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 118  : 
; 119  : 	if( image.cubemap && image.num_sides != 6 )

	cmp	DWORD PTR _image+60, 0
	je	SHORT $LN2@ImagePack
	cmp	DWORD PTR _image+56, 6
	je	SHORT $LN2@ImagePack

; 120  : 	{
; 121  : 		// this never be happens, just in case
; 122  : 		FS_FreeImage( pack );

	mov	ecx, DWORD PTR _pack$[ebp]
	push	ecx
	call	_FS_FreeImage
	add	esp, 4

; 123  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@ImagePack
$LN2@ImagePack:

; 124  : 	}
; 125  : 
; 126  : 	if( image.cubemap ) 

	cmp	DWORD PTR _image+60, 0
	je	SHORT $LN3@ImagePack

; 127  : 	{
; 128  : 		image.flags |= IMAGE_CUBEMAP;

	mov	edx, DWORD PTR _image+24
	or	edx, 1
	mov	DWORD PTR _image+24, edx

; 129  : 		pack->buffer = image.cubemap;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+60
	mov	DWORD PTR [eax+24], ecx

; 130  : 		pack->width = image.source_width;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	ax, WORD PTR _image+44
	mov	WORD PTR [edx], ax

; 131  : 		pack->height = image.source_height;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	dx, WORD PTR _image+48
	mov	WORD PTR [ecx+2], dx

; 132  : 		pack->type = image.source_type;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+52
	mov	DWORD PTR [eax+8], ecx

; 133  : 		pack->size = image.size * image.num_sides;

	mov	edx, DWORD PTR _image+28
	imul	edx, DWORD PTR _image+56
	mov	eax, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [eax+32], edx

; 134  : 	}

	jmp	SHORT $LN4@ImagePack
$LN3@ImagePack:

; 135  : 	else 
; 136  : 	{
; 137  : 		pack->buffer = image.rgba;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR _image+40
	mov	DWORD PTR [ecx+24], edx

; 138  : 		pack->width = image.width;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+8
	mov	WORD PTR [eax], cx

; 139  : 		pack->height = image.height;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	ax, WORD PTR _image+10
	mov	WORD PTR [edx+2], ax

; 140  : 		pack->depth = image.depth;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	dx, WORD PTR _image+12
	mov	WORD PTR [ecx+4], dx

; 141  : 		pack->type = image.type;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+20
	mov	DWORD PTR [eax+8], ecx

; 142  : 		pack->size = image.size;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR _image+28
	mov	DWORD PTR [edx+32], eax
$LN4@ImagePack:

; 143  : 	}
; 144  : 
; 145  : 	// copy fog params
; 146  : 	pack->fogParams[0] = image.fogParams[0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pack$[ebp]
	mov	dl, BYTE PTR _image[edx+76]
	mov	BYTE PTR [eax+ecx+28], dl

; 147  : 	pack->fogParams[1] = image.fogParams[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pack$[ebp]
	mov	al, BYTE PTR _image[eax+76]
	mov	BYTE PTR [edx+ecx+28], al

; 148  : 	pack->fogParams[2] = image.fogParams[2];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _image[ecx+76]
	mov	BYTE PTR [eax+edx+28], cl

; 149  : 	pack->fogParams[3] = image.fogParams[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	al, BYTE PTR _image[eax+76]
	mov	BYTE PTR [ecx+edx+28], al

; 150  : 
; 151  : 	pack->flags = image.flags;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR _image+24
	mov	DWORD PTR [ecx+12], edx

; 152  : 	pack->numMips = image.num_mips;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _image+14
	mov	BYTE PTR [eax+18], cl

; 153  : 	pack->palette = image.palette;

	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR _image+72
	mov	DWORD PTR [edx+20], eax

; 154  : 	pack->encode = image.encode;

	mov	ecx, DWORD PTR _pack$[ebp]
	mov	dx, WORD PTR _image+16
	mov	WORD PTR [ecx+16], dx

; 155  : 	
; 156  : 	return pack;

	mov	eax, DWORD PTR _pack$[ebp]
$LN1@ImagePack:

; 157  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ImagePack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
_Image_Reset PROC

; 90   : {

	push	ebp
	mov	ebp, esp

; 91   : 	// reset global variables
; 92   : 	image.width = image.height = image.depth = 0;

	xor	eax, eax
	mov	WORD PTR _image+12, ax
	mov	cx, WORD PTR _image+12
	mov	WORD PTR _image+10, cx
	mov	dx, WORD PTR _image+10
	mov	WORD PTR _image+8, dx

; 93   : 	image.source_width = image.source_height = 0;

	mov	DWORD PTR _image+48, 0
	mov	eax, DWORD PTR _image+48
	mov	DWORD PTR _image+44, eax

; 94   : 	image.source_type = image.num_mips = 0;

	mov	BYTE PTR _image+14, 0
	movzx	ecx, BYTE PTR _image+14
	mov	DWORD PTR _image+52, ecx

; 95   : 	image.num_sides = image.flags = 0;

	mov	DWORD PTR _image+24, 0
	mov	edx, DWORD PTR _image+24
	mov	DWORD PTR _image+56, edx

; 96   : 	image.encode = DXT_ENCODE_DEFAULT;

	xor	eax, eax
	mov	WORD PTR _image+16, ax

; 97   : 	image.type = PF_UNKNOWN;

	mov	DWORD PTR _image+20, 0

; 98   : 	image.fogParams[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _image[edx+76], 0

; 99   : 	image.fogParams[1] = 0;

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _image[eax+76], 0

; 100  : 	image.fogParams[2] = 0;

	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _image[ecx+76], 0

; 101  : 	image.fogParams[3] = 0;

	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _image[eax+76], 0

; 102  : 
; 103  : 	// pointers will be saved with prevoius picture struct
; 104  : 	// don't care about it
; 105  : 	image.palette = NULL;

	mov	DWORD PTR _image+72, 0

; 106  : 	image.cubemap = NULL;

	mov	DWORD PTR _image+60, 0

; 107  : 	image.rgba = NULL;

	mov	DWORD PTR _image+40, 0

; 108  : 	image.ptr = 0;

	mov	DWORD PTR _image+32, 0

; 109  : 	image.size = 0;

	mov	DWORD PTR _image+28, 0

; 110  : }

	pop	ebp
	ret	0
_Image_Reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
_pack$ = 8						; size = 4
_FS_FreeImage PROC

; 445  : {

	push	ebp
	mov	ebp, esp

; 446  : 	if( !pack ) return;

	cmp	DWORD PTR _pack$[ebp], 0
	jne	SHORT $LN2@FS_FreeIma
	jmp	SHORT $LN1@FS_FreeIma
$LN2@FS_FreeIma:

; 447  : 	if( pack->buffer ) Mem_Free( pack->buffer );

	mov	eax, DWORD PTR _pack$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@FS_FreeIma
	push	447					; 000001bfH
	push	OFFSET $SG130293
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@FS_FreeIma:

; 448  : 	if( pack->palette ) Mem_Free( pack->palette );

	mov	eax, DWORD PTR _pack$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN4@FS_FreeIma
	push	448					; 000001c0H
	push	OFFSET $SG130295
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@FS_FreeIma:

; 449  : 	Mem_Free( pack );

	push	449					; 000001c1H
	push	OFFSET $SG130296
	mov	eax, DWORD PTR _pack$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@FS_FreeIma:

; 450  : }

	pop	ebp
	ret	0
_FS_FreeImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
tv73 = -12						; size = 4
_palSize$ = -8						; size = 4
_out$ = -4						; size = 4
_in$ = 8						; size = 4
_FS_CopyImage PROC

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 461  : 	rgbdata_t	*out;
; 462  : 	int	palSize = 0;

	mov	DWORD PTR _palSize$[ebp], 0

; 463  : 
; 464  : 	if( !in ) return NULL;

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN4@FS_CopyIma
	xor	eax, eax
	jmp	$LN1@FS_CopyIma
$LN4@FS_CopyIma:

; 465  : 
; 466  : 	out = Mem_Malloc( host.imagepool, sizeof( rgbdata_t ));

	push	466					; 000001d2H
	push	OFFSET $SG130307
	push	0
	push	36					; 00000024H
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 467  : 	*out = *in;

	mov	ecx, 9
	mov	esi, DWORD PTR _in$[ebp]
	mov	edi, DWORD PTR _out$[ebp]
	rep movsd

; 468  : 
; 469  : 	switch( in->type )

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 1
	je	SHORT $LN5@FS_CopyIma
	cmp	DWORD PTR tv73[ebp], 2
	je	SHORT $LN6@FS_CopyIma
	jmp	SHORT $LN2@FS_CopyIma
$LN5@FS_CopyIma:

; 470  : 	{
; 471  : 	case PF_INDEXED_24:
; 472  : 		palSize = 768;

	mov	DWORD PTR _palSize$[ebp], 768		; 00000300H

; 473  : 		break;

	jmp	SHORT $LN2@FS_CopyIma
$LN6@FS_CopyIma:

; 474  : 	case PF_INDEXED_32:
; 475  : 		palSize = 1024;

	mov	DWORD PTR _palSize$[ebp], 1024		; 00000400H
$LN2@FS_CopyIma:

; 476  : 		break;
; 477  : 	}
; 478  : 
; 479  : 	if( palSize )

	cmp	DWORD PTR _palSize$[ebp], 0
	je	SHORT $LN7@FS_CopyIma

; 480  : 	{
; 481  : 		out->palette = Mem_Malloc( host.imagepool, palSize );

	push	481					; 000001e1H
	push	OFFSET $SG130311
	push	0
	mov	eax, DWORD PTR _palSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+34740
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+20], eax

; 482  : 		memcpy( out->palette, in->palette, palSize );

	mov	eax, DWORD PTR _palSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@FS_CopyIma:

; 483  : 	}
; 484  : 
; 485  : 	if( in->size )

	mov	edx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN8@FS_CopyIma

; 486  : 	{
; 487  : 		out->buffer = Mem_Malloc( host.imagepool, in->size );

	push	487					; 000001e7H
	push	OFFSET $SG130313
	push	0
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 488  : 		memcpy( out->buffer, in->buffer, in->size );

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@FS_CopyIma:

; 489  : 	}
; 490  : 
; 491  : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@FS_CopyIma:

; 492  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CopyImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
_picBuffer$1 = -556					; size = 4
_realSize$2 = -552					; size = 4
_anyformat$ = -548					; size = 4
tv162 = -544						; size = 4
_box$3 = -540						; size = 4
tv73 = -536						; size = 4
tv71 = -532						; size = 4
_ext$ = -528						; size = 4
_i$4 = -524						; size = 4
_format$ = -520						; size = 4
_path$ = -516						; size = 256
_savename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pix$ = 12						; size = 4
_FS_SaveImage PROC

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 355  : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 356  : 	qboolean		anyformat = !Q_stricmp( ext, "" ) ? true : false;

	push	99999					; 0001869fH
	push	OFFSET $SG130274
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@FS_SaveIma
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN25@FS_SaveIma
$LN24@FS_SaveIma:
	mov	DWORD PTR tv71[ebp], 0
$LN25@FS_SaveIma:
	cmp	DWORD PTR tv71[ebp], 0
	je	SHORT $LN26@FS_SaveIma
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN27@FS_SaveIma
$LN26@FS_SaveIma:
	mov	DWORD PTR tv73[ebp], 0
$LN27@FS_SaveIma:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _anyformat$[ebp], edx

; 357  : 	string		path, savename;
; 358  : 	const savepixformat_t *format;
; 359  : 
; 360  : 	if( !pix || !pix->buffer || anyformat )

	cmp	DWORD PTR _pix$[ebp], 0
	je	SHORT $LN12@FS_SaveIma
	mov	eax, DWORD PTR _pix$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN12@FS_SaveIma
	cmp	DWORD PTR _anyformat$[ebp], 0
	je	SHORT $LN11@FS_SaveIma
$LN12@FS_SaveIma:

; 361  : 	{
; 362  : 		// clear any force flags
; 363  : 		image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 364  : 		return false;

	xor	eax, eax
	jmp	$LN1@FS_SaveIma
$LN11@FS_SaveIma:

; 365  : 	}
; 366  : 
; 367  : 	Q_strncpy( savename, filename, sizeof( savename ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 368  : 	COM_StripExtension( savename ); // remove extension if needed

	lea	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 369  : 
; 370  : 	if( pix->flags & (IMAGE_CUBEMAP|IMAGE_SKYBOX))

	mov	ecx, DWORD PTR _pix$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 33					; 00000021H
	je	$LN13@FS_SaveIma

; 371  : 	{
; 372  : 		size_t		realSize = pix->size; // keep real pic size

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _realSize$2[ebp], ecx

; 373  : 		byte		*picBuffer; // to avoid corrupt memory on free data
; 374  : 		const suffix_t	*box;
; 375  : 		int		i;
; 376  : 
; 377  : 		if( pix->flags & IMAGE_SKYBOX )

	mov	edx, DWORD PTR _pix$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	je	SHORT $LN15@FS_SaveIma

; 378  : 			box = skybox_qv1;

	mov	DWORD PTR _box$3[ebp], OFFSET _skybox_qv1
	jmp	SHORT $LN16@FS_SaveIma
$LN15@FS_SaveIma:

; 379  : 		else if( pix->flags & IMAGE_CUBEMAP )

	mov	ecx, DWORD PTR _pix$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 1
	je	SHORT $LN17@FS_SaveIma

; 380  : 			box = cubemap_v1;

	mov	DWORD PTR _box$3[ebp], OFFSET _cubemap_v1
	jmp	SHORT $LN16@FS_SaveIma
$LN17@FS_SaveIma:

; 381  : 		else
; 382  : 		{
; 383  : 			// clear any force flags
; 384  : 			image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 385  : 			return false;	// do not happens

	xor	eax, eax
	jmp	$LN1@FS_SaveIma
$LN16@FS_SaveIma:

; 386  : 		}
; 387  : 
; 388  : 		pix->size /= 6; // now set as side size 

	mov	eax, DWORD PTR _pix$[ebp]
	mov	eax, DWORD PTR [eax+32]
	xor	edx, edx
	mov	ecx, 6
	div	ecx
	mov	edx, DWORD PTR _pix$[ebp]
	mov	DWORD PTR [edx+32], eax

; 389  : 		picBuffer = pix->buffer;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _picBuffer$1[ebp], ecx

; 390  : 
; 391  : 		// save all sides seperately
; 392  : 		for( format = image.saveformats; format && format->formatstring; format++ )

	mov	edx, DWORD PTR _image+4
	mov	DWORD PTR _format$[ebp], edx
	jmp	SHORT $LN4@FS_SaveIma
$LN2@FS_SaveIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], eax
$LN4@FS_SaveIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN3@FS_SaveIma
	mov	ecx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN3@FS_SaveIma

; 393  : 		{
; 394  : 			if( !Q_stricmp( ext, format->ext ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN19@FS_SaveIma

; 395  : 			{
; 396  : 				for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN7@FS_SaveIma
$LN5@FS_SaveIma:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN7@FS_SaveIma:
	cmp	DWORD PTR _i$4[ebp], 6
	jge	SHORT $LN6@FS_SaveIma

; 397  : 				{
; 398  : 					Q_sprintf( path, format->formatstring, savename, box[i].suf, format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	imul	edx, DWORD PTR _i$4[ebp], 12
	mov	eax, DWORD PTR _box$3[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 399  : 					if( !format->savefunc( path, pix )) break; // there were errors

	mov	eax, DWORD PTR _pix$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@FS_SaveIma
	jmp	SHORT $LN6@FS_SaveIma
$LN20@FS_SaveIma:

; 400  : 					pix->buffer += pix->size; // move pointer

	mov	ecx, DWORD PTR _pix$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _pix$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _pix$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 401  : 				}

	jmp	$LN5@FS_SaveIma
$LN6@FS_SaveIma:

; 402  : 
; 403  : 				// restore pointers
; 404  : 				pix->size = realSize;

	mov	edx, DWORD PTR _pix$[ebp]
	mov	eax, DWORD PTR _realSize$2[ebp]
	mov	DWORD PTR [edx+32], eax

; 405  : 				pix->buffer = picBuffer;

	mov	ecx, DWORD PTR _pix$[ebp]
	mov	edx, DWORD PTR _picBuffer$1[ebp]
	mov	DWORD PTR [ecx+24], edx

; 406  : 
; 407  : 				// clear any force flags
; 408  : 				image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 409  : 
; 410  : 				return ( i == 6 );

	cmp	DWORD PTR _i$4[ebp], 6
	jne	SHORT $LN28@FS_SaveIma
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN29@FS_SaveIma
$LN28@FS_SaveIma:
	mov	DWORD PTR tv162[ebp], 0
$LN29@FS_SaveIma:
	mov	eax, DWORD PTR tv162[ebp]
	jmp	$LN1@FS_SaveIma
$LN19@FS_SaveIma:

; 411  : 			}
; 412  : 		}

	jmp	$LN2@FS_SaveIma
$LN3@FS_SaveIma:

; 413  : 	}

	jmp	$LN14@FS_SaveIma
$LN13@FS_SaveIma:

; 414  : 	else
; 415  : 	{
; 416  : 		for( format = image.saveformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image+4
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN10@FS_SaveIma
$LN8@FS_SaveIma:
	mov	ecx, DWORD PTR _format$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], ecx
$LN10@FS_SaveIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN14@FS_SaveIma
	mov	edx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN14@FS_SaveIma

; 417  : 		{
; 418  : 			if( !Q_stricmp( ext, format->ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@FS_SaveIma

; 419  : 			{
; 420  : 				Q_sprintf( path, format->formatstring, savename, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET $SG130286
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 421  : 				if( format->savefunc( path, pix ))

	mov	eax, DWORD PTR _pix$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@FS_SaveIma

; 422  : 				{
; 423  : 					// clear any force flags
; 424  : 					image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 425  : 					return true; // saved

	mov	eax, 1
	jmp	SHORT $LN1@FS_SaveIma
$LN21@FS_SaveIma:

; 426  : 				}
; 427  : 			}
; 428  : 		}

	jmp	$LN8@FS_SaveIma
$LN14@FS_SaveIma:

; 429  : 	}
; 430  : 
; 431  : 	// clear any force flags
; 432  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 433  : 
; 434  : 	return false;

	xor	eax, eax
$LN1@FS_SaveIma:

; 435  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_SaveImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_main.c
_TEXT	SEGMENT
_anyformat$ = -800					; size = 4
_ext$ = -796						; size = 4
_filesize$ = -792					; size = 4
_i$ = -788						; size = 4
_cmap$ = -784						; size = 4
_f$ = -780						; size = 4
_format$ = -776						; size = 4
_sidename$ = -772					; size = 256
_path$ = -516						; size = 256
_loadname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_FS_LoadImage PROC

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 800				; 00000320H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 214  : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 215  : 	string		path, loadname, sidename;
; 216  : 	qboolean		anyformat = true;

	mov	DWORD PTR _anyformat$[ebp], 1

; 217  : 	int		i, filesize = 0;

	mov	DWORD PTR _filesize$[ebp], 0

; 218  : 	const loadpixformat_t *format;
; 219  : 	const cubepack_t	*cmap;
; 220  : 	byte		*f;
; 221  : 
; 222  : 	Q_strncpy( loadname, filename, sizeof( loadname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 223  : 	Image_Reset(); // clear old image

	call	_Image_Reset

; 224  : 
; 225  : 	if( Q_stricmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET $SG130218
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@FS_LoadIma

; 226  : 	{
; 227  : 		// we needs to compare file extension with list of supported formats
; 228  : 		// and be sure what is real extension, not a filename with dot
; 229  : 		for( format = image.loadformats; format && format->formatstring; format++ )

	mov	ecx, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], ecx
	jmp	SHORT $LN4@FS_LoadIma
$LN2@FS_LoadIma:
	mov	edx, DWORD PTR _format$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], edx
$LN4@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN20@FS_LoadIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@FS_LoadIma

; 230  : 		{
; 231  : 			if( !Q_stricmp( format->ext, ext ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@FS_LoadIma

; 232  : 			{
; 233  : 				COM_StripExtension( loadname );

	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	call	_COM_StripExtension
	add	esp, 4

; 234  : 				anyformat = false;

	mov	DWORD PTR _anyformat$[ebp], 0

; 235  : 				break;

	jmp	SHORT $LN20@FS_LoadIma
$LN21@FS_LoadIma:

; 236  : 			}
; 237  : 		}

	jmp	SHORT $LN2@FS_LoadIma
$LN20@FS_LoadIma:

; 238  : 	}
; 239  : 
; 240  : 	// special mode: skip any checks, load file from buffer
; 241  : 	if( filename[0] == '#' && buffer && size )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	SHORT $LN22@FS_LoadIma
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN22@FS_LoadIma
	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN22@FS_LoadIma

; 242  : 		goto load_internal;

	jmp	$load_internal$45
$LN22@FS_LoadIma:

; 243  : 
; 244  : 	// now try all the formats in the selected list
; 245  : 	for( format = image.loadformats; format && format->formatstring; format++)

	mov	eax, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN7@FS_LoadIma
$LN5@FS_LoadIma:
	mov	ecx, DWORD PTR _format$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], ecx
$LN7@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN6@FS_LoadIma
	mov	edx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN6@FS_LoadIma

; 246  : 	{
; 247  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN24@FS_LoadIma
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN23@FS_LoadIma
$LN24@FS_LoadIma:

; 248  : 		{
; 249  : 			Q_sprintf( path, format->formatstring, loadname, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET $SG130223
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 250  : 			image.hint = format->hint;

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _image+80, ecx

; 251  : 			f = FS_LoadFile( path, &filesize, false );

	push	0
	lea	edx, DWORD PTR _filesize$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 252  : 
; 253  : 			if( f && filesize > 0 )

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN23@FS_LoadIma
	cmp	DWORD PTR _filesize$[ebp], 0
	jle	SHORT $LN23@FS_LoadIma

; 254  : 			{
; 255  : 				if( format->loadfunc( path, f, filesize ))

	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@FS_LoadIma

; 256  : 				{
; 257  : 					Mem_Free( f ); // release buffer

	push	257					; 00000101H
	push	OFFSET $SG130227
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 258  : 					return ImagePack(); // loaded

	call	_ImagePack
	jmp	$LN1@FS_LoadIma

; 259  : 				}

	jmp	SHORT $LN23@FS_LoadIma
$LN26@FS_LoadIma:

; 260  : 				else Mem_Free( f ); // release buffer 

	push	260					; 00000104H
	push	OFFSET $SG130228
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@FS_LoadIma:

; 261  : 			}
; 262  : 		}
; 263  : 	}

	jmp	$LN5@FS_LoadIma
$LN6@FS_LoadIma:

; 264  : 
; 265  : 	// check all cubemap sides with package suffix
; 266  : 	for( cmap = load_cubemap; cmap && cmap->type; cmap++ )

	mov	DWORD PTR _cmap$[ebp], OFFSET _load_cubemap
	jmp	SHORT $LN10@FS_LoadIma
$LN8@FS_LoadIma:
	mov	edx, DWORD PTR _cmap$[ebp]
	add	edx, 8
	mov	DWORD PTR _cmap$[ebp], edx
$LN10@FS_LoadIma:
	cmp	DWORD PTR _cmap$[ebp], 0
	je	$LN9@FS_LoadIma
	mov	eax, DWORD PTR _cmap$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN9@FS_LoadIma

; 267  : 	{
; 268  : 		for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@FS_LoadIma
$LN11@FS_LoadIma:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@FS_LoadIma:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN12@FS_LoadIma

; 269  : 		{
; 270  : 			// for support mixed cubemaps e.g. sky_ft.bmp, sky_rt.tga
; 271  : 			// NOTE: all loaders must keep sides in one format for all
; 272  : 			for( format = image.loadformats; format && format->formatstring; format++ )

	mov	edx, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], edx
	jmp	SHORT $LN16@FS_LoadIma
$LN14@FS_LoadIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], eax
$LN16@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN15@FS_LoadIma
	mov	ecx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN15@FS_LoadIma

; 273  : 			{
; 274  : 				if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN29@FS_LoadIma
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ext$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN28@FS_LoadIma
$LN29@FS_LoadIma:

; 275  : 				{
; 276  : 					Q_sprintf( path, format->formatstring, loadname, cmap->type[i].suf, format->ext );

	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _cmap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 277  : 					image.hint = cmap->type[i].hint; // side hint

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _cmap$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _image+80, eax

; 278  : 
; 279  : 					f = FS_LoadFile( path, &filesize, false );

	push	0
	lea	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 280  : 					if( f && filesize > 0 )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN28@FS_LoadIma
	cmp	DWORD PTR _filesize$[ebp], 0
	jle	$LN28@FS_LoadIma

; 281  : 					{
; 282  : 						// this name will be used only for tell user about problems 
; 283  : 						if( format->loadfunc( path, f, filesize ))

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN31@FS_LoadIma

; 284  : 						{         
; 285  : 							Q_snprintf( sidename, sizeof( sidename ), "%s%s.%s", loadname, cmap->type[i].suf, format->ext );

	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _cmap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	push	OFFSET $SG130233
	push	256					; 00000100H
	lea	eax, DWORD PTR _sidename$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 286  : 							if( FS_AddSideToPack( sidename, cmap->type[i].flags )) // process flags to flip some sides

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _cmap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+ecx+4]
	push	ecx
	lea	edx, DWORD PTR _sidename$[ebp]
	push	edx
	call	_FS_AddSideToPack
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@FS_LoadIma

; 287  : 							{
; 288  : 								Mem_Free( f );

	push	288					; 00000120H
	push	OFFSET $SG130235
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 289  : 								break; // loaded

	jmp	SHORT $LN15@FS_LoadIma
$LN31@FS_LoadIma:

; 290  : 							}
; 291  : 						}
; 292  : 						Mem_Free( f );

	push	292					; 00000124H
	push	OFFSET $SG130236
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN28@FS_LoadIma:

; 293  : 					}
; 294  : 				}
; 295  : 			}

	jmp	$LN14@FS_LoadIma
$LN15@FS_LoadIma:

; 296  : 
; 297  : 			if( image.num_sides != i + 1 ) // check side

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	cmp	DWORD PTR _image+56, edx
	je	SHORT $LN33@FS_LoadIma

; 298  : 			{
; 299  : 				// first side not found, probably it's not cubemap
; 300  : 				// it contain info about image_type and dimensions, don't generate black cubemaps 
; 301  : 				if( !image.cubemap ) break;

	cmp	DWORD PTR _image+60, 0
	jne	SHORT $LN34@FS_LoadIma
	jmp	SHORT $LN12@FS_LoadIma
$LN34@FS_LoadIma:

; 302  : 				// Mem_Alloc already filled memblock with 0x00, no need to do it again
; 303  : 				image.cubemap = Mem_Realloc( host.imagepool, image.cubemap, image.ptr + image.size );

	push	303					; 0000012fH
	push	OFFSET $SG130239
	push	1
	mov	eax, DWORD PTR _image+32
	add	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _image+60
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+60, eax

; 304  : 				image.ptr += image.size; // move to next

	mov	eax, DWORD PTR _image+32
	add	eax, DWORD PTR _image+28
	mov	DWORD PTR _image+32, eax

; 305  : 				image.num_sides++; // merge counter

	mov	ecx, DWORD PTR _image+56
	add	ecx, 1
	mov	DWORD PTR _image+56, ecx
$LN33@FS_LoadIma:

; 306  : 			}
; 307  : 		}

	jmp	$LN11@FS_LoadIma
$LN12@FS_LoadIma:

; 308  : 
; 309  : 		// make sure what all sides is loaded
; 310  : 		if( image.num_sides != 6 )

	cmp	DWORD PTR _image+56, 6
	je	SHORT $LN35@FS_LoadIma

; 311  : 		{
; 312  : 			// unexpected errors ?
; 313  : 			if( image.cubemap )

	cmp	DWORD PTR _image+60, 0
	je	SHORT $LN37@FS_LoadIma

; 314  : 				Mem_Free( image.cubemap );

	push	314					; 0000013aH
	push	OFFSET $SG130243
	mov	edx, DWORD PTR _image+60
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN37@FS_LoadIma:

; 315  : 			Image_Reset();

	call	_Image_Reset

; 316  : 		}

	jmp	SHORT $LN36@FS_LoadIma
$LN35@FS_LoadIma:

; 317  : 		else break;

	jmp	SHORT $LN9@FS_LoadIma
$LN36@FS_LoadIma:

; 318  : 	}

	jmp	$LN8@FS_LoadIma
$LN9@FS_LoadIma:

; 319  : 
; 320  : 	if( image.cubemap )

	cmp	DWORD PTR _image+60, 0
	je	SHORT $load_internal$45

; 321  : 		return ImagePack(); // all done

	call	_ImagePack
	jmp	$LN1@FS_LoadIma
$load_internal$45:

; 322  : 
; 323  : load_internal:
; 324  : 	for( format = image.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN19@FS_LoadIma
$LN17@FS_LoadIma:
	mov	ecx, DWORD PTR _format$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], ecx
$LN19@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN18@FS_LoadIma
	mov	edx, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN18@FS_LoadIma

; 325  : 	{
; 326  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN40@FS_LoadIma
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@FS_LoadIma
$LN40@FS_LoadIma:

; 327  : 		{
; 328  : 			image.hint = format->hint;

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _image+80, ecx

; 329  : 			if( buffer && size > 0  )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN39@FS_LoadIma
	cmp	DWORD PTR _size$[ebp], 0
	jbe	SHORT $LN39@FS_LoadIma

; 330  : 			{
; 331  : 				if( format->loadfunc( loadname, buffer, size ))

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN39@FS_LoadIma

; 332  : 					return ImagePack(); // loaded

	call	_ImagePack
	jmp	SHORT $LN1@FS_LoadIma
$LN39@FS_LoadIma:

; 333  : 			}
; 334  : 		}
; 335  : 	}

	jmp	$LN17@FS_LoadIma
$LN18@FS_LoadIma:

; 336  : 
; 337  : 	if( filename[0] != '#' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 35					; 00000023H
	je	SHORT $LN43@FS_LoadIma

; 338  : 		Con_Reportf( S_WARN "FS_LoadImage: couldn't load \"%s\"\n", loadname );

	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	push	OFFSET $SG130250
	call	_Con_Reportf
	add	esp, 8
$LN43@FS_LoadIma:

; 339  : 
; 340  : 	// clear any force flags
; 341  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 342  : 
; 343  : 	return NULL;

	xor	eax, eax
$LN1@FS_LoadIma:

; 344  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadImage ENDP
_TEXT	ENDS
END
