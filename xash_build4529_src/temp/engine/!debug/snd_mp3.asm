; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Sound_LoadMPG
PUBLIC	_Stream_OpenMPG
PUBLIC	_Stream_ReadMPG
PUBLIC	_Stream_SetPosMPG
PUBLIC	_Stream_GetPosMPG
PUBLIC	_Stream_FreeMPG
EXTRN	_memcpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_create_decoder:PROC
EXTRN	_feed_mpeg_header:PROC
EXTRN	_feed_mpeg_stream:PROC
EXTRN	_open_mpeg_stream:PROC
EXTRN	_read_mpeg_stream:PROC
EXTRN	_get_stream_pos:PROC
EXTRN	_set_stream_pos:PROC
EXTRN	_close_decoder:PROC
EXTRN	_get_error:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_sound:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
$SG129998 DB	'^1Error:^7 %s', 0aH, 00H
	ORG $+1
$SG130000 DB	'^1Error:^7 Sound_LoadMPG: failed to load (%s): %s', 0aH, 00H
	ORG $+1
$SG130002 DB	'^1Error:^7 Sound_LoadMPG: (%s) is probably corrupted', 0aH
	DB	00H
	ORG $+2
$SG130023 DB	'rb', 00H
	ORG $+1
$SG130003 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_mp3.c', 00H
	ORG $+3
$SG130025 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_mp3.c', 00H
	ORG $+3
$SG130027 DB	'^1Error:^7 Stream_OpenMPG: couldn''t create decoder', 0aH
	DB	00H
$SG130032 DB	'^1Error:^7 Stream_OpenMPG: failed to load (%s): %s', 0aH
	DB	00H
$SG130028 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_mp3.c', 00H
	ORG $+3
$SG130030 DB	'^1Error:^7 %s', 0aH, 00H
	ORG $+1
$SG130033 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_mp3.c', 00H
	ORG $+3
$SG130069 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\soundlib\snd_mp3.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_FreeMPG PROC

; 289  : {

	push	ebp
	mov	ebp, esp

; 290  : 	if( stream->ptr )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@Stream_Fre

; 291  : 	{
; 292  : 		close_decoder( stream->ptr );

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_close_decoder
	add	esp, 4

; 293  : 		stream->ptr = NULL;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+28], 0
$LN2@Stream_Fre:

; 294  : 	}
; 295  : 
; 296  : 	if( stream->file )

	mov	ecx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN3@Stream_Fre

; 297  : 	{
; 298  : 		FS_Close( stream->file );

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_FS_Close
	add	esp, 4

; 299  : 		stream->file = NULL;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN3@Stream_Fre:

; 300  : 	}
; 301  : 
; 302  : 	Mem_Free( stream );

	push	302					; 0000012eH
	push	OFFSET $SG130069
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 303  : }

	pop	ebp
	ret	0
_Stream_FreeMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_GetPosMPG PROC

; 277  : {

	push	ebp
	mov	ebp, esp

; 278  : 	return get_stream_pos( stream->ptr );

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_get_stream_pos
	add	esp, 4

; 279  : }

	pop	ebp
	ret	0
_Stream_GetPosMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_newpos$ = 12						; size = 4
_Stream_SetPosMPG PROC

; 257  : {

	push	ebp
	mov	ebp, esp

; 258  : 	if( set_stream_pos( stream->ptr, newpos ) != -1 )

	mov	eax, DWORD PTR _newpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_set_stream_pos
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN2@Stream_Set

; 259  : 	{
; 260  : 		// flush any previous data
; 261  : 		stream->buffsize = 0;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8228], 0

; 262  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Stream_Set
$LN2@Stream_Set:

; 263  : 	}
; 264  : 
; 265  : 	// failed to seek for some reasons
; 266  : 	return false;

	xor	eax, eax
$LN1@Stream_Set:

; 267  : }

	pop	ebp
	ret	0
_Stream_SetPosMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
_TEXT	SEGMENT
_data$1 = -16						; size = 4
_mpg$ = -12						; size = 4
_outsize$2 = -8						; size = 4
_bytesWritten$ = -4					; size = 4
_stream$ = 8						; size = 4
_needBytes$ = 12					; size = 4
_buffer$ = 16						; size = 4
_Stream_ReadMPG PROC

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 210  : 	// buffer handling
; 211  : 	int	bytesWritten = 0;

	mov	DWORD PTR _bytesWritten$[ebp], 0

; 212  : 	void	*mpg;
; 213  : 
; 214  : 	mpg = stream->ptr;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _mpg$[ebp], ecx
$LN2@Stream_Rea:

; 215  : 
; 216  : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN3@Stream_Rea

; 217  : 	{
; 218  : 		byte	*data;
; 219  : 		long	outsize;
; 220  : 
; 221  : 		if( !stream->buffsize )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+8228], 0
	jne	SHORT $LN4@Stream_Rea

; 222  : 		{
; 223  : 			if( read_mpeg_stream( mpg, stream->temp, &stream->pos ) != MP3_OK )

	mov	ecx, DWORD PTR _stream$[ebp]
	add	ecx, 8224				; 00002020H
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _mpg$[ebp]
	push	eax
	call	_read_mpeg_stream
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@Stream_Rea

; 224  : 				break; // there was end of the stream

	jmp	$LN3@Stream_Rea
$LN4@Stream_Rea:

; 225  : 		}
; 226  : 
; 227  : 		// check remaining size
; 228  : 		if( bytesWritten + stream->pos > needBytes )

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _bytesWritten$[ebp]
	add	edx, DWORD PTR [ecx+8224]
	cmp	edx, DWORD PTR _needBytes$[ebp]
	jbe	SHORT $LN6@Stream_Rea

; 229  : 			outsize = ( needBytes - bytesWritten ); 

	mov	eax, DWORD PTR _needBytes$[ebp]
	sub	eax, DWORD PTR _bytesWritten$[ebp]
	mov	DWORD PTR _outsize$2[ebp], eax
	jmp	SHORT $LN7@Stream_Rea
$LN6@Stream_Rea:

; 230  : 		else outsize = stream->pos;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+8224]
	mov	DWORD PTR _outsize$2[ebp], edx
$LN7@Stream_Rea:

; 231  : 
; 232  : 		// copy raw sample to output buffer
; 233  : 		data = (byte *)buffer + bytesWritten;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _bytesWritten$[ebp]
	mov	DWORD PTR _data$1[ebp], eax

; 234  : 		memcpy( data, &stream->temp[stream->buffsize], outsize );

	mov	ecx, DWORD PTR _outsize$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8228]
	mov	ecx, DWORD PTR _stream$[ebp]
	lea	edx, DWORD PTR [ecx+eax+32]
	push	edx
	mov	eax, DWORD PTR _data$1[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 235  : 		bytesWritten += outsize;

	mov	ecx, DWORD PTR _bytesWritten$[ebp]
	add	ecx, DWORD PTR _outsize$2[ebp]
	mov	DWORD PTR _bytesWritten$[ebp], ecx

; 236  : 		stream->pos -= outsize;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8224]
	sub	eax, DWORD PTR _outsize$2[ebp]
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+8224], eax

; 237  : 		stream->buffsize += outsize;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8228]
	add	eax, DWORD PTR _outsize$2[ebp]
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+8228], eax

; 238  : 
; 239  : 		// continue from this sample on a next call
; 240  : 		if( bytesWritten >= needBytes )

	mov	edx, DWORD PTR _bytesWritten$[ebp]
	cmp	edx, DWORD PTR _needBytes$[ebp]
	jl	SHORT $LN8@Stream_Rea

; 241  : 			return bytesWritten;

	mov	eax, DWORD PTR _bytesWritten$[ebp]
	jmp	SHORT $LN1@Stream_Rea
$LN8@Stream_Rea:

; 242  : 
; 243  : 		stream->buffsize = 0; // no bytes remaining

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8228], 0

; 244  : 	}

	jmp	$LN2@Stream_Rea
$LN3@Stream_Rea:

; 245  : 
; 246  : 	return 0;

	xor	eax, eax
$LN1@Stream_Rea:

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_ReadMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
_TEXT	SEGMENT
_ret$ = -32						; size = 4
_file$ = -28						; size = 4
_mpeg$ = -24						; size = 4
_stream$ = -20						; size = 4
_sc$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_Stream_OpenMPG PROC

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 	stream_t	*stream;
; 151  : 	void	*mpeg;
; 152  : 	file_t	*file;
; 153  : 	int	ret;
; 154  : 	wavinfo_t	sc;
; 155  : 
; 156  : 	file = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET $SG130023
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax

; 157  : 	if( !file ) return NULL;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@Stream_Ope
	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN2@Stream_Ope:

; 158  : 
; 159  : 	// at this point we have valid stream
; 160  : 	stream = Mem_Calloc( host.soundpool, sizeof( stream_t ));

	push	160					; 000000a0H
	push	OFFSET $SG130025
	push	1
	push	8232					; 00002028H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _stream$[ebp], eax

; 161  : 	stream->file = file;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+4], eax

; 162  : 	stream->pos = 0;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+8224], 0

; 163  : 
; 164  : 	// couldn't create decoder
; 165  : 	if(( mpeg = create_decoder( &ret )) == NULL )

	lea	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_create_decoder
	add	esp, 4
	mov	DWORD PTR _mpeg$[ebp], eax
	cmp	DWORD PTR _mpeg$[ebp], 0
	jne	SHORT $LN3@Stream_Ope

; 166  : 	{
; 167  : 		Con_DPrintf( S_ERROR "Stream_OpenMPG: couldn't create decoder\n" );

	push	OFFSET $SG130027
	call	_Con_DPrintf
	add	esp, 4

; 168  : 		Mem_Free( stream );

	push	168					; 000000a8H
	push	OFFSET $SG130028
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 169  : 		FS_Close( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 170  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN3@Stream_Ope:

; 171  : 	}
; 172  : 
; 173  : #ifdef _DEBUG
; 174  : 	if( ret ) Con_DPrintf( S_ERROR "%s\n", get_error( mpeg ));

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@Stream_Ope
	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_get_error
	add	esp, 4
	push	eax
	push	OFFSET $SG130030
	call	_Con_DPrintf
	add	esp, 8
$LN4@Stream_Ope:

; 175  : #endif
; 176  : 	// trying to open stream and read header
; 177  : 	if( !open_mpeg_stream( mpeg, file, FS_Read, FS_Seek, &sc ))

	lea	eax, DWORD PTR _sc$[ebp]
	push	eax
	push	OFFSET _FS_Seek
	push	OFFSET _FS_Read
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_open_mpeg_stream
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN5@Stream_Ope

; 178  : 	{
; 179  : #ifdef _DEBUG
; 180  : 		Con_DPrintf( S_ERROR "Stream_OpenMPG: failed to load (%s): %s\n", filename, get_error( mpeg ));

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_get_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG130032
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 181  : #else
; 182  : 		Con_DPrintf( S_ERROR "Stream_OpenMPG: (%s) is probably corrupted\n", filename );
; 183  : #endif
; 184  : 		close_decoder( mpeg );

	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_close_decoder
	add	esp, 4

; 185  : 		Mem_Free( stream );

	push	185					; 000000b9H
	push	OFFSET $SG130033
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 186  : 		FS_Close( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 187  : 
; 188  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Stream_Ope
$LN5@Stream_Ope:

; 189  : 	}
; 190  : 
; 191  : 	stream->buffsize = 0; // how many samples left from previous frame

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+8228], 0

; 192  : 	stream->channels = sc.channels;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sc$[ebp+4]
	mov	DWORD PTR [eax+16], ecx

; 193  : 	stream->rate = sc.rate;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [edx+12], eax

; 194  : 	stream->width = 2;	// always 16 bit

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+8], 2

; 195  : 	stream->ptr = mpeg;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _mpeg$[ebp]
	mov	DWORD PTR [edx+28], eax

; 196  : 	stream->type = WF_MPGDATA;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+20], 2

; 197  : 
; 198  : 	return stream;

	mov	eax, DWORD PTR _stream$[ebp]
$LN1@Stream_Ope:

; 199  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_OpenMPG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\soundlib\snd_mp3.c
_TEXT	SEGMENT
_data$1 = -8244						; size = 4
_padsize$ = -8240					; size = 4
_ret$ = -8236						; size = 4
_size$2 = -8232						; size = 4
_bufsize$3 = -8228					; size = 4
_outsize$ = -8224					; size = 4
_bytesWrite$ = -8220					; size = 4
_pos$ = -8216						; size = 4
_mpeg$ = -8212						; size = 4
_sc$ = -8208						; size = 12
_out$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Sound_LoadMPG PROC

; 56   : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8244				; 00002034H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 57   : 	void	*mpeg;
; 58   : 	size_t	pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 59   : 	size_t	bytesWrite = 0;

	mov	DWORD PTR _bytesWrite$[ebp], 0

; 60   : 	char	out[OUTBUF_SIZE];
; 61   : 	size_t	outsize, padsize;
; 62   : 	int	ret;
; 63   : 	wavinfo_t	sc;
; 64   : 
; 65   : 	// load the file
; 66   : 	if( !buffer || filesize < FRAME_SIZE )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN5@Sound_Load
	cmp	DWORD PTR _filesize$[ebp], 32768	; 00008000H
	jae	SHORT $LN4@Sound_Load
$LN5@Sound_Load:

; 67   : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN4@Sound_Load:

; 68   : 
; 69   : 	// couldn't create decoder
; 70   : 	if(( mpeg = create_decoder( &ret )) == NULL )

	lea	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_create_decoder
	add	esp, 4
	mov	DWORD PTR _mpeg$[ebp], eax
	cmp	DWORD PTR _mpeg$[ebp], 0
	jne	SHORT $LN6@Sound_Load

; 71   : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN6@Sound_Load:

; 72   : 
; 73   : #ifdef _DEBUG
; 74   : 	if( ret ) Con_DPrintf( S_ERROR "%s\n", get_error( mpeg ));

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN7@Sound_Load
	mov	ecx, DWORD PTR _mpeg$[ebp]
	push	ecx
	call	_get_error
	add	esp, 4
	push	eax
	push	OFFSET $SG129998
	call	_Con_DPrintf
	add	esp, 8
$LN7@Sound_Load:

; 75   : #endif
; 76   : 
; 77   : 	// trying to read header
; 78   : 	if( !feed_mpeg_header( mpeg, buffer, FRAME_SIZE, filesize, &sc ))

	lea	edx, DWORD PTR _sc$[ebp]
	push	edx
	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	push	32768					; 00008000H
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_feed_mpeg_header
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN8@Sound_Load

; 79   : 	{
; 80   : #ifdef _DEBUG
; 81   : 		Con_DPrintf( S_ERROR "Sound_LoadMPG: failed to load (%s): %s\n", name, get_error( mpeg ));

	mov	eax, DWORD PTR _mpeg$[ebp]
	push	eax
	call	_get_error
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG130000
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 82   : #else
; 83   : 		Con_DPrintf( S_ERROR "Sound_LoadMPG: (%s) is probably corrupted\n", name );
; 84   : #endif
; 85   : 		close_decoder( mpeg );

	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_close_decoder
	add	esp, 4

; 86   : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN8@Sound_Load:

; 87   : 	}
; 88   : 
; 89   : 	sound.channels = sc.channels;

	mov	eax, DWORD PTR _sc$[ebp+4]
	mov	DWORD PTR _sound+20, eax

; 90   : 	sound.rate = sc.rate;

	mov	ecx, DWORD PTR _sc$[ebp]
	mov	DWORD PTR _sound+12, ecx

; 91   : 	sound.width = 2; // always 16-bit PCM

	mov	DWORD PTR _sound+16, 2

; 92   : 	sound.loopstart = -1;

	mov	DWORD PTR _sound+24, -1

; 93   : 	sound.size = ( sound.channels * sound.rate * sound.width ) * ( sc.playtime / 1000 ); // in bytes

	mov	ecx, DWORD PTR _sound+20
	imul	ecx, DWORD PTR _sound+12
	imul	ecx, DWORD PTR _sound+16
	mov	eax, DWORD PTR _sc$[ebp+8]
	cdq
	mov	esi, 1000				; 000003e8H
	idiv	esi
	imul	ecx, eax
	mov	DWORD PTR _sound+36, ecx

; 94   : 	padsize = sound.size % FRAME_SIZE;

	mov	eax, DWORD PTR _sound+36
	xor	edx, edx
	mov	ecx, 32768				; 00008000H
	div	ecx
	mov	DWORD PTR _padsize$[ebp], edx

; 95   : 	pos += FRAME_SIZE; // evaluate pos

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, 32768				; 00008000H
	mov	DWORD PTR _pos$[ebp], edx

; 96   : 
; 97   : 	if( !sound.size )

	cmp	DWORD PTR _sound+36, 0
	jne	SHORT $LN9@Sound_Load

; 98   : 	{
; 99   : 		// bad mpeg file ?
; 100  : 		Con_DPrintf( S_ERROR "Sound_LoadMPG: (%s) is probably corrupted\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG130002
	call	_Con_DPrintf
	add	esp, 8

; 101  : 		close_decoder( mpeg );

	mov	ecx, DWORD PTR _mpeg$[ebp]
	push	ecx
	call	_close_decoder
	add	esp, 4

; 102  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN9@Sound_Load:

; 103  : 	}
; 104  : 
; 105  : 	// add sentinel make sure we not overrun
; 106  : 	sound.wav = (byte *)Mem_Calloc( host.soundpool, sound.size + padsize );

	push	106					; 0000006aH
	push	OFFSET $SG130003
	push	1
	mov	edx, DWORD PTR _sound+36
	add	edx, DWORD PTR _padsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _sound+40, eax

; 107  : 	sound.type = WF_PCMDATA;

	mov	DWORD PTR _sound+8, 1
$LN2@Sound_Load:

; 108  : 
; 109  : 	// decompress mpg into pcm wav format
; 110  : 	while( bytesWrite < sound.size )

	mov	ecx, DWORD PTR _bytesWrite$[ebp]
	cmp	ecx, DWORD PTR _sound+36
	jae	$LN3@Sound_Load

; 111  : 	{
; 112  : 		int	size;
; 113  : 
; 114  : 		if( feed_mpeg_stream( mpeg, NULL, 0, out, &outsize ) != MP3_OK && outsize <= 0 )

	lea	edx, DWORD PTR _outsize$[ebp]
	push	edx
	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _mpeg$[ebp]
	push	ecx
	call	_feed_mpeg_stream
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN10@Sound_Load
	cmp	DWORD PTR _outsize$[ebp], 0
	ja	SHORT $LN10@Sound_Load

; 115  : 		{
; 116  : 			char	*data = (char *)buffer + pos;

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR _data$1[ebp], edx

; 117  : 			int	bufsize;
; 118  : 
; 119  : 			// if there are no bytes remainig so we can decompress the new frame
; 120  : 			if( pos + FRAME_SIZE > filesize )

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, 32768				; 00008000H
	cmp	eax, DWORD PTR _filesize$[ebp]
	jbe	SHORT $LN11@Sound_Load

; 121  : 				bufsize = ( filesize - pos );

	mov	ecx, DWORD PTR _filesize$[ebp]
	sub	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR _bufsize$3[ebp], ecx
	jmp	SHORT $LN12@Sound_Load
$LN11@Sound_Load:

; 122  : 			else bufsize = FRAME_SIZE;

	mov	DWORD PTR _bufsize$3[ebp], 32768	; 00008000H
$LN12@Sound_Load:

; 123  : 			pos += bufsize;

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR _bufsize$3[ebp]
	mov	DWORD PTR _pos$[ebp], edx

; 124  : 
; 125  : 			if( feed_mpeg_stream( mpeg, data, bufsize, out, &outsize ) != MP3_OK )

	lea	eax, DWORD PTR _outsize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bufsize$3[ebp]
	push	edx
	mov	eax, DWORD PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpeg$[ebp]
	push	ecx
	call	_feed_mpeg_stream
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN10@Sound_Load

; 126  : 				break; // there was end of the stream

	jmp	SHORT $LN3@Sound_Load
$LN10@Sound_Load:

; 127  : 		}
; 128  : 
; 129  : 		if( bytesWrite + outsize > sound.size )

	mov	edx, DWORD PTR _bytesWrite$[ebp]
	add	edx, DWORD PTR _outsize$[ebp]
	cmp	edx, DWORD PTR _sound+36
	jbe	SHORT $LN14@Sound_Load

; 130  : 			size = ( sound.size - bytesWrite );

	mov	eax, DWORD PTR _sound+36
	sub	eax, DWORD PTR _bytesWrite$[ebp]
	mov	DWORD PTR _size$2[ebp], eax
	jmp	SHORT $LN15@Sound_Load
$LN14@Sound_Load:

; 131  : 		else size = outsize;

	mov	ecx, DWORD PTR _outsize$[ebp]
	mov	DWORD PTR _size$2[ebp], ecx
$LN15@Sound_Load:

; 132  : 
; 133  : 		memcpy( &sound.wav[bytesWrite], out, size );

	mov	edx, DWORD PTR _size$2[ebp]
	push	edx
	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sound+40
	add	ecx, DWORD PTR _bytesWrite$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 134  : 		bytesWrite += size;

	mov	edx, DWORD PTR _bytesWrite$[ebp]
	add	edx, DWORD PTR _size$2[ebp]
	mov	DWORD PTR _bytesWrite$[ebp], edx

; 135  : 	}

	jmp	$LN2@Sound_Load
$LN3@Sound_Load:

; 136  : 
; 137  : 	sound.samples = bytesWrite / ( sound.width * sound.channels );

	mov	ecx, DWORD PTR _sound+16
	imul	ecx, DWORD PTR _sound+20
	mov	eax, DWORD PTR _bytesWrite$[ebp]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _sound+28, eax

; 138  : 	close_decoder( mpeg );

	mov	edx, DWORD PTR _mpeg$[ebp]
	push	edx
	call	_close_decoder
	add	esp, 4

; 139  : 
; 140  : 	return true;

	mov	eax, 1
$LN1@Sound_Load:

; 141  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_LoadMPG ENDP
_TEXT	ENDS
END
