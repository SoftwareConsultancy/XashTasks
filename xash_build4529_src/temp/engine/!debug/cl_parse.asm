; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\client\cl_parse.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CL_UPDATE_BACKUP
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_DATA	SEGMENT
_CL_UPDATE_BACKUP DD 010H
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_CL_BatchResourceRequest
PUBLIC	_CL_EstimateNeededResources
PUBLIC	_CL_ParseUserMessage
PUBLIC	_CL_EDICT_NUM
PUBLIC	_CL_ParseServerMessage
PUBLIC	_CL_StartResourceDownloading
PUBLIC	_CL_DispatchUserMessage
PUBLIC	_CL_RequestMissingResources
PUBLIC	_CL_RegisterResources
PUBLIC	_CL_ParseViewEntity
PUBLIC	_CL_ParseServerTime
PUBLIC	_CL_WeaponAnim
PUBLIC	_CL_UserMsgStub
PUBLIC	_CL_ParseSoundPacket
PUBLIC	_CL_ParseRestoreSoundPacket
PUBLIC	_CL_ParseSignon
PUBLIC	_CL_ParseMovevars
PUBLIC	_CL_ParseParticles
PUBLIC	_CL_ParseStaticEntity
PUBLIC	_CL_ParseStaticDecal
PUBLIC	_CL_ParseSoundFade
PUBLIC	_CL_PlayerHasCustomization
PUBLIC	_CL_RemoveCustomization
PUBLIC	_CL_ParseCustomization
PUBLIC	_CL_ParseResourceRequest
PUBLIC	_CL_CreateCustomizationList
PUBLIC	_CL_ParseFileTransferFailed
PUBLIC	_CL_ParseServerData
PUBLIC	_CL_ParseClientData
PUBLIC	_CL_ParseBaseline
PUBLIC	_CL_ParseLightStyle
PUBLIC	_CL_ParseSetAngle
PUBLIC	_CL_ParseAddAngle
PUBLIC	_CL_ParseCrosshairAngle
PUBLIC	_CL_ParseRestore
PUBLIC	_CL_RegisterUserMessage
PUBLIC	_CL_UpdateUserinfo
PUBLIC	_CL_ParseResource
PUBLIC	_CL_UpdateUserPings
PUBLIC	_CL_SendConsistencyInfo
PUBLIC	_CL_ParseConsistencyInfo
PUBLIC	_CL_ParseResourceList
PUBLIC	_CL_ParseVoiceInit
PUBLIC	_CL_ParseVoiceData
PUBLIC	_CL_ParseResLocation
PUBLIC	_CL_ParseHLTV
PUBLIC	_CL_ParseDirector
PUBLIC	_CL_ParseScreenShake
PUBLIC	_CL_ParseScreenFade
PUBLIC	_CL_ParseCvarValue
PUBLIC	_CL_ParseCvarValue2
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@39800000
PUBLIC	__real@3a83126f
PUBLIC	__real@3b800000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3d800000
PUBLIC	__real@3e000000
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@42800000
PUBLIC	__real@437f0000
PUBLIC	__real@45800000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c000000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strrchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Host_AbortCurrentFrame:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Host_Credits:PROC
EXTRN	_SV_Active:PROC
EXTRN	_COM_IsSafeFileToDownload:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_CRC32_File:PROC
EXTRN	_MD5_HashFile:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_COM_CreateCustomization:PROC
EXTRN	_COM_SizeofResourceList:PROC
EXTRN	_CSCR_LoadDefaultCVars:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_R_DecalRemoveAll:PROC
EXTRN	_CL_ServerCommand:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_CL_Disconnect:PROC
EXTRN	_CL_Drop:PROC
EXTRN	_SCR_BeginLoadingPlaque:PROC
EXTRN	_Con_Print:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	_fabs:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_Mod_ValidateCRC:PROC
EXTRN	_Mod_NeedCRC:PROC
EXTRN	_Mod_FreeUnused:PROC
EXTRN	_Mod_GetStudioBounds:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteShort:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadOneBit:PROC
EXTRN	_MSG_ReadBitAngle:PROC
EXTRN	_MSG_ReadSBitLong:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadCmd:PROC
EXTRN	_MSG_ReadChar:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadFloat:PROC
EXTRN	_MSG_ReadVec3Coord:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_FragSend:PROC
EXTRN	_CL_SetLightstyle:PROC
EXTRN	_CL_CheckFile:PROC
EXTRN	_CL_AddToResourceList:PROC
EXTRN	_CL_RemoveFromResourceList:PROC
EXTRN	_CL_MoveToOnHandList:PROC
EXTRN	_CL_Parse_Debug:PROC
EXTRN	_CL_Parse_RecordCommand:PROC
EXTRN	_CL_ResetFrame:PROC
EXTRN	_CL_ProcessFile:PROC
EXTRN	_CL_PrecacheResources:PROC
EXTRN	_CL_SetupOverviewParams:PROC
EXTRN	_CL_SignonReply:PROC
EXTRN	_CL_ClearState:PROC
EXTRN	_CL_WriteDemoMessage:PROC
EXTRN	_CL_ParseEvent:PROC
EXTRN	_CL_ParseReliableEvent:PROC
EXTRN	_CL_LinkUserMessage:PROC
EXTRN	_CL_ParseFinaleCutscene:PROC
EXTRN	_CL_InitEdicts:PROC
EXTRN	_CL_ClearWorld:PROC
EXTRN	_CL_CenterPrint:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_ParseTempEntity:PROC
EXTRN	_SCR_EndLoadingPlaque:PROC
EXTRN	_CL_ParsePacketEntities:PROC
EXTRN	_CL_ResetLatchedVars:PROC
EXTRN	_CL_IsPlayerIndex:PROC
EXTRN	_CL_FireCustomDecal:PROC
EXTRN	_CL_AddClientResources:PROC
EXTRN	_CL_LoadClientSprites:PROC
EXTRN	_Con_FixedFont:PROC
EXTRN	_Con_ClearNotify:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_RestoreSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_S_AmbientSound:PROC
EXTRN	_S_FadeClientVolume:PROC
EXTRN	_Delta_InitClient:PROC
EXTRN	_Delta_ParseTableField:PROC
EXTRN	_MSG_ReadDeltaMovevars:PROC
EXTRN	_MSG_ReadClientData:PROC
EXTRN	_MSG_ReadWeaponData:PROC
EXTRN	_MSG_ReadDeltaEntity:PROC
EXTRN	_R_SetupSky:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_R_AddEfrags:PROC
EXTRN	_R_NewMap:PROC
EXTRN	_R_AllocParticle:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_CL_DecalIndex:PROC
EXTRN	_IN_MouseRestorePos:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gameui:BYTE
EXTRN	_mp_decals:BYTE
EXTRN	_cl_allow_download:BYTE
EXTRN	_cl_download_ingame:BYTE
EXTRN	_cl_levelshot_name:DWORD
EXTRN	_cl_clockreset:DWORD
EXTRN	_glState:BYTE
EXTRN	_r_decals:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b800000
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@39800000
CONST	SEGMENT
__real@39800000 DD 039800000r			; 0.000244141
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG144585 DB	'!#%i', 00H
	ORG $+3
$SG144586 DB	'!%i', 00H
$SG144619 DB	'!%i', 00H
$SG144620 DB	'!%i', 00H
$SG144638 DB	'^1Error:^7 received signon %i when at %i', 0aH, 00H
	ORG $+2
$SG144676 DB	'^1Error:^7 MAX_STATIC_ENTITIES limit exceeded!', 0aH, 00H
$SG144738 DB	'Resource Batch', 00H
	ORG $+1
$SG144742 DB	'skipping in game download of %s', 0aH, 00H
	ORG $+3
$SG144750 DB	'custom.hpk', 00H
	ORG $+1
$SG144752 DB	'!MD5%s', 00H
	ORG $+1
$SG144753 DB	'dlfile %s', 00H
	ORG $+2
$SG144756 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144773 DB	'sound/', 00H
	ORG $+1
$SG144774 DB	'%s%s', 00H
	ORG $+3
$SG144789 DB	'%s', 00H
	ORG $+1
$SG144842 DB	'Bogus player index during customization parsing.', 0aH, 00H
	ORG $+2
$SG144817 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144821 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144843 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144846 DB	'Refusing new resource, cl_allow_download set to 0', 0aH, 00H
	ORG $+1
$SG144849 DB	'Refusing new resource, cl_download_ingame set to 0', 0aH
	DB	00H
$SG144847 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144850 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144855 DB	'custom.hpk', 00H
	ORG $+1
$SG144859 DB	'Duplicate resource ignored for local client', 0aH, 00H
	ORG $+3
$SG144861 DB	'Error loading customization', 0aH, 00H
	ORG $+3
$SG144863 DB	'Requesting %s from server', 0aH, 00H
	ORG $+1
$SG144862 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG144864 DB	'Custom resource propagation...', 0aH, 00H
$SG144878 DB	'ResourceBlock', 00H
	ORG $+2
$SG144896 DB	'problem with client customization %s, ignoring...', 00H
	ORG $+2
$SG144917 DB	'Serverdata packet received.', 0aH, 00H
	ORG $+3
$SG144920 DB	'Server use invalid protocol (%i should be %i)', 0aH, 00H
	ORG $+1
$SG144924 DB	0aH, 01dH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01fH, 0aH, 00H
$SG144928 DB	'user.scr', 00H
	ORG $+3
$SG144922 DB	'^3Warning:^7 server model limit is above client model li'
	DB	'mit %i > %i', 0aH, 00H
	ORG $+3
$SG144925 DB	'%c%s', 0aH, 0aH, 00H
	ORG $+1
$SG144930 DB	'r_decals', 00H
	ORG $+3
$SG144931 DB	'r_decals', 00H
	ORG $+3
$SG144936 DB	'1', 00H
	ORG $+2
$SG144937 DB	'cl_background', 00H
	ORG $+2
$SG144938 DB	'0', 00H
	ORG $+2
$SG144939 DB	'cl_background', 00H
	ORG $+2
$SG144948 DB	'16x9', 00H
	ORG $+3
$SG144949 DB	'4x3', 00H
$SG144950 DB	'levelshots/%s_%s', 00H
	ORG $+3
$SG144951 DB	'cl_levelshot_name', 00H
	ORG $+2
$SG144952 DB	'16x9', 00H
	ORG $+3
$SG144953 DB	'4x3', 00H
$SG144954 DB	'levelshots/%s_%s', 00H
	ORG $+3
$SG144955 DB	'cl_levelshot_name', 00H
	ORG $+2
$SG144956 DB	'scr_loading', 00H
$SG144961 DB	'%s.bmp', 00H
	ORG $+1
$SG144962 DB	'*black', 00H
	ORG $+1
$SG144963 DB	'cl_levelshot_name', 00H
	ORG $+2
$SG144964 DB	'sendres %i', 0aH, 00H
$SG145027 DB	'CL_AllocEdict: no free edicts', 0aH, 00H
	ORG $+1
$SG145060 DB	'Loading decals from %s', 0aH, 00H
$SG145079 DB	'CL_ParseServerMessage: svc_updateuserinfo >= MAX_CLIENTS'
	DB	0aH, 00H
	ORG $+2
$SG145082 DB	'name', 00H
	ORG $+3
$SG145083 DB	'model', 00H
	ORG $+2
$SG145084 DB	'topcolor', 00H
	ORG $+3
$SG145085 DB	'bottomcolor', 00H
$SG145086 DB	'*hltv', 00H
	ORG $+2
$SG145094 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG145109 DB	'CL_ParseServerMessage: svc_pings > MAX_CLIENTS', 0aH, 00H
$SG145133 DB	'sound/', 00H
	ORG $+1
$SG145134 DB	'%s%s', 00H
	ORG $+3
$SG145136 DB	'models/', 00H
$SG145142 DB	'unable to find %s', 0aH, 00H
	ORG $+1
$SG145145 DB	'Unknown consistency type %i', 0aH, 00H
	ORG $+3
$SG145164 DB	'assert failed at %s:%i', 0aH, 00H
$SG145170 DB	'spawn %i', 00H
	ORG $+3
$SG145163 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG145166 DB	'Setting up renderer...', 0aH, 00H
$SG145171 DB	'^1Error:^7 client world model is NULL', 0aH, 00H
	ORG $+1
$SG145196 DB	'models/', 00H
$SG145198 DB	'CL_CheckConsistency: MAX_MODELS limit exceeded (%d)', 0aH
	DB	00H
	ORG $+3
$SG145211 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_parse.c', 00H
	ORG $+3
$SG145214 DB	'Verifying and downloading resources...', 0aH, 00H
$SG145231 DB	'http://', 00H
$SG145232 DB	'https://', 00H
	ORG $+3
$SG145235 DB	'%s/', 00H
$SG145236 DB	'Using %s as primary download location', 0aH, 00H
	ORG $+1
$SG145290 DB	'Not Found', 00H
	ORG $+2
$SG145303 DB	'%s (%g)', 00H
$SG145304 DB	'Not Found', 00H
	ORG $+2
$SG145319 DB	'^1Error:^7 UserMsg: bad message %s', 0aH, 00H
$SG145322 DB	'^1Error:^7 UserMsg: No pfn %s %d', 0aH, 00H
	ORG $+2
$SG145337 DB	'CL_ParseUserMessage: illegible server message %d', 0aH, 00H
	ORG $+2
$SG145340 DB	'CL_ParseUserMessage: illegible server message %d', 0aH, 00H
	ORG $+2
$SG145343 DB	'ScreenShake', 00H
$SG145345 DB	'ScreenFade', 00H
	ORG $+1
$SG145350 DB	'HudText', 00H
$SG145351 DB	'valve', 00H
	ORG $+2
$SG145353 DB	'END3', 00H
	ORG $+3
$SG145354 DB	'^1Error:^7 UserMsg: No pfn %s %d', 0aH, 00H
	ORG $+2
$SG145375 DB	'CL_ParseServerMessage: overflow!', 0aH, 00H
	ORG $+2
$SG145378 DB	'svc_bad', 0aH, 00H
	ORG $+3
$SG145385 DB	'Server changing, reconnecting', 0aH, 00H
	ORG $+1
$SG145387 DB	'Server disconnected, reconnecting', 0aH, 00H
	ORG $+1
$SG145396 DB	'%s', 00H
	ORG $+1
$SG145399 DB	'disconnect', 00H
	ORG $+1
$SG145425 DB	'room_type', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
_DATA	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv145 = -16						; size = 4
_requestID$ = -12					; size = 4
_cvarName$ = -8						; size = 4
_cvar$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseCvarValue2 PROC

; 1829 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1830 : 	int requestID = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _requestID$[ebp], eax

; 1831 : 	const char *cvarName = MSG_ReadString( msg );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _cvarName$[ebp], eax

; 1832 : 	convar_t *cvar = Cvar_FindVar( cvarName );

	push	0
	mov	edx, DWORD PTR _cvarName$[ebp]
	push	edx
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cvar$[ebp], eax

; 1833 : 
; 1834 : 	// build the answer
; 1835 : 	MSG_BeginClientCmd( &cls.netchan.message, clc_requestcvarvalue2 );

	push	0
	push	0
	push	10					; 0000000aH
	push	OFFSET _cls+23620
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1836 : 	MSG_WriteLong( &cls.netchan.message, requestID );

	mov	eax, DWORD PTR _requestID$[ebp]
	push	eax
	push	OFFSET _cls+23620
	call	_MSG_WriteLong
	add	esp, 8

; 1837 : 	MSG_WriteString( &cls.netchan.message, cvarName );

	mov	ecx, DWORD PTR _cvarName$[ebp]
	push	ecx
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8

; 1838 : 
; 1839 : 	if( cvar )

	cmp	DWORD PTR _cvar$[ebp], 0
	je	SHORT $LN2@CL_ParseCv

; 1840 : 	{
; 1841 : 		// cheater can change value ignoring Cvar_Set so we responce incorrect value
; 1842 : 		if( cvar->value != Q_atof( cvar->string ))

	mov	edx, DWORD PTR _cvar$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv145[ebp]
	mov	ecx, DWORD PTR _cvar$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR tv145[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@CL_ParseCv

; 1843 : 			MSG_WriteString( &cls.netchan.message, va( "%s (%g)", cvar->string, cvar->value ));

	mov	edx, DWORD PTR _cvar$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cvar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET $SG145303
	call	_va
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8
	jmp	SHORT $LN5@CL_ParseCv
$LN4@CL_ParseCv:

; 1844 : 		else MSG_WriteString( &cls.netchan.message, cvar->string );

	mov	edx, DWORD PTR _cvar$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8
$LN5@CL_ParseCv:

; 1845 : 	}	

	jmp	SHORT $LN3@CL_ParseCv
$LN2@CL_ParseCv:

; 1846 : 	else
; 1847 : 	{
; 1848 : 		MSG_WriteString( &cls.netchan.message, "Not Found" );

	push	OFFSET $SG145304
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8
$LN3@CL_ParseCv:

; 1849 : 	}
; 1850 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCvarValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_cvarName$ = -12					; size = 4
tv77 = -8						; size = 4
_cvar$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseCvarValue PROC

; 1811 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1812 : 	const char *cvarName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _cvarName$[ebp], eax

; 1813 : 	convar_t *cvar = Cvar_FindVar( cvarName );

	push	0
	mov	ecx, DWORD PTR _cvarName$[ebp]
	push	ecx
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cvar$[ebp], eax

; 1814 : 
; 1815 : 	// build the answer
; 1816 : 	MSG_BeginClientCmd( &cls.netchan.message, clc_requestcvarvalue );

	push	0
	push	0
	push	9
	push	OFFSET _cls+23620
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1817 : 	MSG_WriteString( &cls.netchan.message, cvar ? cvar->string : "Not Found" );

	cmp	DWORD PTR _cvar$[ebp], 0
	je	SHORT $LN3@CL_ParseCv
	mov	edx, DWORD PTR _cvar$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN4@CL_ParseCv
$LN3@CL_ParseCv:
	mov	DWORD PTR tv77[ebp], OFFSET $SG145290
$LN4@CL_ParseCv:
	mov	ecx, DWORD PTR tv77[ebp]
	push	ecx
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8

; 1818 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCvarValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_holdTime$ = -20					; size = 4
_duration$ = -16					; size = 4
_flScale$ = -12						; size = 4
tv76 = -8						; size = 4
_sf$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseScreenFade PROC

; 1758 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1759 : 	float		duration, holdTime;
; 1760 : 	screenfade_t	*sf = &clgame.fade;

	mov	DWORD PTR _sf$[ebp], OFFSET _clgame+122740

; 1761 : 	float		flScale;
; 1762 : 
; 1763 : 	duration = (float)MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _duration$[ebp], xmm0

; 1764 : 	holdTime = (float)MSG_ReadWord( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _holdTime$[ebp], xmm0

; 1765 : 	sf->fadeFlags = MSG_ReadShort( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1766 : 	flScale = ( sf->fadeFlags & FFADE_LONGFADE ) ? (1.0f / 256.0f) : (1.0f / 4096.0f);

	mov	edx, DWORD PTR _sf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, 8
	je	SHORT $LN8@CL_ParseSc
	movss	xmm0, DWORD PTR __real@3b800000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN9@CL_ParseSc
$LN8@CL_ParseSc:
	movss	xmm0, DWORD PTR __real@39800000
	movss	DWORD PTR tv76[ebp], xmm0
$LN9@CL_ParseSc:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR _flScale$[ebp], xmm0

; 1767 : 
; 1768 : 	sf->fader = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	edx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [edx+16], al

; 1769 : 	sf->fadeg = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+17], al

; 1770 : 	sf->fadeb = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+18], al

; 1771 : 	sf->fadealpha = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+19], al

; 1772 : 	sf->fadeSpeed = 0.0f;

	mov	edx, DWORD PTR _sf$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx], xmm0

; 1773 : 	sf->fadeEnd = duration * flScale;

	movss	xmm0, DWORD PTR _duration$[ebp]
	mulss	xmm0, DWORD PTR _flScale$[ebp]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1774 : 	sf->fadeReset = holdTime * flScale;

	movss	xmm0, DWORD PTR _holdTime$[ebp]
	mulss	xmm0, DWORD PTR _flScale$[ebp]
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 1775 : 
; 1776 : 	// calc fade speed
; 1777 : 	if( duration > 0 )

	movss	xmm0, DWORD PTR _duration$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN4@CL_ParseSc

; 1778 : 	{
; 1779 : 		if( sf->fadeFlags & FFADE_OUT )

	mov	edx, DWORD PTR _sf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, 1
	je	SHORT $LN3@CL_ParseSc

; 1780 : 		{
; 1781 : 			if( sf->fadeEnd )

	mov	ecx, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@CL_ParseSc

; 1782 : 			{
; 1783 : 				sf->fadeSpeed = -(float)sf->fadealpha / sf->fadeEnd;

	mov	edx, DWORD PTR _sf$[ebp]
	movzx	eax, BYTE PTR [edx+19]
	cvtsi2ss xmm0, eax
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _sf$[ebp]
	divss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN5@CL_ParseSc:

; 1784 : 			}
; 1785 : 
; 1786 : 			sf->fadeEnd += cl.time;

	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1787 : 			sf->fadeReset += sf->fadeEnd;

	mov	edx, DWORD PTR _sf$[ebp]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	addss	xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 1788 : 		}

	jmp	SHORT $LN4@CL_ParseSc
$LN3@CL_ParseSc:

; 1789 : 		else
; 1790 : 		{
; 1791 : 			if( sf->fadeEnd )

	mov	edx, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_ParseSc

; 1792 : 			{
; 1793 : 				sf->fadeSpeed = (float)sf->fadealpha / sf->fadeEnd;

	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sf$[ebp]
	divss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN6@CL_ParseSc:

; 1794 : 			}
; 1795 : 
; 1796 : 			sf->fadeReset += cl.time;

	mov	ecx, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [edx+12], xmm0

; 1797 : 			sf->fadeEnd += sf->fadeReset;

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [edx+4], xmm0
$LN4@CL_ParseSc:

; 1798 : 		}
; 1799 : 	}
; 1800 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv83 = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseScreenShake PROC

; 1742 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1743 : 	clgame.shake.amplitude = (float)(word)MSG_ReadShort( msg ) * (1.0f / (float)(1<<12));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	movzx	ecx, ax
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@39800000
	movss	DWORD PTR _clgame+122772, xmm0

; 1744 : 	clgame.shake.duration = (float)(word)MSG_ReadShort( msg ) * (1.0f / (float)(1<<12));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	movzx	eax, ax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@39800000
	movss	DWORD PTR _clgame+122768, xmm0

; 1745 : 	clgame.shake.frequency = (float)(word)MSG_ReadShort( msg ) * (1.0f / (float)(1<<8));

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	movzx	edx, ax
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3b800000
	movss	DWORD PTR _clgame+122776, xmm0

; 1746 : 	clgame.shake.time = cl.time + max( clgame.shake.duration, 0.01f );

	movss	xmm0, DWORD PTR _clgame+122768
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN3@CL_ParseSc
	movss	xmm0, DWORD PTR _clgame+122768
	movss	DWORD PTR tv83[ebp], xmm0
	jmp	SHORT $LN4@CL_ParseSc
$LN3@CL_ParseSc:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv83[ebp], xmm0
$LN4@CL_ParseSc:
	cvtss2sd xmm0, DWORD PTR tv83[ebp]
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _clgame+122764, xmm0

; 1747 : 	clgame.shake.next_shake = 0.0f; // apply immediately

	xorps	xmm0, xmm0
	movss	DWORD PTR _clgame+122780, xmm0

; 1748 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseScreenShake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_iSize$ = -264						; size = 4
_pbuf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseDirector PROC

; 1725 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1726 : 	int	iSize = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax

; 1727 : 	byte	pbuf[256];
; 1728 : 
; 1729 : 	// parse user message into buffer
; 1730 : 	MSG_ReadBytes( msg, pbuf, iSize );

	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1731 : 	clgame.dllFuncs.pfnDirectorMessage( iSize, pbuf );

	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	call	DWORD PTR _clgame+156
	add	esp, 8

; 1732 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseDirector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseHLTV PROC

; 1690 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1691 : 	switch( MSG_ReadByte( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@CL_ParseHL
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@CL_ParseHL
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN6@CL_ParseHL
	jmp	$LN1@CL_ParseHL
$LN4@CL_ParseHL:

; 1692 : 	{
; 1693 : 	case HLTV_ACTIVE:
; 1694 : 		cl.proxy_redirect = true;

	mov	DWORD PTR _cl+72, 1

; 1695 : 		cls.spectator = true;

	mov	DWORD PTR _cls+152, 1

; 1696 : 		break;

	jmp	SHORT $LN1@CL_ParseHL
$LN5@CL_ParseHL:

; 1697 : 	case HLTV_STATUS:
; 1698 : 			MSG_ReadLong( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4

; 1699 : 			MSG_ReadShort( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4

; 1700 : 			MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4

; 1701 : 			MSG_ReadLong( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4

; 1702 : 			MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4

; 1703 : 			MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4

; 1704 : 		break;

	jmp	SHORT $LN1@CL_ParseHL
$LN6@CL_ParseHL:

; 1705 : 	case HLTV_LISTEN:
; 1706 : 		cls.signon = SIGNONS;

	mov	DWORD PTR _cls+64, 2

; 1707 : 		NET_StringToAdr( MSG_ReadString( msg ), &cls.hltv_listen_address );

	push	OFFSET _cls+44
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_NET_StringToAdr
	add	esp, 8

; 1708 : //		NET_JoinGroup( cls.netchan.sock, cls.hltv_listen_address );
; 1709 : 		SCR_EndLoadingPlaque();

	call	_SCR_EndLoadingPlaque
$LN1@CL_ParseHL:

; 1710 : 		break;
; 1711 : 	default:
; 1712 : 		break;
; 1713 : 	}
; 1714 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseHLTV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_lastSlash$1 = -8					; size = 4
_url$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseResLocation PROC

; 1667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1668 : 	const char	*url = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _url$[ebp], eax

; 1669 : 
; 1670 : 	if( url && ( !Q_strnicmp( "http://", url, 7 ) || !Q_strnicmp( "https://", url, 8 )))

	cmp	DWORD PTR _url$[ebp], 0
	je	$LN1@CL_ParseRe
	push	7
	mov	ecx, DWORD PTR _url$[ebp]
	push	ecx
	push	OFFSET $SG145231
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@CL_ParseRe
	push	8
	mov	edx, DWORD PTR _url$[ebp]
	push	edx
	push	OFFSET $SG145232
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@CL_ParseRe
$LN3@CL_ParseRe:

; 1671 : 	{
; 1672 : 		const char	*lastSlash = Q_strrchr( url, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _url$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _lastSlash$1[ebp], eax

; 1673 : 
; 1674 : 		if( lastSlash && lastSlash[1] == '\0' )

	cmp	DWORD PTR _lastSlash$1[ebp], 0
	je	SHORT $LN4@CL_ParseRe
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _lastSlash$1[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@CL_ParseRe

; 1675 : 			Q_strncpy( cl.downloadUrl, url, sizeof( cl.downloadUrl ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _url$[ebp]
	push	ecx
	push	OFFSET _cl+1561848
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@CL_ParseRe
$LN4@CL_ParseRe:

; 1676 : 		else Q_snprintf( cl.downloadUrl, sizeof( cl.downloadUrl ), "%s/", url );

	mov	edx, DWORD PTR _url$[ebp]
	push	edx
	push	OFFSET $SG145235
	push	256					; 00000100H
	push	OFFSET _cl+1561848
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN5@CL_ParseRe:

; 1677 : 		Con_Reportf( "Using %s as primary download location\n", cl.downloadUrl );

	push	OFFSET _cl+1561848
	push	OFFSET $SG145236
	call	_Con_Reportf
	add	esp, 8
$LN1@CL_ParseRe:

; 1678 : 	}
; 1679 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResLocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseVoiceData PROC

; 1656 : {

	push	ebp
	mov	ebp, esp

; 1657 : 	// TODO: ???
; 1658 : }

	pop	ebp
	ret	0
_CL_ParseVoiceData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseVoiceInit PROC

; 1645 : {

	push	ebp
	mov	ebp, esp

; 1646 : 	// TODO: ???
; 1647 : }

	pop	ebp
	ret	0
_CL_ParseVoiceInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_total$ = -12						; size = 4
_i$ = -8						; size = 4
_pResource$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseResourceList PROC

; 1608 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1609 : 	resource_t	*pResource;
; 1610 : 	int		i, total;
; 1611 : 
; 1612 : 	total = MSG_ReadUBitLong( msg, MAX_RESOURCE_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _total$[ebp], eax

; 1613 : 
; 1614 : 	for( i = 0; i < total; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseRe
$LN2@CL_ParseRe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_ParseRe:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _total$[ebp]
	jge	$LN3@CL_ParseRe

; 1615 : 	{
; 1616 : 		pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	push	1616					; 00000650H
	push	OFFSET $SG145211
	push	1
	push	136					; 00000088H
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 1617 : 		pResource->type = MSG_ReadUBitLong( msg, 4 );

	push	4
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1618 : 
; 1619 : 		Q_strncpy( pResource->szFileName, MSG_ReadString( msg ), sizeof( pResource->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1620 : 		pResource->nIndex = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 1621 : 		pResource->nDownloadSize = MSG_ReadSBitLong( msg, 24 );

	push	24					; 00000018H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadSBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 1622 : 		pResource->ucFlags = MSG_ReadUBitLong( msg, 3 ) & ~RES_WASMISSING;

	push	3
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 1623 : 
; 1624 : 		if( FBitSet( pResource->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	je	SHORT $LN5@CL_ParseRe

; 1625 : 			MSG_ReadBytes( msg, pResource->rgucMD5_hash, sizeof( pResource->rgucMD5_hash ));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN5@CL_ParseRe:

; 1626 : 
; 1627 : 		if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@CL_ParseRe

; 1628 : 			MSG_ReadBytes( msg, pResource->rguc_reserved, sizeof( pResource->rguc_reserved ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 94					; 0000005eH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN6@CL_ParseRe:

; 1629 : 
; 1630 : 		CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+1984996
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 1631 : 	}

	jmp	$LN2@CL_ParseRe
$LN3@CL_ParseRe:

; 1632 : 
; 1633 : 	CL_ParseConsistencyInfo( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseConsistencyInfo
	add	esp, 4

; 1634 : 
; 1635 : 	CL_StartResourceDownloading( "Verifying and downloading resources...\n", false );

	push	0
	push	OFFSET $SG145214
	call	_CL_StartResourceDownloading
	add	esp, 8

; 1636 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_skip$ = -72						; size = 4
_isdelta$ = -68						; size = 4
_skip_crc_change$ = -64					; size = 4
tv142 = -60						; size = 4
_lastcheck$ = -56					; size = 4
_i$ = -52						; size = 4
_delta$ = -48						; size = 4
_pc$ = -44						; size = 4
_pResource$ = -40					; size = 4
_nullbuffer$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseConsistencyInfo PROC

; 1543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1544 : 	int		lastcheck;
; 1545 : 	int		delta;
; 1546 : 	int		i;
; 1547 : 	int		isdelta;
; 1548 : 	resource_t	*pResource;
; 1549 : 	resource_t	*skip_crc_change;
; 1550 : 	int		skip;
; 1551 : 	consistency_t	*pc;
; 1552 : 	byte		nullbuffer[32];
; 1553 : 
; 1554 : 	memset( nullbuffer, 0, 32 );

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _nullbuffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1555 : 
; 1556 : 	cl.need_force_consistency_response = MSG_ReadOneBit( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _cl+1984856, eax

; 1557 : 	pResource = cl.resourcesneeded.pNext;

	mov	edx, DWORD PTR _cl+1985124
	mov	DWORD PTR _pResource$[ebp], edx

; 1558 : 
; 1559 : 	if( !cl.need_force_consistency_response )

	cmp	DWORD PTR _cl+1984856, 0
	jne	SHORT $LN7@CL_ParseCo

; 1560 : 		return;

	jmp	$LN1@CL_ParseCo
$LN7@CL_ParseCo:

; 1561 : 
; 1562 : 	skip_crc_change = NULL;

	mov	DWORD PTR _skip_crc_change$[ebp], 0

; 1563 : 	lastcheck = 0;

	mov	DWORD PTR _lastcheck$[ebp], 0
$LN2@CL_ParseCo:

; 1564 : 
; 1565 : 	while( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	$LN1@CL_ParseCo

; 1566 : 	{
; 1567 : 		isdelta = MSG_ReadOneBit( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _isdelta$[ebp], eax

; 1568 : 
; 1569 : 		if( isdelta ) delta = MSG_ReadUBitLong( msg, 5 ) + lastcheck;

	cmp	DWORD PTR _isdelta$[ebp], 0
	je	SHORT $LN8@CL_ParseCo
	push	5
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	add	eax, DWORD PTR _lastcheck$[ebp]
	mov	DWORD PTR _delta$[ebp], eax
	jmp	SHORT $LN9@CL_ParseCo
$LN8@CL_ParseCo:

; 1570 : 		else delta = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _delta$[ebp], eax
$LN9@CL_ParseCo:

; 1571 : 
; 1572 : 		skip = delta - lastcheck;

	mov	ecx, DWORD PTR _delta$[ebp]
	sub	ecx, DWORD PTR _lastcheck$[ebp]
	mov	DWORD PTR _skip$[ebp], ecx

; 1573 : 
; 1574 : 		for( i = 0; i < skip; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_ParseCo
$LN4@CL_ParseCo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@CL_ParseCo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _skip$[ebp]
	jge	SHORT $LN5@CL_ParseCo

; 1575 : 		{
; 1576 : 			if( pResource != skip_crc_change && Q_strstr( pResource->szFileName, "models/" ))

	mov	ecx, DWORD PTR _pResource$[ebp]
	cmp	ecx, DWORD PTR _skip_crc_change$[ebp]
	je	SHORT $LN10@CL_ParseCo
	push	OFFSET $SG145196
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@CL_ParseCo

; 1577 : 				Mod_NeedCRC( pResource->szFileName, false );

	push	0
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_Mod_NeedCRC
	add	esp, 8
$LN10@CL_ParseCo:

; 1578 : 			pResource = pResource->pNext;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _pResource$[ebp], edx

; 1579 : 		}

	jmp	SHORT $LN4@CL_ParseCo
$LN5@CL_ParseCo:

; 1580 : 
; 1581 : 		if( cl.num_consistency >= MAX_MODELS )

	cmp	DWORD PTR _cl+1984852, 1024		; 00000400H
	jl	SHORT $LN11@CL_ParseCo

; 1582 : 			Host_Error( "CL_CheckConsistency: MAX_MODELS limit exceeded (%d)\n", MAX_MODELS );

	push	1024					; 00000400H
	push	OFFSET $SG145198
	call	_Host_Error
	add	esp, 8
$LN11@CL_ParseCo:

; 1583 : 
; 1584 : 		pc = &cl.consistency_list[cl.num_consistency];

	imul	eax, DWORD PTR _cl+1984852, 44
	add	eax, OFFSET _cl+1939796
	mov	DWORD PTR _pc$[ebp], eax

; 1585 : 		cl.num_consistency++;

	mov	ecx, DWORD PTR _cl+1984852
	add	ecx, 1
	mov	DWORD PTR _cl+1984852, ecx

; 1586 : 
; 1587 : 		memset( pc, 0, sizeof( consistency_t ));

	push	44					; 0000002cH
	push	0
	mov	edx, DWORD PTR _pc$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1588 : 		pc->filename = pResource->szFileName;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [ecx], eax

; 1589 : 		pc->issound = (pResource->type == t_sound);

	mov	edx, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	SHORT $LN14@CL_ParseCo
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN15@CL_ParseCo
$LN14@CL_ParseCo:
	mov	DWORD PTR tv142[ebp], 0
$LN15@CL_ParseCo:
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1590 : 		pc->orig_index = delta;

	mov	edx, DWORD PTR _pc$[ebp]
	mov	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1591 : 		pc->value = 0;

	mov	ecx, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1592 : 
; 1593 : 		if( pResource->type == t_model && memcmp( nullbuffer, pResource->rguc_reserved, 32 ))

	mov	edx, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [edx+64], 2
	jne	SHORT $LN12@CL_ParseCo
	push	32					; 00000020H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 94					; 0000005eH
	push	eax
	lea	ecx, DWORD PTR _nullbuffer$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@CL_ParseCo

; 1594 : 			pc->check_type = pResource->rguc_reserved[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pResource$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+94]
	mov	eax, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN12@CL_ParseCo:

; 1595 : 
; 1596 : 		skip_crc_change = pResource;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR _skip_crc_change$[ebp], ecx

; 1597 : 		lastcheck = delta;

	mov	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _lastcheck$[ebp], edx

; 1598 : 	}

	jmp	$LN2@CL_ParseCo
$LN1@CL_ParseCo:

; 1599 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseConsistencyInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv136 = -324						; size = 4
_user_changed_diskfile$ = -320				; size = 4
tv138 = -316						; size = 4
_crcFile$ = -312					; size = 4
_i$ = -308						; size = 4
_pc$ = -304						; size = 4
_maxs$ = -300						; size = 12
_mins$ = -288						; size = 12
_filename$ = -276					; size = 256
_md5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_SendConsistencyInfo PROC

; 1403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1404 : 	qboolean		user_changed_diskfile;
; 1405 : 	vec3_t		mins, maxs;
; 1406 : 	string		filename;
; 1407 : 	CRC32_t		crcFile;
; 1408 : 	byte		md5[16];
; 1409 : 	consistency_t	*pc;
; 1410 : 	int		i;
; 1411 : 
; 1412 : 	if( !cl.need_force_consistency_response )

	cmp	DWORD PTR _cl+1984856, 0
	jne	SHORT $LN7@CL_SendCon

; 1413 : 		return;

	jmp	$LN1@CL_SendCon
$LN7@CL_SendCon:

; 1414 : 	cl.need_force_consistency_response = false;

	mov	DWORD PTR _cl+1984856, 0

; 1415 : 
; 1416 : 	MSG_BeginClientCmd( msg, clc_fileconsistency );

	push	0
	push	0
	push	7
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1417 : 
; 1418 : 	for( i = 0; i < cl.num_consistency; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SendCon
$LN2@CL_SendCon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_SendCon:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cl+1984852
	jge	$LN3@CL_SendCon

; 1419 : 	{
; 1420 : 		pc = &cl.consistency_list[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _cl+1939796
	mov	DWORD PTR _pc$[ebp], eax

; 1421 : 
; 1422 : 		user_changed_diskfile = false;

	mov	DWORD PTR _user_changed_diskfile$[ebp], 0

; 1423 : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 1424 : 		MSG_WriteUBitLong( msg, pc->orig_index, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	edx, DWORD PTR _pc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 1425 : 
; 1426 : 		if( pc->issound )

	mov	edx, DWORD PTR _pc$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN8@CL_SendCon

; 1427 : 			Q_snprintf( filename, sizeof( filename ), "%s%s", DEFAULT_SOUNDPATH, pc->filename );

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET $SG145133
	push	OFFSET $SG145134
	push	256					; 00000100H
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN9@CL_SendCon
$LN8@CL_SendCon:

; 1428 : 		else Q_strncpy( filename, pc->filename, sizeof( filename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@CL_SendCon:

; 1429 : 
; 1430 : 		if( Q_strstr( filename, "models/" ))

	push	OFFSET $SG145136
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@CL_SendCon

; 1431 : 		{
; 1432 : 			CRC32_Init( &crcFile );

	lea	ecx, DWORD PTR _crcFile$[ebp]
	push	ecx
	call	_CRC32_Init
	add	esp, 4

; 1433 : 			CRC32_File( &crcFile, filename );

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _crcFile$[ebp]
	push	eax
	call	_CRC32_File
	add	esp, 8

; 1434 : 			crcFile = CRC32_Final( crcFile );

	mov	ecx, DWORD PTR _crcFile$[ebp]
	push	ecx
	call	_CRC32_Final
	add	esp, 4
	mov	DWORD PTR _crcFile$[ebp], eax

; 1435 : 			user_changed_diskfile = !Mod_ValidateCRC( filename, crcFile );

	mov	edx, DWORD PTR _crcFile$[ebp]
	push	edx
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Mod_ValidateCRC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@CL_SendCon
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN20@CL_SendCon
$LN19@CL_SendCon:
	mov	DWORD PTR tv136[ebp], 0
$LN20@CL_SendCon:
	mov	ecx, DWORD PTR tv136[ebp]
	mov	DWORD PTR _user_changed_diskfile$[ebp], ecx
$LN10@CL_SendCon:

; 1436 : 		}
; 1437 : 
; 1438 : 		switch( pc->check_type )

	mov	edx, DWORD PTR _pc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv138[ebp], eax
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN11@CL_SendCon
	cmp	DWORD PTR tv138[ebp], 0
	jle	$LN17@CL_SendCon
	cmp	DWORD PTR tv138[ebp], 2
	jle	SHORT $LN14@CL_SendCon
	jmp	$LN17@CL_SendCon
$LN11@CL_SendCon:

; 1439 : 		{
; 1440 : 		case force_exactfile:
; 1441 : 			MD5_HashFile( md5, filename, NULL );

	push	0
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _md5$[ebp]
	push	edx
	call	_MD5_HashFile
	add	esp, 12					; 0000000cH

; 1442 : 			pc->value = *(int *)md5;

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR _md5$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1443 : 
; 1444 : 			if( user_changed_diskfile )

	cmp	DWORD PTR _user_changed_diskfile$[ebp], 0
	je	SHORT $LN12@CL_SendCon

; 1445 : 				MSG_WriteUBitLong( msg, 0, 32 );

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@CL_SendCon
$LN12@CL_SendCon:

; 1446 : 			else MSG_WriteUBitLong( msg, pc->value, 32 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN13@CL_SendCon:

; 1447 : 			break;

	jmp	$LN5@CL_SendCon
$LN14@CL_SendCon:

; 1448 : 		case force_model_samebounds:
; 1449 : 		case force_model_specifybounds:
; 1450 : 			if( !Mod_GetStudioBounds( filename, mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Mod_GetStudioBounds
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_SendCon

; 1451 : 				Host_Error( "unable to find %s\n", filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG145142
	call	_Host_Error
	add	esp, 8
$LN15@CL_SendCon:

; 1452 : 			if( user_changed_diskfile )

	cmp	DWORD PTR _user_changed_diskfile$[ebp], 0
	je	SHORT $LN16@CL_SendCon

; 1453 : 				ClearBounds( maxs, mins ); // g-cont. especially swapped

	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	call	_ClearBounds
	add	esp, 8
$LN16@CL_SendCon:

; 1454 : 			MSG_WriteBytes( msg, mins, 12 );

	push	12					; 0000000cH
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1455 : 			MSG_WriteBytes( msg, maxs, 12 );

	push	12					; 0000000cH
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1456 : 			break;

	jmp	SHORT $LN5@CL_SendCon
$LN17@CL_SendCon:

; 1457 : 		default:
; 1458 : 			Host_Error( "Unknown consistency type %i\n", pc->check_type );

	mov	ecx, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET $SG145145
	call	_Host_Error
	add	esp, 8
$LN5@CL_SendCon:

; 1459 : 			break;
; 1460 : 		}
; 1461 : 	}

	jmp	$LN2@CL_SendCon
$LN3@CL_SendCon:

; 1462 : 
; 1463 : 	MSG_WriteOneBit( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@CL_SendCon:

; 1464 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendConsistencyInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_player$ = -12						; size = 4
_slot$ = -8						; size = 4
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_UpdateUserPings PROC

; 1383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1384 : 	int		i, slot;
; 1385 : 	player_info_t	*player;
; 1386 : 	
; 1387 : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_UpdateU
$LN2@CL_UpdateU:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_UpdateU:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN1@CL_UpdateU

; 1388 : 	{
; 1389 : 		if( !MSG_ReadOneBit( msg )) break; // end of message

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_UpdateU
	jmp	SHORT $LN1@CL_UpdateU
$LN5@CL_UpdateU:

; 1390 : 
; 1391 : 		slot = MSG_ReadUBitLong( msg, MAX_CLIENT_BITS );

	push	5
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _slot$[ebp], eax

; 1392 : 
; 1393 : 		if( slot >= MAX_CLIENTS )

	cmp	DWORD PTR _slot$[ebp], 32		; 00000020H
	jl	SHORT $LN6@CL_UpdateU

; 1394 : 			Host_Error( "CL_ParseServerMessage: svc_pings > MAX_CLIENTS\n" );

	push	OFFSET $SG145109
	call	_Host_Error
	add	esp, 4
$LN6@CL_UpdateU:

; 1395 : 
; 1396 : 		player = &cl.players[slot];

	imul	eax, DWORD PTR _slot$[ebp], 584
	add	eax, OFFSET _cl+1543148
	mov	DWORD PTR _player$[ebp], eax

; 1397 : 		player->ping = MSG_ReadUBitLong( msg, 12 );

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [edx+296], eax

; 1398 : 		player->packet_loss = MSG_ReadUBitLong( msg, 7 );

	push	7
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 1399 : 	}

	jmp	$LN2@CL_UpdateU
$LN1@CL_UpdateU:

; 1400 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateUserPings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pResource$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseResource PROC

; 1355 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1356 : 	resource_t	*pResource;
; 1357 : 
; 1358 : 	pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	push	1358					; 0000054eH
	push	OFFSET $SG145094
	push	1
	push	136					; 00000088H
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 1359 : 	pResource->type = MSG_ReadUBitLong( msg, 4 );

	push	4
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1360 : 
; 1361 : 	Q_strncpy( pResource->szFileName, MSG_ReadString( msg ), sizeof( pResource->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1362 : 	pResource->nIndex = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 1363 : 	pResource->nDownloadSize = MSG_ReadSBitLong( msg, 24 );

	push	24					; 00000018H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadSBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 1364 : 	pResource->ucFlags = MSG_ReadUBitLong( msg, 3 ) & ~RES_WASMISSING;

	push	3
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 1365 : 
; 1366 : 	if( FBitSet( pResource->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	je	SHORT $LN2@CL_ParseRe

; 1367 : 		MSG_ReadBytes( msg, pResource->rgucMD5_hash, sizeof( pResource->rgucMD5_hash ));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN2@CL_ParseRe:

; 1368 : 
; 1369 : 	if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@CL_ParseRe

; 1370 : 		MSG_ReadBytes( msg, pResource->rguc_reserved, sizeof( pResource->rguc_reserved ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 94					; 0000005eH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN3@CL_ParseRe:

; 1371 : 
; 1372 : 	CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+1984996
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 1373 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_id$ = -20						; size = 4
_active$ = -16						; size = 4
tv76 = -12						; size = 4
_slot$ = -8						; size = 4
_player$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_UpdateUserinfo PROC

; 1318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1319 : 	int		slot, id;
; 1320 : 	qboolean		active;
; 1321 : 	player_info_t	*player;
; 1322 : 
; 1323 : 	slot = MSG_ReadUBitLong( msg, MAX_CLIENT_BITS );

	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _slot$[ebp], eax

; 1324 : 
; 1325 : 	if( slot >= MAX_CLIENTS )

	cmp	DWORD PTR _slot$[ebp], 32		; 00000020H
	jl	SHORT $LN2@CL_UpdateU

; 1326 : 		Host_Error( "CL_ParseServerMessage: svc_updateuserinfo >= MAX_CLIENTS\n" );

	push	OFFSET $SG145079
	call	_Host_Error
	add	esp, 4
$LN2@CL_UpdateU:

; 1327 : 
; 1328 : 	id = MSG_ReadLong( msg );	// unique user ID

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _id$[ebp], eax

; 1329 : 	player = &cl.players[slot];

	imul	edx, DWORD PTR _slot$[ebp], 584
	add	edx, OFFSET _cl+1543148
	mov	DWORD PTR _player$[ebp], edx

; 1330 : 	active = MSG_ReadOneBit( msg ) ? true : false;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@CL_UpdateU
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN8@CL_UpdateU
$LN7@CL_UpdateU:
	mov	DWORD PTR tv76[ebp], 0
$LN8@CL_UpdateU:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _active$[ebp], ecx

; 1331 : 
; 1332 : 	if( active )

	cmp	DWORD PTR _active$[ebp], 0
	je	$LN3@CL_UpdateU

; 1333 : 	{
; 1334 : 		Q_strncpy( player->userinfo, MSG_ReadString( msg ), sizeof( player->userinfo ));

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1335 : 		Q_strncpy( player->name, Info_ValueForKey( player->userinfo, "name" ), sizeof( player->name ));

	push	32					; 00000020H
	push	OFFSET $SG145082
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 4
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1336 : 		Q_strncpy( player->model, Info_ValueForKey( player->userinfo, "model" ), sizeof( player->model ));

	push	64					; 00000040H
	push	OFFSET $SG145083
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1337 : 		player->topcolor = Q_atoi( Info_ValueForKey( player->userinfo, "topcolor" ));

	push	OFFSET $SG145084
	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 4
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+368], eax

; 1338 : 		player->bottomcolor = Q_atoi( Info_ValueForKey( player->userinfo, "bottomcolor" ));

	push	OFFSET $SG145085
	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 4
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 1339 : 		player->spectator = Q_atoi( Info_ValueForKey( player->userinfo, "*hltv" ));

	push	OFFSET $SG145086
	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 4
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 1340 : 		MSG_ReadBytes( msg, player->hashedcdkey, sizeof( player->hashedcdkey ));

	push	16					; 00000010H
	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 568				; 00000238H
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1341 : 
; 1342 : 		if( slot == cl.playernum ) memcpy( &gameui.playerinfo, player, sizeof( player_info_t ));

	mov	ecx, DWORD PTR _slot$[ebp]
	cmp	ecx, DWORD PTR _cl+1568828
	jne	SHORT $LN5@CL_UpdateU
	push	584					; 00000248H
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	push	OFFSET _gameui+3072
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@CL_UpdateU:

; 1343 : 	}

	jmp	SHORT $LN1@CL_UpdateU
$LN3@CL_UpdateU:

; 1344 : 	else memset( player, 0, sizeof( *player ));

	push	584					; 00000248H
	push	0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@CL_UpdateU:

; 1345 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateUserinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pszName$ = -20						; size = 4
tv75 = -16						; size = 4
tv74 = -12						; size = 4
_size$ = -8						; size = 4
_svc_num$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_RegisterUserMessage PROC

; 1295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1296 : 	char	*pszName;
; 1297 : 	int	svc_num, size;
; 1298 : 	
; 1299 : 	svc_num = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _svc_num$[ebp], eax

; 1300 : 	size = MSG_ReadWord( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1301 : 	pszName = MSG_ReadString( msg );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pszName$[ebp], eax

; 1302 : 
; 1303 : 	// important stuff
; 1304 : 	if( size == 0xFFFF ) size = -1;

	cmp	DWORD PTR _size$[ebp], 65535		; 0000ffffH
	jne	SHORT $LN2@CL_Registe
	mov	DWORD PTR _size$[ebp], -1
$LN2@CL_Registe:

; 1305 : 	svc_num = bound( 0, svc_num, 255 );

	cmp	DWORD PTR _svc_num$[ebp], 0
	jl	SHORT $LN6@CL_Registe
	cmp	DWORD PTR _svc_num$[ebp], 255		; 000000ffH
	jge	SHORT $LN4@CL_Registe
	mov	eax, DWORD PTR _svc_num$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN5@CL_Registe
$LN4@CL_Registe:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN5@CL_Registe:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN7@CL_Registe
$LN6@CL_Registe:
	mov	DWORD PTR tv75[ebp], 0
$LN7@CL_Registe:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _svc_num$[ebp], edx

; 1306 : 
; 1307 : 	CL_LinkUserMessage( pszName, svc_num, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svc_num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszName$[ebp]
	push	edx
	call	_CL_LinkUserMessage
	add	esp, 12					; 0000000cH

; 1308 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pMapName$ = -272					; size = 4
_mapCount$ = -268					; size = 4
_i$ = -264						; size = 4
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseRestore PROC

; 1268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1269 : 	string		filename;
; 1270 : 	int		i, mapCount;
; 1271 : 	char		*pMapName;
; 1272 : 
; 1273 : 	// mapname.HL2
; 1274 : 	Q_strncpy( filename, MSG_ReadString( msg ), sizeof( filename ));

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1275 : 	mapCount = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _mapCount$[ebp], eax

; 1276 : 
; 1277 : 	// g-cont. acutally in Xash3D this does nothing.
; 1278 : 	// decals already restored on a server, and correctly transferred through levels
; 1279 : 	// but i'm leave this message for backward compatibility
; 1280 : 	for( i = 0; i < mapCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseRe
$LN2@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseRe:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _mapCount$[ebp]
	jge	SHORT $LN1@CL_ParseRe

; 1281 : 	{
; 1282 : 		pMapName = MSG_ReadString( msg );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pMapName$[ebp], eax

; 1283 : 		Con_Printf( "Loading decals from %s\n", pMapName );

	mov	eax, DWORD PTR _pMapName$[ebp]
	push	eax
	push	OFFSET $SG145060
	call	_Con_Printf
	add	esp, 8

; 1284 : 	}

	jmp	SHORT $LN2@CL_ParseRe
$LN1@CL_ParseRe:

; 1285 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseRestore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseCrosshairAngle PROC

; 1254 : {

	push	ebp
	mov	ebp, esp

; 1255 : 	cl.crosshairangle[0] = MSG_ReadChar( msg ) * 0.2f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _cl[edx+1568652], xmm0

; 1256 : 	cl.crosshairangle[1] = MSG_ReadChar( msg ) * 0.2f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _cl[ecx+1568652], xmm0

; 1257 : 	cl.crosshairangle[2] = 0.0f; // not used for screen space

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[edx+1568652], xmm0

; 1258 : }

	pop	ebp
	ret	0
_CL_ParseCrosshairAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_delta_yaw$ = -8					; size = 4
_a$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseAddAngle PROC

; 1225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1226 : 	pred_viewangle_t	*a;
; 1227 : 	float		delta_yaw;
; 1228 : 	
; 1229 : 	delta_yaw = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	fstp	DWORD PTR _delta_yaw$[ebp]

; 1230 : #if 0
; 1231 : 	cl.viewangles[YAW] += delta_yaw;
; 1232 : 	return;
; 1233 : #endif
; 1234 : 	// update running counter	
; 1235 : 	cl.addangletotal += delta_yaw;

	movss	xmm0, DWORD PTR _cl+1568796
	addss	xmm0, DWORD PTR _delta_yaw$[ebp]
	movss	DWORD PTR _cl+1568796, xmm0

; 1236 : 
; 1237 : 	// select entry into circular buffer
; 1238 : 	cl.angle_position = (cl.angle_position + 1) & ANGLE_MASK;

	mov	ecx, DWORD PTR _cl+1568792
	add	ecx, 1
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _cl+1568792, ecx

; 1239 : 	a = &cl.predicted_angle[cl.angle_position];

	mov	edx, DWORD PTR _cl+1568792
	lea	eax, DWORD PTR _cl[edx*8+1568664]
	mov	DWORD PTR _a$[ebp], eax

; 1240 : 
; 1241 : 	// record update
; 1242 : 	a->starttime = cl.mtime[0];

	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[edx+32]
	mov	eax, DWORD PTR _a$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1243 : 	a->total = cl.addangletotal;

	mov	ecx, DWORD PTR _a$[ebp]
	movss	xmm0, DWORD PTR _cl+1568796
	movss	DWORD PTR [ecx+4], xmm0

; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseAddAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseSetAngle PROC

; 1211 : {

	push	ebp
	mov	ebp, esp

; 1212 : 	cl.viewangles[0] = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _cl[edx+1568612]

; 1213 : 	cl.viewangles[1] = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _cl[ecx+1568612]

; 1214 : 	cl.viewangles[2] = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	fstp	DWORD PTR _cl[eax+1568612]

; 1215 : }

	pop	ebp
	ret	0
_CL_ParseSetAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_style$ = -12						; size = 4
_s$ = -8						; size = 4
_f$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseLightStyle PROC

; 1191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1192 : 	int		style;
; 1193 : 	const char	*s;
; 1194 : 	float		f;
; 1195 : 
; 1196 : 	style = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _style$[ebp], eax

; 1197 : 	s = MSG_ReadString( msg );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 1198 : 	f = MSG_ReadFloat( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR _f$[ebp]

; 1199 : 
; 1200 : 	CL_SetLightstyle( style, s, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _style$[ebp]
	push	ecx
	call	_CL_SetLightstyle
	add	esp, 12					; 0000000cH

; 1201 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_player$ = -360						; size = 4
_i$ = -356						; size = 4
_ent$ = -352						; size = 4
_newnum$ = -348						; size = 4
_nullstate$ = -344					; size = 340
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseBaseline PROC

; 1150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1151 : 	int		i, newnum;
; 1152 : 	entity_state_t	nullstate;
; 1153 : 	qboolean		player;
; 1154 : 	cl_entity_t	*ent;
; 1155 : 
; 1156 : 	Delta_InitClient ();	// finalize client delta's

	call	_Delta_InitClient

; 1157 : 
; 1158 : 	memset( &nullstate, 0, sizeof( nullstate ));

	push	340					; 00000154H
	push	0
	lea	eax, DWORD PTR _nullstate$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@CL_ParseBa:

; 1159 : 
; 1160 : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@CL_ParseBa

; 1161 : 	{
; 1162 : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 1163 : 		if( newnum == LAST_EDICT ) break; // end of baselines

	cmp	DWORD PTR _newnum$[ebp], 8191		; 00001fffH
	jne	SHORT $LN7@CL_ParseBa
	jmp	$LN3@CL_ParseBa
$LN7@CL_ParseBa:

; 1164 : 		player = CL_IsPlayerIndex( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax

; 1165 : 
; 1166 : 		if( newnum >= clgame.maxEntities )

	mov	ecx, DWORD PTR _newnum$[ebp]
	cmp	ecx, DWORD PTR _clgame+1012
	jl	SHORT $LN8@CL_ParseBa

; 1167 : 			Host_Error( "CL_AllocEdict: no free edicts\n" );

	push	OFFSET $SG145027
	call	_Host_Error
	add	esp, 4
$LN8@CL_ParseBa:

; 1168 : 
; 1169 : 		ent = CL_EDICT_NUM( newnum );

	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1170 : 		memset( &ent->prevstate, 0, sizeof( ent->prevstate ));

	push	340					; 00000154H
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1171 : 		ent->index = newnum;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [ecx], edx

; 1172 : 
; 1173 : 		MSG_ReadDeltaEntity( msg, &ent->prevstate, &ent->baseline, newnum, player, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 1174 : 	}

	jmp	$LN2@CL_ParseBa
$LN3@CL_ParseBa:

; 1175 : 
; 1176 : 	cl.instanced_baseline_count = MSG_ReadUBitLong( msg, 6 );

	push	6
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _cl+1590596, eax

; 1177 : 
; 1178 : 	for( i = 0; i < cl.instanced_baseline_count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_ParseBa
$LN4@CL_ParseBa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CL_ParseBa:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cl+1590596
	jge	SHORT $LN5@CL_ParseBa

; 1179 : 	{
; 1180 : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 1181 : 		MSG_ReadDeltaEntity( msg, &nullstate, &cl.instanced_baseline[i], newnum, false, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 340
	add	ecx, OFFSET _cl+1568836
	push	ecx
	lea	edx, DWORD PTR _nullstate$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 1182 : 	}

	jmp	SHORT $LN4@CL_ParseBa
$LN5@CL_ParseBa:

; 1183 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_to_wd$ = -6188						; size = 4
_to_cd$ = -6184						; size = 4
_parsecounttime$ = -6180				; size = 4
_from_wd$ = -6176					; size = 4
_idx$ = -6172						; size = 4
_from_cd$ = -6168					; size = 4
_delta_sequence$1 = -6164				; size = 4
_ps$2 = -6160						; size = 4
_pps$3 = -6156						; size = 4
_pcd$4 = -6152						; size = 4
_ppcd$5 = -6148						; size = 4
_wd$6 = -6144						; size = 4
_pwd$7 = -6140						; size = 4
_last_predicted$8 = -6136				; size = 4
_command_ack$ = -6132					; size = 4
_latency$9 = -6128					; size = 4
_j$ = -6124						; size = 4
_i$ = -6120						; size = 4
_frame$ = -6116						; size = 4
_nullcd$ = -6112					; size = 476
_nullwd$ = -5636					; size = 5632
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseClientData PROC

; 989  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 6188				; 0000182cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 990  : 	float		parsecounttime;
; 991  : 	int		i, j, command_ack;
; 992  : 	clientdata_t	*from_cd, *to_cd;
; 993  : 	weapon_data_t	*from_wd, *to_wd;
; 994  : 	weapon_data_t	nullwd[64];
; 995  : 	clientdata_t	nullcd;
; 996  : 	frame_t		*frame;
; 997  : 	int		idx;
; 998  : 
; 999  : 	// This is the last movement that the server ack'd
; 1000 : 	command_ack = cls.netchan.incoming_acknowledged;

	mov	eax, DWORD PTR _cls+23588
	mov	DWORD PTR _command_ack$[ebp], eax

; 1001 : 
; 1002 : 	// this is the frame update that this message corresponds to
; 1003 : 	i = cls.netchan.incoming_sequence;

	mov	ecx, DWORD PTR _cls+23584
	mov	DWORD PTR _i$[ebp], ecx

; 1004 : 
; 1005 : 	// did we drop some frames?
; 1006 : 	if( i > cl.last_incoming_sequence + 1 )

	mov	edx, DWORD PTR _cl+56
	add	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jle	$LN3@CL_ParseCl

; 1007 : 	{
; 1008 : 		// mark as dropped
; 1009 : 		for( j = cl.last_incoming_sequence + 1; j < i; j++ )

	mov	eax, DWORD PTR _cl+56
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN4@CL_ParseCl
$LN2@CL_ParseCl:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN4@CL_ParseCl:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _i$[ebp]
	jge	SHORT $LN3@CL_ParseCl

; 1010 : 		{
; 1011 : 			if( cl.frames[j & CL_UPDATE_MASK].receivedtime >= 0.0 )

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _j$[ebp]
	imul	ecx, eax, 17304
	movsd	xmm0, QWORD PTR _cl[ecx+88]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN9@CL_ParseCl

; 1012 : 			{
; 1013 : 				cl.frames[j & CL_UPDATE_MASK].receivedtime = -1.0f;

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _j$[ebp]
	imul	eax, edx, 17304
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR _cl[eax+88], xmm0

; 1014 : 				cl.frames[j & CL_UPDATE_MASK].latency = 0;

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _j$[ebp]
	imul	edx, ecx, 17304
	xorps	xmm0, xmm0
	movsd	QWORD PTR _cl[edx+96], xmm0
$LN9@CL_ParseCl:

; 1015 : 			}
; 1016 : 		}

	jmp	$LN2@CL_ParseCl
$LN3@CL_ParseCl:

; 1017 : 	}
; 1018 : 
; 1019 : 	cl.parsecount = i;					// ack'd incoming messages.  

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cl+8, eax

; 1020 : 	cl.parsecountmod = cl.parsecount & CL_UPDATE_MASK;	// index into window.     

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _cl+8
	mov	DWORD PTR _cl+12, ecx

; 1021 : 	frame = &cl.frames[cl.parsecountmod];			// frame at index.

	imul	edx, DWORD PTR _cl+12, 17304
	add	edx, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], edx

; 1022 : 
; 1023 : 	frame->time = cl.mtime[0];				// mark network received time

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR [edx+16], xmm0

; 1024 : 	frame->receivedtime = host.realtime;			// time now that we are parsing.  

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax], xmm0

; 1025 : 
; 1026 : 	memset( &frame->graphdata, 0, sizeof( netbandwidthgraph_t ));

	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR _frame$[ebp]
	add	ecx, 17020				; 0000427cH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1027 : 
; 1028 : 	// send time for that frame.
; 1029 : 	parsecounttime = cl.commands[command_ack & CL_UPDATE_MASK].senttime;

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _command_ack$[ebp]
	imul	eax, edx, 88
	cvtsd2ss xmm0, QWORD PTR _cl[eax+1107544]
	movss	DWORD PTR _parsecounttime$[ebp], xmm0

; 1030 : 
; 1031 : 	// current time that we got a response to the command packet.
; 1032 : 	cl.commands[command_ack & CL_UPDATE_MASK].receivedtime = host.realtime;    

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _command_ack$[ebp]
	imul	edx, ecx, 88
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cl[edx+1107552], xmm0

; 1033 : 
; 1034 : 	if( cl.last_command_ack != -1 )

	cmp	DWORD PTR _cl+52, -1
	je	$LN10@CL_ParseCl

; 1035 : 	{
; 1036 : 		int		last_predicted;
; 1037 : 		clientdata_t	*pcd, *ppcd;
; 1038 : 		entity_state_t	*ps, *pps;
; 1039 : 		weapon_data_t	*wd, *pwd;
; 1040 : 
; 1041 : 		if( !cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	jne	$LN11@CL_ParseCl

; 1042 : 		{
; 1043 : 			last_predicted = ( cl.last_incoming_sequence + ( command_ack - cl.last_command_ack )) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _command_ack$[ebp]
	sub	eax, DWORD PTR _cl+52
	add	eax, DWORD PTR _cl+56
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	mov	DWORD PTR _last_predicted$8[ebp], eax

; 1044 : 
; 1045 : 			pps = &cl.predicted_frames[last_predicted].playerstate;

	imul	edx, DWORD PTR _last_predicted$8[ebp], 6448
	add	edx, OFFSET _cl+1113176
	mov	DWORD PTR _pps$3[ebp], edx

; 1046 : 			pwd = cl.predicted_frames[last_predicted].weapondata;

	imul	eax, DWORD PTR _last_predicted$8[ebp], 6448
	add	eax, OFFSET _cl+1113992
	mov	DWORD PTR _pwd$7[ebp], eax

; 1047 : 			ppcd = &cl.predicted_frames[last_predicted].client;

	imul	ecx, DWORD PTR _last_predicted$8[ebp], 6448
	add	ecx, OFFSET _cl+1113516
	mov	DWORD PTR _ppcd$5[ebp], ecx

; 1048 : 
; 1049 : 			ps = &frame->playerstate[cl.playernum];

	imul	edx, DWORD PTR _cl+1568828, 340
	mov	eax, DWORD PTR _frame$[ebp]
	lea	ecx, DWORD PTR [eax+edx+508]
	mov	DWORD PTR _ps$2[ebp], ecx

; 1050 : 			wd = frame->weapondata;

	mov	edx, DWORD PTR _frame$[ebp]
	add	edx, 11388				; 00002c7cH
	mov	DWORD PTR _wd$6[ebp], edx

; 1051 : 			pcd = &frame->clientdata;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pcd$4[ebp], eax

; 1052 : 		}

	jmp	SHORT $LN12@CL_ParseCl
$LN11@CL_ParseCl:

; 1053 : 		else
; 1054 : 		{
; 1055 : 			ps = &cls.spectator_state.playerstate;

	mov	DWORD PTR _ps$2[ebp], OFFSET _cls+156

; 1056 : 			pps = &cls.spectator_state.playerstate;

	mov	DWORD PTR _pps$3[ebp], OFFSET _cls+156

; 1057 : 			pcd = &cls.spectator_state.client;

	mov	DWORD PTR _pcd$4[ebp], OFFSET _cls+496

; 1058 : 			ppcd = &cls.spectator_state.client;

	mov	DWORD PTR _ppcd$5[ebp], OFFSET _cls+496

; 1059 : 			wd = cls.spectator_state.weapondata;

	mov	DWORD PTR _wd$6[ebp], OFFSET _cls+972

; 1060 : 			pwd = cls.spectator_state.weapondata;

	mov	DWORD PTR _pwd$7[ebp], OFFSET _cls+972
$LN12@CL_ParseCl:

; 1061 : 		}
; 1062 : 
; 1063 : 		clgame.dllFuncs.pfnTxferPredictionData( ps, pps, pcd, ppcd, wd, pwd );

	mov	ecx, DWORD PTR _pwd$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _wd$6[ebp]
	push	edx
	mov	eax, DWORD PTR _ppcd$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcd$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pps$3[ebp]
	push	edx
	mov	eax, DWORD PTR _ps$2[ebp]
	push	eax
	call	DWORD PTR _clgame+120
	add	esp, 24					; 00000018H
$LN10@CL_ParseCl:

; 1064 : 	}
; 1065 : 
; 1066 : 	// do this after all packets read for this frame?
; 1067 : 	cl.last_command_ack = cls.netchan.incoming_acknowledged;

	mov	ecx, DWORD PTR _cls+23588
	mov	DWORD PTR _cl+52, ecx

; 1068 : 	cl.last_incoming_sequence = cls.netchan.incoming_sequence;

	mov	edx, DWORD PTR _cls+23584
	mov	DWORD PTR _cl+56, edx

; 1069 : 
; 1070 : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	$LN13@CL_ParseCl

; 1071 : 	{
; 1072 : 		// calculate latency of this frame.
; 1073 : 		// sent time is set when usercmd is sent to server in CL_Move
; 1074 : 		// this is the # of seconds the round trip took.
; 1075 : 		float	latency = host.realtime - parsecounttime;

	cvtss2sd xmm0, DWORD PTR _parsecounttime$[ebp]
	movsd	xmm1, QWORD PTR _host+1440
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _latency$9[ebp], xmm0

; 1076 : 
; 1077 : 		// fill into frame latency
; 1078 : 		frame->latency = latency;

	cvtss2sd xmm0, DWORD PTR _latency$9[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	movsd	QWORD PTR [eax+8], xmm0

; 1079 : 
; 1080 : 		// negative latency makes no sense.  Huge latency is a problem.
; 1081 : 		if( latency >= 0.0f && latency <= 2.0f )

	movss	xmm0, DWORD PTR _latency$9[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN17@CL_ParseCl
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _latency$9[ebp]
	jb	SHORT $LN17@CL_ParseCl

; 1082 : 		{
; 1083 : 			// drift the average latency towards the observed latency
; 1084 : 			// if round trip was fastest so far, just use that for latency value
; 1085 : 			// otherwise, move in 1 ms steps toward observed channel latency.
; 1086 : 			if( latency < cls.latency )

	movss	xmm0, DWORD PTR _cls+291752
	comiss	xmm0, DWORD PTR _latency$9[ebp]
	jbe	SHORT $LN16@CL_ParseCl

; 1087 : 				cls.latency = latency;

	movss	xmm0, DWORD PTR _latency$9[ebp]
	movss	DWORD PTR _cls+291752, xmm0
	jmp	SHORT $LN17@CL_ParseCl
$LN16@CL_ParseCl:

; 1088 : 			else cls.latency += 0.001f; // drift up, so corrections are needed	

	movss	xmm0, DWORD PTR _cls+291752
	addss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _cls+291752, xmm0
$LN17@CL_ParseCl:

; 1089 : 		}	
; 1090 : 	}

	jmp	SHORT $LN14@CL_ParseCl
$LN13@CL_ParseCl:

; 1091 : 	else
; 1092 : 	{
; 1093 : 		frame->latency = 0.0f;

	mov	ecx, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [ecx+8], xmm0
$LN14@CL_ParseCl:

; 1094 : 	}
; 1095 : 
; 1096 : 	// clientdata for spectators ends here
; 1097 : 	if( cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN18@CL_ParseCl

; 1098 : 	{
; 1099 : 		cl.local.health = 1;

	mov	DWORD PTR _cl+1568556, 1

; 1100 : 		return;

	jmp	$LN1@CL_ParseCl
$LN18@CL_ParseCl:

; 1101 : 	}	
; 1102 : 
; 1103 : 	to_cd = &frame->clientdata;

	mov	edx, DWORD PTR _frame$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR _to_cd$[ebp], edx

; 1104 : 	to_wd = frame->weapondata;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 11388				; 00002c7cH
	mov	DWORD PTR _to_wd$[ebp], eax

; 1105 : 
; 1106 : 	// clear to old value before delta parsing
; 1107 : 	if( MSG_ReadOneBit( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@CL_ParseCl

; 1108 : 	{
; 1109 : 		int	delta_sequence = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _delta_sequence$1[ebp], eax

; 1110 : 
; 1111 : 		from_cd = &cl.frames[delta_sequence & CL_UPDATE_MASK].clientdata;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _delta_sequence$1[ebp]
	imul	ecx, eax, 17304
	add	ecx, OFFSET _cl+120
	mov	DWORD PTR _from_cd$[ebp], ecx

; 1112 : 		from_wd = cl.frames[delta_sequence & CL_UPDATE_MASK].weapondata;

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _delta_sequence$1[ebp]
	imul	eax, edx, 17304
	add	eax, OFFSET _cl+11476
	mov	DWORD PTR _from_wd$[ebp], eax

; 1113 : 	}

	jmp	SHORT $LN20@CL_ParseCl
$LN19@CL_ParseCl:

; 1114 : 	else
; 1115 : 	{
; 1116 : 		memset( &nullcd, 0, sizeof( nullcd ));

	push	476					; 000001dcH
	push	0
	lea	ecx, DWORD PTR _nullcd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1117 : 		memset( nullwd, 0, sizeof( nullwd ));

	push	5632					; 00001600H
	push	0
	lea	edx, DWORD PTR _nullwd$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1118 : 		from_cd = &nullcd;

	lea	eax, DWORD PTR _nullcd$[ebp]
	mov	DWORD PTR _from_cd$[ebp], eax

; 1119 : 		from_wd = nullwd;

	lea	ecx, DWORD PTR _nullwd$[ebp]
	mov	DWORD PTR _from_wd$[ebp], ecx
$LN20@CL_ParseCl:

; 1120 : 	}
; 1121 : 
; 1122 : 	MSG_ReadClientData( msg, from_cd, to_cd, cl.mtime[0] );

	mov	edx, 8
	imul	eax, edx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[eax+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _to_cd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from_cd$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadClientData
	add	esp, 16					; 00000010H

; 1123 : 
; 1124 : 	for( i = 0; i < 64; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_ParseCl
$LN5@CL_ParseCl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@CL_ParseCl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@CL_ParseCl

; 1125 : 	{
; 1126 : 		// check for end of weapondata (and clientdata_t message)
; 1127 : 		if( !MSG_ReadOneBit( msg )) break;

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@CL_ParseCl
	jmp	SHORT $LN6@CL_ParseCl
$LN21@CL_ParseCl:

; 1128 : 
; 1129 : 		// read the weapon idx
; 1130 : 		idx = MSG_ReadUBitLong( msg, MAX_WEAPON_BITS );

	push	6
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _idx$[ebp], eax

; 1131 : 
; 1132 : 		MSG_ReadWeaponData( msg, &from_wd[idx], &to_wd[idx], cl.mtime[0] );

	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[edx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _idx$[ebp], 88
	add	eax, DWORD PTR _to_wd$[ebp]
	push	eax
	imul	ecx, DWORD PTR _idx$[ebp], 88
	add	ecx, DWORD PTR _from_wd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadWeaponData
	add	esp, 16					; 00000010H

; 1133 : 	}

	jmp	SHORT $LN5@CL_ParseCl
$LN6@CL_ParseCl:

; 1134 : 
; 1135 : 	// make a local copy of physinfo
; 1136 : 	Q_strncpy( cls.physinfo, frame->clientdata.physinfo, sizeof( cls.physinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 172				; 000000acH
	push	eax
	push	OFFSET _cls+6860
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1137 : 
; 1138 : 	cl.local.maxspeed = frame->clientdata.maxspeed;

	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	movss	DWORD PTR _cl+1568588, xmm0

; 1139 : 	cl.local.pushmsec = frame->clientdata.pushmsec;

	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	DWORD PTR _cl+1568580, eax

; 1140 : 	cl.local.weapons = frame->clientdata.weapons;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR _cl+1568584, edx

; 1141 : 	cl.local.health = frame->clientdata.health;

	mov	eax, DWORD PTR _frame$[ebp]
	cvttss2si ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _cl+1568556, ecx
$LN1@CL_ParseCl:

; 1142 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseClientData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_background$ = -92					; size = 4
tv250 = -88						; size = 4
tv242 = -84						; size = 4
tv87 = -80						; size = 4
tv86 = -76						; size = 4
_i$ = -72						; size = 4
_gamefolder$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseServerData PROC

; 852  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 853  : 	char	gamefolder[MAX_QPATH];
; 854  : 	qboolean	background;
; 855  : 	int	i;
; 856  : 
; 857  : 	Con_Reportf( "Serverdata packet received.\n" );

	push	OFFSET $SG144917
	call	_Con_Reportf
	add	esp, 4

; 858  : 	cls.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+16

; 859  : 
; 860  : 	cls.demowaiting = false;	// server is changed

	mov	DWORD PTR _cls+297584, 0

; 861  : 
; 862  : 	// wipe the client_t struct
; 863  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN8@CL_ParseSe
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN8@CL_ParseSe

; 864  : 		CL_ClearState ();

	call	_CL_ClearState
$LN8@CL_ParseSe:

; 865  : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 866  : 
; 867  : 	// parse protocol version number
; 868  : 	i = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 869  : 
; 870  : 	if( i != PROTOCOL_VERSION )

	cmp	DWORD PTR _i$[ebp], 49			; 00000031H
	je	SHORT $LN9@CL_ParseSe

; 871  : 		Host_Error( "Server use invalid protocol (%i should be %i)\n", i, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET $SG144920
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN9@CL_ParseSe:

; 872  : 
; 873  : 	cl.servercount = MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _cl, eax

; 874  : 	cl.checksum = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _cl+80, eax

; 875  : 	cl.playernum = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+1568828, eax

; 876  : 	cl.maxclients = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+1568832, eax

; 877  : 	clgame.maxEntities = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _clgame+1012, eax

; 878  : 	clgame.maxEntities = bound( 600, clgame.maxEntities, MAX_EDICTS );

	cmp	DWORD PTR _clgame+1012, 600		; 00000258H
	jl	SHORT $LN34@CL_ParseSe
	cmp	DWORD PTR _clgame+1012, 8192		; 00002000H
	jge	SHORT $LN32@CL_ParseSe
	mov	ecx, DWORD PTR _clgame+1012
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN33@CL_ParseSe
$LN32@CL_ParseSe:
	mov	DWORD PTR tv86[ebp], 8192		; 00002000H
$LN33@CL_ParseSe:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], edx
	jmp	SHORT $LN35@CL_ParseSe
$LN34@CL_ParseSe:
	mov	DWORD PTR tv87[ebp], 600		; 00000258H
$LN35@CL_ParseSe:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR _clgame+1012, eax

; 879  : 	clgame.maxModels = MSG_ReadWord( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _clgame+1024, eax

; 880  : 	Q_strncpy( clgame.mapname, MSG_ReadString( msg ), MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+232
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 881  : 	Q_strncpy( clgame.maptitle, MSG_ReadString( msg ), MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+488
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 882  : 	background = MSG_ReadOneBit( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _background$[ebp], eax

; 883  : 	Q_strncpy( gamefolder, MSG_ReadString( msg ), MAX_QPATH );

	push	64					; 00000040H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _gamefolder$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 884  : 	host.features = (uint)MSG_ReadLong( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _host+34748, eax

; 885  : 
; 886  : 	// receive the player hulls
; 887  : 	for( i = 0; i < MAX_MAP_HULLS * 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseSe
$LN2@CL_ParseSe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_ParseSe:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN3@CL_ParseSe

; 888  : 	{
; 889  : 		host.player_mins[i/3][i%3] = MSG_ReadChar( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	imul	esi, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	edi, 3
	idiv	edi
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _host[esi+edx*4+34236], xmm0

; 890  : 		host.player_maxs[i/3][i%3] = MSG_ReadChar( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	imul	esi, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	edi, 3
	idiv	edi
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _host[esi+edx*4+34284], xmm0

; 891  : 	}

	jmp	SHORT $LN2@CL_ParseSe
$LN3@CL_ParseSe:

; 892  : 
; 893  : 	if( clgame.maxModels > MAX_MODELS )

	cmp	DWORD PTR _clgame+1024, 1024		; 00000400H
	jle	SHORT $LN10@CL_ParseSe

; 894  : 		Con_Printf( S_WARN "server model limit is above client model limit %i > %i\n", clgame.maxModels, MAX_MODELS );

	push	1024					; 00000400H
	mov	edx, DWORD PTR _clgame+1024
	push	edx
	push	OFFSET $SG144922
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN10@CL_ParseSe:

; 895  : 
; 896  : 	// Re-init hud video, especially if we changed game directories
; 897  : 	clgame.dllFuncs.pfnVidInit();

	call	DWORD PTR _clgame+12

; 898  : 
; 899  : 	if( Con_FixedFont( ))

	call	_Con_FixedFont
	test	eax, eax
	je	SHORT $LN11@CL_ParseSe

; 900  : 	{
; 901  : 		// seperate the printfs so the server message can have a color
; 902  : 		Con_Print( "\n\35\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\37\n" );

	push	OFFSET $SG144924
	call	_Con_Print
	add	esp, 4

; 903  : 		Con_Print( va( "%c%s\n\n", 2, clgame.maptitle ));

	push	OFFSET _clgame+488
	push	2
	push	OFFSET $SG144925
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_Con_Print
	add	esp, 4
$LN11@CL_ParseSe:

; 904  : 	}
; 905  : 
; 906  : 	// multiplayer game?
; 907  : 	if( cl.maxclients > 1 )	

	cmp	DWORD PTR _cl+1568832, 1
	jle	SHORT $LN12@CL_ParseSe

; 908  : 	{
; 909  : 		// allow console in multiplayer games
; 910  : 		host.allow_console = true;

	mov	DWORD PTR _host+34336, 1

; 911  : 
; 912  : 		// loading user settings
; 913  : 		CSCR_LoadDefaultCVars( "user.scr" );

	push	OFFSET $SG144928
	call	_CSCR_LoadDefaultCVars
	add	esp, 4

; 914  : 
; 915  : 		if( r_decals->value > mp_decals.value )

	mov	eax, DWORD PTR _r_decals
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _mp_decals+12
	jbe	SHORT $LN14@CL_ParseSe

; 916  : 			Cvar_SetValue( "r_decals", mp_decals.value );

	push	ecx
	movss	xmm0, DWORD PTR _mp_decals+12
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144930
	call	_Cvar_SetValue
	add	esp, 8
$LN14@CL_ParseSe:

; 917  : 	}

	jmp	SHORT $LN13@CL_ParseSe
$LN12@CL_ParseSe:

; 918  : 	else Cvar_Reset( "r_decals" );

	push	OFFSET $SG144931
	call	_Cvar_Reset
	add	esp, 4
$LN13@CL_ParseSe:

; 919  : 
; 920  : 	// set the background state
; 921  : 	if( cls.demoplayback && ( cls.demonum != -1 ))

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN15@CL_ParseSe
	cmp	DWORD PTR _cls+293464, -1
	je	SHORT $LN15@CL_ParseSe

; 922  : 	{
; 923  : 		// re-init mouse
; 924  : 		host.mouse_visible = false;

	mov	DWORD PTR _host+34372, 0

; 925  : 		cl.background = true;

	mov	DWORD PTR _cl+64, 1

; 926  : 	}

	jmp	SHORT $LN16@CL_ParseSe
$LN15@CL_ParseSe:

; 927  : 	else cl.background = background;

	mov	ecx, DWORD PTR _background$[ebp]
	mov	DWORD PTR _cl+64, ecx
$LN16@CL_ParseSe:

; 928  : 
; 929  : 	if( cl.background )	// tell the game parts about background state

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN17@CL_ParseSe

; 930  : 		Cvar_FullSet( "cl_background", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG144936
	push	OFFSET $SG144937
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@CL_ParseSe
$LN17@CL_ParseSe:

; 931  : 	else Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG144938
	push	OFFSET $SG144939
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN18@CL_ParseSe:

; 932  : 
; 933  : 	if( !cls.changelevel ) 

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN19@CL_ParseSe

; 934  : 	{
; 935  : 		// continue playing if we are changing level
; 936  : 		S_StopBackgroundTrack ();

	call	_S_StopBackgroundTrack
$LN19@CL_ParseSe:

; 937  : 	}
; 938  : 
; 939  : 	if( !cls.changedemo )

	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN20@CL_ParseSe

; 940  : 		UI_SetActiveMenu( cl.background );

	mov	edx, DWORD PTR _cl+64
	push	edx
	call	_UI_SetActiveMenu
	add	esp, 4
	jmp	SHORT $LN22@CL_ParseSe
$LN20@CL_ParseSe:

; 941  : 	else if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN22@CL_ParseSe

; 942  : 		Key_SetKeyDest( key_menu );

	push	2
	call	_Key_SetKeyDest
	add	esp, 4
$LN22@CL_ParseSe:

; 943  : 
; 944  : 	// don't reset cursor in background mode
; 945  : 	if( cl.background )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN23@CL_ParseSe

; 946  : 		IN_MouseRestorePos();

	call	_IN_MouseRestorePos
$LN23@CL_ParseSe:

; 947  : 
; 948  : 	// will be changed later
; 949  : 	cl.viewentity = cl.playernum + 1;

	mov	eax, DWORD PTR _cl+1568828
	add	eax, 1
	mov	DWORD PTR _cl+1568608, eax

; 950  : 	gameui.globals->maxClients = cl.maxclients;

	mov	ecx, DWORD PTR _gameui+6712
	mov	edx, DWORD PTR _cl+1568832
	mov	DWORD PTR [ecx+16], edx

; 951  : 	Q_strncpy( gameui.globals->maptitle, clgame.maptitle, sizeof( gameui.globals->maptitle ));

	push	64					; 00000040H
	push	OFFSET _clgame+488
	mov	eax, DWORD PTR _gameui+6712
	add	eax, 96					; 00000060H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 952  : 
; 953  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN24@CL_ParseSe
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN24@CL_ParseSe

; 954  : 		CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts
$LN24@CL_ParseSe:

; 955  : 
; 956  : 	// get splash name
; 957  : 	if( cls.demoplayback && ( cls.demonum != -1 ))

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN25@CL_ParseSe
	cmp	DWORD PTR _cls+293464, -1
	je	SHORT $LN25@CL_ParseSe

; 958  : 		Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", cls.demoname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN36@CL_ParseSe
	mov	DWORD PTR tv242[ebp], OFFSET $SG144948
	jmp	SHORT $LN37@CL_ParseSe
$LN36@CL_ParseSe:
	mov	DWORD PTR tv242[ebp], OFFSET $SG144949
$LN37@CL_ParseSe:
	mov	ecx, DWORD PTR tv242[ebp]
	push	ecx
	push	OFFSET _cls+297592
	push	OFFSET $SG144950
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG144951
	call	_Cvar_Set
	add	esp, 8
	jmp	SHORT $LN26@CL_ParseSe
$LN25@CL_ParseSe:

; 959  : 	else Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", clgame.mapname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN38@CL_ParseSe
	mov	DWORD PTR tv250[ebp], OFFSET $SG144952
	jmp	SHORT $LN39@CL_ParseSe
$LN38@CL_ParseSe:
	mov	DWORD PTR tv250[ebp], OFFSET $SG144953
$LN39@CL_ParseSe:
	mov	edx, DWORD PTR tv250[ebp]
	push	edx
	push	OFFSET _clgame+232
	push	OFFSET $SG144954
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG144955
	call	_Cvar_Set
	add	esp, 8
$LN26@CL_ParseSe:

; 960  : 	Cvar_SetValue( "scr_loading", 0.0f ); // reset progress bar

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144956
	call	_Cvar_SetValue
	add	esp, 8

; 961  : 
; 962  : 	if(( cl_allow_levelshots->value && !cls.changelevel ) || cl.background )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@CL_ParseSe
	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN28@CL_ParseSe
$LN29@CL_ParseSe:
	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN27@CL_ParseSe
$LN28@CL_ParseSe:

; 963  : 	{
; 964  : 		if( !FS_FileExists( va( "%s.bmp", cl_levelshot_name->string ), true )) 

	push	1
	mov	ecx, DWORD PTR _cl_levelshot_name
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET $SG144961
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@CL_ParseSe

; 965  : 			Cvar_Set( "cl_levelshot_name", "*black" ); // render a black screen

	push	OFFSET $SG144962
	push	OFFSET $SG144963
	call	_Cvar_Set
	add	esp, 8
$LN30@CL_ParseSe:

; 966  : 		cls.scrshot_request = scrshot_plaque; // request levelshot even if exist (check filetime)

	mov	DWORD PTR _cls+293056, 3
$LN27@CL_ParseSe:

; 967  : 	}
; 968  : 
; 969  : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_ParseSe
$LN5@CL_ParseSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_ParseSe:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN6@CL_ParseSe

; 970  : 		COM_ClearCustomizationList( &cl.players[i].customdata, true );

	push	1
	imul	ecx, DWORD PTR _i$[ebp], 584
	add	ecx, OFFSET _cl+1543552
	push	ecx
	call	_COM_ClearCustomizationList
	add	esp, 8
	jmp	SHORT $LN5@CL_ParseSe
$LN6@CL_ParseSe:

; 971  : 	CL_CreateCustomizationList();

	call	_CL_CreateCustomizationList

; 972  : 
; 973  : 	// request resources from server
; 974  : 	CL_ServerCommand( true, "sendres %i\n", cl.servercount );

	mov	edx, DWORD PTR _cl
	push	edx
	push	OFFSET $SG144964
	push	1
	call	_CL_ServerCommand
	add	esp, 12					; 0000000cH

; 975  : 
; 976  : 	memset( &clgame.movevars, 0, sizeof( clgame.movevars ));

	push	144					; 00000090H
	push	0
	push	OFFSET _clgame+1028
	call	_memset
	add	esp, 12					; 0000000cH

; 977  : 	memset( &clgame.oldmovevars, 0, sizeof( clgame.oldmovevars ));

	push	144					; 00000090H
	push	0
	push	OFFSET _clgame+1172
	call	_memset
	add	esp, 12					; 0000000cH

; 978  : 	memset( &clgame.centerPrint, 0, sizeof( clgame.centerPrint ));

	push	2068					; 00000814H
	push	0
	push	OFFSET _clgame+122816
	call	_memset
	add	esp, 12					; 0000000cH

; 979  : 	cl.video_prepped = false;

	mov	DWORD PTR _cl+16, 0

; 980  : 	cl.audio_prepped = false;

	mov	DWORD PTR _cl+20, 0

; 981  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseServerData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_name$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseFileTransferFailed PROC

; 832  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 833  : 	const char	*name = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 834  : 
; 835  : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN1@CL_ParseFi

; 836  : 		CL_ProcessFile( false, name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	0
	call	_CL_ProcessFile
	add	esp, 8
$LN1@CL_ParseFi:

; 837  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseFileTransferFailed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pResource$ = -12					; size = 4
_pPlayer$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_CreateCustomizationList PROC

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 809  : 	resource_t	*pResource;
; 810  : 	player_info_t	*pPlayer;
; 811  : 	int		i;
; 812  : 
; 813  : 	pPlayer = &cl.players[cl.playernum];

	imul	eax, DWORD PTR _cl+1568828, 584
	add	eax, OFFSET _cl+1543148
	mov	DWORD PTR _pPlayer$[ebp], eax

; 814  : 	pPlayer->customdata.pNext = NULL;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [ecx+564], 0

; 815  : 
; 816  : 	for( i = 0; i < cl.num_resources; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_CreateC
$LN2@CL_CreateC:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_CreateC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2681452
	jge	SHORT $LN1@CL_CreateC

; 817  : 	{
; 818  : 		pResource = &cl.resourcelist[i];

	imul	ecx, DWORD PTR _i$[ebp], 136
	add	ecx, OFFSET _cl+1985132
	mov	DWORD PTR _pResource$[ebp], ecx

; 819  : 
; 820  : 		if( !COM_CreateCustomization( &pPlayer->customdata, pResource, cl.playernum, 0, NULL, NULL ))

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _cl+1568828
	push	edx
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	add	ecx, 404				; 00000194H
	push	ecx
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN5@CL_CreateC

; 821  : 			Con_Printf( "problem with client customization %s, ignoring...", pResource->szFileName );

	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	push	OFFSET $SG144896
	call	_Con_Printf
	add	esp, 8
$LN5@CL_CreateC:

; 822  : 	}

	jmp	SHORT $LN2@CL_CreateC
$LN1@CL_CreateC:

; 823  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateCustomizationList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_arg$ = -131108						; size = 4
_sbuf$ = -131104					; size = 20
_nStartIndex$ = -131084					; size = 4
_i$ = -131080						; size = 4
_buffer$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseResourceRequest PROC

; 762  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131108				; 00020024H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 763  : 	byte	buffer[MAX_INIT_MSG];
; 764  : 	int	i, arg, nStartIndex;
; 765  : 	sizebuf_t	sbuf;
; 766  : 
; 767  : 	MSG_Init( &sbuf, "ResourceBlock", buffer, sizeof( buffer ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET $SG144878
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 768  : 
; 769  : 	arg = MSG_ReadLong( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _arg$[ebp], eax

; 770  : 	nStartIndex = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _nStartIndex$[ebp], eax

; 771  : 
; 772  : 	if( cl.servercount != arg )

	mov	ecx, DWORD PTR _cl
	cmp	ecx, DWORD PTR _arg$[ebp]
	je	SHORT $LN5@CL_ParseRe

; 773  : 		return;

	jmp	$LN1@CL_ParseRe
$LN5@CL_ParseRe:

; 774  : 
; 775  : 	if( nStartIndex < 0 && nStartIndex > cl.num_resources )

	cmp	DWORD PTR _nStartIndex$[ebp], 0
	jge	SHORT $LN6@CL_ParseRe
	mov	edx, DWORD PTR _nStartIndex$[ebp]
	cmp	edx, DWORD PTR _cl+2681452
	jle	SHORT $LN6@CL_ParseRe

; 776  : 		return;

	jmp	$LN1@CL_ParseRe
$LN6@CL_ParseRe:

; 777  : 
; 778  : 	MSG_BeginClientCmd( &sbuf, clc_resourcelist );

	push	0
	push	0
	push	5
	lea	eax, DWORD PTR _sbuf$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 779  : 	MSG_WriteShort( &sbuf, cl.num_resources );

	mov	ecx, DWORD PTR _cl+2681452
	push	ecx
	lea	edx, DWORD PTR _sbuf$[ebp]
	push	edx
	call	_MSG_WriteShort
	add	esp, 8

; 780  : 
; 781  : 	for( i = nStartIndex; i < cl.num_resources; i++ )

	mov	eax, DWORD PTR _nStartIndex$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@CL_ParseRe
$LN2@CL_ParseRe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_ParseRe:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cl+2681452
	jge	$LN3@CL_ParseRe

; 782  : 	{
; 783  : 		MSG_WriteString( &sbuf, cl.resourcelist[i].szFileName );

	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, OFFSET _cl+1985132
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 784  : 		MSG_WriteByte( &sbuf, cl.resourcelist[i].type );

	imul	edx, DWORD PTR _i$[ebp], 136
	mov	eax, DWORD PTR _cl[edx+1985196]
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 785  : 		MSG_WriteShort( &sbuf, cl.resourcelist[i].nIndex );

	imul	edx, DWORD PTR _i$[ebp], 136
	mov	eax, DWORD PTR _cl[edx+1985200]
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteShort
	add	esp, 8

; 786  : 		MSG_WriteLong( &sbuf, cl.resourcelist[i].nDownloadSize );

	imul	edx, DWORD PTR _i$[ebp], 136
	mov	eax, DWORD PTR _cl[edx+1985204]
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 787  : 		MSG_WriteByte( &sbuf, cl.resourcelist[i].ucFlags );

	imul	edx, DWORD PTR _i$[ebp], 136
	movzx	eax, BYTE PTR _cl[edx+1985208]
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 788  : 
; 789  : 		if( FBitSet( cl.resourcelist[i].ucFlags, RES_CUSTOM ))

	imul	edx, DWORD PTR _i$[ebp], 136
	movzx	eax, BYTE PTR _cl[edx+1985208]
	and	eax, 4
	je	SHORT $LN7@CL_ParseRe

; 790  : 			MSG_WriteBytes( &sbuf, cl.resourcelist[i].rgucMD5_hash, 16 );

	push	16					; 00000010H
	imul	ecx, DWORD PTR _i$[ebp], 136
	add	ecx, OFFSET _cl+1985209
	push	ecx
	lea	edx, DWORD PTR _sbuf$[ebp]
	push	edx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH
$LN7@CL_ParseRe:

; 791  : 	}

	jmp	$LN2@CL_ParseRe
$LN3@CL_ParseRe:

; 792  : 
; 793  : 	if( MSG_GetNumBytesWritten( &sbuf ) > 0 )

	lea	eax, DWORD PTR _sbuf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN1@CL_ParseRe

; 794  : 	{
; 795  : 		Netchan_CreateFragments( &cls.netchan, &sbuf );

	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	push	OFFSET _cls+23520
	call	_Netchan_CreateFragments
	add	esp, 8

; 796  : 		Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_FragSend
	add	esp, 4
$LN1@CL_ParseRe:

; 797  : 	}
; 798  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResourceRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_bError$1 = -24						; size = 4
_bFound$ = -20						; size = 4
_pExistingCustomization$ = -16				; size = 4
_i$ = -12						; size = 4
_pList$ = -8						; size = 4
_pRes$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseCustomization PROC

; 674  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 675  : 	customization_t	*pExistingCustomization;
; 676  : 	customization_t	*pList;
; 677  : 	qboolean		bFound;
; 678  : 	resource_t	*pRes;
; 679  : 	int		i;
; 680  : 
; 681  : 	i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 682  : 	if( i >= MAX_CLIENTS )

	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jl	SHORT $LN5@CL_ParseCu

; 683  : 		Host_Error( "Bogus player index during customization parsing.\n" );

	push	OFFSET $SG144842
	call	_Host_Error
	add	esp, 4
$LN5@CL_ParseCu:

; 684  : 
; 685  : 	pRes = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	push	685					; 000002adH
	push	OFFSET $SG144843
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pRes$[ebp], eax

; 686  : 	pRes->type = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 687  : 
; 688  : 	Q_strncpy( pRes->szFileName, MSG_ReadString( msg ), sizeof( pRes->szFileName ));

	push	64					; 00000040H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 689  : 	pRes->nIndex = MSG_ReadShort( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [edx+68], eax

; 690  : 	pRes->nDownloadSize = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 691  : 	pRes->ucFlags = MSG_ReadByte( msg ) & ~RES_WASMISSING;

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [ecx+76], al

; 692  : 	pRes->pNext = pRes->pPrev = NULL;

	mov	edx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [edx+132], 0
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [eax+128], 0

; 693  : 
; 694  : 	if( FBitSet( pRes->ucFlags, RES_CUSTOM ))

	mov	ecx, DWORD PTR _pRes$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	and	edx, 4
	je	SHORT $LN6@CL_ParseCu

; 695  : 		MSG_ReadBytes( msg, pRes->rgucMD5_hash, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pRes$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN6@CL_ParseCu:

; 696  : 	pRes->playernum = i;

	mov	edx, DWORD PTR _pRes$[ebp]
	mov	al, BYTE PTR _i$[ebp]
	mov	BYTE PTR [edx+93], al

; 697  : 
; 698  : 	if( !cl_allow_download.value )

	movss	xmm0, DWORD PTR _cl_allow_download+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_ParseCu

; 699  : 	{
; 700  : 		Con_DPrintf( "Refusing new resource, cl_allow_download set to 0\n" );

	push	OFFSET $SG144846
	call	_Con_DPrintf
	add	esp, 4

; 701  : 		Mem_Free( pRes );

	push	701					; 000002bdH
	push	OFFSET $SG144847
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 702  : 		return;

	jmp	$LN12@CL_ParseCu
$LN7@CL_ParseCu:

; 703  : 	}
; 704  : 
; 705  : 	if( cls.state == ca_active && !cl_download_ingame.value )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN8@CL_ParseCu
	movss	xmm0, DWORD PTR _cl_download_ingame+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_ParseCu

; 706  : 	{
; 707  : 		Con_DPrintf( "Refusing new resource, cl_download_ingame set to 0\n" );

	push	OFFSET $SG144849
	call	_Con_DPrintf
	add	esp, 4

; 708  : 		Mem_Free( pRes );

	push	708					; 000002c4H
	push	OFFSET $SG144850
	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 709  : 		return;

	jmp	$LN12@CL_ParseCu
$LN8@CL_ParseCu:

; 710  : 	}
; 711  : 
; 712  : 	pExistingCustomization = CL_PlayerHasCustomization( i, pRes->type );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_CL_PlayerHasCustomization
	add	esp, 8
	mov	DWORD PTR _pExistingCustomization$[ebp], eax

; 713  : 
; 714  : 	if( pExistingCustomization )

	cmp	DWORD PTR _pExistingCustomization$[ebp], 0
	je	SHORT $LN9@CL_ParseCu

; 715  : 		CL_RemoveCustomization( i, pExistingCustomization );

	mov	eax, DWORD PTR _pExistingCustomization$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_CL_RemoveCustomization
	add	esp, 8
$LN9@CL_ParseCu:

; 716  : 	bFound = false;

	mov	DWORD PTR _bFound$[ebp], 0

; 717  : 
; 718  : 	for( pList = cl.players[pRes->playernum].customdata.pNext; pList; pList = pList->pNext )

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+93]
	imul	ecx, eax, 584
	mov	edx, DWORD PTR _cl[ecx+1543712]
	mov	DWORD PTR _pList$[ebp], edx
	jmp	SHORT $LN4@CL_ParseCu
$LN2@CL_ParseCu:
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pList$[ebp], ecx
$LN4@CL_ParseCu:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN3@CL_ParseCu

; 719  : 	{
; 720  : 		if( !memcmp( pList->resource.rgucMD5_hash, pRes->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	edx, DWORD PTR _pRes$[ebp]
	add	edx, 77					; 0000004dH
	push	edx
	mov	eax, DWORD PTR _pList$[ebp]
	add	eax, 81					; 00000051H
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@CL_ParseCu

; 721  : 		{
; 722  : 			bFound = true;

	mov	DWORD PTR _bFound$[ebp], 1

; 723  : 			break;

	jmp	SHORT $LN3@CL_ParseCu
$LN10@CL_ParseCu:

; 724  : 		}
; 725  : 	}

	jmp	SHORT $LN2@CL_ParseCu
$LN3@CL_ParseCu:

; 726  : 
; 727  : 	if( HPAK_GetDataPointer( CUSTOM_RES_PATH, pRes, NULL, NULL ))

	push	0
	push	0
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	push	OFFSET $SG144855
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN11@CL_ParseCu

; 728  : 	{
; 729  : 		qboolean	bError = false;

	mov	DWORD PTR _bError$1[ebp], 0

; 730  : 
; 731  : 		if( !bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	jne	SHORT $LN13@CL_ParseCu

; 732  : 		{
; 733  : 			pList = &cl.players[pRes->playernum].customdata;

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+93]
	imul	ecx, eax, 584
	add	ecx, OFFSET _cl+1543552
	mov	DWORD PTR _pList$[ebp], ecx

; 734  : 
; 735  : 			if( !COM_CreateCustomization( pList, pRes, pRes->playernum, FCUST_FROMHPAK, NULL, NULL ))

	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+93]
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pList$[ebp]
	push	edx
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN15@CL_ParseCu

; 736  : 				bError = true;

	mov	DWORD PTR _bError$1[ebp], 1
$LN15@CL_ParseCu:

; 737  : 		}

	jmp	SHORT $LN14@CL_ParseCu
$LN13@CL_ParseCu:

; 738  : 		else
; 739  : 		{
; 740  : 			Con_DPrintf( "Duplicate resource ignored for local client\n" );

	push	OFFSET $SG144859
	call	_Con_DPrintf
	add	esp, 4
$LN14@CL_ParseCu:

; 741  : 		}
; 742  : 
; 743  : 		if( bError ) Con_DPrintf( "Error loading customization\n" );

	cmp	DWORD PTR _bError$1[ebp], 0
	je	SHORT $LN16@CL_ParseCu
	push	OFFSET $SG144861
	call	_Con_DPrintf
	add	esp, 4
$LN16@CL_ParseCu:

; 744  : 		Mem_Free( pRes );

	push	744					; 000002e8H
	push	OFFSET $SG144862
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 745  : 	}

	jmp	SHORT $LN12@CL_ParseCu
$LN11@CL_ParseCu:

; 746  : 	else
; 747  : 	{
; 748  : 		SetBits( pRes->ucFlags, RES_WASMISSING );

	mov	ecx, DWORD PTR _pRes$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	or	edx, 2
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [eax+76], dl

; 749  : 		CL_AddToResourceList( pRes, &cl.resourcesneeded );

	push	OFFSET _cl+1984996
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	_CL_AddToResourceList
	add	esp, 8

; 750  : 		Con_Printf( "Requesting %s from server\n", pRes->szFileName );

	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	push	OFFSET $SG144863
	call	_Con_Printf
	add	esp, 8

; 751  : 		CL_StartResourceDownloading( "Custom resource propagation...\n", true );

	push	1
	push	OFFSET $SG144864
	call	_CL_StartResourceDownloading
	add	esp, 8
$LN12@CL_ParseCu:

; 752  : 	}
; 753  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pNext$ = -8						; size = 4
_pList$ = -4						; size = 4
_nPlayerNum$ = 8					; size = 4
_pRemove$ = 12						; size = 4
_CL_RemoveCustomization PROC

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 638  : 	customization_t	*pList;
; 639  : 	customization_t	*pNext;
; 640  : 
; 641  : 	for( pList = cl.players[nPlayerNum].customdata.pNext; pList; pList = pNext )

	imul	eax, DWORD PTR _nPlayerNum$[ebp], 584
	mov	ecx, DWORD PTR _cl[eax+1543712]
	mov	DWORD PTR _pList$[ebp], ecx
	jmp	SHORT $LN4@CL_RemoveC
$LN2@CL_RemoveC:
	mov	edx, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _pList$[ebp], edx
$LN4@CL_RemoveC:
	cmp	DWORD PTR _pList$[ebp], 0
	je	$LN1@CL_RemoveC

; 642  : 	{
; 643  : 		pNext = pList->pNext;

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pNext$[ebp], ecx

; 644  : 
; 645  : 		if( pRemove != pList )

	mov	edx, DWORD PTR _pRemove$[ebp]
	cmp	edx, DWORD PTR _pList$[ebp]
	je	SHORT $LN5@CL_RemoveC

; 646  : 			continue;

	jmp	SHORT $LN2@CL_RemoveC
$LN5@CL_RemoveC:

; 647  : 
; 648  : 		if( pList->bInUse && pList->pBuffer )

	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@CL_RemoveC
	mov	ecx, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [ecx+156], 0
	je	SHORT $LN6@CL_RemoveC

; 649  : 			Mem_Free( pList->pBuffer );

	push	649					; 00000289H
	push	OFFSET $SG144817
	mov	edx, DWORD PTR _pList$[ebp]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN6@CL_RemoveC:

; 650  : 
; 651  : 		if( pList->bInUse && pList->pInfo )

	mov	ecx, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@CL_RemoveC
	mov	edx, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN7@CL_RemoveC

; 652  : 		{
; 653  : 			if( pList->resource.type == t_decal )

	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN7@CL_RemoveC

; 654  : 			{
; 655  : 				if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN9@CL_RemoveC

; 656  : 					R_DecalRemoveAll( pList->nUserData1 );

	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	_R_DecalRemoveAll
	add	esp, 4
$LN9@CL_RemoveC:

; 657  : 				FS_FreeImage( pList->pInfo );

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	push	ecx
	call	_FS_FreeImage
	add	esp, 4
$LN7@CL_RemoveC:

; 658  : 			}
; 659  : 		}
; 660  : 
; 661  : 		cl.players[nPlayerNum].customdata.pNext = pNext;

	imul	edx, DWORD PTR _nPlayerNum$[ebp], 584
	mov	eax, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _cl[edx+1543712], eax

; 662  : 		Mem_Free( pList );

	push	662					; 00000296H
	push	OFFSET $SG144821
	mov	ecx, DWORD PTR _pList$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 663  : 		break;

	jmp	SHORT $LN1@CL_RemoveC

; 664  : 	}

	jmp	$LN2@CL_RemoveC
$LN1@CL_RemoveC:

; 665  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RemoveCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pList$ = -4						; size = 4
_nPlayerNum$ = 8					; size = 4
_type$ = 12						; size = 4
_CL_PlayerHasCustomization PROC

; 625  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 626  : 	customization_t	*pList;
; 627  : 
; 628  : 	for( pList = cl.players[nPlayerNum].customdata.pNext; pList; pList = pList->pNext )

	imul	eax, DWORD PTR _nPlayerNum$[ebp], 584
	mov	ecx, DWORD PTR _cl[eax+1543712]
	mov	DWORD PTR _pList$[ebp], ecx
	jmp	SHORT $LN4@CL_PlayerH
$LN2@CL_PlayerH:
	mov	edx, DWORD PTR _pList$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	DWORD PTR _pList$[ebp], eax
$LN4@CL_PlayerH:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN3@CL_PlayerH

; 629  : 	{
; 630  : 		if( pList->resource.type == type )

	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	cmp	edx, DWORD PTR _type$[ebp]
	jne	SHORT $LN5@CL_PlayerH

; 631  : 			return pList;

	mov	eax, DWORD PTR _pList$[ebp]
	jmp	SHORT $LN1@CL_PlayerH
$LN5@CL_PlayerH:

; 632  : 	}

	jmp	SHORT $LN2@CL_PlayerH
$LN3@CL_PlayerH:

; 633  : 	return NULL;

	xor	eax, eax
$LN1@CL_PlayerH:

; 634  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerHasCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_fadePercent$ = -16					; size = 4
_fadeOutSeconds$ = -12					; size = 4
_holdTime$ = -8						; size = 4
_fadeInSeconds$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseSoundFade PROC

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 416  : 	float	fadePercent, fadeOutSeconds;
; 417  : 	float	holdTime, fadeInSeconds;
; 418  : 
; 419  : 	fadePercent = (float)MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fadePercent$[ebp], xmm0

; 420  : 	holdTime = (float)MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _holdTime$[ebp], xmm0

; 421  : 	fadeOutSeconds = (float)MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fadeOutSeconds$[ebp], xmm0

; 422  : 	fadeInSeconds = (float)MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fadeInSeconds$[ebp], xmm0

; 423  : 
; 424  : 	S_FadeClientVolume( fadePercent, fadeOutSeconds, holdTime, fadeInSeconds );

	push	ecx
	movss	xmm0, DWORD PTR _fadeInSeconds$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _holdTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fadeOutSeconds$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fadePercent$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_S_FadeClientVolume
	add	esp, 16					; 00000010H

; 425  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSoundFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_ent$ = -40						; size = 4
_decalIndex$ = -36					; size = 4
_flags$ = -32						; size = 4
_scale$ = -28						; size = 4
_entityIndex$ = -24					; size = 4
_modelIndex$ = -20					; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseStaticDecal PROC

; 388  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 389  : 	vec3_t		origin;
; 390  : 	int		decalIndex, entityIndex, modelIndex;
; 391  : 	cl_entity_t	*ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 392  : 	float		scale;
; 393  : 	int		flags;
; 394  : 
; 395  : 	MSG_ReadVec3Coord( msg, origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 396  : 	decalIndex = MSG_ReadWord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 397  : 	entityIndex = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 398  : 
; 399  : 	if( entityIndex > 0 )

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN2@CL_ParseSt

; 400  : 		modelIndex = MSG_ReadWord( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax
	jmp	SHORT $LN3@CL_ParseSt
$LN2@CL_ParseSt:

; 401  : 	else modelIndex = 0;

	mov	DWORD PTR _modelIndex$[ebp], 0
$LN3@CL_ParseSt:

; 402  : 	flags = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 403  : 	scale = (float)MSG_ReadWord( msg ) / 4096.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@45800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 404  : 
; 405  : 	CL_FireCustomDecal( CL_DecalIndex( decalIndex ), entityIndex, modelIndex, origin, flags, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_FireCustomDecal
	add	esp, 24					; 00000018H

; 406  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseStaticDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_newnum$ = -696						; size = 4
_i$ = -692						; size = 4
_ent$ = -688						; size = 4
_to$ = -684						; size = 340
_from$ = -344						; size = 340
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseStaticEntity PROC

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 696				; 000002b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 310  : 	int		i, newnum;
; 311  : 	entity_state_t	from, to;
; 312  : 	cl_entity_t	*ent;
; 313  : 
; 314  : 	memset( &from, 0, sizeof( from ));

	push	340					; 00000154H
	push	0
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 315  : 	newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 316  : 	MSG_ReadDeltaEntity( msg, &from, &to, 0, DELTA_STATIC, cl.mtime[0] );

	mov	edx, 8
	imul	eax, edx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[eax+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	push	0
	lea	ecx, DWORD PTR _to$[ebp]
	push	ecx
	lea	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 317  : 
; 318  : 	i = clgame.numStatics;

	mov	ecx, DWORD PTR _clgame+1020
	mov	DWORD PTR _i$[ebp], ecx

; 319  : 	if( i >= MAX_STATIC_ENTITIES )

	cmp	DWORD PTR _i$[ebp], 3096		; 00000c18H
	jl	SHORT $LN2@CL_ParseSt

; 320  : 	{
; 321  : 		Con_Printf( S_ERROR "MAX_STATIC_ENTITIES limit exceeded!\n" );

	push	OFFSET $SG144676
	call	_Con_Printf
	add	esp, 4

; 322  : 		return;

	jmp	$LN1@CL_ParseSt
$LN2@CL_ParseSt:

; 323  : 	}
; 324  : 
; 325  : 	ent = &clgame.static_entities[i];

	imul	edx, DWORD PTR _i$[ebp], 3000
	add	edx, DWORD PTR _clgame+1004
	mov	DWORD PTR _ent$[ebp], edx

; 326  : 	clgame.numStatics++;

	mov	eax, DWORD PTR _clgame+1020
	add	eax, 1
	mov	DWORD PTR _clgame+1020, eax

; 327  : 
; 328  : 	// all states are same
; 329  : 	ent->baseline = ent->curstate = ent->prevstate = to;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 348				; 0000015cH
	mov	ecx, 85					; 00000055H
	lea	esi, DWORD PTR _to$[ebp]
	rep movsd
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 688				; 000002b0H
	mov	ecx, 85					; 00000055H
	lea	esi, DWORD PTR _to$[ebp]
	rep movsd
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 8
	mov	ecx, 85					; 00000055H
	lea	esi, DWORD PTR _to$[ebp]
	rep movsd

; 330  : 	ent->index = 0; // static entities doesn't has the numbers

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx], 0

; 331  : 
; 332  : 	// statics may be respawned in game e.g. for demo recording
; 333  : 	if( cls.state == ca_connected || cls.state == ca_validate )

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN4@CL_ParseSt
	cmp	DWORD PTR _cls, 3
	jne	SHORT $LN3@CL_ParseSt
$LN4@CL_ParseSt:

; 334  : 		ent->trivial_accept = INVALID_HANDLE;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+2960], 65535		; 0000ffffH
$LN3@CL_ParseSt:

; 335  : 
; 336  : 	// setup the new static entity
; 337  : 	VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [edx+eax+2888], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2888], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2888], eax

; 338  : 	VectorCopy( ent->curstate.angles, ent->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [eax+ecx+2900], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2900], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2900], ecx

; 339  : 	ent->model = CL_ModelHandle( to.modelindex );

	mov	edx, DWORD PTR _to$[ebp+40]
	push	edx
	call	_CL_ModelHandle
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+2964], eax

; 340  : 	ent->curstate.framerate = 1.0f;

	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+784], xmm0

; 341  : 	CL_ResetLatchedVars( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8

; 342  : 
; 343  : 	if( ent->curstate.rendermode == kRenderNormal && ent->model != NULL )

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+760], 0
	jne	SHORT $LN6@CL_ParseSt
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+2964], 0
	je	SHORT $LN6@CL_ParseSt

; 344  : 	{
; 345  : 		// auto 'solid' faces
; 346  : 		if( FBitSet( ent->model->flags, MODEL_TRANSPARENT ) && CL_IsQuakeCompatible( ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN6@CL_ParseSt
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN6@CL_ParseSt

; 347  : 		{
; 348  : 			ent->curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+760], 4

; 349  : 			ent->curstate.renderamt = 255;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+764], 255		; 000000ffH
$LN6@CL_ParseSt:

; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	R_AddEfrags( ent );	// add link

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_R_AddEfrags
	add	esp, 4
$LN1@CL_ParseSt:

; 354  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseStaticEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_color$ = -48						; size = 4
_life$ = -44						; size = 4
_count$ = -40						; size = 4
_i$ = -36						; size = 4
_p$1 = -32						; size = 4
_org$ = -28						; size = 12
_dir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseParticles PROC

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 270  : 	vec3_t		org, dir;
; 271  : 	int		i, count, color;
; 272  : 	float		life;
; 273  : 	
; 274  : 	MSG_ReadVec3Coord( msg, org );	

	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 275  : 
; 276  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParsePa
$LN2@CL_ParsePa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_ParsePa:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@CL_ParsePa

; 277  : 		dir[i] = MSG_ReadChar( msg ) * 0.0625f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _dir$[ebp+ecx*4], xmm0
	jmp	SHORT $LN2@CL_ParsePa
$LN3@CL_ParsePa:

; 278  : 
; 279  : 	count = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 280  : 	color = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 281  : 	if( count == 255 ) count = 1024;

	cmp	DWORD PTR _count$[ebp], 255		; 000000ffH
	jne	SHORT $LN5@CL_ParsePa
	mov	DWORD PTR _count$[ebp], 1024		; 00000400H
$LN5@CL_ParsePa:

; 282  : 	life = MSG_ReadByte( msg ) * 0.125f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e000000
	movss	DWORD PTR _life$[ebp], xmm0

; 283  : 
; 284  : 	if( life != 0.0f && count == 1 )

	movss	xmm0, DWORD PTR _life$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@CL_ParsePa
	cmp	DWORD PTR _count$[ebp], 1
	jne	$LN6@CL_ParsePa

; 285  : 	{
; 286  : 		particle_t	*p;
; 287  : 
; 288  : 		p = R_AllocParticle( NULL );

	push	0
	call	_R_AllocParticle
	add	esp, 4
	mov	DWORD PTR _p$1[ebp], eax

; 289  : 		if( !p ) return;

	cmp	DWORD PTR _p$1[ebp], 0
	jne	SHORT $LN8@CL_ParsePa
	jmp	$LN7@CL_ParsePa
$LN8@CL_ParsePa:

; 290  : 
; 291  : 		p->die += life;

	mov	edx, DWORD PTR _p$1[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	addss	xmm0, DWORD PTR _life$[ebp]
	mov	eax, DWORD PTR _p$1[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 292  : 		p->color = color;

	mov	ecx, DWORD PTR _p$1[ebp]
	mov	dx, WORD PTR _color$[ebp]
	mov	WORD PTR [ecx+12], dx

; 293  : 		p->type = pt_static;

	mov	eax, DWORD PTR _p$1[ebp]
	mov	DWORD PTR [eax+40], 0

; 294  : 
; 295  : 		VectorCopy( org, p->org );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _p$1[ebp]
	mov	edx, DWORD PTR _org$[ebp+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	eax, DWORD PTR _org$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _p$1[ebp]
	mov	ecx, DWORD PTR _org$[ebp+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 296  : 		VectorCopy( dir, p->vel );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	eax, DWORD PTR _dir$[ebp+eax]
	mov	DWORD PTR [ecx+edx+20], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p$1[ebp]
	mov	ecx, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR [eax+edx+20], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	edx, DWORD PTR _dir$[ebp+edx]
	mov	DWORD PTR [ecx+eax+20], edx

; 297  : 	}

	jmp	SHORT $LN7@CL_ParsePa
$LN6@CL_ParsePa:

; 298  : 	else R_RunParticleEffect( org, dir, color, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_R_RunParticleEffect
	add	esp, 16					; 00000010H
$LN7@CL_ParsePa:

; 299  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseParticles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseMovevars PROC

; 242  : {

	push	ebp
	mov	ebp, esp

; 243  : 	Delta_InitClient ();	// finalize client delta's

	call	_Delta_InitClient

; 244  : 
; 245  : 	MSG_ReadDeltaMovevars( msg, &clgame.oldmovevars, &clgame.movevars );

	push	OFFSET _clgame+1028
	push	OFFSET _clgame+1172
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaMovevars
	add	esp, 12					; 0000000cH

; 246  : 
; 247  : 	// water alpha is not allowed
; 248  : 	if( !FBitSet( world.flags, FWORLD_WATERALPHA ))

	mov	ecx, DWORD PTR _world+4
	and	ecx, 4
	jne	SHORT $LN2@CL_ParseMo

; 249  : 		clgame.movevars.wateralpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _clgame+1168, xmm0
$LN2@CL_ParseMo:

; 250  : 
; 251  : 	// update sky if changed
; 252  : 	if( Q_strcmp( clgame.oldmovevars.skyName, clgame.movevars.skyName ) && cl.video_prepped )

	push	99999					; 0001869fH
	push	OFFSET _clgame+1096
	push	OFFSET _clgame+1240
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@CL_ParseMo
	cmp	DWORD PTR _cl+16, 0
	je	SHORT $LN3@CL_ParseMo

; 253  : 		R_SetupSky( clgame.movevars.skyName );

	push	OFFSET _clgame+1096
	call	_R_SetupSky
	add	esp, 4
$LN3@CL_ParseMo:

; 254  : 
; 255  : 	memcpy( &clgame.oldmovevars, &clgame.movevars, sizeof( movevars_t ));

	push	144					; 00000090H
	push	OFFSET _clgame+1028
	push	OFFSET _clgame+1172
	call	_memcpy
	add	esp, 12					; 0000000cH

; 256  : 	clgame.entities->curstate.scale = clgame.movevars.waveHeight;

	mov	edx, DWORD PTR _clgame+1000
	movss	xmm0, DWORD PTR _clgame+1088
	movss	DWORD PTR [edx+752], xmm0

; 257  : 
; 258  : 	// keep features an actual!
; 259  : 	clgame.oldmovevars.features = clgame.movevars.features = host.features;

	mov	eax, DWORD PTR _host+34748
	mov	DWORD PTR _clgame+1160, eax
	mov	ecx, DWORD PTR _clgame+1160
	mov	DWORD PTR _clgame+1304, ecx

; 260  : }

	pop	ebp
	ret	0
_CL_ParseMovevars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseSignon PROC

; 221  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 222  : 	int	i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 223  : 
; 224  : 	if( i <= cls.signon )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cls+64
	jg	SHORT $LN2@CL_ParseSi

; 225  : 	{
; 226  : 		Con_Reportf( S_ERROR "received signon %i when at %i\n", i, cls.signon );

	mov	edx, DWORD PTR _cls+64
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG144638
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 227  : 		CL_Disconnect();

	call	_CL_Disconnect

; 228  : 		return;

	jmp	SHORT $LN1@CL_ParseSi
$LN2@CL_ParseSi:

; 229  : 	}
; 230  : 
; 231  : 	cls.signon = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cls+64, ecx

; 232  : 	CL_SignonReply();

	call	_CL_SignonReply
$LN1@CL_ParseSi:

; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSignon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_samplePos$ = -100					; size = 8
_forcedEnd$ = -92					; size = 8
_entnum$ = -84						; size = 4
_chan$ = -80						; size = 4
_wordIndex$ = -76					; size = 4
_volume$ = -72						; size = 4
_attn$ = -68						; size = 4
_pitch$ = -64						; size = 4
_handle$ = -60						; size = 4
_sound$ = -56						; size = 4
_flags$ = -52						; size = 4
_pos$ = -48						; size = 12
_sentenceName$1 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseRestoreSoundPacket PROC

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 125  : 	vec3_t	pos;
; 126  : 	int 	chan, sound;
; 127  : 	float 	volume, attn;  
; 128  : 	int	flags, pitch, entnum;
; 129  : 	double	samplePos, forcedEnd;
; 130  : 	int	wordIndex;
; 131  : 	sound_t	handle = 0;

	mov	DWORD PTR _handle$[ebp], 0

; 132  : 
; 133  : 	flags = MSG_ReadUBitLong( msg, MAX_SND_FLAGS_BITS );

	push	14					; 0000000eH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _flags$[ebp], eax

; 134  : 	sound = MSG_ReadUBitLong( msg, MAX_SOUND_BITS );

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _sound$[ebp], eax

; 135  : 	chan = MSG_ReadUBitLong( msg, MAX_SND_CHAN_BITS );

	push	4
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _chan$[ebp], eax

; 136  : 
; 137  : 	if( flags & SND_VOLUME )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@CL_ParseRe

; 138  : 		volume = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _volume$[ebp], xmm0
	jmp	SHORT $LN3@CL_ParseRe
$LN2@CL_ParseRe:

; 139  : 	else volume = VOL_NORM;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _volume$[ebp], xmm0
$LN3@CL_ParseRe:

; 140  : 
; 141  : 	if( flags & SND_ATTENUATION )

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN4@CL_ParseRe

; 142  : 		attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0
	jmp	SHORT $LN5@CL_ParseRe
$LN4@CL_ParseRe:

; 143  : 	else attn = ATTN_NONE;	

	xorps	xmm0, xmm0
	movss	DWORD PTR _attn$[ebp], xmm0
$LN5@CL_ParseRe:

; 144  : 
; 145  : 	if( flags & SND_PITCH )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 8
	je	SHORT $LN6@CL_ParseRe

; 146  : 		pitch = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _pitch$[ebp], eax
	jmp	SHORT $LN7@CL_ParseRe
$LN6@CL_ParseRe:

; 147  : 	else pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN7@CL_ParseRe:

; 148  : 
; 149  : 	// entity reletive
; 150  : 	entnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _entnum$[ebp], eax

; 151  : 
; 152  : 	// positioned in space
; 153  : 	MSG_ReadVec3Coord( msg, pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 154  : 
; 155  : 	if( flags & SND_SENTENCE )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN8@CL_ParseRe

; 156  : 	{
; 157  : 		char	sentenceName[32];
; 158  : 
; 159  : 		if( flags & SND_SEQUENCE )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	je	SHORT $LN10@CL_ParseRe

; 160  : 			Q_snprintf( sentenceName, sizeof( sentenceName ), "!%i", sound + MAX_SOUNDS );

	mov	edx, DWORD PTR _sound$[ebp]
	add	edx, 2048				; 00000800H
	push	edx
	push	OFFSET $SG144619
	push	32					; 00000020H
	lea	eax, DWORD PTR _sentenceName$1[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@CL_ParseRe
$LN10@CL_ParseRe:

; 161  : 		else Q_snprintf( sentenceName, sizeof( sentenceName ), "!%i", sound );

	mov	ecx, DWORD PTR _sound$[ebp]
	push	ecx
	push	OFFSET $SG144620
	push	32					; 00000020H
	lea	edx, DWORD PTR _sentenceName$1[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN11@CL_ParseRe:

; 162  : 
; 163  : 		handle = S_RegisterSound( sentenceName );

	lea	eax, DWORD PTR _sentenceName$1[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$[ebp], eax

; 164  : 	}

	jmp	SHORT $LN9@CL_ParseRe
$LN8@CL_ParseRe:

; 165  : 	else handle = cl.sound_index[sound]; // see precached sound

	mov	ecx, DWORD PTR _sound$[ebp]
	movsx	edx, WORD PTR _cl[ecx*2+2681456]
	mov	DWORD PTR _handle$[ebp], edx
$LN9@CL_ParseRe:

; 166  : 
; 167  : 	wordIndex = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _wordIndex$[ebp], eax

; 168  : 
; 169  : 	// 16 bytes here
; 170  : 	MSG_ReadBytes( msg, &samplePos, sizeof( samplePos ));

	push	8
	lea	ecx, DWORD PTR _samplePos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 171  : 	MSG_ReadBytes( msg, &forcedEnd, sizeof( forcedEnd ));

	push	8
	lea	eax, DWORD PTR _forcedEnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 172  : 
; 173  : 	if( !cl.audio_prepped )

	cmp	DWORD PTR _cl+20, 0
	jne	SHORT $LN12@CL_ParseRe

; 174  : 		return; // too early

	jmp	SHORT $LN1@CL_ParseRe
$LN12@CL_ParseRe:

; 175  : 
; 176  : 	S_RestoreSound( pos, entnum, chan, handle, volume, attn, pitch, flags, samplePos, forcedEnd, wordIndex );

	mov	edx, DWORD PTR _wordIndex$[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _forcedEnd$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _samplePos$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entnum$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_S_RestoreSound
	add	esp, 52					; 00000034H
$LN1@CL_ParseRe:

; 177  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseRestoreSoundPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_entnum$ = -80						; size = 4
_chan$ = -76						; size = 4
_volume$ = -72						; size = 4
_attn$ = -68						; size = 4
_pitch$ = -64						; size = 4
_sound$ = -60						; size = 4
_handle$ = -56						; size = 4
_flags$ = -52						; size = 4
_pos$ = -48						; size = 12
_sentenceName$1 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseSoundPacket PROC

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 63   : 	vec3_t	pos;
; 64   : 	int 	chan, sound;
; 65   : 	float 	volume, attn;  
; 66   : 	int	flags, pitch, entnum;
; 67   : 	sound_t	handle = 0;

	mov	DWORD PTR _handle$[ebp], 0

; 68   : 
; 69   : 	flags = MSG_ReadUBitLong( msg, MAX_SND_FLAGS_BITS );

	push	14					; 0000000eH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _flags$[ebp], eax

; 70   : 	sound = MSG_ReadUBitLong( msg, MAX_SOUND_BITS );

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _sound$[ebp], eax

; 71   : 	chan = MSG_ReadUBitLong( msg, MAX_SND_CHAN_BITS );

	push	4
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _chan$[ebp], eax

; 72   : 
; 73   : 	if( FBitSet( flags, SND_VOLUME ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@CL_ParseSo

; 74   : 		volume = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _volume$[ebp], xmm0
	jmp	SHORT $LN3@CL_ParseSo
$LN2@CL_ParseSo:

; 75   : 	else volume = VOL_NORM;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _volume$[ebp], xmm0
$LN3@CL_ParseSo:

; 76   : 
; 77   : 	if( FBitSet( flags, SND_ATTENUATION ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN4@CL_ParseSo

; 78   : 		attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0
	jmp	SHORT $LN5@CL_ParseSo
$LN4@CL_ParseSo:

; 79   : 	else attn = ATTN_NONE;	

	xorps	xmm0, xmm0
	movss	DWORD PTR _attn$[ebp], xmm0
$LN5@CL_ParseSo:

; 80   : 
; 81   : 	if( FBitSet( flags, SND_PITCH ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 8
	je	SHORT $LN6@CL_ParseSo

; 82   : 		pitch = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _pitch$[ebp], eax
	jmp	SHORT $LN7@CL_ParseSo
$LN6@CL_ParseSo:

; 83   : 	else pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN7@CL_ParseSo:

; 84   : 
; 85   : 	// entity reletive
; 86   : 	entnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS ); 

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _entnum$[ebp], eax

; 87   : 
; 88   : 	// positioned in space
; 89   : 	MSG_ReadVec3Coord( msg, pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 90   : 
; 91   : 	if( FBitSet( flags, SND_SENTENCE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN8@CL_ParseSo

; 92   : 	{
; 93   : 		char	sentenceName[32];
; 94   : 
; 95   : 		if( FBitSet( flags, SND_SEQUENCE ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	je	SHORT $LN10@CL_ParseSo

; 96   : 			Q_snprintf( sentenceName, sizeof( sentenceName ), "!#%i", sound + MAX_SOUNDS );

	mov	edx, DWORD PTR _sound$[ebp]
	add	edx, 2048				; 00000800H
	push	edx
	push	OFFSET $SG144585
	push	32					; 00000020H
	lea	eax, DWORD PTR _sentenceName$1[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@CL_ParseSo
$LN10@CL_ParseSo:

; 97   : 		else Q_snprintf( sentenceName, sizeof( sentenceName ), "!%i", sound );

	mov	ecx, DWORD PTR _sound$[ebp]
	push	ecx
	push	OFFSET $SG144586
	push	32					; 00000020H
	lea	edx, DWORD PTR _sentenceName$1[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN11@CL_ParseSo:

; 98   : 
; 99   : 		handle = S_RegisterSound( sentenceName );

	lea	eax, DWORD PTR _sentenceName$1[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$[ebp], eax

; 100  : 	}

	jmp	SHORT $LN9@CL_ParseSo
$LN8@CL_ParseSo:

; 101  : 	else handle = cl.sound_index[sound];	// see precached sound

	mov	ecx, DWORD PTR _sound$[ebp]
	movsx	edx, WORD PTR _cl[ecx*2+2681456]
	mov	DWORD PTR _handle$[ebp], edx
$LN9@CL_ParseSo:

; 102  : 
; 103  : 	if( !cl.audio_prepped )

	cmp	DWORD PTR _cl+20, 0
	jne	SHORT $LN12@CL_ParseSo

; 104  : 		return; // too early

	jmp	SHORT $LN14@CL_ParseSo
$LN12@CL_ParseSo:

; 105  : 
; 106  : 	// g-cont. sound and ambient sound have only difference with channel
; 107  : 	if( chan == CHAN_STATIC )

	cmp	DWORD PTR _chan$[ebp], 6
	jne	SHORT $LN13@CL_ParseSo

; 108  : 	{
; 109  : 		S_AmbientSound( pos, entnum, handle, volume, attn, pitch, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_S_AmbientSound
	add	esp, 28					; 0000001cH

; 110  : 	}

	jmp	SHORT $LN14@CL_ParseSo
$LN13@CL_ParseSo:

; 111  : 	else
; 112  : 	{
; 113  : 		S_StartSound( pos, entnum, chan, handle, volume, attn, pitch, flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN14@CL_ParseSo:

; 114  : 	}
; 115  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSoundPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_iSize$ = 12						; size = 4
_pbuf$ = 16						; size = 4
_CL_UserMsgStub PROC

; 36   : {

	push	ebp
	mov	ebp, esp

; 37   : 	return 1;

	mov	eax, 1

; 38   : }

	pop	ebp
	ret	0
_CL_UserMsgStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_view$ = -4						; size = 4
_iAnim$ = 8						; size = 4
_body$ = 12						; size = 4
_CL_WeaponAnim PROC

; 364  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 365  : 	cl_entity_t	*view = &clgame.viewent;

	mov	DWORD PTR _view$[ebp], OFFSET _clgame+149800

; 366  : 
; 367  : 	cl.local.weaponstarttime = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+1568600, xmm0

; 368  : 	cl.local.weaponsequence = iAnim;

	mov	eax, DWORD PTR _iAnim$[ebp]
	mov	DWORD PTR _cl+1568596, eax

; 369  : 	view->curstate.framerate = 1.0f;

	mov	ecx, DWORD PTR _view$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+784], xmm0

; 370  : 	view->curstate.body = body;

	mov	edx, DWORD PTR _view$[ebp]
	mov	eax, DWORD PTR _body$[ebp]
	mov	DWORD PTR [edx+788], eax

; 371  : 
; 372  : #if 0	// g-cont. for GlowShell testing
; 373  : 	view->curstate.renderfx = kRenderFxGlowShell;
; 374  : 	view->curstate.rendercolor.r = 255;
; 375  : 	view->curstate.rendercolor.g = 128;
; 376  : 	view->curstate.rendercolor.b = 0;
; 377  : 	view->curstate.renderamt = 150;
; 378  : #endif
; 379  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WeaponAnim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv139 = -16						; size = 8
_dt$ = -8						; size = 8
_msg$ = 8						; size = 4
_CL_ParseServerTime PROC

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 	double	dt;
; 188  : 
; 189  : 	cl.mtime[1] = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl[edx+32], xmm0

; 190  : 	cl.mtime[0] = MSG_ReadFloat( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	mov	ecx, 8
	imul	edx, ecx, 0
	fstp	QWORD PTR _cl[edx+32]

; 191  : 
; 192  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	SHORT $LN2@CL_ParseSe

; 193  : 		return; // don't mess the time

	jmp	$LN7@CL_ParseSe
$LN2@CL_ParseSe:

; 194  : 
; 195  : 	if( cl.maxclients == 1 )

	cmp	DWORD PTR _cl+1568832, 1
	jne	SHORT $LN3@CL_ParseSe

; 196  : 		cl.time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl+1525848, xmm0
$LN3@CL_ParseSe:

; 197  : 
; 198  : 	dt = cl.time - cl.mtime[0];

	mov	edx, 8
	imul	eax, edx, 0
	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR _cl[eax+32]
	movsd	QWORD PTR _dt$[ebp], xmm0

; 199  : 
; 200  : 	if( fabs( dt ) > cl_clockreset->value )	// 0.1 by default

	sub	esp, 8
	movsd	xmm0, QWORD PTR _dt$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv139[ebp]
	movsd	xmm0, QWORD PTR tv139[ebp]
	mov	ecx, DWORD PTR _cl_clockreset
	cvtss2sd xmm1, DWORD PTR [ecx+12]
	comisd	xmm0, xmm1
	jbe	SHORT $LN4@CL_ParseSe

; 201  : 	{
; 202  : 		cl.time = cl.mtime[0];

	mov	edx, 8
	imul	eax, edx, 0
	movsd	xmm0, QWORD PTR _cl[eax+32]
	movsd	QWORD PTR _cl+1525848, xmm0

; 203  : 		cl.timedelta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+1525864, xmm0

; 204  : 	}

	jmp	SHORT $LN6@CL_ParseSe
$LN4@CL_ParseSe:

; 205  : 	else if( dt != 0.0 )

	movsd	xmm0, QWORD PTR _dt$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_ParseSe

; 206  : 	{
; 207  : 		cl.timedelta = dt;

	cvtsd2ss xmm0, QWORD PTR _dt$[ebp]
	movss	DWORD PTR _cl+1525864, xmm0
$LN6@CL_ParseSe:

; 208  : 	}
; 209  : 
; 210  : 	if( cl.oldtime > cl.time )

	movsd	xmm0, QWORD PTR _cl+1525856
	comisd	xmm0, QWORD PTR _cl+1525848
	jbe	SHORT $LN7@CL_ParseSe

; 211  : 		cl.oldtime = cl.time;

	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR _cl+1525856, xmm0
$LN7@CL_ParseSe:

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseServerTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv71 = -8						; size = 4
tv70 = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseViewEntity PROC

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 48   : 	cl.viewentity = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _cl+1568608, eax

; 49   : 
; 50   : 	// check entity bounds in case we want
; 51   : 	// to use this directly in clgame.entities[] array
; 52   : 	cl.viewentity = bound( 0, cl.viewentity, clgame.maxEntities - 1 );

	cmp	DWORD PTR _cl+1568608, 0
	jl	SHORT $LN5@CL_ParseVi
	mov	ecx, DWORD PTR _clgame+1012
	sub	ecx, 1
	cmp	DWORD PTR _cl+1568608, ecx
	jge	SHORT $LN3@CL_ParseVi
	mov	edx, DWORD PTR _cl+1568608
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN4@CL_ParseVi
$LN3@CL_ParseVi:
	mov	eax, DWORD PTR _clgame+1012
	sub	eax, 1
	mov	DWORD PTR tv70[ebp], eax
$LN4@CL_ParseVi:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN6@CL_ParseVi
$LN5@CL_ParseVi:
	mov	DWORD PTR tv71[ebp], 0
$LN6@CL_ParseVi:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _cl+1568608, edx

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseViewEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mod$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_RegisterResources PROC

; 1474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1475 : 	model_t	*mod;
; 1476 : 	int	i;
; 1477 : 
; 1478 : 	if( cls.dl.custom || cls.signon == SIGNONS && cls.state == ca_active )

	cmp	DWORD PTR _cls+293460, 0
	jne	SHORT $LN6@CL_Registe
	cmp	DWORD PTR _cls+64, 2
	jne	SHORT $LN5@CL_Registe
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN5@CL_Registe
$LN6@CL_Registe:

; 1479 : 	{
; 1480 : 		cls.dl.custom = false;

	mov	DWORD PTR _cls+293460, 0

; 1481 : 		return;

	jmp	$LN9@CL_Registe
$LN5@CL_Registe:

; 1482 : 	}
; 1483 : 
; 1484 : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN7@CL_Registe

; 1485 : 		CL_SendConsistencyInfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_SendConsistencyInfo
	add	esp, 4
$LN7@CL_Registe:

; 1486 : 
; 1487 : 	// All done precaching.
; 1488 : 	cl.worldmodel = CL_ModelHandle( 1 ); // get world pointer

	push	1
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _cl+2686576, eax

; 1489 : 
; 1490 : 	if( cl.worldmodel && cl.maxclients > 0 )

	cmp	DWORD PTR _cl+2686576, 0
	je	$LN8@CL_Registe
	cmp	DWORD PTR _cl+1568832, 0
	jle	$LN8@CL_Registe

; 1491 : 	{
; 1492 : 		ASSERT( clgame.entities != NULL );

	cmp	DWORD PTR _clgame+1000, 0
	jne	SHORT $LN10@CL_Registe
	push	1492					; 000005d4H
	push	OFFSET $SG145163
	push	OFFSET $SG145164
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN10@CL_Registe:

; 1493 : 		clgame.entities->model = cl.worldmodel;

	mov	ecx, DWORD PTR _clgame+1000
	mov	edx, DWORD PTR _cl+2686576
	mov	DWORD PTR [ecx+2964], edx

; 1494 : 
; 1495 : 		if( !cl.video_prepped && !cl.audio_prepped )

	cmp	DWORD PTR _cl+16, 0
	jne	$LN11@CL_Registe
	cmp	DWORD PTR _cl+20, 0
	jne	$LN11@CL_Registe

; 1496 : 		{
; 1497 : 			Con_Printf( "Setting up renderer...\n" );

	push	OFFSET $SG145166
	call	_Con_Printf
	add	esp, 4

; 1498 : 
; 1499 : 			// load tempent sprites (glowshell, muzzleflashes etc)
; 1500 : 			CL_LoadClientSprites ();

	call	_CL_LoadClientSprites

; 1501 : 
; 1502 : 			// invalidate all decal indexes
; 1503 : 			memset( cl.decal_index, 0, sizeof( cl.decal_index ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _cl+2685552
	call	_memset
	add	esp, 12					; 0000000cH

; 1504 : 			cl.video_prepped = true;

	mov	DWORD PTR _cl+16, 1

; 1505 : 			cl.audio_prepped = true;

	mov	DWORD PTR _cl+20, 1

; 1506 : 
; 1507 : 			CL_ClearWorld ();

	call	_CL_ClearWorld

; 1508 : 
; 1509 : 			// tell rendering system we have a new set of models.
; 1510 : 			R_NewMap ();

	call	_R_NewMap

; 1511 : 
; 1512 : 			CL_SetupOverviewParams();

	call	_CL_SetupOverviewParams

; 1513 : 
; 1514 : 			if( clgame.drawFuncs.R_NewMap != NULL )

	cmp	DWORD PTR _clgame+216, 0
	je	SHORT $LN12@CL_Registe

; 1515 : 				clgame.drawFuncs.R_NewMap();

	call	DWORD PTR _clgame+216
$LN12@CL_Registe:

; 1516 : 
; 1517 : 			// release unused SpriteTextures
; 1518 : 			for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+22288
	jmp	SHORT $LN4@CL_Registe
$LN2@CL_Registe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@CL_Registe:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@CL_Registe

; 1519 : 			{
; 1520 : 				if( mod->needload == NL_UNREFERENCED && COM_CheckString( mod->name ))

	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	SHORT $LN13@CL_Registe
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@CL_Registe

; 1521 : 					Mod_UnloadSpriteModel( mod );

	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_UnloadSpriteModel
	add	esp, 4
$LN13@CL_Registe:

; 1522 : 			}

	jmp	SHORT $LN2@CL_Registe
$LN3@CL_Registe:

; 1523 : 
; 1524 : 			Mod_FreeUnused ();

	call	_Mod_FreeUnused

; 1525 : 
; 1526 : 			if( host_developer.value <= DEV_NONE )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _host_developer+12
	jb	SHORT $LN14@CL_Registe

; 1527 : 				Con_ClearNotify(); // clear any lines of console text

	call	_Con_ClearNotify
$LN14@CL_Registe:

; 1528 : 
; 1529 : 			// done with all resources, issue prespawn command.
; 1530 : 			// Include server count in case server disconnects and changes level during d/l
; 1531 : 			MSG_BeginClientCmd( msg, clc_stringcmd );

	push	0
	push	0
	push	3
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1532 : 			MSG_WriteString( msg, va( "spawn %i", cl.servercount ));

	mov	eax, DWORD PTR _cl
	push	eax
	push	OFFSET $SG145170
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8
$LN11@CL_Registe:

; 1533 : 		}
; 1534 : 	}

	jmp	SHORT $LN9@CL_Registe
$LN8@CL_Registe:

; 1535 : 	else
; 1536 : 	{
; 1537 : 		Con_Printf( S_ERROR "client world model is NULL\n" );

	push	OFFSET $SG145171
	call	_Con_Printf
	add	esp, 4

; 1538 : 		CL_Disconnect();

	call	_CL_Disconnect
$LN9@CL_Registe:

; 1539 : 	}
; 1540 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_p$ = -4						; size = 4
_CL_RequestMissingResources PROC

; 434  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 435  : 	resource_t	*p;
; 436  : 
; 437  : 	if( !cls.dl.doneregistering && ( cls.dl.custom || cls.state == ca_validate ))

	cmp	DWORD PTR _cls+293332, 0
	jne	SHORT $LN2@CL_Request
	cmp	DWORD PTR _cls+293460, 0
	jne	SHORT $LN3@CL_Request
	cmp	DWORD PTR _cls, 3
	jne	SHORT $LN2@CL_Request
$LN3@CL_Request:

; 438  : 	{
; 439  : 		p = cl.resourcesneeded.pNext;

	mov	eax, DWORD PTR _cl+1985124
	mov	DWORD PTR _p$[ebp], eax

; 440  : 
; 441  : 		if( p == &cl.resourcesneeded )

	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	jne	SHORT $LN4@CL_Request

; 442  : 		{
; 443  : 			cls.dl.doneregistering = true;

	mov	DWORD PTR _cls+293332, 1

; 444  : 			host.downloadcount = 0;

	mov	DWORD PTR _host+752, 0

; 445  : 			cls.dl.custom = false;

	mov	DWORD PTR _cls+293460, 0

; 446  : 		}

	jmp	SHORT $LN2@CL_Request
$LN4@CL_Request:

; 447  : 		else if( !FBitSet( p->ucFlags, RES_WASMISSING ))

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	and	edx, 2
	jne	SHORT $LN2@CL_Request

; 448  : 		{
; 449  : 			CL_MoveToOnHandList( cl.resourcesneeded.pNext );

	mov	eax, DWORD PTR _cl+1985124
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 450  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_Request
$LN2@CL_Request:

; 451  : 		}
; 452  : 	}
; 453  : 	return false;

	xor	eax, eax
$LN1@CL_Request:

; 454  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RequestMissingResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_iSize$ = 12						; size = 4
_pbuf$ = 16						; size = 4
_CL_DispatchUserMessage PROC

; 1860 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1861 : 	int	i;
; 1862 : 
; 1863 : 	if( !COM_CheckString( pszName ))

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_Dispatc

; 1864 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Dispatc
$LN5@CL_Dispatc:

; 1865 : 
; 1866 : 	for( i = 0; i < MAX_USER_MESSAGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_Dispatc
$LN2@CL_Dispatc:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_Dispatc:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@CL_Dispatc

; 1867 : 	{
; 1868 : 		// search for user message
; 1869 : 		if( !Q_strcmp( clgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _pszName$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _clgame+1332
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_Dispatc

; 1870 : 			break;

	jmp	SHORT $LN3@CL_Dispatc
$LN6@CL_Dispatc:

; 1871 : 	}

	jmp	SHORT $LN2@CL_Dispatc
$LN3@CL_Dispatc:

; 1872 : 
; 1873 : 	if( i == MAX_USER_MESSAGES )

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN7@CL_Dispatc

; 1874 : 	{
; 1875 : 		Con_DPrintf( S_ERROR "UserMsg: bad message %s\n", pszName );

	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	push	OFFSET $SG145319
	call	_Con_DPrintf
	add	esp, 8

; 1876 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_Dispatc
$LN7@CL_Dispatc:

; 1877 : 	}
; 1878 : 
; 1879 : 	if( clgame.msg[i].func )

	imul	edx, DWORD PTR _i$[ebp], 44
	cmp	DWORD PTR _clgame[edx+1372], 0
	je	SHORT $LN8@CL_Dispatc

; 1880 : 	{
; 1881 : 		clgame.msg[i].func( pszName, iSize, pbuf );

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszName$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1372]
	call	ecx
	add	esp, 12					; 0000000cH

; 1882 : 	}

	jmp	SHORT $LN9@CL_Dispatc
$LN8@CL_Dispatc:

; 1883 : 	else
; 1884 : 	{
; 1885 : 		Con_DPrintf( S_ERROR "UserMsg: No pfn %s %d\n", clgame.msg[i].name, clgame.msg[i].number );

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _clgame[edx+1364]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1332
	push	ecx
	push	OFFSET $SG145322
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1886 : 		clgame.msg[i].func = CL_UserMsgStub; // throw warning only once

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _clgame[edx+1372], OFFSET _CL_UserMsgStub
$LN9@CL_Dispatc:

; 1887 : 	}
; 1888 : 	return true;

	mov	eax, 1
$LN1@CL_Dispatc:

; 1889 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DispatchUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv79 = -40						; size = 4
_ri$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pszMessage$ = 8					; size = 4
_bCustom$ = 12						; size = 4
_CL_StartResourceDownloading PROC

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 597  : 	resourceinfo_t	ri;
; 598  : 
; 599  : 	if( COM_CheckString( pszMessage ))

	mov	eax, DWORD PTR _pszMessage$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_StartRe

; 600  : 		Con_DPrintf( "%s", pszMessage );

	mov	ecx, DWORD PTR _pszMessage$[ebp]
	push	ecx
	push	OFFSET $SG144789
	call	_Con_DPrintf
	add	esp, 8
$LN2@CL_StartRe:

; 601  : 
; 602  : 	cls.dl.nTotalSize = COM_SizeofResourceList( &cl.resourcesneeded, &ri );

	lea	edx, DWORD PTR _ri$[ebp]
	push	edx
	push	OFFSET _cl+1984996
	call	_COM_SizeofResourceList
	add	esp, 8
	mov	DWORD PTR _cls+293444, eax

; 603  : 	cls.dl.nTotalToTransfer = CL_EstimateNeededResources();

	call	_CL_EstimateNeededResources
	mov	DWORD PTR _cls+293448, eax

; 604  : 
; 605  : 	if( bCustom )

	cmp	DWORD PTR _bCustom$[ebp], 0
	je	SHORT $LN3@CL_StartRe

; 606  : 	{
; 607  : 		cls.dl.custom = true;

	mov	DWORD PTR _cls+293460, 1

; 608  : 	}

	jmp	SHORT $LN4@CL_StartRe
$LN3@CL_StartRe:

; 609  : 	else
; 610  : 	{
; 611  : 		cls.state = ca_validate;

	mov	DWORD PTR _cls, 3

; 612  : 		cls.dl.custom = false;

	mov	DWORD PTR _cls+293460, 0
$LN4@CL_StartRe:

; 613  : 	}
; 614  : 
; 615  : 	cls.dl.doneregistering = false;

	mov	DWORD PTR _cls+293332, 0

; 616  : 	cls.dl.fLastStatusUpdate = host.realtime;

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+293456, xmm0

; 617  : 	cls.dl.nRemainingToTransfer = cls.dl.nTotalToTransfer;

	mov	eax, DWORD PTR _cls+293448
	mov	DWORD PTR _cls+293452, eax

; 618  : 	memset( cls.dl.rgStats, 0, sizeof( cls.dl.rgStats ));

	push	96					; 00000060H
	push	0
	push	OFFSET _cls+293344
	call	_memset
	add	esp, 12					; 0000000cH

; 619  : 	cls.dl.nCurStat = 0;

	mov	DWORD PTR _cls+293440, 0

; 620  : 
; 621  : 	CL_BatchResourceRequest( !bCustom );

	cmp	DWORD PTR _bCustom$[ebp], 0
	jne	SHORT $LN6@CL_StartRe
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN7@CL_StartRe
$LN6@CL_StartRe:
	mov	DWORD PTR tv79[ebp], 0
$LN7@CL_StartRe:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	call	_CL_BatchResourceRequest
	add	esp, 4

; 622  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_StartResourceDownloading ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_old_background$ = -56					; size = 4
tv306 = -52						; size = 4
tv305 = -48						; size = 4
tv300 = -44						; size = 4
tv299 = -40						; size = 4
tv254 = -36						; size = 4
_s$ = -32						; size = 4
tv156 = -28						; size = 4
tv131 = -24						; size = 4
_cmd$ = -20						; size = 4
_playerbytes$ = -16					; size = 4
_param2$ = -12						; size = 4
_param1$ = -8						; size = 4
_bufStart$ = -4						; size = 4
_msg$ = 8						; size = 4
_normal_message$ = 12					; size = 4
_CL_ParseServerMessage PROC

; 1977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi

; 1978 : 	size_t		bufStart, playerbytes;
; 1979 : 	int		cmd, param1, param2;
; 1980 : 	int		old_background;
; 1981 : 	const char	*s;
; 1982 : 
; 1983 : 	cls.starting_count = MSG_GetNumBytesRead( msg );	// updates each frame

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _cls+287336, eax

; 1984 : 	CL_Parse_Debug( true );			// begin parsing

	push	1
	call	_CL_Parse_Debug
	add	esp, 4

; 1985 : 
; 1986 : 	if( normal_message )

	cmp	DWORD PTR _normal_message$[ebp], 0
	je	SHORT $LN8@CL_ParseSe

; 1987 : 	{
; 1988 : 		// assume no entity/player update this packet
; 1989 : 		if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN7@CL_ParseSe

; 1990 : 		{
; 1991 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].valid = false;   

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _cls+23584
	imul	edx, ecx, 17304
	mov	DWORD PTR _cl[edx+112], 0

; 1992 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].choked = false;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23584
	imul	ecx, eax, 17304
	mov	DWORD PTR _cl[ecx+116], 0

; 1993 : 		}

	jmp	SHORT $LN8@CL_ParseSe
$LN7@CL_ParseSe:

; 1994 : 		else
; 1995 : 		{
; 1996 : 			CL_ResetFrame( &cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK] );

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _cls+23584
	imul	eax, edx, 17304
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_ResetFrame
	add	esp, 4
$LN8@CL_ParseSe:

; 1997 : 		}
; 1998 : 	}
; 1999 : 	
; 2000 : 	// parse the message
; 2001 : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@CL_ParseSe

; 2002 : 	{
; 2003 : 		if( MSG_CheckOverflow( msg ))

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@CL_ParseSe

; 2004 : 		{
; 2005 : 			Host_Error( "CL_ParseServerMessage: overflow!\n" );

	push	OFFSET $SG145375
	call	_Host_Error
	add	esp, 4

; 2006 : 			return;

	jmp	$LN77@CL_ParseSe
$LN9@CL_ParseSe:

; 2007 : 		}
; 2008 : 
; 2009 : 		// mark start position
; 2010 : 		bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 2011 : 
; 2012 : 		// end of message (align bits)
; 2013 : 		if( MSG_GetNumBitsLeft( msg ) < 8 )

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN10@CL_ParseSe

; 2014 : 			break;		

	jmp	$LN3@CL_ParseSe
$LN10@CL_ParseSe:

; 2015 : 
; 2016 : 		cmd = MSG_ReadServerCmd( msg );

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCmd
	add	esp, 8
	mov	DWORD PTR _cmd$[ebp], eax

; 2017 : 
; 2018 : 		// record command for debugging spew on parse problem
; 2019 : 		CL_Parse_RecordCommand( cmd, bufStart );

	mov	eax, DWORD PTR _bufStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_CL_Parse_RecordCommand
	add	esp, 8

; 2020 : 
; 2021 : 		// other commands
; 2022 : 		switch( cmd )

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR tv131[ebp], edx
	cmp	DWORD PTR tv131[ebp], 58		; 0000003aH
	ja	$LN73@CL_ParseSe
	mov	eax, DWORD PTR tv131[ebp]
	jmp	DWORD PTR $LN91@CL_ParseSe[eax*4]
$LN11@CL_ParseSe:

; 2023 : 		{
; 2024 : 		case svc_bad:
; 2025 : 			Host_Error( "svc_bad\n" );

	push	OFFSET $SG145378
	call	_Host_Error
	add	esp, 4

; 2026 : 			break;

	jmp	$LN4@CL_ParseSe
$LN12@CL_ParseSe:

; 2027 : 		case svc_nop:
; 2028 : 			// this does nothing
; 2029 : 			break;

	jmp	$LN4@CL_ParseSe
$LN13@CL_ParseSe:

; 2030 : 		case svc_disconnect:
; 2031 : 			CL_Drop ();

	call	_CL_Drop

; 2032 : 			Host_AbortCurrentFrame ();

	call	_Host_AbortCurrentFrame

; 2033 : 			break;

	jmp	$LN4@CL_ParseSe
$LN14@CL_ParseSe:

; 2034 : 		case svc_event:
; 2035 : 			CL_ParseEvent( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseEvent
	add	esp, 4

; 2036 : 			cl.frames[cl.parsecountmod].graphdata.event += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17118]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17118], cx

; 2037 : 			break;

	jmp	$LN4@CL_ParseSe
$LN15@CL_ParseSe:

; 2038 : 		case svc_changing:
; 2039 : 			old_background = cl.background;

	mov	eax, DWORD PTR _cl+64
	mov	DWORD PTR _old_background$[ebp], eax

; 2040 : 			if( MSG_ReadOneBit( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@CL_ParseSe

; 2041 : 			{
; 2042 : 				cls.changelevel = true;

	mov	DWORD PTR _cls+8, 1

; 2043 : 				S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 2044 : 
; 2045 : 				Con_Printf( "Server changing, reconnecting\n" );

	push	OFFSET $SG145385
	call	_Con_Printf
	add	esp, 4

; 2046 : 
; 2047 : 				if( cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN18@CL_ParseSe

; 2048 : 				{
; 2049 : 					SCR_BeginLoadingPlaque( cl.background );

	mov	edx, DWORD PTR _cl+64
	push	edx
	call	_SCR_BeginLoadingPlaque
	add	esp, 4

; 2050 : 					cls.changedemo = true;

	mov	DWORD PTR _cls+12, 1
$LN18@CL_ParseSe:

; 2051 : 				}
; 2052 : 
; 2053 : 				CL_ClearState ();

	call	_CL_ClearState

; 2054 : 				CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts

; 2055 : 			}

	jmp	SHORT $LN17@CL_ParseSe
$LN16@CL_ParseSe:

; 2056 : 			else Con_Printf( "Server disconnected, reconnecting\n" );

	push	OFFSET $SG145387
	call	_Con_Printf
	add	esp, 4
$LN17@CL_ParseSe:

; 2057 : 
; 2058 : 			if( cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN19@CL_ParseSe

; 2059 : 			{
; 2060 : 				cl.background = (cls.demonum != -1) ? true : false;

	cmp	DWORD PTR _cls+293464, -1
	je	SHORT $LN79@CL_ParseSe
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN80@CL_ParseSe
$LN79@CL_ParseSe:
	mov	DWORD PTR tv156[ebp], 0
$LN80@CL_ParseSe:
	mov	eax, DWORD PTR tv156[ebp]
	mov	DWORD PTR _cl+64, eax

; 2061 : 				cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 2062 : 			}

	jmp	SHORT $LN20@CL_ParseSe
$LN19@CL_ParseSe:

; 2063 : 			else
; 2064 : 			{
; 2065 : 				// g-cont. local client skip the challenge
; 2066 : 				if( SV_Active( ))

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN21@CL_ParseSe

; 2067 : 					cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0
	jmp	SHORT $LN22@CL_ParseSe
$LN21@CL_ParseSe:

; 2068 : 				else cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1
$LN22@CL_ParseSe:

; 2069 : 				cl.background = old_background;

	mov	ecx, DWORD PTR _old_background$[ebp]
	mov	DWORD PTR _cl+64, ecx

; 2070 : 				cls.connect_time = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0
$LN20@CL_ParseSe:

; 2071 : 			}
; 2072 : 			break;

	jmp	$LN4@CL_ParseSe
$LN23@CL_ParseSe:

; 2073 : 		case svc_setview:
; 2074 : 			CL_ParseViewEntity( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseViewEntity
	add	esp, 4

; 2075 : 			break;

	jmp	$LN4@CL_ParseSe
$LN24@CL_ParseSe:

; 2076 : 		case svc_sound:
; 2077 : 			CL_ParseSoundPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseSoundPacket
	add	esp, 4

; 2078 : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	edx, WORD PTR _cl[esi+17116]
	add	edx, eax
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17116], dx

; 2079 : 			break;

	jmp	$LN4@CL_ParseSe
$LN25@CL_ParseSe:

; 2080 : 		case svc_time:
; 2081 : 			CL_ParseServerTime( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseServerTime
	add	esp, 4

; 2082 : 			break;

	jmp	$LN4@CL_ParseSe
$LN26@CL_ParseSe:

; 2083 : 		case svc_print:
; 2084 : 			Con_Printf( "%s", MSG_ReadString( msg ));

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET $SG145396
	call	_Con_Printf
	add	esp, 8

; 2085 : 			break;

	jmp	$LN4@CL_ParseSe
$LN27@CL_ParseSe:

; 2086 : 		case svc_stufftext:
; 2087 : 			s = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 2088 : #ifdef HACKS_RELATED_HLMODS
; 2089 : 			// dsiable Cry Of Fear antisave protection
; 2090 : 			if( !Q_strnicmp( s, "disconnect", 10 ) && cls.signon != SIGNONS )

	push	10					; 0000000aH
	push	OFFSET $SG145399
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@CL_ParseSe
	cmp	DWORD PTR _cls+64, 2
	je	SHORT $LN28@CL_ParseSe

; 2091 : 				break; // too early

	jmp	$LN4@CL_ParseSe
$LN28@CL_ParseSe:

; 2092 : #endif
; 2093 : 			Cbuf_AddText( s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Cbuf_AddText
	add	esp, 4

; 2094 : 			break;

	jmp	$LN4@CL_ParseSe
$LN29@CL_ParseSe:

; 2095 : 		case svc_setangle:
; 2096 : 			CL_ParseSetAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseSetAngle
	add	esp, 4

; 2097 : 			break;

	jmp	$LN4@CL_ParseSe
$LN30@CL_ParseSe:

; 2098 : 		case svc_serverdata:
; 2099 : 			Cbuf_Execute(); // make sure any stuffed commands are done

	call	_Cbuf_Execute

; 2100 : 			CL_ParseServerData( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseServerData
	add	esp, 4

; 2101 : 			break;

	jmp	$LN4@CL_ParseSe
$LN31@CL_ParseSe:

; 2102 : 		case svc_lightstyle:
; 2103 : 			CL_ParseLightStyle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseLightStyle
	add	esp, 4

; 2104 : 			break;

	jmp	$LN4@CL_ParseSe
$LN32@CL_ParseSe:

; 2105 : 		case svc_updateuserinfo:
; 2106 : 			CL_UpdateUserinfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateUserinfo
	add	esp, 4

; 2107 : 			break;

	jmp	$LN4@CL_ParseSe
$LN33@CL_ParseSe:

; 2108 : 		case svc_deltatable:
; 2109 : 			Delta_ParseTableField( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_Delta_ParseTableField
	add	esp, 4

; 2110 : 			break;

	jmp	$LN4@CL_ParseSe
$LN34@CL_ParseSe:

; 2111 : 		case svc_clientdata:
; 2112 : 			CL_ParseClientData( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseClientData
	add	esp, 4

; 2113 : 			cl.frames[cl.parsecountmod].graphdata.client += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17108]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17108], cx

; 2114 : 			break;

	jmp	$LN4@CL_ParseSe
$LN35@CL_ParseSe:

; 2115 : 		case svc_resource:
; 2116 : 			CL_ParseResource( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseResource
	add	esp, 4

; 2117 : 			break;

	jmp	$LN4@CL_ParseSe
$LN36@CL_ParseSe:

; 2118 : 		case svc_pings:
; 2119 : 			CL_UpdateUserPings( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_UpdateUserPings
	add	esp, 4

; 2120 : 			break;

	jmp	$LN4@CL_ParseSe
$LN37@CL_ParseSe:

; 2121 : 		case svc_particle:
; 2122 : 			CL_ParseParticles( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseParticles
	add	esp, 4

; 2123 : 			break;

	jmp	$LN4@CL_ParseSe
$LN38@CL_ParseSe:

; 2124 : 		case svc_restoresound:
; 2125 : 			CL_ParseRestoreSoundPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseRestoreSoundPacket
	add	esp, 4

; 2126 : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	edx, WORD PTR _cl[esi+17116]
	add	edx, eax
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17116], dx

; 2127 : 			break;

	jmp	$LN4@CL_ParseSe
$LN39@CL_ParseSe:

; 2128 : 		case svc_spawnstatic:
; 2129 : 			CL_ParseStaticEntity( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseStaticEntity
	add	esp, 4

; 2130 : 			break;

	jmp	$LN4@CL_ParseSe
$LN40@CL_ParseSe:

; 2131 : 		case svc_event_reliable:
; 2132 : 			CL_ParseReliableEvent( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseReliableEvent
	add	esp, 4

; 2133 : 			cl.frames[cl.parsecountmod].graphdata.event += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17118]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17118], cx

; 2134 : 			break;

	jmp	$LN4@CL_ParseSe
$LN41@CL_ParseSe:

; 2135 : 		case svc_spawnbaseline:
; 2136 : 			CL_ParseBaseline( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseBaseline
	add	esp, 4

; 2137 : 			break;

	jmp	$LN4@CL_ParseSe
$LN42@CL_ParseSe:

; 2138 : 		case svc_temp_entity:
; 2139 : 			CL_ParseTempEntity( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseTempEntity
	add	esp, 4

; 2140 : 			cl.frames[cl.parsecountmod].graphdata.tentities += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17114]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17114], cx

; 2141 : 			break;

	jmp	$LN4@CL_ParseSe
$LN43@CL_ParseSe:

; 2142 : 		case svc_setpause:
; 2143 : 			cl.paused = ( MSG_ReadOneBit( msg ) != 0 );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN81@CL_ParseSe
	mov	DWORD PTR tv254[ebp], 1
	jmp	SHORT $LN82@CL_ParseSe
$LN81@CL_ParseSe:
	mov	DWORD PTR tv254[ebp], 0
$LN82@CL_ParseSe:
	mov	ecx, DWORD PTR tv254[ebp]
	mov	DWORD PTR _cl+24, ecx

; 2144 : 			break;

	jmp	$LN4@CL_ParseSe
$LN44@CL_ParseSe:

; 2145 : 		case svc_signonnum:
; 2146 : 			CL_ParseSignon( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseSignon
	add	esp, 4

; 2147 : 			break;

	jmp	$LN4@CL_ParseSe
$LN45@CL_ParseSe:

; 2148 : 		case svc_centerprint:
; 2149 : 			CL_CenterPrint( MSG_ReadString( msg ), 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_CL_CenterPrint
	add	esp, 8

; 2150 : 			break;

	jmp	$LN4@CL_ParseSe
$LN46@CL_ParseSe:

; 2151 : 		case svc_intermission:
; 2152 : 			cl.intermission = 1;

	mov	DWORD PTR _cl+1568648, 1

; 2153 : 			break;

	jmp	$LN4@CL_ParseSe
$LN47@CL_ParseSe:

; 2154 : 		case svc_finale:
; 2155 : 			CL_ParseFinaleCutscene( msg, 2 );

	push	2
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 2156 : 			break;

	jmp	$LN4@CL_ParseSe
$LN48@CL_ParseSe:

; 2157 : 		case svc_cdtrack:
; 2158 : 			param1 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 2159 : 			param1 = bound( 1, param1, MAX_CDTRACKS ); // tracknum

	cmp	DWORD PTR _param1$[ebp], 1
	jl	SHORT $LN85@CL_ParseSe
	cmp	DWORD PTR _param1$[ebp], 32		; 00000020H
	jge	SHORT $LN83@CL_ParseSe
	mov	eax, DWORD PTR _param1$[ebp]
	mov	DWORD PTR tv299[ebp], eax
	jmp	SHORT $LN84@CL_ParseSe
$LN83@CL_ParseSe:
	mov	DWORD PTR tv299[ebp], 32		; 00000020H
$LN84@CL_ParseSe:
	mov	ecx, DWORD PTR tv299[ebp]
	mov	DWORD PTR tv300[ebp], ecx
	jmp	SHORT $LN86@CL_ParseSe
$LN85@CL_ParseSe:
	mov	DWORD PTR tv300[ebp], 1
$LN86@CL_ParseSe:
	mov	edx, DWORD PTR tv300[ebp]
	mov	DWORD PTR _param1$[ebp], edx

; 2160 : 			param2 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 2161 : 			param2 = bound( 1, param2, MAX_CDTRACKS ); // loopnum

	cmp	DWORD PTR _param2$[ebp], 1
	jl	SHORT $LN89@CL_ParseSe
	cmp	DWORD PTR _param2$[ebp], 32		; 00000020H
	jge	SHORT $LN87@CL_ParseSe
	mov	ecx, DWORD PTR _param2$[ebp]
	mov	DWORD PTR tv305[ebp], ecx
	jmp	SHORT $LN88@CL_ParseSe
$LN87@CL_ParseSe:
	mov	DWORD PTR tv305[ebp], 32		; 00000020H
$LN88@CL_ParseSe:
	mov	edx, DWORD PTR tv305[ebp]
	mov	DWORD PTR tv306[ebp], edx
	jmp	SHORT $LN90@CL_ParseSe
$LN89@CL_ParseSe:
	mov	DWORD PTR tv306[ebp], 1
$LN90@CL_ParseSe:
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR _param2$[ebp], eax

; 2162 : 			S_StartBackgroundTrack( clgame.cdtracks[param1-1], clgame.cdtracks[param2-1], 0, false );

	push	0
	push	0
	mov	ecx, DWORD PTR _param2$[ebp]
	sub	ecx, 1
	shl	ecx, 8
	add	ecx, OFFSET _clgame+14096
	push	ecx
	mov	edx, DWORD PTR _param1$[ebp]
	sub	edx, 1
	shl	edx, 8
	add	edx, OFFSET _clgame+14096
	push	edx
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H

; 2163 : 			break;

	jmp	$LN4@CL_ParseSe
$LN49@CL_ParseSe:

; 2164 : 		case svc_restore:
; 2165 : 			CL_ParseRestore( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseRestore
	add	esp, 4

; 2166 : 			break;

	jmp	$LN4@CL_ParseSe
$LN50@CL_ParseSe:

; 2167 : 		case svc_cutscene:
; 2168 : 			CL_ParseFinaleCutscene( msg, 3 );

	push	3
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 2169 : 			break;

	jmp	$LN4@CL_ParseSe
$LN51@CL_ParseSe:

; 2170 : 		case svc_weaponanim:
; 2171 : 			param1 = MSG_ReadByte( msg );	// iAnim

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 2172 : 			param2 = MSG_ReadByte( msg );	// body

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 2173 : 			CL_WeaponAnim( param1, param2 );

	mov	ecx, DWORD PTR _param2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _param1$[ebp]
	push	edx
	call	_CL_WeaponAnim
	add	esp, 8

; 2174 : 			break;

	jmp	$LN4@CL_ParseSe
$LN52@CL_ParseSe:

; 2175 : 		case svc_bspdecal:
; 2176 : 			CL_ParseStaticDecal( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseStaticDecal
	add	esp, 4

; 2177 : 			break;

	jmp	$LN4@CL_ParseSe
$LN53@CL_ParseSe:

; 2178 : 		case svc_roomtype:
; 2179 : 			param1 = MSG_ReadShort( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 2180 : 			Cvar_SetValue( "room_type", param1 );

	cvtsi2ss xmm0, DWORD PTR _param1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145425
	call	_Cvar_SetValue
	add	esp, 8

; 2181 : 			break;

	jmp	$LN4@CL_ParseSe
$LN54@CL_ParseSe:

; 2182 : 		case svc_addangle:
; 2183 : 			CL_ParseAddAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseAddAngle
	add	esp, 4

; 2184 : 			break;

	jmp	$LN4@CL_ParseSe
$LN55@CL_ParseSe:

; 2185 : 		case svc_usermessage:
; 2186 : 			CL_RegisterUserMessage( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_RegisterUserMessage
	add	esp, 4

; 2187 : 			break;

	jmp	$LN4@CL_ParseSe
$LN56@CL_ParseSe:

; 2188 : 		case svc_packetentities:
; 2189 : 			playerbytes = CL_ParsePacketEntities( msg, false );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParsePacketEntities
	add	esp, 8
	mov	DWORD PTR _playerbytes$[ebp], eax

; 2190 : 			cl.frames[cl.parsecountmod].graphdata.players += playerbytes;

	imul	edx, DWORD PTR _cl+12, 17304
	movzx	eax, WORD PTR _cl[edx+17110]
	add	eax, DWORD PTR _playerbytes$[ebp]
	imul	ecx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[ecx+17110], ax

; 2191 : 			cl.frames[cl.parsecountmod].graphdata.entities += MSG_GetNumBytesRead( msg ) - bufStart - playerbytes;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	sub	eax, DWORD PTR _playerbytes$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17112]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17112], cx

; 2192 : 			break;

	jmp	$LN4@CL_ParseSe
$LN57@CL_ParseSe:

; 2193 : 		case svc_deltapacketentities:
; 2194 : 			playerbytes = CL_ParsePacketEntities( msg, true );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParsePacketEntities
	add	esp, 8
	mov	DWORD PTR _playerbytes$[ebp], eax

; 2195 : 			cl.frames[cl.parsecountmod].graphdata.players += playerbytes;

	imul	ecx, DWORD PTR _cl+12, 17304
	movzx	edx, WORD PTR _cl[ecx+17110]
	add	edx, DWORD PTR _playerbytes$[ebp]
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17110], dx

; 2196 : 			cl.frames[cl.parsecountmod].graphdata.entities += MSG_GetNumBytesRead( msg ) - bufStart - playerbytes;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	sub	eax, DWORD PTR _playerbytes$[ebp]
	movzx	edx, WORD PTR _cl[esi+17112]
	add	edx, eax
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17112], dx

; 2197 : 			break;

	jmp	$LN4@CL_ParseSe
$LN58@CL_ParseSe:

; 2198 : 		case svc_choke:
; 2199 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].choked = true;

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _cls+23584
	imul	edx, ecx, 17304
	mov	DWORD PTR _cl[edx+116], 1

; 2200 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].receivedtime = -2.0;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23584
	imul	ecx, eax, 17304
	movsd	xmm0, QWORD PTR __real@c000000000000000
	movsd	QWORD PTR _cl[ecx+88], xmm0

; 2201 : 			break;

	jmp	$LN4@CL_ParseSe
$LN59@CL_ParseSe:

; 2202 : 		case svc_resourcelist:
; 2203 : 			CL_ParseResourceList( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseResourceList
	add	esp, 4

; 2204 : 			break;

	jmp	$LN4@CL_ParseSe
$LN60@CL_ParseSe:

; 2205 : 		case svc_deltamovevars:
; 2206 : 			CL_ParseMovevars( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseMovevars
	add	esp, 4

; 2207 : 			break;

	jmp	$LN4@CL_ParseSe
$LN61@CL_ParseSe:

; 2208 : 		case svc_resourcerequest:
; 2209 : 			CL_ParseResourceRequest( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseResourceRequest
	add	esp, 4

; 2210 : 			break;

	jmp	$LN4@CL_ParseSe
$LN62@CL_ParseSe:

; 2211 : 		case svc_customization:
; 2212 : 			CL_ParseCustomization( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseCustomization
	add	esp, 4

; 2213 : 			break;

	jmp	$LN4@CL_ParseSe
$LN63@CL_ParseSe:

; 2214 : 		case svc_crosshairangle:
; 2215 : 			CL_ParseCrosshairAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseCrosshairAngle
	add	esp, 4

; 2216 : 			break;

	jmp	$LN4@CL_ParseSe
$LN64@CL_ParseSe:

; 2217 : 		case svc_soundfade:
; 2218 : 			CL_ParseSoundFade( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseSoundFade
	add	esp, 4

; 2219 : 			break;

	jmp	$LN4@CL_ParseSe
$LN65@CL_ParseSe:

; 2220 : 		case svc_filetxferfailed:
; 2221 : 			CL_ParseFileTransferFailed( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseFileTransferFailed
	add	esp, 4

; 2222 : 			break;

	jmp	$LN4@CL_ParseSe
$LN66@CL_ParseSe:

; 2223 : 		case svc_hltv:
; 2224 : 			CL_ParseHLTV( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseHLTV
	add	esp, 4

; 2225 : 			break;

	jmp	$LN4@CL_ParseSe
$LN67@CL_ParseSe:

; 2226 : 		case svc_director:
; 2227 : 			CL_ParseDirector( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseDirector
	add	esp, 4

; 2228 : 			break;

	jmp	$LN4@CL_ParseSe
$LN68@CL_ParseSe:

; 2229 : 		case svc_voiceinit:
; 2230 : 			CL_ParseVoiceInit( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseVoiceInit
	add	esp, 4

; 2231 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN69@CL_ParseSe:

; 2232 : 		case svc_voicedata:
; 2233 : 			CL_ParseVoiceData( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseVoiceData
	add	esp, 4

; 2234 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN70@CL_ParseSe:

; 2235 : 		case svc_resourcelocation:
; 2236 : 			CL_ParseResLocation( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseResLocation
	add	esp, 4

; 2237 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN71@CL_ParseSe:

; 2238 : 		case svc_querycvarvalue:
; 2239 : 			CL_ParseCvarValue( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseCvarValue
	add	esp, 4

; 2240 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN72@CL_ParseSe:

; 2241 : 		case svc_querycvarvalue2:
; 2242 : 			CL_ParseCvarValue2( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseCvarValue2
	add	esp, 4

; 2243 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN73@CL_ParseSe:

; 2244 : 		default:
; 2245 : 			CL_ParseUserMessage( msg, cmd );

	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseUserMessage
	add	esp, 8

; 2246 : 			cl.frames[cl.parsecountmod].graphdata.usr += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17120]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17120], cx
$LN4@CL_ParseSe:

; 2247 : 			break;
; 2248 : 		}
; 2249 : 	}

	jmp	$LN8@CL_ParseSe
$LN3@CL_ParseSe:

; 2250 : 
; 2251 : 	cl.frames[cl.parsecountmod].graphdata.msgbytes += MSG_GetNumBytesRead( msg ) - cls.starting_count;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _cls+287336
	movzx	ecx, WORD PTR _cl[esi+17122]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17122], cx

; 2252 : 	CL_Parse_Debug( false ); // done

	push	0
	call	_CL_Parse_Debug
	add	esp, 4

; 2253 : 
; 2254 : 	// we don't know if it is ok to save a demo message until
; 2255 : 	// after we have parsed the frame
; 2256 : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN77@CL_ParseSe

; 2257 : 	{
; 2258 : 		if( cls.demorecording && !cls.demowaiting )

	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN75@CL_ParseSe
	cmp	DWORD PTR _cls+297584, 0
	jne	SHORT $LN75@CL_ParseSe

; 2259 : 		{
; 2260 : 			CL_WriteDemoMessage( false, cls.starting_count, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+287336
	push	ecx
	push	0
	call	_CL_WriteDemoMessage
	add	esp, 12					; 0000000cH

; 2261 : 		}

	jmp	SHORT $LN77@CL_ParseSe
$LN75@CL_ParseSe:

; 2262 : 		else if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN77@CL_ParseSe

; 2263 : 		{
; 2264 : 			CL_WriteDemoMessage( true, cls.starting_count, msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _cls+287336
	push	eax
	push	1
	call	_CL_WriteDemoMessage
	add	esp, 12					; 0000000cH
$LN77@CL_ParseSe:

; 2265 : 		}
; 2266 : 	}
; 2267 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN91@CL_ParseSe:
	DD	$LN11@CL_ParseSe
	DD	$LN12@CL_ParseSe
	DD	$LN13@CL_ParseSe
	DD	$LN14@CL_ParseSe
	DD	$LN15@CL_ParseSe
	DD	$LN23@CL_ParseSe
	DD	$LN24@CL_ParseSe
	DD	$LN25@CL_ParseSe
	DD	$LN26@CL_ParseSe
	DD	$LN27@CL_ParseSe
	DD	$LN29@CL_ParseSe
	DD	$LN30@CL_ParseSe
	DD	$LN31@CL_ParseSe
	DD	$LN32@CL_ParseSe
	DD	$LN33@CL_ParseSe
	DD	$LN34@CL_ParseSe
	DD	$LN35@CL_ParseSe
	DD	$LN36@CL_ParseSe
	DD	$LN37@CL_ParseSe
	DD	$LN38@CL_ParseSe
	DD	$LN39@CL_ParseSe
	DD	$LN40@CL_ParseSe
	DD	$LN41@CL_ParseSe
	DD	$LN42@CL_ParseSe
	DD	$LN43@CL_ParseSe
	DD	$LN44@CL_ParseSe
	DD	$LN45@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN46@CL_ParseSe
	DD	$LN47@CL_ParseSe
	DD	$LN48@CL_ParseSe
	DD	$LN49@CL_ParseSe
	DD	$LN50@CL_ParseSe
	DD	$LN51@CL_ParseSe
	DD	$LN52@CL_ParseSe
	DD	$LN53@CL_ParseSe
	DD	$LN54@CL_ParseSe
	DD	$LN55@CL_ParseSe
	DD	$LN56@CL_ParseSe
	DD	$LN57@CL_ParseSe
	DD	$LN58@CL_ParseSe
	DD	$LN59@CL_ParseSe
	DD	$LN60@CL_ParseSe
	DD	$LN61@CL_ParseSe
	DD	$LN62@CL_ParseSe
	DD	$LN63@CL_ParseSe
	DD	$LN64@CL_ParseSe
	DD	$LN65@CL_ParseSe
	DD	$LN66@CL_ParseSe
	DD	$LN67@CL_ParseSe
	DD	$LN68@CL_ParseSe
	DD	$LN69@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN70@CL_ParseSe
	DD	$LN71@CL_ParseSe
	DD	$LN72@CL_ParseSe
_CL_ParseServerMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 853  : {

	push	ebp
	mov	ebp, esp

; 854  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1012
	jge	SHORT $LN2@CL_EDICT_N

; 855  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3000
	add	eax, DWORD PTR _clgame+1000
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 856  : 
; 857  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 858  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 859  : }

	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_iSize$ = -2060						; size = 4
_i$ = -2056						; size = 4
_pbuf$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_svc_num$ = 12						; size = 4
_CL_ParseUserMessage PROC

; 1899 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2060				; 0000080cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1900 : 	byte	pbuf[MAX_USERMSG_LENGTH];
; 1901 : 	int	i, iSize;
; 1902 : 
; 1903 : 	// NOTE: any user message is really parse at engine, not in client.dll
; 1904 : 	if( svc_num <= svc_lastmsg || svc_num > ( MAX_USER_MESSAGES + svc_lastmsg ))

	cmp	DWORD PTR _svc_num$[ebp], 58		; 0000003aH
	jle	SHORT $LN6@CL_ParseUs
	cmp	DWORD PTR _svc_num$[ebp], 255		; 000000ffH
	jle	SHORT $LN5@CL_ParseUs
$LN6@CL_ParseUs:

; 1905 : 	{
; 1906 : 		// out or range
; 1907 : 		Host_Error( "CL_ParseUserMessage: illegible server message %d\n", svc_num );

	mov	eax, DWORD PTR _svc_num$[ebp]
	push	eax
	push	OFFSET $SG145337
	call	_Host_Error
	add	esp, 8

; 1908 : 		return;

	jmp	$LN1@CL_ParseUs
$LN5@CL_ParseUs:

; 1909 : 	}
; 1910 : 
; 1911 : 	for( i = 0; i < MAX_USER_MESSAGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseUs
$LN2@CL_ParseUs:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_ParseUs:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@CL_ParseUs

; 1912 : 	{
; 1913 : 		// search for user message
; 1914 : 		if( clgame.msg[i].number == svc_num )

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _clgame[edx+1364]
	cmp	eax, DWORD PTR _svc_num$[ebp]
	jne	SHORT $LN7@CL_ParseUs

; 1915 : 			break;

	jmp	SHORT $LN3@CL_ParseUs
$LN7@CL_ParseUs:

; 1916 : 	}

	jmp	SHORT $LN2@CL_ParseUs
$LN3@CL_ParseUs:

; 1917 : 
; 1918 : 	if( i == MAX_USER_MESSAGES ) // probably unregistered

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN8@CL_ParseUs

; 1919 : 		Host_Error( "CL_ParseUserMessage: illegible server message %d\n", svc_num );

	mov	ecx, DWORD PTR _svc_num$[ebp]
	push	ecx
	push	OFFSET $SG145340
	call	_Host_Error
	add	esp, 8
$LN8@CL_ParseUs:

; 1920 : 
; 1921 : 	// NOTE: some user messages handled into engine
; 1922 : 	if( !Q_strcmp( clgame.msg[i].name, "ScreenShake" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145343
	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _clgame+1332
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_ParseUs

; 1923 : 	{
; 1924 : 		CL_ParseScreenShake( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseScreenShake
	add	esp, 4

; 1925 : 		return;

	jmp	$LN1@CL_ParseUs

; 1926 : 	}

	jmp	SHORT $LN10@CL_ParseUs
$LN9@CL_ParseUs:

; 1927 : 	else if( !Q_strcmp( clgame.msg[i].name, "ScreenFade" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145345
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1332
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@CL_ParseUs

; 1928 : 	{
; 1929 : 		CL_ParseScreenFade( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseScreenFade
	add	esp, 4

; 1930 : 		return;

	jmp	$LN1@CL_ParseUs
$LN10@CL_ParseUs:

; 1931 : 	}
; 1932 : 
; 1933 : 	iSize = clgame.msg[i].size;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1368]
	mov	DWORD PTR _iSize$[ebp], ecx

; 1934 : 
; 1935 : 	// message with variable sizes receive an actual size as first byte
; 1936 : 	if( iSize == -1 ) iSize = MSG_ReadWord( msg );

	cmp	DWORD PTR _iSize$[ebp], -1
	jne	SHORT $LN12@CL_ParseUs
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax
$LN12@CL_ParseUs:

; 1937 : 
; 1938 : 	// parse user message into buffer
; 1939 : 	MSG_ReadBytes( msg, pbuf, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1940 : 
; 1941 : 	if( clgame.msg[i].func )

	imul	eax, DWORD PTR _i$[ebp], 44
	cmp	DWORD PTR _clgame[eax+1372], 0
	je	$LN13@CL_ParseUs

; 1942 : 	{
; 1943 : 		clgame.msg[i].func( clgame.msg[i].name, iSize, pbuf );

	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _clgame+1332
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	edx, DWORD PTR _clgame[ecx+1372]
	call	edx
	add	esp, 12					; 0000000cH

; 1944 : 
; 1945 : #ifdef HACKS_RELATED_HLMODS
; 1946 : 		// run final credits for Half-Life because hl1 doesn't have call END_SECTION
; 1947 : 		if( !Q_stricmp( clgame.msg[i].name, "HudText" ) && !Q_stricmp( GI->gamefolder, "valve" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145350
	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _clgame+1332
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_ParseUs
	push	99999					; 0001869fH
	push	OFFSET $SG145351
	mov	ecx, DWORD PTR _SI+768
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_ParseUs

; 1948 : 		{
; 1949 : 			// it's a end, so we should run credits
; 1950 : 			if( !Q_strcmp( (char *)pbuf, "END3" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145353
	lea	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_ParseUs

; 1951 : 				Host_Credits();

	call	_Host_Credits
$LN15@CL_ParseUs:

; 1952 : 		}
; 1953 : #endif
; 1954 : 	}

	jmp	SHORT $LN1@CL_ParseUs
$LN13@CL_ParseUs:

; 1955 : 	else
; 1956 : 	{
; 1957 : 		Con_DPrintf( S_ERROR "UserMsg: No pfn %s %d\n", clgame.msg[i].name, clgame.msg[i].number );

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1364]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _clgame+1332
	push	edx
	push	OFFSET $SG145354
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1958 : 		clgame.msg[i].func = CL_UserMsgStub; // throw warning only once

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _clgame[eax+1372], OFFSET _CL_UserMsgStub
$LN1@CL_ParseUs:

; 1959 : 	}
; 1960 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
tv67 = -16						; size = 4
_nSize$ = -12						; size = 4
_nTotalSize$ = -8					; size = 4
_p$ = -4						; size = 4
_CL_EstimateNeededResources PROC

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 548  : 	resource_t	*p;
; 549  : 	int		nTotalSize = 0;

	mov	DWORD PTR _nTotalSize$[ebp], 0

; 550  : 	int		nSize;
; 551  : 
; 552  : 	for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl+1985124
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@CL_Estimat
$LN2@CL_Estimat:
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _p$[ebp], edx
$LN4@CL_Estimat:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	$LN3@CL_Estimat

; 553  : 	{
; 554  : 		switch( p->type )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 5
	ja	$LN5@CL_Estimat
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN16@CL_Estimat[edx*4]
$LN7@CL_Estimat:

; 555  : 		{
; 556  : 		case t_sound:
; 557  : 			nSize = FS_FileSize( va( "%s%s", DEFAULT_SOUNDPATH, p->szFileName ), false );

	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET $SG144773
	push	OFFSET $SG144774
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 558  : 			if( p->szFileName[0] != '*' && nSize == -1 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN8@CL_Estimat
	cmp	DWORD PTR _nSize$[ebp], -1
	jne	SHORT $LN8@CL_Estimat

; 559  : 			{
; 560  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	or	eax, 2
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+76], al

; 561  : 				nTotalSize += p->nDownloadSize;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _nTotalSize$[ebp]
	add	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _nTotalSize$[ebp], eax
$LN8@CL_Estimat:

; 562  : 			}
; 563  : 			break;

	jmp	$LN5@CL_Estimat
$LN9@CL_Estimat:

; 564  : 		case t_model:
; 565  : 			nSize = FS_FileSize( p->szFileName, false );

	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 566  : 			if( p->szFileName[0] != '*' && nSize == -1 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN10@CL_Estimat
	cmp	DWORD PTR _nSize$[ebp], -1
	jne	SHORT $LN10@CL_Estimat

; 567  : 			{
; 568  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl

; 569  : 				nTotalSize += p->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _nTotalSize$[ebp]
	add	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _nTotalSize$[ebp], ecx
$LN10@CL_Estimat:

; 570  : 			}
; 571  : 			break;

	jmp	SHORT $LN5@CL_Estimat
$LN11@CL_Estimat:

; 572  : 		case t_skin:
; 573  : 		case t_generic:
; 574  : 		case t_eventscript:
; 575  : 			nSize = FS_FileSize( p->szFileName, false );

	push	0
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 576  : 			if( nSize == -1 )

	cmp	DWORD PTR _nSize$[ebp], -1
	jne	SHORT $LN12@CL_Estimat

; 577  : 			{
; 578  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl

; 579  : 				nTotalSize += p->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _nTotalSize$[ebp]
	add	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _nTotalSize$[ebp], ecx
$LN12@CL_Estimat:

; 580  : 			}
; 581  : 			break;

	jmp	SHORT $LN5@CL_Estimat
$LN13@CL_Estimat:

; 582  : 		case t_decal:
; 583  : 			if( FBitSet( p->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	je	SHORT $LN5@CL_Estimat

; 584  : 			{
; 585  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax+76], dl

; 586  : 				nTotalSize += p->nDownloadSize;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _nTotalSize$[ebp]
	add	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _nTotalSize$[ebp], edx
$LN5@CL_Estimat:

; 587  : 			}
; 588  : 			break;
; 589  : 		}		
; 590  : 	}

	jmp	$LN2@CL_Estimat
$LN3@CL_Estimat:

; 591  : 
; 592  : 	return nTotalSize;

	mov	eax, DWORD PTR _nTotalSize$[ebp]

; 593  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN16@CL_Estimat:
	DD	$LN7@CL_Estimat
	DD	$LN11@CL_Estimat
	DD	$LN9@CL_Estimat
	DD	$LN13@CL_Estimat
	DD	$LN11@CL_Estimat
	DD	$LN11@CL_Estimat
_CL_EstimateNeededResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_parse.c
_TEXT	SEGMENT
_msg$ = -131364						; size = 20
_n$ = -131344						; size = 4
tv85 = -131340						; size = 4
_p$ = -131336						; size = 4
_data$ = -131332					; size = 131072
_filename$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_initialize$ = 8					; size = 4
_CL_BatchResourceRequest PROC

; 457  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131364				; 00020124H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 458  : 	byte		data[MAX_INIT_MSG];
; 459  : 	resource_t	*p, *n;
; 460  : 	sizebuf_t		msg;
; 461  : 
; 462  : 	MSG_Init( &msg, "Resource Batch", data, sizeof( data ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET $SG144738
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 463  : 
; 464  : 	// client resources is not precached by server
; 465  : 	if( initialize ) CL_AddClientResources();

	cmp	DWORD PTR _initialize$[ebp], 0
	je	SHORT $LN7@CL_BatchRe
	call	_CL_AddClientResources
$LN7@CL_BatchRe:

; 466  : 
; 467  : 	for( p = cl.resourcesneeded.pNext; p && p != &cl.resourcesneeded; p = n )

	mov	edx, DWORD PTR _cl+1985124
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN4@CL_BatchRe
$LN2@CL_BatchRe:
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN4@CL_BatchRe:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@CL_BatchRe
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	$LN3@CL_BatchRe

; 468  : 	{
; 469  : 		n = p->pNext;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _n$[ebp], edx

; 470  : 
; 471  : 		if( !FBitSet( p->ucFlags, RES_WASMISSING ))

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 2
	jne	SHORT $LN8@CL_BatchRe

; 472  : 		{
; 473  : 			CL_MoveToOnHandList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 474  : 			continue;

	jmp	SHORT $LN2@CL_BatchRe
$LN8@CL_BatchRe:

; 475  : 		}
; 476  : 
; 477  : 		if( cls.state == ca_active && !cl_download_ingame.value )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN9@CL_BatchRe
	movss	xmm0, DWORD PTR _cl_download_ingame+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_BatchRe

; 478  : 		{
; 479  : 			Con_Printf( "skipping in game download of %s\n", p->szFileName );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET $SG144742
	call	_Con_Printf
	add	esp, 8

; 480  : 			CL_MoveToOnHandList( p );

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 481  : 			continue;

	jmp	$LN2@CL_BatchRe
$LN9@CL_BatchRe:

; 482  : 		}
; 483  : 
; 484  : 		switch( p->type )

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR tv85[ebp], eax
	cmp	DWORD PTR tv85[ebp], 5
	ja	$LN5@CL_BatchRe
	mov	ecx, DWORD PTR tv85[ebp]
	jmp	DWORD PTR $LN26@CL_BatchRe[ecx*4]
$LN10@CL_BatchRe:

; 485  : 		{
; 486  : 		case t_sound:
; 487  : 			if( !CL_CheckFile( &msg, p ))

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@CL_BatchRe

; 488  : 				break;

	jmp	$LN5@CL_BatchRe
$LN11@CL_BatchRe:

; 489  : 			CL_MoveToOnHandList( p );

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 490  : 			break;

	jmp	$LN5@CL_BatchRe
$LN12@CL_BatchRe:

; 491  : 		case t_skin:
; 492  : 			CL_MoveToOnHandList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 493  : 			break;

	jmp	$LN5@CL_BatchRe
$LN13@CL_BatchRe:

; 494  : 		case t_model:
; 495  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@CL_BatchRe

; 496  : 				break;

	jmp	$LN5@CL_BatchRe
$LN14@CL_BatchRe:

; 497  : 			CL_MoveToOnHandList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 498  : 			break;

	jmp	$LN5@CL_BatchRe
$LN15@CL_BatchRe:

; 499  : 		case t_decal:
; 500  : 			if( !HPAK_GetDataPointer( CUSTOM_RES_PATH, p, NULL, NULL ))

	push	0
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET $SG144750
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN16@CL_BatchRe

; 501  : 			{
; 502  : 				if( !FBitSet( p->ucFlags, RES_REQUESTED ))

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	and	edx, 8
	jne	SHORT $LN17@CL_BatchRe

; 503  : 				{
; 504  : 					string	filename;
; 505  : 
; 506  : 					Q_snprintf( filename, sizeof( filename ), "!MD5%s", MD5_Print( p->rgucMD5_hash ));

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET $SG144752
	push	256					; 00000100H
	lea	ecx, DWORD PTR _filename$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 507  : 					MSG_BeginClientCmd( &msg, clc_stringcmd );

	push	0
	push	0
	push	3
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 508  : 					MSG_WriteString( &msg, va( "dlfile %s", filename ));

	lea	eax, DWORD PTR _filename$1[ebp]
	push	eax
	push	OFFSET $SG144753
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 509  : 					SetBits( p->ucFlags, RES_REQUESTED );

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	or	eax, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx+76], al
$LN17@CL_BatchRe:

; 510  : 				}
; 511  : 				break;

	jmp	$LN5@CL_BatchRe
$LN16@CL_BatchRe:

; 512  : 			}
; 513  : 			CL_MoveToOnHandList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 514  : 			break;

	jmp	$LN5@CL_BatchRe
$LN18@CL_BatchRe:

; 515  : 		case t_generic:
; 516  : 			if( !COM_IsSafeFileToDownload( p->szFileName ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_COM_IsSafeFileToDownload
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@CL_BatchRe

; 517  : 			{
; 518  : 				CL_RemoveFromResourceList( p );

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_CL_RemoveFromResourceList
	add	esp, 4

; 519  : 				Mem_Free( p );

	push	519					; 00000207H
	push	OFFSET $SG144756
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 520  : 				break;

	jmp	SHORT $LN5@CL_BatchRe
$LN19@CL_BatchRe:

; 521  : 			}
; 522  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@CL_BatchRe

; 523  : 				break;

	jmp	SHORT $LN5@CL_BatchRe
$LN20@CL_BatchRe:

; 524  : 			CL_MoveToOnHandList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_CL_MoveToOnHandList
	add	esp, 4

; 525  : 			break;

	jmp	SHORT $LN5@CL_BatchRe
$LN21@CL_BatchRe:

; 526  : 		case t_eventscript:
; 527  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@CL_BatchRe

; 528  : 				break;

	jmp	SHORT $LN5@CL_BatchRe
$LN22@CL_BatchRe:

; 529  : 			CL_MoveToOnHandList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_CL_MoveToOnHandList
	add	esp, 4
$LN5@CL_BatchRe:

; 530  : 			break;
; 531  : 		}
; 532  : 	}

	jmp	$LN2@CL_BatchRe
$LN3@CL_BatchRe:

; 533  : 
; 534  : 	if( cls.state != ca_disconnected )

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN23@CL_BatchRe

; 535  : 	{
; 536  : 		if( !MSG_GetNumBytesWritten( &msg ) && CL_PrecacheResources( ))

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@CL_BatchRe
	call	_CL_PrecacheResources
	test	eax, eax
	je	SHORT $LN24@CL_BatchRe

; 537  : 		{
; 538  : 			CL_RegisterResources( &msg );

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_RegisterResources
	add	esp, 4
$LN24@CL_BatchRe:

; 539  : 		}
; 540  : 
; 541  : 		Netchan_CreateFragments( &cls.netchan, &msg );

	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	OFFSET _cls+23520
	call	_Netchan_CreateFragments
	add	esp, 8

; 542  : 		Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_FragSend
	add	esp, 4
$LN23@CL_BatchRe:

; 543  : 	}
; 544  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN26@CL_BatchRe:
	DD	$LN10@CL_BatchRe
	DD	$LN12@CL_BatchRe
	DD	$LN13@CL_BatchRe
	DD	$LN15@CL_BatchRe
	DD	$LN18@CL_BatchRe
	DD	$LN21@CL_BatchRe
_CL_BatchResourceRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
