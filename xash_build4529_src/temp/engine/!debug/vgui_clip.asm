; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\vgui\vgui_clip.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG126075 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\vgui\vgui_clip.cpp', 00H
$SG126076 DB	'left <= right', 00H
	ORG $+6
$SG126077 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\vgui\vgui_clip.cpp', 00H
$SG126078 DB	'top <= bottom', 00H
CONST	ENDS
PUBLIC	_EnableScissor
PUBLIC	_SetScissorRect
PUBLIC	_ClipRect
PUBLIC	?InterpTCoord@@YAMMMMMM@Z			; InterpTCoord
PUBLIC	__real@3f000000
EXTRN	_DBG_AssertFunction:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_ScissorRect@@3Uwrect_s@@A DB 010H DUP (?)		; g_ScissorRect
?g_bScissor@@3HA DD 01H DUP (?)				; g_bScissor
_BSS	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\vgui\vgui_clip.cpp
;	COMDAT ?InterpTCoord@@YAMMMMMM@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_flPercent$ = -4					; size = 4
_val$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_tMin$ = 20						; size = 4
_tMax$ = 24						; size = 4
?InterpTCoord@@YAMMMMMM@Z PROC				; InterpTCoord, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 51   : 	float	flPercent;
; 52   : 
; 53   : 	if( mins != maxs )

	movss	xmm0, DWORD PTR _mins$[ebp]
	ucomiss	xmm0, DWORD PTR _maxs$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@InterpTCoo

; 54   : 		flPercent = (float)(val - mins) / (maxs - mins);

	movss	xmm0, DWORD PTR _val$[ebp]
	subss	xmm0, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR _maxs$[ebp]
	subss	xmm1, DWORD PTR _mins$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _flPercent$[ebp], xmm0
	jmp	SHORT $LN3@InterpTCoo
$LN2@InterpTCoo:

; 55   : 	else flPercent = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _flPercent$[ebp], xmm0
$LN3@InterpTCoo:

; 56   : 
; 57   : 	return tMin + (tMax - tMin) * flPercent;

	movss	xmm0, DWORD PTR _tMax$[ebp]
	subss	xmm0, DWORD PTR _tMin$[ebp]
	mulss	xmm0, DWORD PTR _flPercent$[ebp]
	addss	xmm0, DWORD PTR _tMin$[ebp]
	movss	DWORD PTR tv81[ebp], xmm0
	fld	DWORD PTR tv81[ebp]

; 58   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InterpTCoord@@YAMMMMMM@Z ENDP				; InterpTCoord
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\vgui\vgui_clip.cpp
_TEXT	SEGMENT
_inUL$ = 8						; size = 4
_inLR$ = 12						; size = 4
_pOutUL$ = 16						; size = 4
_pOutLR$ = 20						; size = 4
_ClipRect PROC

; 65   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 66   : 	if( g_bScissor )

	cmp	DWORD PTR ?g_bScissor@@3HA, 0
	je	$LN2@ClipRect

; 67   : 	{
; 68   : 		// pick whichever left side is larger
; 69   : 		if( g_ScissorRect.left > inUL.point[0] )

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _inUL$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx]
	jbe	SHORT $LN4@ClipRect

; 70   : 			pOutUL->point[0] = g_ScissorRect.left;

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pOutUL$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 71   : 		else

	jmp	SHORT $LN5@ClipRect
$LN4@ClipRect:

; 72   : 			pOutUL->point[0] = inUL.point[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pOutUL$[ebp]
	mov	esi, DWORD PTR _inUL$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
$LN5@ClipRect:

; 73   : 
; 74   : 		// pick whichever right side is smaller
; 75   : 		if( g_ScissorRect.right <= inLR.point[0] )

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+4
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	comiss	xmm1, xmm0
	jb	SHORT $LN6@ClipRect

; 76   : 			pOutLR->point[0] = g_ScissorRect.right;

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+4
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pOutLR$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 77   : 		else

	jmp	SHORT $LN7@ClipRect
$LN6@ClipRect:

; 78   : 			pOutLR->point[0] = inLR.point[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pOutLR$[ebp]
	mov	esi, DWORD PTR _inLR$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax
$LN7@ClipRect:

; 79   : 
; 80   : 		// pick whichever top side is larger
; 81   : 		if( g_ScissorRect.top > inUL.point[1] )

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+8
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _inUL$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx]
	jbe	SHORT $LN8@ClipRect

; 82   : 			pOutUL->point[1] = g_ScissorRect.top;

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 83   : 		else

	jmp	SHORT $LN9@ClipRect
$LN8@ClipRect:

; 84   : 			pOutUL->point[1] = inUL.point[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	mov	esi, DWORD PTR _inUL$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN9@ClipRect:

; 85   : 
; 86   : 		// pick whichever bottom side is smaller
; 87   : 		if( g_ScissorRect.bottom <= inLR.point[1] )

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	comiss	xmm1, xmm0
	jb	SHORT $LN10@ClipRect

; 88   : 			pOutLR->point[1] = g_ScissorRect.bottom;

	cvtsi2ss xmm0, DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+12
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pOutLR$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 89   : 		else

	jmp	SHORT $LN11@ClipRect
$LN10@ClipRect:

; 90   : 			pOutLR->point[1] = inLR.point[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pOutLR$[ebp]
	mov	esi, DWORD PTR _inLR$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
$LN11@ClipRect:

; 91   : 
; 92   : 		// Check for non-intersecting
; 93   : 		if(( pOutUL->point[0] > pOutLR->point[0] ) || ( pOutUL->point[1] > pOutLR->point[1] ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	mov	esi, DWORD PTR _pOutLR$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	comiss	xmm0, DWORD PTR [esi+edx]
	ja	SHORT $LN13@ClipRect
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	mov	esi, DWORD PTR _pOutLR$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	comiss	xmm0, DWORD PTR [esi+eax]
	jbe	SHORT $LN12@ClipRect
$LN13@ClipRect:

; 94   : 		{
; 95   : 			return false;

	xor	eax, eax
	jmp	$LN1@ClipRect
$LN12@ClipRect:

; 96   : 		}
; 97   : 
; 98   : 		pOutUL->coord[0] = InterpTCoord(pOutUL->point[0], inUL.point[0], inLR.point[0], inUL.coord[0], inLR.coord[0] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	call	?InterpTCoord@@YAMMMMMM@Z		; InterpTCoord
	add	esp, 20					; 00000014H
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	fstp	DWORD PTR [ecx+eax+8]

; 99   : 		pOutLR->coord[0] = InterpTCoord(pOutLR->point[0], inUL.point[0], inLR.point[0], inUL.coord[0], inLR.coord[0] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pOutLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	call	?InterpTCoord@@YAMMMMMM@Z		; InterpTCoord
	add	esp, 20					; 00000014H
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pOutLR$[ebp]
	fstp	DWORD PTR [ecx+eax+8]

; 100  : 
; 101  : 		pOutUL->coord[1] = InterpTCoord(pOutUL->point[1], inUL.point[1], inLR.point[1], inUL.coord[1], inLR.coord[1] );

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pOutUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	call	?InterpTCoord@@YAMMMMMM@Z		; InterpTCoord
	add	esp, 20					; 00000014H
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutUL$[ebp]
	fstp	DWORD PTR [ecx+eax+8]

; 102  : 		pOutLR->coord[1] = InterpTCoord(pOutLR->point[1], inUL.point[1], inLR.point[1], inUL.coord[1], inLR.coord[1] );

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _inLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _inUL$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pOutLR$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	call	?InterpTCoord@@YAMMMMMM@Z		; InterpTCoord
	add	esp, 20					; 00000014H
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutLR$[ebp]
	fstp	DWORD PTR [ecx+eax+8]

; 103  : 	}
; 104  : 	else

	jmp	SHORT $LN3@ClipRect
$LN2@ClipRect:

; 105  : 	{
; 106  : 		*pOutUL = inUL;

	mov	edx, DWORD PTR _inUL$[ebp]
	mov	eax, DWORD PTR _pOutUL$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx

; 107  : 		*pOutLR = inLR;

	mov	eax, DWORD PTR _inLR$[ebp]
	mov	ecx, DWORD PTR _pOutLR$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
$LN3@ClipRect:

; 108  : 	}
; 109  : 	return true;

	mov	eax, 1
$LN1@ClipRect:

; 110  : }

	pop	esi
	pop	ebp
	ret	0
_ClipRect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\vgui\vgui_clip.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
tv69 = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_right$ = 16						; size = 4
_bottom$ = 20						; size = 4
_SetScissorRect PROC

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 36   : 	// Check for a valid rectangle...
; 37   : 	Assert( left <= right );

	mov	eax, DWORD PTR _left$[ebp]
	cmp	eax, DWORD PTR _right$[ebp]
	jg	SHORT $LN3@SetScissor
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@SetScissor
$LN3@SetScissor:
	mov	DWORD PTR tv69[ebp], 0
$LN4@SetScissor:
	push	0
	push	37					; 00000025H
	push	OFFSET $SG126075
	push	OFFSET $SG126076
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 38   : 	Assert( top <= bottom );

	mov	edx, DWORD PTR _top$[ebp]
	cmp	edx, DWORD PTR _bottom$[ebp]
	jg	SHORT $LN5@SetScissor
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN6@SetScissor
$LN5@SetScissor:
	mov	DWORD PTR tv76[ebp], 0
$LN6@SetScissor:
	push	0
	push	38					; 00000026H
	push	OFFSET $SG126077
	push	OFFSET $SG126078
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 39   : 
; 40   : 	g_ScissorRect.left = left;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A, ecx

; 41   : 	g_ScissorRect.top = top;

	mov	edx, DWORD PTR _top$[ebp]
	mov	DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+8, edx

; 42   : 	g_ScissorRect.right = right;

	mov	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+4, eax

; 43   : 	g_ScissorRect.bottom = bottom;

	mov	ecx, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR ?g_ScissorRect@@3Uwrect_s@@A+12, ecx

; 44   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SetScissorRect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\vgui\vgui_clip.cpp
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_EnableScissor PROC

; 30   : {

	push	ebp
	mov	ebp, esp

; 31   : 	g_bScissor = enable;

	mov	eax, DWORD PTR _enable$[ebp]
	mov	DWORD PTR ?g_bScissor@@3HA, eax

; 32   : }

	pop	ebp
	ret	0
_EnableScissor ENDP
_TEXT	ENDS
END
