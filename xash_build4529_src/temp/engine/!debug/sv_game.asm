; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\server\sv_game.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnSetGroupMask
PUBLIC	_pfnCreateInstancedBaseline
PUBLIC	_pfnEndSection
PUBLIC	_pfnGetPlayerUserId
PUBLIC	_pfnGetPlayerStats
PUBLIC	_pfnForceUnmodified
PUBLIC	_pfnVoice_GetClientListening
PUBLIC	_pfnVoice_SetClientListening
PUBLIC	_pfnGetPlayerAuthId
PUBLIC	_pfnQueryClientCvarValue
PUBLIC	_pfnQueryClientCvarValue2
PUBLIC	_SV_AllocEdict
PUBLIC	_SV_FreePrivateData
PUBLIC	_SV_FindEntityByString
PUBLIC	_SV_PlaybackEventFull
PUBLIC	_SV_AllocString
PUBLIC	_SV_GetString
PUBLIC	_pfnIndexOfEdict
PUBLIC	_pfnSetFatPVS
PUBLIC	_pfnSetFatPAS
PUBLIC	_pfnPrecacheModel
PUBLIC	_pfnModelIndex
PUBLIC	_pfnRemoveEntity
PUBLIC	_pfnGetCurrentPlayer
PUBLIC	_pfnPEntityOfEntIndex
PUBLIC	_pfnDecalIndex
PUBLIC	_pfnIsMapValid
PUBLIC	_pfnNumberOfEntities
PUBLIC	_SV_StartSound
PUBLIC	_pfnSetModel
PUBLIC	_pfnModelFrames
PUBLIC	_pfnSetSize
PUBLIC	_pfnChangeLevel
PUBLIC	_pfnGetSpawnParms
PUBLIC	_pfnSaveSpawnParms
PUBLIC	_pfnVecToYaw
PUBLIC	_pfnMoveToOrigin
PUBLIC	_pfnChangeYaw
PUBLIC	_pfnChangePitch
PUBLIC	_pfnGetEntityIllum
PUBLIC	_pfnFindEntityInSphere
PUBLIC	_pfnFindClientInPVS
PUBLIC	_pfnEntitiesInPVS
PUBLIC	_pfnMakeVectors
PUBLIC	_pfnCreateNamedEntity
PUBLIC	_pfnDropToFloor
PUBLIC	_pfnWalkMove
PUBLIC	_pfnSetOrigin
PUBLIC	_pfnEmitAmbientSound
PUBLIC	_pfnTraceSphere
PUBLIC	_pfnGetAimVector
PUBLIC	_pfnServerCommand
PUBLIC	_pfnServerExecute
PUBLIC	_pfnClientCommand
PUBLIC	_pfnParticleEffect
PUBLIC	_pfnLightStyle
PUBLIC	_pfnMessageBegin
PUBLIC	_pfnMessageEnd
PUBLIC	_pfnWriteByte
PUBLIC	_pfnWriteChar
PUBLIC	_pfnWriteShort
PUBLIC	_pfnWriteLong
PUBLIC	_pfnWriteAngle
PUBLIC	_pfnWriteCoord
PUBLIC	_pfnWriteString
PUBLIC	_pfnWriteEntity
PUBLIC	_pfnBuildSoundMsg
PUBLIC	_pfnPvAllocEntPrivateData
PUBLIC	_pfnPvEntPrivateData
PUBLIC	_pfnGetVarsOfEnt
PUBLIC	_pfnPEntityOfEntOffset
PUBLIC	_pfnEntOffsetOfPEntity
PUBLIC	_pfnFindEntityByVars
PUBLIC	_pfnRegUserMsg
PUBLIC	_pfnAnimationAutomove
PUBLIC	_pfnFunctionFromName
PUBLIC	_pfnNameForFunction
PUBLIC	_pfnClientPrintf
PUBLIC	_pfnServerPrint
PUBLIC	_pfnCrosshairAngle
PUBLIC	_pfnSetView
PUBLIC	_pfnStaticDecal
PUBLIC	_pfnIsDedicatedServer
PUBLIC	_pfnGetPlayerWONId
PUBLIC	_pfnFadeClientVolume
PUBLIC	_pfnSetClientMaxspeed
PUBLIC	_pfnRunPlayerMove
PUBLIC	_pfnGetInfoKeyBuffer
PUBLIC	_pfnSetValueForKey
PUBLIC	_pfnSetClientKeyValue
PUBLIC	_pfnGetPhysicsKeyValue
PUBLIC	_pfnSetPhysicsKeyValue
PUBLIC	_pfnGetPhysicsInfoString
PUBLIC	_pfnPrecacheEvent
PUBLIC	_pfnCheckVisibility
PUBLIC	_pfnCanSkipPlayer
EXTRN	_SV_SoundIndex:PROC
EXTRN	_SV_GenericIndex:PROC
EXTRN	_SV_FakeConnect:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Args:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddServerCommand:PROC
EXTRN	_SV_PointContents:PROC
EXTRN	_Delta_AddEncoder:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Delta_FindField:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Delta_SetField:PROC
EXTRN	_Cvar_VariableValue:PROC
EXTRN	_Delta_UnsetField:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_Delta_SetFieldByIndex:PROC
EXTRN	_Delta_UnsetFieldByIndex:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_pfnCvar_RegisterServerVariable:PROC
EXTRN	_pfnCvar_RegisterEngineVariable:PROC
EXTRN	_COM_LoadFileForMe:PROC
EXTRN	_pfnCVarGetPointer:PROC
EXTRN	_pfnCVarDirectSet:PROC
EXTRN	_COM_CheckParm:PROC
EXTRN	_pfnGetGameDir:PROC
EXTRN	_pfnTime:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_CRC32_ProcessByte:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_RemoveKey:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_AngleVectors:PROC
_DATA	SEGMENT
$SG137280 DB	'classname', 00H
	ORG $+2
$SG137281 DB	'globalname', 00H
	ORG $+1
$SG137282 DB	'model', 00H
	ORG $+2
$SG137283 DB	'viewmodel', 00H
	ORG $+2
$SG137284 DB	'weaponmodel', 00H
$SG137285 DB	'target', 00H
	ORG $+1
$SG137286 DB	'targetname', 00H
	ORG $+1
$SG137287 DB	'netname', 00H
$SG137288 DB	'message', 00H
$SG137289 DB	'noise', 00H
	ORG $+2
$SG137290 DB	'noise1', 00H
	ORG $+1
$SG137291 DB	'noise2', 00H
	ORG $+1
$SG137292 DB	'noise3', 00H
_DATA	ENDS
PUBLIC	_SV_StartMusic
PUBLIC	_SV_CreateDecal
PUBLIC	_SV_RestoreCustomDecal
PUBLIC	_SV_SysError
PUBLIC	_SV_Serverinfo
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetNumBytesLeft
PUBLIC	_MSG_GetData
PUBLIC	_SV_LoadProgs
PUBLIC	_SV_UnloadProgs
PUBLIC	_SV_FreeEdicts
PUBLIC	_SV_FreeEdict
PUBLIC	_SV_InitEdict
PUBLIC	_SV_ClassName
PUBLIC	_SV_CopyTraceToGlobal
PUBLIC	_SV_CheckEdict
PUBLIC	_SV_SetMinMaxSize
PUBLIC	_SV_PlaybackReliableEvent
PUBLIC	_SV_BuildSoundMsg
PUBLIC	_SV_BoxInPVS
PUBLIC	_SV_QueueChangeLevel
PUBLIC	_SV_WriteEntityPatch
PUBLIC	_SV_AngleMod
PUBLIC	_SV_SpawnEntities
PUBLIC	_SV_AllocPrivateData
PUBLIC	_SV_CreateNamedEntity
PUBLIC	_SV_MakeString
PUBLIC	_SV_ClientFromEdict
PUBLIC	_SV_MapIsValid
PUBLIC	_SV_FindGlobalEntity
PUBLIC	_SV_CreateStaticEntity
PUBLIC	_SV_SendUserReg
PUBLIC	_pfnWriteBytes
PUBLIC	_SV_RestartAmbientSounds
PUBLIC	_SV_RestartDecals
PUBLIC	_SV_RestartStaticEnts
PUBLIC	_SV_EdictNum
PUBLIC	_SV_Localinfo
PUBLIC	_SV_GetEntvarsDescirption
PUBLIC	_SV_ConvertTrace
PUBLIC	_SV_CheckClientVisiblity
PUBLIC	_SV_GetReliableDatagram
PUBLIC	_SV_GetEntityClass
PUBLIC	_SV_CheckClientPVS
PUBLIC	_SV_ParseEdict
PUBLIC	_SV_LoadFromFile
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40a00000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42800000
PUBLIC	__real@42c80000
PUBLIC	__real@42fe0000
PUBLIC	__real@43340000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43b40000
PUBLIC	__real@447a0000
PUBLIC	__real@45000000
PUBLIC	__real@45800000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c3000000
PUBLIC	__real@c3340000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Unlink:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_isdigit:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_IsAllocatedExt:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_Cvar_Unlink:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_COM_ParseVector:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Host_Credits:PROC
EXTRN	_COM_ChangeLevel:PROC
EXTRN	_SV_Active:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_DisableVisibility:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_Log_Printf:PROC
EXTRN	_SV_BroadcastPrintf:PROC
EXTRN	_R_CreateDecalList:PROC
EXTRN	_R_ClearAllDecals:PROC
EXTRN	_R_ClearStaticEntities:PROC
EXTRN	_S_StreamGetCurrentState:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Info_SetValueForStarKey:PROC
EXTRN	_S_StopSound:PROC
EXTRN	_S_GetCurrentStaticSounds:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_Mod_ClearUserData:PROC
EXTRN	_Mod_StudioExtradata:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_Mod_TestBmodelLumps:PROC
EXTRN	_Mod_HeadnodeVisible:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_BoxVisible:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_Mod_GetPVSForPoint:PROC
EXTRN	_Mod_InitStudioAPI:PROC
EXTRN	_Mod_ResetStudioAPI:PROC
EXTRN	_Mod_StudioGetAttachment:PROC
EXTRN	_Mod_GetBonePosition:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteChar:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteShort:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteCoord:PROC
EXTRN	_MSG_WriteVec3Coord:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_SV_ModelIndex:PROC
EXTRN	_SV_EventIndex:PROC
EXTRN	_SV_InitOperatorCommands:PROC
EXTRN	_SV_KillOperatorCommands:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_DeactivateServer:PROC
EXTRN	_SV_InitPhysicsAPI:PROC
EXTRN	_SV_MoveStep:PROC
EXTRN	_SV_MoveTest:PROC
EXTRN	_SV_MoveToOrigin:PROC
EXTRN	_SV_CheckBottom:PROC
EXTRN	_SV_VecToYaw:PROC
EXTRN	_SV_ClientPrintf:PROC
EXTRN	_SV_GetClientIDString:PROC
EXTRN	_SV_RunCmd:PROC
EXTRN	_SV_IsPlayerIndex:PROC
EXTRN	_SV_InitClientMove:PROC
EXTRN	_SV_FindBestBaselineForStatic:PROC
EXTRN	_SV_SkipUpdates:PROC
EXTRN	_SV_InitSaveRestore:PROC
EXTRN	_SV_UnlinkEdict:PROC
EXTRN	_SV_ClipMoveToEntity:PROC
EXTRN	_SV_CustomClipMoveToEntity:PROC
EXTRN	_SV_Move:PROC
EXTRN	_SV_TraceTexture:PROC
EXTRN	_SV_MoveToss:PROC
EXTRN	_SV_LinkEdict:PROC
EXTRN	_SV_SetLightStyle:PROC
EXTRN	_SV_LightForEntity:PROC
EXTRN	_Delta_Init:PROC
EXTRN	_Delta_Shutdown:PROC
EXTRN	_MSG_WriteDeltaEvent:PROC
EXTRN	_MSG_WriteDeltaEntity:PROC
EXTRN	_COM_LoadLibrary:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_COM_NameForFunction:PROC
EXTRN	_COM_FunctionFromName:PROC
EXTRN	_COM_FreeLibrary:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_world:BYTE
EXTRN	_svc_strings:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_novis:DWORD
EXTRN	_sv_validate_changelevel:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_fatpvs	DB	0fffH DUP (?)
	ALIGN	4

_fatphs	DB	0fffH DUP (?)
	ALIGN	4

_clientpvs DB	0fffH DUP (?)
	ALIGN	4

_viewPoint DD	060H DUP (?)
?last_spawncount@?1??pfnChangeLevel@@9@9 DD 01H DUP (?)	; `pfnChangeLevel'::`2'::last_spawncount
?string@?1??pfnWriteString@@9@9 DB 0800H DUP (?)	; `pfnWriteString'::`2'::string
$SG139036 DB	01H DUP (?)
	ALIGN	4

$SG139076 DB	01H DUP (?)
	ALIGN	4

$SG139097 DB	01H DUP (?)
	ALIGN	4

$SG139444 DB	01H DUP (?)
	ALIGN	4

?GetEntityAPI@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GetEntityAPI
?GetEntityAPI2@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GetEntityAPI2
?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GiveFnptrsToDll
?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9 DD 01H DUP (?)	; `SV_LoadProgs'::`2'::GiveNewDllFuncs
?gpEngfuncs@?1??SV_LoadProgs@@9@9 DB 0278H DUP (?)	; `SV_LoadProgs'::`2'::gpEngfuncs
?gpGlobals@?1??SV_LoadProgs@@9@9 DB 0acH DUP (?)	; `SV_LoadProgs'::`2'::gpGlobals
?gpMove@?1??SV_LoadProgs@@9@9 DB 04f5d0H DUP (?)	; `SV_LoadProgs'::`2'::gpMove
$SG139624 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c3000000
CONST	SEGMENT
__real@c3000000 DD 0c3000000r			; -128
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG137252 DB	'bad entity %i (called at %s:%i)', 0aH, 00H
	ORG $+3
_gEntvarsDescription DD 01H
	DD	FLAT:$SG137280
	DD	00H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137281
	DD	04H
	DW	01H
	DW	00H
	DD	010H
	DD	FLAT:$SG137282
	DD	0b8H
	DW	01H
	DW	00H
	DD	010H
	DD	FLAT:$SG137283
	DD	0bcH
	DW	01H
	DW	00H
	DD	010H
	DD	FLAT:$SG137284
	DD	0c0H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137285
	DD	01c8H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137286
	DD	01ccH
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137287
	DD	01d0H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137288
	DD	01d4H
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:$SG137289
	DD	01e8H
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:$SG137290
	DD	01ecH
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:$SG137291
	DD	01f0H
	DW	01H
	DW	00H
	DD	011H
	DD	FLAT:$SG137292
	DD	01f4H
	DW	01H
	DW	00H
$SG137303 DB	'FATAL ERROR (shutting down): %s', 0aH, 00H
	ORG $+3
$SG137344 DB	'^1Error:^7 %s[%i] has backwards mins/maxs', 0aH, 00H
	ORG $+1
$SG137342 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137436 DB	'SV_Multicast: bad dest: %i', 0aH, 00H
$SG137352 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137564 DB	'^1Error:^7 changelevel: %s is invalid or not supported', 0aH
	DB	00H
$SG137594 DB	'maps/%s.bsp', 00H
$SG137384 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137595 DB	'rb', 00H
	ORG $+1
$SG137431 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137600 DB	'maps/%s.ent', 00H
$SG137446 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137498 DB	'^3Warning:^7 MAX_STATIC_ENTITIES limit exceeded (%d)', 0aH
	DB	00H
	ORG $+2
$SG137624 DB	'maps/%s.bsp', 00H
$SG137537 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137625 DB	'rb', 00H
	ORG $+1
$SG137541 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137566 DB	'^1Error:^7 changelevel: map %s doesn''t exist', 0aH, 00H
	ORG $+2
$SG137628 DB	'maps/%s.ent', 00H
$SG137569 DB	'^3Warning:^7 changelevel: %s doesn''t contain landmark ['
	DB	'%s]. smooth transition was disabled', 0aH, 00H
$SG137572 DB	'^1Error:^7 can''t changelevel with same map. Ignored.', 0aH
	DB	00H
	ORG $+2
$SG137653 DB	'classname', 00H
	ORG $+2
$SG137575 DB	'^1Error:^7 changelevel: %s doesn''t have a valid spawnpo'
	DB	'int. Ignored.', 0aH, 00H
	ORG $+2
$SG137578 DB	'^3Warning:^7 an infinite changelevel was detected and wi'
	DB	'll be disabled until a next save\restore', 0aH, 00H
	ORG $+2
$SG137657 DB	'targetname', 00H
	ORG $+1
$SG137599 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137601 DB	'Write ''maps/%s.ent''', 0aH, 00H
	ORG $+3
$SG137678 DB	'pEdict != NULL', 00H
	ORG $+1
$SG137697 DB	'ED_AllocEdict: no free edicts (max is %d)', 0aH, 00H
	ORG $+1
$SG137602 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137807 DB	'^1Error:^7 no precache: %s', 0aH, 00H
$SG137631 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137810 DB	'^1Error:^7 world model can''t be changed', 0aH, 00H
	ORG $+3
$SG137650 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137827 DB	'^1Error:^7 no precache: %s', 0aH, 00H
$SG137660 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137947 DB	'globalname', 00H
	ORG $+1
$SG137670 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138077 DB	'^1Error:^7 can''t delete %s', 0aH, 00H
$SG137677 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138176 DB	'^1Error:^7 SV_StartSound: channel must be in range 0-7', 0aH
	DB	00H
$SG138190 DB	'^1Error:^7 SV_StartSound: %s not precached (%d)', 0aH, 00H
	ORG $+3
$SG137684 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137685 DB	'pEdict != NULL', 00H
	ORG $+1
$SG137716 DB	'custom', 00H
	ORG $+1
$SG137718 DB	'^1Error:^7 No spawn function for %s', 0aH, 00H
	ORG $+3
$SG137751 DB	'(null)', 00H
	ORG $+1
$SG137753 DB	'freed', 00H
	ORG $+2
$SG138076 DB	'client', 00H
	ORG $+1
$SG138269 DB	'music "%s" "%s" %i', 0aH, 00H
$SG137773 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138429 DB	'^1Error:^7 bad server command %s', 0aH, 00H
	ORG $+2
$SG137801 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138434 DB	'exec config.cfg', 0aH, 00H
	ORG $+3
$SG137844 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138436 DB	'server executing ^2config.cfg^7 (%i cvars)', 0aH, 00H
$SG137888 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138461 DB	'^1Error:^7 Tried to stuff bad command %s', 0aH, 00H
	ORG $+2
$SG137894 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138532 DB	'Unknown', 00H
$SG138535 DB	'MessageEnd: called with no active message', 0aH, 00H
	ORG $+1
$SG137900 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG137932 DB	'^1Error:^7 FindEntityByString: field %s not a string', 0aH
	DB	00H
	ORG $+2
$SG138170 DB	'^1Error:^7 SV_StartSound: volume = %i', 0aH, 00H
	ORG $+1
$SG138537 DB	'^1Error:^7 MessageEnd: %s has overflow multicast buffer', 0aH
	DB	00H
	ORG $+3
$SG137934 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138543 DB	'^1Error:^7 SV_Multicast: %s too long (more than %d bytes'
	DB	')', 0aH, 00H
	ORG $+1
$SG137949 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138545 DB	'^1Error:^7 SV_Multicast: %s writes NULL message', 0aH, 00H
	ORG $+3
$SG137956 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138554 DB	'^1Error:^7 SV_Multicast: %s too long (more than %d bytes'
	DB	')', 0aH, 00H
	ORG $+1
$SG137979 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138556 DB	'^1Error:^7 SV_Multicast: %s writes NULL message', 0aH, 00H
	ORG $+3
$SG137981 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138557 DB	'^1Error:^7 SV_Multicast: %s have encountered error', 0aH
	DB	00H
$SG138021 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138651 DB	'%s', 00H
	ORG $+1
$SG138035 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138657 DB	'%s', 00H
	ORG $+1
$SG138056 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138659 DB	'%s', 00H
	ORG $+1
$SG138058 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138661 DB	'^3Warning:^7 %s', 00H
$SG138823 DB	'^1Error:^7 REG_USER_MSG: too long name %s', 0aH, 00H
	ORG $+1
$SG138061 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138825 DB	'^1Error:^7 REG_USER_MSG: %s has too big size %i', 0aH, 00H
	ORG $+3
$SG138073 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138075 DB	'world', 00H
	ORG $+2
$SG138173 DB	'^1Error:^7 SV_StartSound: attenuation %g must be in rang'
	DB	'e 0-4', 0aH, 00H
	ORG $+1
$SG138870 DB	'tried to sprint to a non-client', 0aH, 00H
	ORG $+3
$SG138091 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138873 DB	'%s', 00H
	ORG $+1
$SG138098 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138882 DB	'%s', 00H
	ORG $+1
$SG138107 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138883 DB	'%s', 00H
	ORG $+1
$SG138127 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138932 DB	'^1Error:^7 PF_SetView_I: not a client!', 0aH, 00H
$SG138990 DB	'%.f', 00H
$SG138139 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138179 DB	'^1Error:^7 SV_StartSound: pitch = %i', 0aH, 00H
	ORG $+2
$SG138181 DB	'^1Error:^7 SV_StartSound: passed NULL sample', 0aH, 00H
	ORG $+2
$SG138415 DB	'sv_aim', 00H
	ORG $+1
$SG139096 DB	'^1Error:^7 GetPhysicsInfoString: tried to a non-client!', 0aH
	DB	00H
	ORG $+3
$SG138193 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139159 DB	'^1Error:^7 EV_Playback: event %i was not precached', 0aH
	DB	00H
$SG138194 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139206 DB	'assert failed at %s:%i', 0aH, 00H
$SG139343 DB	'^1Error:^7 no precache: %s', 0aH, 00H
$SG138197 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139221 DB	'assert failed at %s:%i', 0aH, 00H
$SG139381 DB	'Bad Player', 00H
	ORG $+1
$SG138226 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139289 DB	'oem_end_credits', 00H
$SG139398 DB	'Bad Player', 00H
	ORG $+1
$SG138284 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139340 DB	'MAX_MODELS limit exceeded (%d)', 0aH, 00H
$SG139433 DB	'ED_ParseEdict: EOF without closing brace', 0aH, 00H
	ORG $+2
$SG138295 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139436 DB	'ED_ParseEdict: EOF without closing brace', 0aH, 00H
	ORG $+2
$SG138330 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139438 DB	'ED_ParseEdict: closing brace without data', 0aH, 00H
	ORG $+1
$SG138352 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139441 DB	'wad', 00H
$SG138369 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139448 DB	'classname', 00H
	ORG $+2
$SG138412 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138457 DB	'^1Error:^7 stuffcmd: client is not spawned!', 0aH, 00H
	ORG $+3
$SG138483 DB	'SV_LightStyle: style: %i >= %d', 00H
	ORG $+1
$SG139459 DB	'customclass', 00H
$SG138510 DB	'MessageBegin: New message started when msg ''%s'' has no'
	DB	't been sent yet', 0aH, 00H
	ORG $+1
$SG138517 DB	'MessageBegin: tried to send unregistered message %i', 0aH
	DB	00H
	ORG $+3
$SG138549 DB	'^1Error:^7 SV_Multicast: %s expected %i bytes, it writte'
	DB	'n %i. Ignored.', 0aH, 00H
$SG138618 DB	'^1Error:^7 pfnWriteString: exceeds %i symbols', 0aH, 00H
	ORG $+1
$SG138626 DB	'MSG_WriteEntity: invalid entnumber %i', 0aH, 00H
	ORG $+1
$SG138655 DB	'^2Note:^7 %s', 00H
	ORG $+3
$SG138663 DB	'^1Error:^7 %s', 00H
	ORG $+2
$SG138703 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138704 DB	'pEdict != NULL', 00H
	ORG $+1
$SG139461 DB	'ce', 00H
	ORG $+1
$SG138706 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139463 DB	'ce08_02', 00H
$SG139474 DB	'%g %g %g', 00H
	ORG $+3
$SG138726 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138768 DB	'bad entity number %d', 0aH, 00H
	ORG $+2
$SG138828 DB	'^1Error:^7 REG_USER_MSG: user messages limit exceeded', 0aH
	DB	00H
	ORG $+1
$SG139464 DB	'info_player_start_force', 00H
$SG139489 DB	'%g %g %g', 00H
	ORG $+3
$SG138778 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139478 DB	'-90 0 0', 00H
$SG139494 DB	'light_level', 00H
$SG138780 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139518 DB	'entities != NULL', 00H
	ORG $+3
$SG138801 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139522 DB	'ED_LoadFromFile: found %s when expecting {', 0aH, 00H
$SG138847 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139528 DB	0aH, '%i entities inhibited', 0aH, 00H
$SG139534 DB	'sv_wateramp', 00H
$SG138895 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139533 DB	'sv_zmax', 00H
$SG139539 DB	'sv_skyvec_x', 00H
$SG138930 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139540 DB	'sv_skyvec_y', 00H
$SG138936 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG138991 DB	'maxspd', 00H
	ORG $+1
$SG139541 DB	'sv_skyvec_z', 00H
$SG139033 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139049 DB	'^1Error:^7 can''t set client keys with SetValueForKey', 0aH
	DB	00H
	ORG $+2
$SG139075 DB	'^1Error:^7 GetPhysicsKeyValue: tried to a non-client!', 0aH
	DB	00H
	ORG $+1
$SG139088 DB	'^1Error:^7 SetPhysicsKeyValue: tried to a non-client!', 0aH
	DB	00H
	ORG $+1
$SG139157 DB	'^1Error:^7 EV_Playback: invalid eventindex %i', 0aH, 00H
	ORG $+1
$SG139542 DB	'sv_skyname', 00H
	ORG $+1
$SG139166 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139553 DB	'0', 00H
	ORG $+2
$SG139170 DB	'^1Error:^7 %s: not a FEV_GLOBAL event missing origin. Ig'
	DB	'nored.', 0aH, 00H
$SG139174 DB	'^3Warning:^7 %s: specified FEV_NOTHOST when invoker not '
	DB	'a client', 0aH, 00H
	ORG $+2
$SG139458 DB	'custom', 00H
	ORG $+1
$SG139554 DB	'host_gameloaded', 00H
$SG139555 DB	'0', 00H
	ORG $+2
$SG139176 DB	'^3Warning:^7 %s: specified FEV_HOSTONLY when invoker not'
	DB	' a client', 0aH, 00H
	ORG $+1
$SG139598 DB	'Server Edicts Zone', 00H
	ORG $+1
$SG139182 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139602 DB	'GetNewDLLFunctions', 00H
	ORG $+1
$SG139186 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139605 DB	'GiveFnptrsToDll', 00H
$SG139618 DB	'^1Error:^7 SV_LoadProgs: couldn''t get entity API', 0aH, 00H
	ORG $+2
$SG139205 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139619 DB	'SV_LoadProgs: ^2initailized extended EntityAPI ^7ver. %i'
	DB	0aH, 00H
	ORG $+2
$SG139220 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139621 DB	'^1Error:^7 SV_LoadProgs: couldn''t get entity API', 0aH, 00H
	ORG $+2
$SG139247 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139628 DB	'1', 00H
	ORG $+2
$SG139282 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139290 DB	0aH, 'disconnect', 0aH, 00H
	ORG $+3
$SG139466 DB	'angle', 00H
	ORG $+2
$SG139470 DB	'angles', 00H
	ORG $+1
$SG139629 DB	'host_gameloaded', 00H
$SG139632 DB	'Dll loaded for game ^2"%s"', 0aH, 00H
$SG139338 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139382 DB	'^1Error:^7 QueryClientCvarValue: tried to send to a non-'
	DB	'client!', 0aH, 00H
	ORG $+3
$SG139482 DB	'90 0 0', 00H
	ORG $+5
$SG139399 DB	'^1Error:^7 QueryClientCvarValue: tried to send to a non-'
	DB	'client!', 0aH, 00H
	ORG $+3
$SG139484 DB	'0 0 0', 00H
	ORG $+6
_gEngfuncs DD	FLAT:_pfnPrecacheModel
	DD	FLAT:_SV_SoundIndex
	DD	FLAT:_pfnSetModel
	DD	FLAT:_pfnModelIndex
	DD	FLAT:_pfnModelFrames
	DD	FLAT:_pfnSetSize
	DD	FLAT:_pfnChangeLevel
	DD	FLAT:_pfnGetSpawnParms
	DD	FLAT:_pfnSaveSpawnParms
	DD	FLAT:_pfnVecToYaw
	DD	FLAT:_VectorAngles
	DD	FLAT:_pfnMoveToOrigin
	DD	FLAT:_pfnChangeYaw
	DD	FLAT:_pfnChangePitch
	DD	FLAT:_SV_FindEntityByString
	DD	FLAT:_pfnGetEntityIllum
	DD	FLAT:_pfnFindEntityInSphere
	DD	FLAT:_pfnFindClientInPVS
	DD	FLAT:_pfnEntitiesInPVS
	DD	FLAT:_pfnMakeVectors
	DD	FLAT:_AngleVectors
	DD	FLAT:_SV_AllocEdict
	DD	FLAT:_pfnRemoveEntity
	DD	FLAT:_pfnCreateNamedEntity
	DD	FLAT:_pfnMakeStatic
	DD	FLAT:_pfnEntIsOnFloor
	DD	FLAT:_pfnDropToFloor
	DD	FLAT:_pfnWalkMove
	DD	FLAT:_pfnSetOrigin
	DD	FLAT:_SV_StartSound
	DD	FLAT:_pfnEmitAmbientSound
	DD	FLAT:_pfnTraceLine
	DD	FLAT:_pfnTraceToss
	DD	FLAT:_pfnTraceMonsterHull
	DD	FLAT:_pfnTraceHull
	DD	FLAT:_pfnTraceModel
	DD	FLAT:_pfnTraceTexture
	DD	FLAT:_pfnTraceSphere
	DD	FLAT:_pfnGetAimVector
	DD	FLAT:_pfnServerCommand
	DD	FLAT:_pfnServerExecute
	DD	FLAT:_pfnClientCommand
	DD	FLAT:_pfnParticleEffect
	DD	FLAT:_pfnLightStyle
	DD	FLAT:_pfnDecalIndex
	DD	FLAT:_SV_PointContents
	DD	FLAT:_pfnMessageBegin
	DD	FLAT:_pfnMessageEnd
	DD	FLAT:_pfnWriteByte
	DD	FLAT:_pfnWriteChar
	DD	FLAT:_pfnWriteShort
	DD	FLAT:_pfnWriteLong
	DD	FLAT:_pfnWriteAngle
	DD	FLAT:_pfnWriteCoord
	DD	FLAT:_pfnWriteString
	DD	FLAT:_pfnWriteEntity
	DD	FLAT:_pfnCvar_RegisterServerVariable
	DD	FLAT:_Cvar_VariableValue
	DD	FLAT:_Cvar_VariableString
	DD	FLAT:_Cvar_SetValue
	DD	FLAT:_Cvar_Set
	DD	FLAT:_pfnAlertMessage
	DD	FLAT:_pfnEngineFprintf
	DD	FLAT:_pfnPvAllocEntPrivateData
	DD	FLAT:_pfnPvEntPrivateData
	DD	FLAT:_SV_FreePrivateData
	DD	FLAT:_SV_GetString
	DD	FLAT:_SV_AllocString
	DD	FLAT:_pfnGetVarsOfEnt
	DD	FLAT:_pfnPEntityOfEntOffset
	DD	FLAT:_pfnEntOffsetOfPEntity
	DD	FLAT:_pfnIndexOfEdict
	DD	FLAT:_pfnPEntityOfEntIndex
	DD	FLAT:_pfnFindEntityByVars
	DD	FLAT:_pfnGetModelPtr
	DD	FLAT:_pfnRegUserMsg
	DD	FLAT:_pfnAnimationAutomove
	DD	FLAT:_pfnGetBonePosition
	DD	FLAT:_pfnFunctionFromName
	DD	FLAT:_pfnNameForFunction
	DD	FLAT:_pfnClientPrintf
	DD	FLAT:_pfnServerPrint
	DD	FLAT:_Cmd_Args
	DD	FLAT:_Cmd_Argv
	DD	FLAT:_Cmd_Argc
	DD	FLAT:_pfnGetAttachment
	DD	FLAT:_CRC32_Init
	DD	FLAT:_CRC32_ProcessBuffer
	DD	FLAT:_CRC32_ProcessByte
	DD	FLAT:_CRC32_Final
	DD	FLAT:_COM_RandomLong
	DD	FLAT:_COM_RandomFloat
	DD	FLAT:_pfnSetView
	DD	FLAT:_pfnTime
	DD	FLAT:_pfnCrosshairAngle
	DD	FLAT:_COM_LoadFileForMe
	DD	FLAT:_COM_FreeFile
	DD	FLAT:_pfnEndSection
	DD	FLAT:_COM_CompareFileTime
	DD	FLAT:_pfnGetGameDir
	DD	FLAT:_pfnCvar_RegisterEngineVariable
	DD	FLAT:_pfnFadeClientVolume
	DD	FLAT:_pfnSetClientMaxspeed
	DD	FLAT:_SV_FakeConnect
	DD	FLAT:_pfnRunPlayerMove
	DD	FLAT:_pfnNumberOfEntities
	DD	FLAT:_pfnGetInfoKeyBuffer
	DD	FLAT:_Info_ValueForKey
	DD	FLAT:_pfnSetValueForKey
	DD	FLAT:_pfnSetClientKeyValue
	DD	FLAT:_pfnIsMapValid
	DD	FLAT:_pfnStaticDecal
	DD	FLAT:_SV_GenericIndex
	DD	FLAT:_pfnGetPlayerUserId
	DD	FLAT:_pfnBuildSoundMsg
	DD	FLAT:_pfnIsDedicatedServer
	DD	FLAT:_pfnCVarGetPointer
	DD	FLAT:_pfnGetPlayerWONId
	DD	FLAT:_Info_RemoveKey
	DD	FLAT:_pfnGetPhysicsKeyValue
	DD	FLAT:_pfnSetPhysicsKeyValue
	DD	FLAT:_pfnGetPhysicsInfoString
	DD	FLAT:_pfnPrecacheEvent
	DD	FLAT:_SV_PlaybackEventFull
	DD	FLAT:_pfnSetFatPVS
	DD	FLAT:_pfnSetFatPAS
	DD	FLAT:_pfnCheckVisibility
	DD	FLAT:_Delta_SetField
	DD	FLAT:_Delta_UnsetField
	DD	FLAT:_Delta_AddEncoder
	DD	FLAT:_pfnGetCurrentPlayer
	DD	FLAT:_pfnCanSkipPlayer
	DD	FLAT:_Delta_FindField
	DD	FLAT:_Delta_SetFieldByIndex
	DD	FLAT:_Delta_UnsetFieldByIndex
	DD	FLAT:_pfnSetGroupMask
	DD	FLAT:_pfnCreateInstancedBaseline
	DD	FLAT:_pfnCVarDirectSet
	DD	FLAT:_pfnForceUnmodified
	DD	FLAT:_pfnGetPlayerStats
	DD	FLAT:_Cmd_AddServerCommand
	DD	FLAT:_pfnVoice_GetClientListening
	DD	FLAT:_pfnVoice_SetClientListening
	DD	FLAT:_pfnGetPlayerAuthId
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnQueryClientCvarValue
	DD	FLAT:_pfnQueryClientCvarValue2
	DD	FLAT:_COM_CheckParm
$SG139445 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139446 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139449 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139453 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139454 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139455 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139467 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139468 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139469 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139473 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139477 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139481 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139483 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139486 DB	'origin', 00H
	ORG $+5
$SG139487 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139488 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139491 DB	'light', 00H
	ORG $+6
$SG139492 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139493 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139497 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139499 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139501 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139517 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139535 DB	'sv_wateralpha', 00H
	ORG $+2
$SG139536 DB	'sv_skycolor_r', 00H
	ORG $+2
$SG139537 DB	'sv_skycolor_g', 00H
	ORG $+2
$SG139538 DB	'sv_skycolor_b', 00H
	ORG $+6
$SG139551 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139556 DB	'sv_background', 00H
	ORG $+6
$SG139558 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139560 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139561 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139597 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+1
$SG139600 DB	'GetEntityAPI', 00H
	ORG $+3
$SG139601 DB	'GetEntityAPI2', 00H
	ORG $+6
$SG139604 DB	'^1Error:^7 SV_LoadProgs: failed to get address of GetEnt'
	DB	'ityAPI proc', 0aH, 00H
	ORG $+3
$SG139607 DB	'^1Error:^7 SV_LoadProgs: failed to get address of GiveFn'
	DB	'ptrsToDll proc', 0aH, 00H
$SG139611 DB	'^3Warning:^7 SV_LoadProgs: new interface version %i shou'
	DB	'ld be %i', 0aH, 00H
	ORG $+2
$SG139616 DB	'^3Warning:^7 SV_LoadProgs: interface version %i should b'
	DB	'e %i', 0aH, 00H
	ORG $+2
$SG139623 DB	'^3Warning:^7 SV_LoadProgs: couldn''t get physics API', 0aH
	DB	00H
	ORG $+3
$SG139631 DB	'Server Strings', 00H
	ORG $+5
$SG139625 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139626 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139627 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
	ORG $+5
$SG139630 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_game.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_create_world$ = -2068					; size = 4
tv69 = -2064						; size = 4
_inhibited$ = -2060					; size = 4
_ent$ = -2056						; size = 4
_token$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_mapname$ = 8						; size = 4
_entities$ = 12						; size = 4
_SV_LoadFromFile PROC

; 4647 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2068				; 00000814H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4648 : 	char	token[2048];
; 4649 : 	qboolean	create_world = true;

	mov	DWORD PTR _create_world$[ebp], 1

; 4650 : 	int	inhibited;
; 4651 : 	edict_t	*ent;
; 4652 : 
; 4653 : 	Assert( entities != NULL );

	cmp	DWORD PTR _entities$[ebp], 0
	je	SHORT $LN13@SV_LoadFro
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN14@SV_LoadFro
$LN13@SV_LoadFro:
	mov	DWORD PTR tv69[ebp], 0
$LN14@SV_LoadFro:
	push	0
	push	4653					; 0000122dH
	push	OFFSET $SG139517
	push	OFFSET $SG139518
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 4654 : 
; 4655 : 	// user dll can override spawn entities function (Xash3D extension)
; 4656 : 	if( !svgame.physFuncs.SV_LoadEntities || !svgame.physFuncs.SV_LoadEntities( mapname, entities ))

	cmp	DWORD PTR _svgame+19472, 0
	je	SHORT $LN5@SV_LoadFro
	mov	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	DWORD PTR _svgame+19472
	add	esp, 8
	test	eax, eax
	jne	$LN4@SV_LoadFro
$LN5@SV_LoadFro:

; 4657 : 	{
; 4658 : 		inhibited = 0;

	mov	DWORD PTR _inhibited$[ebp], 0
$LN15@SV_LoadFro:

; 4659 : 
; 4660 : 		// parse ents
; 4661 : 		while(( entities = COM_ParseFile( entities, token )) != NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _entities$[ebp], eax
	cmp	DWORD PTR _entities$[ebp], 0
	je	$LN3@SV_LoadFro

; 4662 : 		{
; 4663 : 			if( token[0] != '{' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _token$[ebp+eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN6@SV_LoadFro

; 4664 : 				Host_Error( "ED_LoadFromFile: found %s when expecting {\n", token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	push	OFFSET $SG139522
	call	_Host_Error
	add	esp, 8
$LN6@SV_LoadFro:

; 4665 : 
; 4666 : 			if( create_world )

	cmp	DWORD PTR _create_world$[ebp], 0
	je	SHORT $LN7@SV_LoadFro

; 4667 : 			{
; 4668 : 				create_world = false;

	mov	DWORD PTR _create_world$[ebp], 0

; 4669 : 				ent = EDICT_NUM( 0 ); // already initialized

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 4670 : 			}

	jmp	SHORT $LN8@SV_LoadFro
$LN7@SV_LoadFro:

; 4671 : 			else ent = SV_AllocEdict();

	call	_SV_AllocEdict
	mov	DWORD PTR _ent$[ebp], eax
$LN8@SV_LoadFro:

; 4672 : 
; 4673 : 			if( !SV_ParseEdict( &entities, ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	call	_SV_ParseEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_LoadFro

; 4674 : 				continue;

	jmp	$LN15@SV_LoadFro
$LN9@SV_LoadFro:

; 4675 : 
; 4676 : 			if( svgame.dllFuncs.pfnSpawn( ent ) == -1 )

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19244
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN11@SV_LoadFro

; 4677 : 			{
; 4678 : 				// game rejected the spawn
; 4679 : 				if( !FBitSet( ent->v.flags, FL_KILLME ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 1073741824				; 40000000H
	jne	SHORT $LN11@SV_LoadFro

; 4680 : 				{
; 4681 : 					SV_FreeEdict( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_FreeEdict
	add	esp, 4

; 4682 : 					inhibited++;

	mov	eax, DWORD PTR _inhibited$[ebp]
	add	eax, 1
	mov	DWORD PTR _inhibited$[ebp], eax
$LN11@SV_LoadFro:

; 4683 : 				}
; 4684 : 			}
; 4685 : 		}

	jmp	$LN15@SV_LoadFro
$LN3@SV_LoadFro:

; 4686 : 
; 4687 : 		Con_DPrintf( "\n%i entities inhibited\n", inhibited );

	mov	ecx, DWORD PTR _inhibited$[ebp]
	push	ecx
	push	OFFSET $SG139528
	call	_Con_DPrintf
	add	esp, 8
$LN4@SV_LoadFro:

; 4688 : 	}
; 4689 : 
; 4690 : 	// reset world origin and angles for some reason
; 4691 : 	VectorClear( svgame.edicts->v.origin );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+136], xmm0

; 4692 : 	VectorClear( svgame.edicts->v.angles );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+208], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+7928
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+208], xmm0

; 4693 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadFromFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pstart$1 = -6440					; size = 4
_adjust_origin$ = -6436					; size = 4
_flYawAngle$2 = -6432					; size = 4
_classname$ = -6428					; size = 4
_numpairs$ = -6424					; size = 4
_i$ = -6420						; size = 4
_pkvd$ = -6416						; size = 4096
_origin$ = -2320					; size = 12
_token$ = -2308						; size = 2048
_keyname$3 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_pfile$ = 8						; size = 4
_ent$ = 12						; size = 4
_SV_ParseEdict PROC

; 4489 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 6440				; 00001928H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4490 : 	KeyValueData	pkvd[256]; // per one entity
; 4491 : 	qboolean		adjust_origin = false;

	mov	DWORD PTR _adjust_origin$[ebp], 0

; 4492 : 	int		i, numpairs = 0;

	mov	DWORD PTR _numpairs$[ebp], 0

; 4493 : 	char		*classname = NULL;

	mov	DWORD PTR _classname$[ebp], 0
$LN43@SV_ParseEd:

; 4494 : 	char		token[2048];
; 4495 : 	vec3_t		origin;
; 4496 : 
; 4497 : 	// go through all the dictionary pairs
; 4498 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@SV_ParseEd

; 4499 : 	{	
; 4500 : 		string	keyname;
; 4501 : 
; 4502 : 		// parse key
; 4503 : 		if(( *pfile = COM_ParseFile( *pfile, token )) == NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN10@SV_ParseEd

; 4504 : 			Host_Error( "ED_ParseEdict: EOF without closing brace\n" );

	push	OFFSET $SG139433
	call	_Host_Error
	add	esp, 4
$LN10@SV_ParseEd:

; 4505 : 		if( token[0] == '}' ) break; // end of desc

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN11@SV_ParseEd
	jmp	$LN3@SV_ParseEd
$LN11@SV_ParseEd:

; 4506 : 
; 4507 : 		Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyname$3[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 4508 : 
; 4509 : 		// parse value	
; 4510 : 		if(( *pfile = COM_ParseFile( *pfile, token )) == NULL ) 

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	edx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN12@SV_ParseEd

; 4511 : 			Host_Error( "ED_ParseEdict: EOF without closing brace\n" );

	push	OFFSET $SG139436
	call	_Host_Error
	add	esp, 4
$LN12@SV_ParseEd:

; 4512 : 
; 4513 : 		if( token[0] == '}' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _token$[ebp+edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN13@SV_ParseEd

; 4514 : 			Host_Error( "ED_ParseEdict: closing brace without data\n" );

	push	OFFSET $SG139438
	call	_Host_Error
	add	esp, 4
$LN13@SV_ParseEd:

; 4515 : 
; 4516 : 		// ignore attempts to set key ""
; 4517 : 		if( !keyname[0] ) continue;

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _keyname$3[ebp+edx]
	test	eax, eax
	jne	SHORT $LN14@SV_ParseEd
	jmp	$LN43@SV_ParseEd
$LN14@SV_ParseEd:

; 4518 : 
; 4519 : 		// "wad" field is already handled
; 4520 : 		if( !Q_strcmp( keyname, "wad" ))

	push	99999					; 0001869fH
	push	OFFSET $SG139441
	lea	ecx, DWORD PTR _keyname$3[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@SV_ParseEd

; 4521 : 			continue;

	jmp	$LN43@SV_ParseEd
$LN15@SV_ParseEd:

; 4522 : 
; 4523 : 		// keynames with a leading underscore are used for
; 4524 : 		// utility comments and are immediately discarded by engine
; 4525 : 		if( FBitSet( world.flags, FWORLD_SKYSPHERE ) && keyname[0] == '_' )

	mov	edx, DWORD PTR _world+4
	and	edx, 1
	je	SHORT $LN16@SV_ParseEd
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _keyname$3[ebp+ecx]
	cmp	edx, 95					; 0000005fH
	jne	SHORT $LN16@SV_ParseEd

; 4526 : 			continue;

	jmp	$LN43@SV_ParseEd
$LN16@SV_ParseEd:

; 4527 : 
; 4528 : 		// ignore attempts to set value ""
; 4529 : 		if( !token[0] ) continue;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN17@SV_ParseEd
	jmp	$LN43@SV_ParseEd
$LN17@SV_ParseEd:

; 4530 : 
; 4531 : 		// create keyvalue strings
; 4532 : 		pkvd[numpairs].szClassName = ""; // unknown at this moment

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax], OFFSET $SG139444

; 4533 : 		pkvd[numpairs].szKeyName = copystring( keyname );

	push	4533					; 000011b5H
	push	OFFSET $SG139445
	lea	ecx, DWORD PTR _keyname$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+4], eax

; 4534 : 		pkvd[numpairs].szValue = copystring( token );

	push	4534					; 000011b6H
	push	OFFSET $SG139446
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax

; 4535 : 		pkvd[numpairs].fHandled = false;		

	mov	edx, DWORD PTR _numpairs$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+12], 0

; 4536 : 
; 4537 : 		if( !Q_strcmp( keyname, "classname" ) && classname == NULL )

	push	99999					; 0001869fH
	push	OFFSET $SG139448
	lea	eax, DWORD PTR _keyname$3[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@SV_ParseEd
	cmp	DWORD PTR _classname$[ebp], 0
	jne	SHORT $LN18@SV_ParseEd

; 4538 : 			classname = copystring( pkvd[numpairs].szValue );

	push	4538					; 000011baH
	push	OFFSET $SG139449
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	DWORD PTR _classname$[ebp], eax
$LN18@SV_ParseEd:

; 4539 : 		if( ++numpairs >= 256 ) break;

	mov	ecx, DWORD PTR _numpairs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numpairs$[ebp], ecx
	cmp	DWORD PTR _numpairs$[ebp], 256		; 00000100H
	jl	SHORT $LN19@SV_ParseEd
	jmp	SHORT $LN3@SV_ParseEd
$LN19@SV_ParseEd:

; 4540 : 	}

	jmp	$LN43@SV_ParseEd
$LN3@SV_ParseEd:

; 4541 : 	
; 4542 : 	ent = SV_AllocPrivateData( ent, ALLOC_STRING( classname ));

	mov	edx, DWORD PTR _classname$[ebp]
	push	edx
	call	_SV_AllocString
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_AllocPrivateData
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax

; 4543 : 
; 4544 : 	if( !SV_IsValidEdict( ent ) || FBitSet( ent->v.flags, FL_KILLME ))

	push	4544					; 000011c0H
	push	OFFSET $SG139453
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@SV_ParseEd
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN20@SV_ParseEd
$LN21@SV_ParseEd:

; 4545 : 	{
; 4546 : 		// release allocated strings
; 4547 : 		for( i = 0; i < numpairs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SV_ParseEd
$LN4@SV_ParseEd:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@SV_ParseEd:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numpairs$[ebp]
	jge	SHORT $LN5@SV_ParseEd

; 4548 : 		{
; 4549 : 			Mem_Free( pkvd[i].szKeyName );

	push	4549					; 000011c5H
	push	OFFSET $SG139454
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4550 : 			Mem_Free( pkvd[i].szValue );

	push	4550					; 000011c6H
	push	OFFSET $SG139455
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+8]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4551 : 		}

	jmp	SHORT $LN4@SV_ParseEd
$LN5@SV_ParseEd:

; 4552 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_ParseEd
$LN20@SV_ParseEd:

; 4553 : 	}
; 4554 : 
; 4555 : 	if( FBitSet( ent->v.flags, FL_CUSTOMENTITY ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 536870912				; 20000000H
	je	$LN22@SV_ParseEd

; 4556 : 	{
; 4557 : 		if( numpairs < 256 )

	cmp	DWORD PTR _numpairs$[ebp], 256		; 00000100H
	jge	SHORT $LN23@SV_ParseEd

; 4558 : 		{
; 4559 : 			pkvd[numpairs].szClassName = "custom";

	mov	eax, DWORD PTR _numpairs$[ebp]
	shl	eax, 4
	mov	DWORD PTR _pkvd$[ebp+eax], OFFSET $SG139458

; 4560 : 			pkvd[numpairs].szKeyName = "customclass";

	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+4], OFFSET $SG139459

; 4561 : 			pkvd[numpairs].szValue = classname;

	mov	edx, DWORD PTR _numpairs$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _classname$[ebp]
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax

; 4562 : 			pkvd[numpairs].fHandled = false;

	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+12], 0

; 4563 : 			numpairs++;

	mov	edx, DWORD PTR _numpairs$[ebp]
	add	edx, 1
	mov	DWORD PTR _numpairs$[ebp], edx
$LN23@SV_ParseEd:

; 4564 : 		}
; 4565 : 
; 4566 : 		// clear it now - no longer used
; 4567 : 		ClearBits( ent->v.flags, FL_CUSTOMENTITY );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, -536870913				; dfffffffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+548], ecx
$LN22@SV_ParseEd:

; 4568 : 	}
; 4569 : 
; 4570 : #ifdef HACKS_RELATED_HLMODS
; 4571 : 	// chemical existence have broked changelevels
; 4572 : 	if( !Q_stricmp( GI->gamedir, "ce" ))

	push	99999					; 0001869fH
	push	OFFSET $SG139461
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_ParseEd

; 4573 : 	{
; 4574 : 	 	if( !Q_stricmp( sv.name, "ce08_02" ) && !Q_stricmp( classname, "info_player_start_force" ))

	push	99999					; 0001869fH
	push	OFFSET $SG139463
	push	OFFSET _sv+56
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_ParseEd
	push	99999					; 0001869fH
	push	OFFSET $SG139464
	mov	ecx, DWORD PTR _classname$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_ParseEd

; 4575 : 			adjust_origin = true;

	mov	DWORD PTR _adjust_origin$[ebp], 1
$LN25@SV_ParseEd:

; 4576 : 	}
; 4577 : #endif
; 4578 : 
; 4579 : 	for( i = 0; i < numpairs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@SV_ParseEd
$LN7@SV_ParseEd:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@SV_ParseEd:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numpairs$[ebp]
	jge	$LN8@SV_ParseEd

; 4580 : 	{
; 4581 : 		if( !Q_strcmp( pkvd[i].szKeyName, "angle" ))

	push	99999					; 0001869fH
	push	OFFSET $SG139466
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN32@SV_ParseEd

; 4582 : 		{
; 4583 : 			float	flYawAngle = Q_atof( pkvd[i].szValue );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+8]
	push	ecx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR _flYawAngle$2[ebp]

; 4584 : 
; 4585 : 			Mem_Free( pkvd[i].szKeyName ); // will be replace with 'angles'

	push	4585					; 000011e9H
	push	OFFSET $SG139467
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4586 : 			Mem_Free( pkvd[i].szValue );	// release old value, so we don't need these

	push	4586					; 000011eaH
	push	OFFSET $SG139468
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4587 : 			pkvd[i].szKeyName = copystring( "angles" );

	push	4587					; 000011ebH
	push	OFFSET $SG139469
	push	OFFSET $SG139470
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+4], eax

; 4588 : 
; 4589 : 			if( flYawAngle >= 0.0f )

	movss	xmm0, DWORD PTR _flYawAngle$2[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN27@SV_ParseEd

; 4590 : 				pkvd[i].szValue = copystring( va( "%g %g %g", ent->v.angles[0], flYawAngle, ent->v.angles[2] ));

	push	4590					; 000011eeH
	push	OFFSET $SG139473
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+208]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _flYawAngle$2[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+208]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG139474
	call	_va
	add	esp, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax
	jmp	$LN32@SV_ParseEd
$LN27@SV_ParseEd:

; 4591 : 			else if( flYawAngle == -1.0f )

	movss	xmm0, DWORD PTR _flYawAngle$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@SV_ParseEd

; 4592 : 				pkvd[i].szValue = copystring( "-90 0 0" );

	push	4592					; 000011f0H
	push	OFFSET $SG139477
	push	OFFSET $SG139478
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
	jmp	SHORT $LN32@SV_ParseEd
$LN29@SV_ParseEd:

; 4593 : 			else if( flYawAngle == -2.0f )

	movss	xmm0, DWORD PTR _flYawAngle$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@c0000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@SV_ParseEd

; 4594 : 				pkvd[i].szValue = copystring( "90 0 0" );

	push	4594					; 000011f2H
	push	OFFSET $SG139481
	push	OFFSET $SG139482
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
	jmp	SHORT $LN32@SV_ParseEd
$LN31@SV_ParseEd:

; 4595 : 			else pkvd[i].szValue = copystring( "0 0 0" ); // technically an error

	push	4595					; 000011f3H
	push	OFFSET $SG139483
	push	OFFSET $SG139484
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
$LN32@SV_ParseEd:

; 4596 : 		}
; 4597 : 
; 4598 : #ifdef HACKS_RELATED_HLMODS
; 4599 : 		if( adjust_origin && !Q_strcmp( pkvd[i].szKeyName, "origin" ))

	cmp	DWORD PTR _adjust_origin$[ebp], 0
	je	$LN33@SV_ParseEd
	push	99999					; 0001869fH
	push	OFFSET $SG139486
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN33@SV_ParseEd

; 4600 : 		{
; 4601 : 			char	*pstart = pkvd[i].szValue;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	mov	DWORD PTR _pstart$1[ebp], edx

; 4602 : 
; 4603 : 			COM_ParseVector( &pstart, origin, 3 );

	push	3
	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pstart$1[ebp]
	push	ecx
	call	_COM_ParseVector
	add	esp, 12					; 0000000cH

; 4604 : 			Mem_Free( pkvd[i].szValue );	// release old value, so we don't need these

	push	4604					; 000011fcH
	push	OFFSET $SG139487
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+8]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4605 : 			pkvd[i].szValue = copystring( va( "%g %g %g", origin[0], origin[1], origin[2] - 16.0f ));

	push	4605					; 000011fdH
	push	OFFSET $SG139488
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@41800000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _origin$[ebp+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _origin$[ebp+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG139489
	call	_va
	add	esp, 28					; 0000001cH
	push	eax
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
$LN33@SV_ParseEd:

; 4606 : 		}
; 4607 : #endif
; 4608 : 		if( !Q_strcmp( pkvd[i].szKeyName, "light" ))

	push	99999					; 0001869fH
	push	OFFSET $SG139491
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@SV_ParseEd

; 4609 : 		{
; 4610 : 			Mem_Free( pkvd[i].szKeyName );

	push	4610					; 00001202H
	push	OFFSET $SG139492
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 4611 : 			pkvd[i].szKeyName = copystring( "light_level" );

	push	4611					; 00001203H
	push	OFFSET $SG139493
	push	OFFSET $SG139494
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+4], eax
$LN34@SV_ParseEd:

; 4612 : 		}
; 4613 : 
; 4614 : 		if( !pkvd[i].fHandled )

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	cmp	DWORD PTR _pkvd$[ebp+edx+12], 0
	jne	SHORT $LN35@SV_ParseEd

; 4615 : 		{
; 4616 : 			pkvd[i].szClassName = classname;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _classname$[ebp]
	mov	DWORD PTR _pkvd$[ebp+eax], ecx

; 4617 : 			svgame.dllFuncs.pfnKeyValue( ent, &pkvd[i] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _pkvd$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19264
	add	esp, 8
$LN35@SV_ParseEd:

; 4618 : 		}
; 4619 : 
; 4620 : 		// no reason to keep this data
; 4621 : 		if( Mem_IsAllocatedExt( host.mempool, pkvd[i].szKeyName ))

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@SV_ParseEd

; 4622 : 			Mem_Free( pkvd[i].szKeyName );

	push	4622					; 0000120eH
	push	OFFSET $SG139497
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN36@SV_ParseEd:

; 4623 : 
; 4624 : 		if( Mem_IsAllocatedExt( host.mempool, pkvd[i].szValue ))

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@SV_ParseEd

; 4625 : 			Mem_Free( pkvd[i].szValue );

	push	4625					; 00001211H
	push	OFFSET $SG139499
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN37@SV_ParseEd:

; 4626 : 	}

	jmp	$LN7@SV_ParseEd
$LN8@SV_ParseEd:

; 4627 : 
; 4628 : 	if( classname && Mem_IsAllocatedExt( host.mempool, classname ))

	cmp	DWORD PTR _classname$[ebp], 0
	je	SHORT $LN38@SV_ParseEd
	mov	eax, DWORD PTR _classname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@SV_ParseEd

; 4629 : 		Mem_Free( classname );

	push	4629					; 00001215H
	push	OFFSET $SG139501
	mov	edx, DWORD PTR _classname$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN38@SV_ParseEd:

; 4630 : 
; 4631 : 	return true;

	mov	eax, 1
$LN1@SV_ParseEd:

; 4632 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pfnEngineStub PROC

; 4314 : {

	push	ebp
	mov	ebp, esp

; 4315 : }

	pop	ebp
	ret	0
_pfnEngineStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_player$ = 8						; size = 4
_cvarName$ = 12						; size = 4
_requestID$ = 16					; size = 4
_pfnQueryClientCvarValue2 PROC

; 4286 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4287 : 	sv_client_t *cl;
; 4288 : 
; 4289 : 	if( !COM_CheckString( cvarName ))

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnQueryCl

; 4290 : 		return;

	jmp	$LN1@pfnQueryCl
$LN2@pfnQueryCl:

; 4291 : 
; 4292 : 	if(( cl = SV_ClientFromEdict( player, true )) != NULL )

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	je	SHORT $LN3@pfnQueryCl

; 4293 : 	{
; 4294 : 		MSG_BeginServerCmd( &cl->netchan.message, svc_querycvarvalue2 );

	push	0
	push	1
	push	58					; 0000003aH
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 4295 : 		MSG_WriteLong( &cl->netchan.message, requestID );

	mov	eax, DWORD PTR _requestID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 4296 : 		MSG_WriteString( &cl->netchan.message, cvarName );

	mov	edx, DWORD PTR _cvarName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 4297 : 	}

	jmp	SHORT $LN1@pfnQueryCl
$LN3@pfnQueryCl:

; 4298 : 	else
; 4299 : 	{
; 4300 : 		if( svgame.dllFuncs2.pfnCvarValue2 )

	cmp	DWORD PTR _svgame+19456, 0
	je	SHORT $LN5@pfnQueryCl

; 4301 : 			svgame.dllFuncs2.pfnCvarValue2( player, requestID, cvarName, "Bad Player" );

	push	OFFSET $SG139398
	mov	ecx, DWORD PTR _cvarName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _requestID$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	DWORD PTR _svgame+19456
	add	esp, 16					; 00000010H
$LN5@pfnQueryCl:

; 4302 : 		Con_Printf( S_ERROR "QueryClientCvarValue: tried to send to a non-client!\n" );

	push	OFFSET $SG139399
	call	_Con_Printf
	add	esp, 4
$LN1@pfnQueryCl:

; 4303 : 	}
; 4304 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnQueryClientCvarValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_player$ = 8						; size = 4
_cvarName$ = 12						; size = 4
_pfnQueryClientCvarValue PROC

; 4259 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4260 : 	sv_client_t *cl;
; 4261 : 
; 4262 : 	if( !COM_CheckString( cvarName ))

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnQueryCl

; 4263 : 		return;

	jmp	SHORT $LN1@pfnQueryCl
$LN2@pfnQueryCl:

; 4264 : 
; 4265 : 	if(( cl = SV_ClientFromEdict( player, true )) != NULL )

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	je	SHORT $LN3@pfnQueryCl

; 4266 : 	{
; 4267 : 		MSG_BeginServerCmd( &cl->netchan.message, svc_querycvarvalue );

	push	0
	push	1
	push	57					; 00000039H
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 4268 : 		MSG_WriteString( &cl->netchan.message, cvarName );

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 4269 : 	}

	jmp	SHORT $LN1@pfnQueryCl
$LN3@pfnQueryCl:

; 4270 : 	else
; 4271 : 	{
; 4272 : 		if( svgame.dllFuncs2.pfnCvarValue )

	cmp	DWORD PTR _svgame+19452, 0
	je	SHORT $LN5@pfnQueryCl

; 4273 : 			svgame.dllFuncs2.pfnCvarValue( player, "Bad Player" );

	push	OFFSET $SG139381
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	call	DWORD PTR _svgame+19452
	add	esp, 8
$LN5@pfnQueryCl:

; 4274 : 		Con_Printf( S_ERROR "QueryClientCvarValue: tried to send to a non-client!\n" );

	push	OFFSET $SG139382
	call	_Con_Printf
	add	esp, 4
$LN1@pfnQueryCl:

; 4275 : 	}
; 4276 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnQueryClientCvarValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_pfnGetPlayerAuthId PROC

; 4247 : {

	push	ebp
	mov	ebp, esp

; 4248 : 	return SV_GetClientIDString( SV_ClientFromEdict( e, false ));

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	push	eax
	call	_SV_GetClientIDString
	add	esp, 4

; 4249 : }

	pop	ebp
	ret	0
_pfnGetPlayerAuthId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iReceiver$ = 8						; size = 4
_iSender$ = 12						; size = 4
_bListen$ = 16						; size = 4
_pfnVoice_SetClientListening PROC

; 4224 : {

	push	ebp
	mov	ebp, esp

; 4225 : 	iReceiver -= 1;

	mov	eax, DWORD PTR _iReceiver$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iReceiver$[ebp], eax

; 4226 : 	iSender -= 1;

	mov	ecx, DWORD PTR _iSender$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iSender$[ebp], ecx

; 4227 : 
; 4228 : 	if( iReceiver < 0 || iReceiver >= svs.maxclients || iSender < 0 || iSender > svs.maxclients )

	cmp	DWORD PTR _iReceiver$[ebp], 0
	jl	SHORT $LN3@pfnVoice_S
	mov	edx, DWORD PTR _iReceiver$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jge	SHORT $LN3@pfnVoice_S
	cmp	DWORD PTR _iSender$[ebp], 0
	jl	SHORT $LN3@pfnVoice_S
	mov	eax, DWORD PTR _iSender$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN2@pfnVoice_S
$LN3@pfnVoice_S:

; 4229 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnVoice_S
$LN2@pfnVoice_S:

; 4230 : 
; 4231 : 	if( bListen ) SetBits( svs.clients[iSender].listeners, BIT( iReceiver ));

	cmp	DWORD PTR _bListen$[ebp], 0
	je	SHORT $LN4@pfnVoice_S
	imul	edx, DWORD PTR _iSender$[ebp], 287560
	mov	eax, 1
	mov	ecx, DWORD PTR _iReceiver$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _svs+33344
	or	eax, DWORD PTR [ecx+edx+265508]
	imul	edx, DWORD PTR _iSender$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+edx+265508], eax
	jmp	SHORT $LN5@pfnVoice_S
$LN4@pfnVoice_S:

; 4232 : 	else ClearBits( svs.clients[iSender].listeners, BIT( iReceiver ));

	imul	edx, DWORD PTR _iSender$[ebp], 287560
	mov	eax, 1
	mov	ecx, DWORD PTR _iReceiver$[ebp]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _svs+33344
	and	eax, DWORD PTR [ecx+edx+265508]
	imul	edx, DWORD PTR _iSender$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+edx+265508], eax
$LN5@pfnVoice_S:

; 4233 : 
; 4234 : 	return true;

	mov	eax, 1
$LN1@pfnVoice_S:

; 4235 : }

	pop	ebp
	ret	0
_pfnVoice_SetClientListening ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv76 = -4						; size = 4
_iReceiver$ = 8						; size = 4
_iSender$ = 12						; size = 4
_pfnVoice_GetClientListening PROC

; 4207 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4208 : 	iReceiver -= 1;

	mov	eax, DWORD PTR _iReceiver$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iReceiver$[ebp], eax

; 4209 : 	iSender -= 1;

	mov	ecx, DWORD PTR _iSender$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iSender$[ebp], ecx

; 4210 : 
; 4211 : 	if( iReceiver < 0 || iReceiver >= svs.maxclients || iSender < 0 || iSender > svs.maxclients )

	cmp	DWORD PTR _iReceiver$[ebp], 0
	jl	SHORT $LN3@pfnVoice_G
	mov	edx, DWORD PTR _iReceiver$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jge	SHORT $LN3@pfnVoice_G
	cmp	DWORD PTR _iSender$[ebp], 0
	jl	SHORT $LN3@pfnVoice_G
	mov	eax, DWORD PTR _iSender$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN2@pfnVoice_G
$LN3@pfnVoice_G:

; 4212 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnVoice_G
$LN2@pfnVoice_G:

; 4213 : 
; 4214 : 	return (FBitSet( svs.clients[iSender].listeners, BIT( iReceiver )) != 0 );

	imul	edx, DWORD PTR _iSender$[ebp], 287560
	mov	eax, 1
	mov	ecx, DWORD PTR _iReceiver$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _svs+33344
	and	eax, DWORD PTR [ecx+edx+265508]
	je	SHORT $LN5@pfnVoice_G
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN6@pfnVoice_G
$LN5@pfnVoice_G:
	mov	DWORD PTR tv76[ebp], 0
$LN6@pfnVoice_G:
	mov	eax, DWORD PTR tv76[ebp]
$LN1@pfnVoice_G:

; 4215 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnVoice_GetClientListening ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pc$ = -4						; size = 4
_type$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_filename$ = 20						; size = 4
_pfnForceUnmodified PROC

; 4160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 4161 : 	consistency_t	*pc;
; 4162 : 	int		i;
; 4163 : 
; 4164 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@pfnForceUn

; 4165 : 		return;

	jmp	$LN10@pfnForceUn
$LN8@pfnForceUn:

; 4166 : 
; 4167 : 	if( sv.state == ss_loading )

	cmp	DWORD PTR _sv, 1
	jne	$LN9@pfnForceUn

; 4168 : 	{
; 4169 : 		for( i = 0; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnForceUn
$LN2@pfnForceUn:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@pfnForceUn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@pfnForceUn

; 4170 : 		{
; 4171 : 			pc = &sv.consistency_list[i];

	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _sv+415944
	mov	DWORD PTR _pc$[ebp], edx

; 4172 : 
; 4173 : 			if( !pc->filename )

	mov	eax, DWORD PTR _pc$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN11@pfnForceUn

; 4174 : 			{
; 4175 : 				if( mins ) VectorCopy( mins, pc->mins );

	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN13@pfnForceUn
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+20], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+20], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+20], ecx
$LN13@pfnForceUn:

; 4176 : 				if( maxs ) VectorCopy( maxs, pc->maxs );

	cmp	DWORD PTR _maxs$[ebp], 0
	je	SHORT $LN14@pfnForceUn
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+32], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+32], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+32], edx
$LN14@pfnForceUn:

; 4177 : 				pc->filename = SV_CopyString( filename );

	push	4177					; 00001051H
	push	OFFSET $SG139338
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+19560
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [edx], eax

; 4178 : 				pc->check_type = type;

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 4179 : 				return;

	jmp	$LN10@pfnForceUn

; 4180 : 			}

	jmp	SHORT $LN15@pfnForceUn
$LN11@pfnForceUn:

; 4181 : 			else if( !Q_strcmp( filename, pc->filename ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _pc$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@pfnForceUn

; 4182 : 				return;

	jmp	SHORT $LN10@pfnForceUn
$LN15@pfnForceUn:

; 4183 : 		}

	jmp	$LN2@pfnForceUn
$LN3@pfnForceUn:

; 4184 : 		Host_Error( "MAX_MODELS limit exceeded (%d)\n", MAX_MODELS );

	push	1024					; 00000400H
	push	OFFSET $SG139340
	call	_Host_Error
	add	esp, 8

; 4185 : 	}

	jmp	SHORT $LN10@pfnForceUn
$LN9@pfnForceUn:

; 4186 : 	else
; 4187 : 	{
; 4188 : 		for( i = 0; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@pfnForceUn
$LN5@pfnForceUn:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@pfnForceUn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN6@pfnForceUn

; 4189 : 		{
; 4190 : 			pc = &sv.consistency_list[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _sv+415944
	mov	DWORD PTR _pc$[ebp], eax

; 4191 : 			if( !pc->filename ) continue;

	mov	ecx, DWORD PTR _pc$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN16@pfnForceUn
	jmp	SHORT $LN5@pfnForceUn
$LN16@pfnForceUn:

; 4192 : 
; 4193 : 			if( !Q_strcmp( filename, pc->filename ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _pc$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@pfnForceUn

; 4194 : 				return;

	jmp	SHORT $LN10@pfnForceUn
$LN17@pfnForceUn:

; 4195 : 		}

	jmp	SHORT $LN5@pfnForceUn
$LN6@pfnForceUn:

; 4196 : 		Con_Printf( S_ERROR "no precache: %s\n", filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG139343
	call	_Con_Printf
	add	esp, 8
$LN10@pfnForceUn:

; 4197 : 	}
; 4198 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnForceUnmodified ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_ping$ = 12						; size = 4
_packet_loss$ = 16					; size = 4
_pfnGetPlayerStats PROC

; 4140 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4141 : 	sv_client_t	*cl;
; 4142 : 
; 4143 : 	if( packet_loss ) *packet_loss = 0;

	cmp	DWORD PTR _packet_loss$[ebp], 0
	je	SHORT $LN2@pfnGetPlay
	mov	eax, DWORD PTR _packet_loss$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@pfnGetPlay:

; 4144 : 	if( ping ) *ping = 0;

	cmp	DWORD PTR _ping$[ebp], 0
	je	SHORT $LN3@pfnGetPlay
	mov	ecx, DWORD PTR _ping$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@pfnGetPlay:

; 4145 : 
; 4146 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	edx, DWORD PTR _pClient$[ebp]
	push	edx
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN4@pfnGetPlay

; 4147 : 		return;

	jmp	SHORT $LN6@pfnGetPlay
$LN4@pfnGetPlay:

; 4148 : 
; 4149 : 	if( packet_loss ) *packet_loss = cl->packet_loss;

	cmp	DWORD PTR _packet_loss$[ebp], 0
	je	SHORT $LN5@pfnGetPlay
	mov	eax, DWORD PTR _packet_loss$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264968]
	mov	DWORD PTR [eax], edx
$LN5@pfnGetPlay:

; 4150 : 	if( ping ) *ping = cl->latency * 1000;

	cmp	DWORD PTR _ping$[ebp], 0
	je	SHORT $LN6@pfnGetPlay
	mov	eax, DWORD PTR _cl$[ebp]
	movss	xmm0, DWORD PTR [eax+264972]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _ping$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@pfnGetPlay:

; 4151 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_e$ = 8							; size = 4
_pfnGetPlayerUserId PROC

; 4125 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4126 : 	sv_client_t	*cl;
; 4127 : 
; 4128 : 	if(( cl = SV_ClientFromEdict( e, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnGetPlay

; 4129 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnGetPlay
$LN2@pfnGetPlay:

; 4130 : 	return cl->userid;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [ecx+287556]
$LN1@pfnGetPlay:

; 4131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerUserId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pszSection$ = 8					; size = 4
_pfnEndSection PROC

; 4112 : {

	push	ebp
	mov	ebp, esp

; 4113 : 	if( !Q_stricmp( "oem_end_credits", pszSection ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszSection$[ebp]
	push	eax
	push	OFFSET $SG139289
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnEndSect

; 4114 : 		Host_Credits ();

	call	_Host_Credits
	jmp	SHORT $LN1@pfnEndSect
$LN2@pfnEndSect:

; 4115 : 	else Cbuf_AddText( "\ndisconnect\n" );

	push	OFFSET $SG139290
	call	_Cbuf_AddText
	add	esp, 4
$LN1@pfnEndSect:

; 4116 : }

	pop	ebp
	ret	0
_pfnEndSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_classname$ = 8						; size = 4
_baseline$ = 12						; size = 4
_pfnCreateInstancedBaseline PROC

; 4093 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4094 : 	if( !baseline || sv.num_instanced >= MAX_CUSTOM_BASELINES )

	cmp	DWORD PTR _baseline$[ebp], 0
	je	SHORT $LN3@pfnCreateI
	cmp	DWORD PTR _sv+1179348, 64		; 00000040H
	jl	SHORT $LN2@pfnCreateI
$LN3@pfnCreateI:

; 4095 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnCreateI
$LN2@pfnCreateI:

; 4096 : 
; 4097 : 	// g-cont. must sure that classname is really allocated
; 4098 : 	sv.instanced[sv.num_instanced].classname = SV_CopyString( STRING( classname ));

	push	4098					; 00001002H
	push	OFFSET $SG139282
	mov	eax, DWORD PTR _classname$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _svgame+19560
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	imul	edx, DWORD PTR _sv+1179348, 344
	mov	DWORD PTR _sv[edx+1157328], eax

; 4099 : 	sv.instanced[sv.num_instanced].baseline = *baseline;

	imul	edi, DWORD PTR _sv+1179348, 344
	add	edi, OFFSET _sv+1157332
	mov	ecx, 85					; 00000055H
	mov	esi, DWORD PTR _baseline$[ebp]
	rep movsd

; 4100 : 	sv.num_instanced++;

	mov	eax, DWORD PTR _sv+1179348
	add	eax, 1
	mov	DWORD PTR _sv+1179348, eax

; 4101 : 
; 4102 : 	return sv.num_instanced;

	mov	eax, DWORD PTR _sv+1179348
$LN1@pfnCreateI:

; 4103 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_pfnCreateInstancedBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_mask$ = 8						; size = 4
_op$ = 12						; size = 4
_pfnSetGroupMask PROC

; 4081 : {

	push	ebp
	mov	ebp, esp

; 4082 : 	svs.groupmask = mask;

	mov	eax, DWORD PTR _mask$[ebp]
	mov	DWORD PTR _svs+20, eax

; 4083 : 	svs.groupop = op;

	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _svs+24, ecx

; 4084 : }

	pop	ebp
	ret	0
_pfnSetGroupMask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv71 = -8						; size = 4
_cl$ = -4						; size = 4
_player$ = 8						; size = 4
_pfnCanSkipPlayer PROC

; 4050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4051 : 	sv_client_t	*cl;
; 4052 : 
; 4053 : 	if(( cl = SV_ClientFromEdict( player, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnCanSkip

; 4054 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnCanSkip
$LN2@pfnCanSkip:

; 4055 : 
; 4056 : 	return FBitSet( cl->flags, FCL_LOCAL_WEAPONS ) ? true : false;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 32					; 00000020H
	je	SHORT $LN4@pfnCanSkip
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@pfnCanSkip
$LN4@pfnCanSkip:
	mov	DWORD PTR tv71[ebp], 0
$LN5@pfnCanSkip:
	mov	eax, DWORD PTR tv71[ebp]
$LN1@pfnCanSkip:

; 4057 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCanSkipPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv158 = -16						; size = 4
tv139 = -12						; size = 4
_leafnum$ = -8						; size = 4
_i$ = -4						; size = 4
_ent$ = 8						; size = 4
_pset$ = 12						; size = 4
_pfnCheckVisibility PROC

; 3998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3999 : 	int	i, leafnum;
; 4000 : 
; 4001 : 	if( !SV_IsValidEdict( ent ))

	push	4001					; 00000fa1H
	push	OFFSET $SG139247
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnCheckVi

; 4002 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnCheckVi
$LN8@pfnCheckVi:

; 4003 : 
; 4004 : 	// vis not set - fullvis enabled
; 4005 : 	if( !pset ) return 1;

	cmp	DWORD PTR _pset$[ebp], 0
	jne	SHORT $LN9@pfnCheckVi
	mov	eax, 1
	jmp	$LN1@pfnCheckVi
$LN9@pfnCheckVi:

; 4006 : 
; 4007 : 	if( FBitSet( ent->v.flags, FL_CUSTOMENTITY ) && ent->v.owner && FBitSet( ent->v.owner->v.flags, FL_CLIENT ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 536870912				; 20000000H
	je	SHORT $LN10@pfnCheckVi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+536], 0
	je	SHORT $LN10@pfnCheckVi
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8
	je	SHORT $LN10@pfnCheckVi

; 4008 : 		ent = ent->v.owner;	// upcast beams to my owner

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	DWORD PTR _ent$[ebp], edx
$LN10@pfnCheckVi:

; 4009 : 
; 4010 : 	if( ent->headnode < 0 )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jge	$LN11@pfnCheckVi

; 4011 : 	{
; 4012 : 		// check individual leafs
; 4013 : 		for( i = 0; i < ent->num_leafs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnCheckVi
$LN2@pfnCheckVi:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@pfnCheckVi:
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jge	SHORT $LN3@pfnCheckVi

; 4014 : 		{
; 4015 : 			if( CHECKVISBIT( pset, ent->leafnums[i] ))

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+24]
	test	eax, eax
	jl	SHORT $LN18@pfnCheckVi
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+24]
	sar	eax, 3
	mov	ecx, DWORD PTR _pset$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	ecx, WORD PTR [ecx+eax*2+24]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv139[ebp], ecx
	jmp	SHORT $LN19@pfnCheckVi
$LN18@pfnCheckVi:
	mov	DWORD PTR tv139[ebp], 0
$LN19@pfnCheckVi:
	cmp	DWORD PTR tv139[ebp], 0
	je	SHORT $LN13@pfnCheckVi

; 4016 : 				return 1;	// visible passed by leaf

	mov	eax, 1
	jmp	$LN1@pfnCheckVi
$LN13@pfnCheckVi:

; 4017 : 		}

	jmp	SHORT $LN2@pfnCheckVi
$LN3@pfnCheckVi:

; 4018 : 
; 4019 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnCheckVi

; 4020 : 	}

	jmp	$LN1@pfnCheckVi
$LN11@pfnCheckVi:

; 4021 : 	else
; 4022 : 	{
; 4023 : 		for( i = 0; i < MAX_ENT_LEAFS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@pfnCheckVi
$LN5@pfnCheckVi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@pfnCheckVi:
	cmp	DWORD PTR _i$[ebp], 48			; 00000030H
	jge	SHORT $LN6@pfnCheckVi

; 4024 : 		{
; 4025 : 			leafnum = ent->leafnums[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+24]
	mov	DWORD PTR _leafnum$[ebp], edx

; 4026 : 			if( leafnum == -1 ) break;

	cmp	DWORD PTR _leafnum$[ebp], -1
	jne	SHORT $LN14@pfnCheckVi
	jmp	SHORT $LN6@pfnCheckVi
$LN14@pfnCheckVi:

; 4027 : 
; 4028 : 			if( CHECKVISBIT( pset, leafnum ))

	cmp	DWORD PTR _leafnum$[ebp], 0
	jl	SHORT $LN20@pfnCheckVi
	mov	eax, DWORD PTR _leafnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _pset$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	ecx, DWORD PTR _leafnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv158[ebp], ecx
	jmp	SHORT $LN21@pfnCheckVi
$LN20@pfnCheckVi:
	mov	DWORD PTR tv158[ebp], 0
$LN21@pfnCheckVi:
	cmp	DWORD PTR tv158[ebp], 0
	je	SHORT $LN15@pfnCheckVi

; 4029 : 				return 1;	// visible passed by leaf

	mov	eax, 1
	jmp	SHORT $LN1@pfnCheckVi
$LN15@pfnCheckVi:

; 4030 : 		}

	jmp	SHORT $LN5@pfnCheckVi
$LN6@pfnCheckVi:

; 4031 : 
; 4032 : 		// too many leafs for individual check, go by headnode
; 4033 : 		if( !Mod_HeadnodeVisible( &sv.worldmodel->nodes[ent->headnode], pset, &leafnum ))

	lea	edx, DWORD PTR _leafnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _pset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	imul	edx, DWORD PTR [ecx+16], 52
	mov	eax, DWORD PTR _sv+1359676
	add	edx, DWORD PTR [eax+164]
	push	edx
	call	_Mod_HeadnodeVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@pfnCheckVi

; 4034 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnCheckVi
$LN16@pfnCheckVi:

; 4035 : 
; 4036 : 		((edict_t *)ent)->leafnums[ent->num_leafs] = leafnum;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	cx, WORD PTR _leafnum$[ebp]
	mov	WORD PTR [eax+edx*2+24], cx

; 4037 : 		((edict_t *)ent)->num_leafs = (ent->num_leafs + 1) % MAX_ENT_LEAFS;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+20], edx

; 4038 : 
; 4039 : 		return 2;	// visible passed by headnode

	mov	eax, 2
$LN1@pfnCheckVi:

; 4040 : 	}
; 4041 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCheckVisibility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_type$ = 8						; size = 4
_psz$ = 12						; size = 4
_pfnPrecacheEvent PROC

; 3685 : {

	push	ebp
	mov	ebp, esp

; 3686 : 	return (word)SV_EventIndex( psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_SV_EventIndex
	add	esp, 4

; 3687 : }

	pop	ebp
	ret	0
_pfnPrecacheEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pfnGetPhysicsInfoString PROC

; 3663 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3664 : 	sv_client_t	*cl;
; 3665 : 
; 3666 : 	// pfnUserInfoChanged passed
; 3667 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnGetPhys

; 3668 : 	{
; 3669 : 		Con_Printf( S_ERROR "GetPhysicsInfoString: tried to a non-client!\n" );

	push	OFFSET $SG139096
	call	_Con_Printf
	add	esp, 4

; 3670 : 		return "";

	mov	eax, OFFSET $SG139097
	jmp	SHORT $LN1@pfnGetPhys
$LN2@pfnGetPhys:

; 3671 : 	}
; 3672 : 
; 3673 : 	return cl->physinfo;

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 304				; 00000130H
$LN1@pfnGetPhys:

; 3674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPhysicsInfoString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_pfnSetPhysicsKeyValue PROC

; 3643 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3644 : 	sv_client_t	*cl;
; 3645 : 
; 3646 : 	// pfnUserInfoChanged passed
; 3647 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnSetPhys

; 3648 : 	{
; 3649 : 		Con_Printf( S_ERROR "SetPhysicsKeyValue: tried to a non-client!\n" );

	push	OFFSET $SG139088
	call	_Con_Printf
	add	esp, 4

; 3650 : 		return;

	jmp	SHORT $LN1@pfnSetPhys
$LN2@pfnSetPhys:

; 3651 : 	}
; 3652 : 
; 3653 : 	Info_SetValueForKey( cl->physinfo, key, value, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H
$LN1@pfnSetPhys:

; 3654 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetPhysicsKeyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pClient$ = 8						; size = 4
_key$ = 12						; size = 4
_pfnGetPhysicsKeyValue PROC

; 3623 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3624 : 	sv_client_t	*cl;
; 3625 : 
; 3626 : 	// pfnUserInfoChanged passed
; 3627 : 	if(( cl = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnGetPhys

; 3628 : 	{
; 3629 : 		Con_Printf( S_ERROR "GetPhysicsKeyValue: tried to a non-client!\n" );

	push	OFFSET $SG139075
	call	_Con_Printf
	add	esp, 4

; 3630 : 		return "";

	mov	eax, OFFSET $SG139076
	jmp	SHORT $LN1@pfnGetPhys
$LN2@pfnGetPhys:

; 3631 : 	}
; 3632 : 
; 3633 : 	return Info_ValueForKey( cl->physinfo, key );

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 304				; 00000130H
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
$LN1@pfnGetPhys:

; 3634 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPhysicsKeyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_clientIndex$ = 8					; size = 4
_infobuffer$ = 12					; size = 4
_key$ = 16						; size = 4
_value$ = 20						; size = 4
_pfnSetClientKeyValue PROC

; 3594 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3595 : 	sv_client_t	*cl;
; 3596 : 
; 3597 : 	if( infobuffer == svs.localinfo || infobuffer == svs.serverinfo )

	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+572
	je	SHORT $LN3@pfnSetClie
	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+60
	jne	SHORT $LN2@pfnSetClie
$LN3@pfnSetClie:

; 3598 : 		return;

	jmp	$LN1@pfnSetClie
$LN2@pfnSetClie:

; 3599 : 
; 3600 : 	clientIndex -= 1;

	mov	eax, DWORD PTR _clientIndex$[ebp]
	sub	eax, 1
	mov	DWORD PTR _clientIndex$[ebp], eax

; 3601 : 
; 3602 : 	if( !svs.clients || clientIndex < 0 || clientIndex >= svs.maxclients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN5@pfnSetClie
	cmp	DWORD PTR _clientIndex$[ebp], 0
	jl	SHORT $LN5@pfnSetClie
	mov	ecx, DWORD PTR _clientIndex$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jl	SHORT $LN4@pfnSetClie
$LN5@pfnSetClie:

; 3603 : 		return;

	jmp	SHORT $LN1@pfnSetClie
$LN4@pfnSetClie:

; 3604 : 
; 3605 : 	// value not changed?
; 3606 : 	if( !Q_strcmp( Info_ValueForKey( infobuffer, key ), value ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _infobuffer$[ebp]
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@pfnSetClie

; 3607 : 		return;

	jmp	SHORT $LN1@pfnSetClie
$LN6@pfnSetClie:

; 3608 : 
; 3609 : 	cl = &svs.clients[clientIndex]; 

	imul	edx, DWORD PTR _clientIndex$[ebp], 287560
	add	edx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], edx

; 3610 : 
; 3611 : 	Info_SetValueForStarKey( infobuffer, key, value, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H

; 3612 : 	SetBits( cl->flags, FCL_RESEND_USERINFO );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 3613 : 	cl->next_sendinfotime = 0.0;	// send immediately

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264384], xmm0
$LN1@pfnSetClie:

; 3614 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetClientKeyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_infobuffer$ = 8					; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_pfnSetValueForKey PROC

; 3579 : {

	push	ebp
	mov	ebp, esp

; 3580 : 	if( infobuffer == svs.localinfo )

	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+572
	jne	SHORT $LN2@pfnSetValu

; 3581 : 		Info_SetValueForStarKey( infobuffer, key, value, MAX_LOCALINFO_STRING );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnSetValu
$LN2@pfnSetValu:

; 3582 : 	else if( infobuffer == svs.serverinfo )

	cmp	DWORD PTR _infobuffer$[ebp], OFFSET _svs+60
	jne	SHORT $LN4@pfnSetValu

; 3583 : 		Info_SetValueForStarKey( infobuffer, key, value, MAX_SERVERINFO_STRING );

	push	512					; 00000200H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _infobuffer$[ebp]
	push	edx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnSetValu
$LN4@pfnSetValu:

; 3584 : 	else Con_Printf( S_ERROR "can't set client keys with SetValueForKey\n" );

	push	OFFSET $SG139049
	call	_Con_Printf
	add	esp, 4
$LN1@pfnSetValu:

; 3585 : }

	pop	ebp
	ret	0
_pfnSetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_e$ = 8							; size = 4
_pfnGetInfoKeyBuffer PROC

; 3554 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3555 : 	sv_client_t	*cl;
; 3556 : 
; 3557 : 	// NULL passes localinfo
; 3558 : 	if( !SV_IsValidEdict( e ))

	push	3558					; 00000de6H
	push	OFFSET $SG139033
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetInfo

; 3559 : 		return SV_Localinfo();

	call	_SV_Localinfo
	jmp	SHORT $LN1@pfnGetInfo
$LN2@pfnGetInfo:

; 3560 : 
; 3561 : 	// world passes serverinfo
; 3562 : 	if( e == svgame.edicts )

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR _svgame+7928
	jne	SHORT $LN3@pfnGetInfo

; 3563 : 		return SV_Serverinfo();

	call	_SV_Serverinfo
	jmp	SHORT $LN1@pfnGetInfo
$LN3@pfnGetInfo:

; 3564 : 
; 3565 : 	// userinfo for specified edict
; 3566 : 	if(( cl = SV_ClientFromEdict( e, false )) != NULL )

	push	0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	je	SHORT $LN4@pfnGetInfo

; 3567 : 		return cl->userinfo;

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	jmp	SHORT $LN1@pfnGetInfo
$LN4@pfnGetInfo:

; 3568 : 
; 3569 : 	return ""; // assume error

	mov	eax, OFFSET $SG139036
$LN1@pfnGetInfo:

; 3570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetInfoKeyBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_oldcl$ = -68						; size = 4
_seed$ = -64						; size = 4
_cl$ = -60						; size = 4
_cmd$ = -56						; size = 52
__$ArrayPad$ = -4					; size = 4
_pClient$ = 8						; size = 4
_viewangles$ = 12					; size = 4
_fmove$ = 16						; size = 4
_smove$ = 20						; size = 4
_upmove$ = 24						; size = 4
_buttons$ = 28						; size = 2
_impulse$ = 32						; size = 1
_msec$ = 36						; size = 1
_pfnRunPlayerMove PROC

; 3493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 3494 : 	sv_client_t	*cl, *oldcl;
; 3495 : 	usercmd_t		cmd;
; 3496 : 	uint		seed;
; 3497 : 
; 3498 : 	if(( cl = SV_ClientFromEdict( pClient, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnRunPlay

; 3499 : 		return;

	jmp	$LN1@pfnRunPlay
$LN2@pfnRunPlay:

; 3500 : 
; 3501 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	jne	SHORT $LN3@pfnRunPlay

; 3502 : 		return; // only fakeclients allows

	jmp	$LN1@pfnRunPlay
$LN3@pfnRunPlay:

; 3503 : 
; 3504 : 	oldcl = sv.current_client;

	mov	eax, DWORD PTR _sv+40
	mov	DWORD PTR _oldcl$[ebp], eax

; 3505 : 
; 3506 : 	sv.current_client = SV_ClientFromEdict( pClient, true );

	push	1
	mov	ecx, DWORD PTR _pClient$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _sv+40, eax

; 3507 : 	sv.current_client->timebase = (sv.time + sv.frametime) - ((double)msec / 1000.0);

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _sv+16
	movzx	edx, BYTE PTR _msec$[ebp]
	cvtsi2sd xmm1, edx
	divsd	xmm1, QWORD PTR __real@408f400000000000
	subsd	xmm0, xmm1
	mov	eax, DWORD PTR _sv+40
	movsd	QWORD PTR [eax+264400], xmm0

; 3508 : 
; 3509 : 	memset( &cmd, 0, sizeof( cmd ));

	push	52					; 00000034H
	push	0
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3510 : 	VectorCopy( viewangles, cmd.viewangles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _viewangles$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _cmd$[ebp+edx+4], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _viewangles$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _cmd$[ebp+edx+4], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _viewangles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _cmd$[ebp+eax+4], edx

; 3511 : 	cmd.forwardmove = fmove;

	movss	xmm0, DWORD PTR _fmove$[ebp]
	movss	DWORD PTR _cmd$[ebp+16], xmm0

; 3512 : 	cmd.sidemove = smove;

	movss	xmm0, DWORD PTR _smove$[ebp]
	movss	DWORD PTR _cmd$[ebp+20], xmm0

; 3513 : 	cmd.upmove = upmove;

	movss	xmm0, DWORD PTR _upmove$[ebp]
	movss	DWORD PTR _cmd$[ebp+24], xmm0

; 3514 : 	cmd.buttons = buttons;

	mov	ax, WORD PTR _buttons$[ebp]
	mov	WORD PTR _cmd$[ebp+30], ax

; 3515 : 	cmd.impulse = impulse;

	mov	cl, BYTE PTR _impulse$[ebp]
	mov	BYTE PTR _cmd$[ebp+32], cl

; 3516 : 	cmd.msec = msec;

	mov	dl, BYTE PTR _msec$[ebp]
	mov	BYTE PTR _cmd$[ebp+2], dl

; 3517 : 
; 3518 : 	seed = COM_RandomLong( 0, 0x7fffffff ); // full range

	push	2147483647				; 7fffffffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _seed$[ebp], eax

; 3519 : 
; 3520 : 	SV_RunCmd( cl, &cmd, seed );

	mov	eax, DWORD PTR _seed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 3521 : 
; 3522 : 	cl->lastcmd = cmd;

	mov	edi, DWORD PTR _cl$[ebp]
	add	edi, 264888				; 00040ab8H
	mov	ecx, 13					; 0000000dH
	lea	esi, DWORD PTR _cmd$[ebp]
	rep movsd

; 3523 : 	sv.current_client = oldcl;

	mov	eax, DWORD PTR _oldcl$[ebp]
	mov	DWORD PTR _sv+40, eax
$LN1@pfnRunPlay:

; 3524 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRunPlayerMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv75 = -12						; size = 4
tv72 = -8						; size = 4
_cl$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_fNewMaxspeed$ = 12					; size = 4
_pfnSetClientMaxspeed PROC

; 3474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3475 : 	sv_client_t	*cl;
; 3476 : 
; 3477 : 	// not spawned clients allowed
; 3478 : 	if(( cl = SV_ClientFromEdict( pEdict, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnSetClie

; 3479 : 		return;

	jmp	$LN1@pfnSetClie
$LN2@pfnSetClie:

; 3480 : 
; 3481 : 	fNewMaxspeed = bound( -svgame.movevars.maxspeed, fNewMaxspeed, svgame.movevars.maxspeed );

	movss	xmm0, DWORD PTR _svgame+7944
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _fNewMaxspeed$[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN6@pfnSetClie
	movss	xmm0, DWORD PTR _svgame+7944
	comiss	xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	jbe	SHORT $LN4@pfnSetClie
	movss	xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	movss	DWORD PTR tv72[ebp], xmm0
	jmp	SHORT $LN5@pfnSetClie
$LN4@pfnSetClie:
	movss	xmm0, DWORD PTR _svgame+7944
	movss	DWORD PTR tv72[ebp], xmm0
$LN5@pfnSetClie:
	movss	xmm0, DWORD PTR tv72[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN7@pfnSetClie
$LN6@pfnSetClie:
	movss	xmm0, DWORD PTR _svgame+7944
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv75[ebp], xmm0
$LN7@pfnSetClie:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _fNewMaxspeed$[ebp], xmm0

; 3482 : 	Info_SetValueForKey( cl->physinfo, "maxspd", va( "%.f", fNewMaxspeed ), MAX_INFO_STRING );

	push	256					; 00000100H
	cvtss2sd xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG138990
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG138991
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 3483 : 	cl->edict->v.maxspeed = fNewMaxspeed;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	movss	xmm0, DWORD PTR _fNewMaxspeed$[ebp]
	movss	DWORD PTR [eax+656], xmm0
$LN1@pfnSetClie:

; 3484 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetClientMaxspeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_cl$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_fadePercent$ = 12					; size = 4
_fadeOutSeconds$ = 16					; size = 4
_holdTime$ = 20						; size = 4
_fadeInSeconds$ = 24					; size = 4
_pfnFadeClientVolume PROC

; 3450 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3451 : 	sv_client_t	*cl;
; 3452 : 
; 3453 : 	if(( cl = SV_ClientFromEdict( pEdict, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@pfnFadeCli

; 3454 : 		return;

	jmp	SHORT $LN1@pfnFadeCli
$LN2@pfnFadeCli:

; 3455 : 
; 3456 : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN3@pfnFadeCli

; 3457 : 		return;

	jmp	SHORT $LN1@pfnFadeCli
$LN3@pfnFadeCli:

; 3458 : 
; 3459 : 	MSG_BeginServerCmd( &cl->netchan.message, svc_soundfade );

	push	0
	push	1
	push	48					; 00000030H
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3460 : 	MSG_WriteByte( &cl->netchan.message, fadePercent );

	mov	ecx, DWORD PTR _fadePercent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 3461 : 	MSG_WriteByte( &cl->netchan.message, holdTime );

	mov	eax, DWORD PTR _holdTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 3462 : 	MSG_WriteByte( &cl->netchan.message, fadeOutSeconds );

	mov	edx, DWORD PTR _fadeOutSeconds$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 3463 : 	MSG_WriteByte( &cl->netchan.message, fadeInSeconds );

	mov	ecx, DWORD PTR _fadeInSeconds$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteByte
	add	esp, 8
$LN1@pfnFadeCli:

; 3464 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFadeClientVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_pfnGetPlayerWONId PROC

; 3423 : {

	push	ebp
	mov	ebp, esp

; 3424 : 	return (uint)-1;

	or	eax, -1

; 3425 : }

	pop	ebp
	ret	0
_pfnGetPlayerWONId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_pfnIsDedicatedServer PROC

; 3411 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3412 : 	return (host.type == HOST_DEDICATED);

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN3@pfnIsDedic
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@pfnIsDedic
$LN3@pfnIsDedic:
	mov	DWORD PTR tv65[ebp], 0
$LN4@pfnIsDedic:
	mov	eax, DWORD PTR tv65[ebp]

; 3413 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsDedicatedServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_origin$ = 8						; size = 4
_decalIndex$ = 12					; size = 4
_entityIndex$ = 16					; size = 4
_modelIndex$ = 20					; size = 4
_pfnStaticDecal PROC

; 3400 : {

	push	ebp
	mov	ebp, esp

; 3401 : 	SV_CreateDecal( &sv.signon, origin, decalIndex, entityIndex, modelIndex, FDECAL_PERMANENT, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	push	OFFSET _sv+1220372
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH

; 3402 : }

	pop	ebp
	ret	0
_pfnStaticDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_viewEnt$ = -8						; size = 4
_client$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pViewent$ = 12						; size = 4
_pfnSetView PROC

; 3364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3365 : 	sv_client_t	*client;
; 3366 : 	int		viewEnt;
; 3367 : 
; 3368 : 	if( !SV_IsValidEdict( pClient ))

	push	3368					; 00000d28H
	push	OFFSET $SG138930
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnSetView

; 3369 : 		return;

	jmp	$LN1@pfnSetView
$LN2@pfnSetView:

; 3370 : 
; 3371 : 	if(( client = SV_ClientFromEdict( pClient, false )) == NULL )

	push	0
	mov	ecx, DWORD PTR _pClient$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _client$[ebp], eax
	cmp	DWORD PTR _client$[ebp], 0
	jne	SHORT $LN3@pfnSetView

; 3372 : 	{
; 3373 : 		Con_Printf( S_ERROR "PF_SetView_I: not a client!\n" );

	push	OFFSET $SG138932
	call	_Con_Printf
	add	esp, 4

; 3374 : 		return;

	jmp	$LN1@pfnSetView
$LN3@pfnSetView:

; 3375 : 	}
; 3376 : 
; 3377 : 	if( !SV_IsValidEdict( pViewent ) || pClient == pViewent )

	push	3377					; 00000d31H
	push	OFFSET $SG138936
	mov	edx, DWORD PTR _pViewent$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@pfnSetView
	mov	eax, DWORD PTR _pClient$[ebp]
	cmp	eax, DWORD PTR _pViewent$[ebp]
	jne	SHORT $LN4@pfnSetView
$LN6@pfnSetView:

; 3378 : 		client->pViewEntity = NULL; // just reset viewentity

	mov	ecx, DWORD PTR _client$[ebp]
	mov	DWORD PTR [ecx+264984], 0
	jmp	SHORT $LN5@pfnSetView
$LN4@pfnSetView:

; 3379 : 	else client->pViewEntity = (edict_t *)pViewent;

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _pViewent$[ebp]
	mov	DWORD PTR [edx+264984], eax
$LN5@pfnSetView:

; 3380 : 
; 3381 : 	// fakeclients ignore to send client message (but can see into the trigger_camera through the PVS)
; 3382 : 	if( FBitSet( client->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN7@pfnSetView

; 3383 : 		return;

	jmp	SHORT $LN1@pfnSetView
$LN7@pfnSetView:

; 3384 : 
; 3385 : 	if( client->pViewEntity )

	mov	eax, DWORD PTR _client$[ebp]
	cmp	DWORD PTR [eax+264984], 0
	je	SHORT $LN8@pfnSetView

; 3386 : 		viewEnt = NUM_FOR_EDICT( client->pViewEntity );

	mov	ecx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR [ecx+264984]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
	jmp	SHORT $LN9@pfnSetView
$LN8@pfnSetView:

; 3387 : 	else viewEnt = NUM_FOR_EDICT( client->edict );

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
$LN9@pfnSetView:

; 3388 : 
; 3389 : 	MSG_BeginServerCmd( &client->netchan.message, svc_setview );

	push	0
	push	1
	push	5
	mov	edx, DWORD PTR _client$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3390 : 	MSG_WriteWord( &client->netchan.message, viewEnt );

	mov	eax, DWORD PTR _viewEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8
$LN1@pfnSetView:

; 3391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_client$ = -4						; size = 4
_pClient$ = 8						; size = 4
_pitch$ = 12						; size = 4
_yaw$ = 16						; size = 4
_pfnCrosshairAngle PROC

; 3337 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3338 : 	sv_client_t	*client;
; 3339 : 
; 3340 : 	if(( client = SV_ClientFromEdict( pClient, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _client$[ebp], eax
	cmp	DWORD PTR _client$[ebp], 0
	jne	SHORT $LN2@pfnCrossha

; 3341 : 		return;

	jmp	$LN1@pfnCrossha
$LN2@pfnCrossha:

; 3342 : 
; 3343 : 	// fakeclients ignores it silently
; 3344 : 	if( FBitSet( client->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN3@pfnCrossha

; 3345 : 		return;

	jmp	$LN1@pfnCrossha
$LN3@pfnCrossha:

; 3346 : 
; 3347 : 	if( pitch > 180.0f ) pitch -= 360;

	movss	xmm0, DWORD PTR _pitch$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN4@pfnCrossha
	movss	xmm0, DWORD PTR _pitch$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN4@pfnCrossha:

; 3348 : 	if( pitch < -180.0f ) pitch += 360;

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _pitch$[ebp]
	jbe	SHORT $LN5@pfnCrossha
	movss	xmm0, DWORD PTR _pitch$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN5@pfnCrossha:

; 3349 : 	if( yaw > 180.0f ) yaw -= 360;

	movss	xmm0, DWORD PTR _yaw$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN6@pfnCrossha
	movss	xmm0, DWORD PTR _yaw$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0
$LN6@pfnCrossha:

; 3350 : 	if( yaw < -180.0f ) yaw += 360;

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _yaw$[ebp]
	jbe	SHORT $LN7@pfnCrossha
	movss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0
$LN7@pfnCrossha:

; 3351 : 
; 3352 : 	MSG_BeginServerCmd( &client->netchan.message, svc_crosshairangle );

	push	0
	push	1
	push	47					; 0000002fH
	mov	eax, DWORD PTR _client$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3353 : 	MSG_WriteChar( &client->netchan.message, pitch * 5 );

	movss	xmm0, DWORD PTR _pitch$[ebp]
	mulss	xmm0, DWORD PTR __real@40a00000
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _client$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteChar
	add	esp, 8

; 3354 : 	MSG_WriteChar( &client->netchan.message, yaw * 5 );

	movss	xmm0, DWORD PTR _yaw$[ebp]
	mulss	xmm0, DWORD PTR __real@40a00000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteChar
	add	esp, 8
$LN1@pfnCrossha:

; 3355 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCrosshairAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_iAttachment$ = 12					; size = 4
_rgflOrigin$ = 16					; size = 4
_rgflAngles$ = 20					; size = 4
_pfnGetAttachment PROC

; 3324 : {

	push	ebp
	mov	ebp, esp

; 3325 : 	if( !SV_IsValidEdict( pEdict ))

	push	3325					; 00000cfdH
	push	OFFSET $SG138895
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetAtta

; 3326 : 		return;

	jmp	SHORT $LN1@pfnGetAtta
$LN2@pfnGetAtta:

; 3327 : 	Mod_StudioGetAttachment( pEdict, iAttachment, rgflOrigin, rgflAngles );

	mov	ecx, DWORD PTR _rgflAngles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rgflOrigin$[ebp]
	push	edx
	mov	eax, DWORD PTR _iAttachment$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_Mod_StudioGetAttachment
	add	esp, 16					; 00000010H
$LN1@pfnGetAtta:

; 3328 : }

	pop	ebp
	ret	0
_pfnGetAttachment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_szMsg$ = 8						; size = 4
_pfnServerPrint PROC

; 3311 : {

	push	ebp
	mov	ebp, esp

; 3312 : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 2
	je	SHORT $LN2@pfnServerP

; 3313 : 		SV_BroadcastPrintf( NULL, "%s", szMsg );

	mov	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	push	OFFSET $SG138882
	push	0
	call	_SV_BroadcastPrintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnServerP
$LN2@pfnServerP:

; 3314 : 	else Con_Printf( "%s", szMsg );

	mov	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	push	OFFSET $SG138883
	call	_Con_Printf
	add	esp, 8
$LN1@pfnServerP:

; 3315 : }

	pop	ebp
	ret	0
_pfnServerPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv72 = -8						; size = 4
_client$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_ptype$ = 12						; size = 4
_szMsg$ = 16						; size = 4
_pfnClientPrintf PROC

; 3278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3279 : 	sv_client_t	*client;
; 3280 : 
; 3281 : 	if(( client = SV_ClientFromEdict( pEdict, false )) == NULL )

	push	0
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _client$[ebp], eax
	cmp	DWORD PTR _client$[ebp], 0
	jne	SHORT $LN4@pfnClientP

; 3282 : 	{
; 3283 : 		Con_Printf( "tried to sprint to a non-client\n" );

	push	OFFSET $SG138870
	call	_Con_Printf
	add	esp, 4

; 3284 : 		return;

	jmp	SHORT $LN1@pfnClientP
$LN4@pfnClientP:

; 3285 : 	}
; 3286 : 
; 3287 : 	if( FBitSet( client->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN5@pfnClientP

; 3288 : 		return;

	jmp	SHORT $LN1@pfnClientP
$LN5@pfnClientP:

; 3289 : 
; 3290 : 	switch( ptype )

	mov	eax, DWORD PTR _ptype$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN6@pfnClientP
	cmp	DWORD PTR tv72[ebp], 1
	je	SHORT $LN7@pfnClientP
	cmp	DWORD PTR tv72[ebp], 2
	je	SHORT $LN6@pfnClientP
	jmp	SHORT $LN1@pfnClientP
$LN6@pfnClientP:

; 3291 : 	{
; 3292 : 	case print_console:
; 3293 : 	case print_chat:
; 3294 : 		SV_ClientPrintf( client, "%s", szMsg );

	mov	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	push	OFFSET $SG138873
	mov	edx, DWORD PTR _client$[ebp]
	push	edx
	call	_SV_ClientPrintf
	add	esp, 12					; 0000000cH

; 3295 : 		break;

	jmp	SHORT $LN1@pfnClientP
$LN7@pfnClientP:

; 3296 : 	case print_center:
; 3297 : 		MSG_BeginServerCmd( &client->netchan.message, svc_centerprint );

	push	0
	push	1
	push	26					; 0000001aH
	mov	eax, DWORD PTR _client$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3298 : 		MSG_WriteString( &client->netchan.message, szMsg );

	mov	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _client$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteString
	add	esp, 8
$LN1@pfnClientP:

; 3299 : 		break;
; 3300 : 	}
; 3301 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_function$ = 8						; size = 4
_pfnNameForFunction PROC

; 3267 : {

	push	ebp
	mov	ebp, esp

; 3268 : 	return COM_NameForFunction( svgame.hInstance, function );

	mov	eax, DWORD PTR _function$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_NameForFunction
	add	esp, 8

; 3269 : }

	pop	ebp
	ret	0
_pfnNameForFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pName$ = 8						; size = 4
_pfnFunctionFromName PROC

; 3256 : {

	push	ebp
	mov	ebp, esp

; 3257 : 	return COM_FunctionFromName( svgame.hInstance, pName );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_FunctionFromName
	add	esp, 8

; 3258 : }

	pop	ebp
	ret	0
_pfnFunctionFromName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_iBone$ = 12						; size = 4
_rgflOrigin$ = 16					; size = 4
_rgflAngles$ = 20					; size = 4
_pfnGetBonePosition PROC

; 3243 : {

	push	ebp
	mov	ebp, esp

; 3244 : 	if( !SV_IsValidEdict( pEdict ))

	push	3244					; 00000cacH
	push	OFFSET $SG138847
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetBone

; 3245 : 		return;

	jmp	SHORT $LN1@pfnGetBone
$LN2@pfnGetBone:

; 3246 : 	Mod_GetBonePosition( pEdict, iBone, rgflOrigin, rgflAngles );

	mov	ecx, DWORD PTR _rgflAngles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rgflOrigin$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_Mod_GetBonePosition
	add	esp, 16					; 00000010H
$LN1@pfnGetBone:

; 3247 : }

	pop	ebp
	ret	0
_pfnGetBonePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_flTime$ = 12						; size = 4
_pfnAnimationAutomove PROC

; 3233 : {

	push	ebp
	mov	ebp, esp

; 3234 : }

	pop	ebp
	ret	0
_pfnAnimationAutomove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv79 = -12						; size = 4
tv78 = -8						; size = 4
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_iSize$ = 12						; size = 4
_pfnRegUserMsg PROC

; 3175 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3176 : 	int	i;
; 3177 : 	
; 3178 : 	if( !COM_CheckString( pszName ))

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@pfnRegUser

; 3179 : 		return svc_bad;

	xor	eax, eax
	jmp	$LN1@pfnRegUser
$LN5@pfnRegUser:

; 3180 : 
; 3181 : 	if( Q_strlen( pszName ) >= sizeof( svgame.msg[0].name ))

	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	jb	SHORT $LN6@pfnRegUser

; 3182 : 	{
; 3183 : 		Con_Printf( S_ERROR "REG_USER_MSG: too long name %s\n", pszName );

	mov	edx, DWORD PTR _pszName$[ebp]
	push	edx
	push	OFFSET $SG138823
	call	_Con_Printf
	add	esp, 8

; 3184 : 		return svc_bad; // force error

	xor	eax, eax
	jmp	$LN1@pfnRegUser
$LN6@pfnRegUser:

; 3185 : 	}
; 3186 : 
; 3187 : 	if( iSize > MAX_USERMSG_LENGTH )

	cmp	DWORD PTR _iSize$[ebp], 2048		; 00000800H
	jle	SHORT $LN7@pfnRegUser

; 3188 : 	{
; 3189 : 		Con_Printf( S_ERROR "REG_USER_MSG: %s has too big size %i\n", pszName, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	push	OFFSET $SG138825
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 3190 : 		return svc_bad; // force error

	xor	eax, eax
	jmp	$LN1@pfnRegUser
$LN7@pfnRegUser:

; 3191 : 	}
; 3192 : 
; 3193 : 	// make sure what size inrange
; 3194 : 	iSize = bound( -1, iSize, MAX_USERMSG_LENGTH );

	cmp	DWORD PTR _iSize$[ebp], -1
	jl	SHORT $LN14@pfnRegUser
	cmp	DWORD PTR _iSize$[ebp], 2048		; 00000800H
	jge	SHORT $LN12@pfnRegUser
	mov	edx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN13@pfnRegUser
$LN12@pfnRegUser:
	mov	DWORD PTR tv78[ebp], 2048		; 00000800H
$LN13@pfnRegUser:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN15@pfnRegUser
$LN14@pfnRegUser:
	mov	DWORD PTR tv79[ebp], -1
$LN15@pfnRegUser:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _iSize$[ebp], ecx

; 3195 : 
; 3196 : 	// message 0 is reserved for svc_bad
; 3197 : 	for( i = 1; i < MAX_USER_MESSAGES && svgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnRegUser
$LN2@pfnRegUser:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@pfnRegUser:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@pfnRegUser
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _svgame[eax+edx+4]
	test	eax, eax
	je	SHORT $LN3@pfnRegUser

; 3198 : 	{
; 3199 : 		// see if already registered
; 3200 : 		if( !Q_strcmp( svgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 40
	add	edx, OFFSET _svgame+4
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnRegUser

; 3201 : 			return svc_lastmsg + i; // offset

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 58					; 0000003aH
	jmp	$LN1@pfnRegUser
$LN8@pfnRegUser:

; 3202 : 	}

	jmp	SHORT $LN2@pfnRegUser
$LN3@pfnRegUser:

; 3203 : 
; 3204 : 	if( i == MAX_USER_MESSAGES ) 

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN9@pfnRegUser

; 3205 : 	{
; 3206 : 		Con_Printf( S_ERROR "REG_USER_MSG: user messages limit exceeded\n" );

	push	OFFSET $SG138828
	call	_Con_Printf
	add	esp, 4

; 3207 : 		return svc_bad;

	xor	eax, eax
	jmp	SHORT $LN1@pfnRegUser
$LN9@pfnRegUser:

; 3208 : 	}
; 3209 : 
; 3210 : 	// register new message
; 3211 : 	Q_strncpy( svgame.msg[i].name, pszName, sizeof( svgame.msg[i].name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 40
	add	ecx, OFFSET _svgame+4
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3212 : 	svgame.msg[i].number = svc_lastmsg + i;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 58					; 0000003aH
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _svgame[eax+36], edx

; 3213 : 	svgame.msg[i].size = iSize;

	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	edx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _svgame[ecx+40], edx

; 3214 : 
; 3215 : 	if( sv.state == ss_active )

	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN10@pfnRegUser

; 3216 : 	{
; 3217 : 		// tell the client about new user message
; 3218 : 		SV_SendUserReg( &sv.multicast, &svgame.msg[i] );

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svgame+4
	push	eax
	push	OFFSET _sv+1212160
	call	_SV_SendUserReg
	add	esp, 8

; 3219 : 		SV_Multicast( MSG_ALL, NULL, NULL, false, false );

	push	0
	push	0
	push	0
	push	0
	push	2
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN10@pfnRegUser:

; 3220 : 	}
; 3221 : 
; 3222 : 	return svgame.msg[i].number;

	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	eax, DWORD PTR _svgame[ecx+36]
$LN1@pfnRegUser:

; 3223 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRegUserMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_mod$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_pfnGetModelPtr PROC

; 3144 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3145 : 	model_t	*mod;
; 3146 : 
; 3147 : 	if( !SV_IsValidEdict( pEdict ))

	push	3147					; 00000c4bH
	push	OFFSET $SG138801
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetMode

; 3148 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetMode
$LN2@pfnGetMode:

; 3149 : 
; 3150 : 	mod = SV_ModelHandle( pEdict->v.modelindex );

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	push	edx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 3151 : 	return Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
$LN1@pfnGetMode:

; 3152 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetModelPtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = -8						; size = 4
_i$ = -4						; size = 4
_pvars$ = 8						; size = 4
_pfnFindEntityByVars PROC

; 3117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3118 : 	edict_t	*pEdict;
; 3119 : 	int	i;
; 3120 : 
; 3121 : 	// don't pass invalid arguments
; 3122 : 	if( !pvars ) return NULL;

	cmp	DWORD PTR _pvars$[ebp], 0
	jne	SHORT $LN5@pfnFindEnt
	xor	eax, eax
	jmp	SHORT $LN1@pfnFindEnt
$LN5@pfnFindEnt:

; 3123 : 
; 3124 : 	for( i = 0; i < GI->max_edicts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnFindEnt
$LN2@pfnFindEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnFindEnt:
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+1656]
	jge	SHORT $LN3@pfnFindEnt

; 3125 : 	{
; 3126 : 		pEdict = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax

; 3127 : 
; 3128 : 		// g-cont: we should compare pointers
; 3129 : 		if( &pEdict->v == pvars )

	mov	ecx, DWORD PTR _pEdict$[ebp]
	add	ecx, 128				; 00000080H
	cmp	ecx, DWORD PTR _pvars$[ebp]
	jne	SHORT $LN6@pfnFindEnt

; 3130 : 			return pEdict; // found it

	mov	eax, DWORD PTR _pEdict$[ebp]
	jmp	SHORT $LN1@pfnFindEnt
$LN6@pfnFindEnt:

; 3131 : 	}

	jmp	SHORT $LN2@pfnFindEnt
$LN3@pfnFindEnt:

; 3132 : 
; 3133 : 	return NULL;

	xor	eax, eax
$LN1@pfnFindEnt:

; 3134 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFindEntityByVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_pfnEntOffsetOfPEntity PROC

; 3061 : {

	push	ebp
	mov	ebp, esp

; 3062 : 	return (byte *)pEdict - (byte *)svgame.edicts;

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928

; 3063 : }

	pop	ebp
	ret	0
_pfnEntOffsetOfPEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iEntOffset$ = 8					; size = 4
_pfnPEntityOfEntOffset PROC

; 3050 : {

	push	ebp
	mov	ebp, esp

; 3051 : 	return (edict_t *)((byte *)svgame.edicts + iEntOffset);

	mov	eax, DWORD PTR _svgame+7928
	add	eax, DWORD PTR _iEntOffset$[ebp]

; 3052 : }

	pop	ebp
	ret	0
_pfnPEntityOfEntOffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_pfnGetVarsOfEnt PROC

; 3037 : {

	push	ebp
	mov	ebp, esp

; 3038 : 	if( pEdict )

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN2@pfnGetVars

; 3039 : 		return &pEdict->v;

	mov	eax, DWORD PTR _pEdict$[ebp]
	add	eax, 128				; 00000080H
	jmp	SHORT $LN1@pfnGetVars
$LN2@pfnGetVars:

; 3040 : 	return NULL;

	xor	eax, eax
$LN1@pfnGetVars:

; 3041 : }

	pop	ebp
	ret	0
_pfnGetVarsOfEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_pfnPvEntPrivateData PROC

; 2960 : {

	push	ebp
	mov	ebp, esp

; 2961 : 	if( pEdict )

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN2@pfnPvEntPr

; 2962 : 		return pEdict->pvPrivateData;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $LN1@pfnPvEntPr
$LN2@pfnPvEntPr:

; 2963 : 	return NULL;

	xor	eax, eax
$LN1@pfnPvEntPr:

; 2964 : }

	pop	ebp
	ret	0
_pfnPvEntPrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_pEdict$ = 8						; size = 4
_cb$ = 12						; size = 4
_pfnPvAllocEntPrivateData PROC

; 2938 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2939 : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN4@pfnPvAlloc
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN5@pfnPvAlloc
$LN4@pfnPvAlloc:
	mov	DWORD PTR tv69[ebp], 0
$LN5@pfnPvAlloc:
	push	0
	push	2939					; 00000b7bH
	push	OFFSET $SG138703
	push	OFFSET $SG138704
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2940 : 
; 2941 : 	SV_FreePrivateData( pEdict );

	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_FreePrivateData
	add	esp, 4

; 2942 : 
; 2943 : 	if( cb > 0 )

	cmp	DWORD PTR _cb$[ebp], 0
	jle	SHORT $LN2@pfnPvAlloc

; 2944 : 	{
; 2945 : 		// a poke646 have memory corrupt in somewhere - this is trashed last sixteen bytes :(
; 2946 : 		pEdict->pvPrivateData = Mem_Calloc( svgame.mempool, (cb + 15) & ~15 );

	push	2946					; 00000b82H
	push	OFFSET $SG138706
	push	1
	mov	edx, DWORD PTR _cb$[ebp]
	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	push	edx
	mov	eax, DWORD PTR _svgame+19556
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [ecx+124], eax
$LN2@pfnPvAlloc:

; 2947 : 	}
; 2948 : 
; 2949 : 	return pEdict->pvPrivateData;

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+124]

; 2950 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPvAllocEntPrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pSource$ = 8						; size = 4
_chan$ = 12						; size = 4
_samp$ = 16						; size = 4
_fvol$ = 20						; size = 4
_attn$ = 24						; size = 4
_fFlags$ = 28						; size = 4
_pitch$ = 32						; size = 4
_msg_dest$ = 36						; size = 4
_msg_type$ = 40						; size = 4
_pOrigin$ = 44						; size = 4
_pSend$ = 48						; size = 4
_pfnBuildSoundMsg PROC

; 2925 : {

	push	ebp
	mov	ebp, esp

; 2926 : 	pfnMessageBegin( msg_dest, msg_type, pOrigin, pSend );

	mov	eax, DWORD PTR _pSend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	_pfnMessageBegin
	add	esp, 16					; 00000010H

; 2927 : 	SV_BuildSoundMsg( &sv.multicast, pSource, chan, samp, fvol * 255, attn, fFlags, pitch, pOrigin );

	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	mov	eax, DWORD PTR _fFlags$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _samp$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSource$[ebp]
	push	ecx
	push	OFFSET _sv+1212160
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H

; 2928 : 	pfnMessageEnd();

	call	_pfnMessageEnd

; 2929 : }

	pop	ebp
	ret	0
_pfnBuildSoundMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pfile$ = 8						; size = 4
_szFmt$ = 12						; size = 4
_pfnEngineFprintf PROC

; 2914 : {

	push	ebp
	mov	ebp, esp

; 2915 : }

	pop	ebp
	ret	0
_pfnEngineFprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv77 = -2060						; size = 4
_args$ = -2056						; size = 4
_buffer$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_szFmt$ = 12						; size = 4
_pfnAlertMessage PROC

; 2861 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2060				; 0000080cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2862 : 	char	buffer[2048];
; 2863 : 	va_list	args;
; 2864 : 
; 2865 : 	if( type == at_logged && svs.maxclients > 1 )

	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN4@pfnAlertMe
	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN4@pfnAlertMe

; 2866 : 	{
; 2867 : 		va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 2868 : 		Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	2048					; 00000800H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2869 : 		va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2870 : 		Log_Printf( "%s", buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET $SG138651
	call	_Log_Printf
	add	esp, 8

; 2871 : 		return;

	jmp	$LN2@pfnAlertMe
$LN4@pfnAlertMe:

; 2872 : 	}
; 2873 : 
; 2874 : 	if( host_developer.value <= DEV_NONE )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _host_developer+12
	jb	SHORT $LN5@pfnAlertMe

; 2875 : 		return;

	jmp	$LN2@pfnAlertMe
$LN5@pfnAlertMe:

; 2876 : 
; 2877 : 	// g-cont: some mods have wrong aiconsole messages that crash the engine
; 2878 : 	if( type == at_aiconsole && host_developer.value < DEV_EXTENDED )

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN6@pfnAlertMe
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN6@pfnAlertMe

; 2879 : 		return;

	jmp	$LN2@pfnAlertMe
$LN6@pfnAlertMe:

; 2880 : 
; 2881 : 	va_start( args, szFmt );

	lea	edx, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], edx

; 2882 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFmt$[ebp]
	push	ecx
	push	2048					; 00000800H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2883 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2884 : 
; 2885 : 	// check message for pass
; 2886 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 4
	ja	SHORT $LN2@pfnAlertMe
	mov	ecx, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN13@pfnAlertMe[ecx*4]
$LN7@pfnAlertMe:

; 2887 : 	{
; 2888 : 	case at_notice:
; 2889 : 		Con_Printf( S_NOTE "%s", buffer );

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	OFFSET $SG138655
	call	_Con_Printf
	add	esp, 8

; 2890 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN8@pfnAlertMe:

; 2891 : 	case at_console:
; 2892 : 		Con_Printf( "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET $SG138657
	call	_Con_Printf
	add	esp, 8

; 2893 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN9@pfnAlertMe:

; 2894 : 	case at_aiconsole:
; 2895 : 		Con_DPrintf( "%s", buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET $SG138659
	call	_Con_DPrintf
	add	esp, 8

; 2896 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN10@pfnAlertMe:

; 2897 : 	case at_warning:
; 2898 : 		Con_Printf( S_WARN "%s", buffer );

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	OFFSET $SG138661
	call	_Con_Printf
	add	esp, 8

; 2899 : 		break;

	jmp	SHORT $LN2@pfnAlertMe
$LN11@pfnAlertMe:

; 2900 : 	case at_error:
; 2901 : 		Con_Printf( S_ERROR "%s", buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET $SG138663
	call	_Con_Printf
	add	esp, 8
$LN2@pfnAlertMe:

; 2902 : 		break;
; 2903 : 	}
; 2904 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN13@pfnAlertMe:
	DD	$LN7@pfnAlertMe
	DD	$LN8@pfnAlertMe
	DD	$LN9@pfnAlertMe
	DD	$LN10@pfnAlertMe
	DD	$LN11@pfnAlertMe
_pfnAlertMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteEntity PROC

; 2847 : {

	push	ebp
	mov	ebp, esp

; 2848 : 	if( iValue < 0 || iValue >= svgame.numEntities )

	cmp	DWORD PTR _iValue$[ebp], 0
	jl	SHORT $LN3@pfnWriteEn
	mov	eax, DWORD PTR _iValue$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jl	SHORT $LN2@pfnWriteEn
$LN3@pfnWriteEn:

; 2849 : 		Host_Error( "MSG_WriteEntity: invalid entnumber %i\n", iValue );

	mov	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	push	OFFSET $SG138626
	call	_Host_Error
	add	esp, 8
$LN2@pfnWriteEn:

; 2850 : 	MSG_WriteShort( &sv.multicast, (short)iValue );

	movsx	edx, WORD PTR _iValue$[ebp]
	push	edx
	push	OFFSET _sv+1212160
	call	_MSG_WriteShort
	add	esp, 8

; 2851 : 	svgame.msg_realsize += 2;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 2
	mov	DWORD PTR _svgame+7888, eax

; 2852 : }

	pop	ebp
	ret	0
_pfnWriteEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv141 = -16						; size = 4
_rem$ = -12						; size = 4
_len$ = -8						; size = 4
_dst$ = -4						; size = 4
_src$ = 8						; size = 4
_pfnWriteString PROC

; 2784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2785 : 	static char	string[MAX_USERMSG_LENGTH];
; 2786 : 	int		len = Q_strlen( src ) + 1;

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2787 : 	int		rem = sizeof( string ) - 1;

	mov	DWORD PTR _rem$[ebp], 2047		; 000007ffH

; 2788 : 	char		*dst;
; 2789 : 
; 2790 : 	if( len == 1 )

	cmp	DWORD PTR _len$[ebp], 1
	jne	SHORT $LN4@pfnWriteSt

; 2791 : 	{
; 2792 : 		MSG_WriteChar( &sv.multicast, 0 );

	push	0
	push	OFFSET _sv+1212160
	call	_MSG_WriteChar
	add	esp, 8

; 2793 : 		svgame.msg_realsize += 1; 

	mov	ecx, DWORD PTR _svgame+7888
	add	ecx, 1
	mov	DWORD PTR _svgame+7888, ecx

; 2794 : 		return; // fast exit

	jmp	$LN1@pfnWriteSt
$LN4@pfnWriteSt:

; 2795 : 	}
; 2796 : 
; 2797 : 	// prepare string to sending
; 2798 : 	dst = string;

	mov	DWORD PTR _dst$[ebp], OFFSET ?string@?1??pfnWriteString@@9@9
$LN2@pfnWriteSt:

; 2799 : 
; 2800 : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN3@pfnWriteSt

; 2801 : 	{
; 2802 : 		// some escaped chars parsed as two symbols - merge it here
; 2803 : 		if( src[0] == '\\' && src[1] == 'n' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN5@pfnWriteSt
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _src$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 110				; 0000006eH
	jne	SHORT $LN5@pfnWriteSt

; 2804 : 		{
; 2805 : 			*dst++ = '\n';

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx], 10			; 0000000aH
	mov	edx, DWORD PTR _dst$[ebp]
	add	edx, 1
	mov	DWORD PTR _dst$[ebp], edx

; 2806 : 			src += 2;

	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 2
	mov	DWORD PTR _src$[ebp], eax

; 2807 : 			len -= 1;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 2808 : 		}

	jmp	$LN6@pfnWriteSt
$LN5@pfnWriteSt:

; 2809 : 		else if( src[0] == '\\' && src[1] == 'r' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _src$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN7@pfnWriteSt
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _src$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 114				; 00000072H
	jne	SHORT $LN7@pfnWriteSt

; 2810 : 		{
; 2811 : 			*dst++ = '\r';

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _dst$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dst$[ebp], ecx

; 2812 : 			src += 2;

	mov	edx, DWORD PTR _src$[ebp]
	add	edx, 2
	mov	DWORD PTR _src$[ebp], edx

; 2813 : 			len -= 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2814 : 		}

	jmp	SHORT $LN6@pfnWriteSt
$LN7@pfnWriteSt:

; 2815 : 		else if( src[0] == '\\' && src[1] == 't' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN9@pfnWriteSt
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 116				; 00000074H
	jne	SHORT $LN9@pfnWriteSt

; 2816 : 		{
; 2817 : 			*dst++ = '\t';

	mov	edx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [edx], 9
	mov	eax, DWORD PTR _dst$[ebp]
	add	eax, 1
	mov	DWORD PTR _dst$[ebp], eax

; 2818 : 			src += 2;

	mov	ecx, DWORD PTR _src$[ebp]
	add	ecx, 2
	mov	DWORD PTR _src$[ebp], ecx

; 2819 : 			len -= 1;

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 2820 : 		}

	jmp	SHORT $LN6@pfnWriteSt
$LN9@pfnWriteSt:

; 2821 : 		else if(( *dst++ = *src++ ) == 0 )

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _dst$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv141[ebp], ecx
	mov	edx, DWORD PTR _dst$[ebp]
	add	edx, 1
	mov	DWORD PTR _dst$[ebp], edx
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 1
	mov	DWORD PTR _src$[ebp], eax
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN6@pfnWriteSt

; 2822 : 			break;

	jmp	SHORT $LN3@pfnWriteSt
$LN6@pfnWriteSt:

; 2823 : 
; 2824 : 		if( --rem <= 0 )

	mov	ecx, DWORD PTR _rem$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _rem$[ebp], ecx
	cmp	DWORD PTR _rem$[ebp], 0
	jg	SHORT $LN12@pfnWriteSt

; 2825 : 		{
; 2826 : 			Con_Printf( S_ERROR "pfnWriteString: exceeds %i symbols\n", len );

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	push	OFFSET $SG138618
	call	_Con_Printf
	add	esp, 8

; 2827 : 			*dst = '\0'; // string end (not included in count)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 0

; 2828 : 			len = Q_strlen( string ) + 1;

	push	OFFSET ?string@?1??pfnWriteString@@9@9
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2829 : 			break;

	jmp	SHORT $LN3@pfnWriteSt
$LN12@pfnWriteSt:

; 2830 : 		}
; 2831 : 	}

	jmp	$LN2@pfnWriteSt
$LN3@pfnWriteSt:

; 2832 : 
; 2833 : 	*dst = '\0'; // string end (not included in count)

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx], 0

; 2834 : 	MSG_WriteString( &sv.multicast, string );

	push	OFFSET ?string@?1??pfnWriteString@@9@9
	push	OFFSET _sv+1212160
	call	_MSG_WriteString
	add	esp, 8

; 2835 : 
; 2836 : 	// NOTE: some messages with constant string length can be marked as known sized
; 2837 : 	svgame.msg_realsize += len;

	mov	edx, DWORD PTR _svgame+7888
	add	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _svgame+7888, edx
$LN1@pfnWriteSt:

; 2838 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_flValue$ = 8						; size = 4
_pfnWriteCoord PROC

; 2760 : {

	push	ebp
	mov	ebp, esp

; 2761 : 	MSG_WriteCoord( &sv.multicast, flValue );

	push	ecx
	movss	xmm0, DWORD PTR _flValue$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _sv+1212160
	call	_MSG_WriteCoord
	add	esp, 8

; 2762 : 	svgame.msg_realsize += 2;

	mov	eax, DWORD PTR _svgame+7888
	add	eax, 2
	mov	DWORD PTR _svgame+7888, eax

; 2763 : }

	pop	ebp
	ret	0
_pfnWriteCoord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iAngle$ = -4						; size = 4
_flValue$ = 8						; size = 4
_pfnWriteAngle PROC

; 2746 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2747 : 	int	iAngle = ((int)(( flValue ) * 256 / 360) & 255);

	movss	xmm0, DWORD PTR _flValue$[ebp]
	mulss	xmm0, DWORD PTR __real@43800000
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si eax, xmm0
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _iAngle$[ebp], eax

; 2748 : 
; 2749 : 	MSG_WriteChar( &sv.multicast, iAngle );

	mov	ecx, DWORD PTR _iAngle$[ebp]
	push	ecx
	push	OFFSET _sv+1212160
	call	_MSG_WriteChar
	add	esp, 8

; 2750 : 	svgame.msg_realsize += 1;

	mov	edx, DWORD PTR _svgame+7888
	add	edx, 1
	mov	DWORD PTR _svgame+7888, edx

; 2751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWriteAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteLong PROC

; 2733 : {

	push	ebp
	mov	ebp, esp

; 2734 : 	MSG_WriteLong( &sv.multicast, iValue );

	mov	eax, DWORD PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_WriteLong
	add	esp, 8

; 2735 : 	svgame.msg_realsize += 4;

	mov	ecx, DWORD PTR _svgame+7888
	add	ecx, 4
	mov	DWORD PTR _svgame+7888, ecx

; 2736 : }

	pop	ebp
	ret	0
_pfnWriteLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteShort PROC

; 2721 : {

	push	ebp
	mov	ebp, esp

; 2722 : 	MSG_WriteShort( &sv.multicast, (short)iValue );

	movsx	eax, WORD PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_WriteShort
	add	esp, 8

; 2723 : 	svgame.msg_realsize += 2;

	mov	ecx, DWORD PTR _svgame+7888
	add	ecx, 2
	mov	DWORD PTR _svgame+7888, ecx

; 2724 : }

	pop	ebp
	ret	0
_pfnWriteShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteChar PROC

; 2709 : {

	push	ebp
	mov	ebp, esp

; 2710 : 	MSG_WriteChar( &sv.multicast, (char)iValue );

	movsx	eax, BYTE PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_WriteChar
	add	esp, 8

; 2711 : 	svgame.msg_realsize++;

	mov	ecx, DWORD PTR _svgame+7888
	add	ecx, 1
	mov	DWORD PTR _svgame+7888, ecx

; 2712 : }

	pop	ebp
	ret	0
_pfnWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
_pfnWriteByte PROC

; 2696 : {

	push	ebp
	mov	ebp, esp

; 2697 : 	if( iValue == -1 ) iValue = 0xFF; // convert char to byte 

	cmp	DWORD PTR _iValue$[ebp], -1
	jne	SHORT $LN2@pfnWriteBy
	mov	DWORD PTR _iValue$[ebp], 255		; 000000ffH
$LN2@pfnWriteBy:

; 2698 : 	MSG_WriteByte( &sv.multicast, (byte)iValue );

	movzx	eax, BYTE PTR _iValue$[ebp]
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_WriteByte
	add	esp, 8

; 2699 : 	svgame.msg_realsize++;

	mov	ecx, DWORD PTR _svgame+7888
	add	ecx, 1
	mov	DWORD PTR _svgame+7888, ecx

; 2700 : }

	pop	ebp
	ret	0
_pfnWriteByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_org$ = -28						; size = 4
tv166 = -24						; size = 4
tv165 = -20						; size = 4
_svc_msg$1 = -16					; size = 4
_expsize$2 = -12					; size = 4
_realsize$3 = -8					; size = 4
_name$ = -4						; size = 4
_pfnMessageEnd PROC

; 2598 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2599 : 	const char	*name = "Unknown";

	mov	DWORD PTR _name$[ebp], OFFSET $SG138532

; 2600 : 	float		*org = NULL;

	mov	DWORD PTR _org$[ebp], 0

; 2601 : 
; 2602 : 	if( svgame.msg_name ) name = svgame.msg_name;

	cmp	DWORD PTR _svgame, 0
	je	SHORT $LN2@pfnMessage
	mov	eax, DWORD PTR _svgame
	mov	DWORD PTR _name$[ebp], eax
$LN2@pfnMessage:

; 2603 : 	if( !svgame.msg_started ) Host_Error( "MessageEnd: called with no active message\n" );

	cmp	DWORD PTR _svgame+7900, 0
	jne	SHORT $LN3@pfnMessage
	push	OFFSET $SG138535
	call	_Host_Error
	add	esp, 4
$LN3@pfnMessage:

; 2604 : 	svgame.msg_started = false;

	mov	DWORD PTR _svgame+7900, 0

; 2605 : 
; 2606 : 	if( MSG_CheckOverflow( &sv.multicast ))

	push	OFFSET _sv+1212160
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@pfnMessage

; 2607 : 	{
; 2608 : 		Con_Printf( S_ERROR "MessageEnd: %s has overflow multicast buffer\n", name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138537
	call	_Con_Printf
	add	esp, 8

; 2609 : 		MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2610 : 		return;

	jmp	$LN1@pfnMessage
$LN4@pfnMessage:

; 2611 : 	}
; 2612 : 
; 2613 : 	// check for system message
; 2614 : 	if( svgame.msg_index < 0 )

	cmp	DWORD PTR _svgame+7892, 0
	jge	$LN5@pfnMessage

; 2615 : 	{
; 2616 : 		if( svgame.msg_size_index != -1 )

	cmp	DWORD PTR _svgame+7884, -1
	je	SHORT $LN7@pfnMessage

; 2617 : 		{
; 2618 : 			// variable sized message
; 2619 : 			if( svgame.msg_realsize > MAX_USERMSG_LENGTH )

	cmp	DWORD PTR _svgame+7888, 2048		; 00000800H
	jle	SHORT $LN8@pfnMessage

; 2620 : 			{
; 2621 : 				Con_Printf( S_ERROR "SV_Multicast: %s too long (more than %d bytes)\n", name, MAX_USERMSG_LENGTH );

	push	2048					; 00000800H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG138543
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2622 : 				MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2623 : 				return;

	jmp	$LN1@pfnMessage

; 2624 : 			}

	jmp	SHORT $LN10@pfnMessage
$LN8@pfnMessage:

; 2625 : 			else if( svgame.msg_realsize < 0 )

	cmp	DWORD PTR _svgame+7888, 0
	jge	SHORT $LN10@pfnMessage

; 2626 : 			{
; 2627 : 				Con_Printf( S_ERROR "SV_Multicast: %s writes NULL message\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG138545
	call	_Con_Printf
	add	esp, 8

; 2628 : 				MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2629 : 				return;

	jmp	$LN1@pfnMessage
$LN10@pfnMessage:

; 2630 : 			}
; 2631 : 
; 2632 : 			sv.multicast.pData[svgame.msg_size_index] = svgame.msg_realsize;

	mov	ecx, DWORD PTR _sv+1212168
	add	ecx, DWORD PTR _svgame+7884
	mov	dl, BYTE PTR _svgame+7888
	mov	BYTE PTR [ecx], dl
$LN7@pfnMessage:

; 2633 : 		}
; 2634 : 	}

	jmp	$LN15@pfnMessage
$LN5@pfnMessage:

; 2635 : 	else if( svgame.msg[svgame.msg_index].size != -1 )

	imul	eax, DWORD PTR _svgame+7892, 40
	cmp	DWORD PTR _svgame[eax+40], -1
	je	SHORT $LN11@pfnMessage

; 2636 : 	{
; 2637 : 		int	expsize = svgame.msg[svgame.msg_index].size;

	imul	ecx, DWORD PTR _svgame+7892, 40
	mov	edx, DWORD PTR _svgame[ecx+40]
	mov	DWORD PTR _expsize$2[ebp], edx

; 2638 : 		int	realsize = svgame.msg_realsize;

	mov	eax, DWORD PTR _svgame+7888
	mov	DWORD PTR _realsize$3[ebp], eax

; 2639 : 	
; 2640 : 		// compare sizes
; 2641 : 		if( expsize != realsize )

	mov	ecx, DWORD PTR _expsize$2[ebp]
	cmp	ecx, DWORD PTR _realsize$3[ebp]
	je	SHORT $LN13@pfnMessage

; 2642 : 		{
; 2643 : 			Con_Printf( S_ERROR "SV_Multicast: %s expected %i bytes, it written %i. Ignored.\n", name, expsize, realsize );

	mov	edx, DWORD PTR _realsize$3[ebp]
	push	edx
	mov	eax, DWORD PTR _expsize$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138549
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 2644 : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2645 : 			return;

	jmp	$LN1@pfnMessage
$LN13@pfnMessage:

; 2646 : 		}
; 2647 : 	}

	jmp	$LN15@pfnMessage
$LN11@pfnMessage:

; 2648 : 	else if( svgame.msg_size_index != -1 )

	cmp	DWORD PTR _svgame+7884, -1
	je	SHORT $LN14@pfnMessage

; 2649 : 	{
; 2650 : 		// variable sized message
; 2651 : 		if( svgame.msg_realsize > MAX_USERMSG_LENGTH )

	cmp	DWORD PTR _svgame+7888, 2048		; 00000800H
	jle	SHORT $LN16@pfnMessage

; 2652 : 		{
; 2653 : 			Con_Printf( S_ERROR "SV_Multicast: %s too long (more than %d bytes)\n", name, MAX_USERMSG_LENGTH );

	push	2048					; 00000800H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG138554
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2654 : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2655 : 			return;

	jmp	$LN1@pfnMessage

; 2656 : 		}

	jmp	SHORT $LN18@pfnMessage
$LN16@pfnMessage:

; 2657 : 		else if( svgame.msg_realsize < 0 )

	cmp	DWORD PTR _svgame+7888, 0
	jge	SHORT $LN18@pfnMessage

; 2658 : 		{
; 2659 : 			Con_Printf( S_ERROR "SV_Multicast: %s writes NULL message\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG138556
	call	_Con_Printf
	add	esp, 8

; 2660 : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2661 : 			return;

	jmp	$LN1@pfnMessage
$LN18@pfnMessage:

; 2662 : 		}
; 2663 : 
; 2664 : 		*(word *)&sv.multicast.pData[svgame.msg_size_index] = svgame.msg_realsize;

	mov	ecx, DWORD PTR _sv+1212168
	add	ecx, DWORD PTR _svgame+7884
	mov	dx, WORD PTR _svgame+7888
	mov	WORD PTR [ecx], dx

; 2665 : 	}

	jmp	SHORT $LN15@pfnMessage
$LN14@pfnMessage:

; 2666 : 	else
; 2667 : 	{
; 2668 : 		// this should never happen
; 2669 : 		Con_Printf( S_ERROR "SV_Multicast: %s have encountered error\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG138557
	call	_Con_Printf
	add	esp, 8

; 2670 : 		MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 2671 : 		return;

	jmp	$LN1@pfnMessage
$LN15@pfnMessage:

; 2672 : 	}
; 2673 : 
; 2674 : 	// update some messages in case their was format was changed and we want to keep backward compatibility
; 2675 : 	if( svgame.msg_index < 0 )

	cmp	DWORD PTR _svgame+7892, 0
	jge	SHORT $LN20@pfnMessage

; 2676 : 	{
; 2677 : 		int	svc_msg = abs( svgame.msg_index );

	mov	ecx, DWORD PTR _svgame+7892
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _svc_msg$1[ebp], eax

; 2678 : 
; 2679 : 		if(( svc_msg == svc_finale || svc_msg == svc_cutscene ) && svgame.msg_realsize == 0 )

	cmp	DWORD PTR _svc_msg$1[ebp], 31		; 0000001fH
	je	SHORT $LN21@pfnMessage
	cmp	DWORD PTR _svc_msg$1[ebp], 34		; 00000022H
	jne	SHORT $LN20@pfnMessage
$LN21@pfnMessage:
	cmp	DWORD PTR _svgame+7888, 0
	jne	SHORT $LN20@pfnMessage

; 2680 : 			MSG_WriteChar( &sv.multicast, 0 ); // write null string

	push	0
	push	OFFSET _sv+1212160
	call	_MSG_WriteChar
	add	esp, 8
$LN20@pfnMessage:

; 2681 : 	}
; 2682 : 
; 2683 : 	if( !VectorIsNull( svgame.msg_org )) org = svgame.msg_org;

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _svgame[eax+7908]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@pfnMessage
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _svgame[ecx+7908]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@pfnMessage
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _svgame[edx+7908]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@pfnMessage
$LN23@pfnMessage:
	mov	DWORD PTR _org$[ebp], OFFSET _svgame+7908
$LN22@pfnMessage:

; 2684 : 	svgame.msg_dest = bound( MSG_BROADCAST, svgame.msg_dest, MSG_SPEC );

	cmp	DWORD PTR _svgame+7896, 0
	jl	SHORT $LN27@pfnMessage
	cmp	DWORD PTR _svgame+7896, 9
	jge	SHORT $LN25@pfnMessage
	mov	eax, DWORD PTR _svgame+7896
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN26@pfnMessage
$LN25@pfnMessage:
	mov	DWORD PTR tv165[ebp], 9
$LN26@pfnMessage:
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	jmp	SHORT $LN28@pfnMessage
$LN27@pfnMessage:
	mov	DWORD PTR tv166[ebp], 0
$LN28@pfnMessage:
	mov	edx, DWORD PTR tv166[ebp]
	mov	DWORD PTR _svgame+7896, edx

; 2685 : 
; 2686 : 	SV_Multicast( svgame.msg_dest, org, svgame.msg_ent, true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _svgame+7904
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+7896
	push	edx
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN1@pfnMessage:

; 2687 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMessageEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv70 = -16						; size = 4
tv69 = -12						; size = 4
_iSize$ = -8						; size = 4
_i$ = -4						; size = 4
_msg_dest$ = 8						; size = 4
_msg_num$ = 12						; size = 4
_pOrigin$ = 16						; size = 4
_ed$ = 20						; size = 4
_pfnMessageBegin PROC

; 2533 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2534 : 	int	i, iSize;
; 2535 : 
; 2536 : 	if( svgame.msg_started )

	cmp	DWORD PTR _svgame+7900, 0
	je	SHORT $LN5@pfnMessage

; 2537 : 		Host_Error( "MessageBegin: New message started when msg '%s' has not been sent yet\n", svgame.msg_name );

	mov	eax, DWORD PTR _svgame
	push	eax
	push	OFFSET $SG138510
	call	_Host_Error
	add	esp, 8
$LN5@pfnMessage:

; 2538 : 	svgame.msg_started = true;

	mov	DWORD PTR _svgame+7900, 1

; 2539 : 
; 2540 : 	// check range
; 2541 : 	msg_num = bound( svc_bad, msg_num, 255 );

	cmp	DWORD PTR _msg_num$[ebp], 0
	jl	SHORT $LN19@pfnMessage
	cmp	DWORD PTR _msg_num$[ebp], 255		; 000000ffH
	jge	SHORT $LN17@pfnMessage
	mov	ecx, DWORD PTR _msg_num$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN18@pfnMessage
$LN17@pfnMessage:
	mov	DWORD PTR tv69[ebp], 255		; 000000ffH
$LN18@pfnMessage:
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN20@pfnMessage
$LN19@pfnMessage:
	mov	DWORD PTR tv70[ebp], 0
$LN20@pfnMessage:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR _msg_num$[ebp], eax

; 2542 : 
; 2543 : 	if( msg_num <= svc_lastmsg )

	cmp	DWORD PTR _msg_num$[ebp], 58		; 0000003aH
	jg	SHORT $LN6@pfnMessage

; 2544 : 	{
; 2545 : 		svgame.msg_index = -msg_num; // this is a system message

	mov	ecx, DWORD PTR _msg_num$[ebp]
	neg	ecx
	mov	DWORD PTR _svgame+7892, ecx

; 2546 : 		svgame.msg_name = svc_strings[msg_num];

	mov	edx, DWORD PTR _msg_num$[ebp]
	mov	eax, DWORD PTR _svc_strings[edx*4]
	mov	DWORD PTR _svgame, eax

; 2547 : 
; 2548 : 		if( msg_num == svc_temp_entity )

	cmp	DWORD PTR _msg_num$[ebp], 23		; 00000017H
	jne	SHORT $LN8@pfnMessage

; 2549 : 			iSize = -1; // temp entity have variable size

	mov	DWORD PTR _iSize$[ebp], -1
	jmp	SHORT $LN9@pfnMessage
$LN8@pfnMessage:

; 2550 : 		else iSize = 0;

	mov	DWORD PTR _iSize$[ebp], 0
$LN9@pfnMessage:

; 2551 : 	}

	jmp	$LN7@pfnMessage
$LN6@pfnMessage:

; 2552 : 	else
; 2553 : 	{
; 2554 : 		// check for existing
; 2555 : 		for( i = 1; i < MAX_USER_MESSAGES && svgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnMessage
$LN2@pfnMessage:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@pfnMessage:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@pfnMessage
	imul	edx, DWORD PTR _i$[ebp], 40
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _svgame[edx+ecx+4]
	test	edx, edx
	je	SHORT $LN3@pfnMessage

; 2556 : 		{
; 2557 : 			if( svgame.msg[i].number == msg_num )

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _svgame[eax+36]
	cmp	ecx, DWORD PTR _msg_num$[ebp]
	jne	SHORT $LN10@pfnMessage

; 2558 : 				break; // found

	jmp	SHORT $LN3@pfnMessage
$LN10@pfnMessage:

; 2559 : 		}

	jmp	SHORT $LN2@pfnMessage
$LN3@pfnMessage:

; 2560 : 
; 2561 : 		if( i == MAX_USER_MESSAGES )

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN11@pfnMessage

; 2562 : 		{
; 2563 : 			Host_Error( "MessageBegin: tried to send unregistered message %i\n", msg_num );

	mov	edx, DWORD PTR _msg_num$[ebp]
	push	edx
	push	OFFSET $SG138517
	call	_Host_Error
	add	esp, 8

; 2564 : 			return;

	jmp	$LN1@pfnMessage
$LN11@pfnMessage:

; 2565 : 		}
; 2566 : 
; 2567 : 		svgame.msg_name = svgame.msg[i].name;

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svgame+4
	mov	DWORD PTR _svgame, eax

; 2568 : 		iSize = svgame.msg[i].size;

	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	edx, DWORD PTR _svgame[ecx+40]
	mov	DWORD PTR _iSize$[ebp], edx

; 2569 : 		svgame.msg_index = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _svgame+7892, eax
$LN7@pfnMessage:

; 2570 : 	}
; 2571 : 
; 2572 : 	MSG_WriteCmdExt( &sv.multicast, msg_num, NS_SERVER, svgame.msg_name );

	mov	ecx, DWORD PTR _svgame
	push	ecx
	push	1
	mov	edx, DWORD PTR _msg_num$[ebp]
	push	edx
	push	OFFSET _sv+1212160
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2573 : 
; 2574 : 	// save message destination
; 2575 : 	if( pOrigin ) VectorCopy( pOrigin, svgame.msg_org );

	cmp	DWORD PTR _pOrigin$[ebp], 0
	je	SHORT $LN12@pfnMessage
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pOrigin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _svgame[eax+7908], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _svgame[eax+7908], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pOrigin$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _svgame[ecx+7908], eax
	jmp	SHORT $LN13@pfnMessage
$LN12@pfnMessage:

; 2576 : 	else VectorClear( svgame.msg_org );

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _svgame[ecx+7908], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _svgame[edx+7908], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _svgame[ecx+7908], xmm0
$LN13@pfnMessage:

; 2577 : 
; 2578 : 	if( iSize == -1 )

	cmp	DWORD PTR _iSize$[ebp], -1
	jne	SHORT $LN14@pfnMessage

; 2579 : 	{
; 2580 : 		// variable sized messages sent size as first short
; 2581 : 		svgame.msg_size_index = MSG_GetNumBytesWritten( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _svgame+7884, eax

; 2582 : 		MSG_WriteWord( &sv.multicast, 0 ); // reserve space for now

	push	0
	push	OFFSET _sv+1212160
	call	_MSG_WriteWord
	add	esp, 8

; 2583 : 	}

	jmp	SHORT $LN15@pfnMessage
$LN14@pfnMessage:

; 2584 : 	else svgame.msg_size_index = -1; // message has constant size

	mov	DWORD PTR _svgame+7884, -1
$LN15@pfnMessage:

; 2585 : 
; 2586 : 	svgame.msg_realsize = 0;

	mov	DWORD PTR _svgame+7888, 0

; 2587 : 	svgame.msg_dest = msg_dest;

	mov	edx, DWORD PTR _msg_dest$[ebp]
	mov	DWORD PTR _svgame+7896, edx

; 2588 : 	svgame.msg_ent = ed;

	mov	eax, DWORD PTR _ed$[ebp]
	mov	DWORD PTR _svgame+7904, eax
$LN1@pfnMessage:

; 2589 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMessageBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_style$ = 8						; size = 4
_val$ = 12						; size = 4
_pfnLightStyle PROC

; 2494 : {

	push	ebp
	mov	ebp, esp

; 2495 : 	if( style < 0 ) style = 0;

	cmp	DWORD PTR _style$[ebp], 0
	jge	SHORT $LN2@pfnLightSt
	mov	DWORD PTR _style$[ebp], 0
$LN2@pfnLightSt:

; 2496 : 	if( style >= MAX_LIGHTSTYLES )

	cmp	DWORD PTR _style$[ebp], 64		; 00000040H
	jl	SHORT $LN3@pfnLightSt

; 2497 : 		Host_Error( "SV_LightStyle: style: %i >= %d", style, MAX_LIGHTSTYLES );

	push	64					; 00000040H
	mov	eax, DWORD PTR _style$[ebp]
	push	eax
	push	OFFSET $SG138483
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN3@pfnLightSt:

; 2498 : 	if( sv.loadgame ) return; // don't let the world overwrite our restored styles

	cmp	DWORD PTR _sv+8, 0
	je	SHORT $LN4@pfnLightSt
	jmp	SHORT $LN1@pfnLightSt
$LN4@pfnLightSt:

; 2499 : 
; 2500 : 	SV_SetLightStyle( style, val, 0.0f ); // set correct style

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _style$[ebp]
	push	edx
	call	_SV_SetLightStyle
	add	esp, 12					; 0000000cH
$LN1@pfnLightSt:

; 2501 : }

	pop	ebp
	ret	0
_pfnLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv158 = -28						; size = 4
tv157 = -24						; size = 4
tv139 = -20						; size = 4
tv138 = -16						; size = 4
tv88 = -12						; size = 4
tv87 = -8						; size = 4
_v$ = -4						; size = 4
_org$ = 8						; size = 4
_dir$ = 12						; size = 4
_color$ = 16						; size = 4
_count$ = 20						; size = 4
_pfnParticleEffect PROC

; 2468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2469 : 	int	v;
; 2470 : 
; 2471 : 	if( MSG_GetNumBytesLeft( &sv.datagram ) < 16 )

	push	OFFSET _sv+1179352
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN2@pfnParticl

; 2472 : 		return;

	jmp	$LN1@pfnParticl
$LN2@pfnParticl:

; 2473 : 
; 2474 : 	MSG_BeginServerCmd( &sv.datagram, svc_particle );

	push	0
	push	1
	push	18					; 00000012H
	push	OFFSET _sv+1179352
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2475 : 	MSG_WriteVec3Coord( &sv.datagram, org );

	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	push	OFFSET _sv+1179352
	call	_MSG_WriteVec3Coord
	add	esp, 8

; 2476 : 	v = bound( -128, dir[0] * 16.0f, 127 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR __real@c3000000
	jb	SHORT $LN6@pfnParticl
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@42fe0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@pfnParticl
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN5@pfnParticl
$LN4@pfnParticl:
	movss	xmm0, DWORD PTR __real@42fe0000
	movss	DWORD PTR tv87[ebp], xmm0
$LN5@pfnParticl:
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN7@pfnParticl
$LN6@pfnParticl:
	movss	xmm0, DWORD PTR __real@c3000000
	movss	DWORD PTR tv88[ebp], xmm0
$LN7@pfnParticl:
	cvttss2si ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR _v$[ebp], ecx

; 2477 : 	MSG_WriteChar( &sv.datagram, v );

	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	push	OFFSET _sv+1179352
	call	_MSG_WriteChar
	add	esp, 8

; 2478 : 	v = bound( -128, dir[1] * 16.0f, 127 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR __real@c3000000
	jb	SHORT $LN10@pfnParticl
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@42fe0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@pfnParticl
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv138[ebp], xmm0
	jmp	SHORT $LN9@pfnParticl
$LN8@pfnParticl:
	movss	xmm0, DWORD PTR __real@42fe0000
	movss	DWORD PTR tv138[ebp], xmm0
$LN9@pfnParticl:
	movss	xmm0, DWORD PTR tv138[ebp]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN11@pfnParticl
$LN10@pfnParticl:
	movss	xmm0, DWORD PTR __real@c3000000
	movss	DWORD PTR tv139[ebp], xmm0
$LN11@pfnParticl:
	cvttss2si eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 2479 : 	MSG_WriteChar( &sv.datagram, v );

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	push	OFFSET _sv+1179352
	call	_MSG_WriteChar
	add	esp, 8

; 2480 : 	v = bound( -128, dir[2] * 16.0f, 127 );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR __real@c3000000
	jb	SHORT $LN14@pfnParticl
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR __real@42fe0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@pfnParticl
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv157[ebp], xmm0
	jmp	SHORT $LN13@pfnParticl
$LN12@pfnParticl:
	movss	xmm0, DWORD PTR __real@42fe0000
	movss	DWORD PTR tv157[ebp], xmm0
$LN13@pfnParticl:
	movss	xmm0, DWORD PTR tv157[ebp]
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN15@pfnParticl
$LN14@pfnParticl:
	movss	xmm0, DWORD PTR __real@c3000000
	movss	DWORD PTR tv158[ebp], xmm0
$LN15@pfnParticl:
	cvttss2si edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR _v$[ebp], edx

; 2481 : 	MSG_WriteChar( &sv.datagram, v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET _sv+1179352
	call	_MSG_WriteChar
	add	esp, 8

; 2482 : 	MSG_WriteByte( &sv.datagram, count );

	cvttss2si ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	OFFSET _sv+1179352
	call	_MSG_WriteByte
	add	esp, 8

; 2483 : 	MSG_WriteByte( &sv.datagram, color );

	cvttss2si edx, DWORD PTR _color$[ebp]
	push	edx
	push	OFFSET _sv+1179352
	call	_MSG_WriteByte
	add	esp, 8

; 2484 : 	MSG_WriteByte( &sv.datagram, 0 ); // z-vel

	push	0
	push	OFFSET _sv+1179352
	call	_MSG_WriteByte
	add	esp, 8
$LN1@pfnParticl:

; 2485 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnParticleEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_args$ = -268						; size = 4
_cl$ = -264						; size = 4
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_szFmt$ = 12						; size = 4
_pfnClientCommand PROC

; 2431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2432 : 	sv_client_t	*cl;
; 2433 : 	string		buffer;
; 2434 : 	va_list		args;
; 2435 : 
; 2436 : 	if( sv.state != ss_active )

	cmp	DWORD PTR _sv, 2
	je	SHORT $LN2@pfnClientC

; 2437 : 		return; // early out

	jmp	$LN1@pfnClientC
$LN2@pfnClientC:

; 2438 : 
; 2439 : 	if(( cl = SV_ClientFromEdict( pEdict, true )) == NULL )

	push	1
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax
	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN3@pfnClientC

; 2440 : 	{
; 2441 : 		Con_Printf( S_ERROR "stuffcmd: client is not spawned!\n" );

	push	OFFSET $SG138457
	call	_Con_Printf
	add	esp, 4

; 2442 : 		return;

	jmp	$LN1@pfnClientC
$LN3@pfnClientC:

; 2443 : 	}
; 2444 : 
; 2445 : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN4@pfnClientC

; 2446 : 		return;

	jmp	$LN1@pfnClientC
$LN4@pfnClientC:

; 2447 : 
; 2448 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 2449 : 	Q_vsnprintf( buffer, MAX_STRING, szFmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	256					; 00000100H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2450 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2451 : 
; 2452 : 	if( SV_IsValidCmd( buffer ))

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_SV_IsValidCmd
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@pfnClientC

; 2453 : 	{
; 2454 : 		MSG_BeginServerCmd( &cl->netchan.message, svc_stufftext );

	push	0
	push	1
	push	9
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2455 : 		MSG_WriteString( &cl->netchan.message, buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2456 : 	}

	jmp	SHORT $LN1@pfnClientC
$LN5@pfnClientC:

; 2457 : 	else Con_Printf( S_ERROR "Tried to stuff bad command %s\n", buffer );

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	OFFSET $SG138461
	call	_Con_Printf
	add	esp, 8
$LN1@pfnClientC:

; 2458 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pfnServerExecute PROC

; 2405 : {

	push	ebp
	mov	ebp, esp

; 2406 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 2407 : 
; 2408 : 	if( svgame.config_executed )

	cmp	DWORD PTR _svgame+7924, 0
	je	SHORT $LN2@pfnServerE

; 2409 : 		return;

	jmp	SHORT $LN1@pfnServerE
$LN2@pfnServerE:

; 2410 : 
; 2411 : 	// here we restore arhcived cvars only from game.dll
; 2412 : 	host.apply_game_config = true;

	mov	DWORD PTR _host+34388, 1

; 2413 : 	Cbuf_AddText( "exec config.cfg\n" );

	push	OFFSET $SG138434
	call	_Cbuf_AddText
	add	esp, 4

; 2414 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 2415 : 
; 2416 : 	if( host.sv_cvars_restored > 0 )

	cmp	DWORD PTR _host+34400, 0
	jle	SHORT $LN3@pfnServerE

; 2417 : 		Con_Reportf( "server executing ^2config.cfg^7 (%i cvars)\n", host.sv_cvars_restored );

	mov	eax, DWORD PTR _host+34400
	push	eax
	push	OFFSET $SG138436
	call	_Con_Reportf
	add	esp, 8
$LN3@pfnServerE:

; 2418 : 
; 2419 : 	host.apply_game_config = false;

	mov	DWORD PTR _host+34388, 0

; 2420 : 	svgame.config_executed = true;

	mov	DWORD PTR _svgame+7924, 1

; 2421 : 	host.sv_cvars_restored = 0;

	mov	DWORD PTR _host+34400, 0
$LN1@pfnServerE:

; 2422 : }

	pop	ebp
	ret	0
_pfnServerExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_str$ = 8						; size = 4
_pfnServerCommand PROC

; 2392 : {

	push	ebp
	mov	ebp, esp

; 2393 : 	if( !SV_IsValidCmd( str ))

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_SV_IsValidCmd
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnServerC

; 2394 : 		Con_Printf( S_ERROR "bad server command %s\n", str );

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	push	OFFSET $SG138429
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN1@pfnServerC
$LN2@pfnServerC:

; 2395 : 	else Cbuf_AddText( str );

	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_Cbuf_AddText
	add	esp, 4
$LN1@pfnServerC:

; 2396 : }

	pop	ebp
	ret	0
_pfnServerCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -256						; size = 56
$T2 = -200						; size = 56
tv285 = -144						; size = 4
tv196 = -140						; size = 4
tv157 = -136						; size = 4
_bestdist$ = -132					; size = 4
_dist$ = -128						; size = 4
_i$ = -124						; size = 4
_ilength$3 = -120					; size = 4
_j$ = -116						; size = 4
_check$ = -112						; size = 4
_tr$ = -108						; size = 56
_bestdir$ = -52						; size = 12
_end$ = -40						; size = 12
_start$ = -28						; size = 12
_dir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_speed$ = 12						; size = 4
_rgflReturn$ = 16					; size = 4
_pfnGetAimVector PROC

; 2319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2320 : 	edict_t		*check;
; 2321 : 	vec3_t		start, dir, end, bestdir;
; 2322 : 	float		dist, bestdist;
; 2323 : 	int		i, j;
; 2324 : 	trace_t		tr;
; 2325 : 
; 2326 : 	VectorCopy( svgame.globals->v_forward, rgflReturn );	// assume failure if it returns early

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	esi, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR [esi+ecx+40]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rgflReturn$[ebp]
	mov	esi, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR [esi+edx+40]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	esi, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR [esi+eax+40]
	mov	DWORD PTR [edx+ecx], eax

; 2327 : 
; 2328 : 	if( !SV_IsValidEdict( ent ) || FBitSet( ent->v.flags, FL_FAKECLIENT ))

	push	2328					; 00000918H
	push	OFFSET $SG138412
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@pfnGetAimV
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8192				; 00002000H
	je	SHORT $LN8@pfnGetAimV
$LN9@pfnGetAimV:

; 2329 : 		return;

	jmp	$LN1@pfnGetAimV
$LN8@pfnGetAimV:

; 2330 : 
; 2331 : 	VectorCopy( ent->v.origin, start );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+edx+136]
	mov	DWORD PTR _start$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _start$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR _start$[ebp+edx], ecx

; 2332 : 	VectorAdd( start, ent->v.view_ofs, start );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _start$[ebp+eax]
	addss	xmm0, DWORD PTR [ecx+edx+500]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _start$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _start$[ebp+ecx]
	addss	xmm0, DWORD PTR [eax+edx+500]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _start$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _start$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+500]
	movss	DWORD PTR tv157[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv157[ebp]
	movss	DWORD PTR _start$[ebp+edx], xmm0

; 2333 : 
; 2334 : 	// try sending a trace straight
; 2335 : 	VectorCopy( svgame.globals->v_forward, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _dir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR [ecx+edx+40]
	mov	DWORD PTR _dir$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR _dir$[ebp+ecx], eax

; 2336 : 	VectorMA( start, 2048, dir, end );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@45000000
	mulss	xmm0, DWORD PTR _dir$[ebp+ecx]
	addss	xmm0, DWORD PTR _start$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _end$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@45000000
	mulss	xmm0, DWORD PTR _dir$[ebp+edx]
	addss	xmm0, DWORD PTR _start$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _end$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@45000000
	mulss	xmm0, DWORD PTR _dir$[ebp+edx]
	movss	xmm1, DWORD PTR _start$[ebp+ecx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv196[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR _end$[ebp+eax], xmm0

; 2337 : 	tr = SV_Move( start, vec3_origin, vec3_origin, end, MOVE_NORMAL, ent, false );

	push	0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _end$[ebp]
	push	edx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 2338 : 
; 2339 : 	// don't aim at teammate
; 2340 : 	if( tr.ent && ( tr.ent->v.takedamage == DAMAGE_AIM || ent->v.team <= 0 || ent->v.team != tr.ent->v.team ))

	cmp	DWORD PTR _tr$[ebp+48], 0
	je	SHORT $LN10@pfnGetAimV
	mov	edx, DWORD PTR _tr$[ebp+48]
	movss	xmm0, DWORD PTR [edx+492]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@pfnGetAimV
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+556], 0
	jle	SHORT $LN11@pfnGetAimV
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _tr$[ebp+48]
	mov	eax, DWORD PTR [ecx+556]
	cmp	eax, DWORD PTR [edx+556]
	je	SHORT $LN10@pfnGetAimV
$LN11@pfnGetAimV:

; 2341 : 		return;

	jmp	$LN1@pfnGetAimV
$LN10@pfnGetAimV:

; 2342 : 
; 2343 : 	// try all possible entities
; 2344 : 	VectorCopy( svgame.globals->v_forward, bestdir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR [eax+edx+40]
	mov	DWORD PTR _bestdir$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR _bestdir$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR [eax+ecx+40]
	mov	DWORD PTR _bestdir$[ebp+edx], ecx

; 2345 : 	bestdist = Cvar_VariableValue( "sv_aim" );

	push	OFFSET $SG138415
	call	_Cvar_VariableValue
	add	esp, 4
	fstp	DWORD PTR _bestdist$[ebp]

; 2346 : 
; 2347 : 	check = EDICT_NUM( 1 ); // start at first client

	push	1
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 2348 : 	for( i = 1; i < svgame.numEntities; i++, check++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnGetAimV
$LN2@pfnGetAimV:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 804				; 00000324H
	mov	DWORD PTR _check$[ebp], eax
$LN4@pfnGetAimV:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svgame+7932
	jge	$LN3@pfnGetAimV

; 2349 : 	{
; 2350 : 		if( check->v.takedamage != DAMAGE_AIM )

	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+492]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@pfnGetAimV

; 2351 : 			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN12@pfnGetAimV:

; 2352 : 
; 2353 : 		if( FBitSet( check->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN13@pfnGetAimV

; 2354 :       			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN13@pfnGetAimV:

; 2355 : 
; 2356 : 		if( ent->v.team > 0 && ent->v.team == check->v.team )

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+556], 0
	jle	SHORT $LN14@pfnGetAimV
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [eax+556]
	cmp	edx, DWORD PTR [ecx+556]
	jne	SHORT $LN14@pfnGetAimV

; 2357 : 			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN14@pfnGetAimV:

; 2358 : 
; 2359 : 		if( check == ent )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _ent$[ebp]
	jne	SHORT $LN15@pfnGetAimV

; 2360 : 			continue;

	jmp	SHORT $LN2@pfnGetAimV
$LN15@pfnGetAimV:

; 2361 : 
; 2362 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@pfnGetAimV
$LN5@pfnGetAimV:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@pfnGetAimV:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@pfnGetAimV

; 2363 : 			end[j] = check->v.origin[j] + 0.5f * (check->v.mins[j] + check->v.maxs[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+348]
	addss	xmm0, DWORD PTR [esi+ecx*4+360]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _check$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4+136]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end$[ebp+ecx*4], xmm0
	jmp	SHORT $LN5@pfnGetAimV
$LN6@pfnGetAimV:

; 2364 : 
; 2365 : 		VectorSubtract( end, start, dir );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _end$[ebp+eax]
	subss	xmm0, DWORD PTR _start$[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _end$[ebp+edx]
	subss	xmm0, DWORD PTR _start$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _end$[ebp+edx]
	subss	xmm0, DWORD PTR _start$[ebp+eax]
	movss	DWORD PTR tv285[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv285[ebp]
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 2366 : 		VectorNormalize( dir );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _dir$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR _dir$[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _dir$[ebp+edx]
	mulss	xmm1, DWORD PTR _dir$[ebp+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@pfnGetAimV
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN16@pfnGetAimV:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 2367 : 		dist = DotProduct( dir, svgame.globals->v_forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax+40]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _svgame+19236
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx+40]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19236
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx+40]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 2368 : 
; 2369 : 		if( dist < bestdist )

	movss	xmm0, DWORD PTR _bestdist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN17@pfnGetAimV

; 2370 : 			continue; // to far to turn

	jmp	$LN2@pfnGetAimV
$LN17@pfnGetAimV:

; 2371 : 
; 2372 : 		tr = SV_Move( start, vec3_origin, vec3_origin, end, MOVE_NORMAL, ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 2373 : 
; 2374 : 		if( tr.ent == check )

	mov	ecx, DWORD PTR _tr$[ebp+48]
	cmp	ecx, DWORD PTR _check$[ebp]
	jne	SHORT $LN18@pfnGetAimV

; 2375 : 		{	
; 2376 : 			// can shoot at this one
; 2377 : 			VectorCopy( dir, bestdir );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dir$[ebp+eax]
	mov	DWORD PTR _bestdir$[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR _bestdir$[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR _bestdir$[ebp+edx], eax

; 2378 : 			bestdist = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _bestdist$[ebp], xmm0
$LN18@pfnGetAimV:

; 2379 : 		}
; 2380 : 	}

	jmp	$LN2@pfnGetAimV
$LN3@pfnGetAimV:

; 2381 : 
; 2382 : 	VectorCopy( bestdir, rgflReturn );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _rgflReturn$[ebp]
	mov	edx, DWORD PTR _bestdir$[ebp+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rgflReturn$[ebp]
	mov	eax, DWORD PTR _bestdir$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _rgflReturn$[ebp]
	mov	ecx, DWORD PTR _bestdir$[ebp+ecx]
	mov	DWORD PTR [eax+edx], ecx
$LN1@pfnGetAimV:

; 2383 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetAimVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_fNoMonsters$ = 16					; size = 4
_radius$ = 20						; size = 4
_pentToSkip$ = 24					; size = 4
_ptr$ = 28						; size = 4
_pfnTraceSphere PROC

; 2308 : {

	push	ebp
	mov	ebp, esp

; 2309 : }

	pop	ebp
	ret	0
_pfnTraceSphere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pTextureEntity$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_pfnTraceTexture PROC

; 2293 : {

	push	ebp
	mov	ebp, esp

; 2294 : 	if( !SV_IsValidEdict( pTextureEntity ))

	push	2294					; 000008f6H
	push	OFFSET $SG138369
	mov	eax, DWORD PTR _pTextureEntity$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceTe

; 2295 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 2296 : 
; 2297 : 	return SV_TraceTexture( pTextureEntity, v1, v2 );

	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTextureEntity$[ebp]
	push	eax
	call	_SV_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 2298 : }

	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_oldsolid$1 = -80					; size = 4
_oldmovetype$2 = -76					; size = 4
_model$ = -72						; size = 4
_mins$ = -68						; size = 4
_maxs$ = -64						; size = 4
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_hullNumber$ = 16					; size = 4
_pent$ = 20						; size = 4
_ptr$ = 24						; size = 4
_pfnTraceModel PROC

; 2244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2245 : 	float	*mins, *maxs;
; 2246 : 	model_t	*model;
; 2247 : 	trace_t	trace;
; 2248 : 
; 2249 : 	if( !SV_IsValidEdict( pent ))

	push	2249					; 000008c9H
	push	OFFSET $SG138352
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceMo

; 2250 : 		return;

	jmp	$LN1@pfnTraceMo
$LN2@pfnTraceMo:

; 2251 : 
; 2252 : 	if( hullNumber < 0 || hullNumber > 3 )

	cmp	DWORD PTR _hullNumber$[ebp], 0
	jl	SHORT $LN4@pfnTraceMo
	cmp	DWORD PTR _hullNumber$[ebp], 3
	jle	SHORT $LN3@pfnTraceMo
$LN4@pfnTraceMo:

; 2253 : 		hullNumber = 0;

	mov	DWORD PTR _hullNumber$[ebp], 0
$LN3@pfnTraceMo:

; 2254 : 
; 2255 : 	mins = sv.worldmodel->hulls[hullNumber].clip_mins;

	imul	ecx, DWORD PTR _hullNumber$[ebp], 40
	mov	edx, DWORD PTR _sv+1359676
	lea	eax, DWORD PTR [edx+ecx+224]
	mov	DWORD PTR _mins$[ebp], eax

; 2256 : 	maxs = sv.worldmodel->hulls[hullNumber].clip_maxs;

	imul	ecx, DWORD PTR _hullNumber$[ebp], 40
	mov	edx, DWORD PTR _sv+1359676
	lea	eax, DWORD PTR [edx+ecx+236]
	mov	DWORD PTR _maxs$[ebp], eax

; 2257 : 	model = SV_ModelHandle( pent->v.modelindex );

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+308]
	push	edx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 2258 : 
; 2259 : 	if( pent->v.solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+396], 5
	jne	SHORT $LN5@pfnTraceMo

; 2260 : 	{
; 2261 : 		// NOTE: always goes through custom clipping move
; 2262 : 		// even if our callbacks is not initialized
; 2263 : 		SV_CustomClipMoveToEntity( pent, v1, mins, maxs, v2, &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_SV_CustomClipMoveToEntity
	add	esp, 24					; 00000018H

; 2264 : 	}

	jmp	$LN6@pfnTraceMo
$LN5@pfnTraceMo:

; 2265 : 	else if( model && model->type == mod_brush )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN7@pfnTraceMo
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN7@pfnTraceMo

; 2266 : 	{
; 2267 : 		int oldmovetype = pent->v.movetype;

	mov	edx, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	DWORD PTR _oldmovetype$2[ebp], eax

; 2268 : 		int oldsolid = pent->v.solid;

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+396]
	mov	DWORD PTR _oldsolid$1[ebp], edx

; 2269 : 		pent->v.movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax+392], 7

; 2270 : 		pent->v.solid = SOLID_BSP;

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [ecx+396], 4

; 2271 : 
; 2272 :       		SV_ClipMoveToEntity( pent, v1, mins, maxs, v2, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR _v2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H

; 2273 : 
; 2274 : 		pent->v.movetype = oldmovetype;

	mov	edx, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR _oldmovetype$2[ebp]
	mov	DWORD PTR [edx+392], eax

; 2275 : 		pent->v.solid = oldsolid;

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR _oldsolid$1[ebp]
	mov	DWORD PTR [ecx+396], edx

; 2276 : 	}

	jmp	SHORT $LN6@pfnTraceMo
$LN7@pfnTraceMo:

; 2277 : 	else
; 2278 : 	{
; 2279 :       		SV_ClipMoveToEntity( pent, v1, mins, maxs, v2, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H
$LN6@pfnTraceMo:

; 2280 : 	}
; 2281 : 
; 2282 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8
$LN1@pfnTraceMo:

; 2283 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -124						; size = 56
_monsterClip$ = -68					; size = 4
tv72 = -64						; size = 4
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_fNoMonsters$ = 20					; size = 4
_pentToSkip$ = 24					; size = 4
_ptr$ = 28						; size = 4
_pfnTraceMonsterHull PROC

; 2221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2222 : 	qboolean	monsterClip;
; 2223 : 	trace_t	trace;
; 2224 : 
; 2225 : 	if( !SV_IsValidEdict( pEdict ))

	push	2225					; 000008b1H
	push	OFFSET $SG138330
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceMo

; 2226 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnTraceMo
$LN2@pfnTraceMo:

; 2227 : 
; 2228 : 	monsterClip = FBitSet( pEdict->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 8388608				; 00800000H
	je	SHORT $LN6@pfnTraceMo
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN7@pfnTraceMo
$LN6@pfnTraceMo:
	mov	DWORD PTR tv72[ebp], 0
$LN7@pfnTraceMo:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR _monsterClip$[ebp], eax

; 2229 : 	trace = SV_Move( v1, pEdict->v.mins, pEdict->v.maxs, v2, fNoMonsters, pentToSkip, monsterClip );

	mov	ecx, DWORD PTR _monsterClip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pentToSkip$[ebp]
	push	edx
	mov	eax, DWORD PTR _fNoMonsters$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEdict$[ebp]
	add	edx, 360				; 00000168H
	push	edx
	mov	eax, DWORD PTR _pEdict$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2230 : 	SV_ConvertTrace( ptr, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_SV_ConvertTrace
	add	esp, 8

; 2231 : 
; 2232 : 	if( trace.allsolid || trace.fraction != 1.0f )

	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN4@pfnTraceMo
	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@pfnTraceMo
$LN4@pfnTraceMo:

; 2233 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnTraceMo
$LN3@pfnTraceMo:

; 2234 : 	return false;

	xor	eax, eax
$LN1@pfnTraceMo:

; 2235 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceMonsterHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -116						; size = 56
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_fNoMonsters$ = 16					; size = 4
_hullNumber$ = 20					; size = 4
_pentToSkip$ = 24					; size = 4
_ptr$ = 28						; size = 4
_pfnTraceHull PROC

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2205 : 	trace_t	trace;
; 2206 : 
; 2207 : 	if( hullNumber < 0 || hullNumber > 3 )

	cmp	DWORD PTR _hullNumber$[ebp], 0
	jl	SHORT $LN3@pfnTraceHu
	cmp	DWORD PTR _hullNumber$[ebp], 3
	jle	SHORT $LN2@pfnTraceHu
$LN3@pfnTraceHu:

; 2208 : 		hullNumber = 0;

	mov	DWORD PTR _hullNumber$[ebp], 0
$LN2@pfnTraceHu:

; 2209 : 
; 2210 : 	trace = SV_Move( v1, sv.worldmodel->hulls[hullNumber].clip_mins, sv.worldmodel->hulls[hullNumber].clip_maxs, v2, fNoMonsters, pentToSkip, false );

	push	0
	mov	eax, DWORD PTR _pentToSkip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fNoMonsters$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _sv+1359676
	lea	edx, DWORD PTR [ecx+eax+236]
	push	edx
	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _sv+1359676
	lea	edx, DWORD PTR [ecx+eax+224]
	push	edx
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2211 : 	SV_ConvertTrace( ptr, &trace );

	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_SV_ConvertTrace
	add	esp, 8

; 2212 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -116						; size = 56
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_pent$ = 8						; size = 4
_pentToIgnore$ = 12					; size = 4
_ptr$ = 16						; size = 4
_pfnTraceToss PROC

; 2187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2188 : 	trace_t	trace;
; 2189 : 
; 2190 : 	if( !SV_IsValidEdict( pent ))

	push	2190					; 0000088eH
	push	OFFSET $SG138295
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceTo

; 2191 : 		return;

	jmp	SHORT $LN1@pfnTraceTo
$LN2@pfnTraceTo:

; 2192 : 
; 2193 : 	trace = SV_MoveToss( pent, pentToIgnore );

	mov	ecx, DWORD PTR _pentToIgnore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_MoveToss
	add	esp, 12					; 0000000cH
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2194 : 	SV_ConvertTrace( ptr, &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_SV_ConvertTrace
	add	esp, 8
$LN1@pfnTraceTo:

; 2195 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceToss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -116						; size = 56
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_fNoMonsters$ = 16					; size = 4
_pentToSkip$ = 20					; size = 4
_ptr$ = 24						; size = 4
_pfnTraceLine PROC

; 2171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2172 : 	trace_t	trace;
; 2173 : 
; 2174 : 	trace = SV_Move( v1, vec3_origin, vec3_origin, v2, fNoMonsters, pentToSkip, false );

	push	0
	mov	eax, DWORD PTR _pentToSkip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fNoMonsters$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v2$[ebp]
	push	edx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2175 : 	if( !SV_IsValidEdict( trace.ent ))

	push	2175					; 0000087fH
	push	OFFSET $SG138284
	mov	edx, DWORD PTR _trace$[ebp+48]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnTraceLi

; 2176 : 		trace.ent = svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	mov	DWORD PTR _trace$[ebp+48], eax
$LN2@pfnTraceLi:

; 2177 : 	SV_ConvertTrace( ptr, &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_SV_ConvertTrace
	add	esp, 8

; 2178 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_msg_dest$ = -4						; size = 4
_ent$ = 8						; size = 4
_pos$ = 12						; size = 4
_sample$ = 16						; size = 4
_vol$ = 20						; size = 4
_attn$ = 24						; size = 4
_flags$ = 28						; size = 4
_pitch$ = 32						; size = 4
_pfnEmitAmbientSound PROC

; 2133 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2134 : 	int	msg_dest;
; 2135 : 
; 2136 : 	if( sv.state == ss_loading )

	cmp	DWORD PTR _sv, 1
	jne	SHORT $LN2@pfnEmitAmb

; 2137 : 		SetBits( flags, SND_SPAWNING );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 256				; 00000100H
	mov	DWORD PTR _flags$[ebp], eax
$LN2@pfnEmitAmb:

; 2138 : 
; 2139 : 	if( FBitSet( flags, SND_SPAWNING ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN3@pfnEmitAmb

; 2140 : 		msg_dest = MSG_INIT;

	mov	DWORD PTR _msg_dest$[ebp], 3
	jmp	SHORT $LN4@pfnEmitAmb
$LN3@pfnEmitAmb:

; 2141 : 	else msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
$LN4@pfnEmitAmb:

; 2142 : 
; 2143 : 	// always sending stop sound command
; 2144 : 	if( FBitSet( flags, SND_STOP ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN5@pfnEmitAmb

; 2145 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
$LN5@pfnEmitAmb:

; 2146 : 
; 2147 : 	if( SV_BuildSoundMsg( &sv.multicast, ent, CHAN_STATIC, sample, vol * 255, attn, flags, pitch, pos ))

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _vol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _sample$[ebp]
	push	ecx
	push	6
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	OFFSET _sv+1212160
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN6@pfnEmitAmb

; 2148 : 		SV_Multicast( msg_dest, pos, NULL, false, false );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg_dest$[ebp]
	push	ecx
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN6@pfnEmitAmb:

; 2149 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEmitAmbientSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_rgflOrigin$ = 12					; size = 4
_pfnSetOrigin PROC

; 1974 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1975 : 	if( !SV_IsValidEdict( e ))

	push	1975					; 000007b7H
	push	OFFSET $SG138139
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnSetOrig

; 1976 : 		return;

	jmp	SHORT $LN1@pfnSetOrig
$LN2@pfnSetOrig:

; 1977 : 
; 1978 : 	VectorCopy( rgflOrigin, e->v.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _rgflOrigin$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+136], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _rgflOrigin$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+136], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _rgflOrigin$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+136], ecx

; 1979 : 	SV_LinkEdict( e, false );

	push	0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_LinkEdict
	add	esp, 8
$LN1@pfnSetOrig:

; 1980 : }

	pop	esi
	pop	ebp
	ret	0
_pfnSetOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv160 = -36						; size = 8
tv154 = -28						; size = 8
tv94 = -20						; size = 4
_move$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_yaw$ = 12						; size = 4
_dist$ = 16						; size = 4
_iMode$ = 20						; size = 4
_pfnWalkMove PROC

; 1943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1944 : 	vec3_t	move;
; 1945 : 
; 1946 : 	if( !SV_IsValidEdict( ent ))

	push	1946					; 0000079aH
	push	OFFSET $SG138127
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@pfnWalkMov

; 1947 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnWalkMov
$LN4@pfnWalkMov:

; 1948 : 
; 1949 : 	if( !FBitSet( ent->v.flags, FL_FLY|FL_SWIM|FL_ONGROUND ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 515				; 00000203H
	jne	SHORT $LN5@pfnWalkMov

; 1950 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnWalkMov
$LN5@pfnWalkMov:

; 1951 : 
; 1952 : 	yaw = DEG2RAD( yaw );

	movss	xmm0, DWORD PTR _yaw$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	movss	DWORD PTR _yaw$[ebp], xmm0

; 1953 : 	VectorSet( move, cos( yaw ) * dist, sin( yaw ) * dist, 0.0f );

	cvtss2sd xmm0, DWORD PTR _yaw$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv154[ebp]
	movsd	xmm0, QWORD PTR tv154[ebp]
	cvtss2sd xmm1, DWORD PTR _dist$[ebp]
	mulsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	cvtss2sd xmm0, DWORD PTR _yaw$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv160[ebp]
	movsd	xmm0, QWORD PTR tv160[ebp]
	cvtss2sd xmm1, DWORD PTR _dist$[ebp]
	mulsd	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _move$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _move$[ebp+eax], xmm0

; 1954 : 
; 1955 : 	switch( iMode )

	mov	ecx, DWORD PTR _iMode$[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN6@pfnWalkMov
	cmp	DWORD PTR tv94[ebp], 1
	je	SHORT $LN7@pfnWalkMov
	cmp	DWORD PTR tv94[ebp], 2
	je	SHORT $LN8@pfnWalkMov
	jmp	SHORT $LN2@pfnWalkMov
$LN6@pfnWalkMov:

; 1956 : 	{
; 1957 : 	case WALKMOVE_NORMAL:
; 1958 : 		return SV_MoveStep( ent, move, true );

	push	1
	lea	edx, DWORD PTR _move$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_MoveStep
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnWalkMov
$LN7@pfnWalkMov:

; 1959 : 	case WALKMOVE_WORLDONLY:
; 1960 : 		return SV_MoveTest( ent, move, true );

	push	1
	lea	ecx, DWORD PTR _move$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_MoveTest
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnWalkMov
$LN8@pfnWalkMov:

; 1961 : 	case WALKMOVE_CHECKONLY:
; 1962 : 		return SV_MoveStep( ent, move, false);

	push	0
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_MoveStep
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@pfnWalkMov
$LN2@pfnWalkMov:

; 1963 : 	}
; 1964 : 	return 0;

	xor	eax, eax
$LN1@pfnWalkMov:

; 1965 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnWalkMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -136						; size = 56
_monsterClip$ = -80					; size = 4
tv72 = -76						; size = 4
_trace$ = -72						; size = 56
_end$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_pfnDropToFloor PROC

; 1908 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1909 : 	qboolean	monsterClip;
; 1910 : 	trace_t	trace;
; 1911 : 	vec3_t	end;
; 1912 : 
; 1913 : 	if( !SV_IsValidEdict( e ))

	push	1913					; 00000779H
	push	OFFSET $SG138107
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnDropToF

; 1914 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDropToF
$LN2@pfnDropToF:

; 1915 : 
; 1916 : 	monsterClip = FBitSet( e->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 8388608				; 00800000H
	je	SHORT $LN6@pfnDropToF
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN7@pfnDropToF
$LN6@pfnDropToF:
	mov	DWORD PTR tv72[ebp], 0
$LN7@pfnDropToF:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR _monsterClip$[ebp], eax

; 1917 : 	VectorCopy( e->v.origin, end );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+edx+136]
	mov	DWORD PTR _end$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _end$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR _end$[ebp+edx], ecx

; 1918 : 	end[2] -= 256.0f;

	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _end$[ebp+edx]
	subss	xmm0, DWORD PTR __real@43800000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _end$[ebp+eax], xmm0

; 1919 : 
; 1920 : 	trace = SV_Move( e->v.origin, e->v.mins, e->v.maxs, end, MOVE_NORMAL, e, monsterClip );

	mov	ecx, DWORD PTR _monsterClip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 360				; 00000168H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 348				; 0000015cH
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1921 : 
; 1922 : 	if( trace.allsolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN3@pfnDropToF

; 1923 : 		return -1;

	or	eax, -1
	jmp	$LN1@pfnDropToF
$LN3@pfnDropToF:

; 1924 : 
; 1925 : 	if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnDropToF

; 1926 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDropToF
$LN4@pfnDropToF:

; 1927 : 
; 1928 : 	VectorCopy( trace.endpos, e->v.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [ecx+edx+136], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx

; 1929 : 	SV_LinkEdict( e, false );

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 1930 : 	SetBits( e->v.flags, FL_ONGROUND );

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+548], edx

; 1931 : 	e->v.groundentity = trace.ent;

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [ecx+540], edx

; 1932 : 
; 1933 : 	return 1;

	mov	eax, 1
$LN1@pfnDropToF:

; 1934 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDropToFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_pfnEntIsOnFloor PROC

; 1894 : {

	push	ebp
	mov	ebp, esp

; 1895 : 	if( !SV_IsValidEdict( e ))

	push	1895					; 00000767H
	push	OFFSET $SG138098
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnEntIsOn

; 1896 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnEntIsOn
$LN2@pfnEntIsOn:

; 1897 : 
; 1898 : 	return SV_CheckBottom( e, MOVE_NORMAL );

	push	0
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckBottom
	add	esp, 8
$LN1@pfnEntIsOn:

; 1899 : }

	pop	ebp
	ret	0
_pfnEntIsOnFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_state$ = -4						; size = 4
_ent$ = 8						; size = 4
_pfnMakeStatic PROC

; 1868 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1869 : 	entity_state_t	*state;
; 1870 : 
; 1871 : 	if( !SV_IsValidEdict( ent ))

	push	1871					; 0000074fH
	push	OFFSET $SG138091
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnMakeSta

; 1872 : 		return;

	jmp	$LN1@pfnMakeSta
$LN2@pfnMakeSta:

; 1873 : 
; 1874 : 	// fill the entity state
; 1875 : 	state = &svs.static_entities[sv.num_static_entities];	// allocate a new one

	imul	ecx, DWORD PTR _sv+332996, 340
	add	ecx, DWORD PTR _svs+33364
	mov	DWORD PTR _state$[ebp], ecx

; 1876 : 	svgame.dllFuncs.pfnCreateBaseline( false, NUM_FOR_EDICT( ent ), state, ent, 0, vec3_origin, vec3_origin );

	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	push	eax
	push	0
	call	DWORD PTR _svgame+19400
	add	esp, 28					; 0000001cH

; 1877 : 	state->messagenum = ent->v.model; // member modelname

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	mov	DWORD PTR [edx+12], ecx

; 1878 : 
; 1879 : 	if( SV_CreateStaticEntity( &sv.signon, sv.num_static_entities ))

	mov	edx, DWORD PTR _sv+332996
	push	edx
	push	OFFSET _sv+1220372
	call	_SV_CreateStaticEntity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@pfnMakeSta

; 1880 : 		sv.num_static_entities++;

	mov	eax, DWORD PTR _sv+332996
	add	eax, 1
	mov	DWORD PTR _sv+332996, eax
$LN3@pfnMakeSta:

; 1881 : 
; 1882 : 	// remove at end of the frame
; 1883 : 	SetBits( ent->v.flags, FL_KILLME );

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+548], edx
$LN1@pfnMakeSta:

; 1884 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMakeStatic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_className$ = 8						; size = 4
_pfnCreateNamedEntity PROC

; 1856 : {

	push	ebp
	mov	ebp, esp

; 1857 : 	return SV_CreateNamedEntity( NULL, className );

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	push	0
	call	_SV_CreateNamedEntity
	add	esp, 8

; 1858 : }

	pop	ebp
	ret	0
_pfnCreateNamedEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_rgflVector$ = 8					; size = 4
_pfnMakeVectors PROC

; 1823 : {

	push	ebp
	mov	ebp, esp

; 1824 : 	AngleVectors( rgflVector, svgame.globals->v_forward, svgame.globals->v_right, svgame.globals->v_up );

	mov	eax, DWORD PTR _svgame+19236
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _svgame+19236
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _svgame+19236
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _rgflVector$[ebp]
	push	eax
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 1825 : }

	pop	ebp
	ret	0
_pfnMakeVectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv95 = -36						; size = 4
_pchain$ = -32						; size = 4
_ptest$ = -28						; size = 4
_i$ = -24						; size = 4
_pent$ = -20						; size = 4
_viewpoint$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pview$ = 8						; size = 4
_pfnEntitiesInPVS PROC

; 1783 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1784 : 	edict_t	*pchain, *ptest;
; 1785 : 	vec3_t	viewpoint;
; 1786 : 	edict_t	*pent;
; 1787 : 	int	i;
; 1788 : 
; 1789 : 	if( !SV_IsValidEdict( pview ))

	push	1789					; 000006fdH
	push	OFFSET $SG138056
	mov	eax, DWORD PTR _pview$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@pfnEntitie

; 1790 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@pfnEntitie
$LN5@pfnEntitie:

; 1791 : 
; 1792 : 	VectorAdd( pview->v.origin, pview->v.view_ofs, viewpoint );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pview$[ebp]
	mov	esi, DWORD PTR _pview$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _viewpoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pview$[ebp]
	mov	esi, DWORD PTR _pview$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _viewpoint$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pview$[ebp]
	mov	esi, DWORD PTR _pview$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	movss	DWORD PTR tv95[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR _viewpoint$[ebp+ecx], xmm0

; 1793 : 	pchain = EDICT_NUM( 0 ); 

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pchain$[ebp], eax

; 1794 : 
; 1795 : 	for( i = 1; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnEntitie
$LN2@pfnEntitie:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@pfnEntitie:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN3@pfnEntitie

; 1796 : 	{
; 1797 : 		pent = EDICT_NUM( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax

; 1798 : 
; 1799 : 		if( !SV_IsValidEdict( pent ))

	push	1799					; 00000707H
	push	OFFSET $SG138058
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@pfnEntitie

; 1800 : 			continue;

	jmp	SHORT $LN2@pfnEntitie
$LN6@pfnEntitie:

; 1801 : 
; 1802 : 		if( pent->v.movetype == MOVETYPE_FOLLOW && SV_IsValidEdict( pent->v.aiment ))

	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+392], 12			; 0000000cH
	jne	SHORT $LN7@pfnEntitie
	push	1802					; 0000070aH
	push	OFFSET $SG138061
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@pfnEntitie

; 1803 : 			ptest = pent->v.aiment;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	mov	DWORD PTR _ptest$[ebp], ecx
	jmp	SHORT $LN8@pfnEntitie
$LN7@pfnEntitie:

; 1804 : 		else ptest = pent;

	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR _ptest$[ebp], edx
$LN8@pfnEntitie:

; 1805 : 
; 1806 : 		if( SV_BoxInPVS( viewpoint, ptest->v.absmin, ptest->v.absmax ))

	mov	eax, DWORD PTR _ptest$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	mov	ecx, DWORD PTR _ptest$[ebp]
	add	ecx, 324				; 00000144H
	push	ecx
	lea	edx, DWORD PTR _viewpoint$[ebp]
	push	edx
	call	_SV_BoxInPVS
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@pfnEntitie

; 1807 : 		{
; 1808 : 			pent->v.chain = pchain;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR _pchain$[ebp]
	mov	DWORD PTR [eax+520], ecx

; 1809 : 			pchain = pent;

	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR _pchain$[ebp], edx
$LN9@pfnEntitie:

; 1810 : 		}
; 1811 : 	}

	jmp	$LN2@pfnEntitie
$LN3@pfnEntitie:

; 1812 : 
; 1813 : 	return pchain;

	mov	eax, DWORD PTR _pchain$[ebp]
$LN1@pfnEntitie:

; 1814 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEntitiesInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv219 = -56						; size = 4
tv192 = -52						; size = 4
tv168 = -48						; size = 4
_bMergePVS$ = -44					; size = 4
_pClient$ = -40						; size = 4
tv237 = -36						; size = 4
_delta$ = -32						; size = 4
tv75 = -28						; size = 4
_leaf$ = -24						; size = 4
_mod$ = -20						; size = 4
_view$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_pfnFindClientInPVS PROC

; 1724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1725 : 	edict_t	*pClient;
; 1726 : 	vec3_t	view;
; 1727 : 	float	delta;
; 1728 : 	model_t	*mod;
; 1729 : 	qboolean	bMergePVS;
; 1730 : 	mleaf_t	*leaf;
; 1731 : 
; 1732 : 	if( !SV_IsValidEdict( pEdict ))

	push	1732					; 000006c4H
	push	OFFSET $SG138035
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnFindCli

; 1733 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@pfnFindCli
$LN2@pfnFindCli:

; 1734 : 
; 1735 : 	delta = ( sv.time - sv.lastchecktime );

	movsd	xmm0, QWORD PTR _sv+16
	subsd	xmm0, QWORD PTR _sv+184
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _delta$[ebp], xmm0

; 1736 : 
; 1737 : 	// don't merge visibility for portal entity, only for monsters
; 1738 : 	bMergePVS = FBitSet( pEdict->v.flags, FL_MONSTER ) ? true : false;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 32					; 00000020H
	je	SHORT $LN10@pfnFindCli
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN11@pfnFindCli
$LN10@pfnFindCli:
	mov	DWORD PTR tv75[ebp], 0
$LN11@pfnFindCli:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _bMergePVS$[ebp], eax

; 1739 : 
; 1740 : 	// find a new check if on a new frame
; 1741 : 	if( delta < 0.0f || delta >= 0.1f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _delta$[ebp]
	ja	SHORT $LN4@pfnFindCli
	movss	xmm0, DWORD PTR _delta$[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN3@pfnFindCli
$LN4@pfnFindCli:

; 1742 : 	{
; 1743 : 		sv.lastcheck = SV_CheckClientPVS( sv.lastcheck, bMergePVS );

	mov	ecx, DWORD PTR _bMergePVS$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sv+192
	push	edx
	call	_SV_CheckClientPVS
	add	esp, 8
	mov	DWORD PTR _sv+192, eax

; 1744 : 		sv.lastchecktime = sv.time;

	movsd	xmm0, QWORD PTR _sv+16
	movsd	QWORD PTR _sv+184, xmm0
$LN3@pfnFindCli:

; 1745 : 	}
; 1746 : 
; 1747 : 	// return check if it might be visible	
; 1748 : 	pClient = EDICT_NUM( sv.lastcheck );

	mov	eax, DWORD PTR _sv+192
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pClient$[ebp], eax

; 1749 : 
; 1750 : 	if( !SV_ClientFromEdict( pClient, true ))

	push	1
	mov	ecx, DWORD PTR _pClient$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@pfnFindCli

; 1751 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@pfnFindCli
$LN5@pfnFindCli:

; 1752 : 
; 1753 : 	mod = SV_ModelHandle( pEdict->v.modelindex );

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+308]
	push	eax
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 1754 : 
; 1755 : 	// portals & monitors
; 1756 : 	// NOTE: this specific break "radiaton tick" in normal half-life. use only as feature
; 1757 : 	if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ) && mod && mod->type == mod_brush && !FBitSet( mod->flags, MODEL_HAS_ORIGIN ))

	mov	ecx, DWORD PTR _host+34748
	and	ecx, 8
	je	$LN6@pfnFindCli
	cmp	DWORD PTR _mod$[ebp], 0
	je	$LN6@pfnFindCli
	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 0
	jne	$LN6@pfnFindCli
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	jne	$LN6@pfnFindCli

; 1758 : 	{
; 1759 : 		// handle PVS origin for bmodels
; 1760 : 		VectorAverage( pEdict->v.mins, pEdict->v.maxs, view );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+348]
	addss	xmm0, DWORD PTR [esi+edx+360]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _view$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+348]
	addss	xmm0, DWORD PTR [esi+edx+360]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _view$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+348]
	addss	xmm0, DWORD PTR [esi+eax+360]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv168[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv168[ebp]
	movss	DWORD PTR _view$[ebp+edx], xmm0

; 1761 : 		VectorAdd( view, pEdict->v.origin, view );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR _view$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+136]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _view$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR _view$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+136]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _view$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR _view$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+136]
	movss	DWORD PTR tv192[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv192[ebp]
	movss	DWORD PTR _view$[ebp+eax], xmm0

; 1762 : 	}

	jmp	$LN7@pfnFindCli
$LN6@pfnFindCli:

; 1763 : 	else
; 1764 : 	{
; 1765 : 		VectorAdd( pEdict->v.origin, pEdict->v.view_ofs, view );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _view$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _view$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	esi, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	movss	DWORD PTR tv219[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR _view$[ebp+ecx], xmm0
$LN7@pfnFindCli:

; 1766 : 	}
; 1767 : 
; 1768 : 	leaf = Mod_PointInLeaf( view, sv.worldmodel->nodes );

	mov	edx, DWORD PTR _sv+1359676
	mov	eax, DWORD PTR [edx+164]
	push	eax
	lea	ecx, DWORD PTR _view$[ebp]
	push	ecx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 1769 : 
; 1770 : 	if( CHECKVISBIT( clientpvs, leaf->cluster ))

	mov	edx, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jl	SHORT $LN12@pfnFindCli
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	sar	ecx, 3
	movzx	edx, BYTE PTR _clientpvs[ecx]
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv237[ebp], ecx
	jmp	SHORT $LN13@pfnFindCli
$LN12@pfnFindCli:
	mov	DWORD PTR tv237[ebp], 0
$LN13@pfnFindCli:
	cmp	DWORD PTR tv237[ebp], 0
	je	SHORT $LN8@pfnFindCli

; 1771 : 		return pClient; // client which currently in PVS

	mov	eax, DWORD PTR _pClient$[ebp]
	jmp	SHORT $LN1@pfnFindCli
$LN8@pfnFindCli:

; 1772 : 
; 1773 : 	return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
$LN1@pfnFindCli:

; 1774 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFindClientInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv193 = -60						; size = 4
tv147 = -56						; size = 4
tv67 = -52						; size = 4
tv66 = -48						; size = 4
_cl$ = -44						; size = 4
_k$ = -40						; size = 4
_pvs$ = -36						; size = 4
_j$ = -32						; size = 4
_view$1 = -28						; size = 4
_i$ = -24						; size = 4
_ent$ = -20						; size = 4
_vieworg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_check$ = 8						; size = 4
_bMergePVS$ = 12					; size = 4
_SV_CheckClientPVS PROC

; 1659 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1660 : 	byte		*pvs;
; 1661 : 	vec3_t		vieworg;
; 1662 : 	sv_client_t	*cl;
; 1663 : 	int		i, j, k;
; 1664 : 	edict_t		*ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 1665 : 
; 1666 : 	// cycle to the next one
; 1667 : 	check = bound( 1, check, svs.maxclients );

	cmp	DWORD PTR _check$[ebp], 1
	jl	SHORT $LN23@SV_CheckCl
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN21@SV_CheckCl
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	jmp	SHORT $LN22@SV_CheckCl
$LN21@SV_CheckCl:
	mov	edx, DWORD PTR _svs+16
	mov	DWORD PTR tv66[ebp], edx
$LN22@SV_CheckCl:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN24@SV_CheckCl
$LN23@SV_CheckCl:
	mov	DWORD PTR tv67[ebp], 1
$LN24@SV_CheckCl:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _check$[ebp], ecx

; 1668 : 
; 1669 : 	if( check == svs.maxclients )

	mov	edx, DWORD PTR _check$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jne	SHORT $LN11@SV_CheckCl

; 1670 : 		i = 1; // reset cycle

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN12@SV_CheckCl
$LN11@SV_CheckCl:

; 1671 : 	else i = check + 1;

	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@SV_CheckCl:

; 1672 : 
; 1673 : 	for( ;; i++ )

	jmp	SHORT $LN4@SV_CheckCl
$LN2@SV_CheckCl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_CheckCl:

; 1674 : 	{
; 1675 : 		if( i == ( svs.maxclients + 1 ))

	mov	edx, DWORD PTR _svs+16
	add	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jne	SHORT $LN13@SV_CheckCl

; 1676 : 			i = 1;

	mov	DWORD PTR _i$[ebp], 1
$LN13@SV_CheckCl:

; 1677 : 
; 1678 : 		ent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1679 : 		if( i == check ) break; // didn't find anything else

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _check$[ebp]
	jne	SHORT $LN14@SV_CheckCl
	jmp	SHORT $LN3@SV_CheckCl
$LN14@SV_CheckCl:

; 1680 : 
; 1681 : 		if( ent->free || !ent->pvPrivateData || FBitSet( ent->v.flags, FL_NOTARGET ))

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN16@SV_CheckCl
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN16@SV_CheckCl
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 128				; 00000080H
	je	SHORT $LN15@SV_CheckCl
$LN16@SV_CheckCl:

; 1682 : 			continue;

	jmp	SHORT $LN2@SV_CheckCl
$LN15@SV_CheckCl:

; 1683 : 
; 1684 : 		// anything that is a client, or has a client as an enemy
; 1685 : 		break;

	jmp	SHORT $LN3@SV_CheckCl

; 1686 : 	}

	jmp	SHORT $LN2@SV_CheckCl
$LN3@SV_CheckCl:

; 1687 : 
; 1688 : 	cl = SV_ClientFromEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax

; 1689 : 	memset( clientpvs, 0xFF, world.visbytes );

	mov	ecx, DWORD PTR _world+2592
	push	ecx
	push	255					; 000000ffH
	push	OFFSET _clientpvs
	call	_memset
	add	esp, 12					; 0000000cH

; 1690 : 
; 1691 : 	// get the PVS for the entity
; 1692 : 	VectorAdd( ent->v.origin, ent->v.view_ofs, vieworg );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vieworg$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vieworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+500]
	movss	DWORD PTR tv147[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR _vieworg$[ebp+edx], xmm0

; 1693 : 	pvs = Mod_GetPVSForPoint( vieworg );

	lea	eax, DWORD PTR _vieworg$[ebp]
	push	eax
	call	_Mod_GetPVSForPoint
	add	esp, 4
	mov	DWORD PTR _pvs$[ebp], eax

; 1694 : 	if( pvs ) memcpy( clientpvs, pvs, world.visbytes );

	cmp	DWORD PTR _pvs$[ebp], 0
	je	SHORT $LN17@SV_CheckCl
	mov	ecx, DWORD PTR _world+2592
	push	ecx
	mov	edx, DWORD PTR _pvs$[ebp]
	push	edx
	push	OFFSET _clientpvs
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@SV_CheckCl:

; 1695 : 
; 1696 : 	// transition in progress
; 1697 : 	if( !cl ) return i;

	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN18@SV_CheckCl
	mov	eax, DWORD PTR _i$[ebp]
	jmp	$LN1@SV_CheckCl
$LN18@SV_CheckCl:

; 1698 : 
; 1699 : 	// now merge PVS with all the portal cameras
; 1700 : 	for( k = 0; k < cl->num_viewents && bMergePVS; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@SV_CheckCl
$LN5@SV_CheckCl:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@SV_CheckCl:
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR [ecx+265500]
	jge	$LN6@SV_CheckCl
	cmp	DWORD PTR _bMergePVS$[ebp], 0
	je	$LN6@SV_CheckCl

; 1701 : 	{
; 1702 : 		edict_t	*view = cl->viewentity[k];

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+264988]
	mov	DWORD PTR _view$1[ebp], edx

; 1703 : 
; 1704 : 		if( !SV_IsValidEdict( view ))

	push	1704					; 000006a8H
	push	OFFSET $SG138021
	mov	eax, DWORD PTR _view$1[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@SV_CheckCl

; 1705 : 			continue;

	jmp	SHORT $LN5@SV_CheckCl
$LN19@SV_CheckCl:

; 1706 : 
; 1707 : 		VectorAdd( view->v.origin, view->v.view_ofs, vieworg );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [eax+edx+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vieworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vieworg$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _vieworg$[ebp+ecx], xmm0

; 1708 : 		pvs = Mod_GetPVSForPoint( vieworg );

	lea	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_Mod_GetPVSForPoint
	add	esp, 4
	mov	DWORD PTR _pvs$[ebp], eax

; 1709 : 
; 1710 : 		for( j = 0; j < world.visbytes && pvs; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_CheckCl
$LN8@SV_CheckCl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@SV_CheckCl:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _world+2592
	jae	SHORT $LN9@SV_CheckCl
	cmp	DWORD PTR _pvs$[ebp], 0
	je	SHORT $LN9@SV_CheckCl

; 1711 : 			SetBits( clientpvs[j], pvs[j] );

	mov	edx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR _clientpvs[edx]
	mov	ecx, DWORD PTR _pvs$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	eax, edx
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR _clientpvs[ecx], al
	jmp	SHORT $LN8@SV_CheckCl
$LN9@SV_CheckCl:

; 1712 : 	}

	jmp	$LN5@SV_CheckCl
$LN6@SV_CheckCl:

; 1713 : 
; 1714 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@SV_CheckCl:

; 1715 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckClientPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_distSquared$ = -20					; size = 4
_eorg$ = -16						; size = 4
_ent$ = -12						; size = 4
_e$ = -8						; size = 4
_j$ = -4						; size = 4
_pStartEdict$ = 8					; size = 4
_org$ = 12						; size = 4
_flRadius$ = 16						; size = 4
_pfnFindEntityInSphere PROC

; 1609 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1610 : 	float	distSquared;
; 1611 : 	int	j, e = 0;

	mov	DWORD PTR _e$[ebp], 0

; 1612 : 	float	eorg;
; 1613 : 	edict_t	*ent;
; 1614 : 
; 1615 : 	flRadius *= flRadius;

	movss	xmm0, DWORD PTR _flRadius$[ebp]
	mulss	xmm0, DWORD PTR _flRadius$[ebp]
	movss	DWORD PTR _flRadius$[ebp], xmm0

; 1616 : 
; 1617 : 	if( SV_IsValidEdict( pStartEdict ))

	push	1617					; 00000651H
	push	OFFSET $SG137979
	mov	eax, DWORD PTR _pStartEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@pfnFindEnt

; 1618 : 		e = NUM_FOR_EDICT( pStartEdict );

	mov	eax, DWORD PTR _pStartEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _e$[ebp], eax
$LN8@pfnFindEnt:

; 1619 : 
; 1620 : 	for( e++; e < svgame.numEntities; e++ )

	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 1
	mov	DWORD PTR _e$[ebp], edx
	jmp	SHORT $LN4@pfnFindEnt
$LN2@pfnFindEnt:
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
$LN4@pfnFindEnt:
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR _svgame+7932
	jge	$LN3@pfnFindEnt

; 1621 : 	{
; 1622 : 		ent = EDICT_NUM( e );

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1623 : 
; 1624 : 		if( !SV_IsValidEdict( ent ))

	push	1624					; 00000658H
	push	OFFSET $SG137981
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@pfnFindEnt

; 1625 : 			continue;

	jmp	SHORT $LN2@pfnFindEnt
$LN9@pfnFindEnt:

; 1626 : 
; 1627 : 		// ignore clients that not in a game
; 1628 : 		if( e <= svs.maxclients && !SV_ClientFromEdict( ent, true ))

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jg	SHORT $LN10@pfnFindEnt
	push	1
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@pfnFindEnt

; 1629 : 			continue;

	jmp	SHORT $LN2@pfnFindEnt
$LN10@pfnFindEnt:

; 1630 : 
; 1631 : 		distSquared = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _distSquared$[ebp], xmm0

; 1632 : 
; 1633 : 		for( j = 0; j < 3 && distSquared <= flRadius; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@pfnFindEnt
$LN5@pfnFindEnt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@pfnFindEnt:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@pfnFindEnt
	movss	xmm0, DWORD PTR _flRadius$[ebp]
	comiss	xmm0, DWORD PTR _distSquared$[ebp]
	jb	$LN6@pfnFindEnt

; 1634 : 		{
; 1635 : 			if( org[j] < ent->v.absmin[j] )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+324]
	comiss	xmm0, DWORD PTR [esi+eax*4]
	jbe	SHORT $LN11@pfnFindEnt

; 1636 : 				eorg = org[j] - ent->v.absmin[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [esi+eax*4+324]
	movss	DWORD PTR _eorg$[ebp], xmm0
	jmp	SHORT $LN14@pfnFindEnt
$LN11@pfnFindEnt:

; 1637 : 			else if( org[j] > ent->v.absmax[j] )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR [esi+eax*4+336]
	jbe	SHORT $LN13@pfnFindEnt

; 1638 : 				eorg = org[j] - ent->v.absmax[j];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [esi+eax*4+336]
	movss	DWORD PTR _eorg$[ebp], xmm0
	jmp	SHORT $LN14@pfnFindEnt
$LN13@pfnFindEnt:

; 1639 : 			else eorg = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _eorg$[ebp], xmm0
$LN14@pfnFindEnt:

; 1640 : 
; 1641 : 			distSquared += eorg * eorg;

	movss	xmm0, DWORD PTR _eorg$[ebp]
	mulss	xmm0, DWORD PTR _eorg$[ebp]
	addss	xmm0, DWORD PTR _distSquared$[ebp]
	movss	DWORD PTR _distSquared$[ebp], xmm0

; 1642 : 		}

	jmp	$LN5@pfnFindEnt
$LN6@pfnFindEnt:

; 1643 : 
; 1644 : 		if( distSquared < flRadius )

	movss	xmm0, DWORD PTR _flRadius$[ebp]
	comiss	xmm0, DWORD PTR _distSquared$[ebp]
	jbe	SHORT $LN15@pfnFindEnt

; 1645 : 			return ent;

	mov	eax, DWORD PTR _ent$[ebp]
	jmp	SHORT $LN1@pfnFindEnt
$LN15@pfnFindEnt:

; 1646 : 	}

	jmp	$LN2@pfnFindEnt
$LN3@pfnFindEnt:

; 1647 : 
; 1648 : 	return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
$LN1@pfnFindEnt:

; 1649 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFindEntityInSphere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEnt$ = 8						; size = 4
_pfnGetEntityIllum PROC

; 1594 : {

	push	ebp
	mov	ebp, esp

; 1595 : 	if( !SV_IsValidEdict( pEnt ))

	push	1595					; 0000063bH
	push	OFFSET $SG137956
	mov	eax, DWORD PTR _pEnt$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnGetEnti

; 1596 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnGetEnti
$LN2@pfnGetEnti:

; 1597 : 
; 1598 : 	return SV_LightForEntity( pEnt );

	mov	ecx, DWORD PTR _pEnt$[ebp]
	push	ecx
	call	_SV_LightForEntity
	add	esp, 4
$LN1@pfnGetEnti:

; 1599 : }

	pop	ebp
	ret	0
_pfnGetEntityIllum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnChangePitch PROC

; 1502 : {

	push	ebp
	mov	ebp, esp

; 1503 : 	if( !SV_IsValidEdict( ent ))

	push	1503					; 000005dfH
	push	OFFSET $SG137900
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnChangeP

; 1504 : 		return;

	jmp	SHORT $LN1@pfnChangeP
$LN2@pfnChangeP:

; 1505 : 
; 1506 : 	ent->v.angles[PITCH] = SV_AngleMod( ent->v.idealpitch, ent->v.angles[PITCH], ent->v.pitch_speed );	

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+296]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+208]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+292]
	movss	DWORD PTR [esp], xmm0
	call	_SV_AngleMod
	add	esp, 12					; 0000000cH
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [edx+ecx+208]
$LN1@pfnChangeP:

; 1507 : }

	pop	ebp
	ret	0
_pfnChangePitch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnChangeYaw PROC

; 1488 : {

	push	ebp
	mov	ebp, esp

; 1489 : 	if( !SV_IsValidEdict( ent ))

	push	1489					; 000005d1H
	push	OFFSET $SG137894
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnChangeY

; 1490 : 		return;

	jmp	SHORT $LN1@pfnChangeY
$LN2@pfnChangeY:

; 1491 : 
; 1492 : 	ent->v.angles[YAW] = SV_AngleMod( ent->v.ideal_yaw, ent->v.angles[YAW], ent->v.yaw_speed );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+304]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+208]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+300]
	movss	DWORD PTR [esp], xmm0
	call	_SV_AngleMod
	add	esp, 12					; 0000000cH
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [eax+edx+208]
$LN1@pfnChangeY:

; 1493 : }

	pop	ebp
	ret	0
_pfnChangeYaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pflGoal$ = 12						; size = 4
_dist$ = 16						; size = 4
_iMoveType$ = 20					; size = 4
_pfnMoveToOrigin PROC

; 1474 : {

	push	ebp
	mov	ebp, esp

; 1475 : 	if( !pflGoal || !SV_IsValidEdict( ent ))

	cmp	DWORD PTR _pflGoal$[ebp], 0
	je	SHORT $LN3@pfnMoveToO
	push	1475					; 000005c3H
	push	OFFSET $SG137888
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnMoveToO
$LN3@pfnMoveToO:

; 1476 : 		return;

	jmp	SHORT $LN1@pfnMoveToO
$LN2@pfnMoveToO:

; 1477 : 
; 1478 : 	SV_MoveToOrigin( ent, pflGoal, dist, iMoveType );

	mov	ecx, DWORD PTR _iMoveType$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _pflGoal$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_MoveToOrigin
	add	esp, 16					; 00000010H
$LN1@pfnMoveToO:

; 1479 : }

	pop	ebp
	ret	0
_pfnMoveToOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_rgflVector$ = 8					; size = 4
_pfnVecToYaw PROC

; 1463 : {

	push	ebp
	mov	ebp, esp

; 1464 : 	return SV_VecToYaw( rgflVector );

	mov	eax, DWORD PTR _rgflVector$[ebp]
	push	eax
	call	_SV_VecToYaw
	add	esp, 4

; 1465 : }

	pop	ebp
	ret	0
_pfnVecToYaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnSaveSpawnParms PROC

; 1453 : {

	push	ebp
	mov	ebp, esp

; 1454 : }

	pop	ebp
	ret	0
_pfnSaveSpawnParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_pfnGetSpawnParms PROC

; 1442 : {

	push	ebp
	mov	ebp, esp

; 1443 : }

	pop	ebp
	ret	0
_pfnGetSpawnParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
$T1 = -76						; size = 4
_text$ = -72						; size = 4
_landname$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_landmark$ = 12						; size = 4
_pfnChangeLevel PROC

; 1403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1404 : 	static uint	last_spawncount = 0;
; 1405 : 	char		landname[MAX_QPATH];
; 1406 : 	char		*text;
; 1407 : 
; 1408 : 	if( !COM_CheckString( level ) || sv.state != ss_active )

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@pfnChangeL
	cmp	DWORD PTR _sv, 2
	je	SHORT $LN4@pfnChangeL
$LN5@pfnChangeL:

; 1409 : 		return; // ???

	jmp	$LN8@pfnChangeL
$LN4@pfnChangeL:

; 1410 : 
; 1411 : 	// make sure we don't issue two changelevels
; 1412 : 	if( svs.spawncount == last_spawncount )

	mov	ecx, DWORD PTR _svs+33340
	cmp	ecx, DWORD PTR ?last_spawncount@?1??pfnChangeLevel@@9@9
	jne	SHORT $LN6@pfnChangeL

; 1413 : 		return;

	jmp	$LN8@pfnChangeL
$LN6@pfnChangeL:

; 1414 : 	last_spawncount = svs.spawncount;

	mov	edx, DWORD PTR _svs+33340
	mov	DWORD PTR ?last_spawncount@?1??pfnChangeLevel@@9@9, edx

; 1415 : 	landname[0] ='\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 64			; 00000040H
	jae	SHORT $LN9@pfnChangeL
	jmp	SHORT $LN10@pfnChangeL
$LN9@pfnChangeL:
	call	___report_rangecheckfailure
$LN10@pfnChangeL:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _landname$[ebp+edx], 0

; 1416 : 
; 1417 : #ifdef HACKS_RELATED_HLMODS
; 1418 : 	// g-cont. some level-designers wrote landmark name with space
; 1419 : 	// and Cmd_TokenizeString separating all the after space as next argument
; 1420 : 	// emulate this bug for compatibility
; 1421 : 	if( COM_CheckString( landmark ))

	mov	eax, DWORD PTR _landmark$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@pfnChangeL

; 1422 : 	{
; 1423 : 		text = (char *)landname;

	lea	ecx, DWORD PTR _landname$[ebp]
	mov	DWORD PTR _text$[ebp], ecx
$LN2@pfnChangeL:

; 1424 : 		while( *landmark && ((byte)*landmark) != ' ' )

	mov	edx, DWORD PTR _landmark$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@pfnChangeL
	mov	ecx, DWORD PTR _landmark$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN3@pfnChangeL

; 1425 : 			*text++ = *landmark++;

	mov	eax, DWORD PTR _text$[ebp]
	mov	ecx, DWORD PTR _landmark$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
	mov	ecx, DWORD PTR _landmark$[ebp]
	add	ecx, 1
	mov	DWORD PTR _landmark$[ebp], ecx
	jmp	SHORT $LN2@pfnChangeL
$LN3@pfnChangeL:

; 1426 : 		*text = '\0';

	mov	edx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [edx], 0
$LN7@pfnChangeL:

; 1427 : 	}
; 1428 : #else
; 1429 : 	Q_strncpy( landname, landmark, sizeof( landname ));
; 1430 : #endif
; 1431 : 	SV_QueueChangeLevel( level, landname );

	lea	eax, DWORD PTR _landname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	_SV_QueueChangeLevel
	add	esp, 8
$LN8@pfnChangeL:

; 1432 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_rgflMin$ = 12						; size = 4
_rgflMax$ = 16						; size = 4
_pfnSetSize PROC

; 1389 : {

	push	ebp
	mov	ebp, esp

; 1390 : 	if( !SV_IsValidEdict( e ))

	push	1390					; 0000056eH
	push	OFFSET $SG137844
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnSetSize

; 1391 : 		return;

	jmp	SHORT $LN1@pfnSetSize
$LN2@pfnSetSize:

; 1392 : 
; 1393 : 	SV_SetMinMaxSize( e, rgflMin, rgflMax, true );

	push	1
	mov	ecx, DWORD PTR _rgflMax$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rgflMin$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
$LN1@pfnSetSize:

; 1394 : }

	pop	ebp
	ret	0
_pfnSetSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pmodel$ = -4						; size = 4
_modelIndex$ = 8					; size = 4
_pfnModelFrames PROC

; 1374 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1375 : 	model_t	*pmodel = SV_ModelHandle( modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax

; 1376 : 
; 1377 : 	if( pmodel != NULL )

	cmp	DWORD PTR _pmodel$[ebp], 0
	je	SHORT $LN2@pfnModelFr

; 1378 : 		return pmodel->numframes;

	mov	ecx, DWORD PTR _pmodel$[ebp]
	mov	eax, DWORD PTR [ecx+72]
	jmp	SHORT $LN1@pfnModelFr
$LN2@pfnModelFr:

; 1379 : 	return 1;

	mov	eax, 1
$LN1@pfnModelFr:

; 1380 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnModelFrames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_found$ = -80						; size = 4
_mod$ = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_m$ = 12						; size = 4
_pfnSetModel PROC

; 1281 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1282 : 	char	name[MAX_QPATH];
; 1283 : 	qboolean	found = false;

	mov	DWORD PTR _found$[ebp], 0

; 1284 : 	model_t	*mod;
; 1285 : 	int	i;
; 1286 : 
; 1287 : 	if( !SV_IsValidEdict( e ))

	push	1287					; 00000507H
	push	OFFSET $SG137801
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@pfnSetMode

; 1288 : 		return;

	jmp	$LN1@pfnSetMode
$LN5@pfnSetMode:

; 1289 : 
; 1290 : 	if( *m == '\\' || *m == '/' ) m++;

	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN7@pfnSetMode
	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@pfnSetMode
$LN7@pfnSetMode:
	mov	edx, DWORD PTR _m$[ebp]
	add	edx, 1
	mov	DWORD PTR _m$[ebp], edx
$LN6@pfnSetMode:

; 1291 : 	Q_strncpy( name, m, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1292 : 	COM_FixSlashes( name );

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_COM_FixSlashes
	add	esp, 4

; 1293 : 
; 1294 : 	if( COM_CheckString( name ))

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@pfnSetMode

; 1295 : 	{
; 1296 : 		// check to see if model was properly precached
; 1297 : 		for( i = 1; i < MAX_MODELS && sv.model_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnSetMode
$LN2@pfnSetMode:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@pfnSetMode:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@pfnSetMode
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sv[edx+ecx+196]
	test	edx, edx
	je	SHORT $LN3@pfnSetMode

; 1298 : 		{
; 1299 : 			if( !Q_stricmp( sv.model_precache[i], name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+196
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@pfnSetMode

; 1300 : 			{
; 1301 : 				found = true;

	mov	DWORD PTR _found$[ebp], 1

; 1302 : 				break;

	jmp	SHORT $LN3@pfnSetMode
$LN9@pfnSetMode:

; 1303 : 			}
; 1304 : 		}

	jmp	SHORT $LN2@pfnSetMode
$LN3@pfnSetMode:

; 1305 : 
; 1306 : 		if( !found )

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN8@pfnSetMode

; 1307 : 		{
; 1308 : 			Con_Printf( S_ERROR "no precache: %s\n", name );

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG137807
	call	_Con_Printf
	add	esp, 8

; 1309 : 			return;

	jmp	$LN1@pfnSetMode
$LN8@pfnSetMode:

; 1310 : 		}
; 1311 : 	}
; 1312 : 
; 1313 : 	if( e == svgame.edicts )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7928
	jne	SHORT $LN11@pfnSetMode

; 1314 : 	{
; 1315 : 		if( sv.state == ss_active )

	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN12@pfnSetMode

; 1316 : 			Con_Printf( S_ERROR "world model can't be changed\n" );

	push	OFFSET $SG137810
	call	_Con_Printf
	add	esp, 4
$LN12@pfnSetMode:

; 1317 : 		return;

	jmp	$LN1@pfnSetMode
$LN11@pfnSetMode:

; 1318 : 	}
; 1319 : 
; 1320 : 	if( COM_CheckString( name ))

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@pfnSetMode

; 1321 : 	{
; 1322 : 		e->v.model = MAKE_STRING( sv.model_precache[i] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+196
	push	edx
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 1323 : 		e->v.modelindex = i;

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+308], eax

; 1324 : 		mod = sv.models[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sv[ecx*4+328900]
	mov	DWORD PTR _mod$[ebp], edx

; 1325 : 	}

	jmp	SHORT $LN14@pfnSetMode
$LN13@pfnSetMode:

; 1326 : 	else
; 1327 : 	{
; 1328 : 		// model will be cleared
; 1329 : 		e->v.model = e->v.modelindex = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+308], 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [ecx+312], 0

; 1330 : 		mod = NULL;

	mov	DWORD PTR _mod$[ebp], 0
$LN14@pfnSetMode:

; 1331 : 	}
; 1332 : 
; 1333 : 	// set the model size
; 1334 : 	if( mod && mod->type != mod_studio )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN15@pfnSetMode
	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 3
	je	SHORT $LN15@pfnSetMode

; 1335 : 		SV_SetMinMaxSize( e, mod->mins, mod->maxs, true );

	push	1
	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnSetMode
$LN15@pfnSetMode:

; 1336 : 	else SV_SetMinMaxSize( e, vec3_origin, vec3_origin, true );

	push	1
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
$LN1@pfnSetMode:

; 1337 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_len$ = -4						; size = 4
_pCmd$ = 8						; size = 4
_SV_IsValidCmd PROC

; 1202 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1203 : 	size_t	len = Q_strlen( pCmd );

	mov	eax, DWORD PTR _pCmd$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1204 : 
; 1205 : 	// valid commands all have a ';' or newline '\n' as their last character
; 1206 : 	if( len && ( pCmd[len-1] == '\n' || pCmd[len-1] == ';' ))

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN2@SV_IsValid
	mov	ecx, DWORD PTR _pCmd$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN3@SV_IsValid
	mov	eax, DWORD PTR _pCmd$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN2@SV_IsValid
$LN3@SV_IsValid:

; 1207 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsValid
$LN2@SV_IsValid:

; 1208 : 	return false;

	xor	eax, eax
$LN1@SV_IsValid:

; 1209 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_IsValidCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pszClassName$ = 8					; size = 4
_SV_GetEntityClass PROC

; 1052 : {

	push	ebp
	mov	ebp, esp

; 1053 : 	// allocate edict private memory (passed by dlls)
; 1054 : 	return (LINK_ENTITY_FUNC)COM_GetProcAddress( svgame.hInstance, pszClassName );

	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_GetProcAddress
	add	esp, 8

; 1055 : }

	pop	ebp
	ret	0
_SV_GetEntityClass ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ft1$ = -2596						; size = 4
_lumpofs$ = -2592					; size = 4
_ft2$ = -2588						; size = 4
_header$ = -2584					; size = 4
tv84 = -2580						; size = 4
_lumplen$ = -2576					; size = 4
_ents$ = -2572						; size = 4
_f$ = -2568						; size = 4
_buf$ = -2564						; size = 2048
_entfilename$ = -516					; size = 256
_bspfilename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_flags$ = 12						; size = 4
_SV_ReadEntityScript PROC

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2596				; 00000a24H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 803  : 	string		bspfilename, entfilename;
; 804  : 	int		lumpofs = 0, lumplen = 0;

	mov	DWORD PTR _lumpofs$[ebp], 0
	mov	DWORD PTR _lumplen$[ebp], 0

; 805  : 	byte		buf[MAX_TOKEN];
; 806  : 	char		*ents = NULL;

	mov	DWORD PTR _ents$[ebp], 0

; 807  : 	dheader_t		*header;
; 808  : 	size_t		ft1, ft2;
; 809  : 	file_t		*f;
; 810  : 
; 811  : 	*flags = 0;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax], 0

; 812  : 
; 813  : 	Q_strncpy( bspfilename, va( "maps/%s.bsp", filename ), sizeof( bspfilename ));			

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG137624
	call	_va
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _bspfilename$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 814  : 	f = FS_Open( bspfilename, "rb", false );

	push	0
	push	OFFSET $SG137625
	lea	eax, DWORD PTR _bspfilename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 815  : 	if( !f ) return NULL;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@SV_ReadEnt
	xor	eax, eax
	jmp	$LN1@SV_ReadEnt
$LN2@SV_ReadEnt:

; 816  : 
; 817  : 	SetBits( *flags, MAP_IS_EXIST );

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax], edx

; 818  : 	memset( buf, 0, MAX_TOKEN );

	push	2048					; 00000800H
	push	0
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 819  : 	FS_Read( f, buf, MAX_TOKEN );

	push	2048					; 00000800H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 820  : 	header = (dheader_t *)buf;

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _header$[ebp], ecx

; 821  : 
; 822  : 	// check all the lumps and some other errors
; 823  : 	if( !Mod_TestBmodelLumps( bspfilename, buf, (host_developer.value) ? false : true ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@SV_ReadEnt
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN8@SV_ReadEnt
$LN7@SV_ReadEnt:
	mov	DWORD PTR tv84[ebp], 1
$LN8@SV_ReadEnt:
	mov	edx, DWORD PTR tv84[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bspfilename$[ebp]
	push	ecx
	call	_Mod_TestBmodelLumps
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SV_ReadEnt

; 824  : 	{
; 825  : 		SetBits( *flags, MAP_INVALID_VERSION );

	mov	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 8
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [ecx], eax

; 826  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 827  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_ReadEnt
$LN3@SV_ReadEnt:

; 828  : 	}
; 829  : 
; 830  : 	// after call Mod_TestBmodelLumps we gurantee what map is valid
; 831  : 	lumpofs = header->lumps[LUMP_ENTITIES].fileofs;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _lumpofs$[ebp], eax

; 832  : 	lumplen = header->lumps[LUMP_ENTITIES].filelen;

	mov	ecx, 8
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _lumplen$[ebp], ecx

; 833  : 
; 834  : 	// check for entfile too
; 835  : 	Q_strncpy( entfilename, va( "maps/%s.ent", filename ), sizeof( entfilename ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG137628
	call	_va
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _entfilename$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 836  : 
; 837  : 	// make sure what entity patch is newer than bsp
; 838  : 	ft1 = FS_FileTime( bspfilename, false );

	push	0
	lea	ecx, DWORD PTR _bspfilename$[ebp]
	push	ecx
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft1$[ebp], eax

; 839  : 	ft2 = FS_FileTime( entfilename, true );

	push	1
	lea	edx, DWORD PTR _entfilename$[ebp]
	push	edx
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft2$[ebp], eax

; 840  : 
; 841  : 	if( ft2 != -1 && ft1 < ft2 )

	cmp	DWORD PTR _ft2$[ebp], -1
	je	SHORT $LN4@SV_ReadEnt
	mov	eax, DWORD PTR _ft1$[ebp]
	cmp	eax, DWORD PTR _ft2$[ebp]
	jae	SHORT $LN4@SV_ReadEnt

; 842  : 	{
; 843  : 		// grab .ent files only from gamedir
; 844  : 		ents = FS_LoadFile( entfilename, NULL, true ); 

	push	1
	push	0
	lea	ecx, DWORD PTR _entfilename$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ents$[ebp], eax
$LN4@SV_ReadEnt:

; 845  : 	}
; 846  : 
; 847  : 	// at least entities should contain "{ "classname" "worldspawn" }\0"
; 848  : 	// for correct spawn the level
; 849  : 	if( !ents && lumplen >= 32 )

	cmp	DWORD PTR _ents$[ebp], 0
	jne	SHORT $LN5@SV_ReadEnt
	cmp	DWORD PTR _lumplen$[ebp], 32		; 00000020H
	jl	SHORT $LN5@SV_ReadEnt

; 850  : 	{
; 851  : 		FS_Seek( f, lumpofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _lumpofs$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 852  : 		ents = Z_Calloc( lumplen + 1 );

	push	852					; 00000354H
	push	OFFSET $SG137631
	push	1
	mov	ecx, DWORD PTR _lumplen$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ents$[ebp], eax

; 853  : 		FS_Read( f, ents, lumplen );

	mov	eax, DWORD PTR _lumplen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ents$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
$LN5@SV_ReadEnt:

; 854  : 	}
; 855  : 	FS_Close( f ); // all done

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 856  : 
; 857  : 	return ents;

	mov	eax, DWORD PTR _ents$[ebp]
$LN1@SV_ReadEnt:

; 858  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ReadEntityScript ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_SV_GetReliableDatagram PROC

; 441  : {

	push	ebp
	mov	ebp, esp

; 442  : 	return &sv.reliable_datagram;

	mov	eax, OFFSET _sv+1195756

; 443  : }

	pop	ebp
	ret	0
_SV_GetReliableDatagram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_current$ = -40						; size = 4
tv80 = -36						; size = 4
tv67 = -32						; size = 4
_numsends$ = -28					; size = 4
_specproxy$ = -24					; size = 4
_mask$ = -20						; size = 4
_numclients$ = -16					; size = 4
_j$ = -12						; size = 4
_reliable$ = -8						; size = 4
_cl$ = -4						; size = 4
_dest$ = 8						; size = 4
_origin$ = 12						; size = 4
_ent$ = 16						; size = 4
_usermessage$ = 20					; size = 4
_filter$ = 24						; size = 4
_SV_Multicast PROC

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 325  : 	byte		*mask = NULL;

	mov	DWORD PTR _mask$[ebp], 0

; 326  : 	int		j, numclients = svs.maxclients;

	mov	eax, DWORD PTR _svs+16
	mov	DWORD PTR _numclients$[ebp], eax

; 327  : 	sv_client_t	*cl, *current = svs.clients;

	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _current$[ebp], ecx

; 328  : 	qboolean		reliable = false;

	mov	DWORD PTR _reliable$[ebp], 0

; 329  : 	qboolean		specproxy = false;

	mov	DWORD PTR _specproxy$[ebp], 0

; 330  : 	int		numsends = 0;

	mov	DWORD PTR _numsends$[ebp], 0

; 331  : 
; 332  : 	// some mods trying to send messages after SV_FinalMessage
; 333  : 	if( !svs.initialized || sv.state == ss_dead )

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN8@SV_Multica
	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN7@SV_Multica
$LN8@SV_Multica:

; 334  : 	{
; 335  : 		MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 336  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN7@SV_Multica:

; 337  : 	}
; 338  : 
; 339  : 	switch( dest )

	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 9
	ja	$LN25@SV_Multica
	mov	eax, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN45@SV_Multica[eax*4]
$LN9@SV_Multica:

; 340  : 	{
; 341  : 	case MSG_INIT:
; 342  : 		if( sv.state == ss_loading )

	cmp	DWORD PTR _sv, 1
	jne	SHORT $LN10@SV_Multica

; 343  : 		{
; 344  : 			// copy to signon buffer
; 345  : 			MSG_WriteBits( &sv.signon, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	push	OFFSET _sv+1212160
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_GetData
	add	esp, 4
	push	eax
	push	OFFSET _sv+1220372
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 346  : 			MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 347  : 			return 1;

	mov	eax, 1
	jmp	$LN1@SV_Multica
$LN10@SV_Multica:

; 348  : 		}
; 349  : 		// intentional fallthrough (in-game MSG_INIT it's a MSG_ALL reliable)
; 350  : 	case MSG_ALL:
; 351  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN12@SV_Multica:

; 352  : 		// intentional fallthrough
; 353  : 	case MSG_BROADCAST:
; 354  : 		// nothing to sort	
; 355  : 		break;

	jmp	$LN2@SV_Multica
$LN13@SV_Multica:

; 356  : 	case MSG_PAS_R:
; 357  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN14@SV_Multica:

; 358  : 		// intentional fallthrough
; 359  : 	case MSG_PAS:
; 360  : 		if( origin == NULL ) return false;

	cmp	DWORD PTR _origin$[ebp], 0
	jne	SHORT $LN15@SV_Multica
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN15@SV_Multica:

; 361  : 		// NOTE: GoldSource not using PHS for singleplayer
; 362  : 		Mod_FatPVS( origin, FATPHS_RADIUS, fatphs, world.fatbytes, false, ( svs.maxclients == 1 ));

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN43@SV_Multica
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN44@SV_Multica
$LN43@SV_Multica:
	mov	DWORD PTR tv80[ebp], 0
$LN44@SV_Multica:
	mov	ecx, DWORD PTR tv80[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _world+2596
	push	edx
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 363  : 		mask = fatphs; // using the FatPVS like a PHS

	mov	DWORD PTR _mask$[ebp], OFFSET _fatphs

; 364  : 		break;

	jmp	$LN2@SV_Multica
$LN16@SV_Multica:

; 365  : 	case MSG_PVS_R:
; 366  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN17@SV_Multica:

; 367  : 		// intentional fallthrough
; 368  : 	case MSG_PVS:
; 369  : 		if( origin == NULL ) return 0;

	cmp	DWORD PTR _origin$[ebp], 0
	jne	SHORT $LN18@SV_Multica
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN18@SV_Multica:

; 370  : 		mask = Mod_GetPVSForPoint( origin );

	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_Mod_GetPVSForPoint
	add	esp, 4
	mov	DWORD PTR _mask$[ebp], eax

; 371  : 		break;

	jmp	$LN2@SV_Multica
$LN19@SV_Multica:

; 372  : 	case MSG_ONE:
; 373  : 		reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
$LN20@SV_Multica:

; 374  : 		// intentional fallthrough
; 375  : 	case MSG_ONE_UNRELIABLE:
; 376  : 		if( !SV_IsValidEdict( ent )) return 0;

	push	376					; 00000178H
	push	OFFSET $SG137431
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@SV_Multica
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN21@SV_Multica:

; 377  : 		j = NUM_FOR_EDICT( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _j$[ebp], eax

; 378  : 		if( j < 1 || j > numclients ) return 0;

	cmp	DWORD PTR _j$[ebp], 1
	jl	SHORT $LN23@SV_Multica
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _numclients$[ebp]
	jle	SHORT $LN22@SV_Multica
$LN23@SV_Multica:
	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN22@SV_Multica:

; 379  : 		current = svs.clients + (j - 1);

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	imul	ecx, eax, 287560
	add	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _current$[ebp], ecx

; 380  : 		numclients = 1; // send to one

	mov	DWORD PTR _numclients$[ebp], 1

; 381  : 		break;

	jmp	SHORT $LN2@SV_Multica
$LN24@SV_Multica:

; 382  : 	case MSG_SPEC:
; 383  : 		specproxy = reliable = true;

	mov	DWORD PTR _reliable$[ebp], 1
	mov	edx, DWORD PTR _reliable$[ebp]
	mov	DWORD PTR _specproxy$[ebp], edx

; 384  : 		break;

	jmp	SHORT $LN2@SV_Multica
$LN25@SV_Multica:

; 385  : 	default:
; 386  : 		Host_Error( "SV_Multicast: bad dest: %i\n", dest );

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	push	OFFSET $SG137436
	call	_Host_Error
	add	esp, 8

; 387  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_Multica
$LN2@SV_Multica:

; 388  : 	}
; 389  : 
; 390  : 	// send the data to all relevent clients (or once only)
; 391  : 	for( j = 0, cl = current; j < numclients; j++, cl++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR _cl$[ebp], ecx
	jmp	SHORT $LN6@SV_Multica
$LN4@SV_Multica:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], eax
$LN6@SV_Multica:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _numclients$[ebp]
	jge	$LN5@SV_Multica

; 392  : 	{
; 393  : 		if( cl->state == cs_free || cl->state == cs_zombie )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN27@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN26@SV_Multica
$LN27@SV_Multica:

; 394  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN26@SV_Multica:

; 395  : 
; 396  : 		if( cl->state != cs_spawned && ( !reliable || usermessage ))

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN28@SV_Multica
	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN29@SV_Multica
	cmp	DWORD PTR _usermessage$[ebp], 0
	je	SHORT $LN28@SV_Multica
$LN29@SV_Multica:

; 397  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN28@SV_Multica:

; 398  : 
; 399  : 		if( specproxy && !FBitSet( cl->flags, FCL_HLTV_PROXY ))

	cmp	DWORD PTR _specproxy$[ebp], 0
	je	SHORT $LN30@SV_Multica
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 256				; 00000100H
	jne	SHORT $LN30@SV_Multica

; 400  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN30@SV_Multica:

; 401  : 
; 402  : 		if( !cl->edict || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+264980], 0
	je	SHORT $LN32@SV_Multica
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN31@SV_Multica
$LN32@SV_Multica:

; 403  : 			continue;

	jmp	SHORT $LN4@SV_Multica
$LN31@SV_Multica:

; 404  : 
; 405  : 		// reject step sounds while predicting is enabled
; 406  : 		// FIXME: make sure what this code doesn't cutoff something important!!!
; 407  : 		if( filter && cl == sv.current_client && FBitSet( sv.current_client->flags, FCL_PREDICT_MOVEMENT ))

	cmp	DWORD PTR _filter$[ebp], 0
	je	SHORT $LN33@SV_Multica
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	ecx, DWORD PTR _sv+40
	jne	SHORT $LN33@SV_Multica
	mov	edx, DWORD PTR _sv+40
	mov	eax, DWORD PTR [edx+40]
	and	eax, 16					; 00000010H
	je	SHORT $LN33@SV_Multica

; 408  : 			continue;

	jmp	$LN4@SV_Multica
$LN33@SV_Multica:

; 409  : 
; 410  : 		if( SV_IsValidEdict( ent ) && ent->v.groupinfo && cl->edict->v.groupinfo )

	push	410					; 0000019aH
	push	OFFSET $SG137446
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN36@SV_Multica
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+704], 0
	je	SHORT $LN36@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	cmp	DWORD PTR [ecx+704], 0
	je	SHORT $LN36@SV_Multica

; 411  : 		{
; 412  : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( cl->edict->v.groupinfo, ent->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN35@SV_Multica
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+704]
	and	edx, DWORD PTR [ecx+704]
	jne	SHORT $LN35@SV_Multica

; 413  : 				continue;

	jmp	$LN4@SV_Multica
$LN35@SV_Multica:

; 414  : 
; 415  : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( cl->edict->v.groupinfo, ent->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN36@SV_Multica
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+704]
	and	eax, DWORD PTR [edx+704]
	je	SHORT $LN36@SV_Multica

; 416  : 				continue;

	jmp	$LN4@SV_Multica
$LN36@SV_Multica:

; 417  : 		}
; 418  : 
; 419  : 		if( !SV_CheckClientVisiblity( cl, mask ))

	mov	ecx, DWORD PTR _mask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_CheckClientVisiblity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN37@SV_Multica

; 420  : 			continue;

	jmp	$LN4@SV_Multica
$LN37@SV_Multica:

; 421  : 
; 422  : 		if( specproxy ) MSG_WriteBits( &sv.spec_datagram, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	cmp	DWORD PTR _specproxy$[ebp], 0
	je	SHORT $LN38@SV_Multica
	push	OFFSET _sv+1212160
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_GetData
	add	esp, 4
	push	eax
	push	OFFSET _sv+1351464
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN41@SV_Multica
$LN38@SV_Multica:

; 423  : 		else if( reliable ) MSG_WriteBits( &cl->netchan.message, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN40@SV_Multica
	push	OFFSET _sv+1212160
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_GetData
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN41@SV_Multica
$LN40@SV_Multica:

; 424  : 		else MSG_WriteBits( &cl->datagram, MSG_GetData( &sv.multicast ), MSG_GetNumBitsWritten( &sv.multicast ));

	push	OFFSET _sv+1212160
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_GetData
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
$LN41@SV_Multica:

; 425  : 		numsends++;

	mov	edx, DWORD PTR _numsends$[ebp]
	add	edx, 1
	mov	DWORD PTR _numsends$[ebp], edx

; 426  : 	}

	jmp	$LN4@SV_Multica
$LN5@SV_Multica:

; 427  : 
; 428  : 	MSG_Clear( &sv.multicast );

	push	OFFSET _sv+1212160
	call	_MSG_Clear
	add	esp, 4

; 429  : 
; 430  : 	return numsends; // just for debug

	mov	eax, DWORD PTR _numsends$[ebp]
$LN1@SV_Multica:

; 431  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN45@SV_Multica:
	DD	$LN12@SV_Multica
	DD	$LN19@SV_Multica
	DD	$LN10@SV_Multica
	DD	$LN9@SV_Multica
	DD	$LN17@SV_Multica
	DD	$LN14@SV_Multica
	DD	$LN16@SV_Multica
	DD	$LN13@SV_Multica
	DD	$LN20@SV_Multica
	DD	$LN24@SV_Multica
_SV_Multicast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv214 = -44						; size = 4
tv232 = -40						; size = 4
tv175 = -36						; size = 4
_clientnum$ = -32					; size = 4
_i$ = -28						; size = 4
_leaf$ = -24						; size = 4
_view$1 = -20						; size = 4
_vieworg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_mask$ = 12						; size = 4
_SV_CheckClientVisiblity PROC

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 272  : 	int	i, clientnum;
; 273  : 	vec3_t	vieworg;
; 274  : 	mleaf_t	*leaf;
; 275  : 
; 276  : 	if( !mask ) return true; // GoldSrc rules

	cmp	DWORD PTR _mask$[ebp], 0
	jne	SHORT $LN5@SV_CheckCl
	mov	eax, 1
	jmp	$LN1@SV_CheckCl
$LN5@SV_CheckCl:

; 277  : 
; 278  : 	clientnum = cl - svs.clients;

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	mov	DWORD PTR _clientnum$[ebp], eax

; 279  : 	VectorCopy( viewPoint[clientnum], vieworg );

	imul	edx, DWORD PTR _clientnum$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _viewPoint[edx+ecx]
	mov	DWORD PTR _vieworg$[ebp+eax], ecx
	imul	edx, DWORD PTR _clientnum$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _viewPoint[edx+eax]
	mov	DWORD PTR _vieworg$[ebp+ecx], edx
	imul	eax, DWORD PTR _clientnum$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _viewPoint[eax+ecx]
	mov	DWORD PTR _vieworg$[ebp+edx], eax

; 280  : 
; 281  : 	// Invasion issues: wrong camera position received in ENGINE_SET_PVS
; 282  : 	if( cl->pViewEntity && !VectorCompare( vieworg, cl->pViewEntity->v.origin ))

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+264984], 0
	je	$LN6@SV_CheckCl
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264984]
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _vieworg$[ebp+eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@SV_CheckCl
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264984]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vieworg$[ebp+edx]
	ucomiss	xmm0, DWORD PTR [ecx+eax+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@SV_CheckCl
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264984]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _vieworg$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR [eax+edx+136]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@SV_CheckCl
$LN7@SV_CheckCl:

; 283  : 		VectorCopy( cl->pViewEntity->v.origin, vieworg );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264984]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax+136]
	mov	DWORD PTR _vieworg$[ebp+edx], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264984]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _vieworg$[ebp+ecx], edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264984]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _vieworg$[ebp+eax], ecx
$LN6@SV_CheckCl:

; 284  : 
; 285  : 	leaf = Mod_PointInLeaf( vieworg, sv.worldmodel->nodes );

	mov	edx, DWORD PTR _sv+1359676
	mov	eax, DWORD PTR [edx+164]
	push	eax
	lea	ecx, DWORD PTR _vieworg$[ebp]
	push	ecx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 286  : 
; 287  : 	if( CHECKVISBIT( mask, leaf->cluster ))

	mov	edx, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jl	SHORT $LN12@SV_CheckCl
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	sar	ecx, 3
	mov	edx, DWORD PTR _mask$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN13@SV_CheckCl
$LN12@SV_CheckCl:
	mov	DWORD PTR tv175[ebp], 0
$LN13@SV_CheckCl:
	cmp	DWORD PTR tv175[ebp], 0
	je	SHORT $LN8@SV_CheckCl

; 288  : 		return true; // visible from player view or camera view

	mov	eax, 1
	jmp	$LN1@SV_CheckCl
$LN8@SV_CheckCl:

; 289  : 
; 290  : 	// now check all the portal cameras
; 291  : 	for( i = 0; i < cl->num_viewents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CheckCl
$LN2@SV_CheckCl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_CheckCl:
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+265500]
	jge	$LN3@SV_CheckCl

; 292  : 	{
; 293  : 		edict_t	*view = cl->viewentity[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+264988]
	mov	DWORD PTR _view$1[ebp], eax

; 294  : 
; 295  : 		if( !SV_IsValidEdict( view ))

	push	295					; 00000127H
	push	OFFSET $SG137384
	mov	ecx, DWORD PTR _view$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_CheckCl

; 296  : 			continue;

	jmp	SHORT $LN2@SV_CheckCl
$LN9@SV_CheckCl:

; 297  : 
; 298  : 		VectorAdd( view->v.origin, view->v.view_ofs, vieworg );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vieworg$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vieworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _view$1[ebp]
	mov	esi, DWORD PTR _view$1[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+500]
	movss	DWORD PTR tv214[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv214[ebp]
	movss	DWORD PTR _vieworg$[ebp+edx], xmm0

; 299  : 		leaf = Mod_PointInLeaf( vieworg, sv.worldmodel->nodes );

	mov	eax, DWORD PTR _sv+1359676
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 300  : 
; 301  : 		if( CHECKVISBIT( mask, leaf->cluster ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN14@SV_CheckCl
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	mov	eax, DWORD PTR _mask$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv232[ebp], ecx
	jmp	SHORT $LN15@SV_CheckCl
$LN14@SV_CheckCl:
	mov	DWORD PTR tv232[ebp], 0
$LN15@SV_CheckCl:
	cmp	DWORD PTR tv232[ebp], 0
	je	SHORT $LN10@SV_CheckCl

; 302  : 			return true; // visible from portal camera view

	mov	eax, 1
	jmp	SHORT $LN1@SV_CheckCl
$LN10@SV_CheckCl:

; 303  : 	}

	jmp	$LN2@SV_CheckCl
$LN3@SV_CheckCl:

; 304  : 
; 305  : 	// not visible from any viewpoint
; 306  : 	return false;

	xor	eax, eax
$LN1@SV_CheckCl:

; 307  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckClientVisiblity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_SV_ConvertTrace PROC

; 245  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 246  : 	if( !src || !dst ) return; 

	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN3@SV_Convert
	cmp	DWORD PTR _dst$[ebp], 0
	jne	SHORT $LN2@SV_Convert
$LN3@SV_Convert:
	jmp	$LN1@SV_Convert
$LN2@SV_Convert:

; 247  : 
; 248  : 	dst->fAllSolid = src->allsolid;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 249  : 	dst->fStartSolid = src->startsolid;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 250  : 	dst->fInOpen = src->inopen;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 251  : 	dst->fInWater = src->inwater;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 252  : 	dst->flFraction = src->fraction;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 253  : 	VectorCopy( src->endpos, dst->vecEndPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [esi+edx+20]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [edx+ecx+20], eax

; 254  : 	dst->flPlaneDist = src->plane.dist;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+32], eax

; 255  : 	VectorCopy( src->plane.normal, dst->vecPlaneNormal );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [esi+edx+32]
	mov	DWORD PTR [eax+ecx+36], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+ecx+36], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+32]
	mov	DWORD PTR [eax+edx+36], ecx

; 256  : 	dst->pHit = src->ent;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx

; 257  : 	dst->iHitgroup = src->hitgroup;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx

; 258  : 
; 259  : 	// g-cont: always reset config flags when trace is finished
; 260  : 	svgame.globals->trace_flags = 0;

	mov	edx, DWORD PTR _svgame+19236
	mov	DWORD PTR [edx+132], 0
$LN1@SV_Convert:

; 261  : }

	pop	esi
	pop	ebp
	ret	0
_SV_ConvertTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_number$ = 8						; size = 4
_SV_GetEntvarsDescirption PROC

; 94   : {

	push	ebp
	mov	ebp, esp

; 95   : 	if( number < 0 && number >= ENTVARS_COUNT )

	cmp	DWORD PTR _number$[ebp], 0
	jge	SHORT $LN2@SV_GetEntv
	cmp	DWORD PTR _number$[ebp], 13		; 0000000dH
	jb	SHORT $LN2@SV_GetEntv

; 96   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_GetEntv
$LN2@SV_GetEntv:

; 97   : 	return &gEntvarsDescription[number];

	mov	eax, DWORD PTR _number$[ebp]
	shl	eax, 4
	add	eax, OFFSET _gEntvarsDescription
$LN1@SV_GetEntv:

; 98   : }

	pop	ebp
	ret	0
_SV_GetEntvarsDescirption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_SV_Localinfo PROC

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  : 	return svs.localinfo;

	mov	eax, OFFSET _svs+572

; 137  : }

	pop	ebp
	ret	0
_SV_Localinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_n$ = 8							; size = 4
_SV_EdictNum PROC

; 39   : {

	push	ebp
	mov	ebp, esp

; 40   : 	if(( n >= 0 ) && ( n < GI->max_edicts ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@SV_EdictNu
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	SHORT $LN2@SV_EdictNu

; 41   : 		return svgame.edicts + n;

	imul	eax, DWORD PTR _n$[ebp], 804
	add	eax, DWORD PTR _svgame+7928
	jmp	SHORT $LN1@SV_EdictNu
$LN2@SV_EdictNu:

; 42   : 	return NULL;	

	xor	eax, eax
$LN1@SV_EdictNu:

; 43   : }

	pop	ebp
	ret	0
_SV_EdictNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_idx$ = -4						; size = 4
_pfnGetCurrentPlayer PROC

; 4066 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4067 : 	int	idx = sv.current_client - svs.clients;

	mov	eax, DWORD PTR _sv+40
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 287560				; 00046348H
	idiv	ecx
	mov	DWORD PTR _idx$[ebp], eax

; 4068 : 
; 4069 : 	if( idx < 0 || idx >= svs.maxclients )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN3@pfnGetCurr
	mov	edx, DWORD PTR _idx$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jl	SHORT $LN2@pfnGetCurr
$LN3@pfnGetCurr:

; 4070 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnGetCurr
$LN2@pfnGetCurr:

; 4071 : 	return idx;

	mov	eax, DWORD PTR _idx$[ebp]
$LN1@pfnGetCurr:

; 4072 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetCurrentPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_RestartStaticEnts PROC

; 551  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 	int	i;
; 553  : 
; 554  : 	// remove all the static entities on the client
; 555  : 	R_ClearStaticEntities();

	call	_R_ClearStaticEntities

; 556  : 
; 557  : 	// resend them again
; 558  : 	for( i = 0; i < sv.num_static_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Restart
$LN2@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Restart:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _sv+332996
	jge	SHORT $LN1@SV_Restart

; 559  : 		SV_CreateStaticEntity( &sv.reliable_datagram, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET _sv+1195756
	call	_SV_CreateStaticEntity
	add	esp, 8
	jmp	SHORT $LN2@SV_Restart
$LN1@SV_Restart:

; 560  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestartStaticEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_msg$ = -20						; size = 4
_decalIndex$ = -16					; size = 4
_modelIndex$ = -12					; size = 4
_i$ = -8						; size = 4
_entry$ = -4						; size = 4
_SV_RestartDecals PROC

; 606  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 607  : 	decallist_t	*entry;
; 608  : 	int		decalIndex;
; 609  : 	int		modelIndex;
; 610  : 	sizebuf_t		*msg;
; 611  : 	int		i;
; 612  : 
; 613  : 	if( !SV_Active( )) return;

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN5@SV_Restart
	jmp	$LN1@SV_Restart
$LN5@SV_Restart:

; 614  : 
; 615  : 	// g-cont. add space for studiodecals if present
; 616  : 	host.decalList = (decallist_t *)Z_Calloc( sizeof( decallist_t ) * MAX_RENDER_DECALS * 2 );

	push	616					; 00000268H
	push	OFFSET $SG137537
	push	1
	push	1048576					; 00100000H
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _host+34760, eax

; 617  : 	host.numdecals = R_CreateDecalList( host.decalList );

	mov	ecx, DWORD PTR _host+34760
	push	ecx
	call	_R_CreateDecalList
	add	esp, 4
	mov	DWORD PTR _host+34764, eax

; 618  : 
; 619  : 	// remove decals from map
; 620  : 	R_ClearAllDecals();

	call	_R_ClearAllDecals

; 621  : 
; 622  : 	// write decals into reliable datagram
; 623  : 	msg = SV_GetReliableDatagram();

	call	_SV_GetReliableDatagram
	mov	DWORD PTR _msg$[ebp], eax

; 624  : 
; 625  : 	// restore decals and write them into network message
; 626  : 	for( i = 0; i < host.numdecals; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Restart
$LN2@SV_Restart:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_Restart:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _host+34764
	jge	$LN3@SV_Restart

; 627  : 	{
; 628  : 		entry = &host.decalList[i];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _host+34760
	mov	DWORD PTR _entry$[ebp], ecx

; 629  : 		modelIndex = pfnPEntityOfEntIndex( entry->entityIndex )->v.modelindex;

	mov	edx, DWORD PTR _entry$[ebp]
	movsx	eax, WORD PTR [edx+76]
	push	eax
	call	_pfnPEntityOfEntIndex
	add	esp, 4
	mov	ecx, DWORD PTR [eax+308]
	mov	DWORD PTR _modelIndex$[ebp], ecx

; 630  : 
; 631  : 		// game override
; 632  : 		if( SV_RestoreCustomDecal( entry, pfnPEntityOfEntIndex( entry->entityIndex ), false ))

	push	0
	mov	edx, DWORD PTR _entry$[ebp]
	movsx	eax, WORD PTR [edx+76]
	push	eax
	call	_pfnPEntityOfEntIndex
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	_SV_RestoreCustomDecal
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@SV_Restart

; 633  : 			continue;

	jmp	SHORT $LN2@SV_Restart
$LN6@SV_Restart:

; 634  : 
; 635  : 		decalIndex = pfnDecalIndex( entry->name );

	mov	edx, DWORD PTR _entry$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	_pfnDecalIndex
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 636  : 
; 637  : 		// studiodecals will be restored at game-side
; 638  : 		if( !FBitSet( entry->flags, FDECAL_STUDIO ))

	mov	eax, DWORD PTR _entry$[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN7@SV_Restart

; 639  : 			SV_CreateDecal( msg, entry->position, decalIndex, entry->entityIndex, modelIndex, entry->flags, entry->scale );

	mov	edx, DWORD PTR _entry$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+80]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _entry$[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH
$LN7@SV_Restart:

; 640  : 	}

	jmp	$LN2@SV_Restart
$LN3@SV_Restart:

; 641  : 
; 642  : 	Z_Free( host.decalList );

	cmp	DWORD PTR _host+34760, 0
	je	SHORT $LN8@SV_Restart
	push	642					; 00000282H
	push	OFFSET $SG137541
	mov	edx, DWORD PTR _host+34760
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@SV_Restart:

; 643  : 	host.decalList = NULL;

	mov	DWORD PTR _host+34760, 0

; 644  : 	host.numdecals = 0;

	mov	DWORD PTR _host+34764, 0
$LN1@SV_Restart:

; 645  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestartDecals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_position$ = -29204					; size = 4
_nSounds$ = -29200					; size = 4
_i$ = -29196						; size = 4
_si$1 = -29192						; size = 4
_soundInfo$ = -29188					; size = 28672
_curtrack$ = -516					; size = 256
_looptrack$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_SV_RestartAmbientSounds PROC

; 570  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 29204				; 00007214H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 571  : 	soundlist_t	soundInfo[256];
; 572  : 	string		curtrack, looptrack;
; 573  : 	int		i, nSounds;
; 574  : 	long		position;
; 575  : 
; 576  : 	if( !SV_Active( )) return;

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN5@SV_Restart
	jmp	$LN8@SV_Restart
$LN5@SV_Restart:

; 577  : 
; 578  : 	nSounds = S_GetCurrentStaticSounds( soundInfo, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _soundInfo$[ebp]
	push	eax
	call	_S_GetCurrentStaticSounds
	add	esp, 8
	mov	DWORD PTR _nSounds$[ebp], eax

; 579  : 	
; 580  : 	for( i = 0; i < nSounds; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Restart
$LN2@SV_Restart:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_Restart:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _nSounds$[ebp]
	jge	$LN3@SV_Restart

; 581  : 	{
; 582  : 		soundlist_t *si = &soundInfo[i];

	imul	eax, DWORD PTR _i$[ebp], 112
	lea	ecx, DWORD PTR _soundInfo$[ebp+eax]
	mov	DWORD PTR _si$1[ebp], ecx

; 583  : 
; 584  : 		if( !si->looping || si->entnum == -1 )

	mov	edx, DWORD PTR _si$1[ebp]
	cmp	DWORD PTR [edx+88], 0
	je	SHORT $LN7@SV_Restart
	mov	eax, DWORD PTR _si$1[ebp]
	movsx	ecx, WORD PTR [eax+64]
	cmp	ecx, -1
	jne	SHORT $LN6@SV_Restart
$LN7@SV_Restart:

; 585  : 			continue;

	jmp	SHORT $LN2@SV_Restart
$LN6@SV_Restart:

; 586  : 
; 587  : 		S_StopSound( si->entnum, si->channel, si->name );

	mov	edx, DWORD PTR _si$1[ebp]
	push	edx
	mov	eax, DWORD PTR _si$1[ebp]
	movzx	ecx, BYTE PTR [eax+92]
	push	ecx
	mov	edx, DWORD PTR _si$1[ebp]
	movsx	eax, WORD PTR [edx+64]
	push	eax
	call	_S_StopSound
	add	esp, 12					; 0000000cH

; 588  : 		SV_StartSound( pfnPEntityOfEntIndex( si->entnum ), CHAN_STATIC, si->name, si->volume, si->attenuation, 0, si->pitch );

	mov	ecx, DWORD PTR _si$1[ebp]
	movzx	edx, BYTE PTR [ecx+93]
	push	edx
	push	0
	mov	eax, DWORD PTR _si$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+84]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _si$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+80]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _si$1[ebp]
	push	edx
	push	6
	mov	eax, DWORD PTR _si$1[ebp]
	movsx	ecx, WORD PTR [eax+64]
	push	ecx
	call	_pfnPEntityOfEntIndex
	add	esp, 4
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 589  : 	}

	jmp	$LN2@SV_Restart
$LN3@SV_Restart:

; 590  : 
; 591  : 	// restart soundtrack
; 592  : 	if( S_StreamGetCurrentState( curtrack, looptrack, &position ))

	lea	edx, DWORD PTR _position$[ebp]
	push	edx
	lea	eax, DWORD PTR _looptrack$[ebp]
	push	eax
	lea	ecx, DWORD PTR _curtrack$[ebp]
	push	ecx
	call	_S_StreamGetCurrentState
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@SV_Restart

; 593  : 	{
; 594  : 		SV_StartMusic( curtrack, looptrack, position );

	mov	edx, DWORD PTR _position$[ebp]
	push	edx
	lea	eax, DWORD PTR _looptrack$[ebp]
	push	eax
	lea	ecx, DWORD PTR _curtrack$[ebp]
	push	ecx
	call	_SV_StartMusic
	add	esp, 12					; 0000000cH
$LN8@SV_Restart:

; 595  : 	}
; 596  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestartAmbientSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv76 = -4						; size = 4
_e$ = 8							; size = 4
_pfnRemoveEntity PROC

; 1835 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1836 : 	if( !SV_IsValidEdict( e ))

	push	1836					; 0000072cH
	push	OFFSET $SG138073
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnRemoveE

; 1837 : 		return;

	jmp	SHORT $LN1@pfnRemoveE
$LN2@pfnRemoveE:

; 1838 : 
; 1839 : 	// never free client or world entity
; 1840 : 	if( NUM_FOR_EDICT( e ) < ( svs.maxclients + 1 ))

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	edx, DWORD PTR _svs+16
	add	edx, 1
	cmp	eax, edx
	jge	SHORT $LN3@pfnRemoveE

; 1841 : 	{
; 1842 : 		Con_Printf( S_ERROR "can't delete %s\n", ( e == EDICT_NUM( 0 )) ? "world" : "client" );

	push	0
	call	_SV_EdictNum
	add	esp, 4
	cmp	DWORD PTR _e$[ebp], eax
	jne	SHORT $LN5@pfnRemoveE
	mov	DWORD PTR tv76[ebp], OFFSET $SG138075
	jmp	SHORT $LN6@pfnRemoveE
$LN5@pfnRemoveE:
	mov	DWORD PTR tv76[ebp], OFFSET $SG138076
$LN6@pfnRemoveE:
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	push	OFFSET $SG138077
	call	_Con_Printf
	add	esp, 8

; 1843 : 		return;

	jmp	SHORT $LN1@pfnRemoveE
$LN3@pfnRemoveE:

; 1844 : 	}
; 1845 : 
; 1846 : 	SV_FreeEdict( e );

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_FreeEdict
	add	esp, 4
$LN1@pfnRemoveE:

; 1847 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRemoveEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_pfnModelIndex PROC

; 1346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1347 : 	char	name[MAX_QPATH];
; 1348 : 	int	i;
; 1349 : 
; 1350 : 	if( !COM_CheckString( m ))

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@pfnModelIn

; 1351 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnModelIn
$LN5@pfnModelIn:

; 1352 : 
; 1353 : 	if( *m == '\\' || *m == '/' ) m++;

	mov	ecx, DWORD PTR _m$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN7@pfnModelIn
	mov	eax, DWORD PTR _m$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@pfnModelIn
$LN7@pfnModelIn:
	mov	edx, DWORD PTR _m$[ebp]
	add	edx, 1
	mov	DWORD PTR _m$[ebp], edx
$LN6@pfnModelIn:

; 1354 : 	Q_strncpy( name, m, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1355 : 	COM_FixSlashes( name );

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_COM_FixSlashes
	add	esp, 4

; 1356 : 
; 1357 : 	for( i = 1; i < MAX_MODELS && sv.model_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnModelIn
$LN2@pfnModelIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnModelIn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@pfnModelIn
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _sv[ecx+eax+196]
	test	ecx, ecx
	je	SHORT $LN3@pfnModelIn

; 1358 : 	{
; 1359 : 		if( !Q_stricmp( sv.model_precache[i], name ))

	push	99999					; 0001869fH
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+196
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnModelIn

; 1360 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@pfnModelIn
$LN8@pfnModelIn:

; 1361 : 	}

	jmp	SHORT $LN2@pfnModelIn
$LN3@pfnModelIn:

; 1362 : 
; 1363 : 	Con_Printf( S_ERROR "no precache: %s\n", name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG137827
	call	_Con_Printf
	add	esp, 8

; 1364 : 	return 0; 

	xor	eax, eax
$LN1@pfnModelIn:

; 1365 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnModelIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_optional$ = -8						; size = 4
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_pfnPrecacheModel PROC

; 1253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1254 : 	qboolean	optional = false;

	mov	DWORD PTR _optional$[ebp], 0

; 1255 : 	int	i;
; 1256 : 
; 1257 : 	if( *s == '!' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN2@pfnPrecach

; 1258 : 	{
; 1259 : 		optional = true;

	mov	DWORD PTR _optional$[ebp], 1

; 1260 : 		*s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN2@pfnPrecach:

; 1261 : 	}
; 1262 : 
; 1263 : 	if(( i = SV_ModelIndex( s )) == 0 )

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_SV_ModelIndex
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@pfnPrecach

; 1264 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnPrecach
$LN3@pfnPrecach:

; 1265 : 
; 1266 : 	sv.models[i] = Mod_ForName( sv.model_precache[i], false, true );

	push	1
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+196
	push	ecx
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sv[edx*4+328900], eax

; 1267 : 
; 1268 : 	if( !optional )

	cmp	DWORD PTR _optional$[ebp], 0
	jne	SHORT $LN4@pfnPrecach

; 1269 : 		SetBits( sv.model_precache_flags[i], RES_FATALIFMISSING );

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _sv[eax+327876]
	or	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _sv[edx+327876], cl
$LN4@pfnPrecach:

; 1270 : 
; 1271 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@pfnPrecach:

; 1272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPrecacheModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv173 = -40						; size = 4
tv152 = -36						; size = 4
_fullvis$ = -32						; size = 4
_offset$1 = -28						; size = 12
_viewPos$2 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_pfnSetFatPAS PROC

; 3951 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 3952 : 	qboolean	fullvis = false;

	mov	DWORD PTR _fullvis$[ebp], 0

; 3953 : 
; 3954 : 	if( !sv.worldmodel->visdata || sv_novis->value || !org || CL_DisableVisibility( ))

	mov	eax, DWORD PTR _sv+1359676
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN3@pfnSetFatP
	mov	ecx, DWORD PTR _sv_novis
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@pfnSetFatP
	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN3@pfnSetFatP
	call	_CL_DisableVisibility
	test	eax, eax
	je	SHORT $LN2@pfnSetFatP
$LN3@pfnSetFatP:

; 3955 : 		fullvis = true;

	mov	DWORD PTR _fullvis$[ebp], 1
$LN2@pfnSetFatP:

; 3956 : 
; 3957 : 	ASSERT( pfnGetCurrentPlayer() != -1 );

	call	_pfnGetCurrentPlayer
	cmp	eax, -1
	jne	SHORT $LN4@pfnSetFatP
	push	3957					; 00000f75H
	push	OFFSET $SG139220
	push	OFFSET $SG139221
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@pfnSetFatP:

; 3958 : 
; 3959 : 	// portals can't change viewpoint!
; 3960 : 	if( !FBitSet( sv.hostflags, SVF_MERGE_VISIBILITY ))

	mov	edx, DWORD PTR _sv+44
	and	edx, 2
	jne	$LN5@pfnSetFatP

; 3961 : 	{
; 3962 : 		vec3_t	viewPos, offset;
; 3963 : 
; 3964 : 		// see code from client.cpp for understanding:
; 3965 : 		// org = pView->v.origin + pView->v.view_ofs;
; 3966 : 		// if ( pView->v.flags & FL_DUCKING )
; 3967 : 		// {
; 3968 : 		//	org = org + ( VEC_HULL_MIN - VEC_DUCK_HULL_MIN );
; 3969 : 		// }
; 3970 : 		// so we have unneeded duck calculations who have affect when player
; 3971 : 		// is ducked into water. Remove offset to restore right PVS position
; 3972 : 		if( FBitSet( sv.current_client->edict->v.flags, FL_DUCKING ))

	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 16384				; 00004000H
	je	$LN7@pfnSetFatP

; 3973 : 		{
; 3974 : 			VectorSubtract( svgame.pmove->player_mins[0], svgame.pmove->player_mins[1], offset );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8224
	lea	eax, DWORD PTR [edx+ecx+324852]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [esi+ecx+324852]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _offset$1[ebp+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	esi, DWORD PTR _svgame+8224
	lea	eax, DWORD PTR [esi+eax+324852]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _offset$1[ebp+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8224
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [esi+ecx+324852]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [ecx+esi]
	movss	DWORD PTR tv152[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv152[ebp]
	movss	DWORD PTR _offset$1[ebp+edx], xmm0

; 3975 : 			VectorSubtract( org, offset, viewPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _viewPos$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _viewPos$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$1[ebp+ecx]
	movss	DWORD PTR tv173[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR _viewPos$2[ebp+eax], xmm0

; 3976 : 		}

	jmp	SHORT $LN8@pfnSetFatP
$LN7@pfnSetFatP:

; 3977 : 		else VectorCopy( org, viewPos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _viewPos$2[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _viewPos$2[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _viewPos$2[ebp+edx], ecx
$LN8@pfnSetFatP:

; 3978 : 
; 3979 : 		// build a new PHS frame
; 3980 : 		Mod_FatPVS( viewPos, FATPHS_RADIUS, fatphs, world.fatbytes, false, fullvis );

	mov	edx, DWORD PTR _fullvis$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _world+2596
	push	eax
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _viewPos$2[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 3981 : 	}

	jmp	SHORT $LN6@pfnSetFatP
$LN5@pfnSetFatP:

; 3982 : 	else
; 3983 : 	{
; 3984 : 		// merge PHS
; 3985 : 		Mod_FatPVS( org, FATPHS_RADIUS, fatphs, world.fatbytes, true, fullvis );

	mov	edx, DWORD PTR _fullvis$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _world+2596
	push	eax
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN6@pfnSetFatP:

; 3986 : 	}
; 3987 : 
; 3988 : 	return fatphs;

	mov	eax, OFFSET _fatphs

; 3989 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetFatPAS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv213 = -44						; size = 4
tv173 = -40						; size = 4
tv152 = -36						; size = 4
_fullvis$ = -32						; size = 4
_offset$1 = -28						; size = 12
_viewPos$2 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_pfnSetFatPVS PROC

; 3901 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 3902 : 	qboolean	fullvis = false;

	mov	DWORD PTR _fullvis$[ebp], 0

; 3903 : 
; 3904 : 	if( !sv.worldmodel->visdata || sv_novis->value || !org || CL_DisableVisibility( ))

	mov	eax, DWORD PTR _sv+1359676
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN3@pfnSetFatP
	mov	ecx, DWORD PTR _sv_novis
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@pfnSetFatP
	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN3@pfnSetFatP
	call	_CL_DisableVisibility
	test	eax, eax
	je	SHORT $LN2@pfnSetFatP
$LN3@pfnSetFatP:

; 3905 : 		fullvis = true;

	mov	DWORD PTR _fullvis$[ebp], 1
$LN2@pfnSetFatP:

; 3906 : 
; 3907 : 	ASSERT( pfnGetCurrentPlayer() != -1 );

	call	_pfnGetCurrentPlayer
	cmp	eax, -1
	jne	SHORT $LN4@pfnSetFatP
	push	3907					; 00000f43H
	push	OFFSET $SG139205
	push	OFFSET $SG139206
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@pfnSetFatP:

; 3908 : 
; 3909 : 	// portals can't change viewpoint!
; 3910 : 	if( !FBitSet( sv.hostflags, SVF_MERGE_VISIBILITY ))

	mov	edx, DWORD PTR _sv+44
	and	edx, 2
	jne	$LN5@pfnSetFatP

; 3911 : 	{
; 3912 : 		vec3_t	viewPos, offset;
; 3913 : 
; 3914 : 		// see code from client.cpp for understanding:
; 3915 : 		// org = pView->v.origin + pView->v.view_ofs;
; 3916 : 		// if ( pView->v.flags & FL_DUCKING )
; 3917 : 		// {
; 3918 : 		//	org = org + ( VEC_HULL_MIN - VEC_DUCK_HULL_MIN );
; 3919 : 		// }
; 3920 : 		// so we have unneeded duck calculations who have affect when player
; 3921 : 		// is ducked into water. Remove offset to restore right PVS position
; 3922 : 		if( FBitSet( sv.current_client->edict->v.flags, FL_DUCKING ))

	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 16384				; 00004000H
	je	$LN7@pfnSetFatP

; 3923 : 		{
; 3924 : 			VectorSubtract( svgame.pmove->player_mins[0], svgame.pmove->player_mins[1], offset );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8224
	lea	eax, DWORD PTR [edx+ecx+324852]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [esi+ecx+324852]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _offset$1[ebp+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	esi, DWORD PTR _svgame+8224
	lea	eax, DWORD PTR [esi+eax+324852]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _offset$1[ebp+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8224
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	esi, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [esi+ecx+324852]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [ecx+esi]
	movss	DWORD PTR tv152[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv152[ebp]
	movss	DWORD PTR _offset$1[ebp+edx], xmm0

; 3925 : 			VectorSubtract( org, offset, viewPos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _viewPos$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$1[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _viewPos$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$1[ebp+ecx]
	movss	DWORD PTR tv173[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR _viewPos$2[ebp+eax], xmm0

; 3926 : 		}

	jmp	SHORT $LN8@pfnSetFatP
$LN7@pfnSetFatP:

; 3927 : 		else VectorCopy( org, viewPos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _viewPos$2[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _viewPos$2[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _viewPos$2[ebp+edx], ecx
$LN8@pfnSetFatP:

; 3928 : 
; 3929 : 		// build a new PVS frame
; 3930 : 		Mod_FatPVS( viewPos, FATPVS_RADIUS, fatpvs, world.fatbytes, false, fullvis );

	mov	edx, DWORD PTR _fullvis$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _world+2596
	push	eax
	push	OFFSET _fatpvs
	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _viewPos$2[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 3931 : 		VectorCopy( viewPos, viewPoint[pfnGetCurrentPlayer()] );

	mov	edx, 4
	imul	esi, edx, 0
	call	_pfnGetCurrentPlayer
	imul	eax, eax, 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _viewPos$2[ebp+esi]
	mov	DWORD PTR _viewPoint[eax+edx], ecx
	mov	esi, 4
	shl	esi, 0
	call	_pfnGetCurrentPlayer
	imul	edx, eax, 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _viewPos$2[ebp+esi]
	mov	DWORD PTR _viewPoint[edx+eax], ecx
	call	_pfnGetCurrentPlayer
	imul	edx, eax, 12
	mov	eax, 4
	shl	eax, 1
	lea	ecx, DWORD PTR _viewPoint[edx+eax]
	mov	DWORD PTR tv213[ebp], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR tv213[ebp]
	mov	ecx, DWORD PTR _viewPos$2[ebp+edx]
	mov	DWORD PTR [eax], ecx

; 3932 : 	}

	jmp	SHORT $LN6@pfnSetFatP
$LN5@pfnSetFatP:

; 3933 : 	else
; 3934 : 	{
; 3935 : 		// merge PVS
; 3936 : 		Mod_FatPVS( org, FATPVS_RADIUS, fatpvs, world.fatbytes, true, fullvis );

	mov	edx, DWORD PTR _fullvis$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _world+2596
	push	eax
	push	OFFSET _fatpvs
	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN6@pfnSetFatP:

; 3937 : 	}
; 3938 : 
; 3939 : 	return fatpvs;

	mov	eax, OFFSET _fatpvs

; 3940 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetFatPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
_count$ = 12						; size = 4
_pfnWriteBytes PROC

; 2772 : {

	push	ebp
	mov	ebp, esp

; 2773 : 	MSG_WriteBytes( &sv.multicast, bytes, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	push	OFFSET _sv+1212160
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 2774 : 	svgame.msg_realsize += count;

	mov	edx, DWORD PTR _svgame+7888
	add	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _svgame+7888, edx

; 2775 : }

	pop	ebp
	ret	0
_pfnWriteBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_number$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_pfnIndexOfEdict PROC

; 3072 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3073 : 	int	number;
; 3074 : 
; 3075 : 	if( !pEdict ) return 0; // world ?

	cmp	DWORD PTR _pEdict$[ebp], 0
	jne	SHORT $LN2@pfnIndexOf
	xor	eax, eax
	jmp	SHORT $LN1@pfnIndexOf
$LN2@pfnIndexOf:

; 3076 : 
; 3077 : 	number = NUM_FOR_EDICT( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _number$[ebp], eax

; 3078 : 	if( number < 0 || number > GI->max_edicts )

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN4@pfnIndexOf
	mov	edx, DWORD PTR _SI+768
	mov	eax, DWORD PTR _number$[ebp]
	cmp	eax, DWORD PTR [edx+1656]
	jle	SHORT $LN3@pfnIndexOf
$LN4@pfnIndexOf:

; 3079 : 		Host_Error( "bad entity number %d\n", number );

	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	push	OFFSET $SG138768
	call	_Host_Error
	add	esp, 8
$LN3@pfnIndexOf:

; 3080 : 	return number;

	mov	eax, DWORD PTR _number$[ebp]
$LN1@pfnIndexOf:

; 3081 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIndexOfEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_user$ = 12						; size = 4
_SV_SendUserReg PROC

; 3161 : {

	push	ebp
	mov	ebp, esp

; 3162 : 	MSG_BeginServerCmd( msg, svc_usermessage );

	push	0
	push	1
	push	39					; 00000027H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3163 : 	MSG_WriteByte( msg, user->number );

	mov	ecx, DWORD PTR _user$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 3164 : 	MSG_WriteWord( msg, (word)user->size );

	mov	ecx, DWORD PTR _user$[ebp]
	movzx	edx, WORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteWord
	add	esp, 8

; 3165 : 	MSG_WriteString( msg, user->name );

	mov	ecx, DWORD PTR _user$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 3166 : }

	pop	ebp
	ret	0
_SV_SendUserReg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_offset$ = -356						; size = 4
_baseline$ = -352					; size = 4
_state$ = -348						; size = 4
_nullstate$ = -344					; size = 340
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_index$ = 12						; size = 4
_SV_CreateStaticEntity PROC

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 502  : 	entity_state_t	nullstate, *baseline;	
; 503  : 	entity_state_t	*state;
; 504  : 	int		offset;
; 505  : 
; 506  : 	if( index >= ( MAX_STATIC_ENTITIES - 1 ))

	cmp	DWORD PTR _index$[ebp], 3095		; 00000c17H
	jl	SHORT $LN2@SV_CreateS

; 507  : 	{
; 508  : 		if( !sv.static_ents_overflow )

	cmp	DWORD PTR _sv+1359700, 0
	jne	SHORT $LN3@SV_CreateS

; 509  : 		{
; 510  : 			Con_Printf( S_WARN "MAX_STATIC_ENTITIES limit exceeded (%d)\n", MAX_STATIC_ENTITIES );

	push	3096					; 00000c18H
	push	OFFSET $SG137498
	call	_Con_Printf
	add	esp, 8

; 511  : 			sv.static_ents_overflow = true;

	mov	DWORD PTR _sv+1359700, 1
$LN3@SV_CreateS:

; 512  : 		}
; 513  : 
; 514  : 		sv.ignored_static_ents++; // continue overflowed entities

	mov	eax, DWORD PTR _sv+1359692
	add	eax, 1
	mov	DWORD PTR _sv+1359692, eax

; 515  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CreateS
$LN2@SV_CreateS:

; 516  : 	}
; 517  : 
; 518  : 	// this can happens if serialized map contain too many static entities...
; 519  : 	if( MSG_GetNumBytesLeft( msg ) < 50 )

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN4@SV_CreateS

; 520  : 	{
; 521  : 		sv.ignored_static_ents++;

	mov	edx, DWORD PTR _sv+1359692
	add	edx, 1
	mov	DWORD PTR _sv+1359692, edx

; 522  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CreateS
$LN4@SV_CreateS:

; 523  : 	}
; 524  : 
; 525  : 	state = &svs.static_entities[index]; // allocate a new one

	imul	eax, DWORD PTR _index$[ebp], 340
	add	eax, DWORD PTR _svs+33364
	mov	DWORD PTR _state$[ebp], eax

; 526  : 	memset( &nullstate, 0, sizeof( nullstate ));

	push	340					; 00000154H
	push	0
	lea	ecx, DWORD PTR _nullstate$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 527  : 	baseline = &nullstate;

	lea	edx, DWORD PTR _nullstate$[ebp]
	mov	DWORD PTR _baseline$[ebp], edx

; 528  : 
; 529  : 	// restore modelindex from modelname (already precached)
; 530  : 	state->modelindex = pfnModelIndex( STRING( state->messagenum ));

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	call	_pfnModelIndex
	add	esp, 4
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+40], eax

; 531  : 	state->entityType = ENTITY_NORMAL; // select delta-encode

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax], 1

; 532  : 	state->number = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 533  : 
; 534  : 	// trying to compress with previous delta's
; 535  : 	offset = SV_FindBestBaselineForStatic( index, &baseline, state );

	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	lea	eax, DWORD PTR _baseline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	call	_SV_FindBestBaselineForStatic
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _offset$[ebp], eax

; 536  : 
; 537  : 	MSG_BeginServerCmd( msg, svc_spawnstatic );

	push	0
	push	1
	push	20					; 00000014H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 538  : 	MSG_WriteDeltaEntity( baseline, state, msg, true, DELTA_STATIC, sv.time, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _baseline$[ebp]
	push	eax
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 539  : 
; 540  : 	return true;

	mov	eax, 1
$LN1@SV_CreateS:

; 541  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateStaticEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pent$ = -4						; size = 4
_classname$ = 8						; size = 4
_globalname$ = 12					; size = 4
_SV_FindGlobalEntity PROC

; 1573 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1574 : 	edict_t *pent = SV_FindEntityByString( NULL,  "globalname", STRING( globalname ));

	mov	eax, DWORD PTR _globalname$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET $SG137947
	push	0
	call	_SV_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pent$[ebp], eax

; 1575 : 
; 1576 : 	if( SV_IsValidEdict( pent ))

	push	1576					; 00000628H
	push	OFFSET $SG137949
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@SV_FindGlo

; 1577 : 	{
; 1578 : 		// don't spam about error - game code already tell us
; 1579 : 		if( Q_strcmp( SV_ClassName( pent ), STRING( classname )))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _classname$[ebp]
	push	edx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_SV_ClassName
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@SV_FindGlo

; 1580 : 			pent = NULL;

	mov	DWORD PTR _pent$[ebp], 0
$LN2@SV_FindGlo:

; 1581 : 	}
; 1582 : 
; 1583 : 	return pent;

	mov	eax, DWORD PTR _pent$[ebp]

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindGlobalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv71 = -2328						; size = 4
_need_landmark$1 = -2324				; size = 4
_ents$ = -2320						; size = 4
_pfile$ = -2316						; size = 4
_flags$ = -2312						; size = 4
_token$2 = -2308					; size = 2048
_check_name$3 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_spawn_entity$ = 12					; size = 4
_landmark_name$ = 16					; size = 4
_SV_MapIsValid PROC

; 868  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2328				; 00000918H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 869  : 	int	flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 870  : 	char	*pfile;
; 871  : 	char	*ents;
; 872  : 
; 873  : 	ents = SV_ReadEntityScript( filename, &flags );

	lea	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_SV_ReadEntityScript
	add	esp, 8
	mov	DWORD PTR _ents$[ebp], eax

; 874  : 
; 875  : 	if( ents )

	cmp	DWORD PTR _ents$[ebp], 0
	je	$LN4@SV_MapIsVa

; 876  : 	{
; 877  : 		qboolean	need_landmark = Q_strlen( landmark_name ) > 0 ? true : false;

	mov	edx, DWORD PTR _landmark_name$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN14@SV_MapIsVa
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN15@SV_MapIsVa
$LN14@SV_MapIsVa:
	mov	DWORD PTR tv71[ebp], 0
$LN15@SV_MapIsVa:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _need_landmark$1[ebp], eax

; 878  : 		char	token[MAX_TOKEN];
; 879  : 		string	check_name;
; 880  : 
; 881  : 		// g-cont. in-dev mode we can entering on map even without "info_player_start"
; 882  : 		if( !need_landmark && host_developer.value )

	cmp	DWORD PTR _need_landmark$1[ebp], 0
	jne	SHORT $LN5@SV_MapIsVa
	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@SV_MapIsVa

; 883  : 		{
; 884  : 			// not transition 
; 885  : 			Mem_Free( ents );

	push	885					; 00000375H
	push	OFFSET $SG137650
	mov	ecx, DWORD PTR _ents$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 886  : 
; 887  : 			// skip spawnpoint checks in devmode
; 888  : 			return (flags|MAP_HAS_SPAWNPOINT);

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	jmp	$LN1@SV_MapIsVa
$LN5@SV_MapIsVa:

; 889  : 		}
; 890  : 
; 891  : 		pfile = ents;

	mov	edx, DWORD PTR _ents$[ebp]
	mov	DWORD PTR _pfile$[ebp], edx
$LN2@SV_MapIsVa:

; 892  : 
; 893  : 		while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	eax, DWORD PTR _token$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@SV_MapIsVa

; 894  : 		{
; 895  : 			if( !Q_strcmp( token, "classname" ))

	push	99999					; 0001869fH
	push	OFFSET $SG137653
	lea	edx, DWORD PTR _token$2[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_MapIsVa

; 896  : 			{
; 897  : 				// check classname for spawn entity
; 898  : 				pfile = COM_ParseFile( pfile, check_name );

	lea	eax, DWORD PTR _check_name$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 899  : 				if( !Q_strcmp( spawn_entity, check_name ))

	push	99999					; 0001869fH
	lea	edx, DWORD PTR _check_name$3[ebp]
	push	edx
	mov	eax, DWORD PTR _spawn_entity$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_MapIsVa

; 900  : 				{
; 901  : 					SetBits( flags, MAP_HAS_SPAWNPOINT );

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 2
	mov	DWORD PTR _flags$[ebp], ecx

; 902  : 
; 903  : 					// we already find landmark, stop the parsing
; 904  : 					if( need_landmark && FBitSet( flags, MAP_HAS_LANDMARK ))

	cmp	DWORD PTR _need_landmark$1[ebp], 0
	je	SHORT $LN9@SV_MapIsVa
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	je	SHORT $LN9@SV_MapIsVa

; 905  : 						break;

	jmp	$LN3@SV_MapIsVa
$LN9@SV_MapIsVa:

; 906  : 				}
; 907  : 			}

	jmp	SHORT $LN12@SV_MapIsVa
$LN6@SV_MapIsVa:

; 908  : 			else if( need_landmark && !Q_strcmp( token, "targetname" ))

	cmp	DWORD PTR _need_landmark$1[ebp], 0
	je	SHORT $LN12@SV_MapIsVa
	push	99999					; 0001869fH
	push	OFFSET $SG137657
	lea	eax, DWORD PTR _token$2[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_MapIsVa

; 909  : 			{
; 910  : 				// check targetname for landmark entity
; 911  : 				pfile = COM_ParseFile( pfile, check_name );

	lea	ecx, DWORD PTR _check_name$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 912  : 
; 913  : 				if( !Q_strcmp( landmark_name, check_name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _check_name$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _landmark_name$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_MapIsVa

; 914  : 				{
; 915  : 					SetBits( flags, MAP_HAS_LANDMARK );

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 4
	mov	DWORD PTR _flags$[ebp], edx

; 916  : 
; 917  : 					// we already find spawnpoint, stop the parsing
; 918  : 					if( FBitSet( flags, MAP_HAS_SPAWNPOINT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN12@SV_MapIsVa

; 919  : 						break;

	jmp	SHORT $LN3@SV_MapIsVa
$LN12@SV_MapIsVa:

; 920  : 				}
; 921  : 			}
; 922  : 		}

	jmp	$LN2@SV_MapIsVa
$LN3@SV_MapIsVa:

; 923  : 
; 924  : 		Mem_Free( ents );

	push	924					; 0000039cH
	push	OFFSET $SG137660
	mov	ecx, DWORD PTR _ents$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_MapIsVa:

; 925  : 	}
; 926  : 
; 927  : 	return flags;

	mov	eax, DWORD PTR _flags$[ebp]
$LN1@SV_MapIsVa:

; 928  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MapIsValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pEdict$ = 8						; size = 4
_spawned_only$ = 12					; size = 4
_SV_ClientFromEdict PROC

; 1219 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1220 : 	int	i;
; 1221 : 
; 1222 : 	if( !SV_IsValidEdict( pEdict ))

	push	1222					; 000004c6H
	push	OFFSET $SG137773
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_ClientF

; 1223 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ClientF
$LN2@SV_ClientF:

; 1224 : 
; 1225 : 	i = NUM_FOR_EDICT( pEdict ) - 1;

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1226 : 
; 1227 : 	if( i < 0 || i >= svs.maxclients )

	js	SHORT $LN4@SV_ClientF
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jl	SHORT $LN3@SV_ClientF
$LN4@SV_ClientF:

; 1228 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ClientF
$LN3@SV_ClientF:

; 1229 : 
; 1230 : 	if( spawned_only )

	cmp	DWORD PTR _spawned_only$[ebp], 0
	je	SHORT $LN5@SV_ClientF

; 1231 : 	{
; 1232 : 		if( svs.clients[i].state != cs_spawned )

	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 3
	je	SHORT $LN5@SV_ClientF

; 1233 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ClientF
$LN5@SV_ClientF:

; 1234 : 	}
; 1235 : 
; 1236 : 	return (svs.clients + i);

	imul	eax, DWORD PTR _i$[ebp], 287560
	add	eax, DWORD PTR _svs+33344
$LN1@SV_ClientF:

; 1237 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClientFromEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_iString$ = 8						; size = 4
_SV_GetString PROC

; 3024 : {

	push	ebp
	mov	ebp, esp

; 3025 : 	if( svgame.physFuncs.pfnGetString != NULL )

	cmp	DWORD PTR _svgame+19532, 0
	je	SHORT $LN2@SV_GetStri

; 3026 : 		return svgame.physFuncs.pfnGetString( iString );

	mov	eax, DWORD PTR _iString$[ebp]
	push	eax
	call	DWORD PTR _svgame+19532
	add	esp, 4
	jmp	SHORT $LN1@SV_GetStri
$LN2@SV_GetStri:

; 3027 : 	return (svgame.globals->pStringBase + iString);

	mov	ecx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR [ecx+152]
	add	eax, DWORD PTR _iString$[ebp]
$LN1@SV_GetStri:

; 3028 : }

	pop	ebp
	ret	0
_SV_GetString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_szValue$ = 8						; size = 4
_SV_MakeString PROC

; 3010 : {

	push	ebp
	mov	ebp, esp

; 3011 : 	if( svgame.physFuncs.pfnMakeString != NULL )

	cmp	DWORD PTR _svgame+19528, 0
	je	SHORT $LN2@SV_MakeStr

; 3012 : 		return svgame.physFuncs.pfnMakeString( szValue );

	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	call	DWORD PTR _svgame+19528
	add	esp, 4
	jmp	SHORT $LN1@SV_MakeStr
$LN2@SV_MakeStr:

; 3013 : 	return szValue - svgame.globals->pStringBase;

	mov	ecx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _szValue$[ebp]
	sub	eax, DWORD PTR [ecx+152]
$LN1@SV_MakeStr:

; 3014 : }		

	pop	ebp
	ret	0
_SV_MakeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_out$ = -16						; size = 4
_l$ = -12						; size = 4
_i$ = -8						; size = 4
_out_p$ = -4						; size = 4
_szString$ = 8						; size = 4
_SV_AllocString PROC

; 2974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2975 : 	char	*out, *out_p;
; 2976 : 	int	i, l;
; 2977 : 
; 2978 : 	if( svgame.physFuncs.pfnAllocString != NULL )

	cmp	DWORD PTR _svgame+19524, 0
	je	SHORT $LN5@SV_AllocSt

; 2979 : 		return svgame.physFuncs.pfnAllocString( szString );

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	call	DWORD PTR _svgame+19524
	add	esp, 4
	jmp	$LN1@SV_AllocSt
$LN5@SV_AllocSt:

; 2980 : 
; 2981 : 	if( !COM_CheckString( szString ))

	mov	ecx, DWORD PTR _szString$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_AllocSt

; 2982 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_AllocSt
$LN6@SV_AllocSt:

; 2983 : 
; 2984 : 	l = Q_strlen( szString ) + 1;

	mov	edx, DWORD PTR _szString$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 2985 : 
; 2986 : 	out = out_p = Mem_Calloc( svgame.stringspool, l );

	push	2986					; 00000baaH
	push	OFFSET $SG138726
	push	1
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+19560
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out_p$[ebp], eax
	mov	edx, DWORD PTR _out_p$[ebp]
	mov	DWORD PTR _out$[ebp], edx

; 2987 : 	for( i = 0; i < l; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_AllocSt
$LN2@SV_AllocSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_AllocSt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	jge	SHORT $LN3@SV_AllocSt

; 2988 : 	{
; 2989 : 		if( szString[i] == '\\' && i < l - 1 )

	mov	edx, DWORD PTR _szString$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN7@SV_AllocSt
	mov	ecx, DWORD PTR _l$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN7@SV_AllocSt

; 2990 : 		{
; 2991 : 			i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 2992 : 			if( szString[i] == 'n')

	mov	eax, DWORD PTR _szString$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 110				; 0000006eH
	jne	SHORT $LN9@SV_AllocSt

; 2993 : 				*out_p++ = '\n';

	mov	edx, DWORD PTR _out_p$[ebp]
	mov	BYTE PTR [edx], 10			; 0000000aH
	mov	eax, DWORD PTR _out_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _out_p$[ebp], eax
	jmp	SHORT $LN10@SV_AllocSt
$LN9@SV_AllocSt:

; 2994 : 			else *out_p++ = '\\';

	mov	ecx, DWORD PTR _out_p$[ebp]
	mov	BYTE PTR [ecx], 92			; 0000005cH
	mov	edx, DWORD PTR _out_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _out_p$[ebp], edx
$LN10@SV_AllocSt:

; 2995 : 		}

	jmp	SHORT $LN8@SV_AllocSt
$LN7@SV_AllocSt:

; 2996 : 		else *out_p++ = szString[i];

	mov	eax, DWORD PTR _szString$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out_p$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _out_p$[ebp], eax
$LN8@SV_AllocSt:

; 2997 : 	}

	jmp	SHORT $LN2@SV_AllocSt
$LN3@SV_AllocSt:

; 2998 : 
; 2999 : 	return out - svgame.globals->pStringBase;

	mov	ecx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR [ecx+152]
$LN1@SV_AllocSt:

; 3000 : }		

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllocString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ed$ = -4						; size = 4
_ent$ = 8						; size = 4
_className$ = 12					; size = 4
_SV_CreateNamedEntity PROC

; 1121 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1122 : 	edict_t *ed = SV_AllocPrivateData( ent, className );

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_AllocPrivateData
	add	esp, 8
	mov	DWORD PTR _ed$[ebp], eax

; 1123 : 	
; 1124 : 	// for some reasons this flag should be immediately cleared
; 1125 : 	if( ed ) ClearBits( ed->v.flags, FL_CUSTOMENTITY );

	cmp	DWORD PTR _ed$[ebp], 0
	je	SHORT $LN2@SV_CreateN
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, -536870913				; dfffffffH
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	DWORD PTR [ecx+548], eax
$LN2@SV_CreateN:

; 1126 : 
; 1127 : 	return ed;

	mov	eax, DWORD PTR _ed$[ebp]

; 1128 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateNamedEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pszClassName$ = -8					; size = 4
_SpawnEdict$ = -4					; size = 4
_ent$ = 8						; size = 4
_className$ = 12					; size = 4
_SV_AllocPrivateData PROC

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1066 : 	const char	*pszClassName;
; 1067 : 	LINK_ENTITY_FUNC	SpawnEdict;
; 1068 : 
; 1069 : 	pszClassName = STRING( className );

	mov	eax, DWORD PTR _className$[ebp]
	push	eax
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _pszClassName$[ebp], eax

; 1070 : 
; 1071 : 	if( !ent )

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN2@SV_AllocPr

; 1072 : 	{
; 1073 : 		// allocate a new one
; 1074 : 		ent = SV_AllocEdict();

	call	_SV_AllocEdict
	mov	DWORD PTR _ent$[ebp], eax

; 1075 : 	}

	jmp	SHORT $LN3@SV_AllocPr
$LN2@SV_AllocPr:

; 1076 : 	else if( ent->free )

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@SV_AllocPr

; 1077 : 	{
; 1078 : 		SV_InitEdict( ent ); // re-init edict

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_InitEdict
	add	esp, 4
$LN3@SV_AllocPr:

; 1079 : 	}
; 1080 : 
; 1081 : 	ent->v.classname = className;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _className$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 1082 : 	ent->v.pContainingEntity = ent; // re-link

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+648], eax

; 1083 : 	
; 1084 : 	// allocate edict private memory (passed by dlls)
; 1085 : 	SpawnEdict = SV_GetEntityClass( pszClassName );

	mov	ecx, DWORD PTR _pszClassName$[ebp]
	push	ecx
	call	_SV_GetEntityClass
	add	esp, 4
	mov	DWORD PTR _SpawnEdict$[ebp], eax

; 1086 : 
; 1087 : 	if( !SpawnEdict )

	cmp	DWORD PTR _SpawnEdict$[ebp], 0
	jne	SHORT $LN5@SV_AllocPr

; 1088 : 	{
; 1089 : 		// attempt to create custom entity (Xash3D extension)
; 1090 : 		if( svgame.physFuncs.SV_CreateEntity && svgame.physFuncs.SV_CreateEntity( ent, pszClassName ) != -1 )

	cmp	DWORD PTR _svgame+19464, 0
	je	SHORT $LN6@SV_AllocPr
	mov	edx, DWORD PTR _pszClassName$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19464
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN6@SV_AllocPr

; 1091 : 			return ent;

	mov	eax, DWORD PTR _ent$[ebp]
	jmp	SHORT $LN1@SV_AllocPr
$LN6@SV_AllocPr:

; 1092 : 
; 1093 : 		SpawnEdict = SV_GetEntityClass( "custom" );

	push	OFFSET $SG137716
	call	_SV_GetEntityClass
	add	esp, 4
	mov	DWORD PTR _SpawnEdict$[ebp], eax

; 1094 : 
; 1095 : 		if( !SpawnEdict )

	cmp	DWORD PTR _SpawnEdict$[ebp], 0
	jne	SHORT $LN7@SV_AllocPr

; 1096 : 		{
; 1097 : 			Con_Printf( S_ERROR "No spawn function for %s\n", STRING( className ));

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET $SG137718
	call	_Con_Printf
	add	esp, 8

; 1098 : 
; 1099 : 			// free entity immediately
; 1100 : 			SV_FreeEdict( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_FreeEdict
	add	esp, 4

; 1101 : 
; 1102 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_AllocPr
$LN7@SV_AllocPr:

; 1103 : 		}
; 1104 : 
; 1105 : 		SetBits( ent->v.flags, FL_CUSTOMENTITY ); // it's a custom entity but not a beam!

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	or	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+548], ecx
$LN5@SV_AllocPr:

; 1106 : 	}
; 1107 : 
; 1108 : 	SpawnEdict( &ent->v );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	DWORD PTR _SpawnEdict$[ebp]
	add	esp, 4

; 1109 : 
; 1110 : 	return ent;

	mov	eax, DWORD PTR _ent$[ebp]
$LN1@SV_AllocPr:

; 1111 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllocPrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_mapname$ = 8						; size = 4
_SV_SpawnEntities PROC

; 4704 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4705 : 	edict_t	*ent;
; 4706 : 
; 4707 : 	// reset misc parms
; 4708 : 	Cvar_Reset( "sv_zmax" );

	push	OFFSET $SG139533
	call	_Cvar_Reset
	add	esp, 4

; 4709 : 	Cvar_Reset( "sv_wateramp" );

	push	OFFSET $SG139534
	call	_Cvar_Reset
	add	esp, 4

; 4710 : 	Cvar_Reset( "sv_wateralpha" );

	push	OFFSET $SG139535
	call	_Cvar_Reset
	add	esp, 4

; 4711 : 
; 4712 : 	// reset sky parms	
; 4713 : 	Cvar_Reset( "sv_skycolor_r" );

	push	OFFSET $SG139536
	call	_Cvar_Reset
	add	esp, 4

; 4714 : 	Cvar_Reset( "sv_skycolor_g" );

	push	OFFSET $SG139537
	call	_Cvar_Reset
	add	esp, 4

; 4715 : 	Cvar_Reset( "sv_skycolor_b" );

	push	OFFSET $SG139538
	call	_Cvar_Reset
	add	esp, 4

; 4716 : 	Cvar_Reset( "sv_skyvec_x" );

	push	OFFSET $SG139539
	call	_Cvar_Reset
	add	esp, 4

; 4717 : 	Cvar_Reset( "sv_skyvec_y" );

	push	OFFSET $SG139540
	call	_Cvar_Reset
	add	esp, 4

; 4718 : 	Cvar_Reset( "sv_skyvec_z" );

	push	OFFSET $SG139541
	call	_Cvar_Reset
	add	esp, 4

; 4719 : 	Cvar_Reset( "sv_skyname" );

	push	OFFSET $SG139542
	call	_Cvar_Reset
	add	esp, 4

; 4720 : 
; 4721 : 	ent = EDICT_NUM( 0 );

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 4722 : 	if( ent->free ) SV_InitEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SV_SpawnEn
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_InitEdict
	add	esp, 4
$LN2@SV_SpawnEn:

; 4723 : 	ent->v.model = MAKE_STRING( sv.model_precache[1] );

	mov	edx, 64					; 00000040H
	shl	edx, 0
	add	edx, OFFSET _sv+196
	push	edx
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 4724 : 	ent->v.modelindex = WORLD_INDEX; // world model

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+308], 1

; 4725 : 	ent->v.solid = SOLID_BSP;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+396], 4

; 4726 : 	ent->v.movetype = MOVETYPE_PUSH;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+392], 7

; 4727 : 	svgame.movevars.fog_settings = 0;

	mov	DWORD PTR _svgame+8072, 0

; 4728 : 
; 4729 : 	svgame.globals->maxEntities = GI->max_edicts;

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1656]
	mov	DWORD PTR [edx+148], ecx

; 4730 : 	svgame.globals->mapname = MAKE_STRING( sv.name );

	push	OFFSET _sv+56
	call	_SV_MakeString
	add	esp, 4
	mov	edx, DWORD PTR _svgame+19236
	mov	DWORD PTR [edx+12], eax

; 4731 : 	svgame.globals->startspot = MAKE_STRING( sv.startspot );

	push	OFFSET _sv+120
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _svgame+19236
	mov	DWORD PTR [ecx+16], eax

; 4732 : 	svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	edx, DWORD PTR _svgame+19236
	movss	DWORD PTR [edx], xmm0

; 4733 : 
; 4734 : 	// spawn the rest of the entities on the map
; 4735 : 	SV_LoadFromFile( mapname, sv.worldmodel->entities );

	mov	eax, DWORD PTR _sv+1359676
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	mov	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_SV_LoadFromFile
	add	esp, 8

; 4736 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SpawnEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_move$ = -4						; size = 4
_ideal$ = 8						; size = 4
_current$ = 12						; size = 4
_speed$ = 16						; size = 4
_SV_AngleMod PROC

; 147  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 148  : 	float	move;
; 149  : 
; 150  : 	current = anglemod( current );

	push	ecx
	movss	xmm0, DWORD PTR _current$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	fstp	DWORD PTR _current$[ebp]

; 151  : 
; 152  : 	if( current == ideal ) // already there?

	movss	xmm0, DWORD PTR _current$[ebp]
	ucomiss	xmm0, DWORD PTR _ideal$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SV_AngleMo

; 153  : 		return current; 

	fld	DWORD PTR _current$[ebp]
	jmp	$LN1@SV_AngleMo
$LN2@SV_AngleMo:

; 154  : 
; 155  : 	move = ideal - current;

	movss	xmm0, DWORD PTR _ideal$[ebp]
	subss	xmm0, DWORD PTR _current$[ebp]
	movss	DWORD PTR _move$[ebp], xmm0

; 156  : 
; 157  : 	if( ideal > current )

	movss	xmm0, DWORD PTR _ideal$[ebp]
	comiss	xmm0, DWORD PTR _current$[ebp]
	jbe	SHORT $LN3@SV_AngleMo

; 158  : 	{
; 159  : 		if( move >= 180 )

	movss	xmm0, DWORD PTR _move$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jb	SHORT $LN5@SV_AngleMo

; 160  : 			move = move - 360;

	movss	xmm0, DWORD PTR _move$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _move$[ebp], xmm0
$LN5@SV_AngleMo:

; 161  : 	}

	jmp	SHORT $LN6@SV_AngleMo
$LN3@SV_AngleMo:

; 162  : 	else
; 163  : 	{
; 164  : 		if( move <= -180 )

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _move$[ebp]
	jb	SHORT $LN6@SV_AngleMo

; 165  : 			move = move + 360;

	movss	xmm0, DWORD PTR _move$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _move$[ebp], xmm0
$LN6@SV_AngleMo:

; 166  : 	}
; 167  : 
; 168  : 	if( move > 0 )

	movss	xmm0, DWORD PTR _move$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@SV_AngleMo

; 169  : 	{
; 170  : 		if( move > speed )

	movss	xmm0, DWORD PTR _move$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN9@SV_AngleMo

; 171  : 			move = speed;

	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _move$[ebp], xmm0
$LN9@SV_AngleMo:

; 172  : 	}

	jmp	SHORT $LN10@SV_AngleMo
$LN7@SV_AngleMo:

; 173  : 	else
; 174  : 	{
; 175  : 		if( move < -speed )

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _move$[ebp]
	jbe	SHORT $LN10@SV_AngleMo

; 176  : 			move = -speed;

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _move$[ebp], xmm0
$LN10@SV_AngleMo:

; 177  : 	}
; 178  : 
; 179  : 	return anglemod( current + move );

	movss	xmm0, DWORD PTR _current$[ebp]
	addss	xmm0, DWORD PTR _move$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
$LN1@SV_AngleMo:

; 180  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AngleMod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_lumpofs$ = -2328					; size = 4
_header$ = -2324					; size = 4
_entities$1 = -2320					; size = 4
_lumplen$ = -2316					; size = 4
_f$ = -2312						; size = 4
_buf$ = -2308						; size = 2048
_bspfilename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_SV_WriteEntityPatch PROC

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2328				; 00000918H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 755  : 	int		lumpofs = 0, lumplen = 0;

	mov	DWORD PTR _lumpofs$[ebp], 0
	mov	DWORD PTR _lumplen$[ebp], 0

; 756  : 	byte		buf[MAX_TOKEN]; // 1 kb
; 757  : 	string		bspfilename;
; 758  : 	dheader_t		*header;
; 759  : 	file_t		*f;
; 760  : 
; 761  : 	Q_strncpy( bspfilename, va( "maps/%s.bsp", filename ), sizeof( bspfilename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG137594
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _bspfilename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 762  : 	f = FS_Open( bspfilename, "rb", false );

	push	0
	push	OFFSET $SG137595
	lea	edx, DWORD PTR _bspfilename$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 763  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@SV_WriteEn
	jmp	$LN1@SV_WriteEn
$LN2@SV_WriteEn:

; 764  : 
; 765  : 	memset( buf, 0, MAX_TOKEN );

	push	2048					; 00000800H
	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 766  : 	FS_Read( f, buf, MAX_TOKEN );

	push	2048					; 00000800H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 767  : 	header = (dheader_t *)buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 768  : 
; 769  : 	// check all the lumps and some other errors
; 770  : 	if( !Mod_TestBmodelLumps( bspfilename, buf, true ))

	push	1
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bspfilename$[ebp]
	push	edx
	call	_Mod_TestBmodelLumps
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SV_WriteEn

; 771  : 	{
; 772  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 773  : 		return;

	jmp	$LN1@SV_WriteEn
$LN3@SV_WriteEn:

; 774  : 	}
; 775  : 
; 776  : 	lumpofs = header->lumps[LUMP_ENTITIES].fileofs;

	mov	ecx, 8
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _lumpofs$[ebp], ecx

; 777  : 	lumplen = header->lumps[LUMP_ENTITIES].filelen;

	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _lumplen$[ebp], edx

; 778  : 
; 779  : 	if( lumplen >= 10 )

	cmp	DWORD PTR _lumplen$[ebp], 10		; 0000000aH
	jl	$LN4@SV_WriteEn

; 780  : 	{
; 781  : 		char	*entities = NULL;

	mov	DWORD PTR _entities$1[ebp], 0

; 782  : 		
; 783  : 		FS_Seek( f, lumpofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _lumpofs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 784  : 		entities = (char *)Z_Calloc( lumplen + 1 );

	push	784					; 00000310H
	push	OFFSET $SG137599
	push	1
	mov	edx, DWORD PTR _lumplen$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _entities$1[ebp], eax

; 785  : 		FS_Read( f, entities, lumplen );

	mov	ecx, DWORD PTR _lumplen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entities$1[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 786  : 		FS_WriteFile( va( "maps/%s.ent", filename ), entities, lumplen );

	mov	ecx, DWORD PTR _lumplen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entities$1[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG137600
	call	_va
	add	esp, 8
	push	eax
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 787  : 		Con_Printf( "Write 'maps/%s.ent'\n", filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG137601
	call	_Con_Printf
	add	esp, 8

; 788  : 		Mem_Free( entities );

	push	788					; 00000314H
	push	OFFSET $SG137602
	mov	edx, DWORD PTR _entities$1[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_WriteEn:

; 789  : 	}
; 790  : 
; 791  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@SV_WriteEn:

; 792  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WriteEntityPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_spawn_entity$ = -80					; size = 4
_flags$ = -76						; size = 4
_smooth$ = -72						; size = 4
_mapname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_landname$ = 12						; size = 4
_SV_QueueChangeLevel PROC

; 669  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 670  : 	int	flags, smooth = false;

	mov	DWORD PTR _smooth$[ebp], 0

; 671  : 	char	mapname[MAX_QPATH];
; 672  : 	char	*spawn_entity;
; 673  : 
; 674  : 	// hold mapname to other place
; 675  : 	Q_strncpy( mapname, level, sizeof( mapname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 676  : 	COM_StripExtension( mapname );

	lea	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_COM_StripExtension
	add	esp, 4

; 677  : 
; 678  : 	if( COM_CheckString( landname ))

	mov	eax, DWORD PTR _landname$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SV_QueueCh

; 679  : 		smooth = true;

	mov	DWORD PTR _smooth$[ebp], 1
$LN2@SV_QueueCh:

; 680  : 
; 681  : 	// determine spawn entity classname
; 682  : 	if( svs.maxclients == 1 )

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN3@SV_QueueCh

; 683  : 		spawn_entity = GI->sp_entity;

	mov	ecx, DWORD PTR _SI+768
	add	ecx, 1304				; 00000518H
	mov	DWORD PTR _spawn_entity$[ebp], ecx
	jmp	SHORT $LN4@SV_QueueCh
$LN3@SV_QueueCh:

; 684  : 	else spawn_entity = GI->mp_entity;

	mov	edx, DWORD PTR _SI+768
	add	edx, 1336				; 00000538H
	mov	DWORD PTR _spawn_entity$[ebp], edx
$LN4@SV_QueueCh:

; 685  : 
; 686  : 	flags = SV_MapIsValid( mapname, spawn_entity, landname );

	mov	eax, DWORD PTR _landname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spawn_entity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], eax

; 687  : 
; 688  : 	if( FBitSet( flags, MAP_INVALID_VERSION ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN5@SV_QueueCh

; 689  : 	{
; 690  : 		Con_Printf( S_ERROR "changelevel: %s is invalid or not supported\n", mapname );

	lea	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	push	OFFSET $SG137564
	call	_Con_Printf
	add	esp, 8

; 691  : 		return;

	jmp	$LN16@SV_QueueCh
$LN5@SV_QueueCh:

; 692  : 	}
; 693  : 	
; 694  : 	if( !FBitSet( flags, MAP_IS_EXIST ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	jne	SHORT $LN6@SV_QueueCh

; 695  : 	{
; 696  : 		Con_Printf( S_ERROR "changelevel: map %s doesn't exist\n", mapname );

	lea	eax, DWORD PTR _mapname$[ebp]
	push	eax
	push	OFFSET $SG137566
	call	_Con_Printf
	add	esp, 8

; 697  : 		return;

	jmp	$LN16@SV_QueueCh
$LN6@SV_QueueCh:

; 698  : 	}
; 699  : 
; 700  : 	if( smooth && !FBitSet( flags, MAP_HAS_LANDMARK ))

	cmp	DWORD PTR _smooth$[ebp], 0
	je	SHORT $LN8@SV_QueueCh
	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN8@SV_QueueCh

; 701  : 	{
; 702  : 		if( sv_validate_changelevel->value )

	mov	edx, DWORD PTR _sv_validate_changelevel
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@SV_QueueCh

; 703  : 		{
; 704  : 			// NOTE: we find valid map but specified landmark it's doesn't exist
; 705  : 			// run simple changelevel like in q1, throw warning
; 706  : 			Con_Printf( S_WARN "changelevel: %s doesn't contain landmark [%s]. smooth transition was disabled\n", mapname, landname );

	mov	eax, DWORD PTR _landname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	push	OFFSET $SG137569
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 707  : 			smooth = false;

	mov	DWORD PTR _smooth$[ebp], 0
$LN8@SV_QueueCh:

; 708  : 		}
; 709  : 	}
; 710  : 
; 711  : 	if( svs.maxclients > 1 )

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN9@SV_QueueCh

; 712  : 		smooth = false; // multiplayer doesn't support smooth transition

	mov	DWORD PTR _smooth$[ebp], 0
$LN9@SV_QueueCh:

; 713  : 
; 714  : 	if( smooth && !Q_stricmp( sv.name, level ))

	cmp	DWORD PTR _smooth$[ebp], 0
	je	SHORT $LN10@SV_QueueCh
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	push	OFFSET _sv+56
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@SV_QueueCh

; 715  : 	{
; 716  : 		Con_Printf( S_ERROR "can't changelevel with same map. Ignored.\n" );

	push	OFFSET $SG137572
	call	_Con_Printf
	add	esp, 4

; 717  : 		return;	

	jmp	$LN16@SV_QueueCh
$LN10@SV_QueueCh:

; 718  : 	}
; 719  : 
; 720  : 	if( !smooth && !FBitSet( flags, MAP_HAS_SPAWNPOINT ))

	cmp	DWORD PTR _smooth$[ebp], 0
	jne	SHORT $LN12@SV_QueueCh
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	jne	SHORT $LN12@SV_QueueCh

; 721  : 	{
; 722  : 		if( sv_validate_changelevel->value )

	mov	ecx, DWORD PTR _sv_validate_changelevel
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SV_QueueCh

; 723  : 		{
; 724  : 			Con_Printf( S_ERROR "changelevel: %s doesn't have a valid spawnpoint. Ignored.\n", mapname );

	lea	edx, DWORD PTR _mapname$[ebp]
	push	edx
	push	OFFSET $SG137575
	call	_Con_Printf
	add	esp, 8

; 725  : 			return;	

	jmp	SHORT $LN16@SV_QueueCh
$LN12@SV_QueueCh:

; 726  : 		}
; 727  : 	}
; 728  : 
; 729  : 	// bad changelevel position invoke enables in one-way transition
; 730  : 	if( sv.framecount < 15 )

	cmp	DWORD PTR _sv+36, 15			; 0000000fH
	jge	SHORT $LN14@SV_QueueCh

; 731  : 	{
; 732  : 		if( sv_validate_changelevel->value )

	mov	eax, DWORD PTR _sv_validate_changelevel
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@SV_QueueCh

; 733  : 		{
; 734  : 			Con_Printf( S_WARN "an infinite changelevel was detected and will be disabled until a next save\\restore\n" );

	push	OFFSET $SG137578
	call	_Con_Printf
	add	esp, 4

; 735  : 			return; // lock with svs.spawncount here

	jmp	SHORT $LN16@SV_QueueCh
$LN14@SV_QueueCh:

; 736  : 		}
; 737  : 	}
; 738  : 
; 739  : 	SV_SkipUpdates ();

	call	_SV_SkipUpdates

; 740  : 
; 741  : 	// changelevel will be executed on a next frame
; 742  : 	if( smooth ) COM_ChangeLevel( mapname, landname, sv.background );	// Smoothed Half-Life changelevel

	cmp	DWORD PTR _smooth$[ebp], 0
	je	SHORT $LN15@SV_QueueCh
	mov	ecx, DWORD PTR _sv+4
	push	ecx
	mov	edx, DWORD PTR _landname$[ebp]
	push	edx
	lea	eax, DWORD PTR _mapname$[ebp]
	push	eax
	call	_COM_ChangeLevel
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@SV_QueueCh
$LN15@SV_QueueCh:

; 743  : 	else COM_ChangeLevel( mapname, NULL, sv.background );		// Classic Quake changlevel

	mov	ecx, DWORD PTR _sv+4
	push	ecx
	push	0
	lea	edx, DWORD PTR _mapname$[ebp]
	push	edx
	call	_COM_ChangeLevel
	add	esp, 12					; 0000000cH
$LN16@SV_QueueCh:

; 744  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_QueueChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_org$ = 8						; size = 4
_absmin$ = 12						; size = 4
_absmax$ = 16						; size = 4
_SV_BoxInPVS PROC

; 655  : {

	push	ebp
	mov	ebp, esp

; 656  : 	if( !Mod_BoxVisible( absmin, absmax, Mod_GetPVSForPoint( org )))

	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_Mod_GetPVSForPoint
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _absmax$[ebp]
	push	ecx
	mov	edx, DWORD PTR _absmin$[ebp]
	push	edx
	call	_Mod_BoxVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_BoxInPV

; 657  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_BoxInPV
$LN2@SV_BoxInPV:

; 658  : 	return true;

	mov	eax, 1
$LN1@SV_BoxInPV:

; 659  : }

	pop	ebp
	ret	0
_SV_BoxInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_spawn$ = -48						; size = 4
tv169 = -44						; size = 4
tv95 = -40						; size = 4
tv94 = -36						; size = 4
tv87 = -32						; size = 4
tv86 = -28						; size = 4
tv80 = -24						; size = 4
tv79 = -20						; size = 4
tv71 = -16						; size = 4
tv70 = -12						; size = 4
_entityIndex$ = -8					; size = 4
_sound_idx$ = -4					; size = 4
_msg$ = 8						; size = 4
_ent$ = 12						; size = 4
_chan$ = 16						; size = 4
_sample$ = 20						; size = 4
_vol$ = 24						; size = 4
_attn$ = 28						; size = 4
_flags$ = 32						; size = 4
_pitch$ = 36						; size = 4
_pos$ = 40						; size = 4
_SV_BuildSoundMsg PROC

; 1989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1990 : 	int	entityIndex;
; 1991 : 	int	sound_idx;
; 1992 : 	qboolean	spawn;
; 1993 : 
; 1994 : 	if( vol < 0 || vol > 255 )

	cmp	DWORD PTR _vol$[ebp], 0
	jl	SHORT $LN3@SV_BuildSo
	cmp	DWORD PTR _vol$[ebp], 255		; 000000ffH
	jle	SHORT $LN2@SV_BuildSo
$LN3@SV_BuildSo:

; 1995 : 	{
; 1996 : 		Con_Reportf( S_ERROR "SV_StartSound: volume = %i\n", vol );

	mov	eax, DWORD PTR _vol$[ebp]
	push	eax
	push	OFFSET $SG138170
	call	_Con_Reportf
	add	esp, 8

; 1997 : 		vol = bound( 0, vol, 255 );

	cmp	DWORD PTR _vol$[ebp], 0
	jl	SHORT $LN34@SV_BuildSo
	cmp	DWORD PTR _vol$[ebp], 255		; 000000ffH
	jge	SHORT $LN32@SV_BuildSo
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN33@SV_BuildSo
$LN32@SV_BuildSo:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN33@SV_BuildSo:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN35@SV_BuildSo
$LN34@SV_BuildSo:
	mov	DWORD PTR tv71[ebp], 0
$LN35@SV_BuildSo:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _vol$[ebp], eax
$LN2@SV_BuildSo:

; 1998 : 	}
; 1999 : 
; 2000 : 	if( attn < 0.0f || attn > 4.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _attn$[ebp]
	ja	SHORT $LN5@SV_BuildSo
	movss	xmm0, DWORD PTR _attn$[ebp]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN4@SV_BuildSo
$LN5@SV_BuildSo:

; 2001 : 	{
; 2002 : 		Con_Reportf( S_ERROR "SV_StartSound: attenuation %g must be in range 0-4\n", attn );

	cvtss2sd xmm0, DWORD PTR _attn$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG138173
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2003 : 		attn = bound( 0.0f, attn, 4.0f );

	movss	xmm0, DWORD PTR _attn$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN38@SV_BuildSo
	movss	xmm0, DWORD PTR __real@40800000
	comiss	xmm0, DWORD PTR _attn$[ebp]
	jbe	SHORT $LN36@SV_BuildSo
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN37@SV_BuildSo
$LN36@SV_BuildSo:
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR tv79[ebp], xmm0
$LN37@SV_BuildSo:
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN39@SV_BuildSo
$LN38@SV_BuildSo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv80[ebp], xmm0
$LN39@SV_BuildSo:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR _attn$[ebp], xmm0
$LN4@SV_BuildSo:

; 2004 : 	}
; 2005 : 
; 2006 : 	if( chan < 0 || chan > 7 )

	cmp	DWORD PTR _chan$[ebp], 0
	jl	SHORT $LN7@SV_BuildSo
	cmp	DWORD PTR _chan$[ebp], 7
	jle	SHORT $LN6@SV_BuildSo
$LN7@SV_BuildSo:

; 2007 : 	{
; 2008 : 		Con_Reportf( S_ERROR "SV_StartSound: channel must be in range 0-7\n" );

	push	OFFSET $SG138176
	call	_Con_Reportf
	add	esp, 4

; 2009 : 		chan = bound( 0, chan, 7 );

	cmp	DWORD PTR _chan$[ebp], 0
	jl	SHORT $LN42@SV_BuildSo
	cmp	DWORD PTR _chan$[ebp], 7
	jge	SHORT $LN40@SV_BuildSo
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN41@SV_BuildSo
$LN40@SV_BuildSo:
	mov	DWORD PTR tv86[ebp], 7
$LN41@SV_BuildSo:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], edx
	jmp	SHORT $LN43@SV_BuildSo
$LN42@SV_BuildSo:
	mov	DWORD PTR tv87[ebp], 0
$LN43@SV_BuildSo:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR _chan$[ebp], eax
$LN6@SV_BuildSo:

; 2010 : 	}
; 2011 : 
; 2012 : 	if( pitch < 0 || pitch > 255 )

	cmp	DWORD PTR _pitch$[ebp], 0
	jl	SHORT $LN9@SV_BuildSo
	cmp	DWORD PTR _pitch$[ebp], 255		; 000000ffH
	jle	SHORT $LN8@SV_BuildSo
$LN9@SV_BuildSo:

; 2013 : 	{
; 2014 : 		Con_Reportf( S_ERROR "SV_StartSound: pitch = %i\n", pitch );

	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	OFFSET $SG138179
	call	_Con_Reportf
	add	esp, 8

; 2015 : 		pitch = bound( 0, pitch, 255 );

	cmp	DWORD PTR _pitch$[ebp], 0
	jl	SHORT $LN46@SV_BuildSo
	cmp	DWORD PTR _pitch$[ebp], 255		; 000000ffH
	jge	SHORT $LN44@SV_BuildSo
	mov	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	jmp	SHORT $LN45@SV_BuildSo
$LN44@SV_BuildSo:
	mov	DWORD PTR tv94[ebp], 255		; 000000ffH
$LN45@SV_BuildSo:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN47@SV_BuildSo
$LN46@SV_BuildSo:
	mov	DWORD PTR tv95[ebp], 0
$LN47@SV_BuildSo:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _pitch$[ebp], ecx
$LN8@SV_BuildSo:

; 2016 : 	}
; 2017 : 
; 2018 : 	if( !COM_CheckString( sample ))

	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@SV_BuildSo

; 2019 : 	{
; 2020 : 		Con_Reportf( S_ERROR "SV_StartSound: passed NULL sample\n" );

	push	OFFSET $SG138181
	call	_Con_Reportf
	add	esp, 4

; 2021 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_BuildSo
$LN10@SV_BuildSo:

; 2022 : 	}
; 2023 : 
; 2024 : 	if( sample[0] == '!' && Q_isdigit( sample + 1 ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sample$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN11@SV_BuildSo
	mov	ecx, DWORD PTR _sample$[ebp]
	add	ecx, 1
	push	ecx
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@SV_BuildSo

; 2025 : 	{
; 2026 : 		sound_idx = Q_atoi( sample + 1 );

	mov	edx, DWORD PTR _sample$[ebp]
	add	edx, 1
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _sound_idx$[ebp], eax

; 2027 : 
; 2028 : 		if( sound_idx >= MAX_SOUNDS )

	cmp	DWORD PTR _sound_idx$[ebp], 2048	; 00000800H
	jl	SHORT $LN13@SV_BuildSo

; 2029 : 		{
; 2030 : 			SetBits( flags, SND_SENTENCE|SND_SEQUENCE );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 20					; 00000014H
	mov	DWORD PTR _flags$[ebp], eax

; 2031 : 			sound_idx -= MAX_SOUNDS;

	mov	ecx, DWORD PTR _sound_idx$[ebp]
	sub	ecx, 2048				; 00000800H
	mov	DWORD PTR _sound_idx$[ebp], ecx

; 2032 : 		}

	jmp	SHORT $LN14@SV_BuildSo
$LN13@SV_BuildSo:

; 2033 : 		else SetBits( flags, SND_SENTENCE );

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR _flags$[ebp], edx
$LN14@SV_BuildSo:

; 2034 : 	}

	jmp	SHORT $LN16@SV_BuildSo
$LN11@SV_BuildSo:

; 2035 : 	else if( sample[0] == '#' && Q_isdigit( sample + 1 ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sample$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN15@SV_BuildSo
	mov	ecx, DWORD PTR _sample$[ebp]
	add	ecx, 1
	push	ecx
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@SV_BuildSo

; 2036 : 	{
; 2037 : 		SetBits( flags, SND_SENTENCE|SND_SEQUENCE );

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 20					; 00000014H
	mov	DWORD PTR _flags$[ebp], edx

; 2038 : 		sound_idx = Q_atoi( sample + 1 );

	mov	eax, DWORD PTR _sample$[ebp]
	add	eax, 1
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _sound_idx$[ebp], eax

; 2039 : 	}

	jmp	SHORT $LN16@SV_BuildSo
$LN15@SV_BuildSo:

; 2040 : 	else
; 2041 : 	{
; 2042 : 		// TESTTEST
; 2043 : 		if( *sample == '*' ) chan = CHAN_AUTO;

	mov	ecx, DWORD PTR _sample$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN17@SV_BuildSo
	mov	DWORD PTR _chan$[ebp], 0
$LN17@SV_BuildSo:

; 2044 : 
; 2045 : 		// precache_sound can be used twice: cache sounds when loading
; 2046 : 		// and return sound index when server is active
; 2047 : 		sound_idx = SV_SoundIndex( sample );

	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	call	_SV_SoundIndex
	add	esp, 4
	mov	DWORD PTR _sound_idx$[ebp], eax
$LN16@SV_BuildSo:

; 2048 : 	}
; 2049 : 
; 2050 : 	if( !sound_idx )

	cmp	DWORD PTR _sound_idx$[ebp], 0
	jne	SHORT $LN18@SV_BuildSo

; 2051 : 	{
; 2052 : 		Con_Printf( S_ERROR "SV_StartSound: %s not precached (%d)\n", sample, sound_idx );

	mov	ecx, DWORD PTR _sound_idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	push	OFFSET $SG138190
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2053 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_BuildSo
$LN18@SV_BuildSo:

; 2054 : 	}
; 2055 : 
; 2056 : 	spawn = FBitSet( flags, SND_RESTORE_POSITION ) ? false : true;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN48@SV_BuildSo
	mov	DWORD PTR tv169[ebp], 0
	jmp	SHORT $LN49@SV_BuildSo
$LN48@SV_BuildSo:
	mov	DWORD PTR tv169[ebp], 1
$LN49@SV_BuildSo:
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR _spawn$[ebp], ecx

; 2057 : 
; 2058 : 	if( SV_IsValidEdict( ent ) && SV_IsValidEdict( ent->v.aiment ))

	push	2058					; 0000080aH
	push	OFFSET $SG138193
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@SV_BuildSo
	push	2058					; 0000080aH
	push	OFFSET $SG138194
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@SV_BuildSo

; 2059 : 		entityIndex = NUM_FOR_EDICT( ent->v.aiment );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+532]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _entityIndex$[ebp], eax
	jmp	SHORT $LN22@SV_BuildSo
$LN19@SV_BuildSo:

; 2060 : 	else if( SV_IsValidEdict( ent ))

	push	2060					; 0000080cH
	push	OFFSET $SG138197
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@SV_BuildSo

; 2061 : 		entityIndex = NUM_FOR_EDICT( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _entityIndex$[ebp], eax
	jmp	SHORT $LN22@SV_BuildSo
$LN21@SV_BuildSo:

; 2062 : 	else entityIndex = 0; // assume world

	mov	DWORD PTR _entityIndex$[ebp], 0
$LN22@SV_BuildSo:

; 2063 : 
; 2064 : 	if( vol != 255 ) SetBits( flags, SND_VOLUME );

	cmp	DWORD PTR _vol$[ebp], 255		; 000000ffH
	je	SHORT $LN23@SV_BuildSo
	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 1
	mov	DWORD PTR _flags$[ebp], edx
$LN23@SV_BuildSo:

; 2065 : 	if( attn != ATTN_NONE ) SetBits( flags, SND_ATTENUATION );

	movss	xmm0, DWORD PTR _attn$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SV_BuildSo
	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	mov	DWORD PTR _flags$[ebp], eax
$LN24@SV_BuildSo:

; 2066 : 	if( pitch != PITCH_NORM ) SetBits( flags, SND_PITCH );

	cmp	DWORD PTR _pitch$[ebp], 100		; 00000064H
	je	SHORT $LN25@SV_BuildSo
	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 8
	mov	DWORD PTR _flags$[ebp], ecx
$LN25@SV_BuildSo:

; 2067 : 
; 2068 : 	// not sending (because this is out of range)
; 2069 : 	ClearBits( flags, SND_RESTORE_POSITION );

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, -4097				; ffffefffH
	mov	DWORD PTR _flags$[ebp], edx

; 2070 : 	ClearBits( flags, SND_FILTER_CLIENT );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -2049				; fffff7ffH
	mov	DWORD PTR _flags$[ebp], eax

; 2071 : 	ClearBits( flags, SND_SPAWNING );

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, -257				; fffffeffH
	mov	DWORD PTR _flags$[ebp], ecx

; 2072 : 
; 2073 : 	if( spawn ) MSG_BeginServerCmd( msg, svc_sound );

	cmp	DWORD PTR _spawn$[ebp], 0
	je	SHORT $LN26@SV_BuildSo
	push	0
	push	1
	push	6
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
	jmp	SHORT $LN27@SV_BuildSo
$LN26@SV_BuildSo:

; 2074 : 	else MSG_BeginServerCmd( msg, svc_restoresound );

	push	0
	push	1
	push	19					; 00000013H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
$LN27@SV_BuildSo:

; 2075 : 	MSG_WriteUBitLong( msg, flags, MAX_SND_FLAGS_BITS );

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2076 : 	MSG_WriteUBitLong( msg, sound_idx, MAX_SOUND_BITS );

	push	11					; 0000000bH
	mov	eax, DWORD PTR _sound_idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2077 : 	MSG_WriteUBitLong( msg, chan, MAX_SND_CHAN_BITS );

	push	4
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2078 : 
; 2079 : 	if( FBitSet( flags, SND_VOLUME )) MSG_WriteByte( msg, vol );

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	je	SHORT $LN28@SV_BuildSo
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN28@SV_BuildSo:

; 2080 : 	if( FBitSet( flags, SND_ATTENUATION )) MSG_WriteByte( msg, attn * 64 );

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 2
	je	SHORT $LN29@SV_BuildSo
	movss	xmm0, DWORD PTR _attn$[ebp]
	mulss	xmm0, DWORD PTR __real@42800000
	cvttss2si edx, xmm0
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN29@SV_BuildSo:

; 2081 : 	if( FBitSet( flags, SND_PITCH )) MSG_WriteByte( msg, pitch );

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 8
	je	SHORT $LN30@SV_BuildSo
	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN30@SV_BuildSo:

; 2082 : 
; 2083 : 	MSG_WriteUBitLong( msg, entityIndex, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 2084 : 	MSG_WriteVec3Coord( msg, pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteVec3Coord
	add	esp, 8

; 2085 : 
; 2086 : 	return 1;

	mov	eax, 1
$LN1@SV_BuildSo:

; 2087 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BuildSoundMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_nullargs$ = -76					; size = 72
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_eventindex$ = 12					; size = 2
_delay$ = 16						; size = 4
_args$ = 20						; size = 4
_SV_PlaybackReliableEvent PROC

; 1158 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1159 : 	event_args_t nullargs;
; 1160 : 
; 1161 : 	memset( &nullargs, 0, sizeof( nullargs ));

	push	72					; 00000048H
	push	0
	lea	eax, DWORD PTR _nullargs$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1162 : 
; 1163 : 	MSG_BeginServerCmd( msg, svc_event_reliable );

	push	0
	push	1
	push	21					; 00000015H
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1164 : 
; 1165 : 	// send event index
; 1166 : 	MSG_WriteUBitLong( msg, eventindex, MAX_EVENT_BITS );

	push	10					; 0000000aH
	movzx	edx, WORD PTR _eventindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 1167 : 
; 1168 : 	if( delay )

	movss	xmm0, DWORD PTR _delay$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_Playbac

; 1169 : 	{
; 1170 : 		// send event delay
; 1171 : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 1172 : 		MSG_WriteWord( msg, ( delay * 100.0f ));

	movss	xmm0, DWORD PTR _delay$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si edx, xmm0
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteWord
	add	esp, 8

; 1173 : 	}

	jmp	SHORT $LN3@SV_Playbac
$LN2@SV_Playbac:

; 1174 : 	else MSG_WriteOneBit( msg, 0 );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8
$LN3@SV_Playbac:

; 1175 : 
; 1176 : 	// reliable events not use delta-compression just null-compression
; 1177 : 	MSG_WriteDeltaEvent( msg, &nullargs, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	lea	eax, DWORD PTR _nullargs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteDeltaEvent
	add	esp, 12					; 0000000cH

; 1178 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PlaybackReliableEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv232 = -136						; size = 4
_es$ = -132						; size = 4
_mask$ = -128						; size = 4
tv326 = -124						; size = 4
_ev_name$1 = -120					; size = 4
tv238 = -116						; size = 4
_slot$ = -112						; size = 4
_bestslot$ = -108					; size = 4
_invokerIndex$ = -104					; size = 4
_ei$ = -100						; size = 4
_j$ = -96						; size = 4
_cl$ = -92						; size = 4
_args$ = -88						; size = 72
_pvspoint$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_flags$ = 8						; size = 4
_pInvoker$ = 12						; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_SV_PlaybackEventFull PROC

; 3697 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 3698 : 	sv_client_t	*cl;
; 3699 : 	event_state_t	*es;
; 3700 : 	event_args_t	args;
; 3701 : 	event_info_t	*ei = NULL;

	mov	DWORD PTR _ei$[ebp], 0

; 3702 : 	int		j, slot, bestslot;
; 3703 : 	int		invokerIndex;
; 3704 : 	byte		*mask = NULL;

	mov	DWORD PTR _mask$[ebp], 0

; 3705 : 	vec3_t		pvspoint;
; 3706 : 
; 3707 : 	if( FBitSet( flags, FEV_CLIENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN11@SV_Playbac

; 3708 : 		return;	// someone stupid joke

	jmp	$LN3@SV_Playbac
$LN11@SV_Playbac:

; 3709 : 
; 3710 : 	// first check event for out of bounds
; 3711 : 	if( eventindex < 1 || eventindex > MAX_EVENTS )

	movzx	ecx, WORD PTR _eventindex$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN13@SV_Playbac
	movzx	edx, WORD PTR _eventindex$[ebp]
	cmp	edx, 1024				; 00000400H
	jle	SHORT $LN12@SV_Playbac
$LN13@SV_Playbac:

; 3712 : 	{
; 3713 : 		Con_Printf( S_ERROR "EV_Playback: invalid eventindex %i\n", eventindex );

	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	push	OFFSET $SG139157
	call	_Con_Printf
	add	esp, 8

; 3714 : 		return;

	jmp	$LN3@SV_Playbac
$LN12@SV_Playbac:

; 3715 : 	}
; 3716 : 
; 3717 : 	// check event for precached
; 3718 : 	if( !COM_CheckString( sv.event_precache[eventindex] ))

	movzx	ecx, WORD PTR _eventindex$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+262340
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@SV_Playbac

; 3719 : 	{
; 3720 : 		Con_Printf( S_ERROR "EV_Playback: event %i was not precached\n", eventindex );

	movzx	edx, WORD PTR _eventindex$[ebp]
	push	edx
	push	OFFSET $SG139159
	call	_Con_Printf
	add	esp, 8

; 3721 : 		return;		

	jmp	$LN3@SV_Playbac
$LN14@SV_Playbac:

; 3722 : 	}
; 3723 : 
; 3724 : 	memset( &args, 0, sizeof( args ));

	push	72					; 00000048H
	push	0
	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3725 : 
; 3726 : 	if( origin && !VectorIsNull( origin ))

	cmp	DWORD PTR _origin$[ebp], 0
	je	$LN15@SV_Playbac
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@SV_Playbac
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@SV_Playbac
$LN16@SV_Playbac:

; 3727 : 	{
; 3728 : 		VectorCopy( origin, args.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _args$[ebp+edx+8], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _args$[ebp+edx+8], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+8], edx

; 3729 : 		args.flags |= FEVENT_ORIGIN;

	mov	eax, DWORD PTR _args$[ebp]
	or	eax, 1
	mov	DWORD PTR _args$[ebp], eax
$LN15@SV_Playbac:

; 3730 : 	}
; 3731 : 
; 3732 : 	if( angles && !VectorIsNull( angles ))

	cmp	DWORD PTR _angles$[ebp], 0
	je	$LN17@SV_Playbac
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_Playbac
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_Playbac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@SV_Playbac
$LN18@SV_Playbac:

; 3733 : 	{
; 3734 : 		VectorCopy( angles, args.angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _args$[ebp+edx+20], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _args$[ebp+edx+20], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+20], edx

; 3735 : 		args.flags |= FEVENT_ANGLES;

	mov	eax, DWORD PTR _args$[ebp]
	or	eax, 2
	mov	DWORD PTR _args$[ebp], eax
$LN17@SV_Playbac:

; 3736 : 	}
; 3737 : 
; 3738 : 	// copy other parms
; 3739 : 	args.fparam1 = fparam1;

	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR _args$[ebp+48], xmm0

; 3740 : 	args.fparam2 = fparam2;

	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR _args$[ebp+52], xmm0

; 3741 : 	args.iparam1 = iparam1;

	mov	ecx, DWORD PTR _iparam1$[ebp]
	mov	DWORD PTR _args$[ebp+56], ecx

; 3742 : 	args.iparam2 = iparam2;

	mov	edx, DWORD PTR _iparam2$[ebp]
	mov	DWORD PTR _args$[ebp+60], edx

; 3743 : 	args.bparam1 = bparam1;

	mov	eax, DWORD PTR _bparam1$[ebp]
	mov	DWORD PTR _args$[ebp+64], eax

; 3744 : 	args.bparam2 = bparam2;

	mov	ecx, DWORD PTR _bparam2$[ebp]
	mov	DWORD PTR _args$[ebp+68], ecx

; 3745 : 
; 3746 : 	VectorClear( pvspoint );

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _pvspoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _pvspoint$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _pvspoint$[ebp+edx], xmm0

; 3747 : 
; 3748 : 	if( SV_IsValidEdict( pInvoker ))

	push	3748					; 00000ea4H
	push	OFFSET $SG139166
	mov	eax, DWORD PTR _pInvoker$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN19@SV_Playbac

; 3749 : 	{
; 3750 : 		// add the view_ofs to avoid problems with crossed contents line
; 3751 : 		VectorAdd( pInvoker->v.origin, pInvoker->v.view_ofs, pvspoint );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pInvoker$[ebp]
	mov	esi, DWORD PTR _pInvoker$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _pvspoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	esi, DWORD PTR _pInvoker$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+500]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _pvspoint$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pInvoker$[ebp]
	mov	esi, DWORD PTR _pInvoker$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+136]
	addss	xmm0, DWORD PTR [esi+edx+500]
	movss	DWORD PTR tv232[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv232[ebp]
	movss	DWORD PTR _pvspoint$[ebp+ecx], xmm0

; 3752 : 		args.entindex = invokerIndex = NUM_FOR_EDICT( pInvoker );

	mov	eax, DWORD PTR _pInvoker$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _invokerIndex$[ebp], eax
	mov	edx, DWORD PTR _invokerIndex$[ebp]
	mov	DWORD PTR _args$[ebp+4], edx

; 3753 : 
; 3754 : 		// g-cont. allow 'ducking' param for all entities
; 3755 : 		args.ducking = FBitSet( pInvoker->v.flags, FL_DUCKING ) ? true : false;

	mov	eax, DWORD PTR _pInvoker$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN46@SV_Playbac
	mov	DWORD PTR tv238[ebp], 1
	jmp	SHORT $LN47@SV_Playbac
$LN46@SV_Playbac:
	mov	DWORD PTR tv238[ebp], 0
$LN47@SV_Playbac:
	mov	edx, DWORD PTR tv238[ebp]
	mov	DWORD PTR _args$[ebp+44], edx

; 3756 : 
; 3757 : 		// this will be send only for reliable event
; 3758 : 		if( !FBitSet( args.flags, FEVENT_ORIGIN ))

	mov	eax, DWORD PTR _args$[ebp]
	and	eax, 1
	jne	SHORT $LN21@SV_Playbac

; 3759 : 			VectorCopy( pInvoker->v.origin, args.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pInvoker$[ebp]
	mov	edx, DWORD PTR [eax+edx+136]
	mov	DWORD PTR _args$[ebp+ecx+8], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _args$[ebp+ecx+8], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pInvoker$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR _args$[ebp+edx+8], ecx
$LN21@SV_Playbac:

; 3760 : 
; 3761 : 		// this will be send only for reliable event
; 3762 : 		if( !FBitSet( args.flags, FEVENT_ANGLES ))

	mov	edx, DWORD PTR _args$[ebp]
	and	edx, 2
	jne	SHORT $LN22@SV_Playbac

; 3763 : 			VectorCopy( pInvoker->v.angles, args.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _args$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	mov	edx, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _args$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [edx+eax+208]
	mov	DWORD PTR _args$[ebp+ecx+20], eax
$LN22@SV_Playbac:

; 3764 : 	}

	jmp	SHORT $LN20@SV_Playbac
$LN19@SV_Playbac:

; 3765 : 	else
; 3766 : 	{
; 3767 : 		VectorCopy( args.origin, pvspoint );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _args$[ebp+edx+8]
	mov	DWORD PTR _pvspoint$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _args$[ebp+eax+8]
	mov	DWORD PTR _pvspoint$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _args$[ebp+eax+8]
	mov	DWORD PTR _pvspoint$[ebp+ecx], edx

; 3768 : 		args.entindex = 0;

	mov	DWORD PTR _args$[ebp+4], 0

; 3769 : 		invokerIndex = -1;

	mov	DWORD PTR _invokerIndex$[ebp], -1
$LN20@SV_Playbac:

; 3770 : 	}
; 3771 : 
; 3772 : 	if( !FBitSet( flags, FEV_GLOBAL ) && VectorIsNull( pvspoint ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN23@SV_Playbac
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _pvspoint$[ebp+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@SV_Playbac
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _pvspoint$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@SV_Playbac
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _pvspoint$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@SV_Playbac

; 3773 :           {
; 3774 : 		Con_DPrintf( S_ERROR "%s: not a FEV_GLOBAL event missing origin. Ignored.\n", sv.event_precache[eventindex] );

	movzx	edx, WORD PTR _eventindex$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+262340
	push	edx
	push	OFFSET $SG139170
	call	_Con_DPrintf
	add	esp, 8

; 3775 : 		return;

	jmp	$LN3@SV_Playbac
$LN23@SV_Playbac:

; 3776 : 	}
; 3777 : 
; 3778 : 	// check event for some user errors
; 3779 : 	if( FBitSet( flags, FEV_NOTHOST|FEV_HOSTONLY ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 17					; 00000011H
	je	SHORT $LN27@SV_Playbac

; 3780 : 	{
; 3781 : 		if( !SV_ClientFromEdict( pInvoker, true ))

	push	1
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	push	ecx
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@SV_Playbac

; 3782 : 		{
; 3783 : 			const char *ev_name = sv.event_precache[eventindex];

	movzx	edx, WORD PTR _eventindex$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+262340
	mov	DWORD PTR _ev_name$1[ebp], edx

; 3784 : 
; 3785 : 			if( FBitSet( flags, FEV_NOTHOST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN26@SV_Playbac

; 3786 : 			{
; 3787 : 				Con_DPrintf( S_WARN "%s: specified FEV_NOTHOST when invoker not a client\n", ev_name );

	mov	ecx, DWORD PTR _ev_name$1[ebp]
	push	ecx
	push	OFFSET $SG139174
	call	_Con_DPrintf
	add	esp, 8

; 3788 : 				ClearBits( flags, FEV_NOTHOST );

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, -2					; fffffffeH
	mov	DWORD PTR _flags$[ebp], edx
$LN26@SV_Playbac:

; 3789 : 			}
; 3790 : 
; 3791 : 			if( FBitSet( flags, FEV_HOSTONLY ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN27@SV_Playbac

; 3792 : 			{
; 3793 : 				Con_DPrintf( S_WARN "%s: specified FEV_HOSTONLY when invoker not a client\n", ev_name );

	mov	ecx, DWORD PTR _ev_name$1[ebp]
	push	ecx
	push	OFFSET $SG139176
	call	_Con_DPrintf
	add	esp, 8

; 3794 : 				ClearBits( flags, FEV_HOSTONLY );

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, -17				; ffffffefH
	mov	DWORD PTR _flags$[ebp], edx
$LN27@SV_Playbac:

; 3795 : 			}
; 3796 : 		}
; 3797 : 	}
; 3798 : 
; 3799 : 	SetBits( flags, FEV_SERVER );		// it's a server event!

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _flags$[ebp], eax

; 3800 : 	if( delay < 0.0f ) delay = 0.0f;	// fixup negative delays

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jbe	SHORT $LN28@SV_Playbac
	xorps	xmm0, xmm0
	movss	DWORD PTR _delay$[ebp], xmm0
$LN28@SV_Playbac:

; 3801 : 
; 3802 : 	// setup pvs cluster for invoker
; 3803 : 	if( !FBitSet( flags, FEV_GLOBAL ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN29@SV_Playbac

; 3804 : 	{
; 3805 : 		Mod_FatPVS( pvspoint, FATPHS_RADIUS, fatphs, world.fatbytes, false, ( svs.maxclients == 1 ));

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN48@SV_Playbac
	mov	DWORD PTR tv326[ebp], 1
	jmp	SHORT $LN49@SV_Playbac
$LN48@SV_Playbac:
	mov	DWORD PTR tv326[ebp], 0
$LN49@SV_Playbac:
	mov	edx, DWORD PTR tv326[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _world+2596
	push	eax
	push	OFFSET _fatphs
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pvspoint$[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 3806 : 		mask = fatphs; // using the FatPVS like a PHS

	mov	DWORD PTR _mask$[ebp], OFFSET _fatphs
$LN29@SV_Playbac:

; 3807 : 	}
; 3808 : 
; 3809 : 	// process all the clients
; 3810 : 	for( slot = 0, cl = svs.clients; slot < svs.maxclients; slot++, cl++ )

	mov	DWORD PTR _slot$[ebp], 0
	mov	edx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], edx
	jmp	SHORT $LN4@SV_Playbac
$LN2@SV_Playbac:
	mov	eax, DWORD PTR _slot$[ebp]
	add	eax, 1
	mov	DWORD PTR _slot$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_Playbac:
	mov	edx, DWORD PTR _slot$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jge	$LN3@SV_Playbac

; 3811 : 	{
; 3812 : 		if( cl->state != cs_spawned || !cl->edict || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN31@SV_Playbac
	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+264980], 0
	je	SHORT $LN31@SV_Playbac
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN30@SV_Playbac
$LN31@SV_Playbac:

; 3813 : 			continue;

	jmp	SHORT $LN2@SV_Playbac
$LN30@SV_Playbac:

; 3814 : 
; 3815 : 		if( SV_IsValidEdict( pInvoker ) && pInvoker->v.groupinfo && cl->edict->v.groupinfo )

	push	3815					; 00000ee7H
	push	OFFSET $SG139182
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@SV_Playbac
	mov	edx, DWORD PTR _pInvoker$[ebp]
	cmp	DWORD PTR [edx+704], 0
	je	SHORT $LN34@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	cmp	DWORD PTR [ecx+704], 0
	je	SHORT $LN34@SV_Playbac

; 3816 : 		{
; 3817 : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( cl->edict->v.groupinfo, pInvoker->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN33@SV_Playbac
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	mov	edx, DWORD PTR [eax+704]
	and	edx, DWORD PTR [ecx+704]
	jne	SHORT $LN33@SV_Playbac

; 3818 : 				continue;

	jmp	$LN2@SV_Playbac
$LN33@SV_Playbac:

; 3819 : 
; 3820 : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( cl->edict->v.groupinfo, pInvoker->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN34@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, DWORD PTR _pInvoker$[ebp]
	mov	eax, DWORD PTR [ecx+704]
	and	eax, DWORD PTR [edx+704]
	je	SHORT $LN34@SV_Playbac

; 3821 : 				continue;

	jmp	$LN2@SV_Playbac
$LN34@SV_Playbac:

; 3822 : 		}
; 3823 : 
; 3824 : 		if( SV_IsValidEdict( pInvoker ))

	push	3824					; 00000ef0H
	push	OFFSET $SG139186
	mov	ecx, DWORD PTR _pInvoker$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN36@SV_Playbac

; 3825 : 		{
; 3826 : 			if( !SV_CheckClientVisiblity( cl, mask ))

	mov	edx, DWORD PTR _mask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_CheckClientVisiblity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@SV_Playbac

; 3827 : 				continue;

	jmp	$LN2@SV_Playbac
$LN36@SV_Playbac:

; 3828 : 		}
; 3829 : 
; 3830 : 		if( FBitSet( flags, FEV_NOTHOST ) && cl == sv.current_client && FBitSet( cl->flags, FCL_LOCAL_WEAPONS ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	je	SHORT $LN37@SV_Playbac
	mov	edx, DWORD PTR _cl$[ebp]
	cmp	edx, DWORD PTR _sv+40
	jne	SHORT $LN37@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 32					; 00000020H
	je	SHORT $LN37@SV_Playbac

; 3831 : 			continue;	// will be played on client side

	jmp	$LN2@SV_Playbac
$LN37@SV_Playbac:

; 3832 : 
; 3833 : 		if( FBitSet( flags, FEV_HOSTONLY ) && cl->edict != pInvoker )

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN38@SV_Playbac
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	cmp	ecx, DWORD PTR _pInvoker$[ebp]
	je	SHORT $LN38@SV_Playbac

; 3834 : 			continue;	// sending only to invoker

	jmp	$LN2@SV_Playbac
$LN38@SV_Playbac:

; 3835 : 
; 3836 : 		// all checks passed, send the event
; 3837 : 
; 3838 : 		// reliable event
; 3839 : 		if( FBitSet( flags, FEV_RELIABLE ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN39@SV_Playbac

; 3840 : 		{
; 3841 : 			// skipping queue, write direct into reliable datagram
; 3842 : 			SV_PlaybackReliableEvent( &cl->netchan.message, eventindex, delay, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _eventindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_SV_PlaybackReliableEvent
	add	esp, 16					; 00000010H

; 3843 : 			continue;

	jmp	$LN2@SV_Playbac
$LN39@SV_Playbac:

; 3844 : 		}
; 3845 : 
; 3846 : 		// unreliable event (stores in queue)
; 3847 : 		es = &cl->events;

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 281920				; 00044d40H
	mov	DWORD PTR _es$[ebp], eax

; 3848 : 		bestslot = -1;

	mov	DWORD PTR _bestslot$[ebp], -1

; 3849 : 
; 3850 : 		if( FBitSet( flags, FEV_UPDATE ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 8
	je	SHORT $LN6@SV_Playbac

; 3851 : 		{
; 3852 : 			for( j = 0; j < MAX_EVENT_QUEUE; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@SV_Playbac
$LN5@SV_Playbac:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@SV_Playbac:
	cmp	DWORD PTR _j$[ebp], 64			; 00000040H
	jge	SHORT $LN6@SV_Playbac

; 3853 : 			{
; 3854 : 				ei = &es->ei[j];

	imul	eax, DWORD PTR _j$[ebp], 88
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 3855 : 
; 3856 : 				if( ei->index == eventindex && invokerIndex != -1 && invokerIndex == ei->entity_index )

	mov	ecx, DWORD PTR _ei$[ebp]
	movzx	edx, WORD PTR [ecx]
	movzx	eax, WORD PTR _eventindex$[ebp]
	cmp	edx, eax
	jne	SHORT $LN41@SV_Playbac
	cmp	DWORD PTR _invokerIndex$[ebp], -1
	je	SHORT $LN41@SV_Playbac
	mov	ecx, DWORD PTR _ei$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	cmp	DWORD PTR _invokerIndex$[ebp], edx
	jne	SHORT $LN41@SV_Playbac

; 3857 : 				{
; 3858 : 					bestslot = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _bestslot$[ebp], eax

; 3859 : 					break;

	jmp	SHORT $LN6@SV_Playbac
$LN41@SV_Playbac:

; 3860 : 				}
; 3861 : 			}

	jmp	SHORT $LN5@SV_Playbac
$LN6@SV_Playbac:

; 3862 : 		}
; 3863 : 
; 3864 : 		if( bestslot == -1 )

	cmp	DWORD PTR _bestslot$[ebp], -1
	jne	SHORT $LN9@SV_Playbac

; 3865 : 		{
; 3866 : 			for( j = 0; j < MAX_EVENT_QUEUE; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_Playbac
$LN8@SV_Playbac:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@SV_Playbac:
	cmp	DWORD PTR _j$[ebp], 64			; 00000040H
	jge	SHORT $LN9@SV_Playbac

; 3867 : 			{
; 3868 : 				ei = &es->ei[j];

	imul	edx, DWORD PTR _j$[ebp], 88
	add	edx, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], edx

; 3869 : 		
; 3870 : 				if( ei->index == 0 )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN43@SV_Playbac

; 3871 : 				{
; 3872 : 					// found an empty slot
; 3873 : 					bestslot = j;

	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _bestslot$[ebp], edx

; 3874 : 					break;

	jmp	SHORT $LN9@SV_Playbac
$LN43@SV_Playbac:

; 3875 : 				}
; 3876 : 			}

	jmp	SHORT $LN8@SV_Playbac
$LN9@SV_Playbac:

; 3877 : 		}
; 3878 : 				
; 3879 : 		// no slot found for this player, oh well
; 3880 : 		if( bestslot == -1 ) continue;

	cmp	DWORD PTR _bestslot$[ebp], -1
	jne	SHORT $LN44@SV_Playbac
	jmp	$LN2@SV_Playbac
$LN44@SV_Playbac:

; 3881 : 
; 3882 : 		// add event to queue
; 3883 : 		ei->index = eventindex;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	cx, WORD PTR _eventindex$[ebp]
	mov	WORD PTR [eax], cx

; 3884 : 		ei->fire_time = delay;

	mov	edx, DWORD PTR _ei$[ebp]
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 3885 : 		ei->entity_index = invokerIndex;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	cx, WORD PTR _invokerIndex$[ebp]
	mov	WORD PTR [eax+4], cx

; 3886 : 		ei->packet_index = -1;

	or	edx, -1
	mov	eax, DWORD PTR _ei$[ebp]
	mov	WORD PTR [eax+2], dx

; 3887 : 		ei->flags = flags;

	mov	ecx, DWORD PTR _ei$[ebp]
	mov	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [ecx+84], edx

; 3888 : 		ei->args = args;

	mov	edi, DWORD PTR _ei$[ebp]
	add	edi, 12					; 0000000cH
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR _args$[ebp]
	rep movsd

; 3889 : 	}

	jmp	$LN2@SV_Playbac
$LN3@SV_Playbac:

; 3890 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PlaybackEventFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv75 = -36						; size = 4
tv72 = -32						; size = 4
tv130 = -28						; size = 4
_t$ = -24						; size = 4
tv135 = -20						; size = 4
_index$ = -16						; size = 4
_ed$ = -12						; size = 4
_desc$ = -8						; size = 4
_e$ = -4						; size = 4
_pStartEdict$ = 8					; size = 4
_pszField$ = 12						; size = 4
_pszValue$ = 16						; size = 4
_SV_FindEntityByString PROC

; 1516 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1517 : 	int		index = 0, e = 0;

	mov	DWORD PTR _index$[ebp], 0
	mov	DWORD PTR _e$[ebp], 0

; 1518 : 	TYPEDESCRIPTION	*desc = NULL;

	mov	DWORD PTR _desc$[ebp], 0

; 1519 : 	edict_t		*ed;
; 1520 : 	const char	*t;
; 1521 : 
; 1522 : 	if( !COM_CheckString( pszValue ))

	mov	eax, DWORD PTR _pszValue$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@SV_FindEnt

; 1523 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@SV_FindEnt
$LN9@SV_FindEnt:

; 1524 : 
; 1525 : 	if( pStartEdict ) e = NUM_FOR_EDICT( pStartEdict );

	cmp	DWORD PTR _pStartEdict$[ebp], 0
	je	SHORT $LN2@SV_FindEnt
	mov	eax, DWORD PTR _pStartEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _e$[ebp], eax
$LN2@SV_FindEnt:

; 1526 : 
; 1527 : 	while(( desc = SV_GetEntvarsDescirption( index++ )) != NULL )

	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	push	eax
	call	_SV_GetEntvarsDescirption
	add	esp, 4
	mov	DWORD PTR _desc$[ebp], eax
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN3@SV_FindEnt

; 1528 : 	{
; 1529 : 		if( !Q_strcmp( pszField, desc->fieldName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pszField$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@SV_FindEnt

; 1530 : 			break;

	jmp	SHORT $LN3@SV_FindEnt
$LN11@SV_FindEnt:

; 1531 : 	}

	jmp	SHORT $LN2@SV_FindEnt
$LN3@SV_FindEnt:

; 1532 : 
; 1533 : 	if( desc == NULL )

	cmp	DWORD PTR _desc$[ebp], 0
	jne	SHORT $LN12@SV_FindEnt

; 1534 : 	{
; 1535 : 		Con_Printf( S_ERROR "FindEntityByString: field %s not a string\n", pszField );

	mov	eax, DWORD PTR _pszField$[ebp]
	push	eax
	push	OFFSET $SG137932
	call	_Con_Printf
	add	esp, 8

; 1536 : 		return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
	jmp	$LN1@SV_FindEnt
$LN12@SV_FindEnt:

; 1537 : 	}
; 1538 : 	
; 1539 : 	for( e++; e < svgame.numEntities; e++ )

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1
	mov	DWORD PTR _e$[ebp], ecx
	jmp	SHORT $LN6@SV_FindEnt
$LN4@SV_FindEnt:
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 1
	mov	DWORD PTR _e$[ebp], edx
$LN6@SV_FindEnt:
	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN5@SV_FindEnt

; 1540 : 	{
; 1541 : 		ed = EDICT_NUM( e );

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ed$[ebp], eax

; 1542 : 		if( !SV_IsValidEdict( ed )) continue;

	push	1542					; 00000606H
	push	OFFSET $SG137934
	mov	edx, DWORD PTR _ed$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@SV_FindEnt
	jmp	SHORT $LN4@SV_FindEnt
$LN13@SV_FindEnt:

; 1543 : 
; 1544 : 		if( e <= svs.maxclients && !SV_ClientFromEdict( ed, ( svs.maxclients != 1 )))

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN14@SV_FindEnt
	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN19@SV_FindEnt
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN20@SV_FindEnt
$LN19@SV_FindEnt:
	mov	DWORD PTR tv130[ebp], 0
$LN20@SV_FindEnt:
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	edx, DWORD PTR _ed$[ebp]
	push	edx
	call	_SV_ClientFromEdict
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@SV_FindEnt

; 1545 : 			continue;

	jmp	SHORT $LN4@SV_FindEnt
$LN14@SV_FindEnt:

; 1546 : 
; 1547 : 		switch( desc->fieldType )

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv135[ebp], ecx
	cmp	DWORD PTR tv135[ebp], 1
	je	SHORT $LN15@SV_FindEnt
	cmp	DWORD PTR tv135[ebp], 15		; 0000000fH
	jle	SHORT $LN7@SV_FindEnt
	cmp	DWORD PTR tv135[ebp], 17		; 00000011H
	jle	SHORT $LN15@SV_FindEnt
	jmp	SHORT $LN7@SV_FindEnt
$LN15@SV_FindEnt:

; 1548 : 		{
; 1549 : 		case FIELD_STRING:
; 1550 : 		case FIELD_MODELNAME:
; 1551 : 		case FIELD_SOUNDNAME:
; 1552 : 			t = STRING( *(string_t *)&((byte *)&ed->v)[desc->fieldOffset] );

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+eax+128]
	push	edx
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _t$[ebp], eax

; 1553 : 			if( t != NULL && t != svgame.globals->pStringBase )

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN7@SV_FindEnt
	mov	eax, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR _t$[ebp]
	cmp	ecx, DWORD PTR [eax+152]
	je	SHORT $LN7@SV_FindEnt

; 1554 : 			{
; 1555 : 				if( !Q_strcmp( t, pszValue ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _pszValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@SV_FindEnt

; 1556 : 					return ed;

	mov	eax, DWORD PTR _ed$[ebp]
	jmp	SHORT $LN1@SV_FindEnt
$LN7@SV_FindEnt:

; 1557 : 			}
; 1558 : 			break;
; 1559 : 		}
; 1560 : 	}

	jmp	$LN4@SV_FindEnt
$LN5@SV_FindEnt:

; 1561 : 
; 1562 : 	return svgame.edicts;

	mov	eax, DWORD PTR _svgame+7928
$LN1@SV_FindEnt:

; 1563 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindEntityByString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv171 = -8						; size = 4
_i$ = -4						; size = 4
_e$ = 8							; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_relink$ = 20						; size = 4
_SV_SetMinMaxSize PROC

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 191  : 	int	i;
; 192  : 
; 193  : 	if( !SV_IsValidEdict( e ))

	push	193					; 000000c1H
	push	OFFSET $SG137342
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_SetMinM

; 194  : 		return;

	jmp	$LN8@SV_SetMinM
$LN5@SV_SetMinM:

; 195  : 
; 196  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SetMinM
$LN2@SV_SetMinM:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_SetMinM:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_SetMinM

; 197  : 	{
; 198  : 		if( mins[i] > maxs[i] )

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	comiss	xmm0, DWORD PTR [esi+ecx*4]
	jbe	SHORT $LN6@SV_SetMinM

; 199  : 		{
; 200  : 			Con_Printf( S_ERROR "%s[%i] has backwards mins/maxs\n", SV_ClassName( e ), NUM_FOR_EDICT( e ));

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	push	OFFSET $SG137344
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 201  : 			if( relink ) SV_LinkEdict( e, false ); // just relink edict and exit

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN7@SV_SetMinM
	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN7@SV_SetMinM:

; 202  : 			return;

	jmp	$LN8@SV_SetMinM
$LN6@SV_SetMinM:

; 203  : 		}
; 204  : 	}

	jmp	SHORT $LN2@SV_SetMinM
$LN3@SV_SetMinM:

; 205  : 
; 206  : 	VectorCopy( mins, e->v.mins );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+348], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+348], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+348], ecx

; 207  : 	VectorCopy( maxs, e->v.maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+360], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+360], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+360], edx

; 208  : 	VectorSubtract( maxs, mins, e->v.size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [edx+ecx+372], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [ecx+eax+372], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv171[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR tv171[ebp]
	movss	DWORD PTR [eax+edx+372], xmm0

; 209  : 	if( relink ) SV_LinkEdict( e, false );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN8@SV_SetMinM
	push	0
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_LinkEdict
	add	esp, 8
$LN8@SV_SetMinM:

; 210  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetMinMaxSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv72 = -8						; size = 4
_n$ = -4						; size = 4
_e$ = 8							; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_SV_CheckEdict PROC

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 48   : 	int	n;
; 49   : 
; 50   : 	if( !e ) return false; // may be NULL

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN2@SV_CheckEd
	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckEd
$LN2@SV_CheckEd:

; 51   : 
; 52   : 	n = ((int)((edict_t *)(e) - svgame.edicts));

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _n$[ebp], eax

; 53   : 
; 54   : 	if(( n >= 0 ) && ( n < GI->max_edicts ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN3@SV_CheckEd
	mov	edx, DWORD PTR _SI+768
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+1656]
	jge	SHORT $LN3@SV_CheckEd

; 55   : 		return !e->free;

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@SV_CheckEd
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN6@SV_CheckEd
$LN5@SV_CheckEd:
	mov	DWORD PTR tv72[ebp], 0
$LN6@SV_CheckEd:
	mov	eax, DWORD PTR tv72[ebp]
	jmp	SHORT $LN1@SV_CheckEd
$LN3@SV_CheckEd:

; 56   : 	Con_Printf( "bad entity %i (called at %s:%i)\n", n, file, line );

	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET $SG137252
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 57   : 
; 58   : 	return false;	

	xor	eax, eax
$LN1@SV_CheckEd:

; 59   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_trace$ = 8						; size = 4
_SV_CopyTraceToGlobal PROC

; 220  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 221  : 	svgame.globals->trace_allsolid = trace->allsolid;

	mov	eax, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _svgame+19236
	movss	DWORD PTR [ecx+76], xmm0

; 222  : 	svgame.globals->trace_startsolid = trace->startsolid;

	mov	edx, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _svgame+19236
	movss	DWORD PTR [eax+80], xmm0

; 223  : 	svgame.globals->trace_fraction = trace->fraction;

	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+84], eax

; 224  : 	svgame.globals->trace_plane_dist = trace->plane.dist;

	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+112], eax

; 225  : 	svgame.globals->trace_inopen = trace->inopen;

	mov	ecx, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _svgame+19236
	movss	DWORD PTR [edx+120], xmm0

; 226  : 	svgame.globals->trace_inwater = trace->inwater;

	mov	eax, DWORD PTR _trace$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _svgame+19236
	movss	DWORD PTR [ecx+124], xmm0

; 227  : 	VectorCopy( trace->endpos, svgame.globals->trace_endpos );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _svgame+19236
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [ecx+edx+88], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _svgame+19236
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR [eax+edx+88], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _svgame+19236
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [esi+edx+20]
	mov	DWORD PTR [ecx+eax+88], edx

; 228  : 	VectorCopy( trace->plane.normal, svgame.globals->trace_plane_normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+19236
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+32]
	mov	DWORD PTR [edx+eax+100], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+19236
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [esi+edx+32]
	mov	DWORD PTR [ecx+eax+100], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+19236
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+ecx+100], eax

; 229  : 	svgame.globals->trace_hitgroup = trace->hitgroup;

	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+128], eax

; 230  : 	svgame.globals->trace_flags = 0; // g-cont: always reset config flags when trace is finished

	mov	ecx, DWORD PTR _svgame+19236
	mov	DWORD PTR [ecx+132], 0

; 231  : 
; 232  : 	if( SV_IsValidEdict( trace->ent ))

	push	232					; 000000e8H
	push	OFFSET $SG137352
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@SV_CopyTra

; 233  : 		svgame.globals->trace_ent = trace->ent;

	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+116], eax
	jmp	SHORT $LN3@SV_CopyTra
$LN2@SV_CopyTra:

; 234  : 	else svgame.globals->trace_ent = svgame.edicts;

	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR _svgame+7928
	mov	DWORD PTR [ecx+116], edx
$LN3@SV_CopyTra:

; 235  : }

	pop	esi
	pop	ebp
	ret	0
_SV_CopyTraceToGlobal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
_SV_FreePrivateData PROC

; 938  : {

	push	ebp
	mov	ebp, esp

; 939  : 	if( !pEdict || !pEdict->pvPrivateData )

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN3@SV_FreePri
	mov	eax, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN2@SV_FreePri
$LN3@SV_FreePri:

; 940  : 		return;

	jmp	SHORT $LN1@SV_FreePri
$LN2@SV_FreePri:

; 941  : 
; 942  : 	// NOTE: new interface can be missing
; 943  : 	if( svgame.dllFuncs2.pfnOnFreeEntPrivateData != NULL )

	cmp	DWORD PTR _svgame+19440, 0
	je	SHORT $LN4@SV_FreePri

; 944  : 		svgame.dllFuncs2.pfnOnFreeEntPrivateData( pEdict );

	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19440
	add	esp, 4
$LN4@SV_FreePri:

; 945  : 
; 946  : 	if( Mem_IsAllocatedExt( svgame.mempool, pEdict->pvPrivateData ))

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	mov	ecx, DWORD PTR _svgame+19556
	push	ecx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@SV_FreePri

; 947  : 		Mem_Free( pEdict->pvPrivateData );

	push	947					; 000003b3H
	push	OFFSET $SG137670
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@SV_FreePri:

; 948  : 
; 949  : 	pEdict->pvPrivateData = NULL;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [ecx+124], 0
$LN1@SV_FreePri:

; 950  : }

	pop	ebp
	ret	0
_SV_FreePrivateData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_SV_ClassName PROC

; 1188 : {

	push	ebp
	mov	ebp, esp

; 1189 : 	if( !e ) return "(null)";

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN2@SV_ClassNa
	mov	eax, OFFSET $SG137751
	jmp	SHORT $LN1@SV_ClassNa
$LN2@SV_ClassNa:

; 1190 : 	if( e->free ) return "freed";

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@SV_ClassNa
	mov	eax, OFFSET $SG137753
	jmp	SHORT $LN1@SV_ClassNa
$LN3@SV_ClassNa:

; 1191 : 	return STRING( e->v.classname );

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	call	_SV_GetString
	add	esp, 4
$LN1@SV_ClassNa:

; 1192 : }

	pop	ebp
	ret	0
_SV_ClassName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_pEdict$ = 8						; size = 4
_SV_InitEdict PROC

; 960  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 961  : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN3@SV_InitEdi
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@SV_InitEdi
$LN3@SV_InitEdi:
	mov	DWORD PTR tv69[ebp], 0
$LN4@SV_InitEdi:
	push	0
	push	961					; 000003c1H
	push	OFFSET $SG137677
	push	OFFSET $SG137678
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 962  : 
; 963  : 	SV_FreePrivateData( pEdict );

	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_FreePrivateData
	add	esp, 4

; 964  : 	memset( &pEdict->v, 0, sizeof( entvars_t ));

	push	676					; 000002a4H
	push	0
	mov	edx, DWORD PTR _pEdict$[ebp]
	add	edx, 128				; 00000080H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 965  : 	pEdict->v.pContainingEntity = pEdict;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+648], ecx

; 966  : 	pEdict->v.controller[0] = 0x7F;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [ecx+eax+444], 127		; 0000007fH

; 967  : 	pEdict->v.controller[1] = 0x7F;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [eax+edx+444], 127		; 0000007fH

; 968  : 	pEdict->v.controller[2] = 0x7F;

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [edx+ecx+444], 127		; 0000007fH

; 969  : 	pEdict->v.controller[3] = 0x7F;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	BYTE PTR [edx+ecx+444], 127		; 0000007fH

; 970  : 	pEdict->free = false;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax], 0

; 971  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_pEdict$ = 8						; size = 4
_SV_FreeEdict PROC

; 981  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 982  : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN4@SV_FreeEdi
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN5@SV_FreeEdi
$LN4@SV_FreeEdi:
	mov	DWORD PTR tv69[ebp], 0
$LN5@SV_FreeEdi:
	push	0
	push	982					; 000003d6H
	push	OFFSET $SG137684
	push	OFFSET $SG137685
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 983  : 	if( pEdict->free ) return;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@SV_FreeEdi
	jmp	$LN1@SV_FreeEdi
$LN2@SV_FreeEdi:

; 984  : 
; 985  : 	// unlink from world
; 986  : 	SV_UnlinkEdict( pEdict );

	mov	edx, DWORD PTR _pEdict$[ebp]
	push	edx
	call	_SV_UnlinkEdict
	add	esp, 4

; 987  : 
; 988  : 	SV_FreePrivateData( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_SV_FreePrivateData
	add	esp, 4

; 989  : 
; 990  : 	// mark edict as freed
; 991  : 	pEdict->freetime = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	ecx, DWORD PTR _pEdict$[ebp]
	movss	DWORD PTR [ecx+120], xmm0

; 992  : 	pEdict->serialnumber++; // invalidate EHANDLE's

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 993  : 	pEdict->v.solid = SOLID_NOT;

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [edx+396], 0

; 994  : 	pEdict->v.flags = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+548], 0

; 995  : 	pEdict->v.model = 0;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [ecx+312], 0

; 996  : 	pEdict->v.takedamage = 0;

	mov	edx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+492], xmm0

; 997  : 	pEdict->v.modelindex = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+308], 0

; 998  : 	pEdict->v.nextthink = -1;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+388], xmm0

; 999  : 	pEdict->v.colormap = 0;

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [edx+552], 0

; 1000 : 	pEdict->v.frame = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+432], xmm0

; 1001 : 	pEdict->v.scale = 0;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+452], xmm0

; 1002 : 	pEdict->v.gravity = 0;

	mov	edx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+412], xmm0

; 1003 : 	pEdict->v.skin = 0;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax+400], 0

; 1004 : 
; 1005 : 	VectorClear( pEdict->v.angles );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+208], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+208], xmm0

; 1006 : 	VectorClear( pEdict->v.origin );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+136], xmm0

; 1007 : 	pEdict->free = true;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR [eax], 1
$LN1@SV_FreeEdi:

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FreeEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_e$ = -4						; size = 4
_SV_AllocEdict PROC

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1019 : 	edict_t	*e;
; 1020 : 	int	i;
; 1021 : 
; 1022 : 	for( i = svs.maxclients + 1; i < svgame.numEntities; i++ )

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@SV_AllocEd
$LN2@SV_AllocEd:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_AllocEd:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _svgame+7932
	jge	SHORT $LN3@SV_AllocEd

; 1023 : 	{
; 1024 : 		e = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 1025 : 		// the first couple seconds of server time can involve a lot of
; 1026 : 		// freeing and allocating, so relax the replacement policy
; 1027 : 		if( e->free && ( e->freetime < 2.0f || ( sv.time - e->freetime ) > 0.5f ))

	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN5@SV_AllocEd
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR [edx+120]
	ja	SHORT $LN6@SV_AllocEd
	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+120]
	movsd	xmm1, QWORD PTR _sv+16
	subsd	xmm1, xmm0
	comisd	xmm1, QWORD PTR __real@3fe0000000000000
	jbe	SHORT $LN5@SV_AllocEd
$LN6@SV_AllocEd:

; 1028 : 		{
; 1029 : 			SV_InitEdict( e );

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_InitEdict
	add	esp, 4

; 1030 : 			return e;

	mov	eax, DWORD PTR _e$[ebp]
	jmp	SHORT $LN1@SV_AllocEd
$LN5@SV_AllocEd:

; 1031 : 		}
; 1032 : 	}

	jmp	SHORT $LN2@SV_AllocEd
$LN3@SV_AllocEd:

; 1033 : 
; 1034 : 	if( i >= GI->max_edicts )

	mov	edx, DWORD PTR _SI+768
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+1656]
	jl	SHORT $LN7@SV_AllocEd

; 1035 : 		Host_Error( "ED_AllocEdict: no free edicts (max is %d)\n", GI->max_edicts );

	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [ecx+1656]
	push	edx
	push	OFFSET $SG137697
	call	_Host_Error
	add	esp, 8
$LN7@SV_AllocEd:

; 1036 : 
; 1037 : 	svgame.numEntities++;

	mov	eax, DWORD PTR _svgame+7932
	add	eax, 1
	mov	DWORD PTR _svgame+7932, eax

; 1038 : 	e = EDICT_NUM( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 1039 : 	SV_InitEdict( e );

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_SV_InitEdict
	add	esp, 4

; 1040 : 
; 1041 : 	return e;

	mov	eax, DWORD PTR _e$[ebp]
$LN1@SV_AllocEd:

; 1042 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllocEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_ent$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_FreeEdicts PROC

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1139 : 	int	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1140 : 	edict_t	*ent;
; 1141 : 
; 1142 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_FreeEdi
$LN2@SV_FreeEdi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_FreeEdi:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svgame+7932
	jge	SHORT $LN1@SV_FreeEdi

; 1143 : 	{
; 1144 : 		ent = EDICT_NUM( i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1145 : 		if( ent->free ) continue;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SV_FreeEdi
	jmp	SHORT $LN2@SV_FreeEdi
$LN5@SV_FreeEdi:

; 1146 : 		SV_FreeEdict( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_FreeEdict
	add	esp, 4

; 1147 : 	}

	jmp	SHORT $LN2@SV_FreeEdi
$LN1@SV_FreeEdi:

; 1148 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FreeEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_SV_UnloadProgs PROC

; 4739 : {

	push	ebp
	mov	ebp, esp

; 4740 : 	if( !svgame.hInstance )

	cmp	DWORD PTR _svgame+7920, 0
	jne	SHORT $LN2@SV_UnloadP

; 4741 : 		return;

	jmp	$LN1@SV_UnloadP
$LN2@SV_UnloadP:

; 4742 : 
; 4743 : 	SV_DeactivateServer ();

	call	_SV_DeactivateServer

; 4744 : 	Delta_Shutdown ();

	call	_Delta_Shutdown

; 4745 : 	Mod_ClearUserData ();

	call	_Mod_ClearUserData

; 4746 : 
; 4747 : 	Mem_FreePool( &svgame.stringspool );

	push	4747					; 0000128bH
	push	OFFSET $SG139551
	push	OFFSET _svgame+19560
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 4748 : 
; 4749 : 	if( svgame.dllFuncs2.pfnGameShutdown != NULL )

	cmp	DWORD PTR _svgame+19444, 0
	je	SHORT $LN3@SV_UnloadP

; 4750 : 		svgame.dllFuncs2.pfnGameShutdown ();

	call	DWORD PTR _svgame+19444
$LN3@SV_UnloadP:

; 4751 : 
; 4752 : 	// now we can unload cvars
; 4753 : 	Cvar_FullSet( "host_gameloaded", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG139553
	push	OFFSET $SG139554
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4754 : 	Cvar_FullSet( "sv_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG139555
	push	OFFSET $SG139556
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4755 : 
; 4756 : 	// free entity baselines
; 4757 : 	Z_Free( svs.static_entities );

	cmp	DWORD PTR _svs+33364, 0
	je	SHORT $LN4@SV_UnloadP
	push	4757					; 00001295H
	push	OFFSET $SG139558
	mov	eax, DWORD PTR _svs+33364
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@SV_UnloadP:

; 4758 : 	Z_Free( svs.baselines );

	cmp	DWORD PTR _svs+33360, 0
	je	SHORT $LN5@SV_UnloadP
	push	4758					; 00001296H
	push	OFFSET $SG139560
	mov	ecx, DWORD PTR _svs+33360
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@SV_UnloadP:

; 4759 : 	svs.baselines = NULL;

	mov	DWORD PTR _svs+33360, 0

; 4760 : 
; 4761 : 	// remove server cmds
; 4762 : 	SV_KillOperatorCommands();

	call	_SV_KillOperatorCommands

; 4763 : 
; 4764 : 	// must unlink all game cvars,
; 4765 : 	// before pointers on them will be lost...
; 4766 : 	Cvar_Unlink( FCVAR_EXTDLL );

	push	8
	call	_Cvar_Unlink
	add	esp, 4

; 4767 : 	Cmd_Unlink( CMD_SERVERDLL );

	push	1
	call	_Cmd_Unlink
	add	esp, 4

; 4768 : 
; 4769 : 	Mod_ResetStudioAPI ();

	call	_Mod_ResetStudioAPI

; 4770 : 
; 4771 : 	COM_FreeLibrary( svgame.hInstance );

	mov	edx, DWORD PTR _svgame+7920
	push	edx
	call	_COM_FreeLibrary
	add	esp, 4

; 4772 : 	Mem_FreePool( &svgame.mempool );

	push	4772					; 000012a4H
	push	OFFSET $SG139561
	push	OFFSET _svgame+19556
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 4773 : 	memset( &svgame, 0, sizeof( svgame ));

	push	19564					; 00004c6cH
	push	0
	push	OFFSET _svgame
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@SV_UnloadP:

; 4774 : }

	pop	ebp
	ret	0
_SV_UnloadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_e$ = -12						; size = 4
_i$ = -8						; size = 4
_version$ = -4						; size = 4
_name$ = 8						; size = 4
_SV_LoadProgs PROC

; 4777 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4778 : 	int			i, version;
; 4779 : 	static APIFUNCTION		GetEntityAPI;
; 4780 : 	static APIFUNCTION2		GetEntityAPI2;
; 4781 : 	static GIVEFNPTRSTODLL	GiveFnptrsToDll;
; 4782 : 	static NEW_DLL_FUNCTIONS_FN	GiveNewDllFuncs;
; 4783 : 	static enginefuncs_t	gpEngfuncs;
; 4784 : 	static globalvars_t		gpGlobals;
; 4785 : 	static playermove_t		gpMove;
; 4786 : 	edict_t			*e;
; 4787 : 
; 4788 : 	if( svgame.hInstance ) SV_UnloadProgs();

	cmp	DWORD PTR _svgame+7920, 0
	je	SHORT $LN5@SV_LoadPro
	call	_SV_UnloadProgs
$LN5@SV_LoadPro:

; 4789 : 
; 4790 : 	// fill it in
; 4791 : 	svgame.pmove = &gpMove;

	mov	DWORD PTR _svgame+8224, OFFSET ?gpMove@?1??SV_LoadProgs@@9@9

; 4792 : 	svgame.globals = &gpGlobals;

	mov	DWORD PTR _svgame+19236, OFFSET ?gpGlobals@?1??SV_LoadProgs@@9@9

; 4793 : 	svgame.mempool = Mem_AllocPool( "Server Edicts Zone" );

	push	4793					; 000012b9H
	push	OFFSET $SG139597
	push	OFFSET $SG139598
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _svgame+19556, eax

; 4794 : 	svgame.hInstance = COM_LoadLibrary( name, true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _svgame+7920, eax

; 4795 : 	if( !svgame.hInstance ) return false;

	cmp	DWORD PTR _svgame+7920, 0
	jne	SHORT $LN6@SV_LoadPro
	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN6@SV_LoadPro:

; 4796 : 
; 4797 : 	// make sure what new dll functions is cleared
; 4798 : 	memset( &svgame.dllFuncs2, 0, sizeof( svgame.dllFuncs2 ));

	push	20					; 00000014H
	push	0
	push	OFFSET _svgame+19440
	call	_memset
	add	esp, 12					; 0000000cH

; 4799 : 
; 4800 : 	// make sure what physic functions is cleared
; 4801 : 	memset( &svgame.physFuncs, 0, sizeof( svgame.physFuncs ));

	push	96					; 00000060H
	push	0
	push	OFFSET _svgame+19460
	call	_memset
	add	esp, 12					; 0000000cH

; 4802 : 
; 4803 : 	// make local copy of engfuncs to prevent overwrite it with bots.dll
; 4804 : 	memcpy( &gpEngfuncs, &gEngfuncs, sizeof( gpEngfuncs ));

	push	632					; 00000278H
	push	OFFSET _gEngfuncs
	push	OFFSET ?gpEngfuncs@?1??SV_LoadProgs@@9@9
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4805 : 
; 4806 : 	GetEntityAPI = (APIFUNCTION)COM_GetProcAddress( svgame.hInstance, "GetEntityAPI" );

	push	OFFSET $SG139600
	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9, eax

; 4807 : 	GetEntityAPI2 = (APIFUNCTION2)COM_GetProcAddress( svgame.hInstance, "GetEntityAPI2" );

	push	OFFSET $SG139601
	mov	edx, DWORD PTR _svgame+7920
	push	edx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9, eax

; 4808 : 	GiveNewDllFuncs = (NEW_DLL_FUNCTIONS_FN)COM_GetProcAddress( svgame.hInstance, "GetNewDLLFunctions" );

	push	OFFSET $SG139602
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9, eax

; 4809 : 
; 4810 : 	if( !GetEntityAPI && !GetEntityAPI2 )

	cmp	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9, 0
	jne	SHORT $LN7@SV_LoadPro
	cmp	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9, 0
	jne	SHORT $LN7@SV_LoadPro

; 4811 : 	{
; 4812 : 		COM_FreeLibrary( svgame.hInstance );

	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4

; 4813 :          		Con_Printf( S_ERROR "SV_LoadProgs: failed to get address of GetEntityAPI proc\n" );

	push	OFFSET $SG139604
	call	_Con_Printf
	add	esp, 4

; 4814 : 		svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4815 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN7@SV_LoadPro:

; 4816 : 	}
; 4817 : 
; 4818 : 	GiveFnptrsToDll = (GIVEFNPTRSTODLL)COM_GetProcAddress( svgame.hInstance, "GiveFnptrsToDll" );

	push	OFFSET $SG139605
	mov	edx, DWORD PTR _svgame+7920
	push	edx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9, eax

; 4819 : 
; 4820 : 	if( !GiveFnptrsToDll )

	cmp	DWORD PTR ?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9, 0
	jne	SHORT $LN8@SV_LoadPro

; 4821 : 	{
; 4822 : 		COM_FreeLibrary( svgame.hInstance );

	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4823 : 		Con_Printf( S_ERROR "SV_LoadProgs: failed to get address of GiveFnptrsToDll proc\n" );

	push	OFFSET $SG139607
	call	_Con_Printf
	add	esp, 4

; 4824 : 		svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4825 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN8@SV_LoadPro:

; 4826 : 	}
; 4827 : 
; 4828 : 	GiveFnptrsToDll( &gpEngfuncs, svgame.globals );

	mov	ecx, DWORD PTR _svgame+19236
	push	ecx
	push	OFFSET ?gpEngfuncs@?1??SV_LoadProgs@@9@9
	call	DWORD PTR ?GiveFnptrsToDll@?1??SV_LoadProgs@@9@9

; 4829 : 
; 4830 : 	// get extended callbacks
; 4831 : 	if( GiveNewDllFuncs )

	cmp	DWORD PTR ?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9, 0
	je	SHORT $LN9@SV_LoadPro

; 4832 : 	{
; 4833 : 		version = NEW_DLL_FUNCTIONS_VERSION;

	mov	DWORD PTR _version$[ebp], 1

; 4834 : 	
; 4835 : 		if( !GiveNewDllFuncs( &svgame.dllFuncs2, &version ))

	lea	edx, DWORD PTR _version$[ebp]
	push	edx
	push	OFFSET _svgame+19440
	call	DWORD PTR ?GiveNewDllFuncs@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_LoadPro

; 4836 : 		{
; 4837 : 			if( version != NEW_DLL_FUNCTIONS_VERSION )

	cmp	DWORD PTR _version$[ebp], 1
	je	SHORT $LN11@SV_LoadPro

; 4838 : 				Con_Printf( S_WARN "SV_LoadProgs: new interface version %i should be %i\n", NEW_DLL_FUNCTIONS_VERSION, version );

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	1
	push	OFFSET $SG139611
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN11@SV_LoadPro:

; 4839 : 			memset( &svgame.dllFuncs2, 0, sizeof( svgame.dllFuncs2 ));

	push	20					; 00000014H
	push	0
	push	OFFSET _svgame+19440
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@SV_LoadPro:

; 4840 : 		}
; 4841 : 	}
; 4842 : 
; 4843 : 	version = INTERFACE_VERSION;

	mov	DWORD PTR _version$[ebp], 140		; 0000008cH

; 4844 : 
; 4845 : 	if( GetEntityAPI2 )

	cmp	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9, 0
	je	$LN12@SV_LoadPro

; 4846 : 	{
; 4847 : 		if( !GetEntityAPI2( &svgame.dllFuncs, &version ))

	lea	ecx, DWORD PTR _version$[ebp]
	push	ecx
	push	OFFSET _svgame+19240
	call	DWORD PTR ?GetEntityAPI2@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@SV_LoadPro

; 4848 : 		{
; 4849 : 			Con_Printf( S_WARN "SV_LoadProgs: interface version %i should be %i\n", INTERFACE_VERSION, version );

	mov	edx, DWORD PTR _version$[ebp]
	push	edx
	push	140					; 0000008cH
	push	OFFSET $SG139616
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 4850 : 
; 4851 : 			// fallback to old API
; 4852 : 			if( !GetEntityAPI( &svgame.dllFuncs, version ))

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET _svgame+19240
	call	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@SV_LoadPro

; 4853 : 			{
; 4854 : 				COM_FreeLibrary( svgame.hInstance );

	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4

; 4855 : 				Con_Printf( S_ERROR "SV_LoadProgs: couldn't get entity API\n" );

	push	OFFSET $SG139618
	call	_Con_Printf
	add	esp, 4

; 4856 : 				svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4857 : 				return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN16@SV_LoadPro:

; 4858 : 			}
; 4859 : 		}

	jmp	SHORT $LN15@SV_LoadPro
$LN14@SV_LoadPro:

; 4860 : 		else Con_Reportf( "SV_LoadProgs: ^2initailized extended EntityAPI ^7ver. %i\n", version );

	mov	edx, DWORD PTR _version$[ebp]
	push	edx
	push	OFFSET $SG139619
	call	_Con_Reportf
	add	esp, 8
$LN15@SV_LoadPro:

; 4861 : 	}

	jmp	SHORT $LN13@SV_LoadPro
$LN12@SV_LoadPro:

; 4862 : 	else if( !GetEntityAPI( &svgame.dllFuncs, version ))

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET _svgame+19240
	call	DWORD PTR ?GetEntityAPI@?1??SV_LoadProgs@@9@9
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@SV_LoadPro

; 4863 : 	{
; 4864 : 		COM_FreeLibrary( svgame.hInstance );

	mov	ecx, DWORD PTR _svgame+7920
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4

; 4865 : 		Con_Printf( S_ERROR "SV_LoadProgs: couldn't get entity API\n" );

	push	OFFSET $SG139621
	call	_Con_Printf
	add	esp, 4

; 4866 : 		svgame.hInstance = NULL;

	mov	DWORD PTR _svgame+7920, 0

; 4867 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadPro
$LN13@SV_LoadPro:

; 4868 : 	}
; 4869 : 
; 4870 : 	SV_InitOperatorCommands();

	call	_SV_InitOperatorCommands

; 4871 : 	Mod_InitStudioAPI();

	call	_Mod_InitStudioAPI

; 4872 : 
; 4873 : 	if( !SV_InitPhysicsAPI( ))

	call	_SV_InitPhysicsAPI
	test	eax, eax
	jne	SHORT $LN18@SV_LoadPro

; 4874 : 	{
; 4875 : 		Con_Printf( S_WARN "SV_LoadProgs: couldn't get physics API\n" );

	push	OFFSET $SG139623
	call	_Con_Printf
	add	esp, 4
$LN18@SV_LoadPro:

; 4876 : 	}
; 4877 : 
; 4878 : 	// grab function SV_SaveGameComment
; 4879 : 	SV_InitSaveRestore ();

	call	_SV_InitSaveRestore

; 4880 : 
; 4881 : 	svgame.globals->pStringBase = ""; // setup string base

	mov	edx, DWORD PTR _svgame+19236
	mov	DWORD PTR [edx+152], OFFSET $SG139624

; 4882 : 
; 4883 : 	svgame.globals->maxEntities = GI->max_edicts;

	mov	eax, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [ecx+1656]
	mov	DWORD PTR [eax+148], edx

; 4884 : 	svgame.globals->maxClients = svs.maxclients;

	mov	eax, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR _svs+16
	mov	DWORD PTR [eax+144], ecx

; 4885 : 	svgame.edicts = Mem_Calloc( svgame.mempool, sizeof( edict_t ) * GI->max_edicts );

	push	4885					; 00001315H
	push	OFFSET $SG139625
	push	1
	mov	edx, DWORD PTR _SI+768
	imul	eax, DWORD PTR [edx+1656], 804
	push	eax
	mov	ecx, DWORD PTR _svgame+19556
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _svgame+7928, eax

; 4886 : 	svs.static_entities = Z_Calloc( sizeof( entity_state_t ) * MAX_STATIC_ENTITIES );

	push	4886					; 00001316H
	push	OFFSET $SG139626
	push	1
	push	1052640					; 00100fe0H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _svs+33364, eax

; 4887 : 	svs.baselines = Z_Calloc( sizeof( entity_state_t ) * GI->max_edicts );

	push	4887					; 00001317H
	push	OFFSET $SG139627
	push	1
	mov	eax, DWORD PTR _SI+768
	imul	ecx, DWORD PTR [eax+1656], 340
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _svs+33360, eax

; 4888 : 	svgame.numEntities = svs.maxclients + 1; // clients + world

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	DWORD PTR _svgame+7932, eax

; 4889 : 
; 4890 : 	for( i = 0, e = svgame.edicts; i < GI->max_edicts; i++, e++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svgame+7928
	mov	DWORD PTR _e$[ebp], ecx
	jmp	SHORT $LN4@SV_LoadPro
$LN2@SV_LoadPro:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 804				; 00000324H
	mov	DWORD PTR _e$[ebp], eax
$LN4@SV_LoadPro:
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+1656]
	jge	SHORT $LN3@SV_LoadPro

; 4891 : 		e->free = true; // mark all edicts as freed

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN2@SV_LoadPro
$LN3@SV_LoadPro:

; 4892 : 
; 4893 : 	Cvar_FullSet( "host_gameloaded", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG139628
	push	OFFSET $SG139629
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4894 : 	svgame.stringspool = Mem_AllocPool( "Server Strings" );

	push	4894					; 0000131eH
	push	OFFSET $SG139630
	push	OFFSET $SG139631
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _svgame+19560, eax

; 4895 : 
; 4896 : 	// fire once
; 4897 : 	Con_Printf( "Dll loaded for game ^2\"%s\"\n", svgame.dllFuncs.pfnGetGameDescription( ));

	call	DWORD PTR _svgame+19352
	push	eax
	push	OFFSET $SG139632
	call	_Con_Printf
	add	esp, 8

; 4898 : 
; 4899 : 	// all done, initialize game
; 4900 : 	svgame.dllFuncs.pfnGameInit();

	call	DWORD PTR _svgame+19240

; 4901 : 
; 4902 : 	// initialize pm_shared
; 4903 : 	SV_InitClientMove();

	call	_SV_InitClientMove

; 4904 : 
; 4905 : 	Delta_Init ();

	call	_Delta_Init

; 4906 : 
; 4907 : 	// register custom encoders
; 4908 : 	svgame.dllFuncs.pfnRegisterEncoders();

	call	DWORD PTR _svgame+19404

; 4909 : 
; 4910 : 	return true;

	mov	eax, 1
$LN1@SV_LoadPro:

; 4911 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 106  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesLeft PROC				; COMDAT

; 105  : _inline int MSG_GetNumBytesLeft( sizebuf_t *sb ) { return MSG_GetNumBitsLeft( sb ) >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetNumBytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 101  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_SV_Serverinfo PROC

; 123  : {

	push	ebp
	mov	ebp, esp

; 124  : 	return svs.serverinfo;

	mov	eax, OFFSET _svs+60

; 125  : }

	pop	ebp
	ret	0
_SV_Serverinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_error_string$ = 8					; size = 4
_SV_SysError PROC

; 108  : {

	push	ebp
	mov	ebp, esp

; 109  : 	Log_Printf( "FATAL ERROR (shutting down): %s\n", error_string );

	mov	eax, DWORD PTR _error_string$[ebp]
	push	eax
	push	OFFSET $SG137303
	call	_Log_Printf
	add	esp, 8

; 110  : 
; 111  : 	if( svgame.hInstance != NULL )

	cmp	DWORD PTR _svgame+7920, 0
	je	SHORT $LN1@SV_SysErro

; 112  : 		svgame.dllFuncs.pfnSys_Error( error_string );

	mov	ecx, DWORD PTR _error_string$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19372
	add	esp, 4
$LN1@SV_SysErro:

; 113  : }

	pop	ebp
	ret	0
_SV_SysError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_pEdict$ = 12						; size = 4
_adjacent$ = 16						; size = 4
_SV_RestoreCustomDecal PROC

; 453  : {

	push	ebp
	mov	ebp, esp

; 454  : 	if( svgame.physFuncs.pfnRestoreDecal != NULL )

	cmp	DWORD PTR _svgame+19536, 0
	je	SHORT $LN2@SV_Restore

; 455  : 	{
; 456  : 		if( !pEdict ) pEdict = EDICT_NUM( entry->entityIndex );

	cmp	DWORD PTR _pEdict$[ebp], 0
	jne	SHORT $LN3@SV_Restore
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax
$LN3@SV_Restore:

; 457  : 		// true if decal was sucessfully restored at the game-side
; 458  : 		return svgame.physFuncs.pfnRestoreDecal( entry, pEdict, adjacent );

	mov	edx, DWORD PTR _adjacent$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19536
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@SV_Restore
$LN2@SV_Restore:

; 459  : 	}
; 460  : 	return false;

	xor	eax, eax
$LN1@SV_Restore:

; 461  : }

	pop	ebp
	ret	0
_SV_RestoreCustomDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_origin$ = 12						; size = 4
_decalIndex$ = 16					; size = 4
_entityIndex$ = 20					; size = 4
_modelIndex$ = 24					; size = 4
_flags$ = 28						; size = 4
_scale$ = 32						; size = 4
_SV_CreateDecal PROC

; 471  : {

	push	ebp
	mov	ebp, esp

; 472  : 	if( msg == &sv.signon && sv.state != ss_loading )

	cmp	DWORD PTR _msg$[ebp], OFFSET _sv+1220372
	jne	SHORT $LN2@SV_CreateD
	cmp	DWORD PTR _sv, 1
	je	SHORT $LN2@SV_CreateD

; 473  : 		return;

	jmp	$LN1@SV_CreateD
$LN2@SV_CreateD:

; 474  : 
; 475  : 	// this can happens if serialized map contain 4096 static decals...
; 476  : 	if( MSG_GetNumBytesLeft( msg ) < 20 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 20					; 00000014H
	jge	SHORT $LN3@SV_CreateD

; 477  : 	{
; 478  : 		sv.ignored_world_decals++;

	mov	ecx, DWORD PTR _sv+1359696
	add	ecx, 1
	mov	DWORD PTR _sv+1359696, ecx

; 479  : 		return;

	jmp	$LN1@SV_CreateD
$LN3@SV_CreateD:

; 480  : 	}
; 481  : 
; 482  : 	// static decals are posters, it's always reliable
; 483  : 	MSG_BeginServerCmd( msg, svc_bspdecal );

	push	0
	push	1
	push	36					; 00000024H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 484  : 	MSG_WriteVec3Coord( msg, origin );

	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteVec3Coord
	add	esp, 8

; 485  : 	MSG_WriteWord( msg, decalIndex );

	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteWord
	add	esp, 8

; 486  : 	MSG_WriteShort( msg, entityIndex );

	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteShort
	add	esp, 8

; 487  : 	if( entityIndex > 0 )

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN4@SV_CreateD

; 488  : 		MSG_WriteWord( msg, modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8
$LN4@SV_CreateD:

; 489  : 	MSG_WriteByte( msg, flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 490  : 	MSG_WriteWord( msg, scale * 4096 );

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR __real@45800000
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteWord
	add	esp, 8
$LN1@SV_CreateD:

; 491  : }

	pop	ebp
	ret	0
_SV_CreateDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_curtrack$ = 8						; size = 4
_looptrack$ = 12					; size = 4
_position$ = 16						; size = 4
_SV_StartMusic PROC

; 2158 : {

	push	ebp
	mov	ebp, esp

; 2159 : 	MSG_BeginServerCmd( &sv.multicast, svc_stufftext );

	push	0
	push	1
	push	9
	push	OFFSET _sv+1212160
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2160 : 	MSG_WriteString( &sv.multicast, va( "music \"%s\" \"%s\" %i\n", curtrack, looptrack, position ));

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _looptrack$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curtrack$[ebp]
	push	edx
	push	OFFSET $SG138269
	call	_va
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET _sv+1212160
	call	_MSG_WriteString
	add	esp, 8

; 2161 : 	SV_Multicast( MSG_ALL, NULL, NULL, false, false );

	push	0
	push	0
	push	0
	push	0
	push	2
	call	_SV_Multicast
	add	esp, 20					; 00000014H

; 2162 : }

	pop	ebp
	ret	0
_SV_StartMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
tv163 = -36						; size = 4
tv139 = -32						; size = 4
_filter$ = -28						; size = 4
tv170 = -24						; size = 4
_msg_dest$ = -20					; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_chan$ = 12						; size = 4
_sample$ = 16						; size = 4
_vol$ = 20						; size = 4
_attn$ = 24						; size = 4
_flags$ = 28						; size = 4
_pitch$ = 32						; size = 4
_SV_StartSound PROC

; 2096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2097 : 	qboolean	filter = false;

	mov	DWORD PTR _filter$[ebp], 0

; 2098 : 	int	msg_dest;
; 2099 : 	vec3_t	origin;
; 2100 : 
; 2101 : 	if( !SV_IsValidEdict( ent ))

	push	2101					; 00000835H
	push	OFFSET $SG138226
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_StartSo

; 2102 : 		return;

	jmp	$LN11@SV_StartSo
$LN2@SV_StartSo:

; 2103 : 
; 2104 : 	VectorAverage( ent->v.mins, ent->v.maxs, origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+348]
	addss	xmm0, DWORD PTR [esi+ecx+360]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+348]
	addss	xmm0, DWORD PTR [esi+ecx+360]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _origin$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+348]
	addss	xmm0, DWORD PTR [esi+edx+360]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv139[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv139[ebp]
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 2105 : 	VectorAdd( origin, ent->v.origin, origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	addss	xmm0, DWORD PTR [ecx+edx+136]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _origin$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	addss	xmm0, DWORD PTR [eax+edx+136]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _origin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+136]
	movss	DWORD PTR tv163[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv163[ebp]
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 2106 : 
; 2107 : 	if( FBitSet( flags, SND_SPAWNING ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN3@SV_StartSo

; 2108 : 		msg_dest = MSG_INIT;

	mov	DWORD PTR _msg_dest$[ebp], 3
	jmp	SHORT $LN8@SV_StartSo
$LN3@SV_StartSo:

; 2109 : 	else if( chan == CHAN_STATIC )

	cmp	DWORD PTR _chan$[ebp], 6
	jne	SHORT $LN5@SV_StartSo

; 2110 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
	jmp	SHORT $LN8@SV_StartSo
$LN5@SV_StartSo:

; 2111 : 	else if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	ecx, DWORD PTR _host+34748
	and	ecx, 2
	je	SHORT $LN7@SV_StartSo

; 2112 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
	jmp	SHORT $LN8@SV_StartSo
$LN7@SV_StartSo:

; 2113 : 	else msg_dest = (svs.maxclients <= 1 ) ? MSG_ALL : MSG_PAS_R;

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN13@SV_StartSo
	mov	DWORD PTR tv170[ebp], 2
	jmp	SHORT $LN14@SV_StartSo
$LN13@SV_StartSo:
	mov	DWORD PTR tv170[ebp], 7
$LN14@SV_StartSo:
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _msg_dest$[ebp], edx
$LN8@SV_StartSo:

; 2114 : 
; 2115 : 	// always sending stop sound command
; 2116 : 	if( FBitSet( flags, SND_STOP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN9@SV_StartSo

; 2117 : 		msg_dest = MSG_ALL;

	mov	DWORD PTR _msg_dest$[ebp], 2
$LN9@SV_StartSo:

; 2118 : 
; 2119 : 	if( FBitSet( flags, SND_FILTER_CLIENT ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN10@SV_StartSo

; 2120 : 		filter = true;

	mov	DWORD PTR _filter$[ebp], 1
$LN10@SV_StartSo:

; 2121 : 
; 2122 : 	if( SV_BuildSoundMsg( &sv.multicast, ent, chan, sample, vol * 255, attn, flags, pitch, origin ))

	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _vol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si edx, xmm0
	push	edx
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	OFFSET _sv+1212160
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN11@SV_StartSo

; 2123 : 		SV_Multicast( msg_dest, origin, NULL, false, filter );

	mov	eax, DWORD PTR _filter$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_dest$[ebp]
	push	edx
	call	_SV_Multicast
	add	esp, 20					; 00000014H
$LN11@SV_StartSo:

; 2124 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StartSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_total$ = -8						; size = 4
_i$ = -4						; size = 4
_pfnNumberOfEntities PROC

; 3534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3535 : 	int	i, total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 3536 : 
; 3537 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnNumberO
$LN2@pfnNumberO:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnNumberO:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svgame+7932
	jge	SHORT $LN3@pfnNumberO

; 3538 : 	{
; 3539 : 		if( svgame.edicts[i].free )

	imul	edx, DWORD PTR _i$[ebp], 804
	mov	eax, DWORD PTR _svgame+7928
	cmp	DWORD PTR [eax+edx], 0
	je	SHORT $LN5@pfnNumberO

; 3540 : 			continue;

	jmp	SHORT $LN2@pfnNumberO
$LN5@pfnNumberO:

; 3541 : 		total++;

	mov	ecx, DWORD PTR _total$[ebp]
	add	ecx, 1
	mov	DWORD PTR _total$[ebp], ecx

; 3542 : 	}

	jmp	SHORT $LN2@pfnNumberO
$LN3@pfnNumberO:

; 3543 : 
; 3544 : 	return total;

	mov	eax, DWORD PTR _total$[ebp]

; 3545 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnNumberOfEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_flags$ = -4						; size = 4
_filename$ = 8						; size = 4
_pfnIsMapValid PROC

; 3435 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3436 : 	int	flags = SV_MapIsValid( filename, GI->mp_entity, NULL );

	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 1336				; 00000538H
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], eax

; 3437 : 
; 3438 : 	if( FBitSet( flags, MAP_IS_EXIST ) && FBitSet( flags, MAP_HAS_SPAWNPOINT ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	je	SHORT $LN2@pfnIsMapVa
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN2@pfnIsMapVa

; 3439 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnIsMapVa
$LN2@pfnIsMapVa:

; 3440 : 	return false;

	xor	eax, eax
$LN1@pfnIsMapVa:

; 3441 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsMapValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_m$ = 8							; size = 4
_pfnDecalIndex PROC

; 2511 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2512 : 	int	i;
; 2513 : 
; 2514 : 	if( !COM_CheckString( m ))

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@pfnDecalIn

; 2515 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@pfnDecalIn
$LN5@pfnDecalIn:

; 2516 : 
; 2517 : 	for( i = 1; i < MAX_DECALS && host.draw_decals[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@pfnDecalIn
$LN2@pfnDecalIn:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@pfnDecalIn:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@pfnDecalIn
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _host[edx+ecx+1468]
	test	edx, edx
	je	SHORT $LN3@pfnDecalIn

; 2518 : 	{
; 2519 : 		if( !Q_stricmp( host.draw_decals[i], m ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _host+1468
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@pfnDecalIn

; 2520 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@pfnDecalIn
$LN6@pfnDecalIn:

; 2521 : 	}

	jmp	SHORT $LN2@pfnDecalIn
$LN3@pfnDecalIn:

; 2522 : 
; 2523 : 	return -1;	

	or	eax, -1
$LN1@pfnDecalIn:

; 2524 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDecalIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_game.c
_TEXT	SEGMENT
_pEdict$1 = -4						; size = 4
_iEntIndex$ = 8						; size = 4
_pfnPEntityOfEntIndex PROC

; 3090 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3091 : 	if( iEntIndex >= 0 && iEntIndex < GI->max_edicts )

	cmp	DWORD PTR _iEntIndex$[ebp], 0
	jl	$LN2@pfnPEntity
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _iEntIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	SHORT $LN2@pfnPEntity

; 3092 : 	{
; 3093 : 		edict_t	*pEdict = EDICT_NUM( iEntIndex );

	mov	edx, DWORD PTR _iEntIndex$[ebp]
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$1[ebp], eax

; 3094 : 
; 3095 : 		if( !iEntIndex || FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	cmp	DWORD PTR _iEntIndex$[ebp], 0
	je	SHORT $LN4@pfnPEntity
	mov	eax, DWORD PTR _host+34748
	and	eax, 2
	je	SHORT $LN3@pfnPEntity
$LN4@pfnPEntity:

; 3096 : 			return pEdict; // just get access to array

	mov	eax, DWORD PTR _pEdict$1[ebp]
	jmp	SHORT $LN1@pfnPEntity
$LN3@pfnPEntity:

; 3097 : 
; 3098 : 		if( SV_IsValidEdict( pEdict ) && pEdict->pvPrivateData )

	push	3098					; 00000c1aH
	push	OFFSET $SG138778
	mov	ecx, DWORD PTR _pEdict$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@pfnPEntity
	mov	edx, DWORD PTR _pEdict$1[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	SHORT $LN5@pfnPEntity

; 3099 : 			return pEdict;

	mov	eax, DWORD PTR _pEdict$1[ebp]
	jmp	SHORT $LN1@pfnPEntity
$LN5@pfnPEntity:

; 3100 : 
; 3101 : 		// g-cont: world and clients can be acessed even without private data!
; 3102 : 		if( SV_IsValidEdict( pEdict ) && SV_IsPlayerIndex( iEntIndex ))

	push	3102					; 00000c1eH
	push	OFFSET $SG138780
	mov	eax, DWORD PTR _pEdict$1[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@pfnPEntity
	mov	ecx, DWORD PTR _iEntIndex$[ebp]
	push	ecx
	call	_SV_IsPlayerIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@pfnPEntity

; 3103 : 			return pEdict;

	mov	eax, DWORD PTR _pEdict$1[ebp]
	jmp	SHORT $LN1@pfnPEntity
$LN2@pfnPEntity:

; 3104 : 	}
; 3105 : 
; 3106 : 	return NULL;

	xor	eax, eax
$LN1@pfnPEntity:

; 3107 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPEntityOfEntIndex ENDP
_TEXT	ENDS
END
