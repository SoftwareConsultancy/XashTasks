; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\keys.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_keynames
_DATA	SEGMENT
COMM	_keys:BYTE:01000H
_DATA	ENDS
_BSS	SEGMENT
$SG138447 DB	01H DUP (?)
$SG138449 DB	01H DUP (?)
$SG138455 DB	01H DUP (?)
$SG138471 DB	01H DUP (?)
$SG138473 DB	01H DUP (?)
$SG138491 DB	01H DUP (?)
$SG138495 DB	01H DUP (?)
$SG138499 DB	01H DUP (?)
$SG138505 DB	01H DUP (?)
$SG138507 DB	01H DUP (?)
$SG138515 DB	01H DUP (?)
$SG138517 DB	01H DUP (?)
$SG138519 DB	01H DUP (?)
$SG138521 DB	01H DUP (?)
$SG138523 DB	01H DUP (?)
$SG138525 DB	01H DUP (?)
$SG138529 DB	01H DUP (?)
$SG138533 DB	01H DUP (?)
$SG138543 DB	01H DUP (?)
$SG138545 DB	01H DUP (?)
$SG138549 DB	01H DUP (?)
$SG138551 DB	01H DUP (?)
$SG138553 DB	01H DUP (?)
$SG138557 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_keynames DD	FLAT:$SG138446
	DD	09H
	DD	FLAT:$SG138447
	DD	FLAT:$SG138448
	DD	0dH
	DD	FLAT:$SG138449
	DD	FLAT:$SG138450
	DD	01bH
	DD	FLAT:$SG138451
	DD	FLAT:$SG138452
	DD	020H
	DD	FLAT:$SG138453
	DD	FLAT:$SG138454
	DD	07fH
	DD	FLAT:$SG138455
	DD	FLAT:$SG138456
	DD	080H
	DD	FLAT:$SG138457
	DD	FLAT:$SG138458
	DD	081H
	DD	FLAT:$SG138459
	DD	FLAT:$SG138460
	DD	082H
	DD	FLAT:$SG138461
	DD	FLAT:$SG138462
	DD	083H
	DD	FLAT:$SG138463
	DD	FLAT:$SG138464
	DD	084H
	DD	FLAT:$SG138465
	DD	FLAT:$SG138466
	DD	085H
	DD	FLAT:$SG138467
	DD	FLAT:$SG138468
	DD	086H
	DD	FLAT:$SG138469
	DD	FLAT:$SG138470
	DD	0afH
	DD	FLAT:$SG138471
	DD	FLAT:$SG138472
	DD	046H
	DD	FLAT:$SG138473
	DD	FLAT:$SG138474
	DD	087H
	DD	FLAT:$SG138475
	DD	FLAT:$SG138476
	DD	088H
	DD	FLAT:$SG138477
	DD	FLAT:$SG138478
	DD	089H
	DD	FLAT:$SG138479
	DD	FLAT:$SG138480
	DD	08aH
	DD	FLAT:$SG138481
	DD	FLAT:$SG138482
	DD	08bH
	DD	FLAT:$SG138483
	DD	FLAT:$SG138484
	DD	08cH
	DD	FLAT:$SG138485
	DD	FLAT:$SG138486
	DD	08dH
	DD	FLAT:$SG138487
	DD	FLAT:$SG138488
	DD	08eH
	DD	FLAT:$SG138489
	DD	FLAT:$SG138490
	DD	08fH
	DD	FLAT:$SG138491
	DD	FLAT:$SG138492
	DD	090H
	DD	FLAT:$SG138493
	DD	FLAT:$SG138494
	DD	091H
	DD	FLAT:$SG138495
	DD	FLAT:$SG138496
	DD	092H
	DD	FLAT:$SG138497
	DD	FLAT:$SG138498
	DD	093H
	DD	FLAT:$SG138499
	DD	FLAT:$SG138500
	DD	094H
	DD	FLAT:$SG138501
	DD	FLAT:$SG138502
	DD	095H
	DD	FLAT:$SG138503
	DD	FLAT:$SG138504
	DD	096H
	DD	FLAT:$SG138505
	DD	FLAT:$SG138506
	DD	097H
	DD	FLAT:$SG138507
	DD	FLAT:$SG138508
	DD	098H
	DD	FLAT:$SG138509
	DD	FLAT:$SG138510
	DD	0f1H
	DD	FLAT:$SG138511
	DD	FLAT:$SG138512
	DD	0f2H
	DD	FLAT:$SG138513
	DD	FLAT:$SG138514
	DD	0f3H
	DD	FLAT:$SG138515
	DD	FLAT:$SG138516
	DD	0f4H
	DD	FLAT:$SG138517
	DD	FLAT:$SG138518
	DD	0f5H
	DD	FLAT:$SG138519
	DD	FLAT:$SG138520
	DD	0f0H
	DD	FLAT:$SG138521
	DD	FLAT:$SG138522
	DD	0efH
	DD	FLAT:$SG138523
	DD	FLAT:$SG138524
	DD	0a0H
	DD	FLAT:$SG138525
	DD	FLAT:$SG138526
	DD	0a1H
	DD	FLAT:$SG138527
	DD	FLAT:$SG138528
	DD	0a2H
	DD	FLAT:$SG138529
	DD	FLAT:$SG138530
	DD	0a3H
	DD	FLAT:$SG138531
	DD	FLAT:$SG138532
	DD	0a4H
	DD	FLAT:$SG138533
	DD	FLAT:$SG138534
	DD	0a5H
	DD	FLAT:$SG138535
	DD	FLAT:$SG138536
	DD	0a6H
	DD	FLAT:$SG138537
	DD	FLAT:$SG138538
	DD	0a7H
	DD	FLAT:$SG138539
	DD	FLAT:$SG138540
	DD	0a8H
	DD	FLAT:$SG138541
	DD	FLAT:$SG138542
	DD	0a9H
	DD	FLAT:$SG138543
	DD	FLAT:$SG138544
	DD	0aaH
	DD	FLAT:$SG138545
	DD	FLAT:$SG138546
	DD	0abH
	DD	FLAT:$SG138547
	DD	FLAT:$SG138548
	DD	0acH
	DD	FLAT:$SG138549
	DD	FLAT:$SG138550
	DD	0adH
	DD	FLAT:$SG138551
	DD	FLAT:$SG138552
	DD	0aeH
	DD	FLAT:$SG138553
	DD	FLAT:$SG138554
	DD	0ffH
	DD	FLAT:$SG138555
	DD	FLAT:$SG138556
	DD	03bH
	DD	FLAT:$SG138557
	DD	00H
	DD	00H
	DD	00H
$SG138446 DB	'TAB', 00H
$SG138448 DB	'ENTER', 00H
	ORG $+2
$SG138450 DB	'ESCAPE', 00H
	ORG $+1
$SG138451 DB	'escape', 00H
	ORG $+1
$SG138452 DB	'SPACE', 00H
	ORG $+2
$SG138453 DB	'+jump', 00H
	ORG $+2
$SG138454 DB	'BACKSPACE', 00H
	ORG $+2
$SG138456 DB	'UPARROW', 00H
$SG138457 DB	'+forward', 00H
	ORG $+3
$SG138458 DB	'DOWNARROW', 00H
	ORG $+2
$SG138459 DB	'+back', 00H
	ORG $+2
$SG138460 DB	'LEFTARROW', 00H
	ORG $+2
$SG138461 DB	'+left', 00H
	ORG $+2
$SG138462 DB	'RIGHTARROW', 00H
	ORG $+1
$SG138463 DB	'+right', 00H
	ORG $+1
$SG138464 DB	'ALT', 00H
$SG138465 DB	'+strafe', 00H
$SG138466 DB	'CTRL', 00H
	ORG $+3
$SG138467 DB	'+attack', 00H
$SG138468 DB	'SHIFT', 00H
	ORG $+2
$SG138469 DB	'+speed', 00H
	ORG $+1
$SG138470 DB	'CAPSLOCK', 00H
	ORG $+3
$SG138472 DB	'SCROLLOCK', 00H
	ORG $+2
$SG138474 DB	'F1', 00H
	ORG $+1
$SG138475 DB	'cmd help', 00H
	ORG $+3
$SG138476 DB	'F2', 00H
	ORG $+1
$SG138477 DB	'menu_savegame', 00H
	ORG $+2
$SG138478 DB	'F3', 00H
	ORG $+1
$SG138479 DB	'menu_loadgame', 00H
	ORG $+2
$SG138480 DB	'F4', 00H
	ORG $+1
$SG138481 DB	'menu_controls', 00H
	ORG $+2
$SG138482 DB	'F5', 00H
	ORG $+1
$SG138483 DB	'menu_creategame', 00H
$SG138484 DB	'F6', 00H
	ORG $+1
$SG138485 DB	'savequick', 00H
	ORG $+2
$SG138486 DB	'F7', 00H
	ORG $+1
$SG138487 DB	'loadquick', 00H
	ORG $+2
$SG138488 DB	'F8', 00H
	ORG $+1
$SG138489 DB	'stop', 00H
	ORG $+3
$SG138490 DB	'F9', 00H
	ORG $+1
$SG138492 DB	'F10', 00H
$SG138493 DB	'menu_main', 00H
	ORG $+2
$SG138494 DB	'F11', 00H
$SG138496 DB	'F12', 00H
$SG138497 DB	'snapshot', 00H
	ORG $+3
$SG138498 DB	'INS', 00H
$SG138500 DB	'DEL', 00H
$SG138501 DB	'+lookdown', 00H
	ORG $+2
$SG138502 DB	'PGDN', 00H
	ORG $+3
$SG138503 DB	'+lookup', 00H
$SG138504 DB	'PGUP', 00H
	ORG $+3
$SG138506 DB	'HOME', 00H
	ORG $+3
$SG138508 DB	'END', 00H
$SG138509 DB	'centerview', 00H
	ORG $+1
$SG138510 DB	'MOUSE1', 00H
	ORG $+1
$SG138511 DB	'+attack', 00H
$SG138512 DB	'MOUSE2', 00H
	ORG $+1
$SG138513 DB	'+attack2', 00H
	ORG $+3
$SG138514 DB	'MOUSE3', 00H
	ORG $+1
$SG138516 DB	'MOUSE4', 00H
	ORG $+1
$SG138518 DB	'MOUSE5', 00H
	ORG $+1
$SG138520 DB	'MWHEELUP', 00H
	ORG $+3
$SG138522 DB	'MWHEELDOWN', 00H
	ORG $+1
$SG138524 DB	'KP_HOME', 00H
$SG138526 DB	'KP_UPARROW', 00H
	ORG $+1
$SG138527 DB	'+forward', 00H
	ORG $+3
$SG138528 DB	'KP_PGUP', 00H
$SG138530 DB	'KP_LEFTARROW', 00H
	ORG $+3
$SG138531 DB	'+left', 00H
	ORG $+2
$SG138532 DB	'KP_5', 00H
	ORG $+3
$SG138534 DB	'KP_RIGHTARROW', 00H
	ORG $+2
$SG138535 DB	'+right', 00H
	ORG $+1
$SG138536 DB	'KP_END', 00H
	ORG $+1
$SG138537 DB	'centerview', 00H
	ORG $+1
$SG138538 DB	'KP_DOWNARROW', 00H
	ORG $+3
$SG138539 DB	'+back', 00H
	ORG $+2
$SG138540 DB	'KP_PGDN', 00H
$SG138541 DB	'+lookup', 00H
$SG138542 DB	'KP_ENTER', 00H
	ORG $+3
$SG138544 DB	'KP_INS', 00H
	ORG $+1
$SG138546 DB	'KP_DEL', 00H
	ORG $+1
$SG138547 DB	'+lookdown', 00H
	ORG $+2
$SG138548 DB	'KP_SLASH', 00H
	ORG $+3
$SG138550 DB	'KP_MINUS', 00H
	ORG $+3
$SG138552 DB	'KP_PLUS', 00H
$SG138554 DB	'PAUSE', 00H
	ORG $+2
$SG138555 DB	'pause', 00H
	ORG $+2
$SG138556 DB	'SEMICOLON', 00H
_DATA	ENDS
PUBLIC	_Key_IsDown
PUBLIC	_Key_IsBind
PUBLIC	_Key_Event
PUBLIC	_Key_Init
PUBLIC	_Key_WriteBindings
PUBLIC	_Key_GetBinding
PUBLIC	_Key_SetBinding
PUBLIC	_Key_ClearStates
PUBLIC	_Key_KeynumToString
PUBLIC	_Key_StringToKeynum
PUBLIC	_Key_GetKey
PUBLIC	_Key_SetKeyDest
PUBLIC	_CL_CharEvent
PUBLIC	_Key_Unbind_f
PUBLIC	_Key_Unbindall_f
PUBLIC	_Key_Reset_f
PUBLIC	_Key_Bind_f
PUBLIC	_Key_Bindlist_f
PUBLIC	_Key_AddKeyCommands
PUBLIC	_Key_IsAllowedAutoRepeat
PUBLIC	__real@00000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_Key_EnumCmds_f:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_IN_ToggleClientMouse:PROC
EXTRN	_Con_Visible:PROC
EXTRN	_Con_ToggleConsole_f:PROC
EXTRN	_Con_CharEvent:PROC
EXTRN	_Key_Console:PROC
EXTRN	_Key_Message:PROC
EXTRN	_UI_KeyEvent:PROC
EXTRN	_UI_CharEvent:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gl_showtextures:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?tinystr@?1??Key_KeynumToString@@9@9 DB 05H DUP (?)	; `Key_KeynumToString'::`2'::tinystr
	ALIGN	4

$SG138647 DB	01H DUP (?)
	ALIGN	4

$SG138656 DB	01H DUP (?)
	ALIGN	4

$SG138670 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG138604 DB	'<KEY NOT FOUND>', 00H
$SG138607 DB	'<OUT OF RANGE>', 00H
	ORG $+1
$SG138644 DB	'Usage: unbind <key> : remove commands from a key', 0aH, 00H
	ORG $+2
$SG138619 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\keys.c', 00H
$SG138620 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\keys.c', 00H
$SG138646 DB	'"%s" isn''t a valid key', 0aH, 00H
$SG138657 DB	'cancelselect', 00H
	ORG $+3
$SG138683 DB	'Usage: bind <key> [command] : attach a command to a key', 0aH
	DB	00H
	ORG $+3
$SG138685 DB	'"%s" isn''t a valid key', 0aH, 00H
$SG138689 DB	'"%s" = "%s"', 0aH, 00H
	ORG $+3
$SG138690 DB	'"%s" is not bound', 0aH, 00H
	ORG $+1
$SG138692 DB	' ', 00H
	ORG $+2
$SG138701 DB	'unbindall', 0aH, 00H
	ORG $+1
$SG138703 DB	'bind %s "%s"', 0aH, 00H
	ORG $+2
$SG138712 DB	'%s "%s"', 0aH, 00H
	ORG $+3
$SG138719 DB	'binds a command to the specified key in bindmap', 00H
$SG138720 DB	'bind', 00H
	ORG $+3
$SG138721 DB	'removes a command on the specified key in bindmap', 00H
	ORG $+2
$SG138722 DB	'unbind', 00H
	ORG $+1
$SG138723 DB	'removes all commands from all keys in bindmap', 00H
	ORG $+2
$SG138724 DB	'unbindall', 00H
	ORG $+2
$SG138725 DB	'reset all keys to their default values', 00H
	ORG $+1
$SG138726 DB	'resetkeys', 00H
	ORG $+2
$SG138727 DB	'display current key bindings', 00H
	ORG $+3
$SG138728 DB	'bindlist', 00H
	ORG $+3
$SG138729 DB	'write help.txt that contains all console cvars and cmds', 00H
$SG138730 DB	'makehelp', 00H
	ORG $+3
$SG138755 DB	'%s %i', 0aH, 00H
	ORG $+1
$SG138756 DB	'-%s %i', 0aH, 00H
$SG138758 DB	0aH, 00H
	ORG $+2
$SG138791 DB	'%s is unbound.', 0aH, 00H
$SG138801 DB	'r_showtextures', 00H
	ORG $+1
$SG138826 DB	'Key_SetKeyDest: wrong destination (%i)', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_key$ = 8						; size = 4
_Key_IsAllowedAutoRepeat PROC

; 532  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 533  : 	switch( key )

	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 127				; 0000007fH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 128		; 00000080H
	ja	SHORT $LN5@Key_IsAllo
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN7@Key_IsAllo[edx]
	jmp	DWORD PTR $LN8@Key_IsAllo[eax*4]
$LN4@Key_IsAllo:

; 534  : 	{
; 535  : 	case K_BACKSPACE:
; 536  : 	case K_PAUSE:
; 537  : 	case K_PGUP:
; 538  : 	case K_KP_PGUP:
; 539  : 	case K_PGDN:
; 540  : 	case K_KP_PGDN:
; 541  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Key_IsAllo
$LN5@Key_IsAllo:

; 542  : 	default:
; 543  : 		return false;

	xor	eax, eax
$LN1@Key_IsAllo:

; 544  : 	} 
; 545  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@Key_IsAllo:
	DD	$LN4@Key_IsAllo
	DD	$LN5@Key_IsAllo
$LN7@Key_IsAllo:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_Key_IsAllowedAutoRepeat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_buttonPtr$ = -2060					; size = 4
_i$ = -2056						; size = 4
_cmd$ = -2052						; size = 1024
_button$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_kb$ = 12						; size = 4
_down$ = 16						; size = 4
_Key_AddKeyCommands PROC

; 486  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2060				; 0000080cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 487  : 	char	button[1024];
; 488  : 	char	*buttonPtr;
; 489  : 	char	cmd[1024];
; 490  : 	int	i;
; 491  : 
; 492  : 	if( !kb ) return;

	cmp	DWORD PTR _kb$[ebp], 0
	jne	SHORT $LN7@Key_AddKey
	jmp	$LN1@Key_AddKey
$LN7@Key_AddKey:

; 493  : 	buttonPtr = button;

	lea	eax, DWORD PTR _button$[ebp]
	mov	DWORD PTR _buttonPtr$[ebp], eax

; 494  : 
; 495  : 	for( i = 0; ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_AddKey
$LN2@Key_AddKey:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Key_AddKey:

; 496  : 	{
; 497  : 		if( kb[i] == ';' || !kb[i] )

	mov	edx, DWORD PTR _kb$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN9@Key_AddKey
	mov	ecx, DWORD PTR _kb$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	$LN8@Key_AddKey
$LN9@Key_AddKey:

; 498  : 		{
; 499  : 			*buttonPtr = '\0';

	mov	eax, DWORD PTR _buttonPtr$[ebp]
	mov	BYTE PTR [eax], 0

; 500  : 			if( button[0] == '+' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _button$[ebp+edx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN10@Key_AddKey

; 501  : 			{
; 502  : 				// button commands add keynum as a parm
; 503  : 				if( down ) Q_sprintf( cmd, "%s %i\n", button, key );

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN12@Key_AddKey
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	lea	edx, DWORD PTR _button$[ebp]
	push	edx
	push	OFFSET $SG138755
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN13@Key_AddKey
$LN12@Key_AddKey:

; 504  : 				else Q_sprintf( cmd, "-%s %i\n", button + 1, key );

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	lea	edx, DWORD PTR _button$[ebp+1]
	push	edx
	push	OFFSET $SG138756
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 16					; 00000010H
$LN13@Key_AddKey:

; 505  : 				Cbuf_AddText( cmd );

	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Cbuf_AddText
	add	esp, 4

; 506  : 			}

	jmp	SHORT $LN11@Key_AddKey
$LN10@Key_AddKey:

; 507  : 			else if( down )

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN11@Key_AddKey

; 508  : 			{
; 509  : 				// down-only command
; 510  : 				Cbuf_AddText( button );

	lea	edx, DWORD PTR _button$[ebp]
	push	edx
	call	_Cbuf_AddText
	add	esp, 4

; 511  : 				Cbuf_AddText( "\n" );

	push	OFFSET $SG138758
	call	_Cbuf_AddText
	add	esp, 4
$LN11@Key_AddKey:

; 512  : 			}
; 513  : 
; 514  : 			buttonPtr = button;

	lea	eax, DWORD PTR _button$[ebp]
	mov	DWORD PTR _buttonPtr$[ebp], eax
$LN5@Key_AddKey:

; 515  : 			while(( kb[i] <= ' ' || kb[i] == ';' ) && kb[i] != 0 )

	mov	ecx, DWORD PTR _kb$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jle	SHORT $LN15@Key_AddKey
	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN8@Key_AddKey
$LN15@Key_AddKey:
	mov	edx, DWORD PTR _kb$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN8@Key_AddKey

; 516  : 				i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN5@Key_AddKey
$LN8@Key_AddKey:

; 517  : 		}
; 518  : 
; 519  : 		*buttonPtr++ = kb[i];

	mov	edx, DWORD PTR _kb$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _buttonPtr$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _buttonPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _buttonPtr$[ebp], edx

; 520  : 		if( !kb[i] ) break;

	mov	eax, DWORD PTR _kb$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN16@Key_AddKey
	jmp	SHORT $LN1@Key_AddKey
$LN16@Key_AddKey:

; 521  : 	}

	jmp	$LN2@Key_AddKey
$LN1@Key_AddKey:

; 522  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_AddKeyCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Key_Bindlist_f PROC

; 440  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 441  : 	int	i;
; 442  : 
; 443  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_Bindli
$LN2@Key_Bindli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Bindli:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Key_Bindli

; 444  : 	{
; 445  : 		if( !COM_CheckString( keys[i].binding ))

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Key_Bindli

; 446  : 			continue;

	jmp	SHORT $LN2@Key_Bindli
$LN5@Key_Bindli:

; 447  : 
; 448  : 		Con_Printf( "%s \"%s\"\n", Key_KeynumToString( i ), keys[i].binding );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Key_KeynumToString
	add	esp, 4
	push	eax
	push	OFFSET $SG138712
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 449  : 	}

	jmp	SHORT $LN2@Key_Bindli
$LN1@Key_Bindli:

; 450  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Bindlist_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
$T1 = -1044						; size = 4
_b$ = -1040						; size = 4
_c$ = -1036						; size = 4
_i$ = -1032						; size = 4
_cmd$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_Key_Bind_f PROC

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1044				; 00000414H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 370  : 	char	cmd[1024];
; 371  : 	int	i, c, b;
; 372  : 	
; 373  : 	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 374  : 
; 375  : 	if( c < 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jge	SHORT $LN5@Key_Bind_f

; 376  : 	{
; 377  : 		Con_Printf( S_USAGE "bind <key> [command] : attach a command to a key\n" );

	push	OFFSET $SG138683
	call	_Con_Printf
	add	esp, 4

; 378  : 		return;

	jmp	$LN11@Key_Bind_f
$LN5@Key_Bind_f:

; 379  : 	}
; 380  : 
; 381  : 	b = Key_StringToKeynum( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Key_StringToKeynum
	add	esp, 4
	mov	DWORD PTR _b$[ebp], eax

; 382  : 
; 383  : 	if( b == -1 )

	cmp	DWORD PTR _b$[ebp], -1
	jne	SHORT $LN6@Key_Bind_f

; 384  : 	{
; 385  : 		Con_Printf( "\"%s\" isn't a valid key\n", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG138685
	call	_Con_Printf
	add	esp, 8

; 386  : 		return;

	jmp	$LN11@Key_Bind_f
$LN6@Key_Bind_f:

; 387  : 	}
; 388  : 
; 389  : 	if( c == 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jne	SHORT $LN7@Key_Bind_f

; 390  : 	{
; 391  : 		if( keys[b].binding )

	mov	eax, DWORD PTR _b$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	je	SHORT $LN8@Key_Bind_f

; 392  : 			Con_Printf( "\"%s\" = \"%s\"\n", Cmd_Argv( 1 ), keys[b].binding );

	mov	ecx, DWORD PTR _b$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	push	edx
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG138689
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Key_Bind_f
$LN8@Key_Bind_f:

; 393  : 		else Con_Printf( "\"%s\" is not bound\n", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG138690
	call	_Con_Printf
	add	esp, 8
$LN9@Key_Bind_f:

; 394  : 		return;

	jmp	$LN11@Key_Bind_f
$LN7@Key_Bind_f:

; 395  : 	}
; 396  : 	
; 397  : 	// copy the rest of the command line
; 398  : 	cmd[0] = 0; // start out with a null string

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN12@Key_Bind_f
	jmp	SHORT $LN13@Key_Bind_f
$LN12@Key_Bind_f:
	call	___report_rangecheckfailure
$LN13@Key_Bind_f:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cmd$[ebp+edx], 0

; 399  : 
; 400  : 	for( i = 2; i < c; i++ )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN4@Key_Bind_f
$LN2@Key_Bind_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Bind_f:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _c$[ebp]
	jge	SHORT $LN3@Key_Bind_f

; 401  : 	{
; 402  : 		Q_strcat( cmd, Cmd_Argv( i ));

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 403  : 		if( i != ( c - 1 )) Q_strcat( cmd, " " );

	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	je	SHORT $LN10@Key_Bind_f
	push	99999					; 0001869fH
	push	OFFSET $SG138692
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN10@Key_Bind_f:

; 404  : 	}

	jmp	SHORT $LN2@Key_Bind_f
$LN3@Key_Bind_f:

; 405  : 
; 406  : 	Key_SetBinding( b, cmd );

	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	_Key_SetBinding
	add	esp, 8
$LN11@Key_Bind_f:

; 407  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Bind_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_kn$ = -8						; size = 4
_i$ = -4						; size = 4
_Key_Reset_f PROC

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 348  : 	keyname_t	*kn;
; 349  : 	int	i;
; 350  : 
; 351  : 	// clear all keys first	
; 352  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_Reset_
$LN2@Key_Reset_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Reset_:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Key_Reset_

; 353  : 	{
; 354  : 		if( keys[i].binding )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	cmp	DWORD PTR _keys[ecx+12], 0
	je	SHORT $LN8@Key_Reset_

; 355  : 			Key_SetBinding( i, "" );

	push	OFFSET $SG138670
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Key_SetBinding
	add	esp, 8
$LN8@Key_Reset_:

; 356  : 	}

	jmp	SHORT $LN2@Key_Reset_
$LN3@Key_Reset_:

; 357  : 
; 358  : 	// apply default values
; 359  : 	for( kn = keynames; kn->name; kn++ )

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN7@Key_Reset_
$LN5@Key_Reset_:
	mov	eax, DWORD PTR _kn$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], eax
$LN7@Key_Reset_:
	mov	ecx, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Key_Reset_

; 360  : 		Key_SetBinding( kn->keynum, kn->binding ); 

	mov	edx, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _kn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Key_SetBinding
	add	esp, 8
	jmp	SHORT $LN5@Key_Reset_
$LN1@Key_Reset_:

; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Reset_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Key_Unbindall_f PROC

; 328  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 329  : 	int	i;
; 330  : 	
; 331  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_Unbind
$LN2@Key_Unbind:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_Unbind:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Key_Unbind

; 332  : 	{
; 333  : 		if( keys[i].binding )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	cmp	DWORD PTR _keys[ecx+12], 0
	je	SHORT $LN5@Key_Unbind

; 334  : 			Key_SetBinding( i, "" );

	push	OFFSET $SG138656
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Key_SetBinding
	add	esp, 8
$LN5@Key_Unbind:

; 335  : 	}

	jmp	SHORT $LN2@Key_Unbind
$LN3@Key_Unbind:

; 336  : 
; 337  : 	// set some defaults
; 338  : 	Key_SetBinding( K_ESCAPE, "cancelselect" );

	push	OFFSET $SG138657
	push	27					; 0000001bH
	call	_Key_SetBinding
	add	esp, 8

; 339  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Unbindall_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_b$ = -4						; size = 4
_Key_Unbind_f PROC

; 302  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 303  : 	int	b;
; 304  : 
; 305  : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@Key_Unbind

; 306  : 	{
; 307  : 		Con_Printf( S_USAGE "unbind <key> : remove commands from a key\n" );

	push	OFFSET $SG138644
	call	_Con_Printf
	add	esp, 4

; 308  : 		return;

	jmp	SHORT $LN1@Key_Unbind
$LN2@Key_Unbind:

; 309  : 	}
; 310  : 	
; 311  : 	b = Key_StringToKeynum( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Key_StringToKeynum
	add	esp, 4
	mov	DWORD PTR _b$[ebp], eax

; 312  : 
; 313  : 	if( b == -1 )

	cmp	DWORD PTR _b$[ebp], -1
	jne	SHORT $LN3@Key_Unbind

; 314  : 	{
; 315  : 		Con_Printf( "\"%s\" isn't a valid key\n", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG138646
	call	_Con_Printf
	add	esp, 8

; 316  : 		return;

	jmp	SHORT $LN1@Key_Unbind
$LN3@Key_Unbind:

; 317  : 	}
; 318  : 
; 319  : 	Key_SetBinding( b, "" );

	push	OFFSET $SG138647
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_Key_SetBinding
	add	esp, 8
$LN1@Key_Unbind:

; 320  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Unbind_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_key$ = 8						; size = 4
_CL_CharEvent PROC

; 755  : {

	push	ebp
	mov	ebp, esp

; 756  : 	// the console key should never be used as a char
; 757  : 	if( key == '`' || key == '~' ) return;

	cmp	DWORD PTR _key$[ebp], 96		; 00000060H
	je	SHORT $LN3@CL_CharEve
	cmp	DWORD PTR _key$[ebp], 126		; 0000007eH
	jne	SHORT $LN2@CL_CharEve
$LN3@CL_CharEve:
	jmp	SHORT $LN1@CL_CharEve
$LN2@CL_CharEve:

; 758  : 
; 759  : 	if( cls.key_dest == key_console && !Con_Visible( ))

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN4@CL_CharEve
	call	_Con_Visible
	test	eax, eax
	jne	SHORT $LN4@CL_CharEve

; 760  : 	{
; 761  : 		if((char)key == '¸' || (char)key == '¨' )

	movsx	eax, BYTE PTR _key$[ebp]
	cmp	eax, -72				; ffffffb8H
	je	SHORT $LN6@CL_CharEve
	movsx	ecx, BYTE PTR _key$[ebp]
	cmp	ecx, -88				; ffffffa8H
	jne	SHORT $LN4@CL_CharEve
$LN6@CL_CharEve:

; 762  : 			return; // don't pass '¸' when we open the console 

	jmp	SHORT $LN1@CL_CharEve
$LN4@CL_CharEve:

; 763  : 	}
; 764  : 
; 765  : 	// distribute the key down event to the apropriate handler
; 766  : 	if( cls.key_dest == key_console || cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 0
	je	SHORT $LN9@CL_CharEve
	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN7@CL_CharEve
$LN9@CL_CharEve:

; 767  : 	{
; 768  : 		Con_CharEvent( key );

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Con_CharEvent
	add	esp, 4

; 769  : 	}

	jmp	SHORT $LN1@CL_CharEve
$LN7@CL_CharEve:

; 770  : 	else if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN1@CL_CharEve

; 771  : 	{
; 772  : 		UI_CharEvent( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_UI_CharEvent
	add	esp, 4
$LN1@CL_CharEve:

; 773  : 	}
; 774  : }

	pop	ebp
	ret	0
_CL_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_key_dest$ = 8						; size = 4
_Key_SetKeyDest PROC

; 698  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 699  : 	IN_ToggleClientMouse( key_dest, cls.key_dest );

	mov	eax, DWORD PTR _cls+36
	push	eax
	mov	ecx, DWORD PTR _key_dest$[ebp]
	push	ecx
	call	_IN_ToggleClientMouse
	add	esp, 8

; 700  : 
; 701  : 	switch( key_dest )

	mov	edx, DWORD PTR _key_dest$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 3
	ja	SHORT $LN8@Key_SetKey
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN10@Key_SetKey[eax*4]
$LN4@Key_SetKey:

; 702  : 	{
; 703  : 	case key_game:
; 704  : 		cls.key_dest = key_game;

	mov	DWORD PTR _cls+36, 1

; 705  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN5@Key_SetKey:

; 706  : 	case key_menu:
; 707  : 		cls.key_dest = key_menu;

	mov	DWORD PTR _cls+36, 2

; 708  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN6@Key_SetKey:

; 709  : 	case key_console:
; 710  : 		cls.key_dest = key_console;

	mov	DWORD PTR _cls+36, 0

; 711  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN7@Key_SetKey:

; 712  : 	case key_message:
; 713  : 		cls.key_dest = key_message;

	mov	DWORD PTR _cls+36, 3

; 714  : 		break;

	jmp	SHORT $LN1@Key_SetKey
$LN8@Key_SetKey:

; 715  : 	default:
; 716  : 		Host_Error( "Key_SetKeyDest: wrong destination (%i)\n", key_dest );

	mov	ecx, DWORD PTR _key_dest$[ebp]
	push	ecx
	push	OFFSET $SG138826
	call	_Host_Error
	add	esp, 8
$LN1@Key_SetKey:

; 717  : 		break;
; 718  : 	}
; 719  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Key_SetKey:
	DD	$LN6@Key_SetKey
	DD	$LN4@Key_SetKey
	DD	$LN5@Key_SetKey
	DD	$LN7@Key_SetKey
_Key_SetKeyDest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pBinding$ = 8						; size = 4
_Key_GetKey PROC

; 271  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 272  : 	int	i;
; 273  : 
; 274  : 	if( !pBinding ) return -1;

	cmp	DWORD PTR _pBinding$[ebp], 0
	jne	SHORT $LN5@Key_GetKey
	or	eax, -1
	jmp	$LN1@Key_GetKey
$LN5@Key_GetKey:

; 275  : 
; 276  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_GetKey
$LN2@Key_GetKey:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_GetKey:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@Key_GetKey

; 277  : 	{
; 278  : 		if( !keys[i].binding )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	cmp	DWORD PTR _keys[ecx+12], 0
	jne	SHORT $LN6@Key_GetKey

; 279  : 			continue;

	jmp	SHORT $LN2@Key_GetKey
$LN6@Key_GetKey:

; 280  : 
; 281  : 		if( *keys[i].binding == '+' )

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+12]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN7@Key_GetKey

; 282  :                     {
; 283  : 			if( !Q_strnicmp( keys[i].binding + 1, pBinding, Q_strlen( pBinding )))

	mov	edx, DWORD PTR _pBinding$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pBinding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	add	edx, 1
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Key_GetKey

; 284  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@Key_GetKey
$LN9@Key_GetKey:

; 285  : 		}

	jmp	SHORT $LN8@Key_GetKey
$LN7@Key_GetKey:

; 286  : 		else
; 287  : 		{
; 288  : 			if( !Q_strnicmp( keys[i].binding, pBinding, Q_strlen( pBinding )))

	mov	eax, DWORD PTR _pBinding$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pBinding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+12]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Key_GetKey

; 289  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@Key_GetKey
$LN8@Key_GetKey:

; 290  : 		}
; 291  : 	}

	jmp	$LN2@Key_GetKey
$LN3@Key_GetKey:

; 292  : 
; 293  : 	return -1;

	or	eax, -1
$LN1@Key_GetKey:

; 294  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_GetKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_kn$ = -12						; size = 4
_n2$1 = -8						; size = 4
_n1$2 = -4						; size = 4
_str$ = 8						; size = 4
_Key_StringToKeynum PROC

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 143  : 	keyname_t		*kn;
; 144  : 	
; 145  : 	if( !str || !str[0] ) return -1;

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN6@Key_String
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@Key_String
$LN6@Key_String:
	or	eax, -1
	jmp	$LN1@Key_String
$LN5@Key_String:

; 146  : 	if( !str[1] ) return str[0];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN7@Key_String
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [eax+edx]
	jmp	$LN1@Key_String
$LN7@Key_String:

; 147  : 
; 148  : 	// check for hex code
; 149  : 	if( str[0] == '0' && str[1] == 'x' && Q_strlen( str ) == 4 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jne	$LN8@Key_String
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 120				; 00000078H
	jne	$LN8@Key_String
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 4
	jne	$LN8@Key_String

; 150  : 	{
; 151  : 		int	n1, n2;
; 152  : 		
; 153  : 		n1 = str[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _n1$2[ebp], edx

; 154  : 		if( n1 >= '0' && n1 <= '9' )

	cmp	DWORD PTR _n1$2[ebp], 48		; 00000030H
	jl	SHORT $LN9@Key_String
	cmp	DWORD PTR _n1$2[ebp], 57		; 00000039H
	jg	SHORT $LN9@Key_String

; 155  : 		{
; 156  : 			n1 -= '0';

	mov	eax, DWORD PTR _n1$2[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _n1$2[ebp], eax

; 157  : 		}

	jmp	SHORT $LN10@Key_String
$LN9@Key_String:

; 158  : 		else if( n1 >= 'a' && n1 <= 'f' )

	cmp	DWORD PTR _n1$2[ebp], 97		; 00000061H
	jl	SHORT $LN11@Key_String
	cmp	DWORD PTR _n1$2[ebp], 102		; 00000066H
	jg	SHORT $LN11@Key_String

; 159  : 		{
; 160  : 			n1 = n1 - 'a' + 10;

	mov	ecx, DWORD PTR _n1$2[ebp]
	sub	ecx, 87					; 00000057H
	mov	DWORD PTR _n1$2[ebp], ecx

; 161  : 		}

	jmp	SHORT $LN10@Key_String
$LN11@Key_String:

; 162  : 		else n1 = 0;

	mov	DWORD PTR _n1$2[ebp], 0
$LN10@Key_String:

; 163  : 
; 164  : 		n2 = str[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _n2$1[ebp], edx

; 165  : 		if( n2 >= '0' && n2 <= '9' )

	cmp	DWORD PTR _n2$1[ebp], 48		; 00000030H
	jl	SHORT $LN13@Key_String
	cmp	DWORD PTR _n2$1[ebp], 57		; 00000039H
	jg	SHORT $LN13@Key_String

; 166  : 		{
; 167  : 			n2 -= '0';

	mov	eax, DWORD PTR _n2$1[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _n2$1[ebp], eax

; 168  : 		}

	jmp	SHORT $LN14@Key_String
$LN13@Key_String:

; 169  : 		else if( n2 >= 'a' && n2 <= 'f' )

	cmp	DWORD PTR _n2$1[ebp], 97		; 00000061H
	jl	SHORT $LN15@Key_String
	cmp	DWORD PTR _n2$1[ebp], 102		; 00000066H
	jg	SHORT $LN15@Key_String

; 170  : 		{
; 171  : 			n2 = n2 - 'a' + 10;

	mov	ecx, DWORD PTR _n2$1[ebp]
	sub	ecx, 87					; 00000057H
	mov	DWORD PTR _n2$1[ebp], ecx

; 172  : 		}

	jmp	SHORT $LN14@Key_String
$LN15@Key_String:

; 173  : 		else n2 = 0;

	mov	DWORD PTR _n2$1[ebp], 0
$LN14@Key_String:

; 174  : 
; 175  : 		return n1 * 16 + n2;

	mov	eax, DWORD PTR _n1$2[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _n2$1[ebp]
	jmp	SHORT $LN1@Key_String
$LN8@Key_String:

; 176  : 	}
; 177  : 
; 178  : 	// scan for a text match
; 179  : 	for( kn = keynames; kn->name; kn++ )

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN4@Key_String
$LN2@Key_String:
	mov	edx, DWORD PTR _kn$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], edx
$LN4@Key_String:
	mov	eax, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Key_String

; 180  : 	{
; 181  : 		if( !Q_stricmp( str, kn->name ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _kn$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@Key_String

; 182  : 			return kn->keynum;

	mov	ecx, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN1@Key_String
$LN17@Key_String:

; 183  : 	}

	jmp	SHORT $LN2@Key_String
$LN3@Key_String:

; 184  : 
; 185  : 	return -1;

	or	eax, -1
$LN1@Key_String:

; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_StringToKeynum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv134 = -24						; size = 4
tv94 = -20						; size = 4
$T2 = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_kn$ = -4						; size = 4
_keynum$ = 8						; size = 4
_Key_KeynumToString PROC

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 198  : 	keyname_t		*kn;	
; 199  : 	static char	tinystr[5];
; 200  : 	int		i, j;
; 201  : 
; 202  : 	if ( keynum == -1 ) return "<KEY NOT FOUND>";

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN5@Key_Keynum
	mov	eax, OFFSET $SG138604
	jmp	$LN10@Key_Keynum
$LN5@Key_Keynum:

; 203  : 	if ( keynum < 0 || keynum > 255 ) return "<OUT OF RANGE>";

	cmp	DWORD PTR _keynum$[ebp], 0
	jl	SHORT $LN7@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 255		; 000000ffH
	jle	SHORT $LN6@Key_Keynum
$LN7@Key_Keynum:
	mov	eax, OFFSET $SG138607
	jmp	$LN10@Key_Keynum
$LN6@Key_Keynum:

; 204  : 
; 205  : 	// check for printable ascii (don't use quote)
; 206  : 	if( keynum > 32 && keynum < 127 && keynum != '"' && keynum != ';' && keynum != K_SCROLLOCK )

	cmp	DWORD PTR _keynum$[ebp], 32		; 00000020H
	jle	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 127		; 0000007fH
	jge	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 34		; 00000022H
	je	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 59		; 0000003bH
	je	SHORT $LN8@Key_Keynum
	cmp	DWORD PTR _keynum$[ebp], 70		; 00000046H
	je	SHORT $LN8@Key_Keynum

; 207  : 	{
; 208  : 		tinystr[0] = keynum;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _keynum$[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[ecx], dl

; 209  : 		tinystr[1] = 0;

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 5
	jae	SHORT $LN11@Key_Keynum
	jmp	SHORT $LN12@Key_Keynum
$LN11@Key_Keynum:
	call	___report_rangecheckfailure
$LN12@Key_Keynum:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], 0

; 210  : 		return tinystr;

	mov	eax, OFFSET ?tinystr@?1??Key_KeynumToString@@9@9
	jmp	$LN10@Key_Keynum
$LN8@Key_Keynum:

; 211  : 	}
; 212  : 
; 213  : 	// check for a key string
; 214  : 	for( kn = keynames; kn->name; kn++ )

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN4@Key_Keynum
$LN2@Key_Keynum:
	mov	ecx, DWORD PTR _kn$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], ecx
$LN4@Key_Keynum:
	mov	edx, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@Key_Keynum

; 215  : 	{
; 216  : 		if( keynum == kn->keynum )

	mov	eax, DWORD PTR _kn$[ebp]
	mov	ecx, DWORD PTR _keynum$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN9@Key_Keynum

; 217  : 			return kn->name;

	mov	edx, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$LN10@Key_Keynum
$LN9@Key_Keynum:

; 218  : 	}

	jmp	SHORT $LN2@Key_Keynum
$LN3@Key_Keynum:

; 219  : 
; 220  : 	// make a hex string
; 221  : 	i = keynum >> 4;

	mov	eax, DWORD PTR _keynum$[ebp]
	sar	eax, 4
	mov	DWORD PTR _i$[ebp], eax

; 222  : 	j = keynum & 15;

	mov	ecx, DWORD PTR _keynum$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _j$[ebp], ecx

; 223  : 
; 224  : 	tinystr[0] = '0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], 48 ; 00000030H

; 225  : 	tinystr[1] = 'x';

	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[ecx], 120 ; 00000078H

; 226  : 	tinystr[2] = i > 9 ? i - 10 + 'a' : i + '0';

	cmp	DWORD PTR _i$[ebp], 9
	jle	SHORT $LN13@Key_Keynum
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 87					; 00000057H
	mov	DWORD PTR tv94[ebp], edx
	jmp	SHORT $LN14@Key_Keynum
$LN13@Key_Keynum:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv94[ebp], eax
$LN14@Key_Keynum:
	mov	ecx, 1
	shl	ecx, 1
	mov	dl, BYTE PTR tv94[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[ecx], dl

; 227  : 	tinystr[3] = j > 9 ? j - 10 + 'a' : j + '0';

	cmp	DWORD PTR _j$[ebp], 9
	jle	SHORT $LN15@Key_Keynum
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 87					; 00000057H
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN16@Key_Keynum
$LN15@Key_Keynum:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv134[ebp], ecx
$LN16@Key_Keynum:
	mov	edx, 1
	imul	eax, edx, 3
	mov	cl, BYTE PTR tv134[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], cl

; 228  : 	tinystr[4] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 5
	jae	SHORT $LN17@Key_Keynum
	jmp	SHORT $LN18@Key_Keynum
$LN17@Key_Keynum:
	call	___report_rangecheckfailure
$LN18@Key_Keynum:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?tinystr@?1??Key_KeynumToString@@9@9[eax], 0

; 229  : 
; 230  : 	return tinystr;

	mov	eax, OFFSET ?tinystr@?1??Key_KeynumToString@@9@9
$LN10@Key_Keynum:

; 231  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_KeynumToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Key_ClearStates PROC

; 727  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 728  : 	int	i;
; 729  : 
; 730  : 	// don't clear keys during changelevel
; 731  : 	if( cls.changelevel ) return;

	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN5@Key_ClearS
	jmp	SHORT $LN1@Key_ClearS
$LN5@Key_ClearS:

; 732  : 
; 733  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_ClearS
$LN2@Key_ClearS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Key_ClearS:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Key_ClearS

; 734  : 	{
; 735  : 		if( keys[i].down )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	cmp	DWORD PTR _keys[ecx], 0
	je	SHORT $LN6@Key_ClearS

; 736  : 			Key_Event( i, false );

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Key_Event
	add	esp, 8
$LN6@Key_ClearS:

; 737  : 
; 738  : 		keys[i].down = 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax], 0

; 739  : 		keys[i].repeats = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _keys[ecx+8], 0

; 740  : 		keys[i].gamedown = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _keys[edx+4], 0

; 741  : 	}

	jmp	SHORT $LN2@Key_ClearS
$LN3@Key_ClearS:

; 742  : 
; 743  : 	if( clgame.hInstance )

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN1@Key_ClearS

; 744  : 		clgame.dllFuncs.IN_ClearStates();

	call	DWORD PTR _clgame+52
$LN1@Key_ClearS:

; 745  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_ClearStates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_binding$ = 12						; size = 4
_Key_SetBinding PROC

; 239  : {

	push	ebp
	mov	ebp, esp

; 240  : 	if( keynum == -1 ) return;

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN2@Key_SetBin
	jmp	SHORT $LN1@Key_SetBin
$LN2@Key_SetBin:

; 241  : 
; 242  : 	// free old bindings
; 243  : 	if( keys[keynum].binding )

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	je	SHORT $LN3@Key_SetBin

; 244  : 	{
; 245  : 		Mem_Free((char *)keys[keynum].binding );

	push	245					; 000000f5H
	push	OFFSET $SG138619
	mov	ecx, DWORD PTR _keynum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 246  : 		keys[keynum].binding = NULL;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+12], 0
$LN3@Key_SetBin:

; 247  : 	}
; 248  : 		
; 249  : 	// allocate memory for new binding
; 250  : 	keys[keynum].binding = copystring( binding );

	push	250					; 000000faH
	push	OFFSET $SG138620
	mov	ecx, DWORD PTR _binding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _keynum$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _keys[ecx+12], eax
$LN1@Key_SetBin:

; 251  : }

	pop	ebp
	ret	0
_Key_SetBinding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_Key_GetBinding PROC

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  : 	if( keynum == -1 ) return NULL;

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN2@Key_GetBin
	xor	eax, eax
	jmp	SHORT $LN1@Key_GetBin
$LN2@Key_GetBin:

; 262  : 	return keys[keynum].binding;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _keys[eax+12]
$LN1@Key_GetBin:

; 263  : }

	pop	ebp
	ret	0
_Key_GetBinding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_f$ = 8							; size = 4
_Key_WriteBindings PROC

; 417  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 418  : 	int	i;
; 419  : 
; 420  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN5@Key_WriteB
	jmp	SHORT $LN1@Key_WriteB
$LN5@Key_WriteB:

; 421  : 
; 422  : 	FS_Printf( f, "unbindall\n" );

	push	OFFSET $SG138701
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 423  : 
; 424  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Key_WriteB
$LN2@Key_WriteB:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Key_WriteB:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Key_WriteB

; 425  : 	{
; 426  : 		if( !COM_CheckString( keys[i].binding ))

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+12]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@Key_WriteB

; 427  : 			continue;

	jmp	SHORT $LN2@Key_WriteB
$LN6@Key_WriteB:

; 428  : 
; 429  : 		FS_Printf( f, "bind %s \"%s\"\n", Key_KeynumToString( i ), keys[i].binding );

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Key_KeynumToString
	add	esp, 4
	push	eax
	push	OFFSET $SG138703
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 16					; 00000010H

; 430  : 	}

	jmp	SHORT $LN2@Key_WriteB
$LN1@Key_WriteB:

; 431  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_WriteBindings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_kn$ = -4						; size = 4
_Key_Init PROC

; 465  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 466  : 	keyname_t	*kn;
; 467  : 
; 468  : 	// register our functions
; 469  : 	Cmd_AddCommand( "bind", Key_Bind_f, "binds a command to the specified key in bindmap" );

	push	OFFSET $SG138719
	push	OFFSET _Key_Bind_f
	push	OFFSET $SG138720
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 470  : 	Cmd_AddCommand( "unbind", Key_Unbind_f, "removes a command on the specified key in bindmap" );

	push	OFFSET $SG138721
	push	OFFSET _Key_Unbind_f
	push	OFFSET $SG138722
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 471  : 	Cmd_AddCommand( "unbindall", Key_Unbindall_f, "removes all commands from all keys in bindmap" );

	push	OFFSET $SG138723
	push	OFFSET _Key_Unbindall_f
	push	OFFSET $SG138724
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 472  : 	Cmd_AddCommand( "resetkeys", Key_Reset_f, "reset all keys to their default values" );

	push	OFFSET $SG138725
	push	OFFSET _Key_Reset_f
	push	OFFSET $SG138726
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 473  : 	Cmd_AddCommand( "bindlist", Key_Bindlist_f, "display current key bindings" );

	push	OFFSET $SG138727
	push	OFFSET _Key_Bindlist_f
	push	OFFSET $SG138728
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 474  : 	Cmd_AddCommand( "makehelp", Key_EnumCmds_f, "write help.txt that contains all console cvars and cmds" ); 

	push	OFFSET $SG138729
	push	OFFSET _Key_EnumCmds_f
	push	OFFSET $SG138730
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 475  : 
; 476  : 	// setup default binding. "unbindall" from config.cfg will be reset it
; 477  : 	for( kn = keynames; kn->name; kn++ ) Key_SetBinding( kn->keynum, kn->binding ); 

	mov	DWORD PTR _kn$[ebp], OFFSET _keynames
	jmp	SHORT $LN4@Key_Init
$LN2@Key_Init:
	mov	eax, DWORD PTR _kn$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _kn$[ebp], eax
$LN4@Key_Init:
	mov	ecx, DWORD PTR _kn$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Key_Init
	mov	edx, DWORD PTR _kn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _kn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Key_SetBinding
	add	esp, 8
	jmp	SHORT $LN2@Key_Init
$LN1@Key_Init:

; 478  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
tv185 = -12						; size = 4
tv181 = -8						; size = 4
_kb$ = -4						; size = 4
_key$ = 8						; size = 4
_down$ = 12						; size = 4
_Key_Event PROC

; 555  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 556  : 	const char	*kb;
; 557  : 
; 558  : 	// key was pressed before engine was run
; 559  : 	if( !keys[key].down && !down )

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax], 0
	jne	SHORT $LN4@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN4@Key_Event

; 560  : 		return;

	jmp	$LN38@Key_Event
$LN4@Key_Event:

; 561  : 
; 562  : 	kb = keys[key].binding;

	mov	ecx, DWORD PTR _key$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _keys[ecx+12]
	mov	DWORD PTR _kb$[ebp], edx

; 563  : 	keys[key].down = down;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _down$[ebp]
	mov	DWORD PTR _keys[eax], ecx

; 564  : 
; 565  : #ifdef HACKS_RELATED_HLMODS
; 566  : 	if(( cls.key_dest == key_game ) && ( cls.state == ca_cinematic ) && ( key != K_ESCAPE || !down ))

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN5@Key_Event
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN5@Key_Event
	cmp	DWORD PTR _key$[ebp], 27		; 0000001bH
	jne	SHORT $LN6@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN5@Key_Event
$LN6@Key_Event:

; 567  : 	{
; 568  : 		// only escape passed when cinematic is playing
; 569  : 		// HLFX 0.6 bug: crash in vgui3.dll while press +attack during movie playback
; 570  : 		return;

	jmp	$LN38@Key_Event
$LN5@Key_Event:

; 571  : 	}
; 572  : #endif
; 573  : 	// distribute the key down event to the apropriate handler
; 574  : 	if( cls.key_dest == key_game && ( down || keys[key].gamedown ))

	cmp	DWORD PTR _cls+36, 1
	jne	$LN9@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN8@Key_Event
	mov	edx, DWORD PTR _key$[ebp]
	shl	edx, 4
	cmp	DWORD PTR _keys[edx+4], 0
	je	SHORT $LN9@Key_Event
$LN8@Key_Event:

; 575  : 	{
; 576  : 		if( !clgame.dllFuncs.pfnKey_Event( down, key, keys[key].binding ))

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _keys[eax+12]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	call	DWORD PTR _clgame+140
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Key_Event

; 577  : 		{
; 578  : 			if( keys[key].repeats == 0 && down )

	mov	ecx, DWORD PTR _key$[ebp]
	shl	ecx, 4
	cmp	DWORD PTR _keys[ecx+8], 0
	jne	SHORT $LN10@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN10@Key_Event

; 579  : 			{
; 580  : 				keys[key].gamedown = true;

	mov	edx, DWORD PTR _key$[ebp]
	shl	edx, 4
	mov	DWORD PTR _keys[edx+4], 1
$LN10@Key_Event:

; 581  : 			}
; 582  : 
; 583  : 			if( !down )

	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN11@Key_Event

; 584  : 			{
; 585  : 				keys[key].gamedown = false;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+4], 0

; 586  : 				keys[key].repeats = 0;

	mov	ecx, DWORD PTR _key$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _keys[ecx+8], 0
$LN11@Key_Event:

; 587  : 			}
; 588  : 			return; // handled in client.dll

	jmp	$LN38@Key_Event
$LN9@Key_Event:

; 589  : 		}
; 590  : 	}
; 591  : 
; 592  : 	// update auto-repeat status
; 593  : 	if( down )

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN12@Key_Event

; 594  : 	{
; 595  : 		keys[key].repeats++;

	mov	edx, DWORD PTR _key$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _key$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _keys[ecx+8], eax

; 596  : 
; 597  : 		if( !Key_IsAllowedAutoRepeat( key ) && keys[key].repeats > 1 )

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Key_IsAllowedAutoRepeat
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@Key_Event
	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+8], 1
	jle	SHORT $LN14@Key_Event

; 598  : 		{
; 599  : 			// ignore most autorepeats
; 600  : 			return;

	jmp	$LN38@Key_Event
$LN14@Key_Event:

; 601  : 		}
; 602  : 
; 603  : 		if( key >= 200 && !kb )

	cmp	DWORD PTR _key$[ebp], 200		; 000000c8H
	jl	SHORT $LN15@Key_Event
	cmp	DWORD PTR _kb$[ebp], 0
	jne	SHORT $LN15@Key_Event

; 604  : 			Con_Printf( "%s is unbound.\n", Key_KeynumToString( key ));

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Key_KeynumToString
	add	esp, 4
	push	eax
	push	OFFSET $SG138791
	call	_Con_Printf
	add	esp, 8
$LN15@Key_Event:

; 605  : 	}

	jmp	SHORT $LN13@Key_Event
$LN12@Key_Event:

; 606  : 	else
; 607  : 	{
; 608  : 		keys[key].gamedown = false;

	mov	edx, DWORD PTR _key$[ebp]
	shl	edx, 4
	mov	DWORD PTR _keys[edx+4], 0

; 609  : 		keys[key].repeats = 0;

	mov	eax, DWORD PTR _key$[ebp]
	shl	eax, 4
	mov	DWORD PTR _keys[eax+8], 0
$LN13@Key_Event:

; 610  : 	}
; 611  : 
; 612  : 	// console key is hardcoded, so the user can never unbind it
; 613  : 	if( key == '`' || key == '~' )

	cmp	DWORD PTR _key$[ebp], 96		; 00000060H
	je	SHORT $LN17@Key_Event
	cmp	DWORD PTR _key$[ebp], 126		; 0000007eH
	jne	SHORT $LN16@Key_Event
$LN17@Key_Event:

; 614  : 	{
; 615  : 		// we are in typing mode. So don't switch to console
; 616  : 		if( (word)GetKeyboardLayout( 0 ) == (word)0x419 )

	push	0
	call	DWORD PTR __imp__GetKeyboardLayout@4
	movzx	ecx, ax
	cmp	ecx, 1049				; 00000419H
	jne	SHORT $LN19@Key_Event

; 617  : 		{
; 618  : 			if( cls.key_dest != key_game )

	cmp	DWORD PTR _cls+36, 1
	je	SHORT $LN19@Key_Event

; 619  : 				return;

	jmp	$LN38@Key_Event
$LN19@Key_Event:

; 620  :                     }
; 621  : 
; 622  : 		if( !down ) return;

	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN20@Key_Event
	jmp	$LN38@Key_Event
$LN20@Key_Event:

; 623  :     		Con_ToggleConsole_f();

	call	_Con_ToggleConsole_f

; 624  : 		return;

	jmp	$LN38@Key_Event
$LN16@Key_Event:

; 625  : 	}
; 626  : 
; 627  : 	// escape is always handled special
; 628  : 	if( key == K_ESCAPE && down )

	cmp	DWORD PTR _key$[ebp], 27		; 0000001bH
	jne	$LN2@Key_Event
	cmp	DWORD PTR _down$[ebp], 0
	je	$LN2@Key_Event

; 629  : 	{
; 630  : 		switch( cls.key_dest )

	mov	edx, DWORD PTR _cls+36
	mov	DWORD PTR tv181[ebp], edx
	cmp	DWORD PTR tv181[ebp], 3
	ja	$LN31@Key_Event
	mov	eax, DWORD PTR tv181[ebp]
	jmp	DWORD PTR $LN42@Key_Event[eax*4]
$LN22@Key_Event:

; 631  : 		{
; 632  : 		case key_game:
; 633  : 			if( CVAR_TO_BOOL( gl_showtextures ))

	cmp	DWORD PTR _gl_showtextures, 0
	je	SHORT $LN40@Key_Event
	mov	ecx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@Key_Event
	mov	DWORD PTR tv185[ebp], 1
	jmp	SHORT $LN41@Key_Event
$LN40@Key_Event:
	mov	DWORD PTR tv185[ebp], 0
$LN41@Key_Event:
	cmp	DWORD PTR tv185[ebp], 0
	je	SHORT $LN23@Key_Event

; 634  : 			{
; 635  : 				// close texture atlas
; 636  : 				Cvar_SetValue( "r_showtextures", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138801
	call	_Cvar_SetValue
	add	esp, 8

; 637  : 				return;

	jmp	$LN38@Key_Event

; 638  : 			}

	jmp	SHORT $LN25@Key_Event
$LN23@Key_Event:

; 639  : 			else if( host.mouse_visible && cls.state != ca_cinematic )

	cmp	DWORD PTR _host+34372, 0
	je	SHORT $LN25@Key_Event
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN25@Key_Event

; 640  : 			{
; 641  : 				clgame.dllFuncs.pfnKey_Event( down, key, keys[key].binding );

	mov	edx, DWORD PTR _key$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _keys[edx+12]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _down$[ebp]
	push	edx
	call	DWORD PTR _clgame+140
	add	esp, 12					; 0000000cH

; 642  : 				return; // handled in client.dll

	jmp	$LN38@Key_Event
$LN25@Key_Event:

; 643  : 			}
; 644  : 			break;

	jmp	SHORT $LN2@Key_Event
$LN26@Key_Event:

; 645  : 		case key_message:
; 646  : 			Key_Message( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_Message
	add	esp, 4

; 647  : 			return;

	jmp	$LN38@Key_Event
$LN27@Key_Event:

; 648  : 		case key_console:
; 649  : 			if( cls.state == ca_active && !cl.background )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN28@Key_Event
	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN28@Key_Event

; 650  : 				Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4
	jmp	SHORT $LN29@Key_Event
$LN28@Key_Event:

; 651  : 			else UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN29@Key_Event:

; 652  : 			return;

	jmp	$LN38@Key_Event
$LN30@Key_Event:

; 653  : 		case key_menu:
; 654  : 			UI_KeyEvent( key, true );

	push	1
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_UI_KeyEvent
	add	esp, 8

; 655  : 			return;

	jmp	$LN38@Key_Event
$LN31@Key_Event:

; 656  : 		default:	return;

	jmp	$LN38@Key_Event
$LN2@Key_Event:

; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN32@Key_Event

; 661  : 	{
; 662  : 		// only non printable keys passed
; 663  : 		UI_KeyEvent( key, down );

	mov	edx, DWORD PTR _down$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_UI_KeyEvent
	add	esp, 8

; 664  : 		return;

	jmp	SHORT $LN38@Key_Event
$LN32@Key_Event:

; 665  : 	}
; 666  : 
; 667  : 	// key up events only perform actions if the game key binding is
; 668  : 	// a button command (leading + sign).  These will be processed even in
; 669  : 	// console mode and menu mode, to keep the character from continuing 
; 670  : 	// an action started before a mode switch.
; 671  : 	if( !down )

	cmp	DWORD PTR _down$[ebp], 0
	jne	SHORT $LN33@Key_Event

; 672  : 	{
; 673  : 		Key_AddKeyCommands( key, kb, down );

	mov	ecx, DWORD PTR _down$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kb$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_AddKeyCommands
	add	esp, 12					; 0000000cH

; 674  : 		return;

	jmp	SHORT $LN38@Key_Event
$LN33@Key_Event:

; 675  : 	}
; 676  : 
; 677  : 	// distribute the key down event to the apropriate handler
; 678  : 	if( cls.key_dest == key_game )

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN34@Key_Event

; 679  : 	{
; 680  : 		Key_AddKeyCommands( key, kb, down );

	mov	ecx, DWORD PTR _down$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kb$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Key_AddKeyCommands
	add	esp, 12					; 0000000cH

; 681  : 	}

	jmp	SHORT $LN38@Key_Event
$LN34@Key_Event:

; 682  : 	else if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN36@Key_Event

; 683  : 	{
; 684  : 		Key_Console( key );

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	_Key_Console
	add	esp, 4

; 685  : 	}

	jmp	SHORT $LN38@Key_Event
$LN36@Key_Event:

; 686  : 	else if( cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN38@Key_Event

; 687  : 	{
; 688  : 		Key_Message( key );

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Key_Message
	add	esp, 4
$LN38@Key_Event:

; 689  : 	}
; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN42@Key_Event:
	DD	$LN27@Key_Event
	DD	$LN22@Key_Event
	DD	$LN30@Key_Event
	DD	$LN26@Key_Event
_Key_Event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_Key_IsBind PROC

; 122  : {

	push	ebp
	mov	ebp, esp

; 123  : 	if( keynum == -1 || !keys[keynum].binding )

	cmp	DWORD PTR _keynum$[ebp], -1
	je	SHORT $LN3@Key_IsBind
	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _keys[eax+12], 0
	jne	SHORT $LN2@Key_IsBind
$LN3@Key_IsBind:

; 124  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Key_IsBind
$LN2@Key_IsBind:

; 125  : 	return keys[keynum].binding;

	mov	ecx, DWORD PTR _keynum$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _keys[ecx+12]
$LN1@Key_IsBind:

; 126  : }

	pop	ebp
	ret	0
_Key_IsBind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\keys.c
_TEXT	SEGMENT
_keynum$ = 8						; size = 4
_Key_IsDown PROC

; 110  : {

	push	ebp
	mov	ebp, esp

; 111  : 	if( keynum == -1 )

	cmp	DWORD PTR _keynum$[ebp], -1
	jne	SHORT $LN2@Key_IsDown

; 112  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Key_IsDown
$LN2@Key_IsDown:

; 113  : 	return keys[keynum].down;

	mov	eax, DWORD PTR _keynum$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _keys[eax]
$LN1@Key_IsDown:

; 114  : }

	pop	ebp
	ret	0
_Key_IsDown ENDP
_TEXT	ENDS
END
