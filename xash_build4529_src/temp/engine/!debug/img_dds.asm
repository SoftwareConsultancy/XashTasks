; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\imagelib\img_dds.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Image_DXTGetLinearSize
PUBLIC	_Image_LoadDDS
PUBLIC	_Image_CheckDXT3Alpha
PUBLIC	_Image_CheckDXT5Alpha
PUBLIC	_Image_DXTGetPixelFormat
PUBLIC	_Image_DXTCalcMipmapSize
PUBLIC	_Image_DXTCalcSize
PUBLIC	_Image_DXTAdjustVolume
EXTRN	_memcpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Image_ValidSize:PROC
EXTRN	_Image_CheckFlag:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
$SG131899 DB	'^3Warning:^7 Image_LoadDDS: (%s) probably corrupted (%i '
	DB	'should be %i)', 0aH, 00H
	ORG $+1
$SG131928 DB	'^1Error:^7 Image_LoadDDS: (%s) have corrupted header', 0aH
	DB	00H
	ORG $+2
$SG131930 DB	'^1Error:^7 Image_LoadDDS: (%s) have corrupt pixelformat '
	DB	'header', 0aH, 00H
$SG131937 DB	'^1Error:^7 Image_LoadDDS: (%s) has unrecognized type', 0aH
	DB	00H
	ORG $+2
$SG131948 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\imagelib\img_dds.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_hdr$ = 8						; size = 4
_Image_DXTAdjustVolume PROC

; 237  : {

	push	ebp
	mov	ebp, esp

; 238  : 	if( hdr->dwDepth <= 1 )

	mov	eax, DWORD PTR _hdr$[ebp]
	cmp	DWORD PTR [eax+24], 1
	ja	SHORT $LN2@Image_DXTA

; 239  : 		return;

	jmp	SHORT $LN1@Image_DXTA
$LN2@Image_DXTA:

; 240  : 
; 241  : 	hdr->dwLinearSize = Image_DXTGetLinearSize( image.type, hdr->dwWidth, hdr->dwHeight, hdr->dwDepth );

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _image+20
	push	ecx
	call	_Image_DXTGetLinearSize
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	DWORD PTR [edx+20], eax

; 242  : 	hdr->dwFlags |= DDS_LINEARSIZE;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Image_DXTA:

; 243  : }

	pop	ebp
	ret	0
_Image_DXTAdjustVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_d$ = -16						; size = 4
_h$ = -12						; size = 4
_w$ = -8						; size = 4
_buffsize$ = -4						; size = 4
_name$ = 8						; size = 4
_hdr$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_DXTCalcSize PROC

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 200  : 	size_t buffsize = 0;

	mov	DWORD PTR _buffsize$[ebp], 0

; 201  : 	int w = image.width;

	movzx	eax, WORD PTR _image+8
	mov	DWORD PTR _w$[ebp], eax

; 202  : 	int h = image.height;

	movzx	ecx, WORD PTR _image+10
	mov	DWORD PTR _h$[ebp], ecx

; 203  : 	int d = image.depth;

	movzx	edx, WORD PTR _image+12
	mov	DWORD PTR _d$[ebp], edx

; 204  : 
; 205  : 	if( hdr->dsCaps.dwCaps2 & DDS_CUBEMAP ) 

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	and	ecx, 512				; 00000200H
	je	SHORT $LN2@Image_DXTC

; 206  : 	{
; 207  : 		// cubemap w*h always match for all sides
; 208  : 		buffsize = Image_DXTCalcMipmapSize( hdr ) * 6;

	mov	edx, DWORD PTR _hdr$[ebp]
	push	edx
	call	_Image_DXTCalcMipmapSize
	add	esp, 4
	imul	eax, eax, 6
	mov	DWORD PTR _buffsize$[ebp], eax

; 209  : 	}

	jmp	SHORT $LN3@Image_DXTC
$LN2@Image_DXTC:

; 210  : 	else if( hdr->dwFlags & DDS_MIPMAPCOUNT )

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 131072				; 00020000H
	je	SHORT $LN4@Image_DXTC

; 211  : 	{
; 212  : 		// if mipcount > 1
; 213  : 		buffsize = Image_DXTCalcMipmapSize( hdr );

	mov	eax, DWORD PTR _hdr$[ebp]
	push	eax
	call	_Image_DXTCalcMipmapSize
	add	esp, 4
	mov	DWORD PTR _buffsize$[ebp], eax

; 214  : 	}

	jmp	SHORT $LN3@Image_DXTC
$LN4@Image_DXTC:

; 215  : 	else if( hdr->dwFlags & ( DDS_LINEARSIZE|DDS_PITCH ))

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 524296				; 00080008H
	je	SHORT $LN6@Image_DXTC

; 216  : 	{
; 217  : 		// just in case (no need, really)
; 218  : 		buffsize = hdr->dwLinearSize;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _buffsize$[ebp], ecx

; 219  : 	}

	jmp	SHORT $LN3@Image_DXTC
$LN6@Image_DXTC:

; 220  : 	else 
; 221  : 	{
; 222  : 		// pretty solution for microsoft bug
; 223  : 		buffsize = Image_DXTCalcMipmapSize( hdr );

	mov	edx, DWORD PTR _hdr$[ebp]
	push	edx
	call	_Image_DXTCalcMipmapSize
	add	esp, 4
	mov	DWORD PTR _buffsize$[ebp], eax
$LN3@Image_DXTC:

; 224  : 	}
; 225  : 
; 226  : 	if( filesize != buffsize ) // main check

	mov	eax, DWORD PTR _filesize$[ebp]
	cmp	eax, DWORD PTR _buffsize$[ebp]
	je	SHORT $LN8@Image_DXTC

; 227  : 	{
; 228  : 		Con_DPrintf( S_WARN "Image_LoadDDS: (%s) probably corrupted (%i should be %i)\n", name, buffsize, filesize );

	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG131899
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 229  : 		if( buffsize > filesize )

	mov	ecx, DWORD PTR _buffsize$[ebp]
	cmp	ecx, DWORD PTR _filesize$[ebp]
	jbe	SHORT $LN8@Image_DXTC

; 230  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_DXTC
$LN8@Image_DXTC:

; 231  : 	}
; 232  : 
; 233  : 	return buffsize;

	mov	eax, DWORD PTR _buffsize$[ebp]
$LN1@Image_DXTC:

; 234  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTCalcSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_width$ = -28						; size = 4
_height$ = -24						; size = 4
tv81 = -20						; size = 4
tv75 = -16						; size = 4
tv68 = -12						; size = 4
_buffsize$ = -8						; size = 4
_i$ = -4						; size = 4
_hdr$ = 8						; size = 4
_Image_DXTCalcMipmapSize PROC

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 184  : 	size_t	buffsize = 0;

	mov	DWORD PTR _buffsize$[ebp], 0

; 185  : 	int	i, width, height;
; 186  : 		
; 187  : 	// now correct buffer size
; 188  : 	for( i = 0; i < Q_max( 1, ( hdr->dwMipMapCount )); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_DXTC
$LN2@Image_DXTC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_DXTC:
	mov	ecx, DWORD PTR _hdr$[ebp]
	cmp	DWORD PTR [ecx+28], 1
	jae	SHORT $LN6@Image_DXTC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN7@Image_DXTC
$LN6@Image_DXTC:
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR tv68[ebp], eax
$LN7@Image_DXTC:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR tv68[ebp]
	jae	$LN3@Image_DXTC

; 189  : 	{
; 190  : 		width = Q_max( 1, ( hdr->dwWidth >> i ));

	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	eax, cl
	cmp	eax, 1
	jae	SHORT $LN8@Image_DXTC
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN9@Image_DXTC
$LN8@Image_DXTC:
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	mov	DWORD PTR tv75[ebp], edx
$LN9@Image_DXTC:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 191  : 		height = Q_max( 1, ( hdr->dwHeight >> i ));

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	cmp	edx, 1
	jae	SHORT $LN10@Image_DXTC
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN11@Image_DXTC
$LN10@Image_DXTC:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	mov	DWORD PTR tv81[ebp], edx
$LN11@Image_DXTC:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 192  : 		buffsize += Image_DXTGetLinearSize( image.type, width, height, image.depth );

	movzx	ecx, WORD PTR _image+12
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+20
	push	ecx
	call	_Image_DXTGetLinearSize
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _buffsize$[ebp]
	mov	DWORD PTR _buffsize$[ebp], eax

; 193  : 	}

	jmp	$LN2@Image_DXTC
$LN3@Image_DXTC:

; 194  : 
; 195  : 	return buffsize;

	mov	eax, DWORD PTR _buffsize$[ebp]

; 196  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTCalcMipmapSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_bits$ = -12						; size = 4
tv89 = -8						; size = 4
tv73 = -4						; size = 4
_hdr$ = 8						; size = 4
_Image_DXTGetPixelFormat PROC

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 95   : 	uint bits = hdr->dsPixelFormat.dwRGBBitCount;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _bits$[ebp], ecx

; 96   : 
; 97   : 	if( !FBitSet( hdr->dsCaps.dwCaps2, DDS_VOLUME ))

	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+112]
	and	eax, 2097152				; 00200000H
	jne	SHORT $LN6@Image_DXTG

; 98   : 		hdr->dwDepth = 1;

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	DWORD PTR [ecx+24], 1
$LN6@Image_DXTG:

; 99   : 
; 100  : 	if( FBitSet( hdr->dsPixelFormat.dwFlags, DDS_FOURCC ))

	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 4
	je	$LN7@Image_DXTG

; 101  : 	{
; 102  : 		switch( hdr->dsPixelFormat.dwFourCC )

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 861165636		; 33545844H
	ja	SHORT $LN27@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 861165636		; 33545844H
	je	SHORT $LN11@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 827611204		; 31545844H
	je	SHORT $LN9@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 843666497		; 32495441H
	je	SHORT $LN14@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 844388420		; 32545844H
	je	SHORT $LN10@Image_DXTG
	jmp	SHORT $LN15@Image_DXTG
$LN27@Image_DXTG:
	cmp	DWORD PTR tv73[ebp], 877942852		; 34545844H
	je	SHORT $LN12@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 894720068		; 35545844H
	je	SHORT $LN13@Image_DXTG
	jmp	SHORT $LN15@Image_DXTG
$LN9@Image_DXTG:

; 103  : 		{
; 104  : 		case TYPE_DXT1: 
; 105  : 			image.type = PF_DXT1;

	mov	DWORD PTR _image+20, 8

; 106  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN10@Image_DXTG:

; 107  : 		case TYPE_DXT2:
; 108  : 			image.flags &= ~IMAGE_HAS_ALPHA; // alpha is already premultiplied by color

	mov	eax, DWORD PTR _image+24
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _image+24, eax
$LN11@Image_DXTG:

; 109  : 		case TYPE_DXT3:
; 110  : 			image.type = PF_DXT3;

	mov	DWORD PTR _image+20, 9

; 111  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN12@Image_DXTG:

; 112  : 		case TYPE_DXT4:
; 113  : 			image.flags &= ~IMAGE_HAS_ALPHA; // alpha is already premultiplied by color

	mov	ecx, DWORD PTR _image+24
	and	ecx, -3					; fffffffdH
	mov	DWORD PTR _image+24, ecx
$LN13@Image_DXTG:

; 114  : 		case TYPE_DXT5:
; 115  : 			image.type = PF_DXT5;

	mov	DWORD PTR _image+20, 10			; 0000000aH

; 116  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN14@Image_DXTG:

; 117  : 		case TYPE_ATI2:
; 118  : 			image.type = PF_ATI2;

	mov	DWORD PTR _image+20, 11			; 0000000bH

; 119  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN15@Image_DXTG:

; 120  : 		default:
; 121  : 			image.type = PF_UNKNOWN; // assume error

	mov	DWORD PTR _image+20, 0
$LN2@Image_DXTG:

; 122  : 			break;
; 123  : 		}
; 124  : 	}

	jmp	SHORT $LN8@Image_DXTG
$LN7@Image_DXTG:

; 125  : 	else
; 126  : 	{
; 127  : 		// this dds texture isn't compressed so write out ARGB or luminance format
; 128  : 		if( hdr->dsPixelFormat.dwFlags & DDS_DUDV )

	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 524288				; 00080000H
	je	SHORT $LN16@Image_DXTG

; 129  : 		{
; 130  : 			image.type = PF_UNKNOWN; // assume error

	mov	DWORD PTR _image+20, 0

; 131  : 		}

	jmp	SHORT $LN8@Image_DXTG
$LN16@Image_DXTG:

; 132  : 		else if( hdr->dsPixelFormat.dwFlags & DDS_LUMINANCE )

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 131072				; 00020000H
	je	SHORT $LN18@Image_DXTG

; 133  : 		{
; 134  : 			image.type = PF_UNKNOWN; // assume error

	mov	DWORD PTR _image+20, 0

; 135  : 		}

	jmp	SHORT $LN8@Image_DXTG
$LN18@Image_DXTG:

; 136  : 		else 
; 137  : 		{
; 138  : 			switch( bits )

	mov	eax, DWORD PTR _bits$[ebp]
	mov	DWORD PTR tv89[ebp], eax
	cmp	DWORD PTR tv89[ebp], 8
	je	SHORT $LN22@Image_DXTG
	cmp	DWORD PTR tv89[ebp], 24			; 00000018H
	je	SHORT $LN21@Image_DXTG
	cmp	DWORD PTR tv89[ebp], 32			; 00000020H
	je	SHORT $LN20@Image_DXTG
	jmp	SHORT $LN23@Image_DXTG
$LN20@Image_DXTG:

; 139  : 			{
; 140  : 			case 32:
; 141  : 				image.type = PF_BGRA_32;

	mov	DWORD PTR _image+20, 4

; 142  : 				break;

	jmp	SHORT $LN8@Image_DXTG
$LN21@Image_DXTG:

; 143  : 			case 24:
; 144  : 				image.type = PF_BGR_24;

	mov	DWORD PTR _image+20, 6

; 145  : 				break;

	jmp	SHORT $LN8@Image_DXTG
$LN22@Image_DXTG:

; 146  : 			case 8:
; 147  : 				image.type = PF_LUMINANCE;

	mov	DWORD PTR _image+20, 7

; 148  : 				break;

	jmp	SHORT $LN8@Image_DXTG
$LN23@Image_DXTG:

; 149  : 			default:
; 150  : 				image.type = PF_UNKNOWN;

	mov	DWORD PTR _image+20, 0
$LN8@Image_DXTG:

; 151  : 				break;
; 152  : 			}
; 153  : 		}
; 154  : 	}
; 155  : 
; 156  : 	// setup additional flags
; 157  : 	if( hdr->dsCaps.dwCaps1 & DDS_COMPLEX && hdr->dsCaps.dwCaps2 & DDS_CUBEMAP )

	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	and	edx, 8
	je	SHORT $LN24@Image_DXTG
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	and	ecx, 512				; 00000200H
	je	SHORT $LN24@Image_DXTG

; 158  : 		image.flags |= IMAGE_CUBEMAP;

	mov	edx, DWORD PTR _image+24
	or	edx, 1
	mov	DWORD PTR _image+24, edx
$LN24@Image_DXTG:

; 159  : 
; 160  : 	if( hdr->dwFlags & DDS_MIPMAPCOUNT )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN1@Image_DXTG

; 161  : 		image.num_mips = hdr->dwMipMapCount; // get actual mip count

	mov	edx, DWORD PTR _hdr$[ebp]
	mov	al, BYTE PTR [edx+28]
	mov	BYTE PTR _image+14, al
$LN1@Image_DXTG:

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTGetPixelFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_bitmask$ = -28						; size = 4
_bits$ = -24						; size = 4
_alphamask$ = -20					; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_hdr$ = 8						; size = 4
_fin$ = 12						; size = 4
_Image_CheckDXT5Alpha PROC

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 54   : 	uint	bits, bitmask;
; 55   : 	byte	*alphamask; 
; 56   : 	int	x, y, i, j; 
; 57   : 
; 58   : 	for( y = 0; y < hdr->dwHeight; y += 4 )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN4@Image_Chec
$LN2@Image_Chec:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	mov	DWORD PTR _y$[ebp], eax
$LN4@Image_Chec:
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	$LN3@Image_Chec

; 59   : 	{
; 60   : 		for( x = 0; x < hdr->dwWidth; x += 4 )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@Image_Chec
$LN5@Image_Chec:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 4
	mov	DWORD PTR _x$[ebp], eax
$LN7@Image_Chec:
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jae	$LN6@Image_Chec

; 61   : 		{
; 62   : 			if( y >= hdr->dwHeight || x >= hdr->dwWidth )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN15@Image_Chec
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jb	SHORT $LN14@Image_Chec
$LN15@Image_Chec:

; 63   : 				break;

	jmp	$LN6@Image_Chec
$LN14@Image_Chec:

; 64   : 
; 65   : 			alphamask = fin + 2;

	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, 2
	mov	DWORD PTR _alphamask$[ebp], ecx

; 66   : 			fin += 8;

	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, 8
	mov	DWORD PTR _fin$[ebp], edx

; 67   : 
; 68   : 			bitmask = ((uint *)fin)[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fin$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _bitmask$[ebp], edx

; 69   : 			fin += 8;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _fin$[ebp], eax

; 70   : 
; 71   : 			// last three bytes
; 72   : 			bits = (alphamask[3]) | (alphamask[4] << 8) | (alphamask[5] << 16);

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _alphamask$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _alphamask$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 8
	or	ecx, edx
	mov	eax, 1
	imul	edx, eax, 5
	mov	eax, DWORD PTR _alphamask$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	shl	edx, 16					; 00000010H
	or	ecx, edx
	mov	DWORD PTR _bits$[ebp], ecx

; 73   : 
; 74   : 			for( j = 2; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 2
	jmp	SHORT $LN10@Image_Chec
$LN8@Image_Chec:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Image_Chec:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Image_Chec

; 75   : 			{
; 76   : 				for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Chec
$LN11@Image_Chec:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@Image_Chec:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN12@Image_Chec

; 77   : 				{
; 78   : 					// only put pixels out < width or height
; 79   : 					if((( x + i ) < hdr->dwWidth ) && (( y + j ) < hdr->dwHeight ))

	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _hdr$[ebp]
	cmp	edx, DWORD PTR [eax+16]
	jae	SHORT $LN16@Image_Chec
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _hdr$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jae	SHORT $LN16@Image_Chec

; 80   : 					{
; 81   : 						if( bits & 0x07 )

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 7
	je	SHORT $LN16@Image_Chec

; 82   : 							return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN16@Image_Chec:

; 83   : 					}
; 84   : 					bits >>= 3;

	mov	ecx, DWORD PTR _bits$[ebp]
	shr	ecx, 3
	mov	DWORD PTR _bits$[ebp], ecx

; 85   : 				}

	jmp	SHORT $LN11@Image_Chec
$LN12@Image_Chec:

; 86   : 			}

	jmp	SHORT $LN8@Image_Chec
$LN9@Image_Chec:

; 87   : 		}

	jmp	$LN5@Image_Chec
$LN6@Image_Chec:

; 88   : 	}

	jmp	$LN2@Image_Chec
$LN3@Image_Chec:

; 89   : 
; 90   : 	return false;

	xor	eax, eax
$LN1@Image_Chec:

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckDXT5Alpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_alpha$ = -24						; size = 4
_y$ = -20						; size = 4
_i$ = -16						; size = 4
_x$ = -12						; size = 4
_j$ = -8						; size = 4
_sAlpha$ = -4						; size = 2
_hdr$ = 8						; size = 4
_fin$ = 12						; size = 4
_Image_CheckDXT3Alpha PROC

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 21   : 	word	sAlpha;
; 22   : 	byte	*alpha; 
; 23   : 	int	x, y, i, j; 
; 24   : 
; 25   : 	for( y = 0; y < hdr->dwHeight; y += 4 )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN4@Image_Chec
$LN2@Image_Chec:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	mov	DWORD PTR _y$[ebp], eax
$LN4@Image_Chec:
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	$LN3@Image_Chec

; 26   : 	{
; 27   : 		for( x = 0; x < hdr->dwWidth; x += 4 )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@Image_Chec
$LN5@Image_Chec:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 4
	mov	DWORD PTR _x$[ebp], eax
$LN7@Image_Chec:
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jae	$LN6@Image_Chec

; 28   : 		{
; 29   : 			alpha = fin + 8;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _alpha$[ebp], eax

; 30   : 			fin += 16;

	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _fin$[ebp], ecx

; 31   : 
; 32   : 			for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Image_Chec
$LN8@Image_Chec:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN10@Image_Chec:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Image_Chec

; 33   : 			{
; 34   : 				sAlpha = alpha[2*j] + 256 * alpha[2*j+1];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _alpha$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _alpha$[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	shl	eax, 8
	add	edx, eax
	mov	WORD PTR _sAlpha$[ebp], dx

; 35   : 
; 36   : 				for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Chec
$LN11@Image_Chec:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@Image_Chec:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN12@Image_Chec

; 37   : 				{
; 38   : 					if((( x + i ) < hdr->dwWidth ) && (( y + j ) < hdr->dwHeight ))

	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _hdr$[ebp]
	cmp	edx, DWORD PTR [eax+16]
	jae	SHORT $LN14@Image_Chec
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _hdr$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jae	SHORT $LN14@Image_Chec

; 39   : 					{
; 40   : 						if( sAlpha == 0 )

	movzx	eax, WORD PTR _sAlpha$[ebp]
	test	eax, eax
	jne	SHORT $LN14@Image_Chec

; 41   : 							return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN14@Image_Chec:

; 42   : 					}
; 43   : 					sAlpha >>= 4;

	mov	cx, WORD PTR _sAlpha$[ebp]
	shr	cx, 4
	mov	WORD PTR _sAlpha$[ebp], cx

; 44   : 				}

	jmp	SHORT $LN11@Image_Chec
$LN12@Image_Chec:

; 45   : 			}

	jmp	SHORT $LN8@Image_Chec
$LN9@Image_Chec:

; 46   : 		}

	jmp	$LN5@Image_Chec
$LN6@Image_Chec:

; 47   : 	}

	jmp	$LN2@Image_Chec
$LN3@Image_Chec:

; 48   : 
; 49   : 	return false;

	xor	eax, eax
$LN1@Image_Chec:

; 50   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckDXT3Alpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
_fin$ = -140						; size = 4
tv134 = -136						; size = 4
_header$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadDDS PROC

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 252  : 	dds_t	header;
; 253  : 	byte	*fin;
; 254  : 
; 255  : 	if( filesize < sizeof( dds_t ))

	cmp	DWORD PTR _filesize$[ebp], 128		; 00000080H
	jae	SHORT $LN4@Image_Load

; 256  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN4@Image_Load:

; 257  : 
; 258  : 	memcpy( &header, buffer, sizeof( dds_t ));

	push	128					; 00000080H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 259  : 
; 260  : 	if( header.dwIdent != DDSHEADER )

	cmp	DWORD PTR _header$[ebp], 542327876	; 20534444H
	je	SHORT $LN5@Image_Load

; 261  : 		return false; // it's not a dds file, just skip it

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN5@Image_Load:

; 262  : 
; 263  : 	if( header.dwSize != sizeof( dds_t ) - sizeof( uint )) // size of the structure (minus MagicNum)

	cmp	DWORD PTR _header$[ebp+4], 124		; 0000007cH
	je	SHORT $LN6@Image_Load

; 264  : 	{
; 265  : 		Con_DPrintf( S_ERROR "Image_LoadDDS: (%s) have corrupted header\n", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG131928
	call	_Con_DPrintf
	add	esp, 8

; 266  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN6@Image_Load:

; 267  : 	}
; 268  : 
; 269  : 	if( header.dsPixelFormat.dwSize != sizeof( dds_pixf_t )) // size of the structure

	cmp	DWORD PTR _header$[ebp+76], 32		; 00000020H
	je	SHORT $LN7@Image_Load

; 270  : 	{
; 271  : 		Con_DPrintf( S_ERROR "Image_LoadDDS: (%s) have corrupt pixelformat header\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG131930
	call	_Con_DPrintf
	add	esp, 8

; 272  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN7@Image_Load:

; 273  : 	}
; 274  : 
; 275  : 	image.width = header.dwWidth;

	mov	cx, WORD PTR _header$[ebp+16]
	mov	WORD PTR _image+8, cx

; 276  : 	image.height = header.dwHeight;

	mov	dx, WORD PTR _header$[ebp+12]
	mov	WORD PTR _image+10, dx

; 277  : 
; 278  : 	if( header.dwFlags & DDS_DEPTH )

	mov	eax, DWORD PTR _header$[ebp+8]
	and	eax, 8388608				; 00800000H
	je	SHORT $LN8@Image_Load

; 279  : 		image.depth = header.dwDepth;

	mov	cx, WORD PTR _header$[ebp+24]
	mov	WORD PTR _image+12, cx
	jmp	SHORT $LN9@Image_Load
$LN8@Image_Load:

; 280  : 	else image.depth = 1;

	mov	edx, 1
	mov	WORD PTR _image+12, dx
$LN9@Image_Load:

; 281  : 
; 282  : 	if( !Image_ValidSize( name )) return false;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN10@Image_Load:

; 283  : 
; 284  : 	Image_DXTGetPixelFormat( &header ); // and image type too :)

	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_Image_DXTGetPixelFormat
	add	esp, 4

; 285  : 	Image_DXTAdjustVolume( &header );

	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	call	_Image_DXTAdjustVolume
	add	esp, 4

; 286  : 
; 287  : 	if( !Image_CheckFlag( IL_DDS_HARDWARE ) && ImageDXT( image.type ))

	push	16					; 00000010H
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@Image_Load
	cmp	DWORD PTR _image+20, 8
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR _image+20, 9
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR _image+20, 10			; 0000000aH
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR _image+20, 11			; 0000000bH
	jne	SHORT $LN11@Image_Load
$LN12@Image_Load:

; 288  : 		return false; // silently rejected

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN11@Image_Load:

; 289  : 
; 290  : 	if( image.type == PF_UNKNOWN ) 

	cmp	DWORD PTR _image+20, 0
	jne	SHORT $LN13@Image_Load

; 291  : 	{
; 292  : 		Con_DPrintf( S_ERROR "Image_LoadDDS: (%s) has unrecognized type\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG131937
	call	_Con_DPrintf
	add	esp, 8

; 293  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN13@Image_Load:

; 294  : 	}
; 295  : 
; 296  : 	image.size = Image_DXTCalcSize( name, &header, filesize - 128 ); 

	mov	ecx, DWORD PTR _filesize$[ebp]
	sub	ecx, 128				; 00000080H
	push	ecx
	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_DXTCalcSize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _image+28, eax

; 297  : 	if( image.size == 0 ) return false; // just in case

	cmp	DWORD PTR _image+28, 0
	jne	SHORT $LN14@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN14@Image_Load:

; 298  : 	fin = (byte *)(buffer + sizeof( dds_t ));

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR _fin$[ebp], ecx

; 299  : 
; 300  : 	// copy an encode method
; 301  : 	image.encode = (word)header.dwReserved1[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	cx, WORD PTR _header$[ebp+eax+36]
	mov	WORD PTR _image+16, cx

; 302  : 
; 303  : 	switch( image.encode )

	movzx	edx, WORD PTR _image+16
	mov	DWORD PTR tv134[ebp], edx
	cmp	DWORD PTR tv134[ebp], 6657		; 00001a01H
	je	SHORT $LN15@Image_Load
	cmp	DWORD PTR tv134[ebp], 6660		; 00001a04H
	jle	SHORT $LN17@Image_Load
	cmp	DWORD PTR tv134[ebp], 6665		; 00001a09H
	jle	SHORT $LN16@Image_Load
	jmp	SHORT $LN17@Image_Load
$LN15@Image_Load:

; 304  : 	{
; 305  : 	case DXT_ENCODE_COLOR_YCoCg:
; 306  : 		SetBits( image.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax

; 307  : 		break;

	jmp	$LN2@Image_Load
$LN16@Image_Load:

; 308  : 	case DXT_ENCODE_NORMAL_AG_ORTHO:
; 309  : 	case DXT_ENCODE_NORMAL_AG_STEREO:
; 310  : 	case DXT_ENCODE_NORMAL_AG_PARABOLOID:
; 311  : 	case DXT_ENCODE_NORMAL_AG_QUARTIC:
; 312  : 	case DXT_ENCODE_NORMAL_AG_AZIMUTHAL:
; 313  : 		SetBits( image.flags, IMAGE_HAS_COLOR );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 4
	mov	DWORD PTR _image+24, ecx

; 314  : 		break;

	jmp	SHORT $LN2@Image_Load
$LN17@Image_Load:

; 315  : 	default:	// check for real alpha-pixels
; 316  : 		if( image.type == PF_DXT3 && Image_CheckDXT3Alpha( &header, fin ))

	cmp	DWORD PTR _image+20, 9
	jne	SHORT $LN18@Image_Load
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_Image_CheckDXT3Alpha
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@Image_Load

; 317  : 			SetBits( image.flags, IMAGE_HAS_ALPHA );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 2
	mov	DWORD PTR _image+24, ecx
	jmp	SHORT $LN19@Image_Load
$LN18@Image_Load:

; 318  : 		else if( image.type == PF_DXT5 && Image_CheckDXT5Alpha( &header, fin ))

	cmp	DWORD PTR _image+20, 10			; 0000000aH
	jne	SHORT $LN19@Image_Load
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_Image_CheckDXT5Alpha
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@Image_Load

; 319  : 			SetBits( image.flags, IMAGE_HAS_ALPHA );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 2
	mov	DWORD PTR _image+24, ecx
$LN19@Image_Load:

; 320  : 		if( !FBitSet( header.dsPixelFormat.dwFlags, DDS_LUMINANCE ))

	mov	edx, DWORD PTR _header$[ebp+80]
	and	edx, 131072				; 00020000H
	jne	SHORT $LN2@Image_Load

; 321  : 			SetBits( image.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax
$LN2@Image_Load:

; 322  : 		break;
; 323  : 	}
; 324  : 
; 325  : 	if( image.type == PF_LUMINANCE )

	cmp	DWORD PTR _image+20, 7
	jne	SHORT $LN22@Image_Load

; 326  : 		ClearBits( image.flags, IMAGE_HAS_COLOR|IMAGE_HAS_ALPHA );

	mov	ecx, DWORD PTR _image+24
	and	ecx, -7					; fffffff9H
	mov	DWORD PTR _image+24, ecx
$LN22@Image_Load:

; 327  : 
; 328  : 	if( header.dwReserved1[1] != 0 )

	mov	edx, 4
	shl	edx, 0
	cmp	DWORD PTR _header$[ebp+edx+36], 0
	je	$LN23@Image_Load

; 329  : 	{
; 330  : 		// store texture reflectivity
; 331  : 		image.fogParams[0] = ((header.dwReserved1[1] & 0x000000FF) >> 0 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _header$[ebp+eax+36]
	and	ecx, 255				; 000000ffH
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _image[eax+76], cl

; 332  : 		image.fogParams[1] = ((header.dwReserved1[1] & 0x0000FF00) >> 8 );

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _header$[ebp+ecx+36]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _image[eax+76], dl

; 333  : 		image.fogParams[2] = ((header.dwReserved1[1] & 0x00FF0000) >> 16);

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _header$[ebp+ecx+36]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _image[eax+76], dl

; 334  : 		image.fogParams[3] = ((header.dwReserved1[1] & 0xFF000000) >> 24);

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _header$[ebp+ecx+36]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _image[ecx+76], dl
$LN23@Image_Load:

; 335  : 	}
; 336  : 
; 337  : 	// dds files will be uncompressed on a render. requires minimal of info for set this
; 338  : 	image.rgba = Mem_Malloc( host.imagepool, image.size ); 

	push	338					; 00000152H
	push	OFFSET $SG131948
	push	0
	mov	edx, DWORD PTR _image+28
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax

; 339  : 	memcpy( image.rgba, fin, image.size );

	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+40
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 340  : 	SetBits( image.flags, IMAGE_DDS_FORMAT );

	mov	ecx, DWORD PTR _image+24
	or	ecx, 128				; 00000080H
	mov	DWORD PTR _image+24, ecx

; 341  : 
; 342  : 	return true;

	mov	eax, 1
$LN1@Image_Load:

; 343  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LoadDDS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\imagelib\img_dds.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_type$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_Image_DXTGetLinearSize PROC

; 165  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 166  : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 8
	ja	$LN2@Image_DXTG
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@Image_DXTG[edx*4]
$LN4@Image_DXTG:

; 167  : 	{
; 168  : 	case PF_DXT1: return ((( width + 3 ) / 4 ) * (( height + 3 ) / 4 ) * depth * 8 );

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2
	mov	eax, DWORD PTR _height$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	ecx, eax
	imul	ecx, DWORD PTR _depth$[ebp]
	shl	ecx, 3
	mov	eax, ecx
	jmp	SHORT $LN1@Image_DXTG
$LN5@Image_DXTG:

; 169  : 	case PF_DXT3:
; 170  : 	case PF_DXT5:
; 171  : 	case PF_ATI2: return ((( width + 3 ) / 4 ) * (( height + 3 ) / 4 ) * depth * 16 );

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2
	mov	eax, DWORD PTR _height$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	ecx, eax
	imul	ecx, DWORD PTR _depth$[ebp]
	shl	ecx, 4
	mov	eax, ecx
	jmp	SHORT $LN1@Image_DXTG
$LN6@Image_DXTG:

; 172  : 	case PF_LUMINANCE: return (width * height * depth);

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	jmp	SHORT $LN1@Image_DXTG
$LN7@Image_DXTG:

; 173  : 	case PF_BGR_24:
; 174  : 	case PF_RGB_24: return (width * height * depth * 3);

	mov	edx, DWORD PTR _width$[ebp]
	imul	edx, DWORD PTR _height$[ebp]
	imul	edx, DWORD PTR _depth$[ebp]
	imul	eax, edx, 3
	jmp	SHORT $LN1@Image_DXTG
$LN8@Image_DXTG:

; 175  : 	case PF_BGRA_32:
; 176  : 	case PF_RGBA_32: return (width * height * depth * 4);

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	jmp	SHORT $LN1@Image_DXTG
$LN2@Image_DXTG:

; 177  : 	}	
; 178  : 
; 179  : 	return 0;

	xor	eax, eax
$LN1@Image_DXTG:

; 180  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Image_DXTG:
	DD	$LN8@Image_DXTG
	DD	$LN8@Image_DXTG
	DD	$LN7@Image_DXTG
	DD	$LN7@Image_DXTG
	DD	$LN6@Image_DXTG
	DD	$LN4@Image_DXTG
	DD	$LN5@Image_DXTG
	DD	$LN5@Image_DXTG
	DD	$LN5@Image_DXTG
_Image_DXTGetLinearSize ENDP
_TEXT	ENDS
END
