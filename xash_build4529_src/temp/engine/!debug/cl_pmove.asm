; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\client\cl_pmove.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CL_ClipPMoveToEntity
PUBLIC	_CL_SetSolidEntities
PUBLIC	_CL_SetSolidPlayers
PUBLIC	_CL_InitClientMove
PUBLIC	_CL_PredictMovement
PUBLIC	_CL_CheckPredictionError
PUBLIC	_CL_IsPredicted
PUBLIC	_CL_WaterEntity
PUBLIC	_CL_GetWaterEntity
PUBLIC	_CL_SetupPMove
PUBLIC	_CL_TestLine
PUBLIC	_CL_VisTraceLine
PUBLIC	_CL_TraceLine
PUBLIC	_CL_PushTraceBounds
PUBLIC	_CL_PopTraceBounds
PUBLIC	_CL_MoveSpectatorCamera
PUBLIC	_CL_SetLastUpdate
PUBLIC	_CL_RedoPrediction
PUBLIC	_CL_ClearPhysEnts
PUBLIC	_CL_PushPMStates
PUBLIC	_CL_PopPMStates
PUBLIC	_CL_SetUpPlayerPrediction
PUBLIC	_CL_SetIdealPitch
PUBLIC	_CL_PlayerTeleported
PUBLIC	_CL_AddLinksToPmove
PUBLIC	_CL_FinishPMove
PUBLIC	_CL_RunUsercmd
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4059000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41400000
PUBLIC	__real@42800000
PUBLIC	__real@43200000
PUBLIC	__real@43b40000
PUBLIC	__real@447a0000
PUBLIC	__real@bdcccccd
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileSize:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_MemFgets:PROC
EXTRN	_pfnGetModelBounds:PROC
EXTRN	_pfnGetModelType:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_LoadFile:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_CL_Particle:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_sqrt:PROC
EXTRN	_SinCos:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_CL_DemoInterpolateAngles:PROC
EXTRN	_CL_PlaybackEvent:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_ComputePlayerOrigin:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_Pmove_Init:PROC
EXTRN	_PM_HullForBsp:PROC
EXTRN	_PM_RecursiveHullCheck:PROC
EXTRN	_PM_PlayerTraceExt:PROC
EXTRN	_PM_TestPlayerPosition:PROC
EXTRN	_PM_HullPointContents:PROC
EXTRN	_PM_TruePointContents:PROC
EXTRN	_PM_PointContents:PROC
EXTRN	_PM_TraceTexture:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_PM_TestLineExt:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtoui3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memcpy:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_nopred:DWORD
EXTRN	_cl_showerror:DWORD
EXTRN	_cl_nosmooth:DWORD
EXTRN	_cl_smoothtime:DWORD
EXTRN	_cl_solid_players:DWORD
EXTRN	_cl_idealpitchscale:DWORD
EXTRN	_cl_lw:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?pos@?1??CL_CheckPredictionError@@9@9 DD 01H DUP (?)	; `CL_CheckPredictionError'::`2'::pos
?tr@?1??CL_VisTraceLine@@9@9 DB 044H DUP (?)		; `CL_VisTraceLine'::`2'::tr
?tr@?1??pfnTraceLine@@9@9 DB 044H DUP (?)		; `pfnTraceLine'::`2'::tr
?tr@?1??pfnTraceLineEx@@9@9 DB 044H DUP (?)		; `pfnTraceLineEx'::`2'::tr
_BSS	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43200000
CONST	SEGMENT
__real@43200000 DD 043200000r			; 160
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG139608 DB	'^3player teleported:^7 %.3f units', 0aH, 00H
	ORG $+1
$SG139610 DB	'^1prediction error:^7 %.3f units', 0aH, 00H
	ORG $+2
$SG139645 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_pmove.c', 00H
	ORG $+3
$SG139646 DB	'tr != NULL', 00H
	ORG $+1
$SG139663 DB	'player %i', 00H
	ORG $+2
$SG139991 DB	'CL: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g'
	DB	0aH, 00H
	ORG $+2
$SG140109 DB	'0.1', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_temp$ = -6556						; size = 6448
_cmd$ = -108						; size = 52
_split$ = -56						; size = 52
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_u$ = 16						; size = 4
_runfuncs$ = 20						; size = 4
_time$ = 24						; size = 4
_random_seed$ = 28					; size = 4
_CL_RunUsercmd PROC

; 1092 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 6556				; 0000199cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1093 : 	usercmd_t		cmd;
; 1094 : 	local_state_t	temp;
; 1095 : 	usercmd_t		split;
; 1096 : 
; 1097 : 	memset( &temp, 0, sizeof( temp ));

	push	6448					; 00001930H
	push	0
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1098 : 
; 1099 : 	if( u->msec > 50 )

	mov	ecx, DWORD PTR _u$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cmp	edx, 50					; 00000032H
	jle	SHORT $LN2@CL_RunUser

; 1100 : 	{
; 1101 : 		split = *u;

	mov	ecx, 13					; 0000000dH
	mov	esi, DWORD PTR _u$[ebp]
	lea	edi, DWORD PTR _split$[ebp]
	rep movsd

; 1102 : 		split.msec /= 2;

	movzx	eax, BYTE PTR _split$[ebp+2]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _split$[ebp+2], al

; 1103 : 		CL_RunUsercmd( from, &temp, &split, runfuncs, time, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _runfuncs$[ebp]
	push	edx
	lea	eax, DWORD PTR _split$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1104 : 		split.impulse = split.weaponselect = 0;

	mov	BYTE PTR _split$[ebp+33], 0
	mov	al, BYTE PTR _split$[ebp+33]
	mov	BYTE PTR _split$[ebp+32], al

; 1105 : 		CL_RunUsercmd( &temp, to, &split, runfuncs, time, random_seed );

	mov	ecx, DWORD PTR _random_seed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _time$[ebp]
	push	edx
	mov	eax, DWORD PTR _runfuncs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _split$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1106 : 		return;

	jmp	$LN1@CL_RunUser
$LN2@CL_RunUser:

; 1107 : 	}
; 1108 : 
; 1109 : 	cmd = *u;	// deal with local copy

	mov	ecx, 13					; 0000000dH
	mov	esi, DWORD PTR _u$[ebp]
	lea	edi, DWORD PTR _cmd$[ebp]
	rep movsd

; 1110 : 	*to = *from;

	push	6448					; 00001930H
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1111 : 
; 1112 : 	if( CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	je	$LN5@CL_RunUser

; 1113 : 	{
; 1114 : 		// setup playermove state
; 1115 : 		CL_SetupPMove( clgame.pmove, from, &cmd, runfuncs, *time );

	mov	eax, DWORD PTR _time$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _runfuncs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	call	_CL_SetupPMove
	add	esp, 24					; 00000018H

; 1116 : 
; 1117 : 		// motor!
; 1118 : 		clgame.dllFuncs.pfnPlayerMove( clgame.pmove, false );

	push	0
	mov	edx, DWORD PTR _clgame+1316
	push	edx
	call	DWORD PTR _clgame+28
	add	esp, 8

; 1119 : 
; 1120 : 		// copy results back to client
; 1121 : 		CL_FinishPMove( clgame.pmove, to );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	call	_CL_FinishPMove
	add	esp, 8

; 1122 : 
; 1123 : 		if( clgame.pmove->onground > 0 && clgame.pmove->onground < clgame.pmove->numphysent )

	mov	edx, DWORD PTR _clgame+1316
	cmp	DWORD PTR [edx+224], 0
	jle	SHORT $LN4@CL_RunUser
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [eax+224]
	cmp	edx, DWORD PTR [ecx+588]
	jge	SHORT $LN4@CL_RunUser

; 1124 : 			cl.local.lastground = clgame.pmove->physents[clgame.pmove->onground].info;

	mov	eax, DWORD PTR _clgame+1316
	imul	ecx, DWORD PTR [eax+224], 224
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+ecx+672]
	mov	DWORD PTR _cl+1568528, eax
	jmp	SHORT $LN5@CL_RunUser
$LN4@CL_RunUser:

; 1125 : 		else cl.local.lastground = clgame.pmove->onground; // world(0) or in air(-1)

	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+224]
	mov	DWORD PTR _cl+1568528, edx
$LN5@CL_RunUser:

; 1126 : 	}
; 1127 : 
; 1128 : 	clgame.dllFuncs.pfnPostRunCmd( from, to, &cmd, runfuncs, *time, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _runfuncs$[ebp]
	push	edx
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	call	DWORD PTR _clgame+104
	add	esp, 28					; 0000001cH

; 1129 : 
; 1130 : 	*time += (double)cmd.msec / 1000.0;

	movzx	eax, BYTE PTR _cmd$[ebp+2]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@408f400000000000
	mov	ecx, DWORD PTR _time$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _time$[ebp]
	movsd	QWORD PTR [edx], xmm0
$LN1@CL_RunUser:

; 1131 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RunUsercmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_ps$ = -8						; size = 4
_cd$ = -4						; size = 4
_pmove$ = 8						; size = 4
_to$ = 12						; size = 4
_CL_FinishPMove PROC

; 1039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 1040 : 	entity_state_t	*ps;
; 1041 : 	clientdata_t	*cd;
; 1042 : 
; 1043 : 	ps = &to->playerstate;

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _ps$[ebp], eax

; 1044 : 	cd = &to->client;

	mov	ecx, DWORD PTR _to$[ebp]
	add	ecx, 340				; 00000154H
	mov	DWORD PTR _cd$[ebp], ecx

; 1045 : 
; 1046 : 	cd->flags = pmove->flags;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+40], ecx

; 1047 : 	cd->bInDuck = pmove->bInDuck;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR [edx+68], ecx

; 1048 : 	cd->flTimeStepSound = pmove->flTimeStepSound;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+76], ecx

; 1049 : 	cd->flDuckTime = pmove->flDuckTime;

	mov	edx, DWORD PTR _pmove$[ebp]
	cvttss2si eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 1050 : 	cd->flSwimTime = (int)pmove->flSwimTime;

	mov	edx, DWORD PTR _pmove$[ebp]
	cvttss2si eax, DWORD PTR [edx+172]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 1051 : 	cd->waterjumptime = (int)pmove->waterjumptime;

	mov	edx, DWORD PTR _pmove$[ebp]
	cvttss2si eax, DWORD PTR [edx+204]
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 1052 : 	cd->watertype = pmove->watertype;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	mov	DWORD PTR [edx+48], ecx

; 1053 : 	cd->waterlevel = pmove->waterlevel;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR [edx+44], ecx

; 1054 : 	cd->maxspeed = pmove->clientmaxspeed;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+504]
	mov	DWORD PTR [edx+92], ecx

; 1055 : 	cd->deadflag = pmove->deadflag;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR [edx+136], ecx

; 1056 : 	VectorCopy( pmove->velocity, cd->velocity );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [ecx+edx+12], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [eax+edx+12], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [ecx+eax+12], edx

; 1057 : 	VectorCopy( pmove->view_ofs, cd->view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+128]
	mov	DWORD PTR [edx+eax+52], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+128]
	mov	DWORD PTR [ecx+eax+52], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+128]
	mov	DWORD PTR [edx+ecx+52], eax

; 1058 : 	VectorCopy( pmove->origin, ps->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+56]
	mov	DWORD PTR [eax+ecx+16], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+56]
	mov	DWORD PTR [edx+ecx+16], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+56]
	mov	DWORD PTR [eax+edx+16], ecx

; 1059 : 	VectorCopy( pmove->angles, ps->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+68]
	mov	DWORD PTR [ecx+edx+28], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+68]
	mov	DWORD PTR [eax+edx+28], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+68]
	mov	DWORD PTR [ecx+eax+28], edx

; 1060 : 	VectorCopy( pmove->basevelocity, ps->basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+116]
	mov	DWORD PTR [edx+eax+188], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+116]
	mov	DWORD PTR [ecx+eax+188], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ps$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+116]
	mov	DWORD PTR [edx+ecx+188], eax

; 1061 : 	VectorCopy( pmove->punchangle, cd->punchangle );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+160]
	mov	DWORD PTR [eax+ecx+28], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+160]
	mov	DWORD PTR [edx+ecx+28], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+160]
	mov	DWORD PTR [eax+edx+28], ecx

; 1062 : 	ps->oldbuttons = pmove->oldbuttons;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR [edx+204], ecx

; 1063 : 	ps->friction = pmove->friction;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR [edx+156], ecx

; 1064 : 	ps->movetype = pmove->movetype;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	mov	DWORD PTR [edx+88], ecx

; 1065 : 	ps->onground = pmove->onground;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	mov	DWORD PTR [edx+208], ecx

; 1066 : 	ps->effects = pmove->effects;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	mov	DWORD PTR [edx+60], ecx

; 1067 : 	ps->usehull = pmove->usehull;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR [edx+200], ecx

; 1068 : 	ps->iStepLeft = pmove->iStepLeft;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR [edx+212], ecx

; 1069 : 	ps->flFallVelocity = pmove->flFallVelocity;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	DWORD PTR [edx+216], ecx

; 1070 : 	cd->iuser1 = pmove->iuser1;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	mov	DWORD PTR [edx+396], ecx

; 1071 : 	cd->iuser2 = pmove->iuser2;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR [edx+400], ecx

; 1072 : 	cd->iuser3 = pmove->iuser3;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	mov	DWORD PTR [edx+404], ecx

; 1073 : 	cd->iuser4 = pmove->iuser4;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+520]
	mov	DWORD PTR [edx+408], ecx

; 1074 : 	cd->fuser1 = pmove->fuser1;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+524]
	mov	DWORD PTR [edx+412], ecx

; 1075 : 	cd->fuser2 = pmove->fuser2;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+528]
	mov	DWORD PTR [edx+416], ecx

; 1076 : 	cd->fuser3 = pmove->fuser3;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	mov	DWORD PTR [edx+420], ecx

; 1077 : 	cd->fuser4 = pmove->fuser4;

	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+536]
	mov	DWORD PTR [edx+424], ecx

; 1078 : 	VectorCopy( pmove->vuser1, cd->vuser1 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+540]
	mov	DWORD PTR [ecx+edx+428], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+540]
	mov	DWORD PTR [eax+edx+428], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+540]
	mov	DWORD PTR [ecx+eax+428], edx

; 1079 : 	VectorCopy( pmove->vuser2, cd->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+552]
	mov	DWORD PTR [edx+eax+440], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+552]
	mov	DWORD PTR [ecx+eax+440], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+552]
	mov	DWORD PTR [edx+ecx+440], eax

; 1080 : 	VectorCopy( pmove->vuser3, cd->vuser3 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+564]
	mov	DWORD PTR [eax+ecx+452], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+564]
	mov	DWORD PTR [edx+ecx+452], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+564]
	mov	DWORD PTR [eax+edx+452], ecx

; 1081 : 	VectorCopy( pmove->vuser4, cd->vuser4 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+576]
	mov	DWORD PTR [ecx+edx+464], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+576]
	mov	DWORD PTR [eax+edx+464], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cd$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+576]
	mov	DWORD PTR [ecx+eax+464], edx

; 1082 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FinishPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceSurface PROC

; 891  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 892  : 	physent_t *pe;
; 893  : 
; 894  : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceSu
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceSu
$LN3@pfnTraceSu:

; 895  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceSu
$LN2@pfnTraceSu:

; 896  : 
; 897  : 	pe = &clgame.pmove->physents[ground];

	imul	edx, DWORD PTR _ground$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 898  : 	return PM_TraceSurface( pe, vstart, vend );

	mov	edx, DWORD PTR _vend$[ebp]
	push	edx
	mov	eax, DWORD PTR _vstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
$LN1@pfnTraceSu:

; 899  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -144						; size = 68
$T2 = -76						; size = 68
_old_usehull$ = -8					; size = 4
tv66 = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_pmFilter$ = 24						; size = 4
_pfnTraceLineEx PROC

; 868  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	push	edi

; 869  : 	static pmtrace_t	tr;
; 870  : 	int		old_usehull;
; 871  : 
; 872  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 873  : 	clgame.pmove->usehull = usehull;	

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 874  : 
; 875  : 	switch( flags )

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 876  : 	{
; 877  : 	case PM_TRACELINE_PHYSENTSONLY:
; 878  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numphysent, clgame.pmove->physents, -1, pmFilter );

	mov	edx, DWORD PTR _pmFilter$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR _clgame+1316
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	push	0
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd

; 879  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 880  : 	case PM_TRACELINE_ANYVISIBLE:
; 881  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numvisent, clgame.pmove->visents, -1, pmFilter );

	mov	ecx, DWORD PTR _pmFilter$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _clgame+1316
	add	edx, 149336				; 00024758H
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+149332]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 882  : 		break;
; 883  : 	}
; 884  : 
; 885  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 886  : 
; 887  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLineEx@@9@9

; 888  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLineEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pmFilter$ = 16						; size = 4
_pfnTestPlayerPositionEx PROC

; 863  : {

	push	ebp
	mov	ebp, esp

; 864  : 	return PM_TestPlayerPosition( clgame.pmove, pos, ptrace, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptrace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	push	eax
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 865  : }

	pop	ebp
	ret	0
_pfnTestPlayerPositionEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -68						; size = 68
$T2 = 8							; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_pmFilter$ = 24						; size = 4
_pfnPlayerTraceEx PROC

; 858  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi

; 859  : 	return PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]

; 860  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTraceEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_clientindex$ = 12					; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_pfnPlaybackEventFull PROC

; 853  : {

	push	ebp
	mov	ebp, esp

; 854  : 	CL_PlaybackEvent( flags, NULL, eventindex, delay, origin, angles, fparam1, fparam2, iparam1, iparam2, bparam1, bparam2 );

	mov	eax, DWORD PTR _bparam2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bparam1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iparam2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iparam1$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	call	_CL_PlaybackEvent
	add	esp, 48					; 00000030H

; 855  : }

	pop	ebp
	ret	0
_pfnPlaybackEventFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_channel$ = 8						; size = 4
_sample$ = 12						; size = 4
_volume$ = 16						; size = 4
_attenuation$ = 20					; size = 4
_fFlags$ = 24						; size = 4
_pitch$ = 28						; size = 4
_pfnPlaySound PROC

; 844  : {

	push	ebp
	mov	ebp, esp

; 845  : 	if( !clgame.pmove->runfuncs )

	mov	eax, DWORD PTR _clgame+1316
	cmp	DWORD PTR [eax+325040], 0
	jne	SHORT $LN2@pfnPlaySou

; 846  : 		return;

	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 847  : 
; 848  : 	S_StartSound( NULL, clgame.pmove->player_index + 1, channel, S_RegisterSound( sample ), volume, attenuation, pitch, fFlags );

	mov	ecx, DWORD PTR _fFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _attenuation$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	push	eax
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@pfnPlaySou:

; 849  : }

	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceTexture PROC

; 833  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 834  : 	physent_t *pe;
; 835  : 
; 836  : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceTe
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceTe
$LN3@pfnTraceTe:

; 837  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 838  : 
; 839  : 	pe = &clgame.pmove->physents[ground];

	imul	edx, DWORD PTR _ground$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 840  : 	return PM_TraceTexture( pe, vstart, vend );

	mov	edx, DWORD PTR _vend$[ebp]
	push	edx
	mov	eax, DWORD PTR _vstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 841  : }			

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv248 = -140						; size = 4
tv170 = -136						; size = 4
tv149 = -132						; size = 4
_old_usehull$ = -128					; size = 4
_hull$ = -124						; size = 4
_rotated$ = -120					; size = 4
_matrix$ = -116						; size = 64
_temp$ = -52						; size = 12
_start_l$ = -40						; size = 12
_end_l$ = -28						; size = 12
_offset$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_trace$ = 20						; size = 4
_pfnTraceModel PROC

; 787  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 788  : 	int	old_usehull;
; 789  : 	vec3_t	start_l, end_l;
; 790  : 	vec3_t	offset, temp;
; 791  : 	qboolean	rotated;
; 792  : 	matrix4x4	matrix;
; 793  : 	hull_t	*hull;
; 794  : 
; 795  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 796  : 	clgame.pmove->usehull = 2;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+188], 2

; 797  : 
; 798  : 	hull = PM_HullForBsp( pe, clgame.pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 799  : 
; 800  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 801  : 
; 802  : 	if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 4
	jne	SHORT $LN2@pfnTraceMo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@pfnTraceMo
$LN4@pfnTraceMo:

; 803  : 		rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN3@pfnTraceMo
$LN2@pfnTraceMo:

; 804  : 	else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN3@pfnTraceMo:

; 805  : 
; 806  :  	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN5@pfnTraceMo

; 807  :  	{
; 808  :  		Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 809  :  		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	ecx, DWORD PTR _start_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 810  :  		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 811  :  	}

	jmp	$LN6@pfnTraceMo
$LN5@pfnTraceMo:

; 812  :  	else
; 813  :  	{
; 814  :  		VectorSubtract( start, offset, start_l );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _start_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	movss	DWORD PTR tv149[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0

; 815  :  		VectorSubtract( end, offset, end_l );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	movss	DWORD PTR tv170[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
$LN6@pfnTraceMo:

; 816  :  	}
; 817  : 
; 818  : 	PM_RecursiveHullCheck( hull, hull->firstclipnode, 0, 1, start_l, end_l, (pmtrace_t *)trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 819  : 	trace->ent = NULL;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+48], 0

; 820  : 
; 821  : 	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN7@pfnTraceMo

; 822  : 	{
; 823  : 		VectorCopy( trace->plane.normal, temp );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [eax+edx+32]
	mov	DWORD PTR _temp$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR _temp$[ebp+edx], ecx

; 824  : 		Matrix4x4_TransformPositivePlane( matrix, temp, trace->plane.dist, trace->plane.normal, &trace->plane.dist );

	mov	edx, DWORD PTR _trace$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H
$LN7@pfnTraceMo:

; 825  : 	}
; 826  : 
; 827  : 	VectorLerp( start, trace->fraction, end, trace->endpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mov	ecx, 4
	imul	eax, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mov	eax, 4
	shl	eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	subss	xmm1, DWORD PTR [edi+edx]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv248[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv248[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0

; 828  : 
; 829  : 	return trace->fraction;

	mov	edx, DWORD PTR _trace$[ebp]
	fld	DWORD PTR [edx+16]

; 830  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_pe$ = 8						; size = 4
_offset$ = 12						; size = 4
_pfnHullForBsp PROC

; 782  : {

	push	ebp
	mov	ebp, esp

; 783  : 	return PM_HullForBsp( pe, clgame.pmove, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH

; 784  : }

	pop	ebp
	ret	0
_pfnHullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -144						; size = 68
$T2 = -76						; size = 68
_old_usehull$ = -8					; size = 4
tv66 = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_ignore_pe$ = 24					; size = 4
_pfnTraceLine PROC

; 759  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	push	edi

; 760  : 	static pmtrace_t	tr;
; 761  : 	int		old_usehull;
; 762  : 
; 763  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 764  : 	clgame.pmove->usehull = usehull;	

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 765  : 
; 766  : 	switch( flags )

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 767  : 	{
; 768  : 	case PM_TRACELINE_PHYSENTSONLY:
; 769  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	edx, DWORD PTR _ignore_pe$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	push	0
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd

; 770  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 771  : 	case PM_TRACELINE_ANYVISIBLE:
; 772  : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numvisent, clgame.pmove->visents, ignore_pe, NULL );

	push	0
	mov	ecx, DWORD PTR _ignore_pe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	add	edx, 149336				; 00024758H
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+149332]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 773  : 		break;
; 774  : 	}
; 775  : 
; 776  : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 777  : 
; 778  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLine@@9@9

; 779  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -68						; size = 68
$T2 = 8							; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_ignore_pe$ = 24					; size = 4
_pfnPlayerTrace PROC

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi

; 755  : 	return PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]

; 756  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p$ = 16						; size = 4
_pfnHullPointContents PROC

; 749  : {

	push	ebp
	mov	ebp, esp

; 750  : 	return PM_HullPointContents( hull, num, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH

; 751  : }

	pop	ebp
	ret	0
_pfnHullPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pfnTruePointContents PROC

; 744  : {

	push	ebp
	mov	ebp, esp

; 745  : 	return PM_TruePointContents( clgame.pmove, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	call	_PM_TruePointContents
	add	esp, 8

; 746  : }

	pop	ebp
	ret	0
_pfnTruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_truecont$ = -8						; size = 4
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_truecontents$ = 12					; size = 4
_pfnPointContents PROC

; 732  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 733  : 	int	cont, truecont;
; 734  : 
; 735  : 	truecont = cont = PM_PointContents( clgame.pmove, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	call	_PM_PointContents
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax
	mov	edx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR _truecont$[ebp], edx

; 736  : 	if( truecontents ) *truecontents = truecont;

	cmp	DWORD PTR _truecontents$[ebp], 0
	je	SHORT $LN2@pfnPointCo
	mov	eax, DWORD PTR _truecontents$[ebp]
	mov	ecx, DWORD PTR _truecont$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnPointCo:

; 737  : 
; 738  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN3@pfnPointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN3@pfnPointCo

; 739  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN3@pfnPointCo:

; 740  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 741  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hitent$ = 8						; size = 4
_tr$ = 12						; size = 4
_pfnStuckTouch PROC

; 713  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 714  : 	int	i;
; 715  : 
; 716  : 	for( i = 0; i < clgame.pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnStuckTo
$LN2@pfnStuckTo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnStuckTo:
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+283788]
	jge	SHORT $LN3@pfnStuckTo

; 717  : 	{
; 718  : 		if( clgame.pmove->touchindex[i].ent == hitent )

	imul	eax, DWORD PTR _i$[ebp], 68
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+eax+283840]
	cmp	edx, DWORD PTR _hitent$[ebp]
	jne	SHORT $LN5@pfnStuckTo

; 719  : 			return;

	jmp	$LN1@pfnStuckTo
$LN5@pfnStuckTo:

; 720  : 	}

	jmp	SHORT $LN2@pfnStuckTo
$LN3@pfnStuckTo:

; 721  : 
; 722  : 	if( clgame.pmove->numtouch >= MAX_PHYSENTS )

	mov	eax, DWORD PTR _clgame+1316
	cmp	DWORD PTR [eax+283788], 600		; 00000258H
	jl	SHORT $LN6@pfnStuckTo

; 723  : 		return;

	jmp	$LN1@pfnStuckTo
$LN6@pfnStuckTo:

; 724  : 
; 725  : 	VectorCopy( clgame.pmove->velocity, tr->deltavelocity );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [eax+ecx+52], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+52], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [eax+edx+52], ecx

; 726  : 	tr->ent = hitent;

	mov	edx, DWORD PTR _tr$[ebp]
	mov	eax, DWORD PTR _hitent$[ebp]
	mov	DWORD PTR [edx+48], eax

; 727  : 
; 728  : 	clgame.pmove->touchindex[clgame.pmove->numtouch++] = *tr;

	mov	ecx, DWORD PTR _clgame+1316
	imul	edx, DWORD PTR [ecx+283788], 68
	mov	eax, DWORD PTR _clgame+1316
	lea	edi, DWORD PTR [eax+edx+283792]
	mov	ecx, 17					; 00000011H
	mov	esi, DWORD PTR _tr$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+283788]
	add	edx, 1
	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+283788], edx
$LN1@pfnStuckTo:

; 729  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStuckTouch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pfnTestPlayerPosition PROC

; 708  : {

	push	ebp
	mov	ebp, esp

; 709  : 	return PM_TestPlayerPosition( clgame.pmove, pos, ptrace, NULL );

	push	0
	mov	eax, DWORD PTR _ptrace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	push	edx
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 710  : }

	pop	ebp
	ret	0
_pfnTestPlayerPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_i$ = -16						; size = 4
_pe$ = -12						; size = 4
_model$ = -8						; size = 4
_state$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_AddLinksToPmove PROC

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 434  : 	entity_state_t	*state;
; 435  : 	model_t		*model;
; 436  : 	physent_t		*pe;
; 437  : 	int		i;
; 438  : 
; 439  : 	if( !frame->valid ) return;

	mov	eax, DWORD PTR _frame$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@CL_AddLink
	jmp	$LN3@CL_AddLink
$LN5@CL_AddLink:

; 440  : 
; 441  : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_AddLink
$LN2@CL_AddLink:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_AddLink:
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+17296]
	jge	$LN3@CL_AddLink

; 442  : 	{
; 443  : 		state = &cls.packet_entities[(frame->first_entity + i) % cls.num_client_entities];

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [ecx+17300]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	edx, edx, 340
	add	edx, DWORD PTR _cls+291764
	mov	DWORD PTR _state$[ebp], edx

; 444  : 
; 445  : 		if( state->number >= 1 && state->number <= cl.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN6@CL_AddLink
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _cl+1568832
	jg	SHORT $LN6@CL_AddLink

; 446  : 			continue;

	jmp	SHORT $LN2@CL_AddLink
$LN6@CL_AddLink:

; 447  : 
; 448  : 		if( !state->modelindex )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN7@CL_AddLink

; 449  : 			continue;

	jmp	SHORT $LN2@CL_AddLink
$LN7@CL_AddLink:

; 450  : 
; 451  : 		model = CL_ModelHandle( state->modelindex );

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 452  : 		if( !model ) continue;

	cmp	DWORD PTR _model$[ebp], 0
	jne	SHORT $LN8@CL_AddLink
	jmp	SHORT $LN2@CL_AddLink
$LN8@CL_AddLink:

; 453  : 
; 454  : 		if(( state->owner != 0 ) && ( state->owner == cl.playernum + 1 ))

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN9@CL_AddLink
	mov	ecx, DWORD PTR _cl+1568828
	add	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+152], ecx
	jne	SHORT $LN9@CL_AddLink

; 455  : 			continue;

	jmp	$LN2@CL_AddLink
$LN9@CL_AddLink:

; 456  : 
; 457  : 		if(( model->hulls[1].lastclipnode || model->type == mod_studio ) && clgame.pmove->numvisent < MAX_PHYSENTS )

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+eax+220], 0
	jne	SHORT $LN11@CL_AddLink
	mov	edx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [edx+68], 3
	jne	SHORT $LN10@CL_AddLink
$LN11@CL_AddLink:
	mov	eax, DWORD PTR _clgame+1316
	cmp	DWORD PTR [eax+149332], 600		; 00000258H
	jge	SHORT $LN10@CL_AddLink

; 458  : 		{
; 459  : 			pe = &clgame.pmove->visents[clgame.pmove->numvisent];

	mov	ecx, DWORD PTR _clgame+1316
	imul	edx, DWORD PTR [ecx+149332], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+149336]
	mov	DWORD PTR _pe$[ebp], ecx

; 460  : 			CL_CopyEntityToPhysEnt( pe, state, true );

	push	1
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 461  : 			clgame.pmove->numvisent++;

	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+149332]
	add	edx, 1
	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+149332], edx
$LN10@CL_AddLink:

; 462  : 		}
; 463  : 
; 464  : 		if( state->solid == SOLID_TRIGGER || ( state->solid == SOLID_NOT && state->skin >= CONTENTS_EMPTY ))

	mov	ecx, DWORD PTR _state$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, 1
	je	SHORT $LN13@CL_AddLink
	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	test	ecx, ecx
	jne	SHORT $LN12@CL_AddLink
	mov	edx, DWORD PTR _state$[ebp]
	movsx	eax, WORD PTR [edx+56]
	cmp	eax, -1
	jl	SHORT $LN12@CL_AddLink
$LN13@CL_AddLink:

; 465  : 			continue;

	jmp	$LN2@CL_AddLink
$LN12@CL_AddLink:

; 466  : 
; 467  : 		// dead body
; 468  : 		if( state->mins[2] == 0.0f && state->maxs[2] == 1.0f )

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+124]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_AddLink
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+136]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_AddLink

; 469  : 			continue;

	jmp	$LN2@CL_AddLink
$LN14@CL_AddLink:

; 470  : 
; 471  : 		// can't collide with zeroed hull
; 472  : 		if( VectorIsNull( state->mins ) && VectorIsNull( state->maxs ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+124]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN15@CL_AddLink
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+124]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN15@CL_AddLink
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+124]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+136]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+136]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@CL_AddLink

; 473  : 			continue;

	jmp	$LN2@CL_AddLink
$LN15@CL_AddLink:

; 474  : 
; 475  : 		if( state->solid == SOLID_NOT && state->skin == CONTENTS_LADDER )

	mov	ecx, DWORD PTR _state$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	test	edx, edx
	jne	SHORT $LN16@CL_AddLink
	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN16@CL_AddLink

; 476  : 		{
; 477  : 			if( clgame.pmove->nummoveent >= MAX_MOVEENTS )

	mov	edx, DWORD PTR _clgame+1316
	cmp	DWORD PTR [edx+134992], 64		; 00000040H
	jl	SHORT $LN18@CL_AddLink

; 478  : 				continue;

	jmp	$LN2@CL_AddLink
$LN18@CL_AddLink:

; 479  : 
; 480  : 			pe = &clgame.pmove->moveents[clgame.pmove->nummoveent];

	mov	eax, DWORD PTR _clgame+1316
	imul	ecx, DWORD PTR [eax+134992], 224
	mov	edx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [edx+ecx+134996]
	mov	DWORD PTR _pe$[ebp], eax

; 481  : 			CL_CopyEntityToPhysEnt( pe, state, false );

	push	0
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 482  : 			clgame.pmove->nummoveent++;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+134992]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+134992], ecx

; 483  : 		}

	jmp	$LN17@CL_AddLink
$LN16@CL_AddLink:

; 484  : 		else
; 485  : 		{
; 486  : 			if( !model->hulls[1].lastclipnode && model->type != mod_studio )

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+eax+220], 0
	jne	SHORT $LN19@CL_AddLink
	mov	edx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [edx+68], 3
	je	SHORT $LN19@CL_AddLink

; 487  : 				continue;

	jmp	$LN2@CL_AddLink
$LN19@CL_AddLink:

; 488  : 
; 489  : 			// reserve slots for all the clients
; 490  : 			if( clgame.pmove->numphysent >= ( MAX_PHYSENTS - cl.maxclients ))

	mov	eax, 600				; 00000258H
	sub	eax, DWORD PTR _cl+1568832
	mov	ecx, DWORD PTR _clgame+1316
	cmp	DWORD PTR [ecx+588], eax
	jl	SHORT $LN20@CL_AddLink

; 491  : 				continue;

	jmp	$LN2@CL_AddLink
$LN20@CL_AddLink:

; 492  : 
; 493  : 			pe = &clgame.pmove->physents[clgame.pmove->numphysent];

	mov	edx, DWORD PTR _clgame+1316
	imul	eax, DWORD PTR [edx+588], 224
	mov	ecx, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 494  : 			CL_CopyEntityToPhysEnt( pe, state, false );

	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 495  : 			clgame.pmove->numphysent++;

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+588]
	add	eax, 1
	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+588], eax
$LN17@CL_AddLink:

; 496  : 		}
; 497  : 	}

	jmp	$LN2@CL_AddLink
$LN3@CL_AddLink:

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddLinksToPmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv294 = -8						; size = 4
_mod$ = -4						; size = 4
_pe$ = 8						; size = 4
_state$ = 12						; size = 4
_visent$ = 16						; size = 4
_CL_CopyEntityToPhysEnt PROC

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 348  : 	model_t	*mod = CL_ModelHandle( state->modelindex );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 349  : 
; 350  : 	pe->player = 0;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+32], 0

; 351  : 
; 352  : 	if( state->number >= 1 && state->number <= cl.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN2@CL_CopyEnt
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _cl+1568832
	jg	SHORT $LN2@CL_CopyEnt

; 353  : 		pe->player = state->number;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+32], edx
$LN2@CL_CopyEnt:

; 354  : 
; 355  : 	if( pe->player )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@CL_CopyEnt

; 356  : 	{
; 357  : 		// client or bot
; 358  : 		Q_snprintf( pe->name, sizeof( pe->name ), "player %i", pe->player - 1 );

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, 1
	push	edx
	push	OFFSET $SG139663
	push	32					; 00000020H
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 359  : 	}

	jmp	SHORT $LN4@CL_CopyEnt
$LN3@CL_CopyEnt:

; 360  : 	else
; 361  : 	{
; 362  : 		// otherwise copy the modelname
; 363  : 		Q_strncpy( pe->name, mod->name, sizeof( pe->name ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN4@CL_CopyEnt:

; 364  : 	}
; 365  : 
; 366  : 	pe->model = pe->studiomodel = NULL;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 367  : 
; 368  : 	VectorCopy( state->mins, pe->mins );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+124]
	mov	DWORD PTR [ecx+edx+56], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+124]
	mov	DWORD PTR [eax+edx+56], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+124]
	mov	DWORD PTR [ecx+eax+56], edx

; 369  : 	VectorCopy( state->maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+68], eax

; 370  : 
; 371  : 	if( state->solid == SOLID_BBOX )

	mov	ecx, DWORD PTR _state$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, 2
	jne	SHORT $LN5@CL_CopyEnt

; 372  : 	{
; 373  : 		if( FBitSet( mod->flags, STUDIO_TRACE_HITBOX ))

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 512				; 00000200H
	je	SHORT $LN7@CL_CopyEnt

; 374  : 			pe->studiomodel = mod;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN7@CL_CopyEnt:

; 375  : 	}

	jmp	SHORT $LN9@CL_CopyEnt
$LN5@CL_CopyEnt:

; 376  : 	else
; 377  : 	{
; 378  : 		if( pe->solid != SOLID_BSP && ( mod != NULL ) && ( mod->type == mod_studio ))

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+96], 4
	je	SHORT $LN8@CL_CopyEnt
	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN8@CL_CopyEnt
	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 3
	jne	SHORT $LN8@CL_CopyEnt

; 379  : 			pe->studiomodel = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+52], ecx
	jmp	SHORT $LN9@CL_CopyEnt
$LN8@CL_CopyEnt:

; 380  : 		else pe->model = mod;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+48], eax
$LN9@CL_CopyEnt:

; 381  : 	}
; 382  : 
; 383  : 	// rare case: not solid entities in vistrace
; 384  : 	if( visent && VectorIsNull( pe->mins ))

	cmp	DWORD PTR _visent$[ebp], 0
	je	$LN10@CL_CopyEnt
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@CL_CopyEnt
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@CL_CopyEnt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@CL_CopyEnt

; 385  : 	{
; 386  : 		VectorCopy( mod->mins, pe->mins );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [esi+eax+84]
	mov	DWORD PTR [ecx+edx+56], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+84]
	mov	DWORD PTR [eax+edx+56], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [esi+edx+84]
	mov	DWORD PTR [ecx+eax+56], edx

; 387  : 		VectorCopy( mod->maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+96]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [esi+edx+96]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [esi+eax+96]
	mov	DWORD PTR [edx+ecx+68], eax
$LN10@CL_CopyEnt:

; 388  : 	}
; 389  : 
; 390  : 	pe->info = state->number;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+80], eax

; 391  : 	VectorCopy( state->origin, pe->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [eax+ecx+36], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+36], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+36], ecx

; 392  : 	VectorCopy( state->angles, pe->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [ecx+edx+84], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [eax+edx+84], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+84], edx

; 393  : 
; 394  : 	pe->solid = state->solid;

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 395  : 	pe->rendermode = state->rendermode;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+104], edx

; 396  : 	pe->skin = state->skin;

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 397  : 	pe->frame = state->frame;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+108], edx

; 398  : 	pe->sequence = state->sequence;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+112], edx

; 399  : 
; 400  : 	memcpy( &pe->controller[0], &state->controller[0], sizeof( pe->controller ));

	push	4
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx+104]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	lea	ecx, DWORD PTR [eax+edx+116]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 401  : 	memcpy( &pe->blending[0], &state->blending[0], sizeof( pe->blending ));

	push	2
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax+108]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	lea	eax, DWORD PTR [edx+ecx+120]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 402  : 
; 403  : 	pe->movetype = state->movetype;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx+124], eax

; 404  : 	pe->takedamage = (pe->player) ? DAMAGE_YES : DAMAGE_NO;

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN12@CL_CopyEnt
	mov	DWORD PTR tv294[ebp], 1
	jmp	SHORT $LN13@CL_CopyEnt
$LN12@CL_CopyEnt:
	mov	DWORD PTR tv294[ebp], 0
$LN13@CL_CopyEnt:
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR tv294[ebp]
	mov	DWORD PTR [edx+128], eax

; 405  : 	pe->team = state->team;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	DWORD PTR [ecx+136], eax

; 406  : 	pe->classnumber = state->playerclass;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+168]
	mov	DWORD PTR [ecx+140], eax

; 407  : 	pe->blooddecal = 0;	// unused in GoldSrc

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [ecx+132], 0

; 408  : 
; 409  : 	// for mods
; 410  : 	pe->iuser1 = state->iuser1;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	DWORD PTR [edx+144], ecx

; 411  : 	pe->iuser2 = state->iuser2;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	DWORD PTR [edx+148], ecx

; 412  : 	pe->iuser3 = state->iuser3;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR [edx+152], ecx

; 413  : 	pe->iuser4 = state->iuser4;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	DWORD PTR [edx+156], ecx

; 414  : 	pe->fuser1 = state->fuser1;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	mov	DWORD PTR [edx+160], ecx

; 415  : 	pe->fuser2 = state->fuser2;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	DWORD PTR [edx+164], ecx

; 416  : 	pe->fuser3 = state->fuser3;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	mov	DWORD PTR [edx+168], ecx

; 417  : 	pe->fuser4 = state->fuser4;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	DWORD PTR [edx+172], ecx

; 418  : 
; 419  : 	VectorCopy( state->vuser1, pe->vuser1 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+292]
	mov	DWORD PTR [ecx+edx+176], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+292]
	mov	DWORD PTR [eax+edx+176], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+292]
	mov	DWORD PTR [ecx+eax+176], edx

; 420  : 	VectorCopy( state->vuser2, pe->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+304]
	mov	DWORD PTR [edx+eax+188], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+304]
	mov	DWORD PTR [ecx+eax+188], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+304]
	mov	DWORD PTR [edx+ecx+188], eax

; 421  : 	VectorCopy( state->vuser3, pe->vuser3 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+316]
	mov	DWORD PTR [eax+ecx+200], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+316]
	mov	DWORD PTR [edx+ecx+200], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+316]
	mov	DWORD PTR [eax+edx+200], ecx

; 422  : 	VectorCopy( state->vuser4, pe->vuser4 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+328]
	mov	DWORD PTR [ecx+edx+212], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+328]
	mov	DWORD PTR [eax+edx+212], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+328]
	mov	DWORD PTR [ecx+eax+212], edx

; 423  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CopyEntityToPhysEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_maxlen$ = -32						; size = 4
_len$ = -28						; size = 4
tv90 = -24						; size = 4
tv151 = -20						; size = 4
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_CL_PlayerTeleported PROC

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 213  : 	int	len, maxlen;
; 214  : 	vec3_t	delta;
; 215  : 
; 216  : 	VectorSubtract( to->playerstate.origin, from->playerstate.origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax+16]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax+16]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx+16]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 217  : 
; 218  : 	// compute potential max movement in units per frame and compare with entity movement
; 219  : 	maxlen = ( clgame.movevars.maxvelocity * ( 1.0 / GAME_FPS ));

	cvtss2sd xmm0, DWORD PTR _clgame+1080
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _maxlen$[ebp], ecx

; 220  : 	len = VectorLength( delta );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _len$[ebp], eax

; 221  : 
; 222  : 	return (len > maxlen);

	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$[ebp]
	jle	SHORT $LN3@CL_PlayerT
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN4@CL_PlayerT
$LN3@CL_PlayerT:
	mov	DWORD PTR tv151[ebp], 0
$LN4@CL_PlayerT:
	mov	eax, DWORD PTR tv151[ebp]

; 223  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerTeleported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -220						; size = 68
_sinval$ = -152						; size = 4
_cosval$ = -148						; size = 4
_angleval$ = -144					; size = 4
_steps$ = -140						; size = 4
_step$ = -136						; size = 4
_j$ = -132						; size = 4
_dir$ = -128						; size = 4
_i$ = -124						; size = 4
_tr$ = -120						; size = 68
_z$ = -52						; size = 24
_bottom$ = -28						; size = 12
_top$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_CL_SetIdealPitch PROC

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 143  : 	float	angleval, sinval, cosval;
; 144  : 	int	i, j, step, dir, steps;
; 145  : 	float	z[MAX_FORWARD];
; 146  : 	vec3_t	top, bottom;
; 147  : 	pmtrace_t	tr;
; 148  : 
; 149  : 	if( cl.local.onground == -1 )

	cmp	DWORD PTR _cl+1568560, -1
	jne	SHORT $LN8@CL_SetIdea

; 150  : 		return;

	jmp	$LN1@CL_SetIdea
$LN8@CL_SetIdea:

; 151  : 
; 152  : 	angleval = cl.viewangles[YAW] * M_PI2 / 360.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+1568612]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	divss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _angleval$[ebp], xmm0

; 153  : 	SinCos( angleval, &sinval, &cosval );

	lea	ecx, DWORD PTR _cosval$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sinval$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _angleval$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 154  : 
; 155  : 	// Now move forward by 36, 48, 60, etc. units from the eye position and drop lines straight down
; 156  : 	// 160 or so units to see what's below
; 157  : 	for( i = 0; i < MAX_FORWARD; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetIdea
$LN2@CL_SetIdea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetIdea:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@CL_SetIdea

; 158  : 	{
; 159  : 		top[0] = cl.simorg[0] + cosval * (i + 3.0f) * 12.0f;

	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _cosval$[ebp]
	mulss	xmm0, DWORD PTR __real@41400000
	addss	xmm0, DWORD PTR _cl[edx+1568804]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _top$[ebp+ecx], xmm0

; 160  : 		top[1] = cl.simorg[1] + sinval * (i + 3.0f) * 12.0f;

	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _sinval$[ebp]
	mulss	xmm0, DWORD PTR __real@41400000
	addss	xmm0, DWORD PTR _cl[edx+1568804]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _top$[ebp+eax], xmm0

; 161  : 		top[2] = cl.simorg[2] + cl.viewheight[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _cl[ecx+1568804]
	addss	xmm0, DWORD PTR _cl[edx+1568624]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _top$[ebp+eax], xmm0

; 162  : 		
; 163  : 		bottom[0] = top[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _top$[ebp+edx]
	mov	DWORD PTR _bottom$[ebp+ecx], edx

; 164  : 		bottom[1] = top[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _top$[ebp+eax]
	mov	DWORD PTR _bottom$[ebp+ecx], edx

; 165  : 		bottom[2] = top[2] - 160.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _top$[ebp+eax]
	subss	xmm0, DWORD PTR __real@43200000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _bottom$[ebp+ecx], xmm0

; 166  : 
; 167  : 		// skip any monsters (only world and brush models)
; 168  : 		tr = CL_TraceLine( top, bottom, PM_STUDIO_BOX );

	push	2
	lea	edx, DWORD PTR _bottom$[ebp]
	push	edx
	lea	eax, DWORD PTR _top$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 169  : 		if( tr.allsolid ) return; // looking at a wall, leave ideal the way is was

	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $LN9@CL_SetIdea
	jmp	$LN1@CL_SetIdea
$LN9@CL_SetIdea:

; 170  : 
; 171  : 		if( tr.fraction == 1.0f )

	movss	xmm0, DWORD PTR _tr$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_SetIdea

; 172  : 			return;	// near a dropoff

	jmp	$LN1@CL_SetIdea
$LN10@CL_SetIdea:

; 173  : 		
; 174  : 		z[i] = top[2] + tr.fraction * (bottom[2] - top[2]);

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _bottom$[ebp+eax]
	subss	xmm0, DWORD PTR _top$[ebp+ecx]
	mulss	xmm0, DWORD PTR _tr$[ebp+16]
	addss	xmm0, DWORD PTR _top$[ebp+edx]
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _z$[ebp+edx*4], xmm0

; 175  : 	}

	jmp	$LN2@CL_SetIdea
$LN3@CL_SetIdea:

; 176  : 	
; 177  : 	dir = 0;

	mov	DWORD PTR _dir$[ebp], 0

; 178  : 	steps = 0;

	mov	DWORD PTR _steps$[ebp], 0

; 179  : 
; 180  : 	for( j = 1; j < i; j++ )

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN7@CL_SetIdea
$LN5@CL_SetIdea:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@CL_SetIdea:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _i$[ebp]
	jge	$LN6@CL_SetIdea

; 181  : 	{
; 182  : 		step = z[j] - z[j-1];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp+edx*4]
	subss	xmm0, DWORD PTR _z$[ebp+eax*4-4]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _step$[ebp], ecx

; 183  : 		if( step > -ON_EPSILON && step < ON_EPSILON )

	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jbe	SHORT $LN11@CL_SetIdea
	cvtsi2ss xmm0, DWORD PTR _step$[ebp]
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@CL_SetIdea

; 184  : 			continue;

	jmp	SHORT $LN5@CL_SetIdea
$LN11@CL_SetIdea:

; 185  : 
; 186  : 		if( dir && ( step-dir > ON_EPSILON || step-dir < -ON_EPSILON ))

	cmp	DWORD PTR _dir$[ebp], 0
	je	SHORT $LN12@CL_SetIdea
	mov	edx, DWORD PTR _step$[ebp]
	sub	edx, DWORD PTR _dir$[ebp]
	cvtsi2ss xmm0, edx
	comiss	xmm0, DWORD PTR __real@3dcccccd
	ja	SHORT $LN13@CL_SetIdea
	mov	eax, DWORD PTR _step$[ebp]
	sub	eax, DWORD PTR _dir$[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@bdcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@CL_SetIdea
$LN13@CL_SetIdea:

; 187  : 			return; // mixed changes

	jmp	SHORT $LN1@CL_SetIdea
$LN12@CL_SetIdea:

; 188  : 
; 189  : 		steps++;	

	mov	ecx, DWORD PTR _steps$[ebp]
	add	ecx, 1
	mov	DWORD PTR _steps$[ebp], ecx

; 190  : 		dir = step;

	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR _dir$[ebp], edx

; 191  : 	}

	jmp	$LN5@CL_SetIdea
$LN6@CL_SetIdea:

; 192  : 	
; 193  : 	if( !dir )

	cmp	DWORD PTR _dir$[ebp], 0
	jne	SHORT $LN14@CL_SetIdea

; 194  : 	{
; 195  : 		cl.local.idealpitch = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+1568548, xmm0

; 196  : 		return;

	jmp	SHORT $LN1@CL_SetIdea
$LN14@CL_SetIdea:

; 197  : 	}
; 198  : 	
; 199  : 	if( steps < 2 ) return;

	cmp	DWORD PTR _steps$[ebp], 2
	jge	SHORT $LN15@CL_SetIdea
	jmp	SHORT $LN1@CL_SetIdea
$LN15@CL_SetIdea:

; 200  : 	cl.local.idealpitch = -dir * cl_idealpitchscale->value;

	mov	eax, DWORD PTR _dir$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _cl_idealpitchscale
	mulss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _cl+1568548, xmm0
$LN1@CL_SetIdea:

; 201  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetIdealPitch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_ent$ = -16						; size = 4
_i$ = -12						; size = 4
_state$ = -8						; size = 4
_player$ = -4						; size = 4
_dopred$ = 8						; size = 4
_bIncludeLocalClient$ = 12				; size = 4
_CL_SetUpPlayerPrediction PROC

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 285  : 	entity_state_t	*state;
; 286  : 	predicted_player_t	*player;
; 287  : 	cl_entity_t	*ent;
; 288  : 	int		i;
; 289  : 
; 290  : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetUpPl
$LN2@CL_SetUpPl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetUpPl:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_SetUpPl

; 291  : 	{
; 292  : 		state = &cl.frames[cl.parsecountmod].playerstate[i];

	imul	ecx, DWORD PTR _cl+12, 17304
	imul	edx, DWORD PTR _i$[ebp], 340
	lea	eax, DWORD PTR _cl[ecx+edx+596]
	mov	DWORD PTR _state$[ebp], eax

; 293  : 		player = &cls.predicted_players[i];

	imul	ecx, DWORD PTR _i$[ebp], 40
	add	ecx, OFFSET _cls+291768
	mov	DWORD PTR _player$[ebp], ecx

; 294  : 
; 295  : 		player->active = false;

	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [edx+12], 0

; 296  : 
; 297  : 		if( state->messagenum != cl.parsecount )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _cl+8
	je	SHORT $LN5@CL_SetUpPl

; 298  : 			continue; // not present this frame

	jmp	SHORT $LN2@CL_SetUpPl
$LN5@CL_SetUpPl:

; 299  : 
; 300  : 		if( !state->modelindex )

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $LN6@CL_SetUpPl

; 301  : 			continue;

	jmp	SHORT $LN2@CL_SetUpPl
$LN6@CL_SetUpPl:

; 302  : 
; 303  : 		player->active = true;

	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+12], 1

; 304  : 		player->movetype = state->movetype;

	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx], eax

; 305  : 		player->solid = state->solid;

	mov	ecx, DWORD PTR _state$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+4], edx

; 306  : 		player->usehull = state->usehull;

	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR [ecx+8], eax

; 307  : 
; 308  : 		if( FBitSet( state->effects, EF_NODRAW ) && !bIncludeLocalClient && ( cl.playernum == i ))

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	and	edx, 128				; 00000080H
	je	SHORT $LN7@CL_SetUpPl
	cmp	DWORD PTR _bIncludeLocalClient$[ebp], 0
	jne	SHORT $LN7@CL_SetUpPl
	mov	eax, DWORD PTR _cl+1568828
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN7@CL_SetUpPl

; 309  : 			continue;

	jmp	$LN2@CL_SetUpPl
$LN7@CL_SetUpPl:

; 310  : 
; 311  : 		// note that the local player is special, since he moves locally
; 312  : 		// we use his last predicted postition
; 313  : 		if( cl.playernum == i )

	mov	ecx, DWORD PTR _cl+1568828
	cmp	ecx, DWORD PTR _i$[ebp]
	jne	$LN8@CL_SetUpPl

; 314  : 		{
; 315  : 			VectorCopy( state->origin, player->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+edx+16], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+16], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+16], edx

; 316  : 			VectorCopy( state->angles, player->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+28], eax

; 317  : 		}

	jmp	$LN9@CL_SetUpPl
$LN8@CL_SetUpPl:

; 318  : 		else
; 319  : 		{
; 320  : 			ent = CL_GetEntityByIndex( i + 1 );

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 321  : 
; 322  : 			CL_ComputePlayerOrigin( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_ComputePlayerOrigin
	add	esp, 4

; 323  : 
; 324  : 			VectorCopy( ent->origin, player->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx+16], eax

; 325  : 			VectorCopy( ent->angles, player->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2900]
	mov	DWORD PTR [eax+ecx+28], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2900]
	mov	DWORD PTR [edx+ecx+28], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _player$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2900]
	mov	DWORD PTR [eax+edx+28], ecx
$LN9@CL_SetUpPl:

; 326  : 		}
; 327  : 	}

	jmp	$LN2@CL_SetUpPl
$LN3@CL_SetUpPl:

; 328  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetUpPlayerPrediction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_PopPMStates PROC

; 64   : {

	push	ebp
	mov	ebp, esp

; 65   : 	if( !clgame.pushed ) return;

	cmp	DWORD PTR _clgame+1320, 0
	jne	SHORT $LN2@CL_PopPMSt
	jmp	SHORT $LN1@CL_PopPMSt
$LN2@CL_PopPMSt:

; 66   : 	clgame.pmove->numphysent = clgame.oldphyscount;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _clgame+1328
	mov	DWORD PTR [eax+588], ecx

; 67   : 	clgame.pmove->numvisent  = clgame.oldviscount;

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _clgame+1324
	mov	DWORD PTR [edx+149332], eax

; 68   : 	clgame.pushed = false;

	mov	DWORD PTR _clgame+1320, 0
$LN1@CL_PopPMSt:

; 69   : }

	pop	ebp
	ret	0
_CL_PopPMStates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_PushPMStates PROC

; 50   : {

	push	ebp
	mov	ebp, esp

; 51   : 	if( clgame.pushed ) return;

	cmp	DWORD PTR _clgame+1320, 0
	je	SHORT $LN2@CL_PushPMS
	jmp	SHORT $LN1@CL_PushPMS
$LN2@CL_PushPMS:

; 52   : 	clgame.oldphyscount = clgame.pmove->numphysent;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR _clgame+1328, ecx

; 53   : 	clgame.oldviscount  = clgame.pmove->numvisent;

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+149332]
	mov	DWORD PTR _clgame+1324, eax

; 54   : 	clgame.pushed = true;

	mov	DWORD PTR _clgame+1320, 1
$LN1@CL_PushPMS:

; 55   : }

	pop	ebp
	ret	0
_CL_PushPMStates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_ClearPhysEnts PROC

; 36   : {

	push	ebp
	mov	ebp, esp

; 37   : 	clgame.pmove->numtouch = 0;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+283788], 0

; 38   : 	clgame.pmove->numvisent = 0;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+149332], 0

; 39   : 	clgame.pmove->nummoveent = 0;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+134992], 0

; 40   : 	clgame.pmove->numphysent = 0;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+588], 0

; 41   : }

	pop	ebp
	ret	0
_CL_ClearPhysEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_RedoPrediction PROC

; 128  : {

	push	ebp
	mov	ebp, esp

; 129  : 	if ( cls.netchan.incoming_sequence != cls.lastupdate_sequence )

	mov	eax, DWORD PTR _cls+23584
	cmp	eax, DWORD PTR _cls+287348
	je	SHORT $LN1@CL_RedoPre

; 130  : 	{
; 131  : 		CL_PredictMovement( true );

	push	1
	call	_CL_PredictMovement
	add	esp, 4

; 132  : 		CL_CheckPredictionError();

	call	_CL_CheckPredictionError
$LN1@CL_RedoPre:

; 133  : 	}
; 134  : }

	pop	ebp
	ret	0
_CL_RedoPrediction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_SetLastUpdate PROC

; 118  : {

	push	ebp
	mov	ebp, esp

; 119  : 	cls.lastupdate_sequence = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+23584
	mov	DWORD PTR _cls+287348, eax

; 120  : }

	pop	ebp
	ret	0
_CL_SetLastUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_time$ = -8						; size = 8
_CL_MoveSpectatorCamera PROC

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1143 : 	double	time = cl.time;

	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR _time$[ebp], xmm0

; 1144 : 
; 1145 : 	if( !cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	jne	SHORT $LN2@CL_MoveSpe

; 1146 : 		return;

	jmp	$LN1@CL_MoveSpe
$LN2@CL_MoveSpe:

; 1147 : 
; 1148 : 	CL_SetUpPlayerPrediction( false, true );

	push	1
	push	0
	call	_CL_SetUpPlayerPrediction
	add	esp, 8

; 1149 : 	CL_SetSolidPlayers( cl.playernum );

	mov	eax, DWORD PTR _cl+1568828
	push	eax
	call	_CL_SetSolidPlayers
	add	esp, 4

; 1150 : 	CL_RunUsercmd( &cls.spectator_state, &cls.spectator_state, cl.cmd, true, &time, (uint)( time * 100.0 ));

	movsd	xmm0, QWORD PTR _time$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	call	__dtoui3
	push	eax
	lea	ecx, DWORD PTR _time$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _cl+1568604
	push	edx
	push	OFFSET _cls+156
	push	OFFSET _cls+156
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1151 : 
; 1152 : 	VectorCopy( cls.spectator_state.client.velocity, cl.simvel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cls[ecx+508]
	mov	DWORD PTR _cl[eax+1568816], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cls[edx+508]
	mov	DWORD PTR _cl[eax+1568816], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cls[edx+508]
	mov	DWORD PTR _cl[eax+1568816], ecx

; 1153 : 	VectorCopy( cls.spectator_state.client.origin, cl.simorg );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cls[eax+496]
	mov	DWORD PTR _cl[edx+1568804], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cls[ecx+496]
	mov	DWORD PTR _cl[edx+1568804], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _cls[ecx+496]
	mov	DWORD PTR _cl[edx+1568804], eax

; 1154 : 	VectorCopy( cls.spectator_state.client.punchangle, cl.punchangle );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cls[edx+524]
	mov	DWORD PTR _cl[ecx+1568636], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cls[eax+524]
	mov	DWORD PTR _cl[ecx+1568636], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cls[eax+524]
	mov	DWORD PTR _cl[ecx+1568636], edx

; 1155 : 	VectorCopy( cls.spectator_state.client.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cls[ecx+548]
	mov	DWORD PTR _cl[eax+1568624], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cls[edx+548]
	mov	DWORD PTR _cl[eax+1568624], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cls[edx+548]
	mov	DWORD PTR _cl[eax+1568624], ecx
$LN1@CL_MoveSpe:

; 1156 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_MoveSpectatorCamera ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_PopTraceBounds PROC

; 91   : {

	push	ebp
	mov	ebp, esp

; 92   : 	memcpy( clgame.pmove->player_mins, host.player_mins, sizeof( host.player_mins ));

	push	48					; 00000030H
	push	OFFSET _host+34236
	mov	eax, DWORD PTR _clgame+1316
	add	eax, 324852				; 0004f4f4H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 93   : 	memcpy( clgame.pmove->player_maxs, host.player_maxs, sizeof( host.player_maxs ));

	push	48					; 00000030H
	push	OFFSET _host+34284
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 324900				; 0004f524H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 94   : }

	pop	ebp
	ret	0
_CL_PopTraceBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_hullnum$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_CL_PushTraceBounds PROC

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 79   : 	hullnum = bound( 0, hullnum, 3 );

	cmp	DWORD PTR _hullnum$[ebp], 0
	jl	SHORT $LN5@CL_PushTra
	cmp	DWORD PTR _hullnum$[ebp], 3
	jge	SHORT $LN3@CL_PushTra
	mov	eax, DWORD PTR _hullnum$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_PushTra
$LN3@CL_PushTra:
	mov	DWORD PTR tv66[ebp], 3
$LN4@CL_PushTra:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_PushTra
$LN5@CL_PushTra:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_PushTra:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _hullnum$[ebp], edx

; 80   : 	VectorCopy( mins, clgame.pmove->player_mins[hullnum] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _hullnum$[ebp], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [eax+edx+324852]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _hullnum$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [ecx+eax+324852]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _hullnum$[ebp], 12
	mov	edx, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [edx+ecx+324852]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 81   : 	VectorCopy( maxs, clgame.pmove->player_maxs[hullnum] );

	mov	ecx, 4
	imul	edx, ecx, 0
	imul	eax, DWORD PTR _hullnum$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [ecx+eax+324900]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _hullnum$[ebp], 12
	mov	edx, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [edx+ecx+324900]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _hullnum$[ebp], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [eax+edx+324900]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 82   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PushTraceBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -144						; size = 68
_old_usehull$ = -76					; size = 4
_tr$ = -72						; size = 68
__$ArrayPad$ = -4					; size = 4
$T2 = 8							; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_flags$ = 20						; size = 4
_CL_TraceLine PROC

; 653  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 654  : 	int	old_usehull;
; 655  : 	pmtrace_t	tr;
; 656  : 
; 657  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 658  : 	clgame.pmove->usehull = 2;	

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+188], 2

; 659  : 	tr = PM_PlayerTraceExt( clgame.pmove, start, end, flags, clgame.pmove->numphysent, clgame.pmove->physents, -1, NULL );

	push	0
	push	-1
	mov	eax, DWORD PTR _clgame+1316
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 660  : 	clgame.pmove->usehull = old_usehull;

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 661  : 
; 662  : 	return tr;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _tr$[ebp]
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]

; 663  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
$T1 = -72						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_CL_VisTraceLine PROC

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi

; 674  : 	int		old_usehull;
; 675  : 	static pmtrace_t	tr;
; 676  : 
; 677  : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 678  : 	clgame.pmove->usehull = 2;	

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+188], 2

; 679  : 	tr = PM_PlayerTraceExt( clgame.pmove, start, end, flags, clgame.pmove->numvisent, clgame.pmove->visents, -1, NULL );

	push	0
	push	-1
	mov	eax, DWORD PTR _clgame+1316
	add	eax, 149336				; 00024758H
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+149332]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??CL_VisTraceLine@@9@9
	rep movsd

; 680  : 	clgame.pmove->usehull = old_usehull;

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 681  : 
; 682  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??CL_VisTraceLine@@9@9

; 683  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_VisTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_CL_TestLine PROC

; 703  : {

	push	ebp
	mov	ebp, esp

; 704  : 	return PM_TestLineExt( clgame.pmove, clgame.pmove->physents, clgame.pmove->numphysent, start, end, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	add	edx, 592				; 00000250H
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	push	eax
	call	_PM_TestLineExt
	add	esp, 24					; 00000018H

; 705  : }

	pop	ebp
	ret	0
_CL_TestLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv288 = -20						; size = 4
tv283 = -16						; size = 4
tv71 = -12						; size = 4
_ps$ = -8						; size = 4
_cd$ = -4						; size = 4
_pmove$ = 8						; size = 4
_from$ = 12						; size = 4
_ucmd$ = 16						; size = 4
_runfuncs$ = 20						; size = 4
_time$ = 24						; size = 8
_CL_SetupPMove PROC

; 977  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	push	edi

; 978  : 	entity_state_t	*ps;
; 979  : 	clientdata_t	*cd;
; 980  : 
; 981  : 	ps = &from->playerstate;

	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR _ps$[ebp], eax

; 982  : 	cd = &from->client;

	mov	ecx, DWORD PTR _from$[ebp]
	add	ecx, 340				; 00000154H
	mov	DWORD PTR _cd$[ebp], ecx

; 983  : 
; 984  : 	pmove->player_index = ps->number - 1;

	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [ecx], eax

; 985  : 	pmove->multiplayer = (cl.maxclients > 1);

	cmp	DWORD PTR _cl+1568832, 1
	jle	SHORT $LN3@CL_SetupPM
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CL_SetupPM
$LN3@CL_SetupPM:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CL_SetupPM:
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR [edx+8], eax

; 986  : 	pmove->runfuncs = runfuncs;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _runfuncs$[ebp]
	mov	DWORD PTR [ecx+325040], edx

; 987  : 	pmove->time = time * 1000.0f;

	movsd	xmm0, QWORD PTR _time$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 988  : 	pmove->frametime = ucmd->msec / 1000.0f;

	mov	ecx, DWORD PTR _ucmd$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 989  : 	VectorCopy( ps->origin, pmove->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [eax+ecx+56], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+56], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+56], ecx

; 990  : 	VectorCopy( ps->angles, pmove->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [ecx+edx+68], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [eax+edx+68], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+68], edx

; 991  : 	VectorCopy( pmove->angles, pmove->oldangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+68]
	mov	DWORD PTR [edx+eax+80], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+68]
	mov	DWORD PTR [ecx+eax+80], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+68]
	mov	DWORD PTR [edx+ecx+80], eax

; 992  : 	VectorCopy( cd->velocity, pmove->velocity );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+12]
	mov	DWORD PTR [eax+ecx+92], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+12]
	mov	DWORD PTR [edx+ecx+92], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [eax+edx+92], ecx

; 993  : 	VectorCopy( ps->basevelocity, pmove->basevelocity );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [esi+eax+188]
	mov	DWORD PTR [ecx+edx+116], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+188]
	mov	DWORD PTR [eax+edx+116], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [esi+edx+188]
	mov	DWORD PTR [ecx+eax+116], edx

; 994  : 	VectorCopy( cd->view_ofs, pmove->view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+52]
	mov	DWORD PTR [edx+eax+128], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+52]
	mov	DWORD PTR [ecx+eax+128], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+52]
	mov	DWORD PTR [edx+ecx+128], eax

; 995  : 	VectorClear( pmove->movedir );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+104], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+104], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+104], xmm0

; 996  : 	pmove->flDuckTime = cd->flDuckTime;

	mov	edx, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+80]
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+140], xmm0

; 997  : 	pmove->bInDuck = cd->bInDuck;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx+144], eax

; 998  : 	pmove->usehull = ps->usehull;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR [ecx+188], eax

; 999  : 	pmove->flTimeStepSound = cd->flTimeStepSound;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [ecx+148], eax

; 1000 : 	pmove->iStepLeft = ps->iStepLeft;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR [ecx+152], eax

; 1001 : 	pmove->flFallVelocity = ps->flFallVelocity;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+216]
	mov	DWORD PTR [ecx+156], eax

; 1002 : 	pmove->flSwimTime = cd->flSwimTime;

	mov	ecx, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [edx+172], xmm0

; 1003 : 	VectorCopy( cd->punchangle, pmove->punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+160], eax

; 1004 : 	pmove->flSwimTime = cd->flSwimTime;

	mov	ecx, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [edx+172], xmm0

; 1005 : 	pmove->flNextPrimaryAttack = 0.0f; // not used by PM_ code

	mov	eax, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+176], xmm0

; 1006 : 	pmove->effects = ps->effects;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+180], eax

; 1007 : 	pmove->flags = cd->flags;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+184], eax

; 1008 : 	pmove->gravity = ps->gravity;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	DWORD PTR [ecx+192], eax

; 1009 : 	pmove->friction = ps->friction;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR [ecx+196], eax

; 1010 : 	pmove->oldbuttons = ps->oldbuttons;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR [ecx+200], eax

; 1011 : 	pmove->waterjumptime = cd->waterjumptime;

	mov	ecx, DWORD PTR _cd$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [edx+204], xmm0

; 1012 : 	pmove->dead = (cl.local.health <= 0);

	cmp	DWORD PTR _cl+1568556, 0
	jg	SHORT $LN5@CL_SetupPM
	mov	DWORD PTR tv283[ebp], 1
	jmp	SHORT $LN6@CL_SetupPM
$LN5@CL_SetupPM:
	mov	DWORD PTR tv283[ebp], 0
$LN6@CL_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv283[ebp]
	mov	DWORD PTR [eax+208], ecx

; 1013 : 	pmove->deadflag = cd->deadflag;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR [edx+212], ecx

; 1014 : 	pmove->spectator = (cls.spectator != 0);

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN7@CL_SetupPM
	mov	DWORD PTR tv288[ebp], 1
	jmp	SHORT $LN8@CL_SetupPM
$LN7@CL_SetupPM:
	mov	DWORD PTR tv288[ebp], 0
$LN8@CL_SetupPM:
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR tv288[ebp]
	mov	DWORD PTR [edx+216], eax

; 1015 : 	pmove->movetype = ps->movetype;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx+220], eax

; 1016 : 	pmove->onground = ps->onground;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR [ecx+224], eax

; 1017 : 	pmove->waterlevel = cd->waterlevel;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+228], eax

; 1018 : 	pmove->watertype = cd->watertype;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+232], eax

; 1019 : 	pmove->maxspeed = clgame.movevars.maxspeed;

	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	xmm0, DWORD PTR _clgame+1036
	movss	DWORD PTR [ecx+500], xmm0

; 1020 : 	pmove->clientmaxspeed = cd->maxspeed;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [edx+504], ecx

; 1021 : 	pmove->iuser1 = cd->iuser1;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [edx+508], ecx

; 1022 : 	pmove->iuser2 = cd->iuser2;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR [edx+512], ecx

; 1023 : 	pmove->iuser3 = cd->iuser3;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+404]
	mov	DWORD PTR [edx+516], ecx

; 1024 : 	pmove->iuser4 = cd->iuser4;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	DWORD PTR [edx+520], ecx

; 1025 : 	pmove->fuser1 = cd->fuser1;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+412]
	mov	DWORD PTR [edx+524], ecx

; 1026 : 	pmove->fuser2 = cd->fuser2;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+416]
	mov	DWORD PTR [edx+528], ecx

; 1027 : 	pmove->fuser3 = cd->fuser3;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	mov	DWORD PTR [edx+532], ecx

; 1028 : 	pmove->fuser4 = cd->fuser4;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [eax+424]
	mov	DWORD PTR [edx+536], ecx

; 1029 : 	VectorCopy( cd->vuser1, pmove->vuser1 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+428]
	mov	DWORD PTR [ecx+edx+540], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+428]
	mov	DWORD PTR [eax+edx+540], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+428]
	mov	DWORD PTR [ecx+eax+540], edx

; 1030 : 	VectorCopy( cd->vuser2, pmove->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+440]
	mov	DWORD PTR [edx+eax+552], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+440]
	mov	DWORD PTR [ecx+eax+552], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+440]
	mov	DWORD PTR [edx+ecx+552], eax

; 1031 : 	VectorCopy( cd->vuser3, pmove->vuser3 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+452]
	mov	DWORD PTR [eax+ecx+564], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+452]
	mov	DWORD PTR [edx+ecx+564], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+452]
	mov	DWORD PTR [eax+edx+564], ecx

; 1032 : 	VectorCopy( cd->vuser4, pmove->vuser4 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	eax, DWORD PTR [esi+eax+464]
	mov	DWORD PTR [ecx+edx+576], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+464]
	mov	DWORD PTR [eax+edx+576], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _cd$[ebp]
	mov	edx, DWORD PTR [esi+edx+464]
	mov	DWORD PTR [ecx+eax+576], edx

; 1033 : 	pmove->cmd = *ucmd;	// copy current cmds	

	mov	edi, DWORD PTR _pmove$[ebp]
	add	edi, 283736				; 00045458H
	mov	ecx, 13					; 0000000dH
	mov	esi, DWORD PTR _ucmd$[ebp]
	rep movsd

; 1034 : 
; 1035 : 	Q_strncpy( pmove->physinfo, cls.physinfo, MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET _cls+6860
	mov	eax, DWORD PTR _pmove$[ebp]
	add	eax, 324592				; 0004f3f0H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1036 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetupPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_entnum$ = -4						; size = 4
_rgflPos$ = 8						; size = 4
_CL_GetWaterEntity PROC

; 693  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 694  : 	int	entnum;
; 695  : 
; 696  : 	entnum = CL_WaterEntity( rgflPos );

	mov	eax, DWORD PTR _rgflPos$[ebp]
	push	eax
	call	_CL_WaterEntity
	add	esp, 4
	mov	DWORD PTR _entnum$[ebp], eax

; 697  : 	if( entnum <= 0 ) return NULL; // world or not water

	cmp	DWORD PTR _entnum$[ebp], 0
	jg	SHORT $LN2@CL_GetWate
	xor	eax, eax
	jmp	SHORT $LN1@CL_GetWate
$LN2@CL_GetWate:

; 698  : 
; 699  : 	return CL_GetEntityByIndex( entnum );

	mov	ecx, DWORD PTR _entnum$[ebp]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
$LN1@CL_GetWate:

; 700  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetWaterEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv137 = -112						; size = 4
_oldhull$ = -108					; size = 4
_hull$ = -104						; size = 4
_i$ = -100						; size = 4
_pe$ = -96						; size = 4
_matrix$1 = -92						; size = 64
_test$ = -28						; size = 12
_offset$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_rgflPos$ = 8						; size = 4
_CL_WaterEntity PROC

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 599  : 	physent_t		*pe;
; 600  : 	hull_t		*hull;
; 601  : 	vec3_t		test, offset;
; 602  : 	int		i, oldhull;
; 603  : 
; 604  : 	if( !rgflPos ) return -1;

	cmp	DWORD PTR _rgflPos$[ebp], 0
	jne	SHORT $LN5@CL_WaterEn
	or	eax, -1
	jmp	$LN1@CL_WaterEn
$LN5@CL_WaterEn:

; 605  : 
; 606  : 	oldhull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _oldhull$[ebp], ecx

; 607  : 
; 608  : 	for( i = 0; i < clgame.pmove->numphysent; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_WaterEn
$LN2@CL_WaterEn:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_WaterEn:
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	$LN3@CL_WaterEn

; 609  : 	{
; 610  : 		pe = &clgame.pmove->physents[i];

	imul	edx, DWORD PTR _i$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 611  : 
; 612  : 		if( pe->solid != SOLID_NOT ) // disabled ?

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN6@CL_WaterEn

; 613  : 			continue;

	jmp	SHORT $LN2@CL_WaterEn
$LN6@CL_WaterEn:

; 614  : 
; 615  : 		// only brushes can have special contents
; 616  : 		if( !pe->model || pe->model->type != mod_brush )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN8@CL_WaterEn
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN7@CL_WaterEn
$LN8@CL_WaterEn:

; 617  : 			continue;

	jmp	SHORT $LN2@CL_WaterEn
$LN7@CL_WaterEn:

; 618  : 
; 619  : 		// check water brushes accuracy
; 620  : 		clgame.pmove->usehull = 2;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+188], 2

; 621  : 		hull = PM_HullForBsp( pe, clgame.pmove, offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 622  : 		clgame.pmove->usehull = oldhull;

	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR _oldhull$[ebp]
	mov	DWORD PTR [ecx+188], edx

; 623  : 
; 624  : 		// offset the test point appropriately for this hull.
; 625  : 		VectorSubtract( rgflPos, offset, test );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rgflPos$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _test$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rgflPos$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rgflPos$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv137[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR _test$[ebp+eax], xmm0

; 626  : 
; 627  : 		if( FBitSet( pe->model->flags, MODEL_HAS_ORIGIN ) && !VectorIsNull( pe->angles ))

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 2
	je	$LN9@CL_WaterEn
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_WaterEn
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_WaterEn
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@CL_WaterEn
$LN10@CL_WaterEn:

; 628  : 		{
; 629  : 			matrix4x4	matrix;
; 630  : 	
; 631  : 			Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _matrix$1[ebp]
	push	ecx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 632  : 			Matrix4x4_VectorITransform( matrix, rgflPos, test );

	lea	edx, DWORD PTR _test$[ebp]
	push	edx
	mov	eax, DWORD PTR _rgflPos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$1[ebp]
	push	ecx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN9@CL_WaterEn:

; 633  : 		}
; 634  : 
; 635  : 		// test hull for intersection with this model
; 636  : 		if( PM_HullPointContents( hull, hull->firstclipnode, test ) == CONTENTS_EMPTY )

	lea	edx, DWORD PTR _test$[ebp]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN11@CL_WaterEn

; 637  : 			continue;

	jmp	$LN2@CL_WaterEn
$LN11@CL_WaterEn:

; 638  : 
; 639  : 		// found water entity
; 640  : 		return pe->info;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [eax+80]
	jmp	SHORT $LN1@CL_WaterEn

; 641  : 	}

	jmp	$LN2@CL_WaterEn
$LN3@CL_WaterEn:

; 642  : 	return -1;

	or	eax, -1
$LN1@CL_WaterEn:

; 643  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WaterEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_CL_IsPredicted PROC

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  : 	if( cl_nopred->value || cl.intermission )

	mov	eax, DWORD PTR _cl_nopred
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_IsPredi
	cmp	DWORD PTR _cl+1568648, 0
	je	SHORT $LN2@CL_IsPredi
$LN3@CL_IsPredi:

; 104  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_IsPredi
$LN2@CL_IsPredi:

; 105  : 
; 106  : 	// never predict the quake demos
; 107  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	SHORT $LN4@CL_IsPredi

; 108  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_IsPredi
$LN4@CL_IsPredi:

; 109  : 	return true;

	mov	eax, 1
$LN1@CL_IsPredi:

; 110  : }

	pop	ebp
	ret	0
_CL_IsPredicted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv144 = -32						; size = 4
_dist$ = -28						; size = 4
_frame$ = -24						; size = 4
_cmd$ = -20						; size = 4
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_CL_CheckPredictionError PROC

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 232  : 	int		frame, cmd;
; 233  : 	static int	pos = 0;
; 234  : 	vec3_t		delta;
; 235  : 	float		dist;
; 236  : 
; 237  : 	if( !CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	jne	SHORT $LN2@CL_CheckPr

; 238  : 		return;

	jmp	$LN7@CL_CheckPr
$LN2@CL_CheckPr:

; 239  : 
; 240  : 	// calculate the last usercmd_t we sent that the server has processed
; 241  : 	frame = ( cls.netchan.incoming_acknowledged ) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23588
	mov	DWORD PTR _frame$[ebp], eax

; 242  : 	cmd = cl.parsecountmod;

	mov	ecx, DWORD PTR _cl+12
	mov	DWORD PTR _cmd$[ebp], ecx

; 243  : 
; 244  : 	// compare what the server returned with what we had predicted it to be
; 245  : 	VectorSubtract( cl.frames[cmd].playerstate[cl.playernum].origin, cl.local.predicted_origins[frame], delta );

	imul	edx, DWORD PTR _cmd$[ebp], 17304
	imul	eax, DWORD PTR _cl+1568828, 340
	lea	ecx, DWORD PTR _cl[edx+eax+596]
	mov	edx, 4
	imul	eax, edx, 0
	imul	edx, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax+16]
	subss	xmm0, DWORD PTR _cl[edx+esi+1567736]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _cmd$[ebp], 17304
	imul	eax, DWORD PTR _cl+1568828, 340
	lea	ecx, DWORD PTR _cl[edx+eax+596]
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _cl[eax+esi+1567736]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _cmd$[ebp], 17304
	imul	eax, DWORD PTR _cl+1568828, 340
	lea	ecx, DWORD PTR _cl[edx+eax+596]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _cl[eax+esi+1567736]
	movss	DWORD PTR tv144[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv144[ebp]
	movss	DWORD PTR _delta$[ebp+ecx], xmm0

; 246  : 	dist = VectorLength( delta );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 247  : 
; 248  : 	// save the prediction error for interpolation
; 249  : 	if( dist > MAX_PREDICTION_ERROR )

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@42800000
	jbe	$LN3@CL_CheckPr

; 250  : 	{
; 251  : 		if( cl_showerror->value && host_developer.value )

	mov	ecx, DWORD PTR _cl_showerror
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@CL_CheckPr
	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@CL_CheckPr

; 252  : 			Con_NPrintf( 10 + ( ++pos & 3 ), "^3player teleported:^7 %.3f units\n", dist );

	mov	edx, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	add	edx, 1
	mov	DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9, edx
	cvtss2sd xmm0, DWORD PTR _dist$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG139608
	mov	eax, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	and	eax, 3
	add	eax, 10					; 0000000aH
	push	eax
	call	_Con_NPrintf
	add	esp, 16					; 00000010H
$LN5@CL_CheckPr:

; 253  : 
; 254  : 		// a teleport or something or gamepaused
; 255  : 		VectorClear( cl.local.prediction_error );

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[ecx+1568504], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[edx+1568504], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[ecx+1568504], xmm0

; 256  : 	}

	jmp	$LN7@CL_CheckPr
$LN3@CL_CheckPr:

; 257  : 	else
; 258  : 	{
; 259  : 		if( cl_showerror->value && dist > MIN_PREDICTION_EPSILON && host_developer.value )

	mov	edx, DWORD PTR _cl_showerror
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_CheckPr
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN6@CL_CheckPr
	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_CheckPr

; 260  : 			Con_NPrintf( 10 + ( ++pos & 3 ), "^1prediction error:^7 %.3f units\n", dist );

	mov	eax, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	add	eax, 1
	mov	DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9, eax
	cvtss2sd xmm0, DWORD PTR _dist$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG139610
	mov	ecx, DWORD PTR ?pos@?1??CL_CheckPredictionError@@9@9
	and	ecx, 3
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_Con_NPrintf
	add	esp, 16					; 00000010H
$LN6@CL_CheckPr:

; 261  : 
; 262  : 		VectorCopy( cl.frames[cmd].playerstate[cl.playernum].origin, cl.local.predicted_origins[frame] );

	imul	edx, DWORD PTR _cmd$[ebp], 17304
	imul	eax, DWORD PTR _cl+1568828, 340
	lea	ecx, DWORD PTR _cl[edx+eax+596]
	mov	edx, 4
	imul	eax, edx, 0
	imul	edx, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	mov	eax, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _cl[edx+esi+1567736], eax
	imul	ecx, DWORD PTR _cmd$[ebp], 17304
	imul	edx, DWORD PTR _cl+1568828, 340
	lea	eax, DWORD PTR _cl[ecx+edx+596]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR _cl[edx+esi+1567736], eax
	imul	ecx, DWORD PTR _cmd$[ebp], 17304
	imul	edx, DWORD PTR _cl+1568828, 340
	lea	eax, DWORD PTR _cl[ecx+edx+596]
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _frame$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	mov	eax, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR _cl[edx+esi+1567736], eax

; 263  : 
; 264  : 		// save for error interpolation
; 265  : 		VectorCopy( delta, cl.local.prediction_error );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _delta$[ebp+edx]
	mov	DWORD PTR _cl[ecx+1568504], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _delta$[ebp+eax]
	mov	DWORD PTR _cl[ecx+1568504], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _delta$[ebp+eax]
	mov	DWORD PTR _cl[ecx+1568504], edx

; 266  : 
; 267  : 		if( dist > MIN_CORRECTION_DISTANCE )

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	SHORT $LN7@CL_CheckPr

; 268  : 			cls.correction_time = cl_smoothtime->value;

	mov	eax, DWORD PTR _cl_smoothtime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	QWORD PTR _cls+293048, xmm0
$LN7@CL_CheckPr:

; 269  : 	}
; 270  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckPredictionError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv1163 = -176						; size = 8
_time$ = -168						; size = 8
tv705 = -160						; size = 8
tv704 = -152						; size = 8
tv327 = -144						; size = 8
tv326 = -136						; size = 8
tv767 = -128						; size = 4
tv746 = -124						; size = 4
tv731 = -120						; size = 4
tv610 = -116						; size = 4
tv553 = -112						; size = 4
tv499 = -108						; size = 4
tv445 = -104						; size = 4
_runfuncs$ = -100					; size = 4
_stoppoint$ = -96					; size = 4
tv632 = -92						; size = 4
tv321 = -88						; size = 4
_current_command$ = -84					; size = 4
tv259 = -80						; size = 4
tv206 = -76						; size = 4
_frac$1 = -72						; size = 4
_current_command_mod$ = -68				; size = 4
_ent$ = -64						; size = 4
_from_cmd$ = -60					; size = 4
_i$ = -56						; size = 4
_to_cmd$ = -52						; size = 4
_f$ = -48						; size = 8
_frame$ = -40						; size = 4
_from$ = -36						; size = 4
_to$ = -32						; size = 4
_delta$2 = -28						; size = 12
_delta$3 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_repredicting$ = 8					; size = 4
_CL_PredictMovement PROC

; 1166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1167 : 	runcmd_t		*to_cmd, *from_cmd;
; 1168 : 	local_state_t	*from = NULL, *to = NULL;

	mov	DWORD PTR _from$[ebp], 0
	mov	DWORD PTR _to$[ebp], 0

; 1169 : 	int		current_command;
; 1170 : 	int		current_command_mod;
; 1171 : 	frame_t		*frame = NULL;

	mov	DWORD PTR _frame$[ebp], 0

; 1172 : 	int		i, stoppoint;
; 1173 : 	qboolean		runfuncs;
; 1174 : 	double		f = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _f$[ebp], xmm0

; 1175 : 	cl_entity_t	*ent;
; 1176 : 	double		time;
; 1177 : 
; 1178 : 	if( cls.state != ca_active || cls.spectator )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN6@CL_Predict
	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN5@CL_Predict
$LN6@CL_Predict:

; 1179 : 		return;

	jmp	$LN1@CL_Predict
$LN5@CL_Predict:

; 1180 : 
; 1181 : 	if( cls.demoplayback && !repredicting )

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN7@CL_Predict
	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN7@CL_Predict

; 1182 : 		CL_DemoInterpolateAngles();

	call	_CL_DemoInterpolateAngles
$LN7@CL_Predict:

; 1183 : 
; 1184 : 	CL_SetUpPlayerPrediction( false, false );

	push	0
	push	0
	call	_CL_SetUpPlayerPrediction
	add	esp, 8

; 1185 : 
; 1186 : 	if( cls.state != ca_active || !cl.validsequence )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN9@CL_Predict
	cmp	DWORD PTR _cl+4, 0
	jne	SHORT $LN8@CL_Predict
$LN9@CL_Predict:

; 1187 : 		return;

	jmp	$LN1@CL_Predict
$LN8@CL_Predict:

; 1188 : 
; 1189 : 	if(( cls.netchan.outgoing_sequence - cls.netchan.incoming_acknowledged ) >= CL_UPDATE_MASK )

	mov	eax, DWORD PTR _cls+23600
	sub	eax, DWORD PTR _cls+23588
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	cmp	eax, ecx
	jl	SHORT $LN10@CL_Predict

; 1190 : 		return;

	jmp	$LN1@CL_Predict
$LN10@CL_Predict:

; 1191 : 
; 1192 : 	// this is the last frame received from the server
; 1193 : 	frame = &cl.frames[cl.parsecountmod];

	imul	edx, DWORD PTR _cl+12, 17304
	add	edx, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], edx

; 1194 : 
; 1195 : 	if( !CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	jne	$LN13@CL_Predict

; 1196 : 	{
; 1197 : 		VectorCopy( frame->clientdata.velocity, cl.simvel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+44]
	mov	DWORD PTR _cl[eax+1568816], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+44]
	mov	DWORD PTR _cl[eax+1568816], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+44]
	mov	DWORD PTR _cl[ecx+1568816], eax

; 1198 : 		VectorCopy( frame->clientdata.origin, cl.simorg );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [eax+edx+32]
	mov	DWORD PTR _cl[ecx+1568804], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _cl[ecx+1568804], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR _cl[edx+1568804], ecx

; 1199 : 		VectorCopy( frame->clientdata.punchangle, cl.punchangle );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [ecx+eax+60]
	mov	DWORD PTR _cl[edx+1568636], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+60]
	mov	DWORD PTR _cl[edx+1568636], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+60]
	mov	DWORD PTR _cl[eax+1568636], edx

; 1200 : 		VectorCopy( frame->clientdata.view_ofs, cl.viewheight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+84]
	mov	DWORD PTR _cl[eax+1568624], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+edx+84]
	mov	DWORD PTR _cl[eax+1568624], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+eax+84]
	mov	DWORD PTR _cl[ecx+1568624], eax

; 1201 : 		cl.local.usehull = frame->playerstate[cl.playernum].usehull;

	imul	ecx, DWORD PTR _cl+1568828, 340
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+ecx+708]
	mov	DWORD PTR _cl+1568572, eax

; 1202 : 		cl.local.waterlevel = frame->clientdata.waterlevel;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR _cl+1568568, edx

; 1203 : 
; 1204 : 		if( FBitSet( frame->clientdata.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	and	ecx, 512				; 00000200H
	je	SHORT $LN12@CL_Predict

; 1205 : 			cl.local.onground = frame->playerstate[cl.playernum].onground;

	imul	edx, DWORD PTR _cl+1568828, 340
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+edx+716]
	mov	DWORD PTR _cl+1568560, ecx
	jmp	SHORT $LN13@CL_Predict
$LN12@CL_Predict:

; 1206 : 		else cl.local.onground = -1;

	mov	DWORD PTR _cl+1568560, -1
$LN13@CL_Predict:

; 1207 : 	}
; 1208 : 
; 1209 : 	from = &cl.predicted_frames[cl.parsecountmod];

	imul	edx, DWORD PTR _cl+12, 6448
	add	edx, OFFSET _cl+1113176
	mov	DWORD PTR _from$[ebp], edx

; 1210 : 	from_cmd = &cl.commands[cls.netchan.incoming_acknowledged & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23588
	imul	ecx, eax, 88
	add	ecx, OFFSET _cl+1107544
	mov	DWORD PTR _from_cmd$[ebp], ecx

; 1211 : 	memcpy( from->weapondata, frame->weapondata, sizeof( from->weapondata ));

	push	5632					; 00001600H
	mov	edx, DWORD PTR _frame$[ebp]
	add	edx, 11388				; 00002c7cH
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	add	eax, 816				; 00000330H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1212 : 	from->playerstate = frame->playerstate[cl.playernum];

	imul	ecx, DWORD PTR _cl+1568828, 340
	mov	edx, DWORD PTR _frame$[ebp]
	lea	esi, DWORD PTR [edx+ecx+508]
	mov	ecx, 85					; 00000055H
	mov	edi, DWORD PTR _from$[ebp]
	rep movsd

; 1213 : 	from->client = frame->clientdata;

	mov	esi, DWORD PTR _frame$[ebp]
	add	esi, 32					; 00000020H
	mov	edi, DWORD PTR _from$[ebp]
	add	edi, 340				; 00000154H
	mov	ecx, 119				; 00000077H
	rep movsd

; 1214 : 	if( !frame->valid ) return;

	mov	eax, DWORD PTR _frame$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN14@CL_Predict
	jmp	$LN1@CL_Predict
$LN14@CL_Predict:

; 1215 : 
; 1216 : 	time = frame->time;

	mov	ecx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [ecx+16]
	movsd	QWORD PTR _time$[ebp], xmm0

; 1217 : 	stoppoint = ( repredicting ) ? 0 : 1;

	cmp	DWORD PTR _repredicting$[ebp], 0
	je	SHORT $LN39@CL_Predict
	mov	DWORD PTR tv206[ebp], 0
	jmp	SHORT $LN40@CL_Predict
$LN39@CL_Predict:
	mov	DWORD PTR tv206[ebp], 1
$LN40@CL_Predict:
	mov	edx, DWORD PTR tv206[ebp]
	mov	DWORD PTR _stoppoint$[ebp], edx

; 1218 : 	cl.local.repredicting = repredicting;

	mov	eax, DWORD PTR _repredicting$[ebp]
	mov	DWORD PTR _cl+1568536, eax

; 1219 : 	cl.local.onground = -1;

	mov	DWORD PTR _cl+1568560, -1

; 1220 : 
; 1221 : 	// predict forward until cl.time <= to->senttime
; 1222 : 	CL_PushPMStates();

	call	_CL_PushPMStates

; 1223 : 	CL_SetSolidPlayers( cl.playernum );

	mov	ecx, DWORD PTR _cl+1568828
	push	ecx
	call	_CL_SetSolidPlayers
	add	esp, 4

; 1224 : 
; 1225 : 	for( i = 1; i < CL_UPDATE_MASK && cls.netchan.incoming_acknowledged + i < cls.netchan.outgoing_sequence + stoppoint; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_Predict
$LN2@CL_Predict:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_Predict:
	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@CL_Predict
	mov	ecx, DWORD PTR _cls+23588
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cls+23600
	add	edx, DWORD PTR _stoppoint$[ebp]
	cmp	ecx, edx
	jge	$LN3@CL_Predict

; 1226 : 	{
; 1227 : 		current_command = cls.netchan.incoming_acknowledged + i;

	mov	eax, DWORD PTR _cls+23588
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _current_command$[ebp], eax

; 1228 : 		current_command_mod = current_command & CL_UPDATE_MASK;

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _current_command$[ebp]
	mov	DWORD PTR _current_command_mod$[ebp], ecx

; 1229 : 
; 1230 : 		to = &cl.predicted_frames[(cl.parsecountmod + i) & CL_UPDATE_MASK];

	mov	edx, DWORD PTR _cl+12
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	edx, eax
	imul	ecx, edx, 6448
	add	ecx, OFFSET _cl+1113176
	mov	DWORD PTR _to$[ebp], ecx

; 1231 : 		to_cmd = &cl.commands[current_command_mod];

	imul	edx, DWORD PTR _current_command_mod$[ebp], 88
	add	edx, OFFSET _cl+1107544
	mov	DWORD PTR _to_cmd$[ebp], edx

; 1232 : 		runfuncs = ( !repredicting && !to_cmd->processedfuncs );

	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN41@CL_Predict
	mov	eax, DWORD PTR _to_cmd$[ebp]
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $LN41@CL_Predict
	mov	DWORD PTR tv259[ebp], 1
	jmp	SHORT $LN42@CL_Predict
$LN41@CL_Predict:
	mov	DWORD PTR tv259[ebp], 0
$LN42@CL_Predict:
	mov	ecx, DWORD PTR tv259[ebp]
	mov	DWORD PTR _runfuncs$[ebp], ecx

; 1233 : 
; 1234 : 		CL_RunUsercmd( from, to, &to_cmd->cmd, runfuncs, &time, current_command );

	mov	edx, DWORD PTR _current_command$[ebp]
	push	edx
	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _runfuncs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to_cmd$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	call	_CL_RunUsercmd
	add	esp, 24					; 00000018H

; 1235 : 		VectorCopy( to->playerstate.origin, cl.local.predicted_origins[current_command_mod] );

	mov	edx, 4
	imul	eax, edx, 0
	imul	ecx, DWORD PTR _current_command_mod$[ebp], 12
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR _cl[ecx+edx+1567736], eax
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _current_command_mod$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR _cl[edx+eax+1567736], ecx
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _current_command_mod$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR _cl[eax+ecx+1567736], edx

; 1236 : 		to_cmd->processedfuncs = true;

	mov	eax, DWORD PTR _to_cmd$[ebp]
	mov	DWORD PTR [eax+72], 1

; 1237 : 
; 1238 : 		if( to_cmd->senttime >= host.realtime )

	mov	ecx, DWORD PTR _to_cmd$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR _host+1440
	jb	SHORT $LN15@CL_Predict

; 1239 : 			break;

	jmp	SHORT $LN3@CL_Predict
$LN15@CL_Predict:

; 1240 : 
; 1241 : 		// now interpolate some fraction of the final frame
; 1242 : 		if( to_cmd->senttime != from_cmd->senttime )

	mov	edx, DWORD PTR _to_cmd$[ebp]
	mov	eax, DWORD PTR _from_cmd$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	ucomisd	xmm0, QWORD PTR [eax]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@CL_Predict

; 1243 : 			f = (host.realtime - from_cmd->senttime) / (to_cmd->senttime - from_cmd->senttime) * 0.1;

	mov	ecx, DWORD PTR _from_cmd$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _to_cmd$[ebp]
	mov	eax, DWORD PTR _from_cmd$[ebp]
	movsd	xmm1, QWORD PTR [edx]
	subsd	xmm1, QWORD PTR [eax]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3fb999999999999a
	movsd	QWORD PTR _f$[ebp], xmm0
$LN16@CL_Predict:

; 1244 : 
; 1245 : 		from = to;

	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR _from$[ebp], ecx

; 1246 : 		from_cmd = to_cmd;

	mov	edx, DWORD PTR _to_cmd$[ebp]
	mov	DWORD PTR _from_cmd$[ebp], edx

; 1247 : 	}

	jmp	$LN2@CL_Predict
$LN3@CL_Predict:

; 1248 : 
; 1249 : 	CL_PopPMStates();

	call	_CL_PopPMStates

; 1250 : 
; 1251 : 	if(( i == CL_UPDATE_MASK ) || ( !to && !repredicting ))

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $LN18@CL_Predict
	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN17@CL_Predict
	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN17@CL_Predict
$LN18@CL_Predict:

; 1252 : 	{
; 1253 : 		cl.local.repredicting = false;

	mov	DWORD PTR _cl+1568536, 0

; 1254 : 		return; // net hasn't deliver packets in a long time...

	jmp	$LN1@CL_Predict
$LN17@CL_Predict:

; 1255 : 	}
; 1256 : 
; 1257 : 	if( !to )

	cmp	DWORD PTR _to$[ebp], 0
	jne	SHORT $LN19@CL_Predict

; 1258 : 	{
; 1259 : 		to = from;

	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR _to$[ebp], ecx

; 1260 : 		to_cmd = from_cmd;

	mov	edx, DWORD PTR _from_cmd$[ebp]
	mov	DWORD PTR _to_cmd$[ebp], edx
$LN19@CL_Predict:

; 1261 : 	}
; 1262 : 
; 1263 : 	if( !CL_IsPredicted( ))

	call	_CL_IsPredicted
	test	eax, eax
	jne	$LN20@CL_Predict

; 1264 : 	{
; 1265 : 		// keep onground actual
; 1266 : 		if( FBitSet( frame->clientdata.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	and	ecx, 512				; 00000200H
	je	SHORT $LN21@CL_Predict

; 1267 : 			cl.local.onground = frame->playerstate[cl.playernum].onground;

	imul	edx, DWORD PTR _cl+1568828, 340
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+edx+716]
	mov	DWORD PTR _cl+1568560, ecx
	jmp	SHORT $LN22@CL_Predict
$LN21@CL_Predict:

; 1268 : 		else cl.local.onground = -1;

	mov	DWORD PTR _cl+1568560, -1
$LN22@CL_Predict:

; 1269 : 
; 1270 : 		if( !repredicting || !CVAR_TO_BOOL( cl_lw ))

	cmp	DWORD PTR _repredicting$[ebp], 0
	je	SHORT $LN24@CL_Predict
	cmp	DWORD PTR _cl_lw, 0
	je	SHORT $LN43@CL_Predict
	mov	edx, DWORD PTR _cl_lw
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN43@CL_Predict
	mov	DWORD PTR tv321[ebp], 1
	jmp	SHORT $LN44@CL_Predict
$LN43@CL_Predict:
	mov	DWORD PTR tv321[ebp], 0
$LN44@CL_Predict:
	cmp	DWORD PTR tv321[ebp], 0
	jne	SHORT $LN23@CL_Predict
$LN24@CL_Predict:

; 1271 : 			cl.local.viewmodel = to->client.viewmodel;

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+364]
	mov	DWORD PTR _cl+1568552, ecx
$LN23@CL_Predict:

; 1272 : 		cl.local.repredicting = false;

	mov	DWORD PTR _cl+1568536, 0

; 1273 : 		cl.local.moving = false;

	mov	DWORD PTR _cl+1568576, 0

; 1274 : 		return;

	jmp	$LN1@CL_Predict
$LN20@CL_Predict:

; 1275 : 	}
; 1276 : 
; 1277 : 	f = bound( 0.0f, f, 1.0f );

	movsd	xmm0, QWORD PTR _f$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN47@CL_Predict
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR _f$[ebp]
	jbe	SHORT $LN45@CL_Predict
	movsd	xmm0, QWORD PTR _f$[ebp]
	movsd	QWORD PTR tv326[ebp], xmm0
	jmp	SHORT $LN46@CL_Predict
$LN45@CL_Predict:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv326[ebp], xmm0
$LN46@CL_Predict:
	movsd	xmm0, QWORD PTR tv326[ebp]
	movsd	QWORD PTR tv327[ebp], xmm0
	jmp	SHORT $LN48@CL_Predict
$LN47@CL_Predict:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv327[ebp], xmm0
$LN48@CL_Predict:
	movsd	xmm0, QWORD PTR tv327[ebp]
	movsd	QWORD PTR _f$[ebp], xmm0

; 1278 : 	f = 0.0;	// FIXME: make work, do revision

	xorps	xmm0, xmm0
	movsd	QWORD PTR _f$[ebp], xmm0

; 1279 : 
; 1280 : 	if( CL_PlayerTeleported( from, to ))

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_CL_PlayerTeleported
	add	esp, 8
	test	eax, eax
	je	$LN25@CL_Predict

; 1281 : 	{
; 1282 : 		VectorCopy( to->client.velocity, cl.simvel );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [eax+edx+352]
	mov	DWORD PTR _cl[ecx+1568816], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+352]
	mov	DWORD PTR _cl[ecx+1568816], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+352]
	mov	DWORD PTR _cl[edx+1568816], ecx

; 1283 : 		VectorCopy( to->playerstate.origin, cl.simorg );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _cl[edx+1568804], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR _cl[edx+1568804], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _cl[eax+1568804], edx

; 1284 : 		VectorCopy( to->client.punchangle, cl.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+368]
	mov	DWORD PTR _cl[eax+1568636], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+edx+368]
	mov	DWORD PTR _cl[eax+1568636], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+368]
	mov	DWORD PTR _cl[ecx+1568636], eax

; 1285 : 		VectorCopy( to->client.view_ofs, cl.viewheight );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [eax+edx+392]
	mov	DWORD PTR _cl[ecx+1568624], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+392]
	mov	DWORD PTR _cl[ecx+1568624], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+392]
	mov	DWORD PTR _cl[edx+1568624], ecx

; 1286 : 	}

	jmp	$LN28@CL_Predict
$LN25@CL_Predict:

; 1287 : 	else
; 1288 : 	{
; 1289 : 		VectorLerp( from->playerstate.origin, f, to->playerstate.origin, cl.simorg );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+16]
	subss	xmm1, DWORD PTR [esi+edx+16]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[eax+1568804], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+16]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+16]
	subss	xmm1, DWORD PTR [esi+ecx+16]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[eax+1568804], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+16]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+16]
	subss	xmm1, DWORD PTR [esi+ecx+16]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv445[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv445[ebp]
	movss	DWORD PTR _cl[eax+1568804], xmm0

; 1290 : 		VectorLerp( from->client.velocity, f, to->client.velocity, cl.simvel );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+352]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+352]
	subss	xmm1, DWORD PTR [esi+ecx+352]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[edx+1568816], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax+352]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+352]
	subss	xmm1, DWORD PTR [esi+eax+352]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[edx+1568816], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax+352]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+352]
	subss	xmm1, DWORD PTR [esi+eax+352]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv499[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv499[ebp]
	movss	DWORD PTR _cl[edx+1568816], xmm0

; 1291 : 		VectorLerp( from->client.punchangle, f, to->client.punchangle, cl.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+368]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx+368]
	subss	xmm1, DWORD PTR [esi+eax+368]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+1568636], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+368]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+368]
	subss	xmm1, DWORD PTR [esi+edx+368]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[ecx+1568636], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+368]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+368]
	subss	xmm1, DWORD PTR [esi+edx+368]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv553[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv553[ebp]
	movss	DWORD PTR _cl[ecx+1568636], xmm0

; 1292 : 
; 1293 : 		if( from->playerstate.usehull == to->playerstate.usehull )

	mov	edx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [edx+200]
	cmp	ecx, DWORD PTR [eax+200]
	jne	$LN27@CL_Predict

; 1294 : 			VectorLerp( from->client.view_ofs, f, to->client.view_ofs, cl.viewheight );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax+392]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+392]
	subss	xmm1, DWORD PTR [esi+edx+392]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[eax+1568624], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+392]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+392]
	subss	xmm1, DWORD PTR [esi+ecx+392]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl[eax+1568624], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _from$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+392]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _to$[ebp]
	mov	esi, DWORD PTR _from$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+392]
	subss	xmm1, DWORD PTR [esi+ecx+392]
	cvtss2sd xmm1, xmm1
	mulsd	xmm1, QWORD PTR _f$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv610[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv610[ebp]
	movss	DWORD PTR _cl[eax+1568624], xmm0
	jmp	SHORT $LN28@CL_Predict
$LN27@CL_Predict:

; 1295 : 		else VectorCopy( to->client.view_ofs, cl.viewheight );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [eax+edx+392]
	mov	DWORD PTR _cl[ecx+1568624], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+eax+392]
	mov	DWORD PTR _cl[ecx+1568624], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+392]
	mov	DWORD PTR _cl[edx+1568624], ecx
$LN28@CL_Predict:

; 1296 : 	}
; 1297 : 
; 1298 : 	cl.local.waterlevel = to->client.waterlevel;

	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+384]
	mov	DWORD PTR _cl+1568568, eax

; 1299 : 	cl.local.usehull = to->playerstate.usehull;

	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR _cl+1568572, edx

; 1300 : 	if( !repredicting || !CVAR_TO_BOOL( cl_lw ))

	cmp	DWORD PTR _repredicting$[ebp], 0
	je	SHORT $LN30@CL_Predict
	cmp	DWORD PTR _cl_lw, 0
	je	SHORT $LN49@CL_Predict
	mov	eax, DWORD PTR _cl_lw
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN49@CL_Predict
	mov	DWORD PTR tv632[ebp], 1
	jmp	SHORT $LN50@CL_Predict
$LN49@CL_Predict:
	mov	DWORD PTR tv632[ebp], 0
$LN50@CL_Predict:
	cmp	DWORD PTR tv632[ebp], 0
	jne	SHORT $LN29@CL_Predict
$LN30@CL_Predict:

; 1301 : 		cl.local.viewmodel = to->client.viewmodel;

	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+364]
	mov	DWORD PTR _cl+1568552, edx
$LN29@CL_Predict:

; 1302 : 
; 1303 : 	if( FBitSet( to->client.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+380]
	and	ecx, 512				; 00000200H
	je	$LN31@CL_Predict

; 1304 : 	{
; 1305 : 		ent = CL_GetEntityByIndex( cl.local.lastground );

	mov	edx, DWORD PTR _cl+1568528
	push	edx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1306 : 		cl.local.onground = cl.local.lastground;

	mov	eax, DWORD PTR _cl+1568528
	mov	DWORD PTR _cl+1568560, eax

; 1307 : 		cl.local.moving = false;

	mov	DWORD PTR _cl+1568576, 0

; 1308 : 
; 1309 : 		if( ent )

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN34@CL_Predict

; 1310 : 		{
; 1311 : 			vec3_t delta;
; 1312 : 
; 1313 : 			delta[0] = ent->curstate.origin[0] - ent->prevstate.origin[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+704]
	subss	xmm0, DWORD PTR [esi+ecx+364]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$2[ebp+edx], xmm0

; 1314 : 			delta[1] = ent->curstate.origin[1] - ent->prevstate.origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+704]
	subss	xmm0, DWORD PTR [esi+ecx+364]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _delta$2[ebp+eax], xmm0

; 1315 : 			delta[2] = 0.0f;

	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _delta$2[ebp+ecx], xmm0

; 1316 : 
; 1317 : 			if( VectorLength( delta ) > 0.0f )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$2[ebp+eax]
	mulss	xmm0, DWORD PTR _delta$2[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _delta$2[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$2[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _delta$2[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$2[ebp+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv1163[ebp]
	movsd	xmm0, QWORD PTR tv1163[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN34@CL_Predict

; 1318 : 			{
; 1319 : 				cls.correction_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+293048, xmm0

; 1320 : 				cl.local.moving = true;

	mov	DWORD PTR _cl+1568576, 1
$LN34@CL_Predict:

; 1321 : 			}
; 1322 : 		}
; 1323 : 	}

	jmp	SHORT $LN32@CL_Predict
$LN31@CL_Predict:

; 1324 : 	else
; 1325 : 	{
; 1326 : 		cl.local.onground = -1;

	mov	DWORD PTR _cl+1568560, -1

; 1327 : 		cl.local.moving = 0;

	mov	DWORD PTR _cl+1568576, 0
$LN32@CL_Predict:

; 1328 : 	}
; 1329 : 
; 1330 : 	if( cls.correction_time > 0 && !cl_nosmooth->value && cl_smoothtime->value )

	movsd	xmm0, QWORD PTR _cls+293048
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN35@CL_Predict
	mov	ecx, DWORD PTR _cl_nosmooth
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN35@CL_Predict
	mov	edx, DWORD PTR _cl_smoothtime
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN35@CL_Predict

; 1331 : 	{
; 1332 : 		vec3_t	delta;
; 1333 : 		float	frac;
; 1334 : 
; 1335 : 		// only decay timer once per frame
; 1336 : 		if( !repredicting )

	cmp	DWORD PTR _repredicting$[ebp], 0
	jne	SHORT $LN36@CL_Predict

; 1337 : 			cls.correction_time -= host.frametime;

	movsd	xmm0, QWORD PTR _cls+293048
	subsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _cls+293048, xmm0
$LN36@CL_Predict:

; 1338 : 
; 1339 : 		// Make sure smoothtime is postive
; 1340 : 		if( cl_smoothtime->value <= 0.0 )

	mov	eax, DWORD PTR _cl_smoothtime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	xorps	xmm1, xmm1
	comisd	xmm1, xmm0
	jb	SHORT $LN37@CL_Predict

; 1341 : 			Cvar_DirectSet( cl_smoothtime, "0.1" );

	push	OFFSET $SG140109
	mov	ecx, DWORD PTR _cl_smoothtime
	push	ecx
	call	_Cvar_DirectSet
	add	esp, 8
$LN37@CL_Predict:

; 1342 : 
; 1343 : 		// Clamp from 0 to cl_smoothtime.value
; 1344 : 		cls.correction_time = bound( 0.0, cls.correction_time, cl_smoothtime->value );

	movsd	xmm0, QWORD PTR _cls+293048
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN53@CL_Predict
	mov	edx, DWORD PTR _cl_smoothtime
	movss	xmm0, DWORD PTR [edx+12]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _cls+293048
	jbe	SHORT $LN51@CL_Predict
	movsd	xmm0, QWORD PTR _cls+293048
	movsd	QWORD PTR tv704[ebp], xmm0
	jmp	SHORT $LN52@CL_Predict
$LN51@CL_Predict:
	mov	eax, DWORD PTR _cl_smoothtime
	movss	xmm0, DWORD PTR [eax+12]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv704[ebp], xmm0
$LN52@CL_Predict:
	movsd	xmm0, QWORD PTR tv704[ebp]
	movsd	QWORD PTR tv705[ebp], xmm0
	jmp	SHORT $LN54@CL_Predict
$LN53@CL_Predict:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv705[ebp], xmm0
$LN54@CL_Predict:
	movsd	xmm0, QWORD PTR tv705[ebp]
	movsd	QWORD PTR _cls+293048, xmm0

; 1345 : 
; 1346 : 		// Compute backward interpolation fraction along full correction
; 1347 : 		frac = 1.0 - cls.correction_time / cl_smoothtime->value;

	mov	ecx, DWORD PTR _cl_smoothtime
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	movsd	xmm1, QWORD PTR _cls+293048
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _frac$1[ebp], xmm0

; 1348 : 
; 1349 : 		// Determine how much error we still have to make up for
; 1350 : 		VectorSubtract( cl.simorg, cl.local.lastorigin, delta );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _cl[eax+1568804]
	subss	xmm0, DWORD PTR _cl[edx+1568516]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$3[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[edx+1568804]
	subss	xmm0, DWORD PTR _cl[eax+1568516]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$3[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _cl[edx+1568804]
	subss	xmm0, DWORD PTR _cl[eax+1568516]
	movss	DWORD PTR tv731[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv731[ebp]
	movss	DWORD PTR _delta$3[ebp+ecx], xmm0

; 1351 : 
; 1352 : 		// Scale the error by the backlerp fraction
; 1353 : 		VectorScale( delta, frac, delta );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$3[ebp+eax]
	mulss	xmm0, DWORD PTR _frac$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$3[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _delta$3[ebp+eax]
	mulss	xmm0, DWORD PTR _frac$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$3[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _delta$3[ebp+edx]
	mulss	xmm0, DWORD PTR _frac$1[ebp]
	movss	DWORD PTR tv746[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv746[ebp]
	movss	DWORD PTR _delta$3[ebp+eax], xmm0

; 1354 : 
; 1355 : 		// Go some fraction of the way
; 1356 : 		// FIXME, Probably can't do this any more
; 1357 : 		VectorAdd( cl.local.lastorigin, delta, cl.simorg );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _cl[edx+1568516]
	addss	xmm0, DWORD PTR _delta$3[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _cl[eax+1568804], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _cl[ecx+1568516]
	addss	xmm0, DWORD PTR _delta$3[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _cl[eax+1568804], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _cl[ecx+1568516]
	addss	xmm0, DWORD PTR _delta$3[ebp+edx]
	movss	DWORD PTR tv767[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv767[ebp]
	movss	DWORD PTR _cl[eax+1568804], xmm0
$LN35@CL_Predict:

; 1358 : 	}
; 1359 : 
; 1360 : 	VectorCopy( cl.simorg, cl.local.lastorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl[edx+1568804]
	mov	DWORD PTR _cl[ecx+1568516], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cl[eax+1568804]
	mov	DWORD PTR _cl[ecx+1568516], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cl[eax+1568804]
	mov	DWORD PTR _cl[ecx+1568516], edx

; 1361 : 	cl.local.repredicting = false;

	mov	DWORD PTR _cl+1568536, 0
$LN1@CL_Predict:

; 1362 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PredictMovement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_InitClientMove PROC

; 908  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 909  : 	int	i;
; 910  : 
; 911  : 	Pmove_Init ();

	call	_Pmove_Init

; 912  : 
; 913  : 	clgame.pmove->server = false;	// running at client

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+4], 0

; 914  : 	clgame.pmove->movevars = &clgame.movevars;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+324848], OFFSET _clgame+1028

; 915  : 	clgame.pmove->runfuncs = false;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325040], 0

; 916  : 
; 917  : 	// enumerate client hulls
; 918  : 	for( i = 0; i < MAX_MAP_HULLS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_InitCli
$LN2@CL_InitCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_InitCli:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@CL_InitCli

; 919  : 	{
; 920  : 		if( clgame.dllFuncs.pfnGetHullBounds( i, host.player_mins[i], host.player_maxs[i] ))

	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, OFFSET _host+34284
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, OFFSET _host+34236
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	DWORD PTR _clgame+132
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@CL_InitCli

; 921  : 			Con_Reportf( "CL: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g\n", i,

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR _host[ecx+edx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR _host[eax+ecx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _host[edx+ecx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	cvtss2sd xmm0, DWORD PTR _host[edx+eax+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _host[ecx+edx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtss2sd xmm0, DWORD PTR _host[eax+edx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG139991
	call	_Con_Reportf
	add	esp, 56					; 00000038H
$LN5@CL_InitCli:

; 922  : 			host.player_mins[i][0], host.player_mins[i][1], host.player_mins[i][2],
; 923  : 			host.player_maxs[i][0], host.player_maxs[i][1], host.player_maxs[i][2] );
; 924  : 	}

	jmp	$LN2@CL_InitCli
$LN3@CL_InitCli:

; 925  : 
; 926  : 	memcpy( clgame.pmove->player_mins, host.player_mins, sizeof( host.player_mins ));

	push	48					; 00000030H
	push	OFFSET _host+34236
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 324852				; 0004f4f4H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 927  : 	memcpy( clgame.pmove->player_maxs, host.player_maxs, sizeof( host.player_maxs ));

	push	48					; 00000030H
	push	OFFSET _host+34284
	mov	edx, DWORD PTR _clgame+1316
	add	edx, 324900				; 0004f524H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 928  : 
; 929  : 	// common utilities
; 930  : 	clgame.pmove->PM_Info_ValueForKey = Info_ValueForKey;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+324948], OFFSET _Info_ValueForKey

; 931  : 	clgame.pmove->PM_Particle = CL_Particle;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+324952], OFFSET _CL_Particle

; 932  : 	clgame.pmove->PM_TestPlayerPosition = pfnTestPlayerPosition;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+324956], OFFSET _pfnTestPlayerPosition

; 933  : 	clgame.pmove->Con_NPrintf = Con_NPrintf;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+324960], OFFSET _Con_NPrintf

; 934  : 	clgame.pmove->Con_DPrintf = Con_DPrintf;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+324964], OFFSET _Con_DPrintf

; 935  : 	clgame.pmove->Con_Printf = Con_Printf;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+324968], OFFSET _Con_Printf

; 936  : 	clgame.pmove->Sys_FloatTime = Sys_DoubleTime;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+324972], OFFSET _Sys_DoubleTime

; 937  : 	clgame.pmove->PM_StuckTouch = pfnStuckTouch;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+324976], OFFSET _pfnStuckTouch

; 938  : 	clgame.pmove->PM_PointContents = pfnPointContents;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+324980], OFFSET _pfnPointContents

; 939  : 	clgame.pmove->PM_TruePointContents = pfnTruePointContents;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+324984], OFFSET _pfnTruePointContents

; 940  : 	clgame.pmove->PM_HullPointContents = pfnHullPointContents; 

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+324988], OFFSET _pfnHullPointContents

; 941  : 	clgame.pmove->PM_PlayerTrace = pfnPlayerTrace;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+324992], OFFSET _pfnPlayerTrace

; 942  : 	clgame.pmove->PM_TraceLine = pfnTraceLine;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+324996], OFFSET _pfnTraceLine

; 943  : 	clgame.pmove->RandomLong = COM_RandomLong;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+325000], OFFSET _COM_RandomLong

; 944  : 	clgame.pmove->RandomFloat = COM_RandomFloat;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325004], OFFSET _COM_RandomFloat

; 945  : 	clgame.pmove->PM_GetModelType = pfnGetModelType;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+325008], OFFSET _pfnGetModelType

; 946  : 	clgame.pmove->PM_GetModelBounds = pfnGetModelBounds;	

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+325012], OFFSET _pfnGetModelBounds

; 947  : 	clgame.pmove->PM_HullForBsp = pfnHullForBsp;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325016], OFFSET _pfnHullForBsp

; 948  : 	clgame.pmove->PM_TraceModel = pfnTraceModel;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+325020], OFFSET _pfnTraceModel

; 949  : 	clgame.pmove->COM_FileSize = COM_FileSize;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+325024], OFFSET _COM_FileSize

; 950  : 	clgame.pmove->COM_LoadFile = COM_LoadFile;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325028], OFFSET _COM_LoadFile

; 951  : 	clgame.pmove->COM_FreeFile = COM_FreeFile;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+325032], OFFSET _COM_FreeFile

; 952  : 	clgame.pmove->memfgets = COM_MemFgets;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+325036], OFFSET _COM_MemFgets

; 953  : 	clgame.pmove->PM_PlaySound = pfnPlaySound;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325044], OFFSET _pfnPlaySound

; 954  : 	clgame.pmove->PM_TraceTexture = pfnTraceTexture;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+325048], OFFSET _pfnTraceTexture

; 955  : 	clgame.pmove->PM_PlaybackEventFull = pfnPlaybackEventFull;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+325052], OFFSET _pfnPlaybackEventFull

; 956  : 	clgame.pmove->PM_PlayerTraceEx = pfnPlayerTraceEx;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325056], OFFSET _pfnPlayerTraceEx

; 957  : 	clgame.pmove->PM_TestPlayerPositionEx = pfnTestPlayerPositionEx;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+325060], OFFSET _pfnTestPlayerPositionEx

; 958  : 	clgame.pmove->PM_TraceLineEx = pfnTraceLineEx;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+325064], OFFSET _pfnTraceLineEx

; 959  : 	clgame.pmove->PM_TraceSurface = pfnTraceSurface;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+325068], OFFSET _pfnTraceSurface

; 960  : 
; 961  : 	// initalize pmove
; 962  : 	clgame.dllFuncs.pfnPlayerMoveInit( clgame.pmove );

	mov	eax, DWORD PTR _clgame+1316
	push	eax
	call	DWORD PTR _clgame+32
	add	esp, 4

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitClientMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_state$ = -16						; size = 4
_i$ = -12						; size = 4
_pe$ = -8						; size = 4
_player$ = -4						; size = 4
_playernum$ = 8						; size = 4
_CL_SetSolidPlayers PROC

; 542  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 543  : 	entity_state_t	*state;
; 544  : 	predicted_player_t	*player;
; 545  : 	physent_t		*pe;
; 546  : 	int		i;
; 547  : 
; 548  : 	if( !cl_solid_players->value )

	mov	eax, DWORD PTR _cl_solid_players
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_SetSoli

; 549  : 		return;

	jmp	$LN3@CL_SetSoli
$LN5@CL_SetSoli:

; 550  : 
; 551  : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetSoli
$LN2@CL_SetSoli:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_SetSoli:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_SetSoli

; 552  : 	{
; 553  : 		state = &cl.frames[cl.parsecountmod].playerstate[i];

	imul	edx, DWORD PTR _cl+12, 17304
	imul	eax, DWORD PTR _i$[ebp], 340
	lea	ecx, DWORD PTR _cl[edx+eax+596]
	mov	DWORD PTR _state$[ebp], ecx

; 554  : 		player = &cls.predicted_players[i];

	imul	edx, DWORD PTR _i$[ebp], 40
	add	edx, OFFSET _cls+291768
	mov	DWORD PTR _player$[ebp], edx

; 555  : 
; 556  : 		if( playernum == -1 )

	cmp	DWORD PTR _playernum$[ebp], -1
	jne	SHORT $LN6@CL_SetSoli

; 557  : 		{
; 558  : 			if( i != cl.playernum && !player->active )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+1568828
	je	SHORT $LN8@CL_SetSoli
	mov	ecx, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN8@CL_SetSoli

; 559  : 				continue;

	jmp	SHORT $LN2@CL_SetSoli
$LN8@CL_SetSoli:

; 560  : 		}

	jmp	SHORT $LN10@CL_SetSoli
$LN6@CL_SetSoli:

; 561  : 		else
; 562  : 		{
; 563  : 			if( !player->active )

	mov	edx, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN9@CL_SetSoli

; 564  : 				continue;	// not present this frame

	jmp	SHORT $LN2@CL_SetSoli
$LN9@CL_SetSoli:

; 565  : 
; 566  : 			// the player object never gets added
; 567  : 			if( playernum == i )

	mov	eax, DWORD PTR _playernum$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN10@CL_SetSoli

; 568  : 				continue;

	jmp	SHORT $LN2@CL_SetSoli
$LN10@CL_SetSoli:

; 569  : 		}
; 570  : 
; 571  : 		if( player->solid == SOLID_NOT )

	mov	ecx, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN11@CL_SetSoli

; 572  : 			continue;	// dead body

	jmp	SHORT $LN2@CL_SetSoli
$LN11@CL_SetSoli:

; 573  : 
; 574  : 		if( clgame.pmove->numphysent >= MAX_PHYSENTS )

	mov	edx, DWORD PTR _clgame+1316
	cmp	DWORD PTR [edx+588], 600		; 00000258H
	jl	SHORT $LN12@CL_SetSoli

; 575  : 			break;

	jmp	$LN3@CL_SetSoli
$LN12@CL_SetSoli:

; 576  : 
; 577  : 		pe = &clgame.pmove->physents[clgame.pmove->numphysent];

	mov	eax, DWORD PTR _clgame+1316
	imul	ecx, DWORD PTR [eax+588], 224
	mov	edx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [edx+ecx+592]
	mov	DWORD PTR _pe$[ebp], eax

; 578  : 		CL_CopyEntityToPhysEnt( pe, state, false );

	push	0
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_CL_CopyEntityToPhysEnt
	add	esp, 12					; 0000000cH

; 579  : 		clgame.pmove->numphysent++;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 1
	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+588], ecx

; 580  : 
; 581  : 		// some fields needs to be override from cls.predicted_players
; 582  : 		VectorCopy( player->origin, pe->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+36], eax

; 583  : 		VectorCopy( player->angles, pe->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [eax+ecx+84], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [esi+eax+28]
	mov	DWORD PTR [edx+ecx+84], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+28]
	mov	DWORD PTR [eax+edx+84], ecx

; 584  : 		VectorCopy( clgame.pmove->player_mins[player->usehull], pe->mins );

	mov	edx, DWORD PTR _player$[ebp]
	imul	eax, DWORD PTR [edx+8], 12
	mov	ecx, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [esi+eax+56], ecx
	mov	edx, DWORD PTR _player$[ebp]
	imul	eax, DWORD PTR [edx+8], 12
	mov	ecx, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [esi+ecx+56], edx
	mov	eax, DWORD PTR _player$[ebp]
	imul	ecx, DWORD PTR [eax+8], 12
	mov	edx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [edx+ecx+324852]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [esi+edx+56], eax

; 585  : 		VectorCopy( clgame.pmove->player_maxs[player->usehull], pe->maxs );

	mov	ecx, DWORD PTR _player$[ebp]
	imul	edx, DWORD PTR [ecx+8], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+324900]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [esi+edx+68], eax
	mov	ecx, DWORD PTR _player$[ebp]
	imul	edx, DWORD PTR [ecx+8], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+324900]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax+68], ecx
	mov	edx, DWORD PTR _player$[ebp]
	imul	eax, DWORD PTR [edx+8], 12
	mov	ecx, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [ecx+eax+324900]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [esi+ecx+68], edx

; 586  : 		pe->movetype = player->movetype;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+124], edx

; 587  : 		pe->solid = player->solid;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+96], edx

; 588  : 	}

	jmp	$LN2@CL_SetSoli
$LN3@CL_SetSoli:

; 589  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetSolidPlayers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_CL_SetSolidEntities PROC

; 508  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 509  : 	physent_t	*pe = clgame.pmove->physents;

	mov	eax, DWORD PTR _clgame+1316
	add	eax, 592				; 00000250H
	mov	DWORD PTR _pe$[ebp], eax

; 510  : 
; 511  : 	// setup physents
; 512  : 	clgame.pmove->numvisent = 1;

	mov	ecx, DWORD PTR _clgame+1316
	mov	DWORD PTR [ecx+149332], 1

; 513  : 	clgame.pmove->numphysent = 1;

	mov	edx, DWORD PTR _clgame+1316
	mov	DWORD PTR [edx+588], 1

; 514  : 	clgame.pmove->nummoveent = 0;

	mov	eax, DWORD PTR _clgame+1316
	mov	DWORD PTR [eax+134992], 0

; 515  : 
; 516  : 	memset( clgame.pmove->physents, 0, sizeof( physent_t ));

	push	224					; 000000e0H
	push	0
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 592				; 00000250H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 517  : 	memset( clgame.pmove->visents, 0, sizeof( physent_t ));

	push	224					; 000000e0H
	push	0
	mov	edx, DWORD PTR _clgame+1316
	add	edx, 149336				; 00024758H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 518  : 
; 519  : 	pe->model = cl.worldmodel;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _cl+2686576
	mov	DWORD PTR [eax+48], ecx

; 520  : 	if( pe->model ) Q_strncpy( pe->name, pe->model->name, sizeof( pe->name ));

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN2@CL_SetSoli
	push	32					; 00000020H
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN2@CL_SetSoli:

; 521  : 	pe->takedamage = DAMAGE_YES;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+128], 1

; 522  : 	pe->solid = SOLID_BSP;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [ecx+96], 4

; 523  : 
; 524  : 	// share to visents
; 525  : 	clgame.pmove->visents[0] = clgame.pmove->physents[0];

	mov	edx, 224				; 000000e0H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clgame+1316
	lea	esi, DWORD PTR [ecx+eax+592]
	mov	edx, 224				; 000000e0H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clgame+1316
	lea	edi, DWORD PTR [ecx+eax+149336]
	mov	ecx, 56					; 00000038H
	rep movsd

; 526  : 
; 527  : 	// add all other entities exlucde players
; 528  : 	CL_AddLinksToPmove( &cl.frames[cl.parsecountmod] );

	imul	edx, DWORD PTR _cl+12, 17304
	add	edx, OFFSET _cl+88
	push	edx
	call	_CL_AddLinksToPmove
	add	esp, 4

; 529  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetSolidEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_pmove.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_tr$ = 28						; size = 4
_CL_ClipPMoveToEntity PROC

; 331  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 332  : 	Assert( tr != NULL );

	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $LN5@CL_ClipPMo
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN6@CL_ClipPMo
$LN5@CL_ClipPMo:
	mov	DWORD PTR tv69[ebp], 0
$LN6@CL_ClipPMo:
	push	0
	push	332					; 0000014cH
	push	OFFSET $SG139645
	push	OFFSET $SG139646
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 333  : 
; 334  : 	if( clgame.dllFuncs.pfnClipMoveToEntity != NULL )

	cmp	DWORD PTR _clgame+172, 0
	je	SHORT $LN2@CL_ClipPMo

; 335  : 	{
; 336  : 		// do custom sweep test
; 337  : 		clgame.dllFuncs.pfnClipMoveToEntity( pe, start, mins, maxs, end, tr );

	mov	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	DWORD PTR _clgame+172
	add	esp, 24					; 00000018H

; 338  : 	}

	jmp	SHORT $LN1@CL_ClipPMo
$LN2@CL_ClipPMo:

; 339  : 	else
; 340  : 	{
; 341  : 		// function is missed, so we didn't hit anything
; 342  : 		tr->allsolid = false;

	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [ecx], 0
$LN1@CL_ClipPMo:

; 343  : 	}
; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClipPMoveToEntity ENDP
_TEXT	ENDS
END
