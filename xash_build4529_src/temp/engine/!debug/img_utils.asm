; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_q1palette_init
PUBLIC	_hlpalette_init
EXTRN	_Image_LoadMIP:PROC
EXTRN	_Image_LoadMDL:PROC
EXTRN	_Image_LoadSPR:PROC
EXTRN	_Image_LoadTGA:PROC
EXTRN	_Image_LoadBMP:PROC
EXTRN	_Image_LoadDDS:PROC
EXTRN	_Image_LoadFNT:PROC
EXTRN	_Image_LoadLMP:PROC
EXTRN	_Image_LoadPAL:PROC
EXTRN	_Image_SaveTGA:PROC
EXTRN	_Image_SaveBMP:PROC
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_d_8toQ1table:DWORD:0100H
COMM	_d_8toHLtable:DWORD:0100H
COMM	_d_8to24table:DWORD:0100H
_DATA	ENDS
_BSS	SEGMENT
_q1palette_init DD 01H DUP (?)
_hlpalette_init DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG137303 DB	'%s%s.%s', 00H
$SG137304 DB	'dds', 00H
$SG137305 DB	'%s%s.%s', 00H
$SG137306 DB	'tga', 00H
$SG137307 DB	'%s%s.%s', 00H
$SG137308 DB	'bmp', 00H
$SG137309 DB	'%s%s.%s', 00H
$SG137310 DB	'mip', 00H
$SG137311 DB	'%s%s.%s', 00H
$SG137312 DB	'mdl', 00H
$SG137313 DB	'%s%s.%s', 00H
$SG137314 DB	'spr', 00H
$SG137315 DB	'%s%s.%s', 00H
$SG137316 DB	'lmp', 00H
$SG137317 DB	'%s%s.%s', 00H
$SG137318 DB	'fnt', 00H
$SG137319 DB	'%s%s.%s', 00H
$SG137320 DB	'pal', 00H
$SG137329 DB	'%s%s.%s', 00H
$SG137330 DB	'tga', 00H
$SG137331 DB	'%s%s.%s', 00H
$SG137332 DB	'bmp', 00H
_DATA	ENDS
CONST	SEGMENT
_load_null DD	00H
	DD	00H
	DD	00H
	DD	00H
_load_game DD	FLAT:$SG137303
	DD	FLAT:$SG137304
	DD	FLAT:_Image_LoadDDS
	DD	00H
	DD	FLAT:$SG137305
	DD	FLAT:$SG137306
	DD	FLAT:_Image_LoadTGA
	DD	00H
	DD	FLAT:$SG137307
	DD	FLAT:$SG137308
	DD	FLAT:_Image_LoadBMP
	DD	00H
	DD	FLAT:$SG137309
	DD	FLAT:$SG137310
	DD	FLAT:_Image_LoadMIP
	DD	00H
	DD	FLAT:$SG137311
	DD	FLAT:$SG137312
	DD	FLAT:_Image_LoadMDL
	DD	02H
	DD	FLAT:$SG137313
	DD	FLAT:$SG137314
	DD	FLAT:_Image_LoadSPR
	DD	02H
	DD	FLAT:$SG137315
	DD	FLAT:$SG137316
	DD	FLAT:_Image_LoadLMP
	DD	00H
	DD	FLAT:$SG137317
	DD	FLAT:$SG137318
	DD	FLAT:_Image_LoadFNT
	DD	02H
	DD	FLAT:$SG137319
	DD	FLAT:$SG137320
	DD	FLAT:_Image_LoadPAL
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_save_null DD	00H
	DD	00H
	DD	00H
_save_game DD	FLAT:$SG137329
	DD	FLAT:$SG137330
	DD	FLAT:_Image_SaveTGA
	DD	FLAT:$SG137331
	DD	FLAT:$SG137332
	DD	FLAT:_Image_SaveBMP
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	_Image_Init
PUBLIC	_Image_Shutdown
PUBLIC	_Image_AddCmdFlags
PUBLIC	_Image_Process
PUBLIC	_Image_PaletteHueReplace
PUBLIC	_Image_PaletteTranslate
PUBLIC	_Image_SetForceFlags
PUBLIC	_Image_CustomPalette
PUBLIC	_Image_ClearForceFlags
PUBLIC	_Image_CheckPaletteQ1
PUBLIC	_Image_ResampleInternal
PUBLIC	_Image_FlipInternal
PUBLIC	_Image_Copy8bitRGBA
PUBLIC	_Image_AddIndexedImageToPack
PUBLIC	_Image_GetPaletteLMP
PUBLIC	_Image_GetPaletteBMP
PUBLIC	_Image_ComparePalette
PUBLIC	_Image_CopyPalette32bit
PUBLIC	_Image_GetPaletteQ1
PUBLIC	_Image_GetPaletteHL
PUBLIC	_Image_Copy
PUBLIC	_Image_CopyParms
PUBLIC	_Image_ValidSize
PUBLIC	_Image_LumpValidSize
PUBLIC	_Image_CheckFlag
PUBLIC	_Image_SetPalette
PUBLIC	_Image_Resample32Lerp
PUBLIC	_Image_Resample32Nolerp
PUBLIC	_Image_Resample24Lerp
PUBLIC	_Image_Resample24Nolerp
PUBLIC	_Image_Resample8Nolerp
PUBLIC	_Image_CreateLumaInternal
PUBLIC	_Image_Decompress
PUBLIC	_Image_DecompressInternal
PUBLIC	_Image_LightGamma
PUBLIC	_Image_RemapInternal
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fb4b4b5
PUBLIC	__real@40000000
PUBLIC	__real@41300000
PUBLIC	__real@41f00000
PUBLIC	__real@426c0000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@43000000
PUBLIC	__real@43340000
PUBLIC	__real@43700000
PUBLIC	__real@437f0000
PUBLIC	__real@43960000
PUBLIC	__real@43b40000
PUBLIC	__real@47800000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	__Mem_Check:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_Image_Quantize:PROC
EXTRN	_Image_Reset:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@426c0000
CONST	SEGMENT
__real@426c0000 DD 0426c0000r			; 59
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fb4b4b5
CONST	SEGMENT
__real@3fb4b4b5 DD 03fb4b4b5r			; 1.41176
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG137372 DB	'^1Error:^7 Image: (%s) dims out of range [%dx%d]', 0aH, 00H
	ORG $+2
_palette_q1 DB	00H
	DB	00H
	DB	00H
	DB	0fH
	DB	0fH
	DB	0fH
	DB	01fH
	DB	01fH
	DB	01fH
	DB	02fH
	DB	02fH
	DB	02fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	04bH
	DB	04bH
	DB	04bH
	DB	05bH
	DB	05bH
	DB	05bH
	DB	06bH
	DB	06bH
	DB	06bH
	DB	07bH
	DB	07bH
	DB	07bH
	DB	08bH
	DB	08bH
	DB	08bH
	DB	09bH
	DB	09bH
	DB	09bH
	DB	0abH
	DB	0abH
	DB	0abH
	DB	0bbH
	DB	0bbH
	DB	0bbH
	DB	0cbH
	DB	0cbH
	DB	0cbH
	DB	0dbH
	DB	0dbH
	DB	0dbH
	DB	0ebH
	DB	0ebH
	DB	0ebH
	DB	0fH
	DB	0bH
	DB	07H
	DB	017H
	DB	0fH
	DB	0bH
	DB	01fH
	DB	017H
	DB	0bH
	DB	027H
	DB	01bH
	DB	0fH
	DB	02fH
	DB	023H
	DB	013H
	DB	037H
	DB	02bH
	DB	017H
	DB	03fH
	DB	02fH
	DB	017H
	DB	04bH
	DB	037H
	DB	01bH
	DB	053H
	DB	03bH
	DB	01bH
	DB	05bH
	DB	043H
	DB	01fH
	DB	063H
	DB	04bH
	DB	01fH
	DB	06bH
	DB	053H
	DB	01fH
	DB	073H
	DB	057H
	DB	01fH
	DB	07bH
	DB	05fH
	DB	023H
	DB	083H
	DB	067H
	DB	023H
	DB	08fH
	DB	06fH
	DB	023H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	013H
	DB	013H
	DB	01bH
	DB	01bH
	DB	01bH
	DB	027H
	DB	027H
	DB	027H
	DB	033H
	DB	02fH
	DB	02fH
	DB	03fH
	DB	037H
	DB	037H
	DB	04bH
	DB	03fH
	DB	03fH
	DB	057H
	DB	047H
	DB	047H
	DB	067H
	DB	04fH
	DB	04fH
	DB	073H
	DB	05bH
	DB	05bH
	DB	07fH
	DB	063H
	DB	063H
	DB	08bH
	DB	06bH
	DB	06bH
	DB	097H
	DB	073H
	DB	073H
	DB	0a3H
	DB	07bH
	DB	07bH
	DB	0afH
	DB	083H
	DB	083H
	DB	0bbH
	DB	08bH
	DB	08bH
	DB	0cbH
	DB	00H
	DB	00H
	DB	00H
	DB	07H
	DB	07H
	DB	00H
	DB	0bH
	DB	0bH
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02bH
	DB	02bH
	DB	07H
	DB	02fH
	DB	02fH
	DB	07H
	DB	037H
	DB	037H
	DB	07H
	DB	03fH
	DB	03fH
	DB	07H
	DB	047H
	DB	047H
	DB	07H
	DB	04bH
	DB	04bH
	DB	0bH
	DB	053H
	DB	053H
	DB	0bH
	DB	05bH
	DB	05bH
	DB	0bH
	DB	063H
	DB	063H
	DB	0bH
	DB	06bH
	DB	06bH
	DB	0fH
	DB	07H
	DB	00H
	DB	00H
	DB	0fH
	DB	00H
	DB	00H
	DB	017H
	DB	00H
	DB	00H
	DB	01fH
	DB	00H
	DB	00H
	DB	027H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	037H
	DB	00H
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	04fH
	DB	00H
	DB	00H
	DB	057H
	DB	00H
	DB	00H
	DB	05fH
	DB	00H
	DB	00H
	DB	067H
	DB	00H
	DB	00H
	DB	06fH
	DB	00H
	DB	00H
	DB	077H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02fH
	DB	02bH
	DB	00H
	DB	037H
	DB	02fH
	DB	00H
	DB	043H
	DB	037H
	DB	00H
	DB	04bH
	DB	03bH
	DB	07H
	DB	057H
	DB	043H
	DB	07H
	DB	05fH
	DB	047H
	DB	07H
	DB	06bH
	DB	04bH
	DB	0bH
	DB	077H
	DB	053H
	DB	0fH
	DB	083H
	DB	057H
	DB	013H
	DB	08bH
	DB	05bH
	DB	013H
	DB	097H
	DB	05fH
	DB	01bH
	DB	0a3H
	DB	063H
	DB	01fH
	DB	0afH
	DB	067H
	DB	023H
	DB	023H
	DB	013H
	DB	07H
	DB	02fH
	DB	017H
	DB	0bH
	DB	03bH
	DB	01fH
	DB	0fH
	DB	04bH
	DB	023H
	DB	013H
	DB	057H
	DB	02bH
	DB	017H
	DB	063H
	DB	02fH
	DB	01fH
	DB	073H
	DB	037H
	DB	023H
	DB	07fH
	DB	03bH
	DB	02bH
	DB	08fH
	DB	043H
	DB	033H
	DB	09fH
	DB	04fH
	DB	033H
	DB	0afH
	DB	063H
	DB	02fH
	DB	0bfH
	DB	077H
	DB	02fH
	DB	0cfH
	DB	08fH
	DB	02bH
	DB	0dfH
	DB	0abH
	DB	027H
	DB	0efH
	DB	0cbH
	DB	01fH
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0bH
	DB	07H
	DB	00H
	DB	01bH
	DB	013H
	DB	00H
	DB	02bH
	DB	023H
	DB	0fH
	DB	037H
	DB	02bH
	DB	013H
	DB	047H
	DB	033H
	DB	01bH
	DB	053H
	DB	037H
	DB	023H
	DB	063H
	DB	03fH
	DB	02bH
	DB	06fH
	DB	047H
	DB	033H
	DB	07fH
	DB	053H
	DB	03fH
	DB	08bH
	DB	05fH
	DB	047H
	DB	09bH
	DB	06bH
	DB	053H
	DB	0a7H
	DB	07bH
	DB	05fH
	DB	0b7H
	DB	087H
	DB	06bH
	DB	0c3H
	DB	093H
	DB	07bH
	DB	0d3H
	DB	0a3H
	DB	08bH
	DB	0e3H
	DB	0b3H
	DB	097H
	DB	0abH
	DB	08bH
	DB	0a3H
	DB	09fH
	DB	07fH
	DB	097H
	DB	093H
	DB	073H
	DB	087H
	DB	08bH
	DB	067H
	DB	07bH
	DB	07fH
	DB	05bH
	DB	06fH
	DB	077H
	DB	053H
	DB	063H
	DB	06bH
	DB	04bH
	DB	057H
	DB	05fH
	DB	03fH
	DB	04bH
	DB	057H
	DB	037H
	DB	043H
	DB	04bH
	DB	02fH
	DB	037H
	DB	043H
	DB	027H
	DB	02fH
	DB	037H
	DB	01fH
	DB	023H
	DB	02bH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0bbH
	DB	073H
	DB	09fH
	DB	0afH
	DB	06bH
	DB	08fH
	DB	0a3H
	DB	05fH
	DB	083H
	DB	097H
	DB	057H
	DB	077H
	DB	08bH
	DB	04fH
	DB	06bH
	DB	07fH
	DB	04bH
	DB	05fH
	DB	073H
	DB	043H
	DB	053H
	DB	06bH
	DB	03bH
	DB	04bH
	DB	05fH
	DB	033H
	DB	03fH
	DB	053H
	DB	02bH
	DB	037H
	DB	047H
	DB	023H
	DB	02bH
	DB	03bH
	DB	01fH
	DB	023H
	DB	02fH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0dbH
	DB	0c3H
	DB	0bbH
	DB	0cbH
	DB	0b3H
	DB	0a7H
	DB	0bfH
	DB	0a3H
	DB	09bH
	DB	0afH
	DB	097H
	DB	08bH
	DB	0a3H
	DB	087H
	DB	07bH
	DB	097H
	DB	07bH
	DB	06fH
	DB	087H
	DB	06fH
	DB	05fH
	DB	07bH
	DB	063H
	DB	053H
	DB	06bH
	DB	057H
	DB	047H
	DB	05fH
	DB	04bH
	DB	03bH
	DB	053H
	DB	03fH
	DB	033H
	DB	043H
	DB	033H
	DB	027H
	DB	037H
	DB	02bH
	DB	01fH
	DB	027H
	DB	01fH
	DB	017H
	DB	01bH
	DB	013H
	DB	0fH
	DB	0fH
	DB	0bH
	DB	07H
	DB	06fH
	DB	083H
	DB	07bH
	DB	067H
	DB	07bH
	DB	06fH
	DB	05fH
	DB	073H
	DB	067H
	DB	057H
	DB	06bH
	DB	05fH
	DB	04fH
	DB	063H
	DB	057H
	DB	047H
	DB	05bH
	DB	04fH
	DB	03fH
	DB	053H
	DB	047H
	DB	037H
	DB	04bH
	DB	03fH
	DB	02fH
	DB	043H
	DB	037H
	DB	02bH
	DB	03bH
	DB	02fH
	DB	023H
	DB	033H
	DB	027H
	DB	01fH
	DB	02bH
	DB	01fH
	DB	017H
	DB	023H
	DB	017H
	DB	0fH
	DB	01bH
	DB	013H
	DB	0bH
	DB	013H
	DB	0bH
	DB	07H
	DB	0bH
	DB	07H
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0efH
	DB	0dfH
	DB	017H
	DB	0dbH
	DB	0cbH
	DB	013H
	DB	0cbH
	DB	0b7H
	DB	0fH
	DB	0bbH
	DB	0a7H
	DB	0fH
	DB	0abH
	DB	097H
	DB	0bH
	DB	09bH
	DB	083H
	DB	07H
	DB	08bH
	DB	073H
	DB	07H
	DB	07bH
	DB	063H
	DB	07H
	DB	06bH
	DB	053H
	DB	00H
	DB	05bH
	DB	047H
	DB	00H
	DB	04bH
	DB	037H
	DB	00H
	DB	03bH
	DB	02bH
	DB	00H
	DB	02bH
	DB	01fH
	DB	00H
	DB	01bH
	DB	0fH
	DB	00H
	DB	0bH
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0bH
	DB	0bH
	DB	0efH
	DB	013H
	DB	013H
	DB	0dfH
	DB	01bH
	DB	01bH
	DB	0cfH
	DB	023H
	DB	023H
	DB	0bfH
	DB	02bH
	DB	02bH
	DB	0afH
	DB	02fH
	DB	02fH
	DB	09fH
	DB	02fH
	DB	02fH
	DB	08fH
	DB	02fH
	DB	02fH
	DB	07fH
	DB	02fH
	DB	02fH
	DB	06fH
	DB	02fH
	DB	02fH
	DB	05fH
	DB	02bH
	DB	02bH
	DB	04fH
	DB	023H
	DB	023H
	DB	03fH
	DB	01bH
	DB	01bH
	DB	02fH
	DB	013H
	DB	013H
	DB	01fH
	DB	0bH
	DB	0bH
	DB	0fH
	DB	02bH
	DB	00H
	DB	00H
	DB	03bH
	DB	00H
	DB	00H
	DB	04bH
	DB	07H
	DB	00H
	DB	05fH
	DB	07H
	DB	00H
	DB	06fH
	DB	0fH
	DB	00H
	DB	07fH
	DB	017H
	DB	07H
	DB	093H
	DB	01fH
	DB	07H
	DB	0a3H
	DB	027H
	DB	0bH
	DB	0b7H
	DB	033H
	DB	0fH
	DB	0c3H
	DB	04bH
	DB	01bH
	DB	0cfH
	DB	063H
	DB	02bH
	DB	0dbH
	DB	07fH
	DB	03bH
	DB	0e3H
	DB	097H
	DB	04fH
	DB	0e7H
	DB	0abH
	DB	05fH
	DB	0efH
	DB	0bfH
	DB	077H
	DB	0f7H
	DB	0d3H
	DB	08bH
	DB	0a7H
	DB	07bH
	DB	03bH
	DB	0b7H
	DB	09bH
	DB	037H
	DB	0c7H
	DB	0c3H
	DB	037H
	DB	0e7H
	DB	0e3H
	DB	057H
	DB	07fH
	DB	0bfH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0d7H
	DB	0ffH
	DB	0ffH
	DB	067H
	DB	00H
	DB	00H
	DB	08bH
	DB	00H
	DB	00H
	DB	0b3H
	DB	00H
	DB	00H
	DB	0d7H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0f3H
	DB	093H
	DB	0ffH
	DB	0f7H
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	09fH
	DB	05bH
	DB	053H
_palette_hl DB	00H
	DB	00H
	DB	00H
	DB	0fH
	DB	0fH
	DB	0fH
	DB	01fH
	DB	01fH
	DB	01fH
	DB	02fH
	DB	02fH
	DB	02fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	04bH
	DB	04bH
	DB	04bH
	DB	05bH
	DB	05bH
	DB	05bH
	DB	06bH
	DB	06bH
	DB	06bH
	DB	07bH
	DB	07bH
	DB	07bH
	DB	08bH
	DB	08bH
	DB	08bH
	DB	09bH
	DB	09bH
	DB	09bH
	DB	0abH
	DB	0abH
	DB	0abH
	DB	0bbH
	DB	0bbH
	DB	0bbH
	DB	0cbH
	DB	0cbH
	DB	0cbH
	DB	0dbH
	DB	0dbH
	DB	0dbH
	DB	0ebH
	DB	0ebH
	DB	0ebH
	DB	0fH
	DB	0bH
	DB	07H
	DB	017H
	DB	0fH
	DB	0bH
	DB	01fH
	DB	017H
	DB	0bH
	DB	027H
	DB	01bH
	DB	0fH
	DB	02fH
	DB	023H
	DB	013H
	DB	037H
	DB	02bH
	DB	017H
	DB	03fH
	DB	02fH
	DB	017H
	DB	04bH
	DB	037H
	DB	01bH
	DB	053H
	DB	03bH
	DB	01bH
	DB	05bH
	DB	043H
	DB	01fH
	DB	063H
	DB	04bH
	DB	01fH
	DB	06bH
	DB	053H
	DB	01fH
	DB	073H
	DB	057H
	DB	01fH
	DB	07bH
	DB	05fH
	DB	023H
	DB	083H
	DB	067H
	DB	023H
	DB	08fH
	DB	06fH
	DB	023H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	013H
	DB	013H
	DB	01bH
	DB	01bH
	DB	01bH
	DB	027H
	DB	027H
	DB	027H
	DB	033H
	DB	02fH
	DB	02fH
	DB	03fH
	DB	037H
	DB	037H
	DB	04bH
	DB	03fH
	DB	03fH
	DB	057H
	DB	047H
	DB	047H
	DB	067H
	DB	04fH
	DB	04fH
	DB	073H
	DB	05bH
	DB	05bH
	DB	07fH
	DB	063H
	DB	063H
	DB	08bH
	DB	06bH
	DB	06bH
	DB	097H
	DB	073H
	DB	073H
	DB	0a3H
	DB	07bH
	DB	07bH
	DB	0afH
	DB	083H
	DB	083H
	DB	0bbH
	DB	08bH
	DB	08bH
	DB	0cbH
	DB	00H
	DB	00H
	DB	00H
	DB	07H
	DB	07H
	DB	00H
	DB	0bH
	DB	0bH
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02bH
	DB	02bH
	DB	07H
	DB	02fH
	DB	02fH
	DB	07H
	DB	037H
	DB	037H
	DB	07H
	DB	03fH
	DB	03fH
	DB	07H
	DB	047H
	DB	047H
	DB	07H
	DB	04bH
	DB	04bH
	DB	0bH
	DB	053H
	DB	053H
	DB	0bH
	DB	05bH
	DB	05bH
	DB	0bH
	DB	063H
	DB	063H
	DB	0bH
	DB	06bH
	DB	06bH
	DB	0fH
	DB	07H
	DB	00H
	DB	00H
	DB	0fH
	DB	00H
	DB	00H
	DB	017H
	DB	00H
	DB	00H
	DB	01fH
	DB	00H
	DB	00H
	DB	027H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	037H
	DB	00H
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	04fH
	DB	00H
	DB	00H
	DB	057H
	DB	00H
	DB	00H
	DB	05fH
	DB	00H
	DB	00H
	DB	067H
	DB	00H
	DB	00H
	DB	06fH
	DB	00H
	DB	00H
	DB	077H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02fH
	DB	02bH
	DB	00H
	DB	037H
	DB	02fH
	DB	00H
	DB	043H
	DB	037H
	DB	00H
	DB	04bH
	DB	03bH
	DB	07H
	DB	057H
	DB	043H
	DB	07H
	DB	05fH
	DB	047H
	DB	07H
	DB	06bH
	DB	04bH
	DB	0bH
	DB	077H
	DB	053H
	DB	0fH
	DB	083H
	DB	057H
	DB	013H
	DB	08bH
	DB	05bH
	DB	013H
	DB	097H
	DB	05fH
	DB	01bH
	DB	0a3H
	DB	063H
	DB	01fH
	DB	0afH
	DB	067H
	DB	023H
	DB	023H
	DB	013H
	DB	07H
	DB	02fH
	DB	017H
	DB	0bH
	DB	03bH
	DB	01fH
	DB	0fH
	DB	04bH
	DB	023H
	DB	013H
	DB	057H
	DB	02bH
	DB	017H
	DB	063H
	DB	02fH
	DB	01fH
	DB	073H
	DB	037H
	DB	023H
	DB	07fH
	DB	03bH
	DB	02bH
	DB	08fH
	DB	043H
	DB	033H
	DB	09fH
	DB	04fH
	DB	033H
	DB	0afH
	DB	063H
	DB	02fH
	DB	0bfH
	DB	077H
	DB	02fH
	DB	0cfH
	DB	08fH
	DB	02bH
	DB	0dfH
	DB	0abH
	DB	027H
	DB	0efH
	DB	0cbH
	DB	01fH
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0bH
	DB	07H
	DB	00H
	DB	01bH
	DB	013H
	DB	00H
	DB	02bH
	DB	023H
	DB	0fH
	DB	037H
	DB	02bH
	DB	013H
	DB	047H
	DB	033H
	DB	01bH
	DB	053H
	DB	037H
	DB	023H
	DB	063H
	DB	03fH
	DB	02bH
	DB	06fH
	DB	047H
	DB	033H
	DB	07fH
	DB	053H
	DB	03fH
	DB	08bH
	DB	05fH
	DB	047H
	DB	09bH
	DB	06bH
	DB	053H
	DB	0a7H
	DB	07bH
	DB	05fH
	DB	0b7H
	DB	087H
	DB	06bH
	DB	0c3H
	DB	093H
	DB	07bH
	DB	0d3H
	DB	0a3H
	DB	08bH
	DB	0e3H
	DB	0b3H
	DB	097H
	DB	0abH
	DB	08bH
	DB	0a3H
	DB	09fH
	DB	07fH
	DB	097H
	DB	093H
	DB	073H
	DB	087H
	DB	08bH
	DB	067H
	DB	07bH
	DB	07fH
	DB	05bH
	DB	06fH
	DB	077H
	DB	053H
	DB	063H
	DB	06bH
	DB	04bH
	DB	057H
	DB	05fH
	DB	03fH
	DB	04bH
	DB	057H
	DB	037H
	DB	043H
	DB	04bH
	DB	02fH
	DB	037H
	DB	043H
	DB	027H
	DB	02fH
	DB	037H
	DB	01fH
	DB	023H
	DB	02bH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0bbH
	DB	073H
	DB	09fH
	DB	0afH
	DB	06bH
	DB	08fH
	DB	0a3H
	DB	05fH
	DB	083H
	DB	097H
	DB	057H
	DB	077H
	DB	08bH
	DB	04fH
	DB	06bH
	DB	07fH
	DB	04bH
	DB	05fH
	DB	073H
	DB	043H
	DB	053H
	DB	06bH
	DB	03bH
	DB	04bH
	DB	05fH
	DB	033H
	DB	03fH
	DB	053H
	DB	02bH
	DB	037H
	DB	047H
	DB	023H
	DB	02bH
	DB	03bH
	DB	01fH
	DB	023H
	DB	02fH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0dbH
	DB	0c3H
	DB	0bbH
	DB	0cbH
	DB	0b3H
	DB	0a7H
	DB	0bfH
	DB	0a3H
	DB	09bH
	DB	0afH
	DB	097H
	DB	08bH
	DB	0a3H
	DB	087H
	DB	07bH
	DB	097H
	DB	07bH
	DB	06fH
	DB	087H
	DB	06fH
	DB	05fH
	DB	07bH
	DB	063H
	DB	053H
	DB	06bH
	DB	057H
	DB	047H
	DB	05fH
	DB	04bH
	DB	03bH
	DB	053H
	DB	03fH
	DB	033H
	DB	043H
	DB	033H
	DB	027H
	DB	037H
	DB	02bH
	DB	01fH
	DB	027H
	DB	01fH
	DB	017H
	DB	01bH
	DB	013H
	DB	0fH
	DB	0fH
	DB	0bH
	DB	07H
	DB	06fH
	DB	083H
	DB	07bH
	DB	067H
	DB	07bH
	DB	06fH
	DB	05fH
	DB	073H
	DB	067H
	DB	057H
	DB	06bH
	DB	05fH
	DB	04fH
	DB	063H
	DB	057H
	DB	047H
	DB	05bH
	DB	04fH
	DB	03fH
	DB	053H
	DB	047H
	DB	037H
	DB	04bH
	DB	03fH
	DB	02fH
	DB	043H
	DB	037H
	DB	02bH
	DB	03bH
	DB	02fH
	DB	023H
	DB	033H
	DB	027H
	DB	01fH
	DB	02bH
	DB	01fH
	DB	017H
	DB	023H
	DB	017H
	DB	0fH
	DB	01bH
	DB	013H
	DB	0bH
	DB	013H
	DB	0bH
	DB	07H
	DB	0bH
	DB	07H
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0efH
	DB	0dfH
	DB	017H
	DB	0dbH
	DB	0cbH
	DB	013H
	DB	0cbH
	DB	0b7H
	DB	0fH
	DB	0bbH
	DB	0a7H
	DB	0fH
	DB	0abH
	DB	097H
	DB	0bH
	DB	09bH
	DB	083H
	DB	07H
	DB	08bH
	DB	073H
	DB	07H
	DB	07bH
	DB	063H
	DB	07H
	DB	06bH
	DB	053H
	DB	00H
	DB	05bH
	DB	047H
	DB	00H
	DB	04bH
	DB	037H
	DB	00H
	DB	03bH
	DB	02bH
	DB	00H
	DB	02bH
	DB	01fH
	DB	00H
	DB	01bH
	DB	0fH
	DB	00H
	DB	0bH
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0bH
	DB	0bH
	DB	0efH
	DB	013H
	DB	013H
	DB	0dfH
	DB	01bH
	DB	01bH
	DB	0cfH
	DB	023H
	DB	023H
	DB	0bfH
	DB	02bH
	DB	02bH
	DB	0afH
	DB	02fH
	DB	02fH
	DB	09fH
	DB	02fH
	DB	02fH
	DB	08fH
	DB	02fH
	DB	02fH
	DB	07fH
	DB	02fH
	DB	02fH
	DB	06fH
	DB	02fH
	DB	02fH
	DB	05fH
	DB	02bH
	DB	02bH
	DB	04fH
	DB	023H
	DB	023H
	DB	03fH
	DB	01bH
	DB	01bH
	DB	02fH
	DB	013H
	DB	013H
	DB	01fH
	DB	0bH
	DB	0bH
	DB	0fH
	DB	02bH
	DB	00H
	DB	00H
	DB	03bH
	DB	00H
	DB	00H
	DB	04bH
	DB	07H
	DB	00H
	DB	05fH
	DB	07H
	DB	00H
	DB	06fH
	DB	0fH
	DB	00H
	DB	07fH
	DB	017H
	DB	07H
	DB	093H
	DB	01fH
	DB	07H
	DB	0a3H
	DB	027H
	DB	0bH
	DB	0b7H
	DB	033H
	DB	0fH
	DB	0c3H
	DB	04bH
	DB	01bH
	DB	0cfH
	DB	063H
	DB	02bH
	DB	0dbH
	DB	07fH
	DB	03bH
	DB	0e3H
	DB	097H
	DB	04fH
	DB	0e7H
	DB	0abH
	DB	05fH
	DB	0efH
	DB	0bfH
	DB	077H
	DB	0f7H
	DB	0d3H
	DB	08bH
	DB	0a7H
	DB	07bH
	DB	03bH
	DB	0b7H
	DB	09bH
	DB	037H
	DB	0c7H
	DB	0c3H
	DB	037H
	DB	0e7H
	DB	0e3H
	DB	057H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0d7H
	DB	0ffH
	DB	0ffH
	DB	067H
	DB	00H
	DB	00H
	DB	08bH
	DB	00H
	DB	00H
	DB	0b3H
	DB	00H
	DB	00H
	DB	0d7H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0f3H
	DB	093H
	DB	0ffH
	DB	0f7H
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	09fH
	DB	05bH
	DB	053H
_img_emboss DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	ORG $+4
$SG137338 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137339 DB	'ImageLib Pool', 00H
	ORG $+2
$SG137345 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137346 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137351 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137378 DB	'^1Error:^7 Image: (%s) dims out of range [%dx%d]', 0aH, 00H
	ORG $+6
$SG137430 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137431 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137435 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137440 DB	'gfx/palette.lmp', 00H
$SG137443 DB	'custom quake palette detected', 0aH, 00H
	ORG $+1
$SG137689 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137700 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137791 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137802 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137888 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137890 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137894 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137949 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137978 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG137980 DB	'^1Error:^7 Image_MakeLuma: unsupported format %s', 0aH, 00H
	ORG $+6
$SG137995 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG138021 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG138041 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG138043 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG138122 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
	ORG $+2
$SG138155 DB	'Image_Resample: from[%d x %d] to [%d x %d]', 0aH, 00H
	ORG $+4
$SG138156 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\imagelib\img_utils.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_src$1 = -92						; size = 4
_size$ = -88						; size = 4
tv277 = -84						; size = 4
tv276 = -80						; size = 4
tv223 = -76						; size = 4
tv222 = -72						; size = 4
tv70 = -68						; size = 4
tv69 = -64						; size = 4
_fout$ = -60						; size = 4
_avg$2 = -56						; size = 4
_img_x$3 = -52						; size = 4
_img_y$4 = -48						; size = 4
_fin$ = -44						; size = 4
_tmp$5 = -40						; size = 4
_pos_y$6 = -36						; size = 4
_pos_x$7 = -32						; size = 4
_x$ = -28						; size = 4
_y$ = -24						; size = 4
_i$ = -20						; size = 4
_vout$8 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pic$ = 8						; size = 4
_factor$ = 12						; size = 4
_Image_ApplyFilter PROC

; 1378 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1379 : 	int	i, x, y; 
; 1380 : 	uint	*fin, *fout; 
; 1381 : 	size_t	size;
; 1382 : 
; 1383 : 	// don't waste time
; 1384 : 	if( factor <= 0.0f ) return;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _factor$[ebp]
	jb	SHORT $LN20@Image_Appl
	jmp	$LN1@Image_Appl
$LN20@Image_Appl:

; 1385 : 
; 1386 : 	// first expand the image into 32-bit buffer
; 1387 : 	pic = Image_DecompressInternal( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_DecompressInternal
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax

; 1388 : 	factor = bound( 0.0f, factor, 1.0f );

	movss	xmm0, DWORD PTR _factor$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN24@Image_Appl
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _factor$[ebp]
	jbe	SHORT $LN22@Image_Appl
	movss	xmm0, DWORD PTR _factor$[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN23@Image_Appl
$LN22@Image_Appl:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv69[ebp], xmm0
$LN23@Image_Appl:
	movss	xmm0, DWORD PTR tv69[ebp]
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN25@Image_Appl
$LN24@Image_Appl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
$LN25@Image_Appl:
	movss	xmm0, DWORD PTR tv70[ebp]
	movss	DWORD PTR _factor$[ebp], xmm0

; 1389 : 	size = image.width * image.height * 4;

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	shl	ecx, 2
	mov	DWORD PTR _size$[ebp], ecx

; 1390 : 	image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, size );

	push	1390					; 0000056eH
	push	OFFSET $SG138122
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1391 : 	fout = (uint *)image.tempbuffer;

	mov	eax, DWORD PTR _image+84
	mov	DWORD PTR _fout$[ebp], eax

; 1392 : 	fin = (uint *)pic->buffer;

	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _fin$[ebp], edx

; 1393 : 
; 1394 : 	for( x = 0; x < image.width; x++ ) 

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN4@Image_Appl
$LN2@Image_Appl:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN4@Image_Appl:
	movzx	ecx, WORD PTR _image+8
	cmp	DWORD PTR _x$[ebp], ecx
	jge	$LN3@Image_Appl

; 1395 : 	{ 
; 1396 : 		for( y = 0; y < image.height; y++ ) 

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN7@Image_Appl
$LN5@Image_Appl:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
$LN7@Image_Appl:
	movzx	eax, WORD PTR _image+10
	cmp	DWORD PTR _y$[ebp], eax
	jge	$LN6@Image_Appl

; 1397 : 		{ 
; 1398 : 			vec3_t	vout = { 0.0f, 0.0f, 0.0f }; 

	xorps	xmm0, xmm0
	movss	DWORD PTR _vout$8[ebp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vout$8[ebp+4], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vout$8[ebp+8], xmm0

; 1399 : 			int	pos_x, pos_y;
; 1400 : 			float	avg;
; 1401 : 
; 1402 : 			for( pos_x = 0; pos_x < FILTER_SIZE; pos_x++ ) 

	mov	DWORD PTR _pos_x$7[ebp], 0
	jmp	SHORT $LN10@Image_Appl
$LN8@Image_Appl:
	mov	ecx, DWORD PTR _pos_x$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos_x$7[ebp], ecx
$LN10@Image_Appl:
	cmp	DWORD PTR _pos_x$7[ebp], 5
	jge	$LN9@Image_Appl

; 1403 : 			{ 
; 1404 : 				for( pos_y = 0; pos_y < FILTER_SIZE; pos_y++ ) 

	mov	DWORD PTR _pos_y$6[ebp], 0
	jmp	SHORT $LN13@Image_Appl
$LN11@Image_Appl:
	mov	edx, DWORD PTR _pos_y$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pos_y$6[ebp], edx
$LN13@Image_Appl:
	cmp	DWORD PTR _pos_y$6[ebp], 5
	jge	$LN12@Image_Appl

; 1405 : 				{ 
; 1406 : 					int	img_x = (x - (FILTER_SIZE / 2) + pos_x + image.width) % image.width; 

	mov	eax, DWORD PTR _pos_x$7[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [ecx+eax-2]
	movzx	edx, WORD PTR _image+8
	add	eax, edx
	movzx	ecx, WORD PTR _image+8
	cdq
	idiv	ecx
	mov	DWORD PTR _img_x$3[ebp], edx

; 1407 : 					int	img_y = (y - (FILTER_SIZE / 2) + pos_y + image.height) % image.height; 

	mov	edx, DWORD PTR _pos_y$6[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [eax+edx-2]
	movzx	ecx, WORD PTR _image+10
	add	eax, ecx
	movzx	ecx, WORD PTR _image+10
	cdq
	idiv	ecx
	mov	DWORD PTR _img_y$4[ebp], edx

; 1408 : 
; 1409 : 					// casting's a unary operation anyway, so the othermost set of brackets in the left part 
; 1410 : 					// of the rvalue should not be necessary... but i'm paranoid when it comes to C... 
; 1411 : 					vout[0] += ((float)((byte *)&fin[img_y * image.width + img_x])[0]) * img_emboss[pos_x][pos_y]; 

	mov	edx, 4
	imul	eax, edx, 0
	movzx	ecx, WORD PTR _image+8
	imul	ecx, DWORD PTR _img_y$4[ebp]
	add	ecx, DWORD PTR _img_x$3[ebp]
	mov	edx, DWORD PTR _fin$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	imul	edx, edx, 0
	movzx	ecx, BYTE PTR [ecx+edx]
	cvtsi2ss xmm0, ecx
	imul	edx, DWORD PTR _pos_x$7[ebp], 20
	mov	ecx, DWORD PTR _pos_y$6[ebp]
	mulss	xmm0, DWORD PTR _img_emboss[edx+ecx*4]
	addss	xmm0, DWORD PTR _vout$8[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vout$8[ebp+eax], xmm0

; 1412 : 					vout[1] += ((float)((byte *)&fin[img_y * image.width + img_x])[1]) * img_emboss[pos_x][pos_y]; 

	mov	ecx, 4
	shl	ecx, 0
	movzx	edx, WORD PTR _image+8
	imul	edx, DWORD PTR _img_y$4[ebp]
	add	edx, DWORD PTR _img_x$3[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, 1
	shl	eax, 0
	movzx	edx, BYTE PTR [edx+eax]
	cvtsi2ss xmm0, edx
	imul	eax, DWORD PTR _pos_x$7[ebp], 20
	mov	edx, DWORD PTR _pos_y$6[ebp]
	mulss	xmm0, DWORD PTR _img_emboss[eax+edx*4]
	addss	xmm0, DWORD PTR _vout$8[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vout$8[ebp+eax], xmm0

; 1413 : 					vout[2] += ((float)((byte *)&fin[img_y * image.width + img_x])[2]) * img_emboss[pos_x][pos_y]; 

	mov	ecx, 4
	shl	ecx, 1
	movzx	edx, WORD PTR _image+8
	imul	edx, DWORD PTR _img_y$4[ebp]
	add	edx, DWORD PTR _img_x$3[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, 1
	shl	eax, 1
	movzx	edx, BYTE PTR [edx+eax]
	cvtsi2ss xmm0, edx
	imul	eax, DWORD PTR _pos_x$7[ebp], 20
	mov	edx, DWORD PTR _pos_y$6[ebp]
	mulss	xmm0, DWORD PTR _img_emboss[eax+edx*4]
	addss	xmm0, DWORD PTR _vout$8[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _vout$8[ebp+eax], xmm0

; 1414 : 				} 

	jmp	$LN11@Image_Appl
$LN12@Image_Appl:

; 1415 : 			} 

	jmp	$LN8@Image_Appl
$LN9@Image_Appl:

; 1416 : 
; 1417 : 			// multiply by factor, add bias, and clamp 
; 1418 : 			for( i = 0; i < 3; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Image_Appl
$LN14@Image_Appl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN16@Image_Appl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN15@Image_Appl

; 1419 : 			{ 
; 1420 : 				vout[i] *= factor; 

	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+edx*4]
	mulss	xmm0, DWORD PTR _factor$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _vout$8[ebp+eax*4], xmm0

; 1421 : 				vout[i] += 128.0f; // base 

	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+ecx*4]
	addss	xmm0, DWORD PTR __real@43000000
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _vout$8[ebp+edx*4], xmm0

; 1422 : 				vout[i] = bound( 0.0f, vout[i], 255.0f );

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN28@Image_Appl
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR _vout$8[ebp+ecx*4]
	jbe	SHORT $LN26@Image_Appl
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+edx*4]
	movss	DWORD PTR tv222[ebp], xmm0
	jmp	SHORT $LN27@Image_Appl
$LN26@Image_Appl:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv222[ebp], xmm0
$LN27@Image_Appl:
	movss	xmm0, DWORD PTR tv222[ebp]
	movss	DWORD PTR tv223[ebp], xmm0
	jmp	SHORT $LN29@Image_Appl
$LN28@Image_Appl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv223[ebp], xmm0
$LN29@Image_Appl:
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv223[ebp]
	movss	DWORD PTR _vout$8[ebp+eax*4], xmm0

; 1423 : 			} 

	jmp	$LN14@Image_Appl
$LN15@Image_Appl:

; 1424 : 
; 1425 : 			// NTSC greyscale conversion standard 
; 1426 : 			avg = (vout[0] * 30.0f + vout[1] * 59.0f + vout[2] * 11.0f) / 100.0f; 

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _vout$8[ebp+edx]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _vout$8[ebp+eax]
	mulss	xmm1, DWORD PTR __real@426c0000
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vout$8[ebp+ecx]
	mulss	xmm1, DWORD PTR __real@41300000
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _avg$2[ebp], xmm0

; 1427 : 
; 1428 : 			// divide by 255 so GL operations work as expected 
; 1429 : 			vout[0] = avg / 255.0f; 

	movss	xmm0, DWORD PTR _avg$2[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vout$8[ebp+eax], xmm0

; 1430 : 			vout[1] = avg / 255.0f; 

	movss	xmm0, DWORD PTR _avg$2[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vout$8[ebp+ecx], xmm0

; 1431 : 			vout[2] = avg / 255.0f; 

	movss	xmm0, DWORD PTR _avg$2[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vout$8[ebp+edx], xmm0

; 1432 : 
; 1433 : 			// write to temp - first, write data in (to get the alpha channel quickly and 
; 1434 : 			// easily, which will be left well alone by this particular operation...!) 
; 1435 : 			fout[y * image.width + x] = fin[y * image.width + x]; 

	movzx	eax, WORD PTR _image+8
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	movzx	ecx, WORD PTR _image+8
	imul	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 1436 : 
; 1437 : 			// now write in each element, applying the blend operator.  blend 
; 1438 : 			// operators are based on standard OpenGL TexEnv modes, and the 
; 1439 : 			// formulas are derived from the OpenGL specs (http://www.opengl.org). 
; 1440 : 			for( i = 0; i < 3; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@Image_Appl
$LN17@Image_Appl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN19@Image_Appl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN18@Image_Appl

; 1441 : 			{ 
; 1442 : 				// divide by 255 so GL operations work as expected 
; 1443 : 				float	src = ((float)((byte *)&fin[y * image.width + x])[i]) / 255.0f; 

	movzx	edx, WORD PTR _image+8
	imul	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _src$1[ebp], xmm0

; 1444 : 				float	tmp;
; 1445 : 
; 1446 : 				// default is GL_BLEND here 
; 1447 : 				// CsS + CdD works out as Src * Dst * 2 
; 1448 : 				tmp = vout[i] * src * 2.0f; 

	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+ecx*4]
	mulss	xmm0, DWORD PTR _src$1[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _tmp$5[ebp], xmm0

; 1449 : 
; 1450 : 				// multiply back by 255 to get the proper byte scale 
; 1451 : 				tmp *= 255.0f; 

	movss	xmm0, DWORD PTR _tmp$5[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _tmp$5[ebp], xmm0

; 1452 : 
; 1453 : 				// bound the temp target again now, cos the operation may have thrown it out 
; 1454 : 				tmp = bound( 0.0f, tmp, 255.0f );

	movss	xmm0, DWORD PTR _tmp$5[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN32@Image_Appl
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR _tmp$5[ebp]
	jbe	SHORT $LN30@Image_Appl
	movss	xmm0, DWORD PTR _tmp$5[ebp]
	movss	DWORD PTR tv276[ebp], xmm0
	jmp	SHORT $LN31@Image_Appl
$LN30@Image_Appl:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv276[ebp], xmm0
$LN31@Image_Appl:
	movss	xmm0, DWORD PTR tv276[ebp]
	movss	DWORD PTR tv277[ebp], xmm0
	jmp	SHORT $LN33@Image_Appl
$LN32@Image_Appl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv277[ebp], xmm0
$LN33@Image_Appl:
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR _tmp$5[ebp], xmm0

; 1455 : 				// and copy it in 
; 1456 : 				((byte *)&fout[y * image.width + x])[i] = (byte)tmp; 

	cvttss2si edx, DWORD PTR _tmp$5[ebp]
	movzx	eax, WORD PTR _image+8
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 1457 : 			} 

	jmp	$LN17@Image_Appl
$LN18@Image_Appl:

; 1458 : 		} 

	jmp	$LN5@Image_Appl
$LN6@Image_Appl:

; 1459 : 	} 

	jmp	$LN2@Image_Appl
$LN3@Image_Appl:

; 1460 : 
; 1461 : 	// copy result back
; 1462 : 	memcpy( fin, fout, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Image_Appl:

; 1463 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ApplyFilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv67 = -4						; size = 4
_pic$ = 8						; size = 4
_topColor$ = 12						; size = 4
_bottomColor$ = 16					; size = 4
_Image_RemapInternal PROC

; 1336 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1337 : 	if( !pic->palette )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN4@Image_Rema

; 1338 : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Rema
$LN4@Image_Rema:

; 1339 : 
; 1340 : 	switch( pic->type )

	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 1
	je	SHORT $LN5@Image_Rema
	cmp	DWORD PTR tv67[ebp], 2
	je	SHORT $LN6@Image_Rema
	jmp	SHORT $LN7@Image_Rema
$LN5@Image_Rema:

; 1341 : 	{
; 1342 : 	case PF_INDEXED_24:
; 1343 : 		break;

	jmp	SHORT $LN2@Image_Rema
$LN6@Image_Rema:

; 1344 : 	case PF_INDEXED_32:
; 1345 : 		Image_ConvertPalTo24bit( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_ConvertPalTo24bit
	add	esp, 4

; 1346 : 		break;

	jmp	SHORT $LN2@Image_Rema
$LN7@Image_Rema:

; 1347 : 	default:
; 1348 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Rema
$LN2@Image_Rema:

; 1349 : 	}
; 1350 : 
; 1351 : 	if( Image_ComparePalette( pic->palette ) == PAL_QUAKE1 )

	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_Image_ComparePalette
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN8@Image_Rema

; 1352 : 	{
; 1353 : 		Image_PaletteTranslate( pic->palette, topColor * 16, bottomColor * 16, 3 );

	push	3
	mov	eax, DWORD PTR _bottomColor$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _topColor$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_Image_PaletteTranslate
	add	esp, 16					; 00000010H

; 1354 : 	}

	jmp	SHORT $LN9@Image_Rema
$LN8@Image_Rema:

; 1355 : 	else
; 1356 : 	{
; 1357 : 		// g-cont. preview images has a swapped top and bottom colors. I don't know why.
; 1358 : 		Image_PaletteHueReplace( pic->palette, topColor, SUIT_HUE_START, SUIT_HUE_END, 3 );

	push	3
	push	223					; 000000dfH
	push	192					; 000000c0H
	mov	ecx, DWORD PTR _topColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_Image_PaletteHueReplace
	add	esp, 20					; 00000014H

; 1359 : 		Image_PaletteHueReplace( pic->palette, bottomColor, PLATE_HUE_START, PLATE_HUE_END, 3 );

	push	3
	push	191					; 000000bfH
	push	160					; 000000a0H
	mov	ecx, DWORD PTR _bottomColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_Image_PaletteHueReplace
	add	esp, 20					; 00000014H
$LN9@Image_Rema:

; 1360 : 	}
; 1361 : 
; 1362 : 	return true;

	mov	eax, 1
$LN1@Image_Rema:

; 1363 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_RemapInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_in$ = -4						; size = 4
_pic$ = 8						; size = 4
_Image_LightGamma PROC

; 1318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1319 : 	byte	*in = (byte *)pic->buffer;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _in$[ebp], ecx

; 1320 : 	int	i;
; 1321 : 
; 1322 : 	if( pic->type != PF_RGBA_32 )

	mov	edx, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [edx+8], 3
	je	SHORT $LN5@Image_Ligh

; 1323 : 		return pic;

	mov	eax, DWORD PTR _pic$[ebp]
	jmp	$LN1@Image_Ligh
$LN5@Image_Ligh:

; 1324 : 
; 1325 : 	for( i = 0; i < pic->width * pic->height; i++, in += 4 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Ligh
$LN2@Image_Ligh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$[ebp], ecx
$LN4@Image_Ligh:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@Image_Ligh

; 1326 : 	{
; 1327 : 		in[0] = LightToTexGamma( in[0] );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_LightToTexGamma
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 1328 : 		in[1] = LightToTexGamma( in[1] );

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 1329 : 		in[2] = LightToTexGamma( in[2] );

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _in$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 1330 : 	}

	jmp	$LN2@Image_Ligh
$LN3@Image_Ligh:

; 1331 : 
; 1332 : 	return pic;

	mov	eax, DWORD PTR _pic$[ebp]
$LN1@Image_Ligh:

; 1333 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LightGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_pic$ = 8						; size = 4
_Image_DecompressInternal PROC

; 1295 : {

	push	ebp
	mov	ebp, esp

; 1296 : 	// quick case to reject unneeded conversions
; 1297 : 	if( pic->type == PF_RGBA_32 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN2@Image_Deco

; 1298 : 		return pic;

	mov	eax, DWORD PTR _pic$[ebp]
	jmp	$LN1@Image_Deco
$LN2@Image_Deco:

; 1299 : 
; 1300 : 	Image_CopyParms( pic );

	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	call	_Image_CopyParms
	add	esp, 4

; 1301 : 	image.size = image.ptr = 0;

	mov	DWORD PTR _image+32, 0
	mov	edx, DWORD PTR _image+32
	mov	DWORD PTR _image+28, edx

; 1302 : 
; 1303 : 	Image_Decompress( pic->buffer );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_Image_Decompress
	add	esp, 4

; 1304 : 
; 1305 : 	// now we can change type to RGBA
; 1306 : 	pic->type = PF_RGBA_32;

	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+8], 3

; 1307 : 
; 1308 : 	pic->buffer = Mem_Realloc( host.imagepool, pic->buffer, image.size );

	push	1308					; 0000051cH
	push	OFFSET $SG138041
	push	1
	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1309 : 	memcpy( pic->buffer, image.tempbuffer, image.size );

	mov	edx, DWORD PTR _image+28
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1310 : 	if( pic->palette ) Mem_Free( pic->palette );

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@Image_Deco
	push	1310					; 0000051eH
	push	OFFSET $SG138043
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@Image_Deco:

; 1311 : 	pic->flags = image.flags;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _image+24
	mov	DWORD PTR [eax+12], ecx

; 1312 : 	pic->palette = NULL;

	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1313 : 
; 1314 : 	return pic;

	mov	eax, DWORD PTR _pic$[ebp]
$LN1@Image_Deco:

; 1315 : }

	pop	ebp
	ret	0
_Image_DecompressInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_size$ = -20						; size = 4
tv79 = -16						; size = 4
_fin$ = -12						; size = 4
_fout$ = -8						; size = 4
_i$ = -4						; size = 4
_data$ = 8						; size = 4
_Image_Decompress PROC

; 1227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1228 : 	byte	*fin, *fout;
; 1229 : 	int	i, size; 
; 1230 : 
; 1231 : 	if( !data ) return false;

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN13@Image_Deco
	xor	eax, eax
	jmp	$LN1@Image_Deco
$LN13@Image_Deco:

; 1232 : 	fin = (byte *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _fin$[ebp], eax

; 1233 : 
; 1234 : 	size = image.width * image.height * 4;

	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	shl	ecx, 2
	mov	DWORD PTR _size$[ebp], ecx

; 1235 : 	image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, size );

	push	1235					; 000004d3H
	push	OFFSET $SG138021
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1236 : 	fout = image.tempbuffer;

	mov	eax, DWORD PTR _image+84
	mov	DWORD PTR _fout$[ebp], eax

; 1237 : 
; 1238 : 	switch( PFDesc[image.type].format )

	imul	ecx, DWORD PTR _image+20, 28
	mov	edx, DWORD PTR _PFDesc[ecx]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR tv79[ebp]
	sub	eax, 1
	mov	DWORD PTR tv79[ebp], eax
	cmp	DWORD PTR tv79[ebp], 5
	ja	$LN26@Image_Deco
	mov	ecx, DWORD PTR tv79[ebp]
	jmp	DWORD PTR $LN28@Image_Deco[ecx*4]
$LN14@Image_Deco:

; 1239 : 	{
; 1240 : 	case PF_INDEXED_24:
; 1241 : 		if( image.flags & IMAGE_HAS_ALPHA )

	mov	edx, DWORD PTR _image+24
	and	edx, 2
	je	SHORT $LN15@Image_Deco

; 1242 : 		{
; 1243 : 			if( image.flags & IMAGE_COLORINDEX )

	mov	eax, DWORD PTR _image+24
	and	eax, 8
	je	SHORT $LN17@Image_Deco

; 1244 : 				Image_GetPaletteLMP( image.palette, LUMP_GRADIENT ); 

	push	2
	mov	ecx, DWORD PTR _image+72
	push	ecx
	call	_Image_GetPaletteLMP
	add	esp, 8
	jmp	SHORT $LN18@Image_Deco
$LN17@Image_Deco:

; 1245 : 			else Image_GetPaletteLMP( image.palette, LUMP_MASKED ); 

	push	1
	mov	edx, DWORD PTR _image+72
	push	edx
	call	_Image_GetPaletteLMP
	add	esp, 8
$LN18@Image_Deco:

; 1246 : 		}

	jmp	SHORT $LN19@Image_Deco
$LN15@Image_Deco:

; 1247 : 		else Image_GetPaletteLMP( image.palette, LUMP_NORMAL );

	push	0
	mov	eax, DWORD PTR _image+72
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8
$LN19@Image_Deco:

; 1248 : 		// intentional falltrough
; 1249 : 	case PF_INDEXED_32:
; 1250 : 		if( !image.d_currentpal ) image.d_currentpal = (uint *)image.palette;

	cmp	DWORD PTR _image+64, 0
	jne	SHORT $LN20@Image_Deco
	mov	ecx, DWORD PTR _image+72
	mov	DWORD PTR _image+64, ecx
$LN20@Image_Deco:

; 1251 : 		if( !Image_Copy8bitRGBA( fin, fout, image.width * image.height ))

	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	push	edx
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	call	_Image_Copy8bitRGBA
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Image_Deco

; 1252 : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Deco
$LN21@Image_Deco:

; 1253 : 		break;

	jmp	$LN2@Image_Deco
$LN22@Image_Deco:

; 1254 : 	case PF_BGR_24:
; 1255 : 		for (i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_Deco
$LN4@Image_Deco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Image_Deco:
	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN5@Image_Deco

; 1256 : 		{
; 1257 : 			fout[(i<<2)+0] = fin[i*3+2];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax+2]
	mov	BYTE PTR [edx+ecx*4], al

; 1258 : 			fout[(i<<2)+1] = fin[i*3+1];

	imul	ecx, DWORD PTR _i$[ebp], 3
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	cl, BYTE PTR [esi+ecx+1]
	mov	BYTE PTR [eax+edx*4+1], cl

; 1259 : 			fout[(i<<2)+2] = fin[i*3+0];

	imul	edx, DWORD PTR _i$[ebp], 3
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax*4+2], dl

; 1260 : 			fout[(i<<2)+3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	BYTE PTR [ecx+eax*4+3], 255		; 000000ffH

; 1261 : 		}

	jmp	SHORT $LN4@Image_Deco
$LN5@Image_Deco:

; 1262 : 		break;

	jmp	$LN2@Image_Deco
$LN23@Image_Deco:

; 1263 : 	case PF_RGB_24:
; 1264 : 		for (i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Image_Deco
$LN7@Image_Deco:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@Image_Deco:
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN8@Image_Deco

; 1265 : 		{
; 1266 : 			fout[(i<<2)+0] = fin[i*3+0];

	imul	edx, DWORD PTR _i$[ebp], 3
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax*4], dl

; 1267 : 			fout[(i<<2)+1] = fin[i*3+1];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx*4+1], al

; 1268 : 			fout[(i<<2)+2] = fin[i*3+2];

	imul	ecx, DWORD PTR _i$[ebp], 3
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	cl, BYTE PTR [esi+ecx+2]
	mov	BYTE PTR [eax+edx*4+2], cl

; 1269 : 			fout[(i<<2)+3] = 255;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _fout$[ebp]
	mov	BYTE PTR [eax+edx*4+3], 255		; 000000ffH

; 1270 : 		}

	jmp	SHORT $LN7@Image_Deco
$LN8@Image_Deco:

; 1271 : 		break;

	jmp	$LN2@Image_Deco
$LN24@Image_Deco:

; 1272 : 	case PF_BGRA_32:
; 1273 : 		for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Image_Deco
$LN10@Image_Deco:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN12@Image_Deco:
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN11@Image_Deco

; 1274 : 		{
; 1275 : 			fout[i*4+0] = fin[i*4+2];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax*4+2]
	mov	BYTE PTR [edx+ecx*4], al

; 1276 : 			fout[i*4+1] = fin[i*4+1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax*4+1]
	mov	BYTE PTR [edx+ecx*4+1], al

; 1277 : 			fout[i*4+2] = fin[i*4+0];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax*4]
	mov	BYTE PTR [edx+ecx*4+2], al

; 1278 : 			fout[i*4+3] = fin[i*4+3];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax*4+3]
	mov	BYTE PTR [edx+ecx*4+3], al

; 1279 : 		}

	jmp	SHORT $LN10@Image_Deco
$LN11@Image_Deco:

; 1280 : 		break;

	jmp	SHORT $LN2@Image_Deco
$LN25@Image_Deco:

; 1281 : 	case PF_RGBA_32:
; 1282 : 		// fast default case
; 1283 : 		memcpy( fout, fin, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1284 : 		break;

	jmp	SHORT $LN2@Image_Deco
$LN26@Image_Deco:

; 1285 : 	default: return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Deco
$LN2@Image_Deco:

; 1286 : 	}
; 1287 : 
; 1288 : 	// set new size
; 1289 : 	image.size = size;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _image+28, ecx

; 1290 : 
; 1291 : 	return true;

	mov	eax, 1
$LN1@Image_Deco:

; 1292 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Image_Deco:
	DD	$LN14@Image_Deco
	DD	$LN19@Image_Deco
	DD	$LN25@Image_Deco
	DD	$LN24@Image_Deco
	DD	$LN23@Image_Deco
	DD	$LN22@Image_Deco
_Image_Decompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv86 = -16						; size = 4
tv66 = -12						; size = 4
_out$ = -8						; size = 4
_i$ = -4						; size = 4
_fin$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_type$ = 20						; size = 4
_flags$ = 24						; size = 4
_Image_CreateLumaInternal PROC

; 1171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1172 : 	byte	*out;
; 1173 : 	int	i;
; 1174 : 
; 1175 : 	if( !FBitSet( flags, IMAGE_HAS_LUMA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	jne	SHORT $LN7@Image_Crea

; 1176 : 		return (byte *)fin;	  

	mov	eax, DWORD PTR _fin$[ebp]
	jmp	$LN1@Image_Crea
$LN7@Image_Crea:

; 1177 : 
; 1178 : 	switch( type )

	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jle	$LN9@Image_Crea
	cmp	DWORD PTR tv66[ebp], 2
	jle	SHORT $LN8@Image_Crea
	jmp	$LN9@Image_Crea
$LN8@Image_Crea:

; 1179 : 	{
; 1180 : 	case PF_INDEXED_24:
; 1181 : 	case PF_INDEXED_32:
; 1182 : 		out = image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, width * height );

	push	1182					; 0000049eH
	push	OFFSET $SG137978
	push	1
	mov	edx, DWORD PTR _width$[ebp]
	imul	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _host+34740
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax
	mov	edx, DWORD PTR _image+84
	mov	DWORD PTR _out$[ebp], edx

; 1183 : 		for( i = 0; i < width * height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_Crea
$LN4@Image_Crea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Image_Crea:
	mov	ecx, DWORD PTR _width$[ebp]
	imul	ecx, DWORD PTR _height$[ebp]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN5@Image_Crea

; 1184 : 			*out++ = fin[i] >= 224 ? fin[i] : 0;

	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 224				; 000000e0H
	jl	SHORT $LN11@Image_Crea
	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN12@Image_Crea
$LN11@Image_Crea:
	mov	DWORD PTR tv86[ebp], 0
$LN12@Image_Crea:
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR tv86[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	jmp	SHORT $LN4@Image_Crea
$LN5@Image_Crea:

; 1185 : 		break;

	jmp	SHORT $LN2@Image_Crea
$LN9@Image_Crea:

; 1186 : 	default:
; 1187 : 		// another formats does ugly result :(
; 1188 : 		Con_Printf( S_ERROR "Image_MakeLuma: unsupported format %s\n", PFDesc[type].name );

	imul	eax, DWORD PTR _type$[ebp], 28
	add	eax, OFFSET _PFDesc+4
	push	eax
	push	OFFSET $SG137980
	call	_Con_Printf
	add	esp, 8

; 1189 : 		return (byte *)fin;	

	mov	eax, DWORD PTR _fin$[ebp]
	jmp	SHORT $LN1@Image_Crea
$LN2@Image_Crea:

; 1190 : 	}
; 1191 : 
; 1192 : 	return image.tempbuffer;

	mov	eax, DWORD PTR _image+84
$LN1@Image_Crea:

; 1193 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CreateLumaInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_inrow$ = -28						; size = 4
_in$ = -24						; size = 4
_fracstep$ = -20					; size = 4
_frac$ = -16						; size = 4
_out$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample8Nolerp PROC

; 1032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1033 : 	int	i, j;
; 1034 : 	byte	*in, *inrow;
; 1035 : 	uint	frac, fracstep;
; 1036 : 	byte	*out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 1037 : 
; 1038 : 	in = (byte *)indata;

	mov	ecx, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 1039 : 	fracstep = inwidth * 0x10000 / outwidth;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _fracstep$[ebp], eax

; 1040 : 
; 1041 : 	for( i = 0; i < outheight; i++, out += outwidth )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _out$[ebp], eax
$LN4@Image_Resa:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _outheight$[ebp]
	jge	SHORT $LN1@Image_Resa

; 1042 : 	{
; 1043 : 		inrow = in + inwidth*(i*inheight/outheight);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _inheight$[ebp]
	cdq
	idiv	DWORD PTR _outheight$[ebp]
	imul	eax, DWORD PTR _inwidth$[ebp]
	add	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 1044 : 		frac = fracstep>>1;

	mov	edx, DWORD PTR _fracstep$[ebp]
	shr	edx, 1
	mov	DWORD PTR _frac$[ebp], edx

; 1045 : 
; 1046 : 		for( j = 0; j < outwidth; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Image_Resa
$LN5@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Image_Resa:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _outwidth$[ebp]
	jge	SHORT $LN6@Image_Resa

; 1047 : 		{
; 1048 : 			out[j] = inrow[frac>>16];

	mov	edx, DWORD PTR _frac$[ebp]
	shr	edx, 16					; 00000010H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _inrow$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl

; 1049 : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 1050 : 		}

	jmp	SHORT $LN5@Image_Resa
$LN6@Image_Resa:

; 1051 : 	}

	jmp	SHORT $LN2@Image_Resa
$LN1@Image_Resa:

; 1052 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample8Nolerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_inwidth3$ = -32					; size = 4
_i$ = -28						; size = 4
_j$ = -24						; size = 4
_fracstep$ = -20					; size = 4
_frac$ = -16						; size = 4
_inrow$ = -12						; size = 4
_f$ = -8						; size = 4
_out$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample24Nolerp PROC

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 967  : 	uint	frac, fracstep;
; 968  : 	int	i, j, f, inwidth3 = inwidth * 3;

	imul	eax, DWORD PTR _inwidth$[ebp], 3
	mov	DWORD PTR _inwidth3$[ebp], eax

; 969  : 	byte	*inrow, *out = (byte *)outdata;

	mov	ecx, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], ecx

; 970  : 
; 971  : 	fracstep = inwidth * 0x10000 / outwidth;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _fracstep$[ebp], eax

; 972  : 
; 973  : 	for( i = 0; i < outheight; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	$LN1@Image_Resa

; 974  : 	{
; 975  : 		inrow = (byte *)indata + inwidth3 * (i * inheight / outheight);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _inheight$[ebp]
	cdq
	idiv	DWORD PTR _outheight$[ebp]
	imul	eax, DWORD PTR _inwidth3$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 976  : 		frac = fracstep>>1;

	mov	ecx, DWORD PTR _fracstep$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _frac$[ebp], ecx

; 977  : 		j = outwidth - 4;

	mov	edx, DWORD PTR _outwidth$[ebp]
	sub	edx, 4
	mov	DWORD PTR _j$[ebp], edx
$LN5@Image_Resa:

; 978  : 
; 979  : 		while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 980  : 		{
; 981  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 982  : 			*out++ = inrow[f+0];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 983  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 984  : 			*out++ = inrow[f+2];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 985  : 			frac += fracstep;

	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 986  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 987  : 			*out++ = inrow[f+0];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 988  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 989  : 			*out++ = inrow[f+2];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 990  : 			frac += fracstep;

	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 991  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 992  : 			*out++ = inrow[f+0];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 993  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 994  : 			*out++ = inrow[f+2];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 995  : 			frac += fracstep;

	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 996  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 997  : 			*out++ = inrow[f+0];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 998  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 999  : 			*out++ = inrow[f+2];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1000 : 			frac += fracstep;

	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 1001 : 			j -= 4;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax

; 1002 : 		}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 1003 : 
; 1004 : 		if( j & 2 )

	mov	ecx, DWORD PTR _j$[ebp]
	and	ecx, 2
	je	$LN7@Image_Resa

; 1005 : 		{
; 1006 : 			f = (frac >> 16)*3;

	mov	edx, DWORD PTR _frac$[ebp]
	shr	edx, 16					; 00000010H
	imul	eax, edx, 3
	mov	DWORD PTR _f$[ebp], eax

; 1007 : 			*out++ = inrow[f+0];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1008 : 			*out++ = inrow[f+1];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx+1]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 1009 : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1010 : 			frac += fracstep;

	mov	ecx, DWORD PTR _frac$[ebp]
	add	ecx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], ecx

; 1011 : 			f = (frac >> 16)*3;

	mov	edx, DWORD PTR _frac$[ebp]
	shr	edx, 16					; 00000010H
	imul	eax, edx, 3
	mov	DWORD PTR _f$[ebp], eax

; 1012 : 			*out++ = inrow[f+0];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1013 : 			*out++ = inrow[f+1];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx+1]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 1014 : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1015 : 			frac += fracstep;

	mov	ecx, DWORD PTR _frac$[ebp]
	add	ecx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], ecx

; 1016 : 			out += 2;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx
$LN7@Image_Resa:

; 1017 : 		}
; 1018 : 
; 1019 : 		if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	SHORT $LN8@Image_Resa

; 1020 : 		{
; 1021 : 			f = (frac >> 16)*3;

	mov	ecx, DWORD PTR _frac$[ebp]
	shr	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	mov	DWORD PTR _f$[ebp], edx

; 1022 : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1023 : 			*out++ = inrow[f+1];

	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1024 : 			*out++ = inrow[f+2];

	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR [edx+2]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 1025 : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 1026 : 			out += 1;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
$LN8@Image_Resa:

; 1027 : 		}
; 1028 : 	}

	jmp	$LN2@Image_Resa
$LN1@Image_Resa:

; 1029 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample24Nolerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_endy$ = -60						; size = 4
_fstep$ = -56						; size = 4
_i$ = -52						; size = 4
_inwidth3$ = -48					; size = 4
_f$ = -44						; size = 4
_outwidth3$ = -40					; size = 4
_j$ = -36						; size = 4
_oldy$ = -32						; size = 4
_inrow$ = -28						; size = 4
_yi$ = -24						; size = 4
_lerp$ = -20						; size = 4
_out$ = -16						; size = 4
_resamplerow2$ = -12					; size = 4
_resamplerow1$ = -8					; size = 4
_r$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample24Lerp PROC

; 865  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 866  : 	const byte *inrow;
; 867  : 	int	i, j, r, yi, oldy, f, fstep, lerp, endy = (inheight - 1);

	mov	eax, DWORD PTR _inheight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _endy$[ebp], eax

; 868  : 	int	inwidth3 = inwidth * 3;

	imul	ecx, DWORD PTR _inwidth$[ebp], 3
	mov	DWORD PTR _inwidth3$[ebp], ecx

; 869  : 	int	outwidth3 = outwidth * 3;

	imul	edx, DWORD PTR _outwidth$[ebp], 3
	mov	DWORD PTR _outwidth3$[ebp], edx

; 870  : 	byte	*out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 871  : 	byte	*resamplerow1;
; 872  : 	byte	*resamplerow2;
; 873  : 	
; 874  : 	fstep = (int)(inheight * 65536.0f / outheight);

	cvtsi2ss xmm0, DWORD PTR _inheight$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outheight$[ebp]
	divss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _fstep$[ebp], ecx

; 875  : 
; 876  : 	resamplerow1 = (byte *)Mem_Malloc( host.imagepool, outwidth * 3 * 2 );

	push	876					; 0000036cH
	push	OFFSET $SG137791
	push	0
	imul	edx, DWORD PTR _outwidth$[ebp], 3
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 877  : 	resamplerow2 = resamplerow1 + outwidth*3;

	imul	ecx, DWORD PTR _outwidth$[ebp], 3
	add	ecx, DWORD PTR _resamplerow1$[ebp]
	mov	DWORD PTR _resamplerow2$[ebp], ecx

; 878  : 
; 879  : 	inrow = (const byte *)indata;

	mov	edx, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], edx

; 880  : 	oldy = 0;

	mov	DWORD PTR _oldy$[ebp], 0

; 881  : 	Image_Resample24LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H

; 882  : 	Image_Resample24LerpLine( inrow + inwidth3, resamplerow2, inwidth, outwidth );

	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inrow$[ebp]
	add	ecx, DWORD PTR _inwidth3$[ebp]
	push	ecx
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H

; 883  : 
; 884  : 	for( i = 0, f = 0; i < outheight; i++, f += fstep )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], eax
$LN4@Image_Resa:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _outheight$[ebp]
	jge	$LN3@Image_Resa

; 885  : 	{
; 886  : 		yi = f>>16;

	mov	edx, DWORD PTR _f$[ebp]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _yi$[ebp], edx

; 887  : 
; 888  : 		if( yi < endy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _endy$[ebp]
	jge	$LN7@Image_Resa

; 889  : 		{
; 890  : 			lerp = f & 0xFFFF;

	mov	ecx, DWORD PTR _f$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], ecx

; 891  : 			if( yi != oldy )

	mov	edx, DWORD PTR _yi$[ebp]
	cmp	edx, DWORD PTR _oldy$[ebp]
	je	SHORT $LN9@Image_Resa

; 892  : 			{
; 893  : 				inrow = (byte *)indata + inwidth3 * yi;

	mov	eax, DWORD PTR _inwidth3$[ebp]
	imul	eax, DWORD PTR _yi$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 894  : 				if( yi == oldy + 1) memcpy( resamplerow1, resamplerow2, outwidth3 );

	mov	ecx, DWORD PTR _oldy$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _yi$[ebp], ecx
	jne	SHORT $LN10@Image_Resa
	mov	edx, DWORD PTR _outwidth3$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@Image_Resa
$LN10@Image_Resa:

; 895  : 				else Image_Resample24LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _inwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inrow$[ebp]
	push	edx
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H
$LN11@Image_Resa:

; 896  : 				Image_Resample24LerpLine( inrow + inwidth3, resamplerow2, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _inwidth3$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H

; 897  : 				oldy = yi;

	mov	ecx, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], ecx
$LN9@Image_Resa:

; 898  : 			}
; 899  : 
; 900  : 			j = outwidth - 4;

	mov	edx, DWORD PTR _outwidth$[ebp]
	sub	edx, 4
	mov	DWORD PTR _j$[ebp], edx
$LN5@Image_Resa:

; 901  : 
; 902  : 			while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 903  : 			{
; 904  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 905  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 906  : 				LERPBYTE( 2);

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 907  : 				LERPBYTE( 3);

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 908  : 				LERPBYTE( 4);

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 909  : 				LERPBYTE( 5);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 5
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 910  : 				LERPBYTE( 6);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 6
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 911  : 				LERPBYTE( 7);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 7
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 912  : 				LERPBYTE( 8);

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 913  : 				LERPBYTE( 9);

	mov	edx, 1
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 914  : 				LERPBYTE(10);

	mov	edx, 1
	imul	eax, edx, 10
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 915  : 				LERPBYTE(11);

	mov	edx, 1
	imul	eax, edx, 11
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 916  : 				out += 12;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], edx

; 917  : 				resamplerow1 += 12;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 918  : 				resamplerow2 += 12;

	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _resamplerow2$[ebp], ecx

; 919  : 				j -= 4;

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 4
	mov	DWORD PTR _j$[ebp], edx

; 920  : 			}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 921  : 
; 922  : 			if( j & 2 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	$LN12@Image_Resa

; 923  : 			{
; 924  : 				LERPBYTE( 0);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 925  : 				LERPBYTE( 1);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 926  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 927  : 				LERPBYTE( 3);

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 928  : 				LERPBYTE( 4);

	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 929  : 				LERPBYTE( 5);

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 930  : 				out += 6;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 6
	mov	DWORD PTR _out$[ebp], ecx

; 931  : 				resamplerow1 += 6;

	mov	edx, DWORD PTR _resamplerow1$[ebp]
	add	edx, 6
	mov	DWORD PTR _resamplerow1$[ebp], edx

; 932  : 				resamplerow2 += 6;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 6
	mov	DWORD PTR _resamplerow2$[ebp], eax
$LN12@Image_Resa:

; 933  : 			}
; 934  : 
; 935  : 			if( j & 1 )

	mov	ecx, DWORD PTR _j$[ebp]
	and	ecx, 1
	je	$LN13@Image_Resa

; 936  : 			{
; 937  : 				LERPBYTE( 0);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 938  : 				LERPBYTE( 1);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 939  : 				LERPBYTE( 2);

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 940  : 				out += 3;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 3
	mov	DWORD PTR _out$[ebp], eax

; 941  : 				resamplerow1 += 3;

	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	add	ecx, 3
	mov	DWORD PTR _resamplerow1$[ebp], ecx

; 942  : 				resamplerow2 += 3;

	mov	edx, DWORD PTR _resamplerow2$[ebp]
	add	edx, 3
	mov	DWORD PTR _resamplerow2$[ebp], edx
$LN13@Image_Resa:

; 943  : 			}
; 944  : 
; 945  : 			resamplerow1 -= outwidth3;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	sub	eax, DWORD PTR _outwidth3$[ebp]
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 946  : 			resamplerow2 -= outwidth3;

	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	sub	ecx, DWORD PTR _outwidth3$[ebp]
	mov	DWORD PTR _resamplerow2$[ebp], ecx

; 947  : 		}

	jmp	SHORT $LN8@Image_Resa
$LN7@Image_Resa:

; 948  : 		else
; 949  : 		{
; 950  : 			if( yi != oldy )

	mov	edx, DWORD PTR _yi$[ebp]
	cmp	edx, DWORD PTR _oldy$[ebp]
	je	SHORT $LN14@Image_Resa

; 951  : 			{
; 952  : 				inrow = (byte *)indata + inwidth3*yi;

	mov	eax, DWORD PTR _inwidth3$[ebp]
	imul	eax, DWORD PTR _yi$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 953  : 				if( yi == oldy + 1) memcpy( resamplerow1, resamplerow2, outwidth3 );

	mov	ecx, DWORD PTR _oldy$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _yi$[ebp], ecx
	jne	SHORT $LN15@Image_Resa
	mov	edx, DWORD PTR _outwidth3$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@Image_Resa
$LN15@Image_Resa:

; 954  : 				else Image_Resample24LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _inwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inrow$[ebp]
	push	edx
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H
$LN16@Image_Resa:

; 955  : 				oldy = yi;

	mov	eax, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], eax
$LN14@Image_Resa:

; 956  : 			}
; 957  : 
; 958  : 			memcpy( out, resamplerow1, outwidth3 );

	mov	ecx, DWORD PTR _outwidth3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@Image_Resa:

; 959  : 		}
; 960  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 961  : 
; 962  : 	Mem_Free( resamplerow1 );

	push	962					; 000003c2H
	push	OFFSET $SG137802
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample24Lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_i$ = -24						; size = 4
_j$ = -20						; size = 4
_inrow$ = -16						; size = 4
_fracstep$ = -12					; size = 4
_out$ = -8						; size = 4
_frac$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample32Nolerp PROC

; 826  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 827  : 	int	i, j;
; 828  : 	uint	frac, fracstep;
; 829  : 	int	*inrow, *out = (int *)outdata; // relies on int being 4 bytes

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 830  : 
; 831  : 	fracstep = inwidth * 0x10000 / outwidth;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _fracstep$[ebp], eax

; 832  : 
; 833  : 	for( i = 0; i < outheight; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Image_Resa:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _outheight$[ebp]
	jge	$LN1@Image_Resa

; 834  : 	{
; 835  : 		inrow = (int *)indata + inwidth * (i * inheight / outheight);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _inheight$[ebp]
	cdq
	idiv	DWORD PTR _outheight$[ebp]
	imul	eax, DWORD PTR _inwidth$[ebp]
	mov	ecx, DWORD PTR _indata$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _inrow$[ebp], edx

; 836  : 		frac = fracstep>>1;

	mov	eax, DWORD PTR _fracstep$[ebp]
	shr	eax, 1
	mov	DWORD PTR _frac$[ebp], eax

; 837  : 		j = outwidth - 4;

	mov	ecx, DWORD PTR _outwidth$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _j$[ebp], ecx
$LN5@Image_Resa:

; 838  : 
; 839  : 		while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 840  : 		{
; 841  : 			out[0] = inrow[frac >> 16];frac += fracstep;

	mov	edx, DWORD PTR _frac$[ebp]
	shr	edx, 16					; 00000010H
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 842  : 			out[1] = inrow[frac >> 16];frac += fracstep;

	mov	ecx, DWORD PTR _frac$[ebp]
	shr	ecx, 16					; 00000010H
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 843  : 			out[2] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, DWORD PTR _frac$[ebp]
	add	ecx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], ecx

; 844  : 			out[3] = inrow[frac >> 16];frac += fracstep;

	mov	edx, DWORD PTR _frac$[ebp]
	shr	edx, 16					; 00000010H
	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 845  : 			out += 4;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], ecx

; 846  : 			j -= 4;

	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 4
	mov	DWORD PTR _j$[ebp], edx

; 847  : 		}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 848  : 
; 849  : 		if( j & 2 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	SHORT $LN7@Image_Resa

; 850  : 		{
; 851  : 			out[0] = inrow[frac >> 16];frac += fracstep;

	mov	ecx, DWORD PTR _frac$[ebp]
	shr	ecx, 16					; 00000010H
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 852  : 			out[1] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, DWORD PTR _frac$[ebp]
	add	ecx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], ecx

; 853  : 			out += 2;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 8
	mov	DWORD PTR _out$[ebp], edx
$LN7@Image_Resa:

; 854  : 		}
; 855  : 
; 856  : 		if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	SHORT $LN8@Image_Resa

; 857  : 		{
; 858  : 			out[0] = inrow[frac >> 16];frac += fracstep;

	mov	ecx, DWORD PTR _frac$[ebp]
	shr	ecx, 16					; 00000010H
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, DWORD PTR _frac$[ebp]
	add	edx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], edx

; 859  : 			out += 1;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 4
	mov	DWORD PTR _out$[ebp], eax
$LN8@Image_Resa:

; 860  : 		}
; 861  : 	}

	jmp	$LN2@Image_Resa
$LN1@Image_Resa:

; 862  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample32Nolerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_endy$ = -60						; size = 4
_fstep$ = -56						; size = 4
_i$ = -52						; size = 4
_inwidth4$ = -48					; size = 4
_f$ = -44						; size = 4
_outwidth4$ = -40					; size = 4
_j$ = -36						; size = 4
_oldy$ = -32						; size = 4
_inrow$ = -28						; size = 4
_yi$ = -24						; size = 4
_lerp$ = -20						; size = 4
_out$ = -16						; size = 4
_resamplerow2$ = -12					; size = 4
_resamplerow1$ = -8					; size = 4
_r$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample32Lerp PROC

; 718  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 719  : 	const byte *inrow;
; 720  : 	int	i, j, r, yi, oldy = 0, f, fstep, lerp, endy = (inheight - 1);

	mov	DWORD PTR _oldy$[ebp], 0
	mov	eax, DWORD PTR _inheight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _endy$[ebp], eax

; 721  : 	int	inwidth4 = inwidth * 4;

	mov	ecx, DWORD PTR _inwidth$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _inwidth4$[ebp], ecx

; 722  : 	int	outwidth4 = outwidth * 4;

	mov	edx, DWORD PTR _outwidth$[ebp]
	shl	edx, 2
	mov	DWORD PTR _outwidth4$[ebp], edx

; 723  : 	byte	*out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 724  : 	byte	*resamplerow1;
; 725  : 	byte	*resamplerow2;
; 726  : 
; 727  : 	fstep = (int)(inheight * 65536.0f / outheight);

	cvtsi2ss xmm0, DWORD PTR _inheight$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outheight$[ebp]
	divss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _fstep$[ebp], ecx

; 728  : 
; 729  : 	resamplerow1 = (byte *)Mem_Malloc( host.imagepool, outwidth * 4 * 2);

	push	729					; 000002d9H
	push	OFFSET $SG137689
	push	0
	mov	edx, DWORD PTR _outwidth$[ebp]
	shl	edx, 2
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 730  : 	resamplerow2 = resamplerow1 + outwidth * 4;

	mov	ecx, DWORD PTR _outwidth$[ebp]
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 731  : 
; 732  : 	inrow = (const byte *)indata;

	mov	ecx, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], ecx

; 733  : 
; 734  : 	Image_Resample32LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _inwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inrow$[ebp]
	push	edx
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H

; 735  : 	Image_Resample32LerpLine( inrow + inwidth4, resamplerow2, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _inwidth4$[ebp]
	push	eax
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H

; 736  : 
; 737  : 	for( i = 0, f = 0; i < outheight; i++, f += fstep )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _f$[ebp]
	add	edx, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], edx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	$LN3@Image_Resa

; 738  : 	{
; 739  : 		yi = f>>16;

	mov	ecx, DWORD PTR _f$[ebp]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _yi$[ebp], ecx

; 740  : 
; 741  : 		if( yi < endy )

	mov	edx, DWORD PTR _yi$[ebp]
	cmp	edx, DWORD PTR _endy$[ebp]
	jge	$LN7@Image_Resa

; 742  : 		{
; 743  : 			lerp = f & 0xFFFF;

	mov	eax, DWORD PTR _f$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], eax

; 744  : 			if( yi != oldy )

	mov	ecx, DWORD PTR _yi$[ebp]
	cmp	ecx, DWORD PTR _oldy$[ebp]
	je	SHORT $LN9@Image_Resa

; 745  : 			{
; 746  : 				inrow = (byte *)indata + inwidth4 * yi;

	mov	edx, DWORD PTR _inwidth4$[ebp]
	imul	edx, DWORD PTR _yi$[ebp]
	add	edx, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], edx

; 747  : 				if( yi == oldy + 1 ) memcpy( resamplerow1, resamplerow2, outwidth4 );

	mov	eax, DWORD PTR _oldy$[ebp]
	add	eax, 1
	cmp	DWORD PTR _yi$[ebp], eax
	jne	SHORT $LN10@Image_Resa
	mov	ecx, DWORD PTR _outwidth4$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@Image_Resa
$LN10@Image_Resa:

; 748  : 				else Image_Resample32LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inrow$[ebp]
	push	ecx
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H
$LN11@Image_Resa:

; 749  : 				Image_Resample32LerpLine( inrow + inwidth4, resamplerow2, inwidth, outwidth );

	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _inwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inrow$[ebp]
	add	edx, DWORD PTR _inwidth4$[ebp]
	push	edx
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H

; 750  : 				oldy = yi;

	mov	eax, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], eax
$LN9@Image_Resa:

; 751  : 			}
; 752  : 
; 753  : 			j = outwidth - 4;

	mov	ecx, DWORD PTR _outwidth$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _j$[ebp], ecx
$LN5@Image_Resa:

; 754  : 
; 755  : 			while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 756  : 			{
; 757  : 				LERPBYTE( 0);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 758  : 				LERPBYTE( 1);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 759  : 				LERPBYTE( 2);

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 760  : 				LERPBYTE( 3);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 761  : 				LERPBYTE( 4);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 762  : 				LERPBYTE( 5);

	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 763  : 				LERPBYTE( 6);

	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 764  : 				LERPBYTE( 7);

	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 765  : 				LERPBYTE( 8);

	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 766  : 				LERPBYTE( 9);

	mov	ecx, 1
	imul	edx, ecx, 9
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 9
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 767  : 				LERPBYTE(10);

	mov	ecx, 1
	imul	edx, ecx, 10
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 10
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 10
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 768  : 				LERPBYTE(11);

	mov	ecx, 1
	imul	edx, ecx, 11
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 11
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 11
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 769  : 				LERPBYTE(12);

	mov	ecx, 1
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 12
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 770  : 				LERPBYTE(13);

	mov	ecx, 1
	imul	edx, ecx, 13
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 13
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 771  : 				LERPBYTE(14);

	mov	ecx, 1
	imul	edx, ecx, 14
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 14
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 14
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 772  : 				LERPBYTE(15);

	mov	ecx, 1
	imul	edx, ecx, 15
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 15
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 15
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 773  : 				out += 16;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], ecx

; 774  : 				resamplerow1 += 16;

	mov	edx, DWORD PTR _resamplerow1$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _resamplerow1$[ebp], edx

; 775  : 				resamplerow2 += 16;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 776  : 				j -= 4;

	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _j$[ebp], ecx

; 777  : 			}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 778  : 
; 779  : 			if( j & 2 )

	mov	edx, DWORD PTR _j$[ebp]
	and	edx, 2
	je	$LN12@Image_Resa

; 780  : 			{
; 781  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 782  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 783  : 				LERPBYTE( 2);

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 784  : 				LERPBYTE( 3);

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 785  : 				LERPBYTE( 4);

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 786  : 				LERPBYTE( 5);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 5
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 787  : 				LERPBYTE( 6);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 6
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 788  : 				LERPBYTE( 7);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _resamplerow2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, DWORD PTR _r$[ebp]
	imul	ecx, DWORD PTR _lerp$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, 1
	imul	eax, edx, 7
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 789  : 				out += 8;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 8
	mov	DWORD PTR _out$[ebp], eax

; 790  : 				resamplerow1 += 8;

	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	add	ecx, 8
	mov	DWORD PTR _resamplerow1$[ebp], ecx

; 791  : 				resamplerow2 += 8;

	mov	edx, DWORD PTR _resamplerow2$[ebp]
	add	edx, 8
	mov	DWORD PTR _resamplerow2$[ebp], edx
$LN12@Image_Resa:

; 792  : 			}
; 793  : 
; 794  : 			if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	$LN13@Image_Resa

; 795  : 			{
; 796  : 				LERPBYTE( 0);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _r$[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 797  : 				LERPBYTE( 1);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 798  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 799  : 				LERPBYTE( 3);

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 800  : 				out += 4;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 4
	mov	DWORD PTR _out$[ebp], edx

; 801  : 				resamplerow1 += 4;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 4
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 802  : 				resamplerow2 += 4;

	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	add	ecx, 4
	mov	DWORD PTR _resamplerow2$[ebp], ecx
$LN13@Image_Resa:

; 803  : 			}
; 804  : 
; 805  : 			resamplerow1 -= outwidth4;

	mov	edx, DWORD PTR _resamplerow1$[ebp]
	sub	edx, DWORD PTR _outwidth4$[ebp]
	mov	DWORD PTR _resamplerow1$[ebp], edx

; 806  : 			resamplerow2 -= outwidth4;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	sub	eax, DWORD PTR _outwidth4$[ebp]
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 807  : 		}

	jmp	SHORT $LN8@Image_Resa
$LN7@Image_Resa:

; 808  : 		else
; 809  : 		{
; 810  : 			if( yi != oldy )

	mov	ecx, DWORD PTR _yi$[ebp]
	cmp	ecx, DWORD PTR _oldy$[ebp]
	je	SHORT $LN14@Image_Resa

; 811  : 			{
; 812  : 				inrow = (byte *)indata + inwidth4 * yi;

	mov	edx, DWORD PTR _inwidth4$[ebp]
	imul	edx, DWORD PTR _yi$[ebp]
	add	edx, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], edx

; 813  : 				if( yi == oldy + 1 ) memcpy( resamplerow1, resamplerow2, outwidth4 );

	mov	eax, DWORD PTR _oldy$[ebp]
	add	eax, 1
	cmp	DWORD PTR _yi$[ebp], eax
	jne	SHORT $LN15@Image_Resa
	mov	ecx, DWORD PTR _outwidth4$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@Image_Resa
$LN15@Image_Resa:

; 814  : 				else Image_Resample32LerpLine( inrow, resamplerow1, inwidth, outwidth);

	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inrow$[ebp]
	push	ecx
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H
$LN16@Image_Resa:

; 815  : 				oldy = yi;

	mov	edx, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], edx
$LN14@Image_Resa:

; 816  : 			}
; 817  : 
; 818  : 			memcpy( out, resamplerow1, outwidth4 );

	mov	eax, DWORD PTR _outwidth4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@Image_Resa:

; 819  : 		}
; 820  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 821  : 
; 822  : 	Mem_Free( resamplerow1 );

	push	822					; 00000336H
	push	OFFSET $SG137700
	mov	eax, DWORD PTR _resamplerow1$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 823  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample32Lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_endx$ = -28						; size = 4
_fstep$ = -24						; size = 4
_lerp$ = -20						; size = 4
_oldx$ = -16						; size = 4
_j$ = -12						; size = 4
_f$ = -8						; size = 4
_xi$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_inwidth$ = 16						; size = 4
_outwidth$ = 20						; size = 4
_Image_Resample24LerpLine PROC

; 685  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 686  : 	int	j, xi, oldx = 0, f, fstep, endx, lerp;

	mov	DWORD PTR _oldx$[ebp], 0

; 687  : 
; 688  : 	fstep = (int)(inwidth * 65536.0f / outwidth);

	cvtsi2ss xmm0, DWORD PTR _inwidth$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outwidth$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _fstep$[ebp], eax

; 689  : 	endx = (inwidth-1);

	mov	ecx, DWORD PTR _inwidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _endx$[ebp], ecx

; 690  : 
; 691  : 	for( j = 0, f = 0; j < outwidth; j++, f += fstep )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], eax
$LN4@Image_Resa:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _outwidth$[ebp]
	jge	$LN3@Image_Resa

; 692  : 	{
; 693  : 		xi = f>>16;

	mov	edx, DWORD PTR _f$[ebp]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _xi$[ebp], edx

; 694  : 
; 695  : 		if( xi != oldx )

	mov	eax, DWORD PTR _xi$[ebp]
	cmp	eax, DWORD PTR _oldx$[ebp]
	je	SHORT $LN5@Image_Resa

; 696  : 		{
; 697  : 			in += (xi - oldx) * 3;

	mov	ecx, DWORD PTR _xi$[ebp]
	sub	ecx, DWORD PTR _oldx$[ebp]
	imul	edx, ecx, 3
	add	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _in$[ebp], edx

; 698  : 			oldx = xi;

	mov	eax, DWORD PTR _xi$[ebp]
	mov	DWORD PTR _oldx$[ebp], eax
$LN5@Image_Resa:

; 699  : 		}
; 700  : 
; 701  : 		if( xi < endx )

	mov	ecx, DWORD PTR _xi$[ebp]
	cmp	ecx, DWORD PTR _endx$[ebp]
	jge	$LN6@Image_Resa

; 702  : 		{
; 703  : 			lerp = f & 0xFFFF;

	mov	edx, DWORD PTR _f$[ebp]
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], edx

; 704  : 			*out++ = (byte)((((in[3] - in[0]) * lerp)>>16) + in[0]);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	sub	eax, edx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 705  : 			*out++ = (byte)((((in[4] - in[1]) * lerp)>>16) + in[1]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edx, eax
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	edx, ecx
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 706  : 			*out++ = (byte)((((in[5] - in[2]) * lerp)>>16) + in[2]);

	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edx, eax
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	mov	ecx, 1
	shl	ecx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	edx, ecx
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 707  : 		}

	jmp	SHORT $LN7@Image_Resa
$LN6@Image_Resa:

; 708  : 		else // last pixel of the line has no pixel to lerp to
; 709  : 		{
; 710  : 			*out++ = in[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 711  : 			*out++ = in[1];

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 712  : 			*out++ = in[2];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
$LN7@Image_Resa:

; 713  : 		}
; 714  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 715  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample24LerpLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_endx$ = -28						; size = 4
_fstep$ = -24						; size = 4
_oldx$ = -20						; size = 4
_j$ = -16						; size = 4
_lerp$ = -12						; size = 4
_f$ = -8						; size = 4
_xi$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_inwidth$ = 16						; size = 4
_outwidth$ = 20						; size = 4
_Image_Resample32LerpLine PROC

; 652  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 653  : 	int	j, xi, oldx = 0, f, fstep, endx, lerp;

	mov	DWORD PTR _oldx$[ebp], 0

; 654  : 
; 655  : 	fstep = (int)(inwidth * 65536.0f / outwidth);

	cvtsi2ss xmm0, DWORD PTR _inwidth$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outwidth$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _fstep$[ebp], eax

; 656  : 	endx = (inwidth-1);

	mov	ecx, DWORD PTR _inwidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _endx$[ebp], ecx

; 657  : 
; 658  : 	for( j = 0, f = 0; j < outwidth; j++, f += fstep )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], eax
$LN4@Image_Resa:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _outwidth$[ebp]
	jge	$LN3@Image_Resa

; 659  : 	{
; 660  : 		xi = f>>16;

	mov	edx, DWORD PTR _f$[ebp]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _xi$[ebp], edx

; 661  : 		if( xi != oldx )

	mov	eax, DWORD PTR _xi$[ebp]
	cmp	eax, DWORD PTR _oldx$[ebp]
	je	SHORT $LN5@Image_Resa

; 662  : 		{
; 663  : 			in += (xi - oldx) * 4;

	mov	ecx, DWORD PTR _xi$[ebp]
	sub	ecx, DWORD PTR _oldx$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _in$[ebp], eax

; 664  : 			oldx = xi;

	mov	ecx, DWORD PTR _xi$[ebp]
	mov	DWORD PTR _oldx$[ebp], ecx
$LN5@Image_Resa:

; 665  : 		}
; 666  : 		if( xi < endx )

	mov	edx, DWORD PTR _xi$[ebp]
	cmp	edx, DWORD PTR _endx$[ebp]
	jge	$LN6@Image_Resa

; 667  : 		{
; 668  : 			lerp = f & 0xFFFF;

	mov	eax, DWORD PTR _f$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], eax

; 669  : 			*out++ = (byte)((((in[4] - in[0]) * lerp)>>16) + in[0]);

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	sub	eax, edx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 670  : 			*out++ = (byte)((((in[5] - in[1]) * lerp)>>16) + in[1]);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	sub	eax, ecx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 671  : 			*out++ = (byte)((((in[6] - in[2]) * lerp)>>16) + in[2]);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	sub	eax, ecx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 672  : 			*out++ = (byte)((((in[7] - in[3]) * lerp)>>16) + in[3]);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	sub	eax, edx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 673  : 		}

	jmp	SHORT $LN7@Image_Resa
$LN6@Image_Resa:

; 674  : 		else // last pixel of the line has no pixel to lerp to
; 675  : 		{
; 676  : 			*out++ = in[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 677  : 			*out++ = in[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 678  : 			*out++ = in[2];

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 679  : 			*out++ = in[3];

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
$LN7@Image_Resa:

; 680  : 		}
; 681  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 682  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample32LerpLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_converted$ = -16					; size = 4
_i$ = -12						; size = 4
_pal32$ = -8						; size = 4
_pal24$ = -4						; size = 4
_pic$ = 8						; size = 4
_Image_ConvertPalTo24bit PROC

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 331  : 	byte	*pal32, *pal24;
; 332  : 	byte	*converted;
; 333  : 	int	i;
; 334  : 
; 335  : 	if( pic->type == PF_INDEXED_24 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN5@Image_Conv

; 336  : 		return; // does nothing

	jmp	$LN1@Image_Conv
$LN5@Image_Conv:

; 337  : 
; 338  : 	pal24 = converted = Mem_Malloc( host.imagepool, 768 );

	push	338					; 00000152H
	push	OFFSET $SG137430
	push	0
	push	768					; 00000300H
	mov	ecx, DWORD PTR _host+34740
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _converted$[ebp], eax
	mov	edx, DWORD PTR _converted$[ebp]
	mov	DWORD PTR _pal24$[ebp], edx

; 339  : 	pal32 = pic->palette;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pal32$[ebp], ecx

; 340  : 
; 341  : 	for( i = 0; i < 256; i++, pal24 += 3, pal32 += 4 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Conv
$LN2@Image_Conv:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _pal24$[ebp]
	add	eax, 3
	mov	DWORD PTR _pal24$[ebp], eax
	mov	ecx, DWORD PTR _pal32$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pal32$[ebp], ecx
$LN4@Image_Conv:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Image_Conv

; 342  : 	{
; 343  : 		pal24[0] = pal32[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pal24$[ebp]
	mov	esi, DWORD PTR _pal32$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al

; 344  : 		pal24[1] = pal32[1];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pal24$[ebp]
	mov	esi, DWORD PTR _pal32$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl

; 345  : 		pal24[2] = pal32[2];

	mov	edx, 1
	shl	edx, 1
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pal24$[ebp]
	mov	esi, DWORD PTR _pal32$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl

; 346  : 	}

	jmp	SHORT $LN2@Image_Conv
$LN3@Image_Conv:

; 347  : 
; 348  : 	Mem_Free( pic->palette );

	push	348					; 0000015cH
	push	OFFSET $SG137431
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 349  : 	pic->palette = converted;

	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR _converted$[ebp]
	mov	DWORD PTR [edx+20], eax

; 350  : 	pic->type = PF_INDEXED_24;

	mov	ecx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN1@Image_Conv:

; 351  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ConvertPalTo24bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv64 = -12						; size = 4
_rgba$ = -8						; size = 4
_i$ = -4						; size = 4
_pal$ = 8						; size = 4
_d_table$ = 12						; size = 4
_Image_SetPalette PROC

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 279  : 	byte	rgba[4];
; 280  : 	int	i;	
; 281  : 
; 282  : 	// setup palette
; 283  : 	switch( image.d_rendermode )

	mov	eax, DWORD PTR _image+68
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 3
	ja	$LN1@Image_SetP
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN21@Image_SetP[ecx*4]
$LN16@Image_SetP:

; 284  : 	{
; 285  : 	case LUMP_NORMAL:
; 286  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_SetP
$LN4@Image_SetP:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN5@Image_SetP

; 287  : 		{
; 288  : 			rgba[0] = pal[i*3+0];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR _rgba$[ebp+edx], al

; 289  : 			rgba[1] = pal[i*3+1];

	imul	ecx, DWORD PTR _i$[ebp], 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1]
	mov	BYTE PTR _rgba$[ebp+edx], cl

; 290  : 			rgba[2] = pal[i*3+2];

	imul	edx, DWORD PTR _i$[ebp], 3
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [ecx+edx+2]
	mov	BYTE PTR _rgba$[ebp+eax], dl

; 291  : 			rgba[3] = 0xFF;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _rgba$[ebp+ecx], 255		; 000000ffH

; 292  : 			d_table[i] = *(uint *)rgba;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _d_table$[ebp]
	mov	ecx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 293  : 		}

	jmp	SHORT $LN4@Image_SetP
$LN5@Image_SetP:

; 294  : 		break;

	jmp	$LN1@Image_SetP
$LN17@Image_SetP:

; 295  : 	case LUMP_GRADIENT:
; 296  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Image_SetP
$LN7@Image_SetP:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN8@Image_SetP

; 297  : 		{
; 298  : 			rgba[0] = pal[765];

	mov	eax, 1
	imul	ecx, eax, 765
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 299  : 			rgba[1] = pal[766];

	mov	edx, 1
	imul	eax, edx, 766
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _rgba$[ebp+ecx], al

; 300  : 			rgba[2] = pal[767];

	mov	ecx, 1
	imul	edx, ecx, 767
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _rgba$[ebp+eax], dl

; 301  : 			rgba[3] = i;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR _rgba$[ebp+ecx], dl

; 302  : 			d_table[i] = *(uint *)rgba;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _d_table$[ebp]
	mov	edx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 303  : 		}

	jmp	$LN7@Image_SetP
$LN8@Image_SetP:

; 304  : 		break;

	jmp	$LN1@Image_SetP
$LN18@Image_SetP:

; 305  : 	case LUMP_MASKED:
; 306  : 		for( i = 0; i < 255; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Image_SetP
$LN10@Image_SetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@Image_SetP

; 307  : 		{
; 308  : 			rgba[0] = pal[i*3+0];

	imul	ecx, DWORD PTR _i$[ebp], 3
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 309  : 			rgba[1] = pal[i*3+1];

	imul	edx, DWORD PTR _i$[ebp], 3
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1]
	mov	BYTE PTR _rgba$[ebp+eax], dl

; 310  : 			rgba[2] = pal[i*3+2];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax+2]
	mov	BYTE PTR _rgba$[ebp+ecx], al

; 311  : 			rgba[3] = 0xFF;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _rgba$[ebp+edx], 255		; 000000ffH

; 312  : 			d_table[i] = *(uint *)rgba;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _d_table$[ebp]
	mov	edx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 313  : 		}

	jmp	SHORT $LN10@Image_SetP
$LN11@Image_SetP:

; 314  : 		d_table[255] = 0;

	mov	eax, 4
	imul	ecx, eax, 255
	mov	edx, DWORD PTR _d_table$[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 315  : 		break;

	jmp	SHORT $LN1@Image_SetP
$LN19@Image_SetP:

; 316  : 	case LUMP_EXTENDED:
; 317  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@Image_SetP
$LN13@Image_SetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Image_SetP

; 318  : 		{
; 319  : 			rgba[0] = pal[i*4+0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [ecx+eax*4]
	mov	BYTE PTR _rgba$[ebp+edx], al

; 320  : 			rgba[1] = pal[i*4+1];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [eax+edx*4+1]
	mov	BYTE PTR _rgba$[ebp+ecx], dl

; 321  : 			rgba[2] = pal[i*4+2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx*4+2]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 322  : 			rgba[3] = pal[i*4+3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx*4+3]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 323  : 			d_table[i] = *(uint *)rgba;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _d_table$[ebp]
	mov	ecx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 324  : 		}

	jmp	SHORT $LN13@Image_SetP
$LN1@Image_SetP:

; 325  : 		break;	
; 326  : 	}
; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN21@Image_SetP:
	DD	$LN16@Image_SetP
	DD	$LN18@Image_SetP
	DD	$LN17@Image_SetP
	DD	$LN19@Image_SetP
_Image_SetPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_Image_CheckFlag PROC

; 201  : {

	push	ebp
	mov	ebp, esp

; 202  : 	if( FBitSet( image.force_flags, bit ))

	mov	eax, DWORD PTR _image+92
	and	eax, DWORD PTR _bit$[ebp]
	je	SHORT $LN2@Image_Chec

; 203  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN2@Image_Chec:

; 204  : 
; 205  : 	if( FBitSet( image.cmd_flags, bit ))

	mov	ecx, DWORD PTR _image+88
	and	ecx, DWORD PTR _bit$[ebp]
	je	SHORT $LN3@Image_Chec

; 206  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN3@Image_Chec:

; 207  : 
; 208  : 	return false;

	xor	eax, eax
$LN1@Image_Chec:

; 209  : }

	pop	ebp
	ret	0
_Image_CheckFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Image_LumpValidSize PROC

; 252  : {

	push	ebp
	mov	ebp, esp

; 253  : 	if( image.width > LUMP_MAXWIDTH || image.height > LUMP_MAXHEIGHT || image.width <= 0 || image.height <= 0 )

	movzx	eax, WORD PTR _image+8
	cmp	eax, 1024				; 00000400H
	jg	SHORT $LN3@Image_Lump
	movzx	ecx, WORD PTR _image+10
	cmp	ecx, 1024				; 00000400H
	jg	SHORT $LN3@Image_Lump
	movzx	edx, WORD PTR _image+8
	test	edx, edx
	jle	SHORT $LN3@Image_Lump
	movzx	eax, WORD PTR _image+10
	test	eax, eax
	jg	SHORT $LN2@Image_Lump
$LN3@Image_Lump:

; 254  : 	{
; 255  : 		Con_DPrintf( S_ERROR "Image: (%s) dims out of range [%dx%d]\n", name, image.width,image.height );

	movzx	ecx, WORD PTR _image+10
	push	ecx
	movzx	edx, WORD PTR _image+8
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG137378
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 256  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Lump
$LN2@Image_Lump:

; 257  : 	}
; 258  : 	return true;

	mov	eax, 1
$LN1@Image_Lump:

; 259  : }

	pop	ebp
	ret	0
_Image_LumpValidSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Image_ValidSize PROC

; 242  : {

	push	ebp
	mov	ebp, esp

; 243  : 	if( image.width > IMAGE_MAXWIDTH || image.height > IMAGE_MAXHEIGHT || image.width <= 0 || image.height <= 0 )

	movzx	eax, WORD PTR _image+8
	cmp	eax, 8192				; 00002000H
	jg	SHORT $LN3@Image_Vali
	movzx	ecx, WORD PTR _image+10
	cmp	ecx, 8192				; 00002000H
	jg	SHORT $LN3@Image_Vali
	movzx	edx, WORD PTR _image+8
	test	edx, edx
	jle	SHORT $LN3@Image_Vali
	movzx	eax, WORD PTR _image+10
	test	eax, eax
	jg	SHORT $LN2@Image_Vali
$LN3@Image_Vali:

; 244  : 	{
; 245  : 		Con_DPrintf( S_ERROR "Image: (%s) dims out of range [%dx%d]\n", name, image.width, image.height );

	movzx	ecx, WORD PTR _image+10
	push	ecx
	movzx	edx, WORD PTR _image+8
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG137372
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 246  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Vali
$LN2@Image_Vali:

; 247  : 	}
; 248  : 	return true;

	mov	eax, 1
$LN1@Image_Vali:

; 249  : }

	pop	ebp
	ret	0
_Image_ValidSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_src$ = 8						; size = 4
_Image_CopyParms PROC

; 562  : {

	push	ebp
	mov	ebp, esp

; 563  : 	Image_Reset();

	call	_Image_Reset

; 564  : 
; 565  : 	image.width = src->width;

	mov	eax, DWORD PTR _src$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _image+8, cx

; 566  : 	image.height = src->height;

	mov	edx, DWORD PTR _src$[ebp]
	mov	ax, WORD PTR [edx+2]
	mov	WORD PTR _image+10, ax

; 567  : 	image.type = src->type;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _image+20, edx

; 568  : 	image.flags = src->flags;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _image+24, ecx

; 569  : 	image.size = src->size;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _image+28, eax

; 570  : 	image.palette = src->palette;	// may be NULL

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _image+72, edx

; 571  : 
; 572  : 	memcpy( image.fogParams, src->fogParams, sizeof( image.fogParams ));

	push	4
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET _image+76
	call	_memcpy
	add	esp, 12					; 0000000cH

; 573  : }

	pop	ebp
	ret	0
_Image_CopyParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_out$ = -4						; size = 4
_size$ = 8						; size = 4
_Image_Copy PROC

; 176  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 177  : 	byte	*out;
; 178  : 
; 179  : 	out = Mem_Malloc( host.imagepool, size );

	push	179					; 000000b3H
	push	OFFSET $SG137351
	push	0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+34740
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 180  : 	memcpy( out, image.tempbuffer, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 181  : 
; 182  : 	return out; 

	mov	eax, DWORD PTR _out$[ebp]

; 183  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_Image_GetPaletteHL PROC

; 396  : {

	push	ebp
	mov	ebp, esp

; 397  : 	if( !hlpalette_init )

	cmp	DWORD PTR _hlpalette_init, 0
	jne	SHORT $LN2@Image_GetP

; 398  : 	{
; 399  : 		image.d_rendermode = LUMP_NORMAL;

	mov	DWORD PTR _image+68, 0

; 400  : 		Image_SetPalette( palette_hl, d_8toHLtable );

	push	OFFSET _d_8toHLtable
	push	OFFSET _palette_hl
	call	_Image_SetPalette
	add	esp, 8

; 401  : 		hlpalette_init = true;

	mov	DWORD PTR _hlpalette_init, 1
$LN2@Image_GetP:

; 402  : 	}
; 403  : 
; 404  : 	image.d_rendermode = LUMP_HALFLIFE;

	mov	DWORD PTR _image+68, 4

; 405  : 	image.d_currentpal = d_8toHLtable;

	mov	DWORD PTR _image+64, OFFSET _d_8toHLtable

; 406  : }

	pop	ebp
	ret	0
_Image_GetPaletteHL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_Image_GetPaletteQ1 PROC

; 382  : {

	push	ebp
	mov	ebp, esp

; 383  : 	if( !q1palette_init )

	cmp	DWORD PTR _q1palette_init, 0
	jne	SHORT $LN2@Image_GetP

; 384  : 	{
; 385  : 		image.d_rendermode = LUMP_NORMAL;

	mov	DWORD PTR _image+68, 0

; 386  : 		Image_SetPalette( palette_q1, d_8toQ1table );

	push	OFFSET _d_8toQ1table
	push	OFFSET _palette_q1
	call	_Image_SetPalette
	add	esp, 8

; 387  : 		d_8toQ1table[255] = 0; // 255 is transparent

	mov	eax, 4
	imul	ecx, eax, 255
	mov	DWORD PTR _d_8toQ1table[ecx], 0

; 388  : 		q1palette_init = true;

	mov	DWORD PTR _q1palette_init, 1
$LN2@Image_GetP:

; 389  : 	}
; 390  : 
; 391  : 	image.d_rendermode = LUMP_QUAKE1;

	mov	DWORD PTR _image+68, 5

; 392  : 	image.d_currentpal = d_8toQ1table;

	mov	DWORD PTR _image+64, OFFSET _d_8toQ1table

; 393  : }

	pop	ebp
	ret	0
_Image_GetPaletteQ1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_Image_CopyPalette32bit PROC

; 354  : {

	push	ebp
	mov	ebp, esp

; 355  : 	if( image.palette ) return; // already created ?

	cmp	DWORD PTR _image+72, 0
	je	SHORT $LN2@Image_Copy
	jmp	SHORT $LN1@Image_Copy
$LN2@Image_Copy:

; 356  : 	image.palette = Mem_Malloc( host.imagepool, 1024 );

	push	356					; 00000164H
	push	OFFSET $SG137435
	push	0
	push	1024					; 00000400H
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+72, eax

; 357  : 	memcpy( image.palette, image.d_currentpal, 1024 );

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _image+64
	push	ecx
	mov	edx, DWORD PTR _image+72
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Image_Copy:

; 358  : }

	pop	ebp
	ret	0
_Image_CopyPalette32bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_pal$ = 8						; size = 4
_Image_ComparePalette PROC

; 267  : {

	push	ebp
	mov	ebp, esp

; 268  : 	if( pal == NULL )

	cmp	DWORD PTR _pal$[ebp], 0
	jne	SHORT $LN2@Image_Comp

; 269  : 		return PAL_INVALID;

	or	eax, -1
	jmp	SHORT $LN1@Image_Comp
	jmp	SHORT $LN3@Image_Comp
$LN2@Image_Comp:

; 270  : 	else if( !memcmp( palette_q1, pal, 765 )) // last color was changed

	push	765					; 000002fdH
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	push	OFFSET _palette_q1
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@Image_Comp

; 271  : 		return PAL_QUAKE1;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Comp
	jmp	SHORT $LN3@Image_Comp
$LN4@Image_Comp:

; 272  : 	else if( !memcmp( palette_hl, pal, 765 ))

	push	765					; 000002fdH
	mov	ecx, DWORD PTR _pal$[ebp]
	push	ecx
	push	OFFSET _palette_hl
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Image_Comp

; 273  : 		return PAL_HALFLIFE;

	mov	eax, 2
	jmp	SHORT $LN1@Image_Comp
$LN3@Image_Comp:

; 274  : 	return PAL_CUSTOM;		

	xor	eax, eax
$LN1@Image_Comp:

; 275  : }

	pop	ebp
	ret	0
_Image_ComparePalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_pal$ = 8						; size = 4
_Image_GetPaletteBMP PROC

; 409  : {

	push	ebp
	mov	ebp, esp

; 410  : 	image.d_rendermode = LUMP_EXTENDED;

	mov	DWORD PTR _image+68, 3

; 411  : 
; 412  : 	if( pal )

	cmp	DWORD PTR _pal$[ebp], 0
	je	SHORT $LN1@Image_GetP

; 413  : 	{
; 414  : 		Image_SetPalette( pal, d_8to24table );

	push	OFFSET _d_8to24table
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	call	_Image_SetPalette
	add	esp, 8

; 415  : 		image.d_currentpal = d_8to24table;

	mov	DWORD PTR _image+64, OFFSET _d_8to24table
$LN1@Image_GetP:

; 416  : 	}
; 417  : }

	pop	ebp
	ret	0
_Image_GetPaletteBMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv67 = -4						; size = 4
_pal$ = 8						; size = 4
_rendermode$ = 12					; size = 4
_Image_GetPaletteLMP PROC

; 420  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 421  : 	image.d_rendermode = rendermode;

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR _image+68, eax

; 422  : 
; 423  : 	if( pal )

	cmp	DWORD PTR _pal$[ebp], 0
	je	SHORT $LN4@Image_GetP

; 424  : 	{
; 425  : 		Image_SetPalette( pal, d_8to24table );

	push	OFFSET _d_8to24table
	mov	ecx, DWORD PTR _pal$[ebp]
	push	ecx
	call	_Image_SetPalette
	add	esp, 8

; 426  : 		image.d_currentpal = d_8to24table;

	mov	DWORD PTR _image+64, OFFSET _d_8to24table

; 427  : 	}

	jmp	SHORT $LN1@Image_GetP
$LN4@Image_GetP:

; 428  : 	else
; 429  : 	{
; 430  : 		switch( rendermode )

	mov	edx, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 4
	je	SHORT $LN7@Image_GetP
	cmp	DWORD PTR tv67[ebp], 5
	je	SHORT $LN6@Image_GetP
	jmp	SHORT $LN8@Image_GetP
$LN6@Image_GetP:

; 431  : 		{
; 432  : 		case LUMP_QUAKE1:
; 433  : 			Image_GetPaletteQ1();

	call	_Image_GetPaletteQ1

; 434  : 			break;

	jmp	SHORT $LN1@Image_GetP
$LN7@Image_GetP:

; 435  : 		case LUMP_HALFLIFE:
; 436  : 			Image_GetPaletteHL();

	call	_Image_GetPaletteHL

; 437  : 			break;

	jmp	SHORT $LN1@Image_GetP
$LN8@Image_GetP:

; 438  : 		default:
; 439  : 			// defaulting to half-life palette
; 440  : 			Image_GetPaletteHL();

	call	_Image_GetPaletteHL
$LN1@Image_GetP:

; 441  : 			break;
; 442  : 		}
; 443  : 	}
; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_GetPaletteLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_mipsize$ = -8						; size = 4
_expand_to_rgba$ = -4					; size = 4
_in$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_Image_AddIndexedImageToPack PROC

; 1196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1197 : 	int	mipsize = width * height;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _mipsize$[ebp], eax

; 1198 : 	qboolean	expand_to_rgba = true;

	mov	DWORD PTR _expand_to_rgba$[ebp], 1

; 1199 : 
; 1200 : 	if( Image_CheckFlag( IL_KEEP_8BIT ))

	push	2
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Image_AddI

; 1201 : 		expand_to_rgba = false;

	mov	DWORD PTR _expand_to_rgba$[ebp], 0
	jmp	SHORT $LN3@Image_AddI
$LN2@Image_AddI:

; 1202 : 	else if( FBitSet( image.flags, IMAGE_HAS_LUMA|IMAGE_QUAKESKY ))

	mov	ecx, DWORD PTR _image+24
	and	ecx, 80					; 00000050H
	je	SHORT $LN3@Image_AddI

; 1203 : 		expand_to_rgba = false;

	mov	DWORD PTR _expand_to_rgba$[ebp], 0
$LN3@Image_AddI:

; 1204 : 
; 1205 : 	image.size = mipsize;

	mov	edx, DWORD PTR _mipsize$[ebp]
	mov	DWORD PTR _image+28, edx

; 1206 : 
; 1207 : 	if( expand_to_rgba ) image.size *= 4;

	cmp	DWORD PTR _expand_to_rgba$[ebp], 0
	je	SHORT $LN5@Image_AddI
	mov	eax, DWORD PTR _image+28
	shl	eax, 2
	mov	DWORD PTR _image+28, eax
	jmp	SHORT $LN6@Image_AddI
$LN5@Image_AddI:

; 1208 : 	else Image_CopyPalette32bit(); 

	call	_Image_CopyPalette32bit
$LN6@Image_AddI:

; 1209 : 
; 1210 : 	// reallocate image buffer
; 1211 : 	image.rgba = Mem_Malloc( host.imagepool, image.size );	

	push	1211					; 000004bbH
	push	OFFSET $SG137995
	push	0
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax

; 1212 : 	if( !expand_to_rgba ) memcpy( image.rgba, in, image.size );

	cmp	DWORD PTR _expand_to_rgba$[ebp], 0
	jne	SHORT $LN7@Image_AddI
	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+40
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@Image_AddI
$LN7@Image_AddI:

; 1213 : 	else if( !Image_Copy8bitRGBA( in, image.rgba, mipsize ))

	mov	eax, DWORD PTR _mipsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+40
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_Image_Copy8bitRGBA
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Image_AddI

; 1214 : 		return false; // probably pallette not installed

	xor	eax, eax
	jmp	SHORT $LN1@Image_AddI
$LN8@Image_AddI:

; 1215 : 
; 1216 : 	return true;

	mov	eax, 1
$LN1@Image_AddI:

; 1217 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_AddIndexedImageToPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv82 = -20						; size = 4
_fin$ = -16						; size = 4
_col$ = -12						; size = 4
_i$ = -8						; size = 4
_iout$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_pixels$ = 16						; size = 4
_Image_Copy8bitRGBA PROC

; 583  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 584  : 	int	*iout = (int *)out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _iout$[ebp], eax

; 585  : 	byte	*fin = (byte *)in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _fin$[ebp], ecx

; 586  : 	byte	*col;
; 587  : 	int	i;
; 588  : 
; 589  : 	if( !in || !image.d_currentpal )

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN11@Image_Copy
	cmp	DWORD PTR _image+64, 0
	jne	SHORT $LN10@Image_Copy
$LN11@Image_Copy:

; 590  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Copy
$LN10@Image_Copy:

; 591  : 
; 592  : 	// this is a base image with luma - clear luma pixels
; 593  : 	if( image.flags & IMAGE_HAS_LUMA )

	mov	edx, DWORD PTR _image+24
	and	edx, 16					; 00000010H
	je	SHORT $LN12@Image_Copy

; 594  : 	{
; 595  : 		for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Copy
$LN2@Image_Copy:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Copy:
	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN12@Image_Copy

; 596  : 			fin[i] = fin[i] < 224 ? fin[i] : 0;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 224				; 000000e0H
	jge	SHORT $LN19@Image_Copy
	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN20@Image_Copy
$LN19@Image_Copy:
	mov	DWORD PTR tv82[ebp], 0
$LN20@Image_Copy:
	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR tv82[ebp]
	mov	BYTE PTR [ecx], dl
	jmp	SHORT $LN2@Image_Copy
$LN12@Image_Copy:

; 597  : 	}
; 598  : 
; 599  : 	// check for color
; 600  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Copy
$LN5@Image_Copy:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Copy:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN8@Image_Copy

; 601  : 	{
; 602  : 		col = (byte *)&image.d_currentpal[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _image+64
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _col$[ebp], eax

; 603  : 		if( col[0] != col[1] || col[1] != col[2] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	cmp	ecx, edx
	jne	SHORT $LN14@Image_Copy
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	cmp	edx, eax
	je	SHORT $LN13@Image_Copy
$LN14@Image_Copy:

; 604  : 		{
; 605  : 			image.flags |= IMAGE_HAS_COLOR;

	mov	ecx, DWORD PTR _image+24
	or	ecx, 4
	mov	DWORD PTR _image+24, ecx

; 606  : 			break;

	jmp	SHORT $LN8@Image_Copy
$LN13@Image_Copy:

; 607  : 		}
; 608  : 	}

	jmp	SHORT $LN5@Image_Copy
$LN8@Image_Copy:

; 609  : 
; 610  : 	while( pixels >= 8 )

	cmp	DWORD PTR _pixels$[ebp], 8
	jl	$LN9@Image_Copy

; 611  : 	{
; 612  : 		iout[0] = image.d_currentpal[in[0]];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx], edx

; 613  : 		iout[1] = image.d_currentpal[in[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 614  : 		iout[2] = image.d_currentpal[in[2]];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 615  : 		iout[3] = image.d_currentpal[in[3]];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 616  : 		iout[4] = image.d_currentpal[in[4]];

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax

; 617  : 		iout[5] = image.d_currentpal[in[5]];

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 4
	imul	eax, edx, 5
	mov	edx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [edx+eax], ecx

; 618  : 		iout[6] = image.d_currentpal[in[6]];

	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	imul	ecx, eax, 6
	mov	eax, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx], edx

; 619  : 		iout[7] = image.d_currentpal[in[7]];

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 620  : 
; 621  : 		in += 8;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 8
	mov	DWORD PTR _in$[ebp], ecx

; 622  : 		iout += 8;

	mov	edx, DWORD PTR _iout$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR _iout$[ebp], edx

; 623  : 		pixels -= 8;

	mov	eax, DWORD PTR _pixels$[ebp]
	sub	eax, 8
	mov	DWORD PTR _pixels$[ebp], eax

; 624  : 	}

	jmp	$LN8@Image_Copy
$LN9@Image_Copy:

; 625  : 
; 626  : 	if( pixels & 4 )

	mov	ecx, DWORD PTR _pixels$[ebp]
	and	ecx, 4
	je	$LN15@Image_Copy

; 627  : 	{
; 628  : 		iout[0] = image.d_currentpal[in[0]];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx], edx

; 629  : 		iout[1] = image.d_currentpal[in[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 630  : 		iout[2] = image.d_currentpal[in[2]];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 631  : 		iout[3] = image.d_currentpal[in[3]];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 632  : 		in += 4;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$[ebp], ecx

; 633  : 		iout += 4;

	mov	edx, DWORD PTR _iout$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _iout$[ebp], edx
$LN15@Image_Copy:

; 634  : 	}
; 635  : 
; 636  : 	if( pixels & 2 )

	mov	eax, DWORD PTR _pixels$[ebp]
	and	eax, 2
	je	SHORT $LN16@Image_Copy

; 637  : 	{
; 638  : 		iout[0] = image.d_currentpal[in[0]];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [edx+eax], ecx

; 639  : 		iout[1] = image.d_currentpal[in[1]];

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx], ecx

; 640  : 		in += 2;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx

; 641  : 		iout += 2;

	mov	eax, DWORD PTR _iout$[ebp]
	add	eax, 8
	mov	DWORD PTR _iout$[ebp], eax
$LN16@Image_Copy:

; 642  : 	}
; 643  : 
; 644  : 	if( pixels & 1 ) // last byte

	mov	ecx, DWORD PTR _pixels$[ebp]
	and	ecx, 1
	je	SHORT $LN17@Image_Copy

; 645  : 		iout[0] = image.d_currentpal[in[0]];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+ecx], edx
$LN17@Image_Copy:

; 646  : 	image.type = PF_RGBA_32;	// update image type;

	mov	DWORD PTR _image+20, 3

; 647  : 
; 648  : 	return true;

	mov	eax, 1
$LN1@Image_Copy:

; 649  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Copy8bitRGBA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_flip_i$ = -96						; size = 4
_col_inc$ = -92						; size = 4
_col_ofs$ = -88						; size = 4
_row_inc$ = -84						; size = 4
_row_ofs$ = -80						; size = 4
tv130 = -76						; size = 4
tv95 = -72						; size = 4
_flip_x$ = -68						; size = 4
tv90 = -64						; size = 4
_flip_y$ = -60						; size = 4
tv83 = -56						; size = 4
tv78 = -52						; size = 4
tv75 = -48						; size = 4
tv72 = -44						; size = 4
tv69 = -40						; size = 4
_out$ = -36						; size = 4
_p$ = -32						; size = 4
_x$ = -28						; size = 4
_line$ = -24						; size = 4
_y$ = -20						; size = 4
_i$ = -16						; size = 4
_samples$ = -12						; size = 4
_height$ = -8						; size = 2
_width$ = -4						; size = 2
_in$ = 8						; size = 4
_srcwidth$ = 12						; size = 4
_srcheight$ = 16					; size = 4
_type$ = 20						; size = 4
_flags$ = 24						; size = 4
_Image_FlipInternal PROC

; 1105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 1106 : 	int	i, x, y;
; 1107 : 	word	width = *srcwidth;

	mov	eax, DWORD PTR _srcwidth$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _width$[ebp], cx

; 1108 : 	word	height = *srcheight; 

	mov	edx, DWORD PTR _srcheight$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _height$[ebp], ax

; 1109 : 	int	samples = PFDesc[type].bpp;

	imul	ecx, DWORD PTR _type$[ebp], 28
	mov	edx, DWORD PTR _PFDesc[ecx+24]
	mov	DWORD PTR _samples$[ebp], edx

; 1110 : 	qboolean	flip_x = FBitSet( flags, IMAGE_FLIP_X ) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN30@Image_Flip
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN31@Image_Flip
$LN30@Image_Flip:
	mov	DWORD PTR tv69[ebp], 0
$LN31@Image_Flip:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _flip_x$[ebp], ecx

; 1111 : 	qboolean	flip_y = FBitSet( flags, IMAGE_FLIP_Y ) ? true : false;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 131072				; 00020000H
	je	SHORT $LN32@Image_Flip
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN33@Image_Flip
$LN32@Image_Flip:
	mov	DWORD PTR tv72[ebp], 0
$LN33@Image_Flip:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR _flip_y$[ebp], eax

; 1112 : 	qboolean	flip_i = FBitSet( flags, IMAGE_ROT_90 ) ? true : false;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN34@Image_Flip
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN35@Image_Flip
$LN34@Image_Flip:
	mov	DWORD PTR tv75[ebp], 0
$LN35@Image_Flip:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _flip_i$[ebp], edx

; 1113 : 	int	row_inc = ( flip_y ? -samples : samples ) * width;

	cmp	DWORD PTR _flip_y$[ebp], 0
	je	SHORT $LN36@Image_Flip
	mov	eax, DWORD PTR _samples$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN37@Image_Flip
$LN36@Image_Flip:
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN37@Image_Flip:
	movzx	edx, WORD PTR _width$[ebp]
	imul	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _row_inc$[ebp], edx

; 1114 : 	int	col_inc = ( flip_x ? -samples : samples );

	cmp	DWORD PTR _flip_x$[ebp], 0
	je	SHORT $LN38@Image_Flip
	mov	eax, DWORD PTR _samples$[ebp]
	neg	eax
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN39@Image_Flip
$LN38@Image_Flip:
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN39@Image_Flip:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _col_inc$[ebp], edx

; 1115 : 	int	row_ofs = ( flip_y ? ( height - 1 ) * width * samples : 0 );

	cmp	DWORD PTR _flip_y$[ebp], 0
	je	SHORT $LN40@Image_Flip
	movzx	eax, WORD PTR _height$[ebp]
	sub	eax, 1
	movzx	ecx, WORD PTR _width$[ebp]
	imul	eax, ecx
	imul	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN41@Image_Flip
$LN40@Image_Flip:
	mov	DWORD PTR tv90[ebp], 0
$LN41@Image_Flip:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _row_ofs$[ebp], edx

; 1116 : 	int	col_ofs = ( flip_x ? ( width - 1 ) * samples : 0 );

	cmp	DWORD PTR _flip_x$[ebp], 0
	je	SHORT $LN42@Image_Flip
	movzx	eax, WORD PTR _width$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN43@Image_Flip
$LN42@Image_Flip:
	mov	DWORD PTR tv95[ebp], 0
$LN43@Image_Flip:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _col_ofs$[ebp], ecx

; 1117 : 	const byte *p, *line;
; 1118 : 	byte	*out;
; 1119 : 
; 1120 : 	// nothing to process
; 1121 : 	if( !FBitSet( flags, IMAGE_FLIP_X|IMAGE_FLIP_Y|IMAGE_ROT_90 ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 458752				; 00070000H
	jne	SHORT $LN22@Image_Flip

; 1122 : 		return (byte *)in;

	mov	eax, DWORD PTR _in$[ebp]
	jmp	$LN1@Image_Flip
$LN22@Image_Flip:

; 1123 : 
; 1124 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv130[ebp], eax
	cmp	DWORD PTR tv130[ebp], 0
	jle	SHORT $LN24@Image_Flip
	cmp	DWORD PTR tv130[ebp], 6
	jle	SHORT $LN23@Image_Flip
	jmp	SHORT $LN24@Image_Flip
$LN23@Image_Flip:

; 1125 : 	{
; 1126 : 	case PF_INDEXED_24:
; 1127 : 	case PF_INDEXED_32:
; 1128 : 	case PF_RGB_24:
; 1129 : 	case PF_BGR_24:
; 1130 : 	case PF_RGBA_32:
; 1131 : 	case PF_BGRA_32:
; 1132 : 		image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, width * height * samples );

	push	1132					; 0000046cH
	push	OFFSET $SG137949
	push	1
	movzx	ecx, WORD PTR _width$[ebp]
	movzx	edx, WORD PTR _height$[ebp]
	imul	ecx, edx
	imul	ecx, DWORD PTR _samples$[ebp]
	push	ecx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _host+34740
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1133 : 		break;

	jmp	SHORT $LN2@Image_Flip
$LN24@Image_Flip:

; 1134 : 	default:
; 1135 : 		return (byte *)in;	

	mov	eax, DWORD PTR _in$[ebp]
	jmp	$LN1@Image_Flip
$LN2@Image_Flip:

; 1136 : 	}
; 1137 : 
; 1138 : 	out = image.tempbuffer;

	mov	edx, DWORD PTR _image+84
	mov	DWORD PTR _out$[ebp], edx

; 1139 : 
; 1140 : 	if( flip_i )

	cmp	DWORD PTR _flip_i$[ebp], 0
	je	$LN25@Image_Flip

; 1141 : 	{
; 1142 : 		for( x = 0, line = in + col_ofs; x < width; x++, line += col_inc )

	mov	DWORD PTR _x$[ebp], 0
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _col_ofs$[ebp]
	mov	DWORD PTR _line$[ebp], eax
	jmp	SHORT $LN6@Image_Flip
$LN4@Image_Flip:
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx
	mov	edx, DWORD PTR _line$[ebp]
	add	edx, DWORD PTR _col_inc$[ebp]
	mov	DWORD PTR _line$[ebp], edx
$LN6@Image_Flip:
	movzx	eax, WORD PTR _width$[ebp]
	cmp	DWORD PTR _x$[ebp], eax
	jge	SHORT $LN5@Image_Flip

; 1143 : 			for( y = 0, p = line + row_ofs; y < height; y++, p += row_inc, out += samples )

	mov	DWORD PTR _y$[ebp], 0
	mov	ecx, DWORD PTR _line$[ebp]
	add	ecx, DWORD PTR _row_ofs$[ebp]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN9@Image_Flip
$LN7@Image_Flip:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _row_inc$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN9@Image_Flip:
	movzx	edx, WORD PTR _height$[ebp]
	cmp	DWORD PTR _y$[ebp], edx
	jge	SHORT $LN8@Image_Flip

; 1144 : 				for( i = 0; i < samples; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Image_Flip
$LN10@Image_Flip:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Image_Flip:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _samples$[ebp]
	jge	SHORT $LN11@Image_Flip

; 1145 : 					out[i] = p[i];

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN10@Image_Flip
$LN11@Image_Flip:
	jmp	SHORT $LN7@Image_Flip
$LN8@Image_Flip:
	jmp	$LN4@Image_Flip
$LN5@Image_Flip:

; 1146 : 	}

	jmp	$LN26@Image_Flip
$LN25@Image_Flip:

; 1147 : 	else
; 1148 : 	{
; 1149 : 		for( y = 0, line = in + row_ofs; y < height; y++, line += row_inc )

	mov	DWORD PTR _y$[ebp], 0
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row_ofs$[ebp]
	mov	DWORD PTR _line$[ebp], edx
	jmp	SHORT $LN15@Image_Flip
$LN13@Image_Flip:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _line$[ebp]
	add	ecx, DWORD PTR _row_inc$[ebp]
	mov	DWORD PTR _line$[ebp], ecx
$LN15@Image_Flip:
	movzx	edx, WORD PTR _height$[ebp]
	cmp	DWORD PTR _y$[ebp], edx
	jge	SHORT $LN26@Image_Flip

; 1150 : 			for( x = 0, p = line + col_ofs; x < width; x++, p += col_inc, out += samples )

	mov	DWORD PTR _x$[ebp], 0
	mov	eax, DWORD PTR _line$[ebp]
	add	eax, DWORD PTR _col_ofs$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN18@Image_Flip
$LN16@Image_Flip:
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _col_inc$[ebp]
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _out$[ebp], eax
$LN18@Image_Flip:
	movzx	ecx, WORD PTR _width$[ebp]
	cmp	DWORD PTR _x$[ebp], ecx
	jge	SHORT $LN17@Image_Flip

; 1151 : 				for( i = 0; i < samples; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@Image_Flip
$LN19@Image_Flip:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN21@Image_Flip:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jge	SHORT $LN20@Image_Flip

; 1152 : 					out[i] = p[i];

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN19@Image_Flip
$LN20@Image_Flip:
	jmp	SHORT $LN16@Image_Flip
$LN17@Image_Flip:
	jmp	$LN13@Image_Flip
$LN26@Image_Flip:

; 1153 : 	}
; 1154 : 
; 1155 : 	// update dims
; 1156 : 	if( FBitSet( flags, IMAGE_ROT_90 ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN27@Image_Flip

; 1157 : 	{
; 1158 : 		*srcwidth = height;

	mov	edx, DWORD PTR _srcwidth$[ebp]
	mov	ax, WORD PTR _height$[ebp]
	mov	WORD PTR [edx], ax

; 1159 : 		*srcheight = width;		

	mov	ecx, DWORD PTR _srcheight$[ebp]
	mov	dx, WORD PTR _width$[ebp]
	mov	WORD PTR [ecx], dx

; 1160 : 	}

	jmp	SHORT $LN28@Image_Flip
$LN27@Image_Flip:

; 1161 : 	else
; 1162 : 	{
; 1163 : 		*srcwidth = width;

	mov	eax, DWORD PTR _srcwidth$[ebp]
	mov	cx, WORD PTR _width$[ebp]
	mov	WORD PTR [eax], cx

; 1164 : 		*srcheight = height;	

	mov	edx, DWORD PTR _srcheight$[ebp]
	mov	ax, WORD PTR _height$[ebp]
	mov	WORD PTR [edx], ax
$LN28@Image_Flip:

; 1165 : 	}
; 1166 : 
; 1167 : 	return image.tempbuffer;

	mov	eax, DWORD PTR _image+84
$LN1@Image_Flip:

; 1168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_FlipInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_quality$ = -8						; size = 4
tv68 = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outwidth$ = 20						; size = 4
_outheight$ = 24					; size = 4
_type$ = 28						; size = 4
_resampled$ = 32					; size = 4
_Image_ResampleInternal PROC

; 1060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1061 : 	qboolean	quality = Image_CheckFlag( IL_USE_LERPING );

	push	1
	call	_Image_CheckFlag
	add	esp, 4
	mov	DWORD PTR _quality$[ebp], eax

; 1062 : 
; 1063 : 	// nothing to resample ?
; 1064 : 	if( inwidth == outwidth && inheight == outheight )

	mov	eax, DWORD PTR _inwidth$[ebp]
	cmp	eax, DWORD PTR _outwidth$[ebp]
	jne	SHORT $LN4@Image_Resa
	mov	ecx, DWORD PTR _inheight$[ebp]
	cmp	ecx, DWORD PTR _outheight$[ebp]
	jne	SHORT $LN4@Image_Resa

; 1065 : 	{
; 1066 : 		*resampled = false;

	mov	edx, DWORD PTR _resampled$[ebp]
	mov	DWORD PTR [edx], 0

; 1067 : 		return (byte *)indata;

	mov	eax, DWORD PTR _indata$[ebp]
	jmp	$LN1@Image_Resa
$LN4@Image_Resa:

; 1068 : 	}
; 1069 : 
; 1070 : 	// alloc new buffer
; 1071 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 5
	ja	$LN12@Image_Resa
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN14@Image_Resa[edx*4]
$LN5@Image_Resa:

; 1072 : 	{
; 1073 : 	case PF_INDEXED_24:
; 1074 : 	case PF_INDEXED_32:
; 1075 : 		image.tempbuffer = (byte *)Mem_Realloc( host.imagepool, image.tempbuffer, outwidth * outheight );

	push	1075					; 00000433H
	push	OFFSET $SG137888
	push	1
	mov	eax, DWORD PTR _outwidth$[ebp]
	imul	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _host+34740
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1076 : 		Image_Resample8Nolerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	mov	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _inheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _indata$[ebp]
	push	edx
	call	_Image_Resample8Nolerp
	add	esp, 24					; 00000018H

; 1077 : 		break;		

	jmp	$LN2@Image_Resa
$LN6@Image_Resa:

; 1078 : 	case PF_RGB_24:
; 1079 : 	case PF_BGR_24:
; 1080 : 		image.tempbuffer = (byte *)Mem_Realloc( host.imagepool, image.tempbuffer, outwidth * outheight * 3 );

	push	1080					; 00000438H
	push	OFFSET $SG137890
	push	1
	mov	eax, DWORD PTR _outwidth$[ebp]
	imul	eax, DWORD PTR _outheight$[ebp]
	imul	ecx, eax, 3
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1081 : 		if( quality ) Image_Resample24Lerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	cmp	DWORD PTR _quality$[ebp], 0
	je	SHORT $LN7@Image_Resa
	mov	ecx, DWORD PTR _outheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _inheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _indata$[ebp]
	push	eax
	call	_Image_Resample24Lerp
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@Image_Resa
$LN7@Image_Resa:

; 1082 : 		else Image_Resample24Nolerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	mov	ecx, DWORD PTR _outheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _inheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _indata$[ebp]
	push	eax
	call	_Image_Resample24Nolerp
	add	esp, 24					; 00000018H
$LN8@Image_Resa:

; 1083 : 		break;

	jmp	$LN2@Image_Resa
$LN9@Image_Resa:

; 1084 : 	case PF_RGBA_32:
; 1085 : 	case PF_BGRA_32:
; 1086 : 		image.tempbuffer = (byte *)Mem_Realloc( host.imagepool, image.tempbuffer, outwidth * outheight * 4 );

	push	1086					; 0000043eH
	push	OFFSET $SG137894
	push	1
	mov	ecx, DWORD PTR _outwidth$[ebp]
	imul	ecx, DWORD PTR _outheight$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34740
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1087 : 		if( quality ) Image_Resample32Lerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	cmp	DWORD PTR _quality$[ebp], 0
	je	SHORT $LN10@Image_Resa
	mov	ecx, DWORD PTR _outheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _inheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _indata$[ebp]
	push	eax
	call	_Image_Resample32Lerp
	add	esp, 24					; 00000018H
	jmp	SHORT $LN11@Image_Resa
$LN10@Image_Resa:

; 1088 : 		else Image_Resample32Nolerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	mov	ecx, DWORD PTR _outheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _inheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inwidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _indata$[ebp]
	push	eax
	call	_Image_Resample32Nolerp
	add	esp, 24					; 00000018H
$LN11@Image_Resa:

; 1089 : 		break;

	jmp	SHORT $LN2@Image_Resa
$LN12@Image_Resa:

; 1090 : 	default:
; 1091 : 		*resampled = false;

	mov	ecx, DWORD PTR _resampled$[ebp]
	mov	DWORD PTR [ecx], 0

; 1092 : 		return (byte *)indata;	

	mov	eax, DWORD PTR _indata$[ebp]
	jmp	SHORT $LN1@Image_Resa
$LN2@Image_Resa:

; 1093 : 	}
; 1094 : 
; 1095 : 	*resampled = true;

	mov	edx, DWORD PTR _resampled$[ebp]
	mov	DWORD PTR [edx], 1

; 1096 : 	return image.tempbuffer;

	mov	eax, DWORD PTR _image+84
$LN1@Image_Resa:

; 1097 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@Image_Resa:
	DD	$LN5@Image_Resa
	DD	$LN5@Image_Resa
	DD	$LN9@Image_Resa
	DD	$LN9@Image_Resa
	DD	$LN6@Image_Resa
	DD	$LN6@Image_Resa
_Image_ResampleInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_pic$ = -4						; size = 4
_Image_CheckPaletteQ1 PROC

; 361  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 362  : 	rgbdata_t	*pic = FS_LoadImage( DEFAULT_INTERNAL_PALETTE, NULL, 0 );

	push	0
	push	0
	push	OFFSET $SG137440
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pic$[ebp], eax

; 363  : 
; 364  : 	if( pic && pic->size == 1024 )

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN2@Image_Chec
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+32], 1024		; 00000400H
	jne	SHORT $LN2@Image_Chec

; 365  : 	{
; 366  : 		Image_ConvertPalTo24bit( pic );

	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	call	_Image_ConvertPalTo24bit
	add	esp, 4

; 367  : 		if( Image_ComparePalette( pic->palette ) == PAL_CUSTOM )

	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_Image_ComparePalette
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Image_Chec

; 368  : 		{
; 369  : 			image.d_rendermode = LUMP_NORMAL;

	mov	DWORD PTR _image+68, 0

; 370  : 			Con_DPrintf( "custom quake palette detected\n" );

	push	OFFSET $SG137443
	call	_Con_DPrintf
	add	esp, 4

; 371  : 			Image_SetPalette( pic->palette, d_8toQ1table );

	push	OFFSET _d_8toQ1table
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_Image_SetPalette
	add	esp, 8

; 372  : 			d_8toQ1table[255] = 0; // 255 is transparent

	mov	eax, 4
	imul	ecx, eax, 255
	mov	DWORD PTR _d_8toQ1table[ecx], 0

; 373  : 			image.custom_palette = true;

	mov	DWORD PTR _image+96, 1

; 374  : 			q1palette_init = true;

	mov	DWORD PTR _q1palette_init, 1
$LN2@Image_Chec:

; 375  : 		}
; 376  : 	}
; 377  : 
; 378  : 	if( pic ) FS_FreeImage( pic );

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN1@Image_Chec
	mov	edx, DWORD PTR _pic$[ebp]
	push	edx
	call	_FS_FreeImage
	add	esp, 4
$LN1@Image_Chec:

; 379  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckPaletteQ1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_Image_ClearForceFlags PROC

; 227  : {

	push	ebp
	mov	ebp, esp

; 228  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 229  : }

	pop	ebp
	ret	0
_Image_ClearForceFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_Image_CustomPalette PROC

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  : 	return image.custom_palette;

	mov	eax, DWORD PTR _image+96

; 193  : }

	pop	ebp
	ret	0
_Image_CustomPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_Image_SetForceFlags PROC

; 217  : {

	push	ebp
	mov	ebp, esp

; 218  : 	SetBits( image.force_flags, flags );

	mov	eax, DWORD PTR _image+92
	or	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _image+92, eax

; 219  : }

	pop	ebp
	ret	0
_Image_SetForceFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv67 = -528						; size = 4
tv66 = -524						; size = 4
_i$ = -520						; size = 4
_src$ = -516						; size = 256
_dst$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_palSrc$ = 8						; size = 4
_top$ = 12						; size = 4
_bottom$ = 16						; size = 4
_pal_size$ = 20						; size = 4
_Image_PaletteTranslate PROC

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 523  : 	byte	dst[256], src[256];
; 524  : 	int	i;
; 525  : 
; 526  : 	pal_size = bound( 3, pal_size, 4 );

	cmp	DWORD PTR _pal_size$[ebp], 3
	jl	SHORT $LN21@Image_Pale
	cmp	DWORD PTR _pal_size$[ebp], 4
	jge	SHORT $LN19@Image_Pale
	mov	eax, DWORD PTR _pal_size$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN20@Image_Pale
$LN19@Image_Pale:
	mov	DWORD PTR tv66[ebp], 4
$LN20@Image_Pale:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN22@Image_Pale
$LN21@Image_Pale:
	mov	DWORD PTR tv67[ebp], 3
$LN22@Image_Pale:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _pal_size$[ebp], edx

; 527  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Pale
$LN2@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Image_Pale

; 528  : 		src[i] = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR _src$[ebp+ecx], dl
	jmp	SHORT $LN2@Image_Pale
$LN3@Image_Pale:

; 529  : 	memcpy( dst, src, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _src$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 530  : 
; 531  : 	if( top < 128 )

	cmp	DWORD PTR _top$[ebp], 128		; 00000080H
	jge	SHORT $LN14@Image_Pale

; 532  : 	{
; 533  : 		// the artists made some backwards ranges. sigh.
; 534  : 		memcpy( dst + SHIRT_HUE_START, src + top, 16 );

	push	16					; 00000010H
	mov	edx, DWORD PTR _top$[ebp]
	lea	eax, DWORD PTR _src$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _dst$[ebp+16]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 535  : 	}

	jmp	SHORT $LN15@Image_Pale
$LN14@Image_Pale:

; 536  : 	else
; 537  : 	{
; 538  : 		for( i = 0; i < 16; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Pale
$LN5@Image_Pale:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN15@Image_Pale

; 539  : 			dst[SHIRT_HUE_START+i] = src[top + 15 - i];

	mov	eax, DWORD PTR _top$[ebp]
	add	eax, 15					; 0000000fH
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _src$[ebp+eax]
	mov	BYTE PTR _dst$[ebp+ecx+16], dl
	jmp	SHORT $LN5@Image_Pale
$LN15@Image_Pale:

; 540  : 	}
; 541  : 
; 542  : 	if( bottom < 128 )

	cmp	DWORD PTR _bottom$[ebp], 128		; 00000080H
	jge	SHORT $LN16@Image_Pale

; 543  : 	{
; 544  : 		memcpy( dst + PANTS_HUE_START, src + bottom, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _bottom$[ebp]
	lea	ecx, DWORD PTR _src$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _dst$[ebp+96]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 545  : 	}

	jmp	SHORT $LN17@Image_Pale
$LN16@Image_Pale:

; 546  : 	else
; 547  : 	{
; 548  : 		for( i = 0; i < 16; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Image_Pale
$LN8@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN17@Image_Pale

; 549  : 			dst[PANTS_HUE_START + i] = src[bottom + 15 - i];

	mov	ecx, DWORD PTR _bottom$[ebp]
	add	ecx, 15					; 0000000fH
	sub	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _src$[ebp+ecx]
	mov	BYTE PTR _dst$[ebp+edx+96], al
	jmp	SHORT $LN8@Image_Pale
$LN17@Image_Pale:

; 550  : 	}
; 551  : 
; 552  : 	// last color isn't changed
; 553  : 	for( i = 0; i < 255; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Pale
$LN11@Image_Pale:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 255			; 000000ffH
	jge	SHORT $LN1@Image_Pale

; 554  : 	{
; 555  : 		palSrc[i*pal_size+0] = palette_q1[dst[i]*3+0];

	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _dst$[ebp+edx]
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, DWORD PTR _pal_size$[ebp]
	mov	eax, DWORD PTR _palSrc$[ebp]
	mov	cl, BYTE PTR _palette_q1[ecx]
	mov	BYTE PTR [eax+edx], cl

; 556  : 		palSrc[i*pal_size+1] = palette_q1[dst[i]*3+1];

	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _dst$[ebp+edx]
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, DWORD PTR _pal_size$[ebp]
	mov	eax, DWORD PTR _palSrc$[ebp]
	mov	cl, BYTE PTR _palette_q1[ecx+1]
	mov	BYTE PTR [eax+edx+1], cl

; 557  : 		palSrc[i*pal_size+2] = palette_q1[dst[i]*3+2];

	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _dst$[ebp+edx]
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, DWORD PTR _pal_size$[ebp]
	mov	eax, DWORD PTR _palSrc$[ebp]
	mov	cl, BYTE PTR _palette_q1[ecx+2]
	mov	BYTE PTR [eax+edx+2], cl

; 558  : 	}

	jmp	$LN11@Image_Pale
$LN1@Image_Pale:

; 559  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_PaletteTranslate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_sat$ = -68						; size = 4
tv135 = -64						; size = 4
tv134 = -60						; size = 4
tv131 = -56						; size = 4
tv128 = -52						; size = 4
tv95 = -48						; size = 4
tv92 = -44						; size = 4
tv70 = -40						; size = 4
tv69 = -36						; size = 4
_maxcol$ = -32						; size = 4
_i$ = -28						; size = 4
_b$ = -24						; size = 4
_val$ = -20						; size = 4
_g$ = -16						; size = 4
_r$ = -12						; size = 4
_mincol$ = -8						; size = 4
_hue$ = -4						; size = 4
_palSrc$ = 8						; size = 4
_newHue$ = 12						; size = 4
_start$ = 16						; size = 4
_end$ = 20						; size = 4
_pal_size$ = 24						; size = 4
_Image_PaletteHueReplace PROC

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 448  : 	float	r, g, b;
; 449  : 	float	maxcol, mincol;
; 450  : 	float	hue, val, sat;
; 451  : 	int	i;
; 452  : 
; 453  : 	hue = (float)(newHue * ( 360.0f / 255 ));

	cvtsi2ss xmm0, DWORD PTR _newHue$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb4b4b5
	movss	DWORD PTR _hue$[ebp], xmm0

; 454  : 	pal_size = bound( 3, pal_size, 4 );

	cmp	DWORD PTR _pal_size$[ebp], 3
	jl	SHORT $LN19@Image_Pale
	cmp	DWORD PTR _pal_size$[ebp], 4
	jge	SHORT $LN17@Image_Pale
	mov	eax, DWORD PTR _pal_size$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN18@Image_Pale
$LN17@Image_Pale:
	mov	DWORD PTR tv69[ebp], 4
$LN18@Image_Pale:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN20@Image_Pale
$LN19@Image_Pale:
	mov	DWORD PTR tv70[ebp], 3
$LN20@Image_Pale:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _pal_size$[ebp], edx

; 455  : 
; 456  : 	for( i = start; i <= end; i++ )

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Image_Pale
$LN2@Image_Pale:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Image_Pale:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	jg	$LN3@Image_Pale

; 457  : 	{
; 458  : 		r = palSrc[i*pal_size+0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _r$[ebp], xmm0

; 459  : 		g = palSrc[i*pal_size+1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _g$[ebp], xmm0

; 460  : 		b = palSrc[i*pal_size+2];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+2]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _b$[ebp], xmm0

; 461  : 		
; 462  : 		maxcol = max( max( r, g ), b ) / 255.0f;

	movss	xmm0, DWORD PTR _r$[ebp]
	comiss	xmm0, DWORD PTR _g$[ebp]
	jbe	SHORT $LN21@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN22@Image_Pale
$LN21@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
$LN22@Image_Pale:
	movss	xmm0, DWORD PTR tv92[ebp]
	comiss	xmm0, DWORD PTR _b$[ebp]
	jbe	SHORT $LN25@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	comiss	xmm0, DWORD PTR _g$[ebp]
	jbe	SHORT $LN23@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN24@Image_Pale
$LN23@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
$LN24@Image_Pale:
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN26@Image_Pale
$LN25@Image_Pale:
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
$LN26@Image_Pale:
	movss	xmm0, DWORD PTR tv128[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _maxcol$[ebp], xmm0

; 463  : 		mincol = min( min( r, g ), b ) / 255.0f;

	movss	xmm0, DWORD PTR _g$[ebp]
	comiss	xmm0, DWORD PTR _r$[ebp]
	jbe	SHORT $LN27@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN28@Image_Pale
$LN27@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
$LN28@Image_Pale:
	movss	xmm0, DWORD PTR _b$[ebp]
	comiss	xmm0, DWORD PTR tv131[ebp]
	jbe	SHORT $LN31@Image_Pale
	movss	xmm0, DWORD PTR _g$[ebp]
	comiss	xmm0, DWORD PTR _r$[ebp]
	jbe	SHORT $LN29@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN30@Image_Pale
$LN29@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
$LN30@Image_Pale:
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN32@Image_Pale
$LN31@Image_Pale:
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
$LN32@Image_Pale:
	movss	xmm0, DWORD PTR tv135[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _mincol$[ebp], xmm0

; 464  : 
; 465  : 		if( maxcol == 0 ) continue;

	movss	xmm0, DWORD PTR _maxcol$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Image_Pale
	jmp	$LN2@Image_Pale
$LN5@Image_Pale:

; 466  : 		
; 467  : 		val = maxcol;

	movss	xmm0, DWORD PTR _maxcol$[ebp]
	movss	DWORD PTR _val$[ebp], xmm0

; 468  : 		sat = (maxcol - mincol) / maxcol;

	movss	xmm0, DWORD PTR _maxcol$[ebp]
	subss	xmm0, DWORD PTR _mincol$[ebp]
	divss	xmm0, DWORD PTR _maxcol$[ebp]
	movss	DWORD PTR _sat$[ebp], xmm0

; 469  : 
; 470  : 		mincol = val * (1.0f - sat);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _sat$[ebp]
	mulss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _mincol$[ebp], xmm0

; 471  : 
; 472  : 		if( hue <= 120.0f )

	movss	xmm0, DWORD PTR __real@42f00000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jb	$LN6@Image_Pale

; 473  : 		{
; 474  : 			b = mincol;

	movss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 475  : 			if( hue < 60 )

	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jbe	SHORT $LN8@Image_Pale

; 476  : 			{
; 477  : 				r = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 478  : 				g = mincol + hue * (val - mincol) / (120.0f - hue);

	movss	xmm0, DWORD PTR _val$[ebp]
	subss	xmm0, DWORD PTR _mincol$[ebp]
	mulss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR __real@42f00000
	subss	xmm1, DWORD PTR _hue$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 479  : 			}

	jmp	SHORT $LN9@Image_Pale
$LN8@Image_Pale:

; 480  : 			else
; 481  : 			{
; 482  : 				g = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 483  : 				r = mincol + (120.0f - hue) * (val - mincol) / hue;

	movss	xmm0, DWORD PTR __real@42f00000
	subss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	divss	xmm0, DWORD PTR _hue$[ebp]
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0
$LN9@Image_Pale:

; 484  : 			}
; 485  : 		}

	jmp	$LN15@Image_Pale
$LN6@Image_Pale:

; 486  : 		else if( hue <= 240.0f )

	movss	xmm0, DWORD PTR __real@43700000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jb	$LN10@Image_Pale

; 487  : 		{
; 488  : 			r = mincol;

	movss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 489  : 			if( hue < 180.0f )

	movss	xmm0, DWORD PTR __real@43340000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jbe	SHORT $LN12@Image_Pale

; 490  : 			{
; 491  : 				g = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 492  : 				b = mincol + (hue - 120.0f) * (val - mincol) / (240.0f - hue);

	movss	xmm0, DWORD PTR _hue$[ebp]
	subss	xmm0, DWORD PTR __real@42f00000
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@43700000
	subss	xmm1, DWORD PTR _hue$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 493  : 			}

	jmp	SHORT $LN13@Image_Pale
$LN12@Image_Pale:

; 494  : 			else
; 495  : 			{
; 496  : 				b = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 497  : 				g = mincol + (240.0f - hue) * (val - mincol) / (hue - 120.0f);

	movss	xmm0, DWORD PTR __real@43700000
	subss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _hue$[ebp]
	subss	xmm1, DWORD PTR __real@42f00000
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0
$LN13@Image_Pale:

; 498  : 			}
; 499  : 		}

	jmp	$LN15@Image_Pale
$LN10@Image_Pale:

; 500  : 		else
; 501  : 		{
; 502  : 			g = mincol;

	movss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 503  : 			if( hue < 300.0f )

	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jbe	SHORT $LN14@Image_Pale

; 504  : 			{
; 505  : 				b = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 506  : 				r = mincol + (hue - 240.0f) * (val - mincol) / (360.0f - hue);

	movss	xmm0, DWORD PTR _hue$[ebp]
	subss	xmm0, DWORD PTR __real@43700000
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@43b40000
	subss	xmm1, DWORD PTR _hue$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 507  : 			}

	jmp	SHORT $LN15@Image_Pale
$LN14@Image_Pale:

; 508  : 			else
; 509  : 			{
; 510  : 				r = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 511  : 				b = mincol + (360.0f - hue) * (val - mincol) / (hue - 240.0f);

	movss	xmm0, DWORD PTR __real@43b40000
	subss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _hue$[ebp]
	subss	xmm1, DWORD PTR __real@43700000
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0
$LN15@Image_Pale:

; 512  : 			}
; 513  : 		}
; 514  : 
; 515  : 		palSrc[i*pal_size+0] = (byte)(r * 255);

	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pal_size$[ebp]
	mov	edx, DWORD PTR _palSrc$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 516  : 		palSrc[i*pal_size+1] = (byte)(g * 255);

	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pal_size$[ebp]
	mov	edx, DWORD PTR _palSrc$[ebp]
	mov	BYTE PTR [edx+ecx+1], al

; 517  : 		palSrc[i*pal_size+2] = (byte)(b * 255);

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pal_size$[ebp]
	mov	edx, DWORD PTR _palSrc$[ebp]
	mov	BYTE PTR [edx+ecx+2], al

; 518  : 	}

	jmp	$LN2@Image_Pale
$LN3@Image_Pale:

; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_PaletteHueReplace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_result$ = -40						; size = 4
_resampled$1 = -36					; size = 4
tv174 = -32						; size = 4
tv173 = -28						; size = 4
tv170 = -24						; size = 4
tv169 = -20						; size = 4
_h$2 = -16						; size = 4
_w$3 = -12						; size = 4
_out$ = -8						; size = 4
_pic$ = -4						; size = 4
_pix$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_flags$ = 20						; size = 4
_bumpscale$ = 24					; size = 4
_Image_Process PROC

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1467 : 	rgbdata_t	*pic = *pix;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pic$[ebp], ecx

; 1468 : 	qboolean	result = true;

	mov	DWORD PTR _result$[ebp], 1

; 1469 : 	byte	*out;
; 1470 : 				
; 1471 : 	// check for buffers
; 1472 : 	if( !pic || !pic->buffer )

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN3@Image_Proc
	mov	edx, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN2@Image_Proc
$LN3@Image_Proc:

; 1473 : 	{
; 1474 : 		image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 1475 : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Proc
$LN2@Image_Proc:

; 1476 : 	}
; 1477 : 
; 1478 : 	if( !flags )

	cmp	DWORD PTR _flags$[ebp], 0
	jne	SHORT $LN4@Image_Proc

; 1479 : 	{
; 1480 : 		// clear any force flags
; 1481 : 		image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 1482 : 		return false; // no operation specfied

	xor	eax, eax
	jmp	$LN1@Image_Proc
$LN4@Image_Proc:

; 1483 : 	}
; 1484 : 
; 1485 : 	if( FBitSet( flags, IMAGE_MAKE_LUMA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN5@Image_Proc

; 1486 : 	{
; 1487 : 		out = Image_CreateLumaInternal( pic->buffer, pic->width, pic->height, pic->type, pic->flags );

	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_Image_CreateLumaInternal
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 1488 : 		if( pic->buffer != out ) memcpy( pic->buffer, image.tempbuffer, pic->size );

	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _out$[ebp]
	je	SHORT $LN6@Image_Proc
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN6@Image_Proc:

; 1489 : 		ClearBits( pic->flags, IMAGE_HAS_LUMA );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN5@Image_Proc:

; 1490 : 	}
; 1491 : 
; 1492 : 	if( FBitSet( flags, IMAGE_REMAP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 134217728				; 08000000H
	je	SHORT $LN8@Image_Proc

; 1493 : 	{
; 1494 : 		// NOTE: user should keep copy of indexed image manually for new changes
; 1495 : 		if( Image_RemapInternal( pic, width, height ))

	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_RemapInternal
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@Image_Proc

; 1496 : 			pic = Image_DecompressInternal( pic );

	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	call	_Image_DecompressInternal
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN8@Image_Proc:

; 1497 : 	}
; 1498 : 
; 1499 : 	// update format to RGBA if any
; 1500 : 	if( FBitSet( flags, IMAGE_FORCE_RGBA ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8388608				; 00800000H
	je	SHORT $LN9@Image_Proc

; 1501 : 		pic = Image_DecompressInternal( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_DecompressInternal
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN9@Image_Proc:

; 1502 : 
; 1503 : 	if( FBitSet( flags, IMAGE_LIGHTGAMMA ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 67108864				; 04000000H
	je	SHORT $LN10@Image_Proc

; 1504 : 		pic = Image_LightGamma( pic );

	mov	edx, DWORD PTR _pic$[ebp]
	push	edx
	call	_Image_LightGamma
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN10@Image_Proc:

; 1505 : 
; 1506 : 	if( FBitSet( flags, IMAGE_EMBOSS ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 524288				; 00080000H
	je	SHORT $LN11@Image_Proc

; 1507 : 		Image_ApplyFilter( pic, bumpscale );

	push	ecx
	movss	xmm0, DWORD PTR _bumpscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	call	_Image_ApplyFilter
	add	esp, 8
$LN11@Image_Proc:

; 1508 : 
; 1509 : 	out = Image_FlipInternal( pic->buffer, &pic->width, &pic->height, pic->type, flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	add	edx, 2
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_Image_FlipInternal
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 1510 : 	if( pic->buffer != out ) memcpy( pic->buffer, image.tempbuffer, pic->size );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _out$[ebp]
	je	SHORT $LN12@Image_Proc
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN12@Image_Proc:

; 1511 : 
; 1512 : 	if( FBitSet( flags, IMAGE_RESAMPLE ) && width > 0 && height > 0 )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1048576				; 00100000H
	je	$LN15@Image_Proc
	cmp	DWORD PTR _width$[ebp], 0
	jle	$LN15@Image_Proc
	cmp	DWORD PTR _height$[ebp], 0
	jle	$LN15@Image_Proc

; 1513 : 	{
; 1514 : 		int	w = bound( 1, width, IMAGE_MAXWIDTH );	// 1 - 4096

	cmp	DWORD PTR _width$[ebp], 1
	jl	SHORT $LN20@Image_Proc
	cmp	DWORD PTR _width$[ebp], 8192		; 00002000H
	jge	SHORT $LN18@Image_Proc
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv169[ebp], edx
	jmp	SHORT $LN19@Image_Proc
$LN18@Image_Proc:
	mov	DWORD PTR tv169[ebp], 8192		; 00002000H
$LN19@Image_Proc:
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $LN21@Image_Proc
$LN20@Image_Proc:
	mov	DWORD PTR tv170[ebp], 1
$LN21@Image_Proc:
	mov	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _w$3[ebp], ecx

; 1515 : 		int	h = bound( 1, height, IMAGE_MAXHEIGHT);	// 1 - 4096

	cmp	DWORD PTR _height$[ebp], 1
	jl	SHORT $LN24@Image_Proc
	cmp	DWORD PTR _height$[ebp], 8192		; 00002000H
	jge	SHORT $LN22@Image_Proc
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv173[ebp], edx
	jmp	SHORT $LN23@Image_Proc
$LN22@Image_Proc:
	mov	DWORD PTR tv173[ebp], 8192		; 00002000H
$LN23@Image_Proc:
	mov	eax, DWORD PTR tv173[ebp]
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN25@Image_Proc
$LN24@Image_Proc:
	mov	DWORD PTR tv174[ebp], 1
$LN25@Image_Proc:
	mov	ecx, DWORD PTR tv174[ebp]
	mov	DWORD PTR _h$2[ebp], ecx

; 1516 : 		qboolean	resampled = false;

	mov	DWORD PTR _resampled$1[ebp], 0

; 1517 : 
; 1518 : 		out = Image_ResampleInternal((uint *)pic->buffer, pic->width, pic->height, w, h, pic->type, &resampled );

	lea	edx, DWORD PTR _resampled$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _h$2[ebp]
	push	edx
	mov	eax, DWORD PTR _w$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_Image_ResampleInternal
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 1519 : 
; 1520 : 		if( resampled ) // resampled or filled

	cmp	DWORD PTR _resampled$1[ebp], 0
	je	$LN14@Image_Proc

; 1521 : 		{
; 1522 : 			Con_Reportf( "Image_Resample: from[%d x %d] to [%d x %d]\n", pic->width, pic->height, w, h );

	mov	ecx, DWORD PTR _h$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET $SG138155
	call	_Con_Reportf
	add	esp, 20					; 00000014H

; 1523 : 			pic->width = w, pic->height = h;

	mov	ecx, DWORD PTR _pic$[ebp]
	mov	dx, WORD PTR _w$3[ebp]
	mov	WORD PTR [ecx], dx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	cx, WORD PTR _h$2[ebp]
	mov	WORD PTR [eax+2], cx

; 1524 : 			pic->size = w * h * PFDesc[pic->type].bpp;

	mov	edx, DWORD PTR _w$3[ebp]
	imul	edx, DWORD PTR _h$2[ebp]
	mov	eax, DWORD PTR _pic$[ebp]
	imul	ecx, DWORD PTR [eax+8], 28
	imul	edx, DWORD PTR _PFDesc[ecx+24]
	mov	eax, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [eax+32], edx

; 1525 : 			Mem_Free( pic->buffer );		// free original image buffer

	push	1525					; 000005f5H
	push	OFFSET $SG138156
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1526 : 			pic->buffer = Image_Copy( pic->size );	// unzone buffer (don't touch image.tempbuffer)

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_Image_Copy
	add	esp, 4
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1527 : 		}

	jmp	SHORT $LN15@Image_Proc
$LN14@Image_Proc:

; 1528 : 		else
; 1529 : 		{
; 1530 : 			// not a resampled or filled
; 1531 : 			result = false;

	mov	DWORD PTR _result$[ebp], 0
$LN15@Image_Proc:

; 1532 : 		}
; 1533 : 	}
; 1534 : 
; 1535 : 	// quantize image
; 1536 : 	if( FBitSet( flags, IMAGE_QUANTIZE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 33554432				; 02000000H
	je	SHORT $LN16@Image_Proc

; 1537 : 		pic = Image_Quantize( pic );

	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	call	_Image_Quantize
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN16@Image_Proc:

; 1538 : 
; 1539 : 	*pix = pic;

	mov	edx, DWORD PTR _pix$[ebp]
	mov	eax, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx], eax

; 1540 : 
; 1541 : 	// clear any force flags
; 1542 : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 1543 : 
; 1544 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@Image_Proc:

; 1545 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_Image_AddCmdFlags PROC

; 237  : {

	push	ebp
	mov	ebp, esp

; 238  : 	SetBits( image.cmd_flags, flags );

	mov	eax, DWORD PTR _image+88
	or	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _image+88, eax

; 239  : }

	pop	ebp
	ret	0
_Image_AddCmdFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
_Image_Shutdown PROC

; 170  : {

	push	ebp
	mov	ebp, esp

; 171  : 	Mem_Check(); // check for leaks

	push	171					; 000000abH
	push	OFFSET $SG137345
	call	__Mem_Check
	add	esp, 8

; 172  : 	Mem_FreePool( &host.imagepool );

	push	172					; 000000acH
	push	OFFSET $SG137346
	push	OFFSET _host+34740
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 173  : }

	pop	ebp
	ret	0
_Image_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\imagelib\img_utils.c
_TEXT	SEGMENT
tv68 = -4						; size = 4
_Image_Init PROC

; 142  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 143  : 	// init pools
; 144  : 	host.imagepool = Mem_AllocPool( "ImageLib Pool" );

	push	144					; 00000090H
	push	OFFSET $SG137338
	push	OFFSET $SG137339
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _host+34740, eax

; 145  : 
; 146  : 	// install image formats (can be re-install later by Image_Setup)
; 147  : 	switch( host.type )

	mov	eax, DWORD PTR _host+164
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN4@Image_Init
	cmp	DWORD PTR tv68[ebp], 1
	je	SHORT $LN5@Image_Init
	jmp	SHORT $LN6@Image_Init
$LN4@Image_Init:

; 148  : 	{
; 149  : 	case HOST_NORMAL:
; 150  : 		image.cmd_flags = IL_USE_LERPING|IL_ALLOW_OVERWRITE;		

	mov	DWORD PTR _image+88, 5

; 151  : 		image.loadformats = load_game;

	mov	DWORD PTR _image, OFFSET _load_game

; 152  : 		image.saveformats = save_game;

	mov	DWORD PTR _image+4, OFFSET _save_game

; 153  : 		break;

	jmp	SHORT $LN2@Image_Init
$LN5@Image_Init:

; 154  : 	case HOST_DEDICATED:
; 155  : 		image.cmd_flags = 0;

	mov	DWORD PTR _image+88, 0

; 156  : 		image.loadformats = load_game;

	mov	DWORD PTR _image, OFFSET _load_game

; 157  : 		image.saveformats = save_null;

	mov	DWORD PTR _image+4, OFFSET _save_null

; 158  : 		break;

	jmp	SHORT $LN2@Image_Init
$LN6@Image_Init:

; 159  : 	default:	// all other instances not using imagelib
; 160  : 		image.cmd_flags = 0;

	mov	DWORD PTR _image+88, 0

; 161  : 		image.loadformats = load_null;

	mov	DWORD PTR _image, OFFSET _load_null

; 162  : 		image.saveformats = save_null;

	mov	DWORD PTR _image+4, OFFSET _save_null
$LN2@Image_Init:

; 163  : 		break;
; 164  : 	}
; 165  : 
; 166  : 	image.tempbuffer = NULL;

	mov	DWORD PTR _image+84, 0

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Init ENDP
_TEXT	ENDS
END
