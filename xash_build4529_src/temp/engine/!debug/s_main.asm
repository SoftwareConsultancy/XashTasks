; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\s_main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_snd_ambient
PUBLIC	_snd_fade_sequence
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_ambient_sfx:DWORD:04H
_DATA	ENDS
_BSS	SEGMENT
_snd_ambient DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pglColor4usv:DWORD
COMM	_channels:BYTE:0c1c00H
COMM	_raw_channels:DWORD:010H
COMM	_total_channels:DWORD
COMM	_paintedtime:DWORD
COMM	_soundtime:DWORD
COMM	_s_listener:BYTE:0105cH
COMM	_dma:BYTE:010H
COMM	_pglColorMask:DWORD
COMM	_s_volume:DWORD
COMM	_s_musicvolume:DWORD
COMM	_s_show:DWORD
COMM	_s_mixahead:DWORD
COMM	_s_lerping:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_s_test:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_BSS	SEGMENT
_snd_fade_sequence DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_s_ambient_level:DWORD
COMM	_s_ambient_fade:DWORD
COMM	_s_combine_sounds:DWORD
COMM	_snd_foliage_db_loss:DWORD
COMM	_snd_gain:DWORD
COMM	_snd_gain_max:DWORD
COMM	_snd_gain_min:DWORD
COMM	_s_refdist:DWORD
COMM	_s_refdb:DWORD
COMM	_s_cull:DWORD
COMM	_s_phs:DWORD
COMM	_sndpool:DWORD
_DATA	ENDS
PUBLIC	_S_Init
PUBLIC	_S_Shutdown
PUBLIC	_S_StopSound
PUBLIC	_S_GetCurrentStaticSounds
PUBLIC	_S_StopAllSounds
PUBLIC	_S_GetMasterVolume
PUBLIC	_S_FreeChannel
PUBLIC	_S_SoundInfo_f
PUBLIC	_SND_PickDynamicChannel
PUBLIC	_SND_PickStaticChannel
PUBLIC	_S_GetCurrentDynamicSounds
PUBLIC	_S_FindRawChannel
PUBLIC	_S_RawSamples
PUBLIC	_S_UpdateFrame
PUBLIC	_S_GetRawSamplesLength
PUBLIC	_S_ClearRawChannel
PUBLIC	_S_StreamAviSamples
PUBLIC	_S_RestoreSound
PUBLIC	_S_StartSound
PUBLIC	_S_AmbientSound
PUBLIC	_S_FadeClientVolume
PUBLIC	_S_StartLocalSound
PUBLIC	_SND_UpdateSound
PUBLIC	_S_ExtraUpdate
PUBLIC	_dB_To_Gain
PUBLIC	_dB_To_Radius
PUBLIC	_S_IsClient
PUBLIC	_S_UpdateSoundFade
PUBLIC	_SND_ChannelOkToTrace
PUBLIC	_SND_ChannelTraceReset
PUBLIC	_SND_FStreamIsPlaying
PUBLIC	_S_AlterChannel
PUBLIC	_SND_FadeToNewGain
PUBLIC	_SND_GetGainObscured
PUBLIC	_SND_GetGain
PUBLIC	_SND_CheckPHS
PUBLIC	_S_SpatializeChannel
PUBLIC	_SND_Spatialize
PUBLIC	_S_InitAmbientChannels
PUBLIC	_S_UpdateAmbientSounds
PUBLIC	_S_ClearBuffer
PUBLIC	_S_UpdateChannels
PUBLIC	_S_Play_f
PUBLIC	_S_Play2_f
PUBLIC	_S_PlayVol_f
PUBLIC	_S_Say_f
PUBLIC	_S_SayReliable_f
PUBLIC	_S_Music_f
PUBLIC	_S_StopSound_f
PUBLIC	_S_SoundFade_f
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3cb9c278
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40d0000000000000
PUBLIC	__real@40e5888000000000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@41c00000
PUBLIC	__real@42700000
PUBLIC	__real@42a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@430c0000
PUBLIC	__real@43580000
PUBLIC	__real@43700000
PUBLIC	__real@437f0000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@472c4400
PUBLIC	__real@bf800000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c02ccccd
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	__imp__atof:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_CL_Active:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_AVI_GetAudioInfo:PROC
EXTRN	_AVI_GetAudioChunk:PROC
EXTRN	_AVI_TimeToSoundPosition:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_CL_IsInMenu:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Con_NXPrintf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_Cmd_Null_f:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_fabs:PROC
EXTRN	_log10:PROC
EXTRN	_pow:PROC
EXTRN	_sqrt:PROC
EXTRN	_SimpleSpline:PROC
EXTRN	_VectorNormalizeLength2:PROC
EXTRN	_VectorVectors:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_RemapVal:PROC
EXTRN	_ApproachVal:PROC
EXTRN	_VOX_LoadWord:PROC
EXTRN	_VOX_FreeWord:PROC
EXTRN	_SNDDMA_Init:PROC
EXTRN	_SNDDMA_GetSoundtime:PROC
EXTRN	_SNDDMA_Shutdown:PROC
EXTRN	_SNDDMA_BeginPainting:PROC
EXTRN	_SNDDMA_Submit:PROC
EXTRN	_S_InitScaletable:PROC
EXTRN	_S_LoadSound:PROC
EXTRN	_MIX_ClearAllPaintBuffers:PROC
EXTRN	_MIX_InitAllPaintbuffers:PROC
EXTRN	_MIX_FreeAllPaintbuffers:PROC
EXTRN	_MIX_PaintChannels:PROC
EXTRN	_S_TestSoundChar:PROC
EXTRN	_S_SkipSoundChar:PROC
EXTRN	_S_FindName:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_InitSounds:PROC
EXTRN	_SX_Init:PROC
EXTRN	_SX_Free:PROC
EXTRN	_DSP_ClearState:PROC
EXTRN	_S_SoundList_f:PROC
EXTRN	_S_GetSfxByHandle:PROC
EXTRN	_S_FreeSounds:PROC
EXTRN	_SND_InitMouth:PROC
EXTRN	_SND_CloseMouth:PROC
EXTRN	_S_StreamSoundTrack:PROC
EXTRN	_S_StreamBackgroundTrack:PROC
EXTRN	_S_PrintBackgroundTrackState:PROC
EXTRN	_S_FadeMusicVolume:PROC
EXTRN	_S_SetSampleStart:PROC
EXTRN	_VOX_Init:PROC
EXTRN	_VOX_Shutdown:PROC
EXTRN	_VOX_SetChanVol:PROC
EXTRN	_VOX_LoadSound:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_BoxVisible:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_CL_TraceLine:PROC
EXTRN	_CL_GetEntitySpatialization:PROC
EXTRN	_CL_GetMovieSpatialization:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtoui3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_idsp_room:DWORD
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_RI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_soundfade DB	018H DUP (?)
_trace_count DD	01H DUP (?)
_last_trace_chan DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c02ccccd
CONST	SEGMENT
__real@c02ccccd DD 0c02ccccdr			; -2.7
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@472c4400
CONST	SEGMENT
__real@472c4400 DD 0472c4400r			; 44100
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@43580000
CONST	SEGMENT
__real@43580000 DD 043580000r			; 216
CONST	ENDS
;	COMDAT __real@430c0000
CONST	SEGMENT
__real@430c0000 DD 0430c0000r			; 140
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e5888000000000
CONST	SEGMENT
__real@40e5888000000000 DQ 040e5888000000000r	; 44100
CONST	ENDS
;	COMDAT __real@40d0000000000000
CONST	SEGMENT
__real@40d0000000000000 DQ 040d0000000000000r	; 16384
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3cb9c278
CONST	SEGMENT
__real@3cb9c278 DD 03cb9c278r			; 0.0226757
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG144065 DB	'^1Error:^7 S_PickStaticChannel: no free channels', 0aH, 00H
	ORG $+2
$SG144294 DB	'sound/', 00H
	ORG $+1
$SG144295 DB	'^1Error:^7 dropped sound "%s%s"', 0aH, 00H
	ORG $+3
$SG144343 DB	'sound/', 00H
	ORG $+1
$SG144344 DB	'^1Error:^7 dropped sound "%s%s"', 0aH, 00H
	ORG $+3
$SG144429 DB	'*default', 00H
	ORG $+3
$SG144495 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_main.c', 00H
	ORG $+2
$SG144755 DB	'chan %i, pos (%.f %.f %.f) ent %i, lv%3i rv%3i %s', 0aH, 00H
	ORG $+1
$SG144640 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_main.c', 00H
	ORG $+2
$SG144762 DB	'room_type: %i ----(%i)---- painted: %i', 0aH, 00H
$SG144767 DB	'Usage: play <soundfile>', 0aH, 00H
	ORG $+3
$SG144680 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_main.c', 00H
	ORG $+2
$SG144775 DB	'Usage: play2 <soundfile>', 0aH, 00H
	ORG $+2
$SG144780 DB	'Usage: playvol <soundfile volume>', 0aH, 00H
	ORG $+1
$SG144785 DB	'Usage: speak <soundfile>', 0aH, 00H
	ORG $+2
$SG144790 DB	'Usage: spk <soundfile>', 0aH, 00H
$SG144811 DB	'mp3', 00H
$SG144813 DB	'wav', 00H
$SG144814 DB	'%s_intro', 00H
	ORG $+3
$SG144815 DB	'%s_main', 00H
$SG144816 DB	'media/%s.%s', 00H
$SG144817 DB	'media/%s.%s', 00H
$SG144821 DB	'media/%s.%s', 00H
$SG144826 DB	'Usage: music <musicfile> [loopfile]', 0aH, 00H
	ORG $+3
$SG144838 DB	'Audio: DirectSound', 0aH, 00H
$SG144839 DB	'%5d channel(s)', 0aH, 00H
$SG144840 DB	'%5d samples', 0aH, 00H
	ORG $+3
$SG144841 DB	'%5d bits/sample', 0aH, 00H
	ORG $+3
$SG144842 DB	'%5d bytes/sec', 0aH, 00H
	ORG $+1
$SG144843 DB	'%5d total_channels', 0aH, 00H
$SG144847 DB	'-nosound', 00H
	ORG $+3
$SG144848 DB	'Audio: Disabled', 0aH, 00H
	ORG $+3
$SG144849 DB	'sound volume', 00H
	ORG $+3
$SG144850 DB	'0.7', 00H
$SG144851 DB	'volume', 00H
	ORG $+1
$SG144852 DB	'background music volume', 00H
$SG144853 DB	'1.0', 00H
$SG144854 DB	'MP3Volume', 00H
	ORG $+2
$SG144855 DB	'how much sound to mix ahead of time', 00H
$SG144856 DB	'0.12', 00H
	ORG $+3
$SG144857 DB	'_snd_mixahead', 00H
	ORG $+2
$SG144858 DB	'show playing sounds', 00H
$SG144859 DB	'0', 00H
	ORG $+2
$SG144860 DB	's_show', 00H
	ORG $+1
$SG144861 DB	'apply interpolation to sound output', 00H
$SG144862 DB	'0', 00H
	ORG $+2
$SG144863 DB	's_lerping', 00H
	ORG $+2
$SG144864 DB	'volume of environment noises (water and wind)', 00H
	ORG $+2
$SG144865 DB	'0.3', 00H
$SG144866 DB	'ambient_level', 00H
	ORG $+2
$SG144867 DB	'rate of volume fading when client is moving', 00H
$SG144868 DB	'1000', 00H
	ORG $+3
$SG144869 DB	'ambient_fade', 00H
	ORG $+3
$SG144870 DB	'combine channels with same sounds', 00H
	ORG $+2
$SG144871 DB	'0', 00H
	ORG $+2
$SG144872 DB	's_combine_channels', 00H
	ORG $+1
$SG144873 DB	'foliage loss factor', 00H
$SG144874 DB	'4', 00H
	ORG $+2
$SG144875 DB	'snd_foliage_db_loss', 00H
$SG144876 DB	'gain maximal threshold', 00H
	ORG $+1
$SG144877 DB	'1', 00H
	ORG $+2
$SG144878 DB	'snd_gain_max', 00H
	ORG $+3
$SG144879 DB	'gain minimal threshold', 00H
	ORG $+1
$SG144880 DB	'0.01', 00H
	ORG $+3
$SG144881 DB	'snd_gain_min', 00H
	ORG $+3
$SG144882 DB	'soundlevel reference distance', 00H
	ORG $+2
$SG144883 DB	'36', 00H
	ORG $+1
$SG144884 DB	's_refdist', 00H
	ORG $+2
$SG144885 DB	'soundlevel refernce dB', 00H
	ORG $+1
$SG144886 DB	'60', 00H
	ORG $+1
$SG144887 DB	's_refdb', 00H
$SG144888 DB	'sound default gain', 00H
	ORG $+1
$SG144889 DB	'1', 00H
	ORG $+2
$SG144890 DB	'snd_gain', 00H
	ORG $+3
$SG144891 DB	'cull sounds by geometry', 00H
$SG144892 DB	'0', 00H
	ORG $+2
$SG144893 DB	's_cull', 00H
	ORG $+1
$SG144894 DB	'engine developer cvar for quick testing new features', 00H
	ORG $+3
$SG144895 DB	'0', 00H
	ORG $+2
$SG144896 DB	's_test', 00H
	ORG $+1
$SG144897 DB	'cull sounds by PHS', 00H
	ORG $+1
$SG144898 DB	'0', 00H
	ORG $+2
$SG144899 DB	's_phs', 00H
	ORG $+2
$SG144900 DB	'playing a specified sound file', 00H
	ORG $+1
$SG144901 DB	'play', 00H
	ORG $+3
$SG144902 DB	'playing a group of specified sound files', 00H
	ORG $+3
$SG144903 DB	'play2', 00H
	ORG $+2
$SG144904 DB	'playing a specified sound file with specified volume', 00H
	ORG $+3
$SG144905 DB	'playvol', 00H
$SG144906 DB	'stop all sounds', 00H
$SG144907 DB	'stopsound', 00H
	ORG $+2
$SG144908 DB	'starting a background track', 00H
$SG144909 DB	'music', 00H
	ORG $+2
$SG144910 DB	'display loaded sounds', 00H
	ORG $+2
$SG144911 DB	'soundlist', 00H
	ORG $+2
$SG144912 DB	'print sound system information', 00H
	ORG $+1
$SG144913 DB	's_info', 00H
	ORG $+1
$SG144914 DB	'fade all sounds then stop all', 00H
	ORG $+2
$SG144915 DB	's_fade', 00H
	ORG $+1
$SG144916 DB	'start voice recording (non-implemented)', 00H
$SG144917 DB	'+voicerecord', 00H
	ORG $+3
$SG144918 DB	'stop voice recording (non-implemented)', 00H
	ORG $+1
$SG144919 DB	'-voicerecord', 00H
	ORG $+3
$SG144920 DB	'reliable play a specified sententce', 00H
$SG144921 DB	'spk', 00H
$SG144922 DB	'playing a specified sententce', 00H
	ORG $+2
$SG144923 DB	'speak', 00H
	ORG $+2
$SG144925 DB	'Audio: sound system can''t be initialized', 0aH, 00H
	ORG $+2
$SG144926 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_main.c', 00H
	ORG $+2
$SG144927 DB	'Sound Zone', 00H
	ORG $+1
$SG144931 DB	'play', 00H
	ORG $+3
$SG144932 DB	'playvol', 00H
$SG144933 DB	'stopsound', 00H
	ORG $+2
$SG144934 DB	'music', 00H
	ORG $+2
$SG144935 DB	'soundlist', 00H
	ORG $+2
$SG144936 DB	's_info', 00H
	ORG $+1
$SG144937 DB	's_fade', 00H
	ORG $+1
$SG144938 DB	'+voicerecord', 00H
	ORG $+3
$SG144939 DB	'-voicerecord', 00H
	ORG $+3
$SG144940 DB	'speak', 00H
	ORG $+2
$SG144941 DB	'spk', 00H
	ORG $+4
$SG144942 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_main.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv138 = -40						; size = 8
tv132 = -32						; size = 8
tv84 = -24						; size = 8
tv83 = -16						; size = 8
_c$ = -8						; size = 4
_fadeTime$ = -4						; size = 4
_S_SoundFade_f PROC

; 2234 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 2235 : 	int	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 2236 : 	float	fadeTime = 5.0f;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _fadeTime$[ebp], xmm0

; 2237 : 
; 2238 : 	if( c == 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jne	$LN2@S_SoundFad

; 2239 : 		fadeTime = bound( 1.0f, atof( Cmd_Argv( 1 )), 60.0f );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	fstp	QWORD PTR tv132[ebp]
	movsd	xmm0, QWORD PTR tv132[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN6@S_SoundFad
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	fstp	QWORD PTR tv138[ebp]
	movsd	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm0, QWORD PTR tv138[ebp]
	jbe	SHORT $LN4@S_SoundFad
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	fstp	QWORD PTR tv83[ebp]
	jmp	SHORT $LN5@S_SoundFad
$LN4@S_SoundFad:
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv83[ebp], xmm0
$LN5@S_SoundFad:
	movsd	xmm0, QWORD PTR tv83[ebp]
	movsd	QWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN7@S_SoundFad
$LN6@S_SoundFad:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv84[ebp], xmm0
$LN7@S_SoundFad:
	cvtsd2ss xmm0, QWORD PTR tv84[ebp]
	movss	DWORD PTR _fadeTime$[ebp], xmm0
$LN2@S_SoundFad:

; 2240 : 
; 2241 : 	S_FadeClientVolume( 100.0f, fadeTime, 1.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fadeTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	call	_S_FadeClientVolume
	add	esp, 16					; 00000010H

; 2242 : 	snd_fade_sequence = true;

	mov	DWORD PTR _snd_fade_sequence, 1

; 2243 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_SoundFade_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_StopSound_f PROC

; 2224 : {

	push	ebp
	mov	ebp, esp

; 2225 : 	S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 2226 : }

	pop	ebp
	ret	0
_S_StopSound_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_main_path$1 = -796					; size = 4
_intro_path$2 = -792					; size = 4
_ext$3 = -788						; size = 8
_c$ = -780						; size = 4
_i$4 = -776						; size = 4
_track$5 = -772						; size = 256
_intro$6 = -516						; size = 256
_main$7 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_S_Music_f PROC

; 2167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 796				; 0000031cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2168 : 	int	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 2169 : 
; 2170 : 	// run background track
; 2171 : 	if( c == 1 )

	cmp	DWORD PTR _c$[ebp], 1
	jne	SHORT $LN5@S_Music_f

; 2172 : 	{
; 2173 : 		// blank name stopped last track
; 2174 : 		S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 2175 : 	}

	jmp	$LN1@S_Music_f
$LN5@S_Music_f:

; 2176 : 	else if( c == 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jne	$LN7@S_Music_f

; 2177 : 	{
; 2178 : 		string	intro, main, track;
; 2179 : 		char	*ext[] = { "mp3", "wav" };

	mov	DWORD PTR _ext$3[ebp], OFFSET $SG144811
	mov	DWORD PTR _ext$3[ebp+4], OFFSET $SG144813

; 2180 : 		int	i;
; 2181 : 
; 2182 : 		Q_strncpy( track, Cmd_Argv( 1 ), sizeof( track ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _track$5[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2183 : 		Q_snprintf( intro, sizeof( intro ), "%s_intro", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG144814
	push	256					; 00000100H
	lea	ecx, DWORD PTR _intro$6[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2184 : 		Q_snprintf( main, sizeof( main ), "%s_main", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG144815
	push	256					; 00000100H
	lea	edx, DWORD PTR _main$7[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2185 : 
; 2186 : 		for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@S_Music_f
$LN2@S_Music_f:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN4@S_Music_f:
	cmp	DWORD PTR _i$4[ebp], 2
	jge	$LN3@S_Music_f

; 2187 : 		{
; 2188 : 			const char *intro_path = va( "media/%s.%s", intro, ext[i] );

	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _ext$3[ebp+ecx*4]
	push	edx
	lea	eax, DWORD PTR _intro$6[ebp]
	push	eax
	push	OFFSET $SG144816
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _intro_path$2[ebp], eax

; 2189 : 			const char *main_path = va( "media/%s.%s", main, ext[i] );

	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _ext$3[ebp+ecx*4]
	push	edx
	lea	eax, DWORD PTR _main$7[ebp]
	push	eax
	push	OFFSET $SG144817
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _main_path$1[ebp], eax

; 2190 : 
; 2191 : 			if( FS_FileExists( intro_path, false ) && FS_FileExists( main_path, false ))

	push	0
	mov	ecx, DWORD PTR _intro_path$2[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@S_Music_f
	push	0
	mov	edx, DWORD PTR _main_path$1[ebp]
	push	edx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@S_Music_f

; 2192 : 			{
; 2193 : 				// combined track with introduction and main loop theme
; 2194 : 				S_StartBackgroundTrack( intro, main, 0, false );

	push	0
	push	0
	lea	eax, DWORD PTR _main$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _intro$6[ebp]
	push	ecx
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H

; 2195 : 				break;

	jmp	SHORT $LN3@S_Music_f

; 2196 : 			}

	jmp	SHORT $LN10@S_Music_f
$LN9@S_Music_f:

; 2197 : 			else if( FS_FileExists( va( "media/%s.%s", track, ext[i] ), false ))

	push	0
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _ext$3[ebp+edx*4]
	push	eax
	lea	ecx, DWORD PTR _track$5[ebp]
	push	ecx
	push	OFFSET $SG144821
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@S_Music_f

; 2198 : 			{
; 2199 : 				// single non-looped theme
; 2200 : 				S_StartBackgroundTrack( track, NULL, 0, false );

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _track$5[ebp]
	push	edx
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H

; 2201 : 				break;

	jmp	SHORT $LN3@S_Music_f
$LN10@S_Music_f:

; 2202 : 			}
; 2203 : 		}

	jmp	$LN2@S_Music_f
$LN3@S_Music_f:

; 2204 : 
; 2205 : 	}

	jmp	$LN1@S_Music_f
$LN7@S_Music_f:

; 2206 : 	else if( c == 3 )

	cmp	DWORD PTR _c$[ebp], 3
	jne	SHORT $LN12@S_Music_f

; 2207 : 	{
; 2208 : 		S_StartBackgroundTrack( Cmd_Argv( 1 ), Cmd_Argv( 2 ), 0, false );

	push	0
	push	0
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H

; 2209 : 	}

	jmp	SHORT $LN1@S_Music_f
$LN12@S_Music_f:

; 2210 : 	else if( c == 4 && Q_atoi( Cmd_Argv( 3 )) != 0 )

	cmp	DWORD PTR _c$[ebp], 4
	jne	SHORT $LN14@S_Music_f
	push	3
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@S_Music_f

; 2211 : 	{
; 2212 : 		// restore command for singleplayer: all arguments are valid
; 2213 : 		S_StartBackgroundTrack( Cmd_Argv( 1 ), Cmd_Argv( 2 ), Q_atoi( Cmd_Argv( 3 )), false );

	push	0
	push	3
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	push	eax
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H

; 2214 : 	}

	jmp	SHORT $LN1@S_Music_f
$LN14@S_Music_f:

; 2215 : 	else Con_Printf( S_USAGE "music <musicfile> [loopfile]\n" );

	push	OFFSET $SG144826
	call	_Con_Printf
	add	esp, 4
$LN1@S_Music_f:

; 2216 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Music_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_SayReliable_f PROC

; 2151 : {

	push	ebp
	mov	ebp, esp

; 2152 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_SayRelia

; 2153 : 	{
; 2154 : 		Con_Printf( S_USAGE "spk <soundfile>\n" );

	push	OFFSET $SG144790
	call	_Con_Printf
	add	esp, 4

; 2155 : 		return;

	jmp	SHORT $LN1@S_SayRelia
$LN2@S_SayRelia:

; 2156 : 	}
; 2157 : 
; 2158 : 	S_StartLocalSound( Cmd_Argv( 1 ), 1.0f, true );

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_SayRelia:

; 2159 : }

	pop	ebp
	ret	0
_S_SayReliable_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_Say_f PROC

; 2140 : {

	push	ebp
	mov	ebp, esp

; 2141 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_Say_f

; 2142 : 	{
; 2143 : 		Con_Printf( S_USAGE "speak <soundfile>\n" );

	push	OFFSET $SG144785
	call	_Con_Printf
	add	esp, 4

; 2144 : 		return;

	jmp	SHORT $LN1@S_Say_f
$LN2@S_Say_f:

; 2145 : 	}
; 2146 : 
; 2147 : 	S_StartLocalSound( Cmd_Argv( 1 ), 1.0f, false );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_Say_f:

; 2148 : }

	pop	ebp
	ret	0
_S_Say_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_PlayVol_f PROC

; 2129 : {

	push	ebp
	mov	ebp, esp

; 2130 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_PlayVol_

; 2131 : 	{
; 2132 : 		Con_Printf( S_USAGE "playvol <soundfile volume>\n" );

	push	OFFSET $SG144780
	call	_Con_Printf
	add	esp, 4

; 2133 : 		return;

	jmp	SHORT $LN1@S_PlayVol_
$LN2@S_PlayVol_:

; 2134 : 	}
; 2135 : 
; 2136 : 	S_StartLocalSound( Cmd_Argv( 1 ), Q_atof( Cmd_Argv( 2 )), false );

	push	0
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	fstp	DWORD PTR [esp]
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_PlayVol_:

; 2137 : }

	pop	ebp
	ret	0
_S_PlayVol_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_S_Play2_f PROC

; 2112 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2113 : 	int	i = 1;

	mov	DWORD PTR _i$[ebp], 1

; 2114 : 
; 2115 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN4@S_Play2_f

; 2116 : 	{
; 2117 : 		Con_Printf( S_USAGE "play2 <soundfile>\n" );

	push	OFFSET $SG144775
	call	_Con_Printf
	add	esp, 4

; 2118 : 		return;

	jmp	SHORT $LN3@S_Play2_f
$LN4@S_Play2_f:

; 2119 : 	}
; 2120 : 
; 2121 : 	while( i < Cmd_Argc( ))

	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@S_Play2_f

; 2122 : 	{
; 2123 : 		S_StartLocalSound( Cmd_Argv( i ), VOL_NORM, true );

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH

; 2124 : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 2125 : 	}

	jmp	SHORT $LN4@S_Play2_f
$LN3@S_Play2_f:

; 2126 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_Play2_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_Play_f PROC

; 2101 : {

	push	ebp
	mov	ebp, esp

; 2102 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_Play_f

; 2103 : 	{
; 2104 : 		Con_Printf( S_USAGE "play <soundfile>\n" );

	push	OFFSET $SG144767
	call	_Con_Printf
	add	esp, 4

; 2105 : 		return;

	jmp	SHORT $LN1@S_Play_f
$LN2@S_Play_f:

; 2106 : 	}
; 2107 : 
; 2108 : 	S_StartLocalSound( Cmd_Argv( 1 ), VOL_NORM, false );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_Play_f:

; 2109 : }

	pop	ebp
	ret	0
_S_Play_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_samps$ = -8						; size = 4
_endtime$ = -4						; size = 4
_S_UpdateChannels PROC

; 1902 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1903 : 	uint	endtime;
; 1904 : 	int	samps;
; 1905 : 
; 1906 : 	SNDDMA_BeginPainting();

	call	_SNDDMA_BeginPainting

; 1907 : 
; 1908 : 	if( !dma.buffer ) return;

	cmp	DWORD PTR _dma+8, 0
	jne	SHORT $LN2@S_UpdateCh
	jmp	$LN1@S_UpdateCh
$LN2@S_UpdateCh:

; 1909 : 
; 1910 : 	// updates DMA time
; 1911 : 	soundtime = SNDDMA_GetSoundtime();

	call	_SNDDMA_GetSoundtime
	mov	DWORD PTR _soundtime, eax

; 1912 : 
; 1913 : 	// soundtime - total samples that have been played out to hardware at dmaspeed
; 1914 : 	// paintedtime - total samples that have been mixed at speed
; 1915 : 	// endtime - target for samples in mixahead buffer at speed
; 1916 : 	endtime = soundtime + s_mixahead->value * SOUND_DMA_SPEED;

	cvtsi2ss xmm0, DWORD PTR _soundtime
	mov	eax, DWORD PTR _s_mixahead
	movss	xmm1, DWORD PTR [eax+12]
	mulss	xmm1, DWORD PTR __real@472c4400
	addss	xmm0, xmm1
	call	__ftoui3
	mov	DWORD PTR _endtime$[ebp], eax

; 1917 : 	samps = dma.samples >> 1;

	mov	ecx, DWORD PTR _dma
	sar	ecx, 1
	mov	DWORD PTR _samps$[ebp], ecx

; 1918 : 
; 1919 : 	if((int)(endtime - soundtime) > samps )

	mov	edx, DWORD PTR _endtime$[ebp]
	sub	edx, DWORD PTR _soundtime
	cmp	edx, DWORD PTR _samps$[ebp]
	jle	SHORT $LN3@S_UpdateCh

; 1920 : 		endtime = soundtime + samps;

	mov	eax, DWORD PTR _soundtime
	add	eax, DWORD PTR _samps$[ebp]
	mov	DWORD PTR _endtime$[ebp], eax
$LN3@S_UpdateCh:

; 1921 : 	
; 1922 : 	if(( endtime - paintedtime ) & 0x3 )

	mov	ecx, DWORD PTR _endtime$[ebp]
	sub	ecx, DWORD PTR _paintedtime
	and	ecx, 3
	je	SHORT $LN4@S_UpdateCh

; 1923 : 	{
; 1924 : 		// the difference between endtime and painted time should align on 
; 1925 : 		// boundaries of 4 samples. this is important when upsampling from 11khz -> 44khz.
; 1926 : 		endtime -= ( endtime - paintedtime ) & 0x3;

	mov	edx, DWORD PTR _endtime$[ebp]
	sub	edx, DWORD PTR _paintedtime
	and	edx, 3
	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, edx
	mov	DWORD PTR _endtime$[ebp], eax
$LN4@S_UpdateCh:

; 1927 : 	}
; 1928 : 
; 1929 : 	MIX_PaintChannels( endtime );

	mov	ecx, DWORD PTR _endtime$[ebp]
	push	ecx
	call	_MIX_PaintChannels
	add	esp, 4

; 1930 : 
; 1931 : 	SNDDMA_Submit();

	call	_SNDDMA_Submit
$LN1@S_UpdateCh:

; 1932 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_ClearBuffer PROC

; 1842 : {

	push	ebp
	mov	ebp, esp

; 1843 : 	S_ClearRawChannels();

	call	_S_ClearRawChannels

; 1844 : 
; 1845 : 	SNDDMA_BeginPainting ();

	call	_SNDDMA_BeginPainting

; 1846 : 	if( dma.buffer ) memset( dma.buffer, 0, dma.samples * 2 );

	cmp	DWORD PTR _dma+8, 0
	je	SHORT $LN2@S_ClearBuf
	mov	eax, DWORD PTR _dma
	shl	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _dma+8
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@S_ClearBuf:

; 1847 : 	SNDDMA_Submit ();

	call	_SNDDMA_Submit

; 1848 : 
; 1849 : 	MIX_ClearAllPaintBuffers( PAINTBUFFER_SIZE, true );

	push	1
	push	1024					; 00000400H
	call	_MIX_ClearAllPaintBuffers
	add	esp, 8

; 1850 : }

	pop	ebp
	ret	0
_S_ClearBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_S_FreeRawChannels PROC

; 1821 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1822 : 	int	i;
; 1823 : 
; 1824 : 	// free raw samples
; 1825 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_FreeRawC
$LN2@S_FreeRawC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_FreeRawC:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@S_FreeRawC

; 1826 : 	{
; 1827 : 		if( raw_channels[i] )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _raw_channels[ecx*4], 0
	je	SHORT $LN5@S_FreeRawC

; 1828 : 			Mem_Free( raw_channels[i] );

	push	1828					; 00000724H
	push	OFFSET $SG144680
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _raw_channels[edx*4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@S_FreeRawC:

; 1829 : 	}

	jmp	SHORT $LN2@S_FreeRawC
$LN3@S_FreeRawC:

; 1830 : 
; 1831 : 	memset( raw_channels, 0, sizeof( raw_channels ));

	push	64					; 00000040H
	push	0
	push	OFFSET _raw_channels
	call	_memset
	add	esp, 12					; 0000000cH

; 1832 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv145 = -44						; size = 4
_interval$1 = -40					; size = 4
_dist$2 = -36						; size = 4
_dot$3 = -32						; size = 4
_i$ = -28						; size = 4
_blend$4 = -24						; size = 4
_ch$5 = -20						; size = 4
_source_vec$6 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_S_SpatializeRawChannels PROC

; 1753 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1754 : 	int	i;
; 1755 : 	
; 1756 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Spatiali
$LN2@S_Spatiali:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Spatiali:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN3@S_Spatiali

; 1757 : 	{
; 1758 : 		rawchan_t	*ch = raw_channels[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _raw_channels[ecx*4]
	mov	DWORD PTR _ch$5[ebp], edx

; 1759 : 		vec3_t	source_vec;
; 1760 : 		float	dist, dot;
; 1761 : 
; 1762 : 		if( !ch ) continue;

	cmp	DWORD PTR _ch$5[ebp], 0
	jne	SHORT $LN5@S_Spatiali
	jmp	SHORT $LN2@S_Spatiali
$LN5@S_Spatiali:

; 1763 : 
; 1764 : 		if( ch->s_rawend < paintedtime )

	mov	eax, DWORD PTR _ch$5[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _paintedtime
	jae	SHORT $LN6@S_Spatiali

; 1765 : 		{
; 1766 : 			ch->leftvol = ch->rightvol = 0;

	mov	edx, DWORD PTR _ch$5[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR _ch$5[ebp]
	mov	DWORD PTR [eax+8], 0

; 1767 : 			continue;

	jmp	SHORT $LN2@S_Spatiali
$LN6@S_Spatiali:

; 1768 : 		}
; 1769 : 
; 1770 : 		// spatialization
; 1771 : 		if( !S_IsClient( ch->entnum ) && ch->dist_mult && ch->entnum >= 0 && ch->entnum < GI->max_edicts )

	mov	ecx, DWORD PTR _ch$5[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	jne	$LN7@S_Spatiali
	mov	eax, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN7@S_Spatiali
	mov	ecx, DWORD PTR _ch$5[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	$LN7@S_Spatiali
	mov	edx, DWORD PTR _ch$5[ebp]
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+1656]
	jge	$LN7@S_Spatiali

; 1772 : 		{
; 1773 : 			if( !CL_GetMovieSpatialization( ch ))

	mov	edx, DWORD PTR _ch$5[ebp]
	push	edx
	call	_CL_GetMovieSpatialization
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@S_Spatiali

; 1774 : 			{
; 1775 : 				// origin is null and entity not exist on client
; 1776 : 				ch->leftvol = ch->rightvol = 0;

	mov	eax, DWORD PTR _ch$5[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _ch$5[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1777 : 			}

	jmp	$LN10@S_Spatiali
$LN9@S_Spatiali:

; 1778 : 			else
; 1779 : 			{
; 1780 : 				VectorSubtract( ch->origin, s_listener.origin, source_vec );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+20]
	subss	xmm0, DWORD PTR _s_listener[edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _source_vec$6[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+20]
	subss	xmm0, DWORD PTR _s_listener[edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _source_vec$6[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+20]
	subss	xmm0, DWORD PTR _s_listener[eax]
	movss	DWORD PTR tv145[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR _source_vec$6[ebp+edx], xmm0

; 1781 : 
; 1782 : 				// normalize source_vec and get distance from listener to source
; 1783 : 				dist = VectorNormalizeLength( source_vec );

	lea	eax, DWORD PTR _source_vec$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _source_vec$6[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR _dist$2[ebp]

; 1784 : 				dot = DotProduct( s_listener.right, source_vec );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _s_listener[eax+36]
	mulss	xmm0, DWORD PTR _source_vec$6[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _s_listener[eax+36]
	mulss	xmm1, DWORD PTR _source_vec$6[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _s_listener[edx+36]
	mulss	xmm1, DWORD PTR _source_vec$6[ebp+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _dot$3[ebp], xmm0

; 1785 : 
; 1786 : 				// for sounds with a radius, spatialize left/right evenly within the radius
; 1787 : 				if( ch->radius > 0 && dist < ch->radius )

	mov	ecx, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@S_Spatiali
	mov	edx, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	comiss	xmm0, DWORD PTR _dist$2[ebp]
	jbe	SHORT $LN11@S_Spatiali

; 1788 : 				{
; 1789 : 					float	interval = ch->radius * 0.5f;

	mov	eax, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _interval$1[ebp], xmm0

; 1790 : 					float	blend = dist - interval;

	movss	xmm0, DWORD PTR _dist$2[ebp]
	subss	xmm0, DWORD PTR _interval$1[ebp]
	movss	DWORD PTR _blend$4[ebp], xmm0

; 1791 : 
; 1792 : 					if( blend < 0 ) blend = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _blend$4[ebp]
	jbe	SHORT $LN12@S_Spatiali
	xorps	xmm0, xmm0
	movss	DWORD PTR _blend$4[ebp], xmm0
$LN12@S_Spatiali:

; 1793 : 					blend /= interval;	

	movss	xmm0, DWORD PTR _blend$4[ebp]
	divss	xmm0, DWORD PTR _interval$1[ebp]
	movss	DWORD PTR _blend$4[ebp], xmm0

; 1794 : 
; 1795 : 					// blend is 0.0 - 1.0, from 50% radius -> 100% radius
; 1796 : 					// at radius * 0.5, dot is 0 (ie: sound centered left/right)
; 1797 : 					// at radius dot == dot
; 1798 : 					dot *= blend;

	movss	xmm0, DWORD PTR _dot$3[ebp]
	mulss	xmm0, DWORD PTR _blend$4[ebp]
	movss	DWORD PTR _dot$3[ebp], xmm0
$LN11@S_Spatiali:

; 1799 : 				}
; 1800 : 
; 1801 : 				// don't pan sounds with no attenuation
; 1802 : 				if( ch->dist_mult <= 0.0f ) dot = 0.0f;

	mov	ecx, DWORD PTR _ch$5[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+16]
	jb	SHORT $LN13@S_Spatiali
	xorps	xmm0, xmm0
	movss	DWORD PTR _dot$3[ebp], xmm0
$LN13@S_Spatiali:

; 1803 : 
; 1804 : 				// fill out channel volumes for single location
; 1805 : 				S_SpatializeChannel( &ch->leftvol, &ch->rightvol, ch->master_vol, 1.0f, dot, dist * ch->dist_mult );

	mov	edx, DWORD PTR _ch$5[ebp]
	movss	xmm0, DWORD PTR _dist$2[ebp]
	mulss	xmm0, DWORD PTR [edx+16]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dot$3[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$5[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ch$5[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _ch$5[ebp]
	add	eax, 8
	push	eax
	call	_S_SpatializeChannel
	add	esp, 24					; 00000018H
$LN10@S_Spatiali:

; 1806 : 			}
; 1807 : 		}

	jmp	SHORT $LN8@S_Spatiali
$LN7@S_Spatiali:

; 1808 : 		else
; 1809 : 		{
; 1810 : 			ch->leftvol = ch->rightvol = ch->master_vol;

	mov	ecx, DWORD PTR _ch$5[ebp]
	mov	edx, DWORD PTR _ch$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _ch$5[ebp]
	mov	edx, DWORD PTR _ch$5[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+8], eax
$LN8@S_Spatiali:

; 1811 : 		}
; 1812 : 	}

	jmp	$LN2@S_Spatiali
$LN3@S_Spatiali:

; 1813 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_SpatializeRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch$1 = -8						; size = 4
_i$ = -4						; size = 4
_S_ClearRawChannels PROC

; 1734 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1735 : 	int	i;
; 1736 : 
; 1737 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_ClearRaw
$LN2@S_ClearRaw:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_ClearRaw:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@S_ClearRaw

; 1738 : 	{
; 1739 : 		rawchan_t	*ch = raw_channels[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _raw_channels[ecx*4]
	mov	DWORD PTR _ch$1[ebp], edx

; 1740 : 
; 1741 : 		if( !ch ) continue;

	cmp	DWORD PTR _ch$1[ebp], 0
	jne	SHORT $LN5@S_ClearRaw
	jmp	SHORT $LN2@S_ClearRaw
$LN5@S_ClearRaw:

; 1742 : 		ch->s_rawend = 0;

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	DWORD PTR [eax+36], 0

; 1743 : 		ch->oldtime = -1;

	mov	ecx, DWORD PTR _ch$1[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+68], xmm0

; 1744 : 	}

	jmp	SHORT $LN2@S_ClearRaw
$LN3@S_ClearRaw:

; 1745 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_ClearRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch$1 = -8						; size = 4
_i$ = -4						; size = 4
_S_FreeIdleRawChannels PROC

; 1708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1709 : 	int	i;
; 1710 : 
; 1711 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_FreeIdle
$LN2@S_FreeIdle:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_FreeIdle:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN1@S_FreeIdle

; 1712 : 	{
; 1713 : 		rawchan_t	*ch = raw_channels[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _raw_channels[ecx*4]
	mov	DWORD PTR _ch$1[ebp], edx

; 1714 : 
; 1715 : 		if( !ch ) continue;

	cmp	DWORD PTR _ch$1[ebp], 0
	jne	SHORT $LN5@S_FreeIdle
	jmp	SHORT $LN2@S_FreeIdle
$LN5@S_FreeIdle:

; 1716 : 
; 1717 : 		if( ch->s_rawend >= paintedtime )

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _paintedtime
	jb	SHORT $LN6@S_FreeIdle

; 1718 : 			continue;

	jmp	SHORT $LN2@S_FreeIdle
$LN6@S_FreeIdle:

; 1719 : 
; 1720 : 		if(( paintedtime - ch->s_rawend ) / SOUND_DMA_SPEED >= S_RAW_SOUND_IDLE_SEC )

	mov	edx, DWORD PTR _ch$1[ebp]
	mov	eax, DWORD PTR _paintedtime
	sub	eax, DWORD PTR [edx+36]
	xor	edx, edx
	mov	ecx, 44100				; 0000ac44H
	div	ecx
	cmp	eax, 10					; 0000000aH
	jb	SHORT $LN7@S_FreeIdle

; 1721 : 		{
; 1722 : 			raw_channels[i] = NULL;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _raw_channels[edx*4], 0

; 1723 : 			Mem_Free( ch );

	push	1723					; 000006bbH
	push	OFFSET $SG144640
	mov	eax, DWORD PTR _ch$1[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@S_FreeIdle:

; 1724 : 		}
; 1725 : 	}

	jmp	SHORT $LN2@S_FreeIdle
$LN1@S_FreeIdle:

; 1726 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeIdleRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_samples$ = 12						; size = 4
_rate$ = 16						; size = 4
_width$ = 20						; size = 2
_channels$ = 24						; size = 2
_data$ = 28						; size = 4
_snd_vol$ = 32						; size = 4
_S_RawEntSamples PROC

; 1560 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1561 : 	rawchan_t	*ch;
; 1562 : 
; 1563 : 	if( snd_vol < 0 )

	cmp	DWORD PTR _snd_vol$[ebp], 0
	jge	SHORT $LN2@S_RawEntSa

; 1564 : 		snd_vol = 0;

	mov	DWORD PTR _snd_vol$[ebp], 0
$LN2@S_RawEntSa:

; 1565 : 
; 1566 : 	if( !( ch = S_FindRawChannel( entnum, true )))

	push	1
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN3@S_RawEntSa

; 1567 : 		return;

	jmp	SHORT $LN1@S_RawEntSa
$LN3@S_RawEntSa:

; 1568 : 
; 1569 : 	ch->master_vol = snd_vol;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _snd_vol$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1570 : 	ch->dist_mult = (ATTN_NONE / SND_CLIP_DISTANCE);

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+16], xmm0

; 1571 : 	ch->s_rawend = S_RawSamplesStereo( ch->rawsamples, ch->s_rawend, ch->max_samples, samples, rate, width, channels, data );

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _channels$[ebp]
	push	edx
	movzx	eax, WORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _samples$[ebp]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	_S_RawSamplesStereo
	add	esp, 32					; 00000020H
	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+36], eax

; 1572 : 	ch->leftvol = ch->rightvol = snd_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _snd_vol$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _snd_vol$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@S_RawEntSa:

; 1573 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_RawEntSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_in$1 = -28						; size = 4
tv196 = -24						; size = 4
_fracstep$ = -20					; size = 4
_in$2 = -16						; size = 4
_dst$ = -12						; size = 4
_samplefrac$ = -8					; size = 4
_src$ = -4						; size = 4
_rawsamples$ = 8					; size = 4
_rawend$ = 12						; size = 4
_max_samples$ = 16					; size = 4
_samples$ = 20						; size = 4
_rate$ = 24						; size = 4
_width$ = 28						; size = 2
_channels$ = 32						; size = 2
_data$ = 36						; size = 4
_S_RawSamplesStereo PROC

; 1494 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1495 : 	uint	fracstep, samplefrac;
; 1496 : 	uint	src, dst;
; 1497 : 
; 1498 : 	if( rawend < paintedtime )

	mov	eax, DWORD PTR _rawend$[ebp]
	cmp	eax, DWORD PTR _paintedtime
	jae	SHORT $LN14@S_RawSampl

; 1499 : 		rawend = paintedtime;

	mov	ecx, DWORD PTR _paintedtime
	mov	DWORD PTR _rawend$[ebp], ecx
$LN14@S_RawSampl:

; 1500 : 
; 1501 : 	fracstep = ((double) rate / (double)SOUND_DMA_SPEED) * (double)(1 << S_RAW_SAMPLES_PRECISION_BITS);

	mov	edx, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv196[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv196[ebp]
	mov	eax, DWORD PTR tv196[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, QWORD PTR __real@40e5888000000000
	mulsd	xmm0, QWORD PTR __real@40d0000000000000
	call	__dtoui3
	mov	DWORD PTR _fracstep$[ebp], eax

; 1502 : 	samplefrac = 0;

	mov	DWORD PTR _samplefrac$[ebp], 0

; 1503 : 
; 1504 : 	if( width == 2 )

	movzx	ecx, WORD PTR _width$[ebp]
	cmp	ecx, 2
	jne	$LN15@S_RawSampl

; 1505 : 	{
; 1506 : 		const short *in = (const short *)data;

	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _in$2[ebp], edx

; 1507 : 
; 1508 : 		if( channels == 2 )

	movzx	eax, WORD PTR _channels$[ebp]
	cmp	eax, 2
	jne	SHORT $LN17@S_RawSampl

; 1509 : 		{
; 1510 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN4@S_RawSampl
$LN2@S_RawSampl:
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	add	ecx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], ecx
	mov	edx, DWORD PTR _samplefrac$[ebp]
	shr	edx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], edx
$LN4@S_RawSampl:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jae	SHORT $LN3@S_RawSampl

; 1511 : 			{
; 1512 : 				dst = rawend++ & ( max_samples - 1 );

	mov	ecx, DWORD PTR _max_samples$[ebp]
	sub	ecx, 1
	and	ecx, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], ecx
	mov	edx, DWORD PTR _rawend$[ebp]
	add	edx, 1
	mov	DWORD PTR _rawend$[ebp], edx

; 1513 : 				rawsamples[dst].left = in[src*2+0];

	mov	eax, DWORD PTR _src$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _in$2[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1514 : 				rawsamples[dst].right = in[src*2+1];

	mov	edx, DWORD PTR _src$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _in$2[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+2]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 1515 : 			}

	jmp	SHORT $LN2@S_RawSampl
$LN3@S_RawSampl:

; 1516 : 		}

	jmp	SHORT $LN6@S_RawSampl
$LN17@S_RawSampl:

; 1517 : 		else
; 1518 : 		{
; 1519 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN7@S_RawSampl
$LN5@S_RawSampl:
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	add	ecx, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], ecx
	mov	edx, DWORD PTR _samplefrac$[ebp]
	shr	edx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], edx
$LN7@S_RawSampl:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jae	SHORT $LN6@S_RawSampl

; 1520 : 			{
; 1521 : 				dst = rawend++ & ( max_samples - 1 );

	mov	ecx, DWORD PTR _max_samples$[ebp]
	sub	ecx, 1
	and	ecx, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], ecx
	mov	edx, DWORD PTR _rawend$[ebp]
	add	edx, 1
	mov	DWORD PTR _rawend$[ebp], edx

; 1522 : 				rawsamples[dst].left = in[src];

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1523 : 				rawsamples[dst].right = in[src];

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR _in$2[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 1524 : 			}

	jmp	SHORT $LN5@S_RawSampl
$LN6@S_RawSampl:

; 1525 : 		}
; 1526 : 	}

	jmp	$LN12@S_RawSampl
$LN15@S_RawSampl:

; 1527 : 	else
; 1528 : 	{
; 1529 : 		if( channels == 2 )

	movzx	ecx, WORD PTR _channels$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN19@S_RawSampl

; 1530 : 		{
; 1531 : 			const char *in = (const char *)data;

	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _in$1[ebp], edx

; 1532 : 
; 1533 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN10@S_RawSampl
$LN8@S_RawSampl:
	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], ecx
$LN10@S_RawSampl:
	mov	edx, DWORD PTR _src$[ebp]
	cmp	edx, DWORD PTR _samples$[ebp]
	jae	SHORT $LN9@S_RawSampl

; 1534 : 			{
; 1535 : 				dst = rawend++ & ( max_samples - 1 );

	mov	eax, DWORD PTR _max_samples$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _rawend$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rawend$[ebp], ecx

; 1536 : 				rawsamples[dst].left = in[src*2+0] << 8;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR _in$1[ebp]
	movsx	ecx, BYTE PTR [eax+edx*2]
	shl	ecx, 8
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 1537 : 				rawsamples[dst].right = in[src*2+1] << 8;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _in$1[ebp]
	movsx	eax, BYTE PTR [edx+ecx*2+1]
	shl	eax, 8
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 1538 : 			}

	jmp	SHORT $LN8@S_RawSampl
$LN9@S_RawSampl:

; 1539 : 		}

	jmp	SHORT $LN12@S_RawSampl
$LN19@S_RawSampl:

; 1540 : 		else
; 1541 : 		{
; 1542 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN13@S_RawSampl
$LN11@S_RawSampl:
	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], ecx
$LN13@S_RawSampl:
	mov	edx, DWORD PTR _src$[ebp]
	cmp	edx, DWORD PTR _samples$[ebp]
	jae	SHORT $LN12@S_RawSampl

; 1543 : 			{
; 1544 : 				dst = rawend++ & ( max_samples - 1 );

	mov	eax, DWORD PTR _max_samples$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _rawend$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rawend$[ebp], ecx

; 1545 : 				rawsamples[dst].left = ( data[src] - 128 ) << 8;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _src$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	eax, 128				; 00000080H
	shl	eax, 8
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 1546 : 				rawsamples[dst].right = ( data[src] - 128 ) << 8;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	shl	ecx, 8
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 1547 : 			}

	jmp	SHORT $LN11@S_RawSampl
$LN12@S_RawSampl:

; 1548 : 		}
; 1549 : 	}
; 1550 : 
; 1551 : 	return rawend;

	mov	eax, DWORD PTR _rawend$[ebp]

; 1552 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_RawSamplesStereo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_leaf$ = -16						; size = 4
_vol$ = -12						; size = 4
_ambient_channel$ = -8					; size = 4
_chan$ = -4						; size = 4
_S_UpdateAmbientSounds PROC

; 1367 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1368 : 	mleaf_t	*leaf;
; 1369 : 	float	vol;
; 1370 : 	int	ambient_channel;
; 1371 : 	channel_t	*chan;
; 1372 : 
; 1373 : 	if( !snd_ambient ) return;

	cmp	DWORD PTR _snd_ambient, 0
	jne	SHORT $LN8@S_UpdateAm
	jmp	$LN6@S_UpdateAm
$LN8@S_UpdateAm:

; 1374 : 
; 1375 : 	// calc ambient sound levels
; 1376 : 	if( !cl.worldmodel ) return;

	cmp	DWORD PTR _cl+2686576, 0
	jne	SHORT $LN9@S_UpdateAm
	jmp	$LN6@S_UpdateAm
$LN9@S_UpdateAm:

; 1377 : 
; 1378 : 	leaf = Mod_PointInLeaf( s_listener.origin, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+2686576
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	push	OFFSET _s_listener
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 1379 : 
; 1380 : 	if( !leaf || !s_ambient_level->value )

	cmp	DWORD PTR _leaf$[ebp], 0
	je	SHORT $LN11@S_UpdateAm
	mov	edx, DWORD PTR _s_ambient_level
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@S_UpdateAm
$LN11@S_UpdateAm:

; 1381 : 	{
; 1382 : 		for( ambient_channel = 0; ambient_channel < NUM_AMBIENTS; ambient_channel++ )

	mov	DWORD PTR _ambient_channel$[ebp], 0
	jmp	SHORT $LN4@S_UpdateAm
$LN2@S_UpdateAm:
	mov	eax, DWORD PTR _ambient_channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _ambient_channel$[ebp], eax
$LN4@S_UpdateAm:
	cmp	DWORD PTR _ambient_channel$[ebp], 4
	jge	SHORT $LN3@S_UpdateAm

; 1383 : 			channels[ambient_channel].sfx = NULL;

	imul	ecx, DWORD PTR _ambient_channel$[ebp], 2480
	mov	DWORD PTR _channels[ecx+16], 0
	jmp	SHORT $LN2@S_UpdateAm
$LN3@S_UpdateAm:

; 1384 : 		return;

	jmp	$LN6@S_UpdateAm
$LN10@S_UpdateAm:

; 1385 : 	}
; 1386 : 
; 1387 : 	for( ambient_channel = 0; ambient_channel < NUM_AMBIENTS; ambient_channel++ )

	mov	DWORD PTR _ambient_channel$[ebp], 0
	jmp	SHORT $LN7@S_UpdateAm
$LN5@S_UpdateAm:
	mov	edx, DWORD PTR _ambient_channel$[ebp]
	add	edx, 1
	mov	DWORD PTR _ambient_channel$[ebp], edx
$LN7@S_UpdateAm:
	cmp	DWORD PTR _ambient_channel$[ebp], 4
	jge	$LN6@S_UpdateAm

; 1388 : 	{
; 1389 : 		chan = &channels[ambient_channel];	

	imul	eax, DWORD PTR _ambient_channel$[ebp], 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _chan$[ebp], eax

; 1390 : 		chan->sfx = S_GetSfxByHandle( ambient_sfx[ambient_channel] );

	mov	ecx, DWORD PTR _ambient_channel$[ebp]
	mov	edx, DWORD PTR _ambient_sfx[ecx*4]
	push	edx
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1391 : 
; 1392 : 		// ambient is unused
; 1393 : 		if( !chan->sfx )

	mov	edx, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN12@S_UpdateAm

; 1394 : 		{
; 1395 : 			chan->rightvol = 0;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1396 : 			chan->leftvol = 0;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 1397 : 			continue;

	jmp	SHORT $LN5@S_UpdateAm
$LN12@S_UpdateAm:

; 1398 : 		}
; 1399 : 
; 1400 : 		vol = s_ambient_level->value * leaf->ambient_sound_level[ambient_channel];

	mov	edx, DWORD PTR _leaf$[ebp]
	add	edx, DWORD PTR _ambient_channel$[ebp]
	movzx	eax, BYTE PTR [edx+56]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _s_ambient_level
	mulss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _vol$[ebp], xmm0

; 1401 : 		if( vol < 0 ) vol = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _vol$[ebp]
	jbe	SHORT $LN13@S_UpdateAm
	xorps	xmm0, xmm0
	movss	DWORD PTR _vol$[ebp], xmm0
$LN13@S_UpdateAm:

; 1402 : 
; 1403 : 		// don't adjust volume too fast
; 1404 : 		if( chan->master_vol < vol )

	mov	edx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+52]
	movss	xmm1, DWORD PTR _vol$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@S_UpdateAm

; 1405 : 		{
; 1406 : 			chan->master_vol += s_listener.frametime * s_ambient_fade->value;

	mov	eax, DWORD PTR _s_ambient_fade
	movss	xmm0, DWORD PTR _s_listener+68
	mulss	xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+52], edx

; 1407 : 			if( chan->master_vol > vol ) chan->master_vol = vol;

	mov	ecx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+52]
	comiss	xmm0, DWORD PTR _vol$[ebp]
	jbe	SHORT $LN16@S_UpdateAm
	cvttss2si edx, DWORD PTR _vol$[ebp]
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+52], edx
$LN16@S_UpdateAm:

; 1408 : 		}

	jmp	SHORT $LN18@S_UpdateAm
$LN14@S_UpdateAm:

; 1409 : 		else if( chan->master_vol > vol )

	mov	ecx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+52]
	comiss	xmm0, DWORD PTR _vol$[ebp]
	jbe	SHORT $LN18@S_UpdateAm

; 1410 : 		{
; 1411 : 			chan->master_vol -= s_listener.frametime * s_ambient_fade->value;

	mov	edx, DWORD PTR _s_ambient_fade
	movss	xmm0, DWORD PTR _s_listener+68
	mulss	xmm0, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+52]
	subss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 1412 : 			if( chan->master_vol < vol ) chan->master_vol = vol;

	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+52]
	movss	xmm1, DWORD PTR _vol$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@S_UpdateAm
	cvttss2si ecx, DWORD PTR _vol$[ebp]
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN18@S_UpdateAm:

; 1413 : 		}
; 1414 : 		
; 1415 : 		chan->leftvol = chan->rightvol = chan->master_vol;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx

; 1416 : 	}

	jmp	$LN5@S_UpdateAm
$LN6@S_UpdateAm:

; 1417 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateAmbientSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ambient_channel$ = -8					; size = 4
_chan$ = -4						; size = 4
_S_InitAmbientChannels PROC

; 1345 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1346 : 	int	ambient_channel;
; 1347 : 	channel_t	*chan;
; 1348 : 
; 1349 : 	for( ambient_channel = 0; ambient_channel < NUM_AMBIENTS; ambient_channel++ )

	mov	DWORD PTR _ambient_channel$[ebp], 0
	jmp	SHORT $LN4@S_InitAmbi
$LN2@S_InitAmbi:
	mov	eax, DWORD PTR _ambient_channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _ambient_channel$[ebp], eax
$LN4@S_InitAmbi:
	cmp	DWORD PTR _ambient_channel$[ebp], 4
	jge	SHORT $LN3@S_InitAmbi

; 1350 : 	{
; 1351 : 		chan = &channels[ambient_channel];	

	imul	ecx, DWORD PTR _ambient_channel$[ebp], 2480
	add	ecx, OFFSET _channels
	mov	DWORD PTR _chan$[ebp], ecx

; 1352 : 
; 1353 : 		chan->staticsound = true;

	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+72], 1

; 1354 : 		chan->use_loop = true;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+68], 1

; 1355 : 		chan->entchannel = CHAN_STATIC;

	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+32], 6

; 1356 : 		chan->dist_mult = (ATTN_NONE / SND_CLIP_DISTANCE);

	mov	edx, DWORD PTR _chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+48], xmm0

; 1357 : 		chan->basePitch = PITCH_NORM;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+60], 100			; 00000064H

; 1358 : 	}

	jmp	SHORT $LN2@S_InitAmbi
$LN3@S_InitAmbi:

; 1359 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_InitAmbientChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv163 = -56						; size = 4
tv139 = -52						; size = 4
_gain$ = -48						; size = 4
_looping$ = -44						; size = 4
_interval$1 = -40					; size = 4
_pSource$ = -36						; size = 4
_fplayersound$ = -32					; size = 4
_dot$ = -28						; size = 4
_dist$ = -24						; size = 4
_blend$2 = -20						; size = 4
_source_vec$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_ch$ = 8						; size = 4
_SND_Spatialize PROC

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 802  : 	vec3_t	source_vec;
; 803  : 	float	dist, dot, gain = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gain$[ebp], xmm0

; 804  : 	qboolean	fplayersound = false;

	mov	DWORD PTR _fplayersound$[ebp], 0

; 805  : 	qboolean	looping = false;

	mov	DWORD PTR _looping$[ebp], 0

; 806  : 	wavdata_t	*pSource;
; 807  : 
; 808  : 	// anything coming from the view entity will allways be full volume
; 809  : 	if( S_IsClient( ch->entnum ))

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SND_Spatia

; 810  : 	{
; 811  : 		if( !s_cull->value )

	mov	edx, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SND_Spatia

; 812  : 		{
; 813  : 			ch->leftvol = ch->master_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+20], edx

; 814  : 			ch->rightvol = ch->master_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+24], edx

; 815  : 			return;

	jmp	$LN14@SND_Spatia
$LN3@SND_Spatia:

; 816  : 		}
; 817  : 
; 818  : 		// sounds coming from listener actually come from a short distance directly in front of listener
; 819  : 		fplayersound = true;

	mov	DWORD PTR _fplayersound$[ebp], 1
$LN2@SND_Spatia:

; 820  : 	}
; 821  : 
; 822  : 	pSource = ch->sfx->cache;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _pSource$[ebp], edx

; 823  : 
; 824  : 	if( ch->use_loop && pSource && pSource->loopStart != -1 )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN4@SND_Spatia
	cmp	DWORD PTR _pSource$[ebp], 0
	je	SHORT $LN4@SND_Spatia
	mov	ecx, DWORD PTR _pSource$[ebp]
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN4@SND_Spatia

; 825  : 		looping = true;

	mov	DWORD PTR _looping$[ebp], 1
$LN4@SND_Spatia:

; 826  : 
; 827  : 	if( !ch->staticsound )

	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+72], 0
	jne	SHORT $LN6@SND_Spatia

; 828  : 	{
; 829  : 		if( !CL_GetEntitySpatialization( ch ) || !SND_CheckPHS( ch ))

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_CL_GetEntitySpatialization
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@SND_Spatia
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_SND_CheckPHS
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SND_Spatia
$LN7@SND_Spatia:

; 830  : 		{
; 831  : 			// origin is null and entity not exist on client
; 832  : 			ch->leftvol = ch->rightvol = 0;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+20], 0

; 833  : 			ch->bfirstpass = false;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 834  : 			return;

	jmp	$LN14@SND_Spatia
$LN6@SND_Spatia:

; 835  : 		}
; 836  : 	}
; 837  : 
; 838  : 	// source_vec is vector from listener to sound source
; 839  : 	// player sounds come from 1' in front of player
; 840  : 	if( fplayersound ) VectorScale( s_listener.forward, 12.0f, source_vec );

	cmp	DWORD PTR _fplayersound$[ebp], 0
	je	SHORT $LN8@SND_Spatia
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _s_listener[eax+24]
	mulss	xmm0, DWORD PTR __real@41400000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _source_vec$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _s_listener[eax+24]
	mulss	xmm0, DWORD PTR __real@41400000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _source_vec$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _s_listener[edx+24]
	mulss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR tv139[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv139[ebp]
	movss	DWORD PTR _source_vec$[ebp+eax], xmm0
	jmp	$LN9@SND_Spatia
$LN8@SND_Spatia:

; 841  : 	else VectorSubtract( ch->origin, s_listener.origin, source_vec );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+36]
	subss	xmm0, DWORD PTR _s_listener[ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _source_vec$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+36]
	subss	xmm0, DWORD PTR _s_listener[ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _source_vec$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+36]
	subss	xmm0, DWORD PTR _s_listener[edx]
	movss	DWORD PTR tv163[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv163[ebp]
	movss	DWORD PTR _source_vec$[ebp+ecx], xmm0
$LN9@SND_Spatia:

; 842  : 
; 843  : 	// normalize source_vec and get distance from listener to source
; 844  : 	dist = VectorNormalizeLength( source_vec );

	lea	edx, DWORD PTR _source_vec$[ebp]
	push	edx
	lea	eax, DWORD PTR _source_vec$[ebp]
	push	eax
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 845  : 	dot = DotProduct( s_listener.right, source_vec );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _s_listener[edx+36]
	mulss	xmm0, DWORD PTR _source_vec$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _s_listener[edx+36]
	mulss	xmm1, DWORD PTR _source_vec$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _s_listener[ecx+36]
	mulss	xmm1, DWORD PTR _source_vec$[ebp+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dot$[ebp], xmm0

; 846  : 
; 847  : 	// for sounds with a radius, spatialize left/right evenly within the radius
; 848  : 	if( ch->radius > 0 && dist < ch->radius )

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@SND_Spatia
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN10@SND_Spatia

; 849  : 	{
; 850  : 		float	interval = ch->radius * 0.5f;

	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+132]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _interval$1[ebp], xmm0

; 851  : 		float	blend = dist - interval;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _interval$1[ebp]
	movss	DWORD PTR _blend$2[ebp], xmm0

; 852  : 
; 853  : 		if( blend < 0 ) blend = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _blend$2[ebp]
	jbe	SHORT $LN11@SND_Spatia
	xorps	xmm0, xmm0
	movss	DWORD PTR _blend$2[ebp], xmm0
$LN11@SND_Spatia:

; 854  : 		blend /= interval;	

	movss	xmm0, DWORD PTR _blend$2[ebp]
	divss	xmm0, DWORD PTR _interval$1[ebp]
	movss	DWORD PTR _blend$2[ebp], xmm0

; 855  : 
; 856  : 		// blend is 0.0 - 1.0, from 50% radius -> 100% radius
; 857  : 		// at radius * 0.5, dot is 0 (ie: sound centered left/right)
; 858  : 		// at radius dot == dot
; 859  : 		dot *= blend;

	movss	xmm0, DWORD PTR _dot$[ebp]
	mulss	xmm0, DWORD PTR _blend$2[ebp]
	movss	DWORD PTR _dot$[ebp], xmm0
$LN10@SND_Spatia:

; 860  : 	}
; 861  : 
; 862  : 	if( s_cull->value )

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SND_Spatia

; 863  : 	{
; 864  : 		// calculate gain based on distance, atmospheric attenuation, interposed objects
; 865  : 		// perform compression as gain approaches 1.0
; 866  : 		gain = SND_GetGain( ch, fplayersound, looping, dist );

	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _looping$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fplayersound$[ebp]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_GetGain
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _gain$[ebp]
$LN12@SND_Spatia:

; 867  : 	}
; 868  : 
; 869  : 	// don't pan sounds with no attenuation
; 870  : 	if( ch->dist_mult <= 0.0f ) dot = 0.0f;

	mov	ecx, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+48]
	jb	SHORT $LN13@SND_Spatia
	xorps	xmm0, xmm0
	movss	DWORD PTR _dot$[ebp], xmm0
$LN13@SND_Spatia:

; 871  : 
; 872  : 	// fill out channel volumes for single location
; 873  : 	S_SpatializeChannel( &ch->leftvol, &ch->rightvol, ch->master_vol, gain, dot, dist * ch->dist_mult );

	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR [edx+48]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_S_SpatializeChannel
	add	esp, 24					; 00000018H

; 874  : 
; 875  : 	// if playing a word, set volume
; 876  : 	VOX_SetChanVol( ch );

	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_VOX_SetChanVol
	add	esp, 4

; 877  : 
; 878  : 	// end of first time spatializing sound
; 879  : 	if( CL_Active( )) ch->bfirstpass = false;

	call	_CL_Active
	test	eax, eax
	je	SHORT $LN14@SND_Spatia
	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+112], 0
$LN14@SND_Spatia:

; 880  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_Spatialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv95 = -28						; size = 4
tv94 = -24						; size = 4
tv91 = -20						; size = 4
tv90 = -16						; size = 4
_lscale$ = -12						; size = 4
_rscale$ = -8						; size = 4
_scale$ = -4						; size = 4
_left_vol$ = 8						; size = 4
_right_vol$ = 12					; size = 4
_master_vol$ = 16					; size = 4
_gain$ = 20						; size = 4
_dot$ = 24						; size = 4
_dist$ = 28						; size = 4
_S_SpatializeChannel PROC

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 777  : 	float	lscale, rscale, scale;
; 778  : 
; 779  : 	rscale = 1.0f + dot;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _dot$[ebp]
	movss	DWORD PTR _rscale$[ebp], xmm0

; 780  : 	lscale = 1.0f - dot;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dot$[ebp]
	movss	DWORD PTR _lscale$[ebp], xmm0

; 781  : 
; 782  : 	// add in distance effect
; 783  : 	if( s_cull->value ) scale = gain * rscale / 2;

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@S_Spatiali
	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR _rscale$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _scale$[ebp], xmm0
	jmp	SHORT $LN3@S_Spatiali
$LN2@S_Spatiali:

; 784  : 	else scale = ( 1.0f - dist ) * rscale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _rscale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@S_Spatiali:

; 785  : 	*right_vol = (int)( master_vol * scale );

	cvtsi2ss xmm0, DWORD PTR _master_vol$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _right_vol$[ebp]
	mov	DWORD PTR [edx], ecx

; 786  : 
; 787  : 	if( s_cull->value ) scale = gain * lscale / 2;

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@S_Spatiali
	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR _lscale$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _scale$[ebp], xmm0
	jmp	SHORT $LN5@S_Spatiali
$LN4@S_Spatiali:

; 788  : 	else scale = ( 1.0f - dist ) * lscale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _lscale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN5@S_Spatiali:

; 789  : 	*left_vol = (int)( master_vol * scale );

	cvtsi2ss xmm0, DWORD PTR _master_vol$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _left_vol$[ebp]
	mov	DWORD PTR [edx], ecx

; 790  : 
; 791  : 	*right_vol = bound( 0, *right_vol, 255 );

	mov	eax, DWORD PTR _right_vol$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN9@S_Spatiali
	mov	ecx, DWORD PTR _right_vol$[ebp]
	cmp	DWORD PTR [ecx], 255			; 000000ffH
	jge	SHORT $LN7@S_Spatiali
	mov	edx, DWORD PTR _right_vol$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN8@S_Spatiali
$LN7@S_Spatiali:
	mov	DWORD PTR tv90[ebp], 255		; 000000ffH
$LN8@S_Spatiali:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv91[ebp], ecx
	jmp	SHORT $LN10@S_Spatiali
$LN9@S_Spatiali:
	mov	DWORD PTR tv91[ebp], 0
$LN10@S_Spatiali:
	mov	edx, DWORD PTR _right_vol$[ebp]
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR [edx], eax

; 792  : 	*left_vol = bound( 0, *left_vol, 255 );

	mov	ecx, DWORD PTR _left_vol$[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN13@S_Spatiali
	mov	edx, DWORD PTR _left_vol$[ebp]
	cmp	DWORD PTR [edx], 255			; 000000ffH
	jge	SHORT $LN11@S_Spatiali
	mov	eax, DWORD PTR _left_vol$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN12@S_Spatiali
$LN11@S_Spatiali:
	mov	DWORD PTR tv94[ebp], 255		; 000000ffH
$LN12@S_Spatiali:
	mov	edx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], edx
	jmp	SHORT $LN14@S_Spatiali
$LN13@S_Spatiali:
	mov	DWORD PTR tv95[ebp], 0
$LN14@S_Spatiali:
	mov	eax, DWORD PTR _left_vol$[ebp]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR [eax], ecx

; 793  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_SpatializeChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv129 = -8						; size = 4
_leaf$ = -4						; size = 4
_ch$ = 8						; size = 4
_SND_CheckPHS PROC

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 746  : 	mleaf_t	*leaf;
; 747  : 
; 748  : 	if( !s_phs->value )

	mov	eax, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SND_CheckP

; 749  : 		return true;

	mov	eax, 1
	jmp	$LN1@SND_CheckP
$LN2@SND_CheckP:

; 750  : 
; 751  : 	if( !ch->dist_mult && ch->entnum )

	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SND_CheckP
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN3@SND_CheckP

; 752  : 		return true; // no attenuation 

	mov	eax, 1
	jmp	$LN1@SND_CheckP
$LN3@SND_CheckP:

; 753  : 
; 754  : 	if( ch->movetype == MOVETYPE_PUSH )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+160], 7
	jne	SHORT $LN4@SND_CheckP

; 755  : 	{
; 756  : 		if( Mod_BoxVisible( ch->absmin, ch->absmax, s_listener.pasbytes ))

	push	OFFSET _s_listener+92
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 148				; 00000094H
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	call	_Mod_BoxVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@SND_CheckP

; 757  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_CheckP
$LN6@SND_CheckP:

; 758  : 	}

	jmp	SHORT $LN7@SND_CheckP
$LN4@SND_CheckP:

; 759  : 	else
; 760  : 	{
; 761  : 		leaf = Mod_PointInLeaf( ch->origin, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+2686576
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 762  : 
; 763  : 		if( CHECKVISBIT( s_listener.pasbytes, leaf->cluster ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN9@SND_CheckP
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	movzx	eax, BYTE PTR _s_listener[edx+92]
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN10@SND_CheckP
$LN9@SND_CheckP:
	mov	DWORD PTR tv129[ebp], 0
$LN10@SND_CheckP:
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN7@SND_CheckP

; 764  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_CheckP
$LN7@SND_CheckP:

; 765  : 	}
; 766  : 
; 767  : 	return false;

	xor	eax, eax
$LN1@SND_CheckP:

; 768  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_CheckPHS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv265 = -84						; size = 8
tv297 = -76						; size = 8
tv258 = -68						; size = 8
tv238 = -60						; size = 8
tv230 = -52						; size = 8
tv136 = -44						; size = 8
tv293 = -36						; size = 4
tv285 = -32						; size = 4
_Y$1 = -28						; size = 4
_additional_dist_mult$2 = -24				; size = 4
_additional_dB_loss$3 = -20				; size = 4
_sndlvl$4 = -16						; size = 4
_relative_dist$5 = -12					; size = 4
_snd_gain_comp_power$6 = -8				; size = 4
_gain$ = -4						; size = 4
_ch$ = 8						; size = 4
_fplayersound$ = 12					; size = 4
_flooping$ = 16						; size = 4
_dist$ = 20						; size = 4
_SND_GetGain PROC

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 677  : 	float	gain = snd_gain->value;

	mov	eax, DWORD PTR _snd_gain
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _gain$[ebp], xmm0

; 678  : 
; 679  : 	if( ch->dist_mult )

	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@SND_GetGai

; 680  : 	{
; 681  : 		// test additional attenuation
; 682  : 		// at 30c, 14.7psi, 60% humidity, 1000Hz == 0.22dB / 100ft.
; 683  : 		// dense foliage is roughly 2dB / 100ft
; 684  : 		float additional_dB_loss = snd_foliage_db_loss->value * (dist / 1200);

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR __real@44960000
	mov	edx, DWORD PTR _snd_foliage_db_loss
	mulss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _additional_dB_loss$3[ebp], xmm0

; 685  : 		float additional_dist_mult = pow( 10, additional_dB_loss / 20 );

	movss	xmm0, DWORD PTR _additional_dB_loss$3[ebp]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _additional_dist_mult$2[ebp]

; 686  : 		float relative_dist = dist * ch->dist_mult * additional_dist_mult;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR _additional_dist_mult$2[ebp]
	movss	DWORD PTR _relative_dist$5[ebp], xmm0

; 687  : 
; 688  : 		// hard code clamp gain to 10x normal (assumes volume and external clipping)
; 689  : 		if( relative_dist > 0.1f )

	movss	xmm0, DWORD PTR _relative_dist$5[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN3@SND_GetGai

; 690  : 			gain *= ( 1.0f / relative_dist );

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _relative_dist$5[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0
	jmp	SHORT $LN4@SND_GetGai
$LN3@SND_GetGai:

; 691  : 		else gain *= 10.0f;

	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _gain$[ebp], xmm0
$LN4@SND_GetGai:

; 692  : 
; 693  : 		// if gain passess threshold, compress gain curve such that gain smoothly approaches 1.0
; 694  : 		if( gain > SND_GAIN_COMP_THRESH )

	movss	xmm0, DWORD PTR _gain$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN5@SND_GetGai

; 695  : 		{
; 696  : 			float	snd_gain_comp_power = SND_GAIN_COMP_EXP_MAX;

	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR _snd_gain_comp_power$6[ebp], xmm0

; 697  : 			int	sndlvl = DIST_MULT_TO_SNDLVL( ch->dist_mult );

	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN12@SND_GetGai
	mov	edx, DWORD PTR _s_refdb
	movss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv230[ebp]
	movsd	xmm0, QWORD PTR tv230[ebp]
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _s_refdist
	movss	xmm1, DWORD PTR [eax+48]
	mulss	xmm1, DWORD PTR [ecx+12]
	cvtss2sd xmm1, xmm1
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log10
	add	esp, 8
	fstp	QWORD PTR tv238[ebp]
	movsd	xmm0, QWORD PTR tv238[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR tv136[ebp], xmm0
	jmp	SHORT $LN13@SND_GetGai
$LN12@SND_GetGai:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv136[ebp], xmm0
$LN13@SND_GetGai:
	cvttsd2si edx, QWORD PTR tv136[ebp]
	mov	DWORD PTR _sndlvl$4[ebp], edx

; 698  : 			float	Y;
; 699  : 			
; 700  : 			// decrease compression curve fit for higher sndlvl values
; 701  : 			if( sndlvl > SND_DB_MED )

	cvtsi2ss xmm0, DWORD PTR _sndlvl$4[ebp]
	comiss	xmm0, DWORD PTR __real@42b40000
	jbe	SHORT $LN6@SND_GetGai

; 702  : 			{
; 703  : 				// snd_gain_power varies from max to min as sndlvl varies from 90 to 140
; 704  : 				snd_gain_comp_power = RemapVal((float)sndlvl, SND_DB_MED, SND_DB_MAX, SND_GAIN_COMP_EXP_MAX, SND_GAIN_COMP_EXP_MIN );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@430c0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _sndlvl$4[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_RemapVal
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _snd_gain_comp_power$6[ebp]
$LN6@SND_GetGai:

; 705  : 			}
; 706  : 
; 707  : 			// calculate crossover point
; 708  : 			Y = -1.0f / ( pow( SND_GAIN_COMP_THRESH, snd_gain_comp_power ) * ( SND_GAIN_COMP_THRESH - 1 ));

	cvtss2sd xmm0, DWORD PTR _snd_gain_comp_power$6[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv258[ebp]
	movsd	xmm0, QWORD PTR tv258[ebp]
	mulsd	xmm0, QWORD PTR __real@bfe0000000000000
	movsd	xmm1, QWORD PTR __real@bff0000000000000
	divsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _Y$1[ebp], xmm0

; 709  : 			
; 710  : 			// calculate compressed gain
; 711  : 			gain = 1.0f - 1.0f / (Y * pow( gain, snd_gain_comp_power ));

	cvtss2sd xmm0, DWORD PTR _Y$1[ebp]
	cvtss2sd xmm1, DWORD PTR _snd_gain_comp_power$6[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	cvtss2sd xmm1, DWORD PTR _gain$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv297[ebp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv265[ebp]
	movsd	xmm0, QWORD PTR tv297[ebp]
	mulsd	xmm0, QWORD PTR tv265[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _gain$[ebp], xmm0

; 712  : 			gain = gain * snd_gain_max->value;

	mov	eax, DWORD PTR _snd_gain_max
	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _gain$[ebp], xmm0
$LN5@SND_GetGai:

; 713  : 		}
; 714  : 
; 715  : 		if( gain < snd_gain_min->value )

	mov	ecx, DWORD PTR _snd_gain_min
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR _gain$[ebp]
	jbe	SHORT $LN8@SND_GetGai

; 716  : 		{
; 717  : 			// sounds less than snd_gain_min fall off to 0 in distance it took them to fall to snd_gain_min
; 718  : 			gain = snd_gain_min->value * ( 2.0f - relative_dist * snd_gain_min->value );

	mov	edx, DWORD PTR _snd_gain_min
	movss	xmm0, DWORD PTR _relative_dist$5[ebp]
	mulss	xmm0, DWORD PTR [edx+12]
	movss	xmm1, DWORD PTR __real@40000000
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _snd_gain_min
	mulss	xmm1, DWORD PTR [eax+12]
	movss	DWORD PTR _gain$[ebp], xmm1

; 719  : 			if( gain <= 0.0f ) gain = 0.001f; // don't propagate 0 gain

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _gain$[ebp]
	jb	SHORT $LN8@SND_GetGai
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _gain$[ebp], xmm0
$LN8@SND_GetGai:

; 720  : 		}
; 721  : 	}
; 722  : 
; 723  : 	if( fplayersound )

	cmp	DWORD PTR _fplayersound$[ebp], 0
	je	SHORT $LN10@SND_GetGai

; 724  : 	{
; 725  : 		// player weapon sounds get extra gain - this compensates
; 726  : 		// for npc distance effect weapons which mix louder as L+R into L, R
; 727  : 		if( ch->entchannel == CHAN_WEAPON )

	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN10@SND_GetGai

; 728  : 			gain = gain * dB_To_Gain( SND_GAIN_PLAYER_WEAPON_DB );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_dB_To_Gain
	add	esp, 4
	fstp	DWORD PTR tv285[ebp]
	movss	xmm0, DWORD PTR tv285[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0
$LN10@SND_GetGai:

; 729  : 	}
; 730  : 
; 731  : 	// modify gain if sound source not visible to player
; 732  : 	gain = gain * SND_GetGainObscured( ch, fplayersound, flooping );

	mov	edx, DWORD PTR _flooping$[ebp]
	push	edx
	mov	eax, DWORD PTR _fplayersound$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_SND_GetGainObscured
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR tv293[ebp]
	movss	xmm0, DWORD PTR tv293[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0

; 733  : 
; 734  : 	return gain; 

	fld	DWORD PTR _gain$[ebp]

; 735  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_GetGain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
$T1 = -456						; size = 68
$T2 = -388						; size = 68
tv728 = -320						; size = 8
tv720 = -312						; size = 8
tv161 = -304						; size = 8
tv526 = -296						; size = 4
tv493 = -292						; size = 4
tv460 = -288						; size = 4
tv436 = -284						; size = 4
tv412 = -280						; size = 4
tv397 = -276						; size = 4
tv304 = -272						; size = 4
tv272 = -268						; size = 4
tv209 = -264						; size = 4
_sndlvl$3 = -260					; size = 4
tv1033 = -256						; size = 4
tv592 = -252						; size = 4
tv559 = -248						; size = 4
_count$ = -244						; size = 4
_ilength$4 = -240					; size = 4
_ilength$5 = -236					; size = 4
_ilength$6 = -232					; size = 4
_i$7 = -228						; size = 4
_gain$ = -224						; size = 4
_radius$8 = -220					; size = 4
_tr$ = -216						; size = 68
_vecr2$9 = -148						; size = 12
_vecl2$10 = -136					; size = 12
_endpoints$11 = -124					; size = 48
_vsrc_right$12 = -76					; size = 12
_vsrc_up$13 = -64					; size = 12
_endpoint$ = -52					; size = 12
_vsrc_forward$14 = -40					; size = 12
_vecr$15 = -28						; size = 12
_vecl$16 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ch$ = 8						; size = 4
_fplayersound$ = 12					; size = 4
_flooping$ = 16						; size = 4
_SND_GetGainObscured PROC

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 456				; 000001c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 559  : 	float	gain = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gain$[ebp], xmm0

; 560  : 	vec3_t	endpoint;
; 561  : 	int	count = 1;

	mov	DWORD PTR _count$[ebp], 1

; 562  : 	pmtrace_t	tr;
; 563  : 
; 564  : 	if( fplayersound ) return gain; // unchanged

	cmp	DWORD PTR _fplayersound$[ebp], 0
	je	SHORT $LN8@SND_GetGai
	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN8@SND_GetGai:

; 565  : 
; 566  : 	// during signon just apply regular state machine since world hasn't been
; 567  : 	// created or settled yet...
; 568  : 	if( !CL_Active( ))

	call	_CL_Active
	test	eax, eax
	jne	SHORT $LN9@SND_GetGai

; 569  : 	{
; 570  : 		gain = SND_FadeToNewGain( ch, -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 571  : 		return gain;

	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN9@SND_GetGai:

; 572  : 	}
; 573  : 
; 574  : 	// don't do gain obscuring more than once on short one-shot sounds
; 575  : 	if( !ch->bfirstpass && !ch->isSentence && !flooping && ( ch->entchannel != CHAN_STREAM ))

	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+112], 0
	jne	SHORT $LN10@SND_GetGai
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN10@SND_GetGai
	cmp	DWORD PTR _flooping$[ebp], 0
	jne	SHORT $LN10@SND_GetGai
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+32], 5
	je	SHORT $LN10@SND_GetGai

; 576  : 	{
; 577  : 		gain = SND_FadeToNewGain( ch, -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 578  : 		return gain;

	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN10@SND_GetGai:

; 579  : 	}
; 580  : 
; 581  : 	// if long or looping sound, process N channels per frame - set 'processed' flag, clear by
; 582  : 	// cycling through all channels - this maintains a cap on traces per frame
; 583  : 	if( !SND_ChannelOkToTrace( ch ))

	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_SND_ChannelOkToTrace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SND_GetGai

; 584  : 	{
; 585  : 		// just keep updating fade to existing target gain - no new trace checking
; 586  : 		gain = SND_FadeToNewGain( ch, -1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 587  : 		return gain;

	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN11@SND_GetGai:

; 588  : 	}
; 589  : 
; 590  : 	// set up traceline from player eyes to sound emitting entity origin
; 591  : 	VectorCopy( ch->origin, endpoint );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [eax+edx+36]
	mov	DWORD PTR _endpoint$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _endpoint$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+36]
	mov	DWORD PTR _endpoint$[ebp+edx], ecx

; 592  : 
; 593  : 	tr = CL_TraceLine( s_listener.origin, endpoint, PM_STUDIO_IGNORE );

	push	1
	lea	edx, DWORD PTR _endpoint$[ebp]
	push	edx
	push	OFFSET _s_listener
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 594  : 
; 595  : 	if(( tr.fraction < 1.0f || tr.allsolid || tr.startsolid ) && tr.fraction < 0.99f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	ja	SHORT $LN13@SND_GetGai
	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN13@SND_GetGai
	cmp	DWORD PTR _tr$[ebp+4], 0
	je	$LN6@SND_GetGai
$LN13@SND_GetGai:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	jbe	$LN6@SND_GetGai

; 596  : 	{
; 597  : 		// can't see center of sound source:
; 598  : 		// build extents based on dB sndlvl of source,
; 599  : 		// test to see how many extents are visible,
; 600  : 		// drop gain by g_snd_obscured_loss_db per extent hidden
; 601  : 		vec3_t	endpoints[4];
; 602  : 		int	i, sndlvl = DIST_MULT_TO_SNDLVL( ch->dist_mult );

	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN24@SND_GetGai
	mov	edx, DWORD PTR _s_refdb
	movss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv720[ebp]
	movsd	xmm0, QWORD PTR tv720[ebp]
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _s_refdist
	movss	xmm1, DWORD PTR [eax+48]
	mulss	xmm1, DWORD PTR [ecx+12]
	cvtss2sd xmm1, xmm1
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log10
	add	esp, 8
	fstp	QWORD PTR tv728[ebp]
	movsd	xmm0, QWORD PTR tv728[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR tv161[ebp], xmm0
	jmp	SHORT $LN25@SND_GetGai
$LN24@SND_GetGai:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv161[ebp], xmm0
$LN25@SND_GetGai:
	cvttsd2si edx, QWORD PTR tv161[ebp]
	mov	DWORD PTR _sndlvl$3[ebp], edx

; 603  : 		vec3_t	vecl, vecr, vecl2, vecr2;
; 604  : 		vec3_t	vsrc_forward;
; 605  : 		vec3_t	vsrc_right;
; 606  : 		vec3_t	vsrc_up;
; 607  : 		float	radius;
; 608  : 
; 609  : 		// get radius
; 610  : 		if( ch->radius > 0 ) radius = ch->radius;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN14@SND_GetGai
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	movss	DWORD PTR _radius$8[ebp], xmm0
	jmp	SHORT $LN15@SND_GetGai
$LN14@SND_GetGai:

; 611  : 		else radius = dB_To_Radius( sndlvl ); // approximate radius from soundlevel

	cvtsi2ss xmm0, DWORD PTR _sndlvl$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_dB_To_Radius
	add	esp, 4
	fstp	DWORD PTR _radius$8[ebp]
$LN15@SND_GetGai:

; 612  : 		
; 613  : 		// set up extent endpoints - on upward or downward diagonals, facing player
; 614  : 		for( i = 0; i < 4; i++ ) VectorCopy( endpoint, endpoints[i] );

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN4@SND_GetGai
$LN2@SND_GetGai:
	mov	edx, DWORD PTR _i$7[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7[ebp], edx
$LN4@SND_GetGai:
	cmp	DWORD PTR _i$7[ebp], 4
	jge	SHORT $LN3@SND_GetGai
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$7[ebp], 12
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	ecx, DWORD PTR _endpoint$[ebp+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$7[ebp], 12
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	edx, DWORD PTR _endpoint$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$7[ebp], 12
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _endpoint$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
	jmp	SHORT $LN2@SND_GetGai
$LN3@SND_GetGai:

; 615  : 
; 616  : 		// vsrc_forward is normalized vector from sound source to listener
; 617  : 		VectorSubtract( s_listener.origin, endpoint, vsrc_forward );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _s_listener[edx]
	subss	xmm0, DWORD PTR _endpoint$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vsrc_forward$14[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _s_listener[ecx]
	subss	xmm0, DWORD PTR _endpoint$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vsrc_forward$14[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _s_listener[ecx]
	subss	xmm0, DWORD PTR _endpoint$[ebp+edx]
	movss	DWORD PTR tv209[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR _vsrc_forward$14[ebp+eax], xmm0

; 618  : 		VectorNormalize( vsrc_forward );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vsrc_forward$14[ebp+edx]
	mulss	xmm0, DWORD PTR _vsrc_forward$14[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _vsrc_forward$14[ebp+edx]
	mulss	xmm1, DWORD PTR _vsrc_forward$14[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _vsrc_forward$14[ebp+ecx]
	mulss	xmm1, DWORD PTR _vsrc_forward$14[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$6[ebp]
	movss	xmm0, DWORD PTR _ilength$6[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@SND_GetGai
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$6[ebp]
	movss	DWORD PTR _ilength$6[ebp], xmm0
$LN16@SND_GetGai:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vsrc_forward$14[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$6[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vsrc_forward$14[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vsrc_forward$14[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$6[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vsrc_forward$14[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vsrc_forward$14[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$6[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vsrc_forward$14[ebp+ecx], xmm0

; 619  : 		VectorVectors( vsrc_forward, vsrc_right, vsrc_up );

	lea	edx, DWORD PTR _vsrc_up$13[ebp]
	push	edx
	lea	eax, DWORD PTR _vsrc_right$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _vsrc_forward$14[ebp]
	push	ecx
	call	_VectorVectors
	add	esp, 12					; 0000000cH

; 620  : 
; 621  : 		VectorAdd( vsrc_up, vsrc_right, vecl );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+eax]
	addss	xmm0, DWORD PTR _vsrc_right$12[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecl$16[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+edx]
	addss	xmm0, DWORD PTR _vsrc_right$12[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecl$16[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+edx]
	addss	xmm0, DWORD PTR _vsrc_right$12[ebp+eax]
	movss	DWORD PTR tv272[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv272[ebp]
	movss	DWORD PTR _vecl$16[ebp+ecx], xmm0

; 622  : 		
; 623  : 		// if src above listener, force 'up' vector to point down - create diagonals up & down
; 624  : 		if( endpoint[2] > s_listener.origin[2] + ( 10 * 12 ))

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _s_listener[eax]
	addss	xmm0, DWORD PTR __real@42f00000
	movss	xmm1, DWORD PTR _endpoint$[ebp+edx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@SND_GetGai

; 625  : 			vsrc_up[2] = -vsrc_up[2];

	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vsrc_up$13[ebp+edx], xmm0
$LN17@SND_GetGai:

; 626  : 
; 627  : 		VectorSubtract( vsrc_up, vsrc_right, vecr );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+ecx]
	subss	xmm0, DWORD PTR _vsrc_right$12[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecr$15[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+eax]
	subss	xmm0, DWORD PTR _vsrc_right$12[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecr$15[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vsrc_up$13[ebp+eax]
	subss	xmm0, DWORD PTR _vsrc_right$12[ebp+ecx]
	movss	DWORD PTR tv304[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv304[ebp]
	movss	DWORD PTR _vecr$15[ebp+edx], xmm0

; 628  : 		VectorNormalize( vecl );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecl$16[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecl$16[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecl$16[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecl$16[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecl$16[ebp+eax]
	mulss	xmm1, DWORD PTR _vecl$16[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$5[ebp]
	movss	xmm0, DWORD PTR _ilength$5[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN18@SND_GetGai
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$5[ebp]
	movss	DWORD PTR _ilength$5[ebp], xmm0
$LN18@SND_GetGai:
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecl$16[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecl$16[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecl$16[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecl$16[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _vecl$16[ebp+edx]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _vecl$16[ebp+eax], xmm0

; 629  : 		VectorNormalize( vecr );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecr$15[ebp+edx]
	mulss	xmm0, DWORD PTR _vecr$15[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _vecr$15[ebp+edx]
	mulss	xmm1, DWORD PTR _vecr$15[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _vecr$15[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecr$15[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$4[ebp]
	movss	xmm0, DWORD PTR _ilength$4[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@SND_GetGai
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$4[ebp]
	movss	DWORD PTR _ilength$4[ebp], xmm0
$LN19@SND_GetGai:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecr$15[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecr$15[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vecr$15[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecr$15[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecr$15[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vecr$15[ebp+ecx], xmm0

; 630  : 
; 631  : 		// get diagonal vectors from sound source 
; 632  : 		VectorScale( vecl, radius, vecl2 );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecl$16[ebp+eax]
	mulss	xmm0, DWORD PTR _radius$8[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecl2$10[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecl$16[ebp+eax]
	mulss	xmm0, DWORD PTR _radius$8[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecl2$10[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _vecl$16[ebp+edx]
	mulss	xmm0, DWORD PTR _radius$8[ebp]
	movss	DWORD PTR tv397[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR _vecl2$10[ebp+eax], xmm0

; 633  : 		VectorScale( vecr, radius, vecr2 );

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _vecr$15[ebp+edx]
	mulss	xmm0, DWORD PTR _radius$8[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecr2$9[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _vecr$15[ebp+edx]
	mulss	xmm0, DWORD PTR _radius$8[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vecr2$9[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vecr$15[ebp+ecx]
	mulss	xmm0, DWORD PTR _radius$8[ebp]
	movss	DWORD PTR tv412[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv412[ebp]
	movss	DWORD PTR _vecr2$9[ebp+edx], xmm0

; 634  : 		VectorScale( vecl, (radius / 2.0f), vecl );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _radius$8[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecl$16[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecl$16[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _radius$8[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecl$16[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecl$16[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _radius$8[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _vecl$16[ebp+eax]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv436[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv436[ebp]
	movss	DWORD PTR _vecl$16[ebp+ecx], xmm0

; 635  : 		VectorScale( vecr, (radius / 2.0f), vecr );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _radius$8[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecr$15[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecr$15[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _radius$8[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecr$15[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecr$15[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _radius$8[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _vecr$15[ebp+edx]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv460[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv460[ebp]
	movss	DWORD PTR _vecr$15[ebp+eax], xmm0

; 636  : 
; 637  : 		// endpoints from diagonal vectors
; 638  : 		VectorAdd( endpoints[0], vecl, endpoints[0] );

	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _vecl$16[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecl$16[ebp+edx]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecl$16[ebp+edx]
	movss	DWORD PTR tv493[ebp], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv493[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 639  : 		VectorAdd( endpoints[1], vecr, endpoints[1] );

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _vecr$15[ebp+eax]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecr$15[ebp+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _vecr$15[ebp+eax]
	movss	DWORD PTR tv526[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv526[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 640  : 		VectorAdd( endpoints[2], vecl2, endpoints[2] );

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _vecl2$10[ebp+eax]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecl2$10[ebp+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _vecl2$10[ebp+eax]
	movss	DWORD PTR tv559[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv559[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 641  : 		VectorAdd( endpoints[3], vecr2, endpoints[3] );

	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _vecr2$9[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _endpoints$11[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecr2$9[ebp+edx]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecr2$9[ebp+edx]
	movss	DWORD PTR tv592[ebp], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _endpoints$11[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv592[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 642  : 
; 643  : 		// drop gain for each point on radius diagonal that is obscured
; 644  : 		for( count = 0, i = 0; i < 4; i++ )

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN7@SND_GetGai
$LN5@SND_GetGai:
	mov	ecx, DWORD PTR _i$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7[ebp], ecx
$LN7@SND_GetGai:
	cmp	DWORD PTR _i$7[ebp], 4
	jge	$LN6@SND_GetGai

; 645  : 		{
; 646  : 			// UNDONE: some endpoints are in walls - in this case, trace from the wall hit location
; 647  : 			tr = CL_TraceLine( s_listener.origin, endpoints[i], PM_STUDIO_IGNORE );

	push	1
	imul	edx, DWORD PTR _i$7[ebp], 12
	lea	eax, DWORD PTR _endpoints$11[ebp+edx]
	push	eax
	push	OFFSET _s_listener
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 648  : 
; 649  : 			if(( tr.fraction < 1.0f || tr.allsolid || tr.startsolid ) && tr.fraction < 0.99f && !tr.startsolid )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	ja	SHORT $LN21@SND_GetGai
	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN21@SND_GetGai
	cmp	DWORD PTR _tr$[ebp+4], 0
	je	SHORT $LN22@SND_GetGai
$LN21@SND_GetGai:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	jbe	SHORT $LN22@SND_GetGai
	cmp	DWORD PTR _tr$[ebp+4], 0
	jne	SHORT $LN22@SND_GetGai

; 650  : 			{
; 651  : 				// skip first obscured point: at least 2 points + center should be obscured to hear db loss
; 652  : 				if( ++count > 1 ) gain = gain * dB_To_Gain( SND_OBSCURED_LOSS_DB );

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
	cmp	DWORD PTR _count$[ebp], 1
	jle	SHORT $LN22@SND_GetGai
	push	ecx
	movss	xmm0, DWORD PTR __real@c02ccccd
	movss	DWORD PTR [esp], xmm0
	call	_dB_To_Gain
	add	esp, 4
	fstp	DWORD PTR tv1033[ebp]
	movss	xmm0, DWORD PTR tv1033[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0
$LN22@SND_GetGai:

; 653  : 			}
; 654  : 		}

	jmp	$LN5@SND_GetGai
$LN6@SND_GetGai:

; 655  : 	}
; 656  : 
; 657  : 	// crossfade to new gain
; 658  : 	gain = SND_FadeToNewGain( ch, gain );

	push	ecx
	movss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 659  : 
; 660  : 	return gain;

	fld	DWORD PTR _gain$[ebp]
$LN1@SND_GetGai:

; 661  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_GetGainObscured ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv179 = -24						; size = 8
tv152 = -16						; size = 8
_speed$ = -8						; size = 4
_frametime$ = -4					; size = 4
_ch$ = 8						; size = 4
_gain_new$ = 12						; size = 4
_SND_FadeToNewGain PROC

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 508  : 	float	speed, frametime;
; 509  : 
; 510  : 	if( gain_new == -1.0 )

	cvtss2sd xmm0, DWORD PTR _gain_new$[ebp]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SND_FadeTo

; 511  : 	{
; 512  : 		// if -1 passed in, just keep fading to existing target
; 513  : 		gain_new = ch->ob_gain_target;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+120]
	movss	DWORD PTR _gain_new$[ebp], xmm0
$LN2@SND_FadeTo:

; 514  : 	}
; 515  : 
; 516  : 	// if first time updating, store new gain into gain & target, return
; 517  : 	// if gain_new is close to existing gain, store new gain into gain & target, return
; 518  : 	if( ch->bfirstpass || ( fabs( gain_new - ch->ob_gain ) < 0.01f ))

	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+112], 0
	jne	SHORT $LN4@SND_FadeTo
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	subss	xmm0, DWORD PTR [edx+116]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv152[ebp]
	movsd	xmm0, QWORD PTR __real@3f847ae140000000
	comisd	xmm0, QWORD PTR tv152[ebp]
	jbe	SHORT $LN3@SND_FadeTo
$LN4@SND_FadeTo:

; 519  : 	{
; 520  : 		ch->ob_gain = gain_new;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	movss	DWORD PTR [eax+116], xmm0

; 521  : 		ch->ob_gain_target = gain_new;

	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	movss	DWORD PTR [ecx+120], xmm0

; 522  : 		ch->ob_gain_inc = 0.0f;

	mov	edx, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+124], xmm0

; 523  : 		return gain_new;

	fld	DWORD PTR _gain_new$[ebp]
	jmp	$LN1@SND_FadeTo
$LN3@SND_FadeTo:

; 524  : 	}
; 525  : 
; 526  : 	// set up new increment to new target
; 527  : 	frametime = s_listener.frametime;

	movss	xmm0, DWORD PTR _s_listener+68
	movss	DWORD PTR _frametime$[ebp], xmm0

; 528  : 	speed = ( frametime / SND_GAIN_FADE_TIME ) * ( gain_new - ch->ob_gain );

	movss	xmm0, DWORD PTR _frametime$[ebp]
	divss	xmm0, DWORD PTR __real@3e800000
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm1, DWORD PTR _gain_new$[ebp]
	subss	xmm1, DWORD PTR [eax+116]
	mulss	xmm0, xmm1
	movss	DWORD PTR _speed$[ebp], xmm0

; 529  : 
; 530  : 	ch->ob_gain_inc = fabs( speed );

	cvtss2sd xmm0, DWORD PTR _speed$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	mov	ecx, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [ecx+124]

; 531  : 
; 532  : 	// ch->ob_gain_inc = fabs( gain_new - ch->ob_gain ) / 10.0f;
; 533  : 	ch->ob_gain_target = gain_new;

	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 534  : 
; 535  : 	// if not hit target, keep approaching
; 536  : 	if( fabs( ch->ob_gain - ch->ob_gain_target ) > 0.01f )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+116]
	subss	xmm0, DWORD PTR [ecx+120]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv179[ebp]
	movsd	xmm0, QWORD PTR tv179[ebp]
	comisd	xmm0, QWORD PTR __real@3f847ae140000000
	jbe	SHORT $LN5@SND_FadeTo

; 537  : 	{
; 538  : 		ch->ob_gain = ApproachVal( ch->ob_gain_target, ch->ob_gain, ch->ob_gain_inc );

	mov	edx, DWORD PTR _ch$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+124]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+120]
	movss	DWORD PTR [esp], xmm0
	call	_ApproachVal
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [edx+116]

; 539  : 	}

	jmp	SHORT $LN6@SND_FadeTo
$LN5@SND_FadeTo:

; 540  : 	else
; 541  : 	{
; 542  : 		// close enough, set gain = target
; 543  : 		ch->ob_gain = ch->ob_gain_target;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR [eax+116], edx
$LN6@SND_FadeTo:

; 544  : 	}
; 545  : 
; 546  : 	return ch->ob_gain;

	mov	eax, DWORD PTR _ch$[ebp]
	fld	DWORD PTR [eax+116]
$LN1@SND_FadeTo:

; 547  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_FadeToNewGain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_channel$ = 12						; size = 4
_sfx$ = 16						; size = 4
_vol$ = 20						; size = 4
_pitch$ = 24						; size = 4
_flags$ = 28						; size = 4
_S_AlterChannel PROC

; 446  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 447  : 	channel_t	*ch;
; 448  : 	int	i;	
; 449  : 
; 450  : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	$LN8@S_AlterCha

; 451  : 	{
; 452  : 		// This is a sentence name.
; 453  : 		// For sentences: assume that the entity is only playing one sentence
; 454  : 		// at a time, so we can just shut off
; 455  : 		// any channel that has ch->isSentence >= 0 and matches the entnum.
; 456  : 
; 457  : 		for( i = NUM_AMBIENTS, ch = channels + NUM_AMBIENTS; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 4
	mov	DWORD PTR _ch$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN4@S_AlterCha
$LN2@S_AlterCha:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], edx
$LN4@S_AlterCha:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN3@S_AlterCha

; 458  : 		{
; 459  : 			if( ch->entnum == entnum && ch->entchannel == channel && ch->sfx && ch->isSentence )

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _channel$[ebp]
	jne	SHORT $LN9@S_AlterCha
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN9@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN9@S_AlterCha

; 460  : 			{
; 461  : 				if( flags & SND_CHANGE_PITCH )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN10@S_AlterCha

; 462  : 					ch->basePitch = pitch;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [edx+60], eax
$LN10@S_AlterCha:

; 463  : 				
; 464  : 				if( flags & SND_CHANGE_VOL )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN11@S_AlterCha

; 465  : 					ch->master_vol = vol;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN11@S_AlterCha:

; 466  : 				
; 467  : 				if( flags & SND_STOP )

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN12@S_AlterCha

; 468  : 					S_FreeChannel( ch );

	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_S_FreeChannel
	add	esp, 4
$LN12@S_AlterCha:

; 469  : 
; 470  : 				return true;

	mov	eax, 1
	jmp	$LN1@S_AlterCha
$LN9@S_AlterCha:

; 471  : 			}
; 472  : 		}

	jmp	$LN2@S_AlterCha
$LN3@S_AlterCha:

; 473  : 		// channel not found
; 474  : 		return false;

	xor	eax, eax
	jmp	$LN1@S_AlterCha
$LN8@S_AlterCha:

; 475  : 
; 476  : 	}
; 477  : 
; 478  : 	// regular sound or streaming sound
; 479  : 	for( i = NUM_AMBIENTS, ch = channels + NUM_AMBIENTS; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 4
	mov	DWORD PTR _ch$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN7@S_AlterCha
$LN5@S_AlterCha:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN7@S_AlterCha:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _total_channels
	jge	SHORT $LN6@S_AlterCha

; 480  : 	{
; 481  : 		if( ch->entnum == entnum && ch->entchannel == channel && ch->sfx == sfx )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN13@S_AlterCha
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR _channel$[ebp]
	jne	SHORT $LN13@S_AlterCha
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN13@S_AlterCha

; 482  : 		{
; 483  : 			if( flags & SND_CHANGE_PITCH )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN14@S_AlterCha

; 484  : 				ch->basePitch = pitch;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [ecx+60], edx
$LN14@S_AlterCha:

; 485  : 				
; 486  : 			if( flags & SND_CHANGE_VOL )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN15@S_AlterCha

; 487  : 				ch->master_vol = vol;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [ecx+52], edx
$LN15@S_AlterCha:

; 488  : 
; 489  : 			if( flags & SND_STOP )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN16@S_AlterCha

; 490  : 				S_FreeChannel( ch );

	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_S_FreeChannel
	add	esp, 4
$LN16@S_AlterCha:

; 491  : 
; 492  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@S_AlterCha
$LN13@S_AlterCha:

; 493  : 		}
; 494  : 	}

	jmp	$LN5@S_AlterCha
$LN6@S_AlterCha:

; 495  : 	return false;

	xor	eax, eax
$LN1@S_AlterCha:

; 496  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_AlterChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch_idx$ = -4						; size = 4
_sfx$ = 8						; size = 4
_SND_FStreamIsPlaying PROC

; 286  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 287  : 	int	ch_idx;
; 288  : 
; 289  : 	for( ch_idx = NUM_AMBIENTS; ch_idx < MAX_DYNAMIC_CHANNELS; ch_idx++ )

	mov	DWORD PTR _ch_idx$[ebp], 4
	jmp	SHORT $LN4@SND_FStrea
$LN2@SND_FStrea:
	mov	eax, DWORD PTR _ch_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ch_idx$[ebp], eax
$LN4@SND_FStrea:
	cmp	DWORD PTR _ch_idx$[ebp], 64		; 00000040H
	jge	SHORT $LN3@SND_FStrea

; 290  : 	{
; 291  : 		if( channels[ch_idx].sfx == sfx )

	imul	ecx, DWORD PTR _ch_idx$[ebp], 2480
	mov	edx, DWORD PTR _channels[ecx+16]
	cmp	edx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN5@SND_FStrea

; 292  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_FStrea
$LN5@SND_FStrea:

; 293  : 	}

	jmp	SHORT $LN2@SND_FStrea
$LN3@SND_FStrea:

; 294  : 
; 295  : 	return false;

	xor	eax, eax
$LN1@SND_FStrea:

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_FStreamIsPlaying ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SND_ChannelTraceReset PROC

; 257  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 258  : 	int	i;
; 259  : 
; 260  : 	// reset search point - make sure we start counting from a new spot 
; 261  : 	// in channel list each time
; 262  : 	last_trace_chan += SND_TRACE_UPDATE_MAX;

	mov	eax, DWORD PTR _last_trace_chan
	add	eax, 2
	mov	DWORD PTR _last_trace_chan, eax

; 263  : 	
; 264  : 	// wrap at total_channels
; 265  : 	if( last_trace_chan >= total_channels )

	mov	ecx, DWORD PTR _last_trace_chan
	cmp	ecx, DWORD PTR _total_channels
	jl	SHORT $LN5@SND_Channe

; 266  : 		last_trace_chan = last_trace_chan - total_channels;

	mov	edx, DWORD PTR _last_trace_chan
	sub	edx, DWORD PTR _total_channels
	mov	DWORD PTR _last_trace_chan, edx
$LN5@SND_Channe:

; 267  : 
; 268  : 	// reset traceline counter
; 269  : 	trace_count = 0;

	mov	DWORD PTR _trace_count, 0

; 270  : 
; 271  : 	// reset channel traceline flag
; 272  : 	for( i = 0; i < total_channels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SND_Channe
$LN2@SND_Channe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SND_Channe:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _total_channels
	jge	SHORT $LN1@SND_Channe

; 273  : 		channels[i].bTraced = false; 

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	DWORD PTR _channels[edx+128], 0
	jmp	SHORT $LN2@SND_Channe
$LN1@SND_Channe:

; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_ChannelTraceReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_j$ = -4						; size = 4
_ch$ = 8						; size = 4
_SND_ChannelOkToTrace PROC

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 219  : 	int 	i, j;
; 220  : 
; 221  : 	// always trace first time sound is spatialized
; 222  : 	if( ch->bfirstpass ) return true;

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+112], 0
	je	SHORT $LN5@SND_Channe
	mov	eax, 1
	jmp	$LN1@SND_Channe
$LN5@SND_Channe:

; 223  : 
; 224  : 	// if already traced max channels, return
; 225  : 	if( trace_count >= SND_TRACE_UPDATE_MAX )

	cmp	DWORD PTR _trace_count, 2
	jl	SHORT $LN6@SND_Channe

; 226  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SND_Channe
$LN6@SND_Channe:

; 227  : 
; 228  : 	// search through all channels starting at g_snd_last_trace_chan index
; 229  : 	j = last_trace_chan;

	mov	ecx, DWORD PTR _last_trace_chan
	mov	DWORD PTR _j$[ebp], ecx

; 230  : 
; 231  :  	for( i = 0; i < total_channels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SND_Channe
$LN2@SND_Channe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SND_Channe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN3@SND_Channe

; 232  : 	{
; 233  : 		if( &( channels[j] ) == ch )

	imul	ecx, DWORD PTR _j$[ebp], 2480
	add	ecx, OFFSET _channels
	cmp	ecx, DWORD PTR _ch$[ebp]
	jne	SHORT $LN7@SND_Channe

; 234  : 		{
; 235  : 			ch->bTraced = true;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+128], 1

; 236  : 			trace_count++;

	mov	eax, DWORD PTR _trace_count
	add	eax, 1
	mov	DWORD PTR _trace_count, eax

; 237  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_Channe
$LN7@SND_Channe:

; 238  : 		}
; 239  : 
; 240  : 		// wrap channel index
; 241  : 		if( ++j >= total_channels )

	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _total_channels
	jl	SHORT $LN8@SND_Channe

; 242  : 			j = 0;

	mov	DWORD PTR _j$[ebp], 0
$LN8@SND_Channe:

; 243  : 	}

	jmp	SHORT $LN2@SND_Channe
$LN3@SND_Channe:

; 244  : 	
; 245  : 	// why didn't we find this channel?
; 246  : 	return false;			

	xor	eax, eax
$LN1@SND_Channe:

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_ChannelOkToTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv91 = -20						; size = 4
tv90 = -16						; size = 4
_totaltime$ = -12					; size = 4
_elapsed$ = -8						; size = 4
_f$ = -4						; size = 4
_S_UpdateSoundFade PROC

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 159  : 	float	f, totaltime, elapsed;
; 160  : 
; 161  : 	// determine current fade value.
; 162  : 	// assume no fading remains
; 163  : 	soundfade.percent = 0;  

	xorps	xmm0, xmm0
	movss	DWORD PTR _soundfade+4, xmm0

; 164  : 
; 165  : 	totaltime = soundfade.fadeouttime + soundfade.fadeintime + soundfade.holdtime;

	movss	xmm0, DWORD PTR _soundfade+12
	addss	xmm0, DWORD PTR _soundfade+20
	addss	xmm0, DWORD PTR _soundfade+16
	movss	DWORD PTR _totaltime$[ebp], xmm0

; 166  : 
; 167  : 	elapsed = cl.mtime[0] - soundfade.starttime;

	mov	eax, 8
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _soundfade+8
	movsd	xmm1, QWORD PTR _cl[ecx+32]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _elapsed$[ebp], xmm0

; 168  : 
; 169  : 	// clock wrapped or reset (BUG) or we've gone far enough
; 170  : 	if( elapsed < 0.0f || elapsed >= totaltime || totaltime <= 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _elapsed$[ebp]
	ja	SHORT $LN3@S_UpdateSo
	movss	xmm0, DWORD PTR _elapsed$[ebp]
	comiss	xmm0, DWORD PTR _totaltime$[ebp]
	jae	SHORT $LN3@S_UpdateSo
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _totaltime$[ebp]
	jb	SHORT $LN2@S_UpdateSo
$LN3@S_UpdateSo:

; 171  : 		return;

	jmp	$LN9@S_UpdateSo
$LN2@S_UpdateSo:

; 172  : 
; 173  : 	// We are in the fade time, so determine amount of fade.
; 174  : 	if( soundfade.fadeouttime > 0.0f && ( elapsed < soundfade.fadeouttime ))

	movss	xmm0, DWORD PTR _soundfade+12
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@S_UpdateSo
	movss	xmm0, DWORD PTR _soundfade+12
	comiss	xmm0, DWORD PTR _elapsed$[ebp]
	jbe	SHORT $LN4@S_UpdateSo

; 175  : 	{
; 176  : 		// ramp up
; 177  : 		f = elapsed / soundfade.fadeouttime;

	movss	xmm0, DWORD PTR _elapsed$[ebp]
	divss	xmm0, DWORD PTR _soundfade+12
	movss	DWORD PTR _f$[ebp], xmm0

; 178  : 	}

	jmp	SHORT $LN7@S_UpdateSo
$LN4@S_UpdateSo:

; 179  : 	else if( elapsed <= ( soundfade.fadeouttime + soundfade.holdtime ))	// Inside the hold time

	movss	xmm0, DWORD PTR _soundfade+12
	addss	xmm0, DWORD PTR _soundfade+16
	comiss	xmm0, DWORD PTR _elapsed$[ebp]
	jb	SHORT $LN6@S_UpdateSo

; 180  : 	{
; 181  : 		// stay
; 182  : 		f = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _f$[ebp], xmm0

; 183  : 	}

	jmp	SHORT $LN7@S_UpdateSo
$LN6@S_UpdateSo:

; 184  : 	else
; 185  : 	{
; 186  : 		// ramp down
; 187  : 		f = ( elapsed - ( soundfade.fadeouttime + soundfade.holdtime ) ) / soundfade.fadeintime;

	movss	xmm0, DWORD PTR _soundfade+12
	addss	xmm0, DWORD PTR _soundfade+16
	movss	xmm1, DWORD PTR _elapsed$[ebp]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR _soundfade+20
	movss	DWORD PTR _f$[ebp], xmm1

; 188  : 		f = 1.0f - f; // backward interpolated...

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _f$[ebp], xmm0
$LN7@S_UpdateSo:

; 189  : 	}
; 190  : 
; 191  : 	// spline it.
; 192  : 	f = SimpleSpline( f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SimpleSpline
	add	esp, 4
	fstp	DWORD PTR _f$[ebp]

; 193  : 	f = bound( 0.0f, f, 1.0f );

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN13@S_UpdateSo
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN11@S_UpdateSo
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN12@S_UpdateSo
$LN11@S_UpdateSo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv90[ebp], xmm0
$LN12@S_UpdateSo:
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR tv91[ebp], xmm0
	jmp	SHORT $LN14@S_UpdateSo
$LN13@S_UpdateSo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv91[ebp], xmm0
$LN14@S_UpdateSo:
	movss	xmm0, DWORD PTR tv91[ebp]
	movss	DWORD PTR _f$[ebp], xmm0

; 194  : 
; 195  : 	soundfade.percent = soundfade.initial_percent * f;

	movss	xmm0, DWORD PTR _soundfade
	mulss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _soundfade+4, xmm0

; 196  : 
; 197  : 	if( snd_fade_sequence )

	cmp	DWORD PTR _snd_fade_sequence, 0
	je	SHORT $LN8@S_UpdateSo

; 198  : 		S_FadeMusicVolume( soundfade.percent );

	push	ecx
	movss	xmm0, DWORD PTR _soundfade+4
	movss	DWORD PTR [esp], xmm0
	call	_S_FadeMusicVolume
	add	esp, 4
$LN8@S_UpdateSo:

; 199  : 
; 200  : 	if( snd_fade_sequence && soundfade.percent == 100.0f )

	cmp	DWORD PTR _snd_fade_sequence, 0
	je	SHORT $LN9@S_UpdateSo
	movss	xmm0, DWORD PTR _soundfade+4
	ucomiss	xmm0, DWORD PTR __real@42c80000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@S_UpdateSo

; 201  : 	{
; 202  : 		S_StopAllSounds( false );

	push	0
	call	_S_StopAllSounds
	add	esp, 4

; 203  : 		S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 204  : 		snd_fade_sequence = false;

	mov	DWORD PTR _snd_fade_sequence, 0
$LN9@S_UpdateSo:

; 205  : 	}
; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateSoundFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_entnum$ = 8						; size = 4
_S_IsClient PROC

; 125  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 126  : 	return ( entnum == s_listener.entnum );

	mov	eax, DWORD PTR _entnum$[ebp]
	cmp	eax, DWORD PTR _s_listener+60
	jne	SHORT $LN3@S_IsClient
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@S_IsClient
$LN3@S_IsClient:
	mov	DWORD PTR tv65[ebp], 0
$LN4@S_IsClient:
	mov	eax, DWORD PTR tv65[ebp]

; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_IsClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
;	COMDAT _dB_To_Radius
_TEXT	SEGMENT
tv74 = -4						; size = 4
_db$ = 8						; size = 4
_dB_To_Radius PROC					; COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 78   : 	return (SND_RADIUS_MIN + (SND_RADIUS_MAX - SND_RADIUS_MIN) * (db - SND_DB_MIN) / (SND_DB_MAX - SND_DB_MIN));

	movss	xmm0, DWORD PTR _db$[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	mulss	xmm0, DWORD PTR __real@43580000
	divss	xmm0, DWORD PTR __real@42a00000
	addss	xmm0, DWORD PTR __real@41c00000
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_dB_To_Radius ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
;	COMDAT _dB_To_Gain
_TEXT	SEGMENT
tv76 = -4						; size = 4
_dB$ = 8						; size = 4
_dB_To_Gain PROC					; COMDAT

; 70   : _inline float dB_To_Gain ( float dB ) { return pow( 10, dB / 20.0f ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _dB$[ebp]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv76[ebp]
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_dB_To_Gain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_ExtraUpdate PROC

; 1942 : {

	push	ebp
	mov	ebp, esp

; 1943 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_ExtraUpd
	jmp	SHORT $LN1@S_ExtraUpd
$LN2@S_ExtraUpd:

; 1944 : 	S_UpdateChannels ();

	call	_S_UpdateChannels
$LN1@S_ExtraUpd:

; 1945 : }

	pop	ebp
	ret	0
_S_ExtraUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv206 = -52						; size = 4
tv86 = -48						; size = 4
_total$ = -44						; size = 4
_j$ = -40						; size = 4
_i$ = -36						; size = 4
_combine$ = -32						; size = 4
_ch$ = -28						; size = 4
_info$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_SND_UpdateSound PROC

; 1972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1973 : 	int		i, j, total;
; 1974 : 	channel_t		*ch, *combine;
; 1975 : 	con_nprint_t	info;
; 1976 : 
; 1977 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN11@SND_Update
	jmp	$LN1@SND_Update
$LN11@SND_Update:

; 1978 : 
; 1979 : 	// if the loading plaque is up, clear everything
; 1980 : 	// out to make sure we aren't looping a dirty
; 1981 : 	// dma buffer while loading
; 1982 : 	// update any client side sound fade
; 1983 : 	S_UpdateSoundFade();

	call	_S_UpdateSoundFade

; 1984 : 
; 1985 : 	// release raw-channels that no longer used more than 10 secs
; 1986 : 	S_FreeIdleRawChannels();

	call	_S_FreeIdleRawChannels

; 1987 : 
; 1988 : 	VectorCopy( cl.simvel, s_listener.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+1568816]
	mov	DWORD PTR _s_listener[eax+12], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+1568816]
	mov	DWORD PTR _s_listener[eax+12], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+1568816]
	mov	DWORD PTR _s_listener[eax+12], ecx

; 1989 : 	s_listener.frametime = (cl.time - cl.oldtime);

	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR _cl+1525856
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s_listener+68, xmm0

; 1990 : 	s_listener.waterlevel = cl.local.waterlevel;

	mov	edx, DWORD PTR _cl+1568568
	mov	DWORD PTR _s_listener+64, edx

; 1991 : 	s_listener.active = CL_IsInGame();

	call	_CL_IsInGame
	mov	DWORD PTR _s_listener+72, eax

; 1992 : 	s_listener.inmenu = CL_IsInMenu();

	call	_CL_IsInMenu
	mov	DWORD PTR _s_listener+76, eax

; 1993 : 	s_listener.paused = cl.paused;

	mov	eax, DWORD PTR _cl+24
	mov	DWORD PTR _s_listener+80, eax

; 1994 : 
; 1995 : 	if( cl.worldmodel != NULL )

	cmp	DWORD PTR _cl+2686576, 0
	je	SHORT $LN12@SND_Update

; 1996 : 		Mod_FatPVS( s_listener.origin, FATPHS_RADIUS, s_listener.pasbytes, world.visbytes, false, !s_phs->value );

	mov	ecx, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@SND_Update
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN32@SND_Update
$LN31@SND_Update:
	mov	DWORD PTR tv86[ebp], 0
$LN32@SND_Update:
	mov	edx, DWORD PTR tv86[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _world+2592
	push	eax
	push	OFFSET _s_listener+92
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _s_listener
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN12@SND_Update:

; 1997 : 
; 1998 : 	// update general area ambient sound sources
; 1999 : 	S_UpdateAmbientSounds();

	call	_S_UpdateAmbientSounds

; 2000 : 
; 2001 : 	combine = NULL;

	mov	DWORD PTR _combine$[ebp], 0

; 2002 : 
; 2003 : 	// update spatialization for static and dynamic sounds	
; 2004 : 	for( i = NUM_AMBIENTS, ch = channels + NUM_AMBIENTS; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 4
	mov	DWORD PTR _ch$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN4@SND_Update
$LN2@SND_Update:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], edx
$LN4@SND_Update:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	$LN3@SND_Update

; 2005 : 	{
; 2006 : 		if( !ch->sfx ) continue;

	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN13@SND_Update
	jmp	SHORT $LN2@SND_Update
$LN13@SND_Update:

; 2007 : 		SND_Spatialize( ch ); // respatialize channel

	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_SND_Spatialize
	add	esp, 4

; 2008 : 
; 2009 : 		if( !ch->leftvol && !ch->rightvol )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN14@SND_Update
	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN14@SND_Update

; 2010 : 			continue;

	jmp	SHORT $LN2@SND_Update
$LN14@SND_Update:

; 2011 : 
; 2012 : 		// try to combine static sounds with a previous channel of the same
; 2013 : 		// sound effect so we don't mix five torches every frame
; 2014 : 		// g-cont: perfomance option, probably kill stereo effect in most cases
; 2015 : 		if( i >= MAX_DYNAMIC_CHANNELS && s_combine_sounds->value )

	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jl	$LN19@SND_Update
	mov	edx, DWORD PTR _s_combine_sounds
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN19@SND_Update

; 2016 : 		{
; 2017 : 			// see if it can just use the last one
; 2018 : 			if( combine && combine->sfx == ch->sfx )

	cmp	DWORD PTR _combine$[ebp], 0
	je	SHORT $LN16@SND_Update
	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN16@SND_Update

; 2019 : 			{
; 2020 : 				combine->leftvol += ch->leftvol;

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _ch$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2021 : 				combine->rightvol += ch->rightvol;

	mov	ecx, DWORD PTR _combine$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _ch$[ebp]
	add	edx, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2022 : 				ch->leftvol = ch->rightvol = 0;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+20], 0

; 2023 : 				continue;

	jmp	$LN2@SND_Update
$LN16@SND_Update:

; 2024 : 			}
; 2025 : 
; 2026 : 			// search for one
; 2027 : 			combine = channels + MAX_DYNAMIC_CHANNELS;

	mov	DWORD PTR _combine$[ebp], OFFSET _channels+158720

; 2028 : 
; 2029 : 			for( j = MAX_DYNAMIC_CHANNELS; j < i; j++, combine++ )

	mov	DWORD PTR _j$[ebp], 64			; 00000040H
	jmp	SHORT $LN7@SND_Update
$LN5@SND_Update:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	mov	edx, DWORD PTR _combine$[ebp]
	add	edx, 2480				; 000009b0H
	mov	DWORD PTR _combine$[ebp], edx
$LN7@SND_Update:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $LN6@SND_Update

; 2030 : 			{
; 2031 : 				if( combine->sfx == ch->sfx )

	mov	ecx, DWORD PTR _combine$[ebp]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN17@SND_Update

; 2032 : 					break;

	jmp	SHORT $LN6@SND_Update
$LN17@SND_Update:

; 2033 : 			}

	jmp	SHORT $LN5@SND_Update
$LN6@SND_Update:

; 2034 : 
; 2035 : 			if( j == total_channels )

	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _total_channels
	jne	SHORT $LN18@SND_Update

; 2036 : 			{
; 2037 : 				combine = NULL;

	mov	DWORD PTR _combine$[ebp], 0

; 2038 : 			}

	jmp	SHORT $LN19@SND_Update
$LN18@SND_Update:

; 2039 : 			else
; 2040 : 			{
; 2041 : 				if( combine != ch )

	mov	edx, DWORD PTR _combine$[ebp]
	cmp	edx, DWORD PTR _ch$[ebp]
	je	SHORT $LN20@SND_Update

; 2042 : 				{
; 2043 : 					combine->leftvol += ch->leftvol;

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _ch$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2044 : 					combine->rightvol += ch->rightvol;

	mov	ecx, DWORD PTR _combine$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _ch$[ebp]
	add	edx, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2045 : 					ch->leftvol = ch->rightvol = 0;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+20], 0
$LN20@SND_Update:

; 2046 : 				}
; 2047 : 				continue;

	jmp	$LN2@SND_Update
$LN19@SND_Update:

; 2048 : 			}
; 2049 : 		}
; 2050 : 	}

	jmp	$LN2@SND_Update
$LN3@SND_Update:

; 2051 : 
; 2052 : 	S_SpatializeRawChannels();

	call	_S_SpatializeRawChannels

; 2053 : 
; 2054 : 	// debugging output
; 2055 : 	if( CVAR_TO_BOOL( s_show ))

	cmp	DWORD PTR _s_show, 0
	je	SHORT $LN33@SND_Update
	mov	ecx, DWORD PTR _s_show
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN33@SND_Update
	mov	DWORD PTR tv206[ebp], 1
	jmp	SHORT $LN34@SND_Update
$LN33@SND_Update:
	mov	DWORD PTR tv206[ebp], 0
$LN34@SND_Update:
	cmp	DWORD PTR tv206[ebp], 0
	je	$LN21@SND_Update

; 2056 : 	{
; 2057 : 		info.color[0] = 1.0f;

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+eax+8], xmm0

; 2058 : 		info.color[1] = 0.6f;

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0

; 2059 : 		info.color[2] = 0.0f;

	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+edx+8], xmm0

; 2060 : 		info.time_to_live = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _info$[ebp+4], xmm0

; 2061 : 
; 2062 : 		for( i = 0, total = 1, ch = channels; i < MAX_CHANNELS; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _total$[ebp], 1
	mov	DWORD PTR _ch$[ebp], OFFSET _channels
	jmp	SHORT $LN10@SND_Update
$LN8@SND_Update:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN10@SND_Update:
	cmp	DWORD PTR _i$[ebp], 320			; 00000140H
	jge	$LN9@SND_Update

; 2063 : 		{
; 2064 : 			if( ch->sfx && ( ch->leftvol || ch->rightvol ))

	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN22@SND_Update
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN23@SND_Update
	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	$LN22@SND_Update
$LN23@SND_Update:

; 2065 : 			{
; 2066 : 				info.index = total;

	mov	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR _info$[ebp], edx

; 2067 : 				Con_NXPrintf( &info, "chan %i, pos (%.f %.f %.f) ent %i, lv%3i rv%3i %s\n",

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG144755
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_Con_NXPrintf
	add	esp, 52					; 00000034H

; 2068 : 				i, ch->origin[0], ch->origin[1], ch->origin[2], ch->entnum, ch->leftvol, ch->rightvol, ch->sfx->name );
; 2069 : 				total++;

	mov	edx, DWORD PTR _total$[ebp]
	add	edx, 1
	mov	DWORD PTR _total$[ebp], edx
$LN22@SND_Update:

; 2070 : 			}
; 2071 : 		}

	jmp	$LN8@SND_Update
$LN9@SND_Update:

; 2072 : 
; 2073 : 		// to differentiate modes
; 2074 : 		if( s_cull->value && s_phs->value )

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SND_Update
	mov	ecx, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SND_Update

; 2075 : 			VectorSet( info.color, 0.0f, 1.0f, 0.0f );

	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	jmp	$LN29@SND_Update
$LN24@SND_Update:

; 2076 : 		else if( s_phs->value )

	mov	eax, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@SND_Update

; 2077 : 			VectorSet( info.color, 1.0f, 1.0f, 0.0f );

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	jmp	$LN29@SND_Update
$LN26@SND_Update:

; 2078 : 		else if( s_cull->value )

	mov	edx, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@SND_Update

; 2079 : 			VectorSet( info.color, 1.0f, 0.0f, 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	jmp	SHORT $LN29@SND_Update
$LN28@SND_Update:

; 2080 : 		else VectorSet( info.color, 1.0f, 1.0f, 1.0f );

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
$LN29@SND_Update:

; 2081 : 		info.index = 0;

	mov	DWORD PTR _info$[ebp], 0

; 2082 : 
; 2083 : 		Con_NXPrintf( &info, "room_type: %i ----(%i)---- painted: %i\n", idsp_room, total - 1, paintedtime );

	mov	edx, DWORD PTR _paintedtime
	push	edx
	mov	eax, DWORD PTR _total$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _idsp_room
	push	ecx
	push	OFFSET $SG144762
	lea	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_Con_NXPrintf
	add	esp, 20					; 00000014H
$LN21@SND_Update:

; 2084 : 	}
; 2085 : 
; 2086 : 	S_StreamBackgroundTrack ();

	call	_S_StreamBackgroundTrack

; 2087 : 	S_StreamSoundTrack ();

	call	_S_StreamSoundTrack

; 2088 : 
; 2089 : 	// mix some sound
; 2090 : 	S_UpdateChannels ();

	call	_S_UpdateChannels
$LN1@SND_Update:

; 2091 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_UpdateSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_sfxHandle$ = -12					; size = 4
_flags$ = -8						; size = 4
_channel$ = -4						; size = 4
_name$ = 8						; size = 4
_volume$ = 12						; size = 4
_reliable$ = 16						; size = 4
_S_StartLocalSound PROC

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1241 : 	sound_t	sfxHandle;
; 1242 : 	int	flags = (SND_LOCALSOUND|SND_STOP_LOOPING);

	mov	DWORD PTR _flags$[ebp], 1536		; 00000600H

; 1243 : 	int	channel = CHAN_AUTO;

	mov	DWORD PTR _channel$[ebp], 0

; 1244 : 
; 1245 : 	if( reliable ) channel = CHAN_STATIC;

	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN2@S_StartLoc
	mov	DWORD PTR _channel$[ebp], 6
$LN2@S_StartLoc:

; 1246 : 
; 1247 : 	if( !dma.initialized ) return;	

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN3@S_StartLoc
	jmp	SHORT $LN1@S_StartLoc
$LN3@S_StartLoc:

; 1248 : 	sfxHandle = S_RegisterSound( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _sfxHandle$[ebp], eax

; 1249 : 	S_StartSound( NULL, s_listener.entnum, channel, sfxHandle, volume, ATTN_NONE, PITCH_NORM, flags );

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	100					; 00000064H
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sfxHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s_listener+60
	push	ecx
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@S_StartLoc:

; 1250 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_StartLocalSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_fadePercent$ = 8					; size = 4
_fadeOutSeconds$ = 12					; size = 4
_holdTime$ = 16						; size = 4
_fadeInSeconds$ = 20					; size = 4
_S_FadeClientVolume PROC

; 111  : {

	push	ebp
	mov	ebp, esp

; 112  : 	soundfade.starttime	= cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR _soundfade+8, xmm0

; 113  : 	soundfade.initial_percent = fadePercent;       

	movss	xmm0, DWORD PTR _fadePercent$[ebp]
	movss	DWORD PTR _soundfade, xmm0

; 114  : 	soundfade.fadeouttime = fadeOutSeconds;    

	movss	xmm0, DWORD PTR _fadeOutSeconds$[ebp]
	movss	DWORD PTR _soundfade+12, xmm0

; 115  : 	soundfade.holdtime = holdTime;   

	movss	xmm0, DWORD PTR _holdTime$[ebp]
	movss	DWORD PTR _soundfade+16, xmm0

; 116  : 	soundfade.fadeintime = fadeInSeconds;

	movss	xmm0, DWORD PTR _fadeInSeconds$[ebp]
	movss	DWORD PTR _soundfade+20, xmm0

; 117  : }

	pop	ebp
	ret	0
_S_FadeClientVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_radius$ = -44						; size = 4
_fvox$ = -40						; size = 4
_vol$ = -36						; size = 4
tv182 = -32						; size = 4
tv178 = -28						; size = 4
tv174 = -24						; size = 4
tv77 = -20						; size = 4
tv76 = -16						; size = 4
_pSource$ = -12						; size = 4
_sfx$ = -8						; size = 4
_ch$ = -4						; size = 4
_pos$ = 8						; size = 4
_ent$ = 12						; size = 4
_handle$ = 16						; size = 4
_fvol$ = 20						; size = 4
_attn$ = 24						; size = 4
_pitch$ = 28						; size = 4
_flags$ = 32						; size = 4
_S_AmbientSound PROC

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 1156 : 	channel_t	*ch;
; 1157 : 	wavdata_t	*pSource = NULL;

	mov	DWORD PTR _pSource$[ebp], 0

; 1158 : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 1159 : 	int	vol, fvox = 0;

	mov	DWORD PTR _fvox$[ebp], 0

; 1160 : 	float	radius = SND_RADIUS_MAX;

	movss	xmm0, DWORD PTR __real@43700000
	movss	DWORD PTR _radius$[ebp], xmm0

; 1161 : 
; 1162 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN2@S_AmbientS:

; 1163 : 	sfx = S_GetSfxByHandle( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 1164 : 	if( !sfx ) return;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN3@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN3@S_AmbientS:

; 1165 : 
; 1166 : 	vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN16@S_AmbientS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@S_AmbientS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN15@S_AmbientS
$LN14@S_AmbientS:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
$LN15@S_AmbientS:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN17@S_AmbientS
$LN16@S_AmbientS:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv77[ebp], xmm0
$LN17@S_AmbientS:
	cvttss2si ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _vol$[ebp], ecx

; 1167 : 	if( pitch <= 1 ) pitch = PITCH_NORM; // Invasion issues

	cmp	DWORD PTR _pitch$[ebp], 1
	jg	SHORT $LN4@S_AmbientS
	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN4@S_AmbientS:

; 1168 : 
; 1169 : 	if( flags & (SND_STOP|SND_CHANGE_VOL|SND_CHANGE_PITCH))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 224				; 000000e0H
	je	SHORT $LN7@S_AmbientS

; 1170 : 	{
; 1171 : 		if( S_AlterChannel( ent, CHAN_STATIC, sfx, vol, pitch, flags ))

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	push	6
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_S_AlterChannel
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN6@S_AmbientS

; 1172 : 			return;

	jmp	$LN1@S_AmbientS
$LN6@S_AmbientS:

; 1173 : 		if( flags & SND_STOP ) return;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN7@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN7@S_AmbientS:

; 1174 : 	}
; 1175 : 
; 1176 : 	// pick a channel to play on from the static area
; 1177 : 	ch = SND_PickStaticChannel( pos, sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_SND_PickStaticChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax

; 1178 : 	if( !ch ) return;

	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN8@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN8@S_AmbientS:

; 1179 : 
; 1180 : 	VectorCopy( pos, ch->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx+36], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+36], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+36], edx

; 1181 : 	ch->entnum = ent;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1182 : 
; 1183 : 	CL_GetEntitySpatialization( ch );

	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_CL_GetEntitySpatialization
	add	esp, 4

; 1184 : 
; 1185 : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@S_AmbientS

; 1186 : 	{
; 1187 : 		// this is a sentence. link words to play in sequence.
; 1188 : 		// NOTE: sentence names stored in the cache lookup are
; 1189 : 		// prepended with a '!'.  Sentence names stored in the
; 1190 : 		// sentence file do not have a leading '!'. 
; 1191 : 
; 1192 : 		// link all words and load the first word
; 1193 : 		VOX_LoadSound( ch, S_SkipSoundChar( sfx->name ));

	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_S_SkipSoundChar
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_VOX_LoadSound
	add	esp, 8

; 1194 : 		Q_strncpy( ch->name, sfx->name, sizeof( ch->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1195 : 		sfx = ch->sfx;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _sfx$[ebp], eax

; 1196 : 		if( sfx ) pSource = sfx->cache;

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN11@S_AmbientS
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _pSource$[ebp], edx
$LN11@S_AmbientS:

; 1197 : 		fvox = 1;

	mov	DWORD PTR _fvox$[ebp], 1

; 1198 : 	}

	jmp	SHORT $LN10@S_AmbientS
$LN9@S_AmbientS:

; 1199 : 	else
; 1200 : 	{
; 1201 : 		// load regular or stream sound
; 1202 : 		pSource = S_LoadSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 1203 : 		ch->sfx = sfx;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1204 : 		ch->isSentence = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+56], 0

; 1205 : 		ch->name[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	BYTE PTR [eax+edx], 0
$LN10@S_AmbientS:

; 1206 : 	}
; 1207 : 
; 1208 : 	if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN12@S_AmbientS

; 1209 : 	{
; 1210 : 		S_FreeChannel( ch );

	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_S_FreeChannel
	add	esp, 4

; 1211 : 		return;

	jmp	$LN1@S_AmbientS
$LN12@S_AmbientS:

; 1212 : 	}
; 1213 : 
; 1214 : 	// never update positions if source entity is 0
; 1215 : 	ch->staticsound = ( ent == 0 ) ? true : false;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN18@S_AmbientS
	mov	DWORD PTR tv174[ebp], 1
	jmp	SHORT $LN19@S_AmbientS
$LN18@S_AmbientS:
	mov	DWORD PTR tv174[ebp], 0
$LN19@S_AmbientS:
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR tv174[ebp]
	mov	DWORD PTR [edx+72], eax

; 1216 : 	ch->use_loop = (flags & SND_STOP_LOOPING) ? false : true;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN20@S_AmbientS
	mov	DWORD PTR tv178[ebp], 0
	jmp	SHORT $LN21@S_AmbientS
$LN20@S_AmbientS:
	mov	DWORD PTR tv178[ebp], 1
$LN21@S_AmbientS:
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR tv178[ebp]
	mov	DWORD PTR [edx+68], eax

; 1217 : 	ch->localsound = (flags & SND_LOCALSOUND) ? true : false;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN22@S_AmbientS
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN23@S_AmbientS
$LN22@S_AmbientS:
	mov	DWORD PTR tv182[ebp], 0
$LN23@S_AmbientS:
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR tv182[ebp]
	mov	DWORD PTR [edx+76], eax

; 1218 : 	ch->master_vol = vol;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 1219 : 	ch->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 1220 : 	ch->entchannel = CHAN_STATIC;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+32], 6

; 1221 : 	ch->basePitch = pitch;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [edx+60], eax

; 1222 : 	ch->radius = radius;

	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [ecx+132], xmm0

; 1223 : 
; 1224 : 	// initialize gain due to obscured sound source
; 1225 : 	ch->bfirstpass = true;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+112], 1

; 1226 : 	ch->ob_gain = 0.0;

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+116], xmm0

; 1227 : 	ch->ob_gain_inc = 0.0;

	mov	ecx, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+124], xmm0

; 1228 : 	ch->ob_gain_target = 0.0;

	mov	edx, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+120], xmm0

; 1229 : 	ch->bTraced = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+128], 0

; 1230 : 
; 1231 : 	SND_Spatialize( ch );

	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_SND_Spatialize
	add	esp, 4
$LN1@S_AmbientS:

; 1232 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_S_AmbientSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_skip$1 = -52						; size = 4
_vol$ = -48						; size = 4
tv170 = -44						; size = 4
tv166 = -40						; size = 4
tv162 = -36						; size = 4
_bIgnore$ = -32						; size = 4
tv77 = -28						; size = 4
tv76 = -24						; size = 4
_ch_idx$ = -20						; size = 4
_pSource$ = -16						; size = 4
_check$ = -12						; size = 4
_sfx$ = -8						; size = 4
_target_chan$ = -4					; size = 4
_pos$ = 8						; size = 4
_ent$ = 12						; size = 4
_chan$ = 16						; size = 4
_handle$ = 20						; size = 4
_fvol$ = 24						; size = 4
_attn$ = 28						; size = 4
_pitch$ = 32						; size = 4
_flags$ = 36						; size = 4
_S_StartSound PROC

; 899  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 900  : 	wavdata_t	*pSource;
; 901  : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 902  : 	channel_t	*target_chan, *check;
; 903  : 	int	vol, ch_idx;
; 904  : 	qboolean	bIgnore = false;

	mov	DWORD PTR _bIgnore$[ebp], 0

; 905  : 
; 906  : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_StartSou
	jmp	$LN3@S_StartSou
$LN5@S_StartSou:

; 907  : 	sfx = S_GetSfxByHandle( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 908  : 	if( !sfx ) return;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN6@S_StartSou
	jmp	$LN3@S_StartSou
$LN6@S_StartSou:

; 909  : 
; 910  : 	vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN30@S_StartSou
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN28@S_StartSou
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN29@S_StartSou
$LN28@S_StartSou:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
$LN29@S_StartSou:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN31@S_StartSou
$LN30@S_StartSou:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv77[ebp], xmm0
$LN31@S_StartSou:
	cvttss2si ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _vol$[ebp], ecx

; 911  : 	if( pitch <= 1 ) pitch = PITCH_NORM; // Invasion issues

	cmp	DWORD PTR _pitch$[ebp], 1
	jg	SHORT $LN7@S_StartSou
	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN7@S_StartSou:

; 912  : 
; 913  : 	if( flags & ( SND_STOP|SND_CHANGE_VOL|SND_CHANGE_PITCH ))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 224				; 000000e0H
	je	SHORT $LN10@S_StartSou

; 914  : 	{
; 915  : 		if( S_AlterChannel( ent, chan, sfx, vol, pitch, flags ))

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_S_AlterChannel
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN9@S_StartSou

; 916  : 			return;

	jmp	$LN3@S_StartSou
$LN9@S_StartSou:

; 917  : 
; 918  : 		if( flags & SND_STOP ) return;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN10@S_StartSou
	jmp	$LN3@S_StartSou
$LN10@S_StartSou:

; 919  : 		// fall through - if we're not trying to stop the sound, 
; 920  : 		// and we didn't find it (it's not playing), go ahead and start it up
; 921  : 	}
; 922  : 
; 923  : 	if( !pos ) pos = RI.vieworg;

	cmp	DWORD PTR _pos$[ebp], 0
	jne	SHORT $LN11@S_StartSou
	mov	DWORD PTR _pos$[ebp], OFFSET _RI+200
$LN11@S_StartSou:

; 924  : 
; 925  : 	if( chan == CHAN_STREAM )

	cmp	DWORD PTR _chan$[ebp], 5
	jne	SHORT $LN12@S_StartSou

; 926  : 		SetBits( flags, SND_STOP_LOOPING );

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR _flags$[ebp], ecx
$LN12@S_StartSou:

; 927  : 
; 928  : 	// pick a channel to play on
; 929  : 	if( chan == CHAN_STATIC ) target_chan = SND_PickStaticChannel( pos, sfx );

	cmp	DWORD PTR _chan$[ebp], 6
	jne	SHORT $LN13@S_StartSou
	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_SND_PickStaticChannel
	add	esp, 8
	mov	DWORD PTR _target_chan$[ebp], eax
	jmp	SHORT $LN14@S_StartSou
$LN13@S_StartSou:

; 930  : 	else target_chan = SND_PickDynamicChannel( ent, chan, sfx, &bIgnore );

	lea	ecx, DWORD PTR _bIgnore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SND_PickDynamicChannel
	add	esp, 16					; 00000010H
	mov	DWORD PTR _target_chan$[ebp], eax
$LN14@S_StartSou:

; 931  : 
; 932  : 	if( !target_chan )

	cmp	DWORD PTR _target_chan$[ebp], 0
	jne	SHORT $LN15@S_StartSou

; 933  : 	{
; 934  : 		if( !bIgnore )

	cmp	DWORD PTR _bIgnore$[ebp], 0
	jne	SHORT $LN16@S_StartSou

; 935  : 			Con_DPrintf( S_ERROR "dropped sound \"%s%s\"\n", DEFAULT_SOUNDPATH, sfx->name );

	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	push	OFFSET $SG144294
	push	OFFSET $SG144295
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN16@S_StartSou:

; 936  : 		return;

	jmp	$LN3@S_StartSou
$LN15@S_StartSou:

; 937  : 	}
; 938  : 
; 939  : 	// spatialize
; 940  : 	memset( target_chan, 0, sizeof( *target_chan ));

	push	2480					; 000009b0H
	push	0
	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  : 	VectorCopy( pos, target_chan->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+36], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+36], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+36], ecx

; 943  : 	target_chan->staticsound = ( ent == 0 ) ? true : false;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN32@S_StartSou
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN33@S_StartSou
$LN32@S_StartSou:
	mov	DWORD PTR tv162[ebp], 0
$LN33@S_StartSou:
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR [edx+72], eax

; 944  : 	target_chan->use_loop = (flags & SND_STOP_LOOPING) ? false : true;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN34@S_StartSou
	mov	DWORD PTR tv166[ebp], 0
	jmp	SHORT $LN35@S_StartSou
$LN34@S_StartSou:
	mov	DWORD PTR tv166[ebp], 1
$LN35@S_StartSou:
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR [edx+68], eax

; 945  : 	target_chan->localsound = (flags & SND_LOCALSOUND) ? true : false;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN36@S_StartSou
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN37@S_StartSou
$LN36@S_StartSou:
	mov	DWORD PTR tv170[ebp], 0
$LN37@S_StartSou:
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR tv170[ebp]
	mov	DWORD PTR [edx+76], eax

; 946  : 	target_chan->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _target_chan$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 947  : 	target_chan->master_vol = vol;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [edx+52], eax

; 948  : 	target_chan->entnum = ent;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 949  : 	target_chan->entchannel = chan;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 950  : 	target_chan->basePitch = pitch;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [edx+60], eax

; 951  : 	target_chan->isSentence = false;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 952  : 	target_chan->radius = 0.0f;

	mov	edx, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+132], xmm0

; 953  : 	target_chan->sfx = sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 954  : 
; 955  : 	// initialize gain due to obscured sound source
; 956  : 	target_chan->bfirstpass = true;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [edx+112], 1

; 957  : 	target_chan->ob_gain = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+116], xmm0

; 958  : 	target_chan->ob_gain_inc = 0.0f;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+124], xmm0

; 959  : 	target_chan->ob_gain_target = 0.0f;

	mov	edx, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+120], xmm0

; 960  : 	target_chan->bTraced = false;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+128], 0

; 961  : 
; 962  : 	pSource = NULL;

	mov	DWORD PTR _pSource$[ebp], 0

; 963  : 
; 964  : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@S_StartSou

; 965  : 	{
; 966  : 		// this is a sentence
; 967  : 		// link all words and load the first word
; 968  : 		// NOTE: sentence names stored in the cache lookup are
; 969  : 		// prepended with a '!'.  Sentence names stored in the
; 970  : 		// sentence file do not have a leading '!'. 
; 971  : 		VOX_LoadSound( target_chan, S_SkipSoundChar( sfx->name ));

	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	call	_S_SkipSoundChar
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_VOX_LoadSound
	add	esp, 8

; 972  : 		Q_strncpy( target_chan->name, sfx->name, sizeof( target_chan->name ));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _target_chan$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 973  : 		sfx = target_chan->sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _sfx$[ebp], ecx

; 974  : 		if( sfx ) pSource = sfx->cache;

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN19@S_StartSou
	mov	edx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _pSource$[ebp], eax
$LN19@S_StartSou:

; 975  : 	}

	jmp	SHORT $LN18@S_StartSou
$LN17@S_StartSou:

; 976  : 	else
; 977  : 	{
; 978  : 		// regular or streamed sound fx
; 979  : 		pSource = S_LoadSound( sfx );

	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 980  : 		target_chan->name[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	BYTE PTR [ecx+eax], 0
$LN18@S_StartSou:

; 981  : 	}
; 982  : 
; 983  : 	if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN20@S_StartSou

; 984  : 	{
; 985  : 		S_FreeChannel( target_chan );

	mov	edx, DWORD PTR _target_chan$[ebp]
	push	edx
	call	_S_FreeChannel
	add	esp, 4

; 986  : 		return;

	jmp	$LN3@S_StartSou
$LN20@S_StartSou:

; 987  : 	}
; 988  : 
; 989  : 	SND_Spatialize( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_SND_Spatialize
	add	esp, 4

; 990  : 
; 991  : 	// If a client can't hear a sound when they FIRST receive the StartSound message,
; 992  : 	// the client will never be able to hear that sound. This is so that out of 
; 993  : 	// range sounds don't fill the playback buffer. For streaming sounds, we bypass this optimization.
; 994  : 	if( !target_chan->leftvol && !target_chan->rightvol )

	mov	ecx, DWORD PTR _target_chan$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN24@S_StartSou
	mov	edx, DWORD PTR _target_chan$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN24@S_StartSou

; 995  : 	{
; 996  : 		// looping sounds don't use this optimization because they should stick around until they're killed.
; 997  : 		if( !sfx->cache || sfx->cache->loopStart == -1 )

	mov	eax, DWORD PTR _sfx$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN23@S_StartSou
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN24@S_StartSou
$LN23@S_StartSou:

; 998  : 		{
; 999  : 			// if this is a streaming sound, play the whole thing.
; 1000 : 			if( chan != CHAN_STREAM )

	cmp	DWORD PTR _chan$[ebp], 5
	je	SHORT $LN24@S_StartSou

; 1001 : 			{
; 1002 : 				S_FreeChannel( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 1003 : 				return; // not audible at all

	jmp	$LN3@S_StartSou
$LN24@S_StartSou:

; 1004 : 			}
; 1005 : 		}
; 1006 : 	}
; 1007 : 
; 1008 : 	// Init client entity mouth movement vars
; 1009 : 	SND_InitMouth( ent, chan );

	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SND_InitMouth
	add	esp, 8

; 1010 : 
; 1011 : 	for( ch_idx = NUM_AMBIENTS, check = channels + NUM_AMBIENTS; ch_idx < MAX_DYNAMIC_CHANNELS; ch_idx++, check++)

	mov	DWORD PTR _ch_idx$[ebp], 4
	mov	DWORD PTR _check$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN4@S_StartSou
$LN2@S_StartSou:
	mov	eax, DWORD PTR _ch_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ch_idx$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@S_StartSou:
	cmp	DWORD PTR _ch_idx$[ebp], 64		; 00000040H
	jge	SHORT $LN3@S_StartSou

; 1012 : 	{
; 1013 : 		if( check == target_chan ) continue;

	mov	edx, DWORD PTR _check$[ebp]
	cmp	edx, DWORD PTR _target_chan$[ebp]
	jne	SHORT $LN25@S_StartSou
	jmp	SHORT $LN2@S_StartSou
$LN25@S_StartSou:

; 1014 : 
; 1015 : 		if( check->sfx == sfx && !check->pMixer.sample )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN26@S_StartSou
	mov	edx, DWORD PTR _check$[ebp]
	movsd	xmm0, QWORD PTR [edx+80]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@S_StartSou

; 1016 : 		{
; 1017 : 			// skip up to 0.1 seconds of audio
; 1018 : 			int skip = COM_RandomLong( 0, (long)( 0.1f * check->sfx->cache->rate ));

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	movzx	eax, WORD PTR [edx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvttss2si ecx, xmm0
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _skip$1[ebp], eax

; 1019 :                               
; 1020 : 			S_SetSampleStart( check, sfx->cache, skip );

	mov	edx, DWORD PTR _skip$1[ebp]
	push	edx
	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _check$[ebp]
	push	edx
	call	_S_SetSampleStart
	add	esp, 12					; 0000000cH

; 1021 : 			break;

	jmp	SHORT $LN3@S_StartSou
$LN26@S_StartSou:

; 1022 : 		}
; 1023 : 	}

	jmp	$LN2@S_StartSou
$LN3@S_StartSou:

; 1024 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StartSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_vol$ = -40						; size = 4
tv155 = -36						; size = 4
tv151 = -32						; size = 4
tv147 = -28						; size = 4
_bIgnore$ = -24						; size = 4
tv77 = -20						; size = 4
tv76 = -16						; size = 4
_pSource$ = -12						; size = 4
_sfx$ = -8						; size = 4
_target_chan$ = -4					; size = 4
_pos$ = 8						; size = 4
_ent$ = 12						; size = 4
_chan$ = 16						; size = 4
_handle$ = 20						; size = 4
_fvol$ = 24						; size = 4
_attn$ = 28						; size = 4
_pitch$ = 32						; size = 4
_flags$ = 36						; size = 4
_sample$ = 40						; size = 8
_end$ = 48						; size = 8
_wordIndex$ = 56					; size = 4
_S_RestoreSound PROC

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 1035 : 	wavdata_t	*pSource;
; 1036 : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 1037 : 	channel_t	*target_chan;
; 1038 : 	qboolean	bIgnore = false;

	mov	DWORD PTR _bIgnore$[ebp], 0

; 1039 : 	int	vol;
; 1040 : 
; 1041 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_RestoreS
	jmp	$LN1@S_RestoreS
$LN2@S_RestoreS:

; 1042 : 	sfx = S_GetSfxByHandle( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 1043 : 	if( !sfx ) return;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN3@S_RestoreS
	jmp	$LN1@S_RestoreS
$LN3@S_RestoreS:

; 1044 : 
; 1045 : 	vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN19@S_RestoreS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@S_RestoreS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN18@S_RestoreS
$LN17@S_RestoreS:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
$LN18@S_RestoreS:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN20@S_RestoreS
$LN19@S_RestoreS:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv77[ebp], xmm0
$LN20@S_RestoreS:
	cvttss2si ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _vol$[ebp], ecx

; 1046 : 	if( pitch <= 1 ) pitch = PITCH_NORM; // Invasion issues

	cmp	DWORD PTR _pitch$[ebp], 1
	jg	SHORT $LN4@S_RestoreS
	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN4@S_RestoreS:

; 1047 : 
; 1048 : 	// pick a channel to play on
; 1049 : 	if( chan == CHAN_STATIC ) target_chan = SND_PickStaticChannel( pos, sfx );

	cmp	DWORD PTR _chan$[ebp], 6
	jne	SHORT $LN5@S_RestoreS
	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_SND_PickStaticChannel
	add	esp, 8
	mov	DWORD PTR _target_chan$[ebp], eax
	jmp	SHORT $LN6@S_RestoreS
$LN5@S_RestoreS:

; 1050 : 	else target_chan = SND_PickDynamicChannel( ent, chan, sfx, &bIgnore );

	lea	ecx, DWORD PTR _bIgnore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SND_PickDynamicChannel
	add	esp, 16					; 00000010H
	mov	DWORD PTR _target_chan$[ebp], eax
$LN6@S_RestoreS:

; 1051 : 
; 1052 : 	if( !target_chan )

	cmp	DWORD PTR _target_chan$[ebp], 0
	jne	SHORT $LN7@S_RestoreS

; 1053 : 	{
; 1054 : 		if( !bIgnore )

	cmp	DWORD PTR _bIgnore$[ebp], 0
	jne	SHORT $LN8@S_RestoreS

; 1055 : 			Con_DPrintf( S_ERROR "dropped sound \"%s%s\"\n", DEFAULT_SOUNDPATH, sfx->name );

	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	push	OFFSET $SG144343
	push	OFFSET $SG144344
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN8@S_RestoreS:

; 1056 : 		return;

	jmp	$LN1@S_RestoreS
$LN7@S_RestoreS:

; 1057 : 	}
; 1058 : 
; 1059 : 	// spatialize
; 1060 : 	memset( target_chan, 0, sizeof( *target_chan ));

	push	2480					; 000009b0H
	push	0
	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1061 : 
; 1062 : 	VectorCopy( pos, target_chan->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx+36], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+36], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx+36], ecx

; 1063 : 	target_chan->staticsound = ( ent == 0 ) ? true : false;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN21@S_RestoreS
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN22@S_RestoreS
$LN21@S_RestoreS:
	mov	DWORD PTR tv147[ebp], 0
$LN22@S_RestoreS:
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR [edx+72], eax

; 1064 : 	target_chan->use_loop = (flags & SND_STOP_LOOPING) ? false : true;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN23@S_RestoreS
	mov	DWORD PTR tv151[ebp], 0
	jmp	SHORT $LN24@S_RestoreS
$LN23@S_RestoreS:
	mov	DWORD PTR tv151[ebp], 1
$LN24@S_RestoreS:
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR tv151[ebp]
	mov	DWORD PTR [edx+68], eax

; 1065 : 	target_chan->localsound = (flags & SND_LOCALSOUND) ? true : false;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN25@S_RestoreS
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN26@S_RestoreS
$LN25@S_RestoreS:
	mov	DWORD PTR tv155[ebp], 0
$LN26@S_RestoreS:
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR [edx+76], eax

; 1066 : 	target_chan->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _target_chan$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 1067 : 	target_chan->master_vol = vol;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [edx+52], eax

; 1068 : 	target_chan->entnum = ent;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1069 : 	target_chan->entchannel = chan;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1070 : 	target_chan->basePitch = pitch;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [edx+60], eax

; 1071 : 	target_chan->isSentence = false;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 1072 : 	target_chan->radius = 0.0f;

	mov	edx, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+132], xmm0

; 1073 : 	target_chan->sfx = sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1074 : 
; 1075 : 	// initialize gain due to obscured sound source
; 1076 : 	target_chan->bfirstpass = true;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [edx+112], 1

; 1077 : 	target_chan->ob_gain = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+116], xmm0

; 1078 : 	target_chan->ob_gain_inc = 0.0f;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+124], xmm0

; 1079 : 	target_chan->ob_gain_target = 0.0f;

	mov	edx, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+120], xmm0

; 1080 : 	target_chan->bTraced = false;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+128], 0

; 1081 : 
; 1082 : 	pSource = NULL;

	mov	DWORD PTR _pSource$[ebp], 0

; 1083 : 
; 1084 : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	$LN9@S_RestoreS

; 1085 : 	{
; 1086 : 		// this is a sentence
; 1087 : 		// link all words and load the first word
; 1088 : 		// NOTE: sentence names stored in the cache lookup are
; 1089 : 		// prepended with a '!'.  Sentence names stored in the
; 1090 : 		// sentence file do not have a leading '!'. 
; 1091 : 		VOX_LoadSound( target_chan, S_SkipSoundChar( sfx->name ));

	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	call	_S_SkipSoundChar
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_VOX_LoadSound
	add	esp, 8

; 1092 : 		Q_strncpy( target_chan->name, sfx->name, sizeof( target_chan->name ));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _target_chan$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1093 : 
; 1094 : 		// not a first word in sentence!
; 1095 : 		if( wordIndex != 0 )

	cmp	DWORD PTR _wordIndex$[ebp], 0
	je	SHORT $LN11@S_RestoreS

; 1096 : 		{
; 1097 : 			VOX_FreeWord( target_chan );		// release first loaded word

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_VOX_FreeWord
	add	esp, 4

; 1098 : 			target_chan->wordIndex = wordIndex;	// restore current word

	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR _wordIndex$[ebp]
	mov	DWORD PTR [ecx+164], edx

; 1099 : 			VOX_LoadWord( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_VOX_LoadWord
	add	esp, 4

; 1100 : 
; 1101 : 			if( target_chan->currentWord )

	mov	ecx, DWORD PTR _target_chan$[ebp]
	cmp	DWORD PTR [ecx+168], 0
	je	SHORT $LN13@S_RestoreS

; 1102 : 			{
; 1103 : 				target_chan->sfx = target_chan->words[target_chan->wordIndex].sfx;

	mov	edx, DWORD PTR _target_chan$[ebp]
	imul	eax, DWORD PTR [edx+164], 36
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR [edx+eax+204]
	mov	DWORD PTR [ecx+16], eax

; 1104 : 				sfx = target_chan->sfx;

	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _sfx$[ebp], edx

; 1105 : 				pSource = sfx->cache;

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pSource$[ebp], ecx
$LN13@S_RestoreS:

; 1106 : 			}
; 1107 : 		}

	jmp	SHORT $LN14@S_RestoreS
$LN11@S_RestoreS:

; 1108 : 		else
; 1109 : 		{
; 1110 : 			sfx = target_chan->sfx;

	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _sfx$[ebp], eax

; 1111 : 			if( sfx ) pSource = sfx->cache;

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN14@S_RestoreS
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _pSource$[ebp], edx
$LN14@S_RestoreS:

; 1112 : 		}
; 1113 : 	}

	jmp	SHORT $LN10@S_RestoreS
$LN9@S_RestoreS:

; 1114 : 	else
; 1115 : 	{
; 1116 : 		// regular or streamed sound fx
; 1117 : 		pSource = S_LoadSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 1118 : 		target_chan->name[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	BYTE PTR [eax+edx], 0
$LN10@S_RestoreS:

; 1119 : 	}
; 1120 : 
; 1121 : 	if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN15@S_RestoreS

; 1122 : 	{
; 1123 : 		S_FreeChannel( target_chan );

	mov	ecx, DWORD PTR _target_chan$[ebp]
	push	ecx
	call	_S_FreeChannel
	add	esp, 4

; 1124 : 		return;

	jmp	SHORT $LN1@S_RestoreS
$LN15@S_RestoreS:

; 1125 : 	}
; 1126 : 
; 1127 : 	SND_Spatialize( target_chan );

	mov	edx, DWORD PTR _target_chan$[ebp]
	push	edx
	call	_SND_Spatialize
	add	esp, 4

; 1128 : 
; 1129 : 	// NOTE: first spatialization may be failed because listener position is invalid at this time
; 1130 : 	// so we should keep all sounds an actual and waiting for player spawn.
; 1131 : 
; 1132 : 	// apply the sample offests
; 1133 : 	target_chan->pMixer.sample = sample;

	mov	eax, DWORD PTR _target_chan$[ebp]
	movsd	xmm0, QWORD PTR _sample$[ebp]
	movsd	QWORD PTR [eax+80], xmm0

; 1134 : 	target_chan->pMixer.forcedEndSample = end;	

	mov	ecx, DWORD PTR _target_chan$[ebp]
	movsd	xmm0, QWORD PTR _end$[ebp]
	movsd	QWORD PTR [ecx+96], xmm0

; 1135 : 
; 1136 : 	// Init client entity mouth movement vars
; 1137 : 	SND_InitMouth( ent, chan );

	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SND_InitMouth
	add	esp, 8
$LN1@S_RestoreS:

; 1138 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_S_RestoreSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv252 = -8240						; size = 8
_duration$ = -8232					; size = 4
_bufferSamples$ = -8228					; size = 4
tv93 = -8224						; size = 4
tv92 = -8220						; size = 4
_fileSamples$ = -8216					; size = 4
_r$ = -8212						; size = 4
_fileBytes$ = -8208					; size = 4
_info$1 = -8204						; size = 4
_ch$ = -8200						; size = 4
_raw$ = -8196						; size = 8192
__$ArrayPad$ = -4					; size = 4
_Avi$ = 8						; size = 4
_entnum$ = 12						; size = 4
_fvol$ = 16						; size = 4
_attn$ = 20						; size = 4
_synctime$ = 24						; size = 4
_S_StreamAviSamples PROC

; 1596 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8240				; 00002030H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1597 : 	int	bufferSamples;
; 1598 : 	int	fileSamples;
; 1599 : 	byte	raw[MAX_RAW_SAMPLES];
; 1600 : 	float	duration = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _duration$[ebp], xmm0

; 1601 : 	int	r, fileBytes;
; 1602 : 	rawchan_t	*ch = NULL;

	mov	DWORD PTR _ch$[ebp], 0

; 1603 : 
; 1604 : 	if( !dma.initialized || s_listener.paused || !CL_IsInGame( ))

	cmp	DWORD PTR _dma+12, 0
	je	SHORT $LN5@S_StreamAv
	cmp	DWORD PTR _s_listener+80, 0
	jne	SHORT $LN5@S_StreamAv
	call	_CL_IsInGame
	test	eax, eax
	jne	SHORT $LN4@S_StreamAv
$LN5@S_StreamAv:

; 1605 : 		return;

	jmp	$LN3@S_StreamAv
$LN4@S_StreamAv:

; 1606 : 
; 1607 : 	if( entnum < 0 || entnum >= GI->max_edicts )

	cmp	DWORD PTR _entnum$[ebp], 0
	jl	SHORT $LN7@S_StreamAv
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _entnum$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jl	SHORT $LN6@S_StreamAv
$LN7@S_StreamAv:

; 1608 : 		return;

	jmp	$LN3@S_StreamAv
$LN6@S_StreamAv:

; 1609 : 
; 1610 : 	if( !( ch = S_FindRawChannel( entnum, true )))

	push	1
	mov	edx, DWORD PTR _entnum$[ebp]
	push	edx
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN8@S_StreamAv

; 1611 : 		return;

	jmp	$LN3@S_StreamAv
$LN8@S_StreamAv:

; 1612 : 
; 1613 : 	if( ch->sound_info.rate == 0 )

	mov	eax, DWORD PTR _ch$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	test	ecx, ecx
	jne	SHORT $LN10@S_StreamAv

; 1614 : 	{
; 1615 : 		if( !AVI_GetAudioInfo( Avi, &ch->sound_info ))

	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	push	eax
	call	_AVI_GetAudioInfo
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@S_StreamAv

; 1616 : 			return; // no audiotrack

	jmp	$LN3@S_StreamAv
$LN10@S_StreamAv:

; 1617 : 	}
; 1618 : 
; 1619 : 	ch->master_vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN21@S_StreamAv
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@S_StreamAv
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN20@S_StreamAv
$LN19@S_StreamAv:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv92[ebp], xmm0
$LN20@S_StreamAv:
	movss	xmm0, DWORD PTR tv92[ebp]
	movss	DWORD PTR tv93[ebp], xmm0
	jmp	SHORT $LN22@S_StreamAv
$LN21@S_StreamAv:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv93[ebp], xmm0
$LN22@S_StreamAv:
	cvttss2si ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1620 : 	ch->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 1621 : 
; 1622 : 	// see how many samples should be copied into the raw buffer
; 1623 : 	if( ch->s_rawend < soundtime )

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR _soundtime
	jae	SHORT $LN11@S_StreamAv

; 1624 : 		ch->s_rawend = soundtime;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	mov	DWORD PTR [eax+36], ecx
$LN11@S_StreamAv:

; 1625 : 
; 1626 : 	// position is changed, synchronization is lost etc
; 1627 : 	if( fabs( ch->oldtime - synctime ) > s_mixahead->value )

	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	subss	xmm0, DWORD PTR _synctime$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv252[ebp]
	movsd	xmm0, QWORD PTR tv252[ebp]
	mov	eax, DWORD PTR _s_mixahead
	cvtss2sd xmm1, DWORD PTR [eax+12]
	comisd	xmm0, xmm1
	jbe	SHORT $LN12@S_StreamAv

; 1628 : 		ch->sound_info.loopStart = AVI_TimeToSoundPosition( Avi, synctime * 1000 );

	movss	xmm0, DWORD PTR _synctime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	push	edx
	call	_AVI_TimeToSoundPosition
	add	esp, 8
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+44], eax
$LN12@S_StreamAv:

; 1629 : 	ch->oldtime = synctime; // keep actual time

	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _synctime$[ebp]
	movss	DWORD PTR [edx+68], xmm0
$LN2@S_StreamAv:

; 1630 : 
; 1631 : 	while( ch->s_rawend < soundtime + ch->max_samples )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	add	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+36], ecx
	jae	$LN3@S_StreamAv

; 1632 : 	{
; 1633 : 		wavdata_t	*info = &ch->sound_info;

	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _info$1[ebp], eax

; 1634 : 
; 1635 : 		bufferSamples = ch->max_samples - (ch->s_rawend - soundtime);

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, DWORD PTR _soundtime
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	sub	ecx, edx
	mov	DWORD PTR _bufferSamples$[ebp], ecx

; 1636 : 
; 1637 : 		// decide how much data needs to be read from the file
; 1638 : 		fileSamples = bufferSamples * ((float)info->rate / SOUND_DMA_SPEED );

	cvtsi2ss xmm0, DWORD PTR _bufferSamples$[ebp]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, WORD PTR [edx]
	cvtsi2ss xmm1, eax
	divss	xmm1, DWORD PTR __real@472c4400
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _fileSamples$[ebp], ecx

; 1639 : 		if( fileSamples <= 1 ) return; // no more samples need

	cmp	DWORD PTR _fileSamples$[ebp], 1
	jg	SHORT $LN13@S_StreamAv
	jmp	$LN3@S_StreamAv
$LN13@S_StreamAv:

; 1640 : 
; 1641 : 		// our max buffer size
; 1642 : 		fileBytes = fileSamples * ( info->width * info->channels );

	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	imul	eax, edx
	imul	eax, DWORD PTR _fileSamples$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], eax

; 1643 : 
; 1644 : 		if( fileBytes > sizeof( raw ))

	cmp	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H
	jbe	SHORT $LN14@S_StreamAv

; 1645 : 		{
; 1646 : 			fileBytes = sizeof( raw );

	mov	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H

; 1647 : 			fileSamples = fileBytes / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _fileBytes$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN14@S_StreamAv:

; 1648 : 		}
; 1649 : 
; 1650 : 		// read audio stream
; 1651 : 		r = AVI_GetAudioChunk( Avi, raw, info->loopStart, fileBytes );

	mov	ecx, DWORD PTR _fileBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	push	edx
	call	_AVI_GetAudioChunk
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r$[ebp], eax

; 1652 : 		info->loopStart += r; // advance play position

	mov	eax, DWORD PTR _info$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _info$1[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1653 : 
; 1654 : 		if( r < fileBytes )

	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _fileBytes$[ebp]
	jge	SHORT $LN15@S_StreamAv

; 1655 : 		{
; 1656 : 			fileBytes = r;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], ecx

; 1657 : 			fileSamples = r / ( info->width * info->channels );

	mov	edx, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [edx+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _r$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN15@S_StreamAv:

; 1658 : 		}
; 1659 : 
; 1660 : 		if( r > 0 )

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN16@S_StreamAv

; 1661 : 		{
; 1662 : 			// add to raw buffer
; 1663 : 			ch->s_rawend = S_RawSamplesStereo( ch->rawsamples, ch->s_rawend, ch->max_samples,

	lea	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	ax, BYTE PTR [edx+3]
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	ax, BYTE PTR [edx+2]
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _fileSamples$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	call	_S_RawSamplesStereo
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1664 : 			fileSamples, info->rate, info->width, info->channels, raw );
; 1665 : 		}

	jmp	SHORT $LN17@S_StreamAv
$LN16@S_StreamAv:

; 1666 : 		else break; // no more samples for this frame

	jmp	SHORT $LN3@S_StreamAv
$LN17@S_StreamAv:

; 1667 : 	}

	jmp	$LN2@S_StreamAv
$LN3@S_StreamAv:

; 1668 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StreamAviSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_S_ClearRawChannel PROC

; 1691 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1692 : 	rawchan_t	*ch;
; 1693 : 
; 1694 : 	if( !( ch = S_FindRawChannel( entnum, false )))

	push	0
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN2@S_ClearRaw

; 1695 : 		return;

	jmp	SHORT $LN1@S_ClearRaw
$LN2@S_ClearRaw:

; 1696 : 
; 1697 : 	ch->s_rawend = 0;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+36], 0
$LN1@S_ClearRaw:

; 1698 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_ClearRawChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv88 = -20						; size = 8
tv76 = -12						; size = 4
tv85 = -8						; size = 4
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_S_GetRawSamplesLength PROC

; 1676 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1677 : 	rawchan_t	*ch;
; 1678 : 
; 1679 : 	if( !( ch = S_FindRawChannel( entnum, false )))

	push	0
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN2@S_GetRawSa

; 1680 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@S_GetRawSa
$LN2@S_GetRawSa:

; 1681 : 
; 1682 : 	return ch->s_rawend <= paintedtime ? 0 : (float)(ch->s_rawend - paintedtime) * DMA_MSEC_PER_SAMPLE;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR _paintedtime
	ja	SHORT $LN4@S_GetRawSa
	xorps	xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN5@S_GetRawSa
$LN4@S_GetRawSa:
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR _paintedtime
	mov	DWORD PTR tv85[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR tv85[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv88[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv88[ebp]
	mulss	xmm0, DWORD PTR __real@3cb9c278
	movss	DWORD PTR tv76[ebp], xmm0
$LN5@S_GetRawSa:
	movss	xmm0, DWORD PTR tv76[ebp]
	call	__ftoui3
$LN1@S_GetRawSa:

; 1683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetRawSamplesLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_rvp$ = 8						; size = 4
_S_UpdateFrame PROC

; 1955 : {

	push	ebp
	mov	ebp, esp

; 1956 : 	if( !FBitSet( rvp->flags, RF_DRAW_WORLD ) || FBitSet( rvp->flags, RF_ONLY_CLIENTDRAW ))

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 1
	je	SHORT $LN3@S_UpdateFr
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+52]
	and	eax, 8
	je	SHORT $LN2@S_UpdateFr
$LN3@S_UpdateFr:

; 1957 : 		return; 

	jmp	SHORT $LN1@S_UpdateFr
$LN2@S_UpdateFr:

; 1958 : 
; 1959 : 	VectorCopy( rvp->vieworigin, s_listener.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _s_listener[ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _s_listener[ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR _s_listener[edx], ecx

; 1960 : 	AngleVectors( rvp->viewangles, s_listener.forward, s_listener.right, s_listener.up );

	push	OFFSET _s_listener+48
	push	OFFSET _s_listener+36
	push	OFFSET _s_listener+24
	mov	edx, DWORD PTR _rvp$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 1961 : 	s_listener.entnum = rvp->viewentity; // can be camera entity too

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _s_listener+60, ecx
$LN1@S_UpdateFr:

; 1962 : }

	pop	ebp
	ret	0
_S_UpdateFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_snd_vol$ = -4						; size = 4
_samples$ = 8						; size = 4
_rate$ = 12						; size = 4
_width$ = 16						; size = 2
_channels$ = 20						; size = 2
_data$ = 24						; size = 4
_entnum$ = 28						; size = 4
_S_RawSamples PROC

; 1581 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1582 : 	int	snd_vol = 128;

	mov	DWORD PTR _snd_vol$[ebp], 128		; 00000080H

; 1583 : 
; 1584 : 	if( entnum < 0 ) snd_vol = 256; // bg track or movie track

	cmp	DWORD PTR _entnum$[ebp], 0
	jge	SHORT $LN2@S_RawSampl
	mov	DWORD PTR _snd_vol$[ebp], 256		; 00000100H
$LN2@S_RawSampl:

; 1585 : 	if( snd_vol < 0 ) snd_vol = 0; // fixup negative values

	cmp	DWORD PTR _snd_vol$[ebp], 0
	jge	SHORT $LN3@S_RawSampl
	mov	DWORD PTR _snd_vol$[ebp], 0
$LN3@S_RawSampl:

; 1586 : 
; 1587 : 	S_RawEntSamples( entnum, samples, rate, width, channels, data, snd_vol );

	mov	eax, DWORD PTR _snd_vol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _channels$[ebp]
	push	edx
	movzx	eax, WORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _samples$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_RawEntSamples
	add	esp, 28					; 0000001cH

; 1588 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_RawSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_best_time$ = -28					; size = 4
_time$1 = -24						; size = 4
_raw_samples$ = -20					; size = 4
_free$ = -16						; size = 4
_best$ = -12						; size = 4
_i$ = -8						; size = 4
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_create$ = 12						; size = 4
_S_FindRawChannel PROC

; 1432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1433 : 	int	i, free;
; 1434 : 	int	best, best_time;
; 1435 : 	size_t	raw_samples = 0;

	mov	DWORD PTR _raw_samples$[ebp], 0

; 1436 : 	rawchan_t	*ch;
; 1437 : 
; 1438 : 	if( !entnum ) return NULL; // world is unused

	cmp	DWORD PTR _entnum$[ebp], 0
	jne	SHORT $LN5@S_FindRawC
	xor	eax, eax
	jmp	$LN1@S_FindRawC
$LN5@S_FindRawC:

; 1439 : 
; 1440 : 	// check for replacement sound, or find the best one to replace
; 1441 : 	best_time = 0x7fffffff;

	mov	DWORD PTR _best_time$[ebp], 2147483647	; 7fffffffH

; 1442 : 	best = free = -1;

	mov	DWORD PTR _free$[ebp], -1
	mov	eax, DWORD PTR _free$[ebp]
	mov	DWORD PTR _best$[ebp], eax

; 1443 : 
; 1444 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_FindRawC
$LN2@S_FindRawC:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@S_FindRawC:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@S_FindRawC

; 1445 : 	{
; 1446 : 		ch = raw_channels[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _raw_channels[edx*4]
	mov	DWORD PTR _ch$[ebp], eax

; 1447 : 
; 1448 : 		if( free < 0 && !ch )

	cmp	DWORD PTR _free$[ebp], 0
	jge	SHORT $LN6@S_FindRawC
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN6@S_FindRawC

; 1449 : 		{
; 1450 : 			free = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _free$[ebp], ecx

; 1451 : 		}

	jmp	SHORT $LN7@S_FindRawC
$LN6@S_FindRawC:

; 1452 : 		else if( ch )

	cmp	DWORD PTR _ch$[ebp], 0
	je	SHORT $LN7@S_FindRawC

; 1453 : 		{
; 1454 : 			int	time;
; 1455 : 
; 1456 : 			// exact match
; 1457 : 			if( ch->entnum == entnum )

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@S_FindRawC

; 1458 : 				return ch;

	mov	eax, DWORD PTR _ch$[ebp]
	jmp	$LN1@S_FindRawC
$LN9@S_FindRawC:

; 1459 : 
; 1460 : 			time = ch->s_rawend - paintedtime;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	sub	edx, DWORD PTR _paintedtime
	mov	DWORD PTR _time$1[ebp], edx

; 1461 : 			if( time < best_time )

	mov	eax, DWORD PTR _time$1[ebp]
	cmp	eax, DWORD PTR _best_time$[ebp]
	jge	SHORT $LN7@S_FindRawC

; 1462 : 			{
; 1463 : 				best = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _best$[ebp], ecx

; 1464 : 				best_time = time;

	mov	edx, DWORD PTR _time$1[ebp]
	mov	DWORD PTR _best_time$[ebp], edx
$LN7@S_FindRawC:

; 1465 : 			}
; 1466 : 		}
; 1467 : 	}

	jmp	SHORT $LN2@S_FindRawC
$LN3@S_FindRawC:

; 1468 : 
; 1469 : 	if( !create ) return NULL;

	cmp	DWORD PTR _create$[ebp], 0
	jne	SHORT $LN11@S_FindRawC
	xor	eax, eax
	jmp	$LN1@S_FindRawC
$LN11@S_FindRawC:

; 1470 : 
; 1471 : 	if( free >= 0 ) best = free;

	cmp	DWORD PTR _free$[ebp], 0
	jl	SHORT $LN12@S_FindRawC
	mov	eax, DWORD PTR _free$[ebp]
	mov	DWORD PTR _best$[ebp], eax
$LN12@S_FindRawC:

; 1472 : 	if( best < 0 ) return NULL; // no free slots

	cmp	DWORD PTR _best$[ebp], 0
	jge	SHORT $LN13@S_FindRawC
	xor	eax, eax
	jmp	SHORT $LN1@S_FindRawC
$LN13@S_FindRawC:

; 1473 : 
; 1474 : 	if( !raw_channels[best] )

	mov	ecx, DWORD PTR _best$[ebp]
	cmp	DWORD PTR _raw_channels[ecx*4], 0
	jne	SHORT $LN14@S_FindRawC

; 1475 : 	{
; 1476 : 		raw_samples = MAX_RAW_SAMPLES;

	mov	DWORD PTR _raw_samples$[ebp], 8192	; 00002000H

; 1477 : 		raw_channels[best] = Mem_Calloc( sndpool, sizeof( *ch ) + sizeof( portable_samplepair_t ) * ( raw_samples - 1 ));

	push	1477					; 000005c5H
	push	OFFSET $SG144495
	push	1
	mov	edx, DWORD PTR _raw_samples$[ebp]
	lea	eax, DWORD PTR [edx*8+76]
	push	eax
	mov	ecx, DWORD PTR _sndpool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _best$[ebp]
	mov	DWORD PTR _raw_channels[edx*4], eax
$LN14@S_FindRawC:

; 1478 : 	}
; 1479 : 
; 1480 : 	ch = raw_channels[best];

	mov	eax, DWORD PTR _best$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$[ebp], ecx

; 1481 : 	ch->max_samples = raw_samples;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _raw_samples$[ebp]
	mov	DWORD PTR [edx+72], eax

; 1482 : 	ch->entnum = entnum;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _entnum$[ebp]
	mov	DWORD PTR [ecx], edx

; 1483 : 	ch->s_rawend = 0;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1484 : 
; 1485 : 	return ch;

	mov	eax, DWORD PTR _ch$[ebp]
$LN1@S_FindRawC:

; 1486 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_FindRawChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_looped$ = -20						; size = 4
tv173 = -16						; size = 4
tv131 = -12						; size = 4
_sounds_left$ = -8					; size = 4
_i$ = -4						; size = 4
_pout$ = 8						; size = 4
_size$ = 12						; size = 4
_S_GetCurrentDynamicSounds PROC

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1302 : 	int	sounds_left = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1303 : 	int	i, looped;
; 1304 : 
; 1305 : 	if( !dma.initialized )

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_GetCurre

; 1306 : 		return 0;

	xor	eax, eax
	jmp	$LN1@S_GetCurre
$LN5@S_GetCurre:

; 1307 : 
; 1308 : 	for( i = 0; i < MAX_CHANNELS && sounds_left; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_GetCurre
$LN2@S_GetCurre:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@S_GetCurre:
	cmp	DWORD PTR _i$[ebp], 320			; 00000140H
	jge	$LN3@S_GetCurre
	cmp	DWORD PTR _sounds_left$[ebp], 0
	je	$LN3@S_GetCurre

; 1309 : 	{
; 1310 : 		if( !channels[i].sfx || !channels[i].sfx->name[0] || !Q_stricmp( channels[i].sfx->name, "*default" ))

	imul	edx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[edx+16], 0
	je	SHORT $LN7@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax]
	test	ecx, ecx
	je	SHORT $LN7@S_GetCurre
	push	99999					; 0001869fH
	push	OFFSET $SG144429
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _channels[edx+16]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@S_GetCurre
$LN7@S_GetCurre:

; 1311 : 			continue;	// don't serialize default sounds

	jmp	SHORT $LN2@S_GetCurre
$LN6@S_GetCurre:

; 1312 : 
; 1313 : 		looped = ( channels[i].use_loop && channels[i].sfx->cache->loopStart != -1 );

	imul	ecx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[ecx+68], 0
	je	SHORT $LN12@S_GetCurre
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _channels[edx+16]
	mov	ecx, DWORD PTR [eax+64]
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN12@S_GetCurre
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN13@S_GetCurre
$LN12@S_GetCurre:
	mov	DWORD PTR tv131[ebp], 0
$LN13@S_GetCurre:
	mov	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR _looped$[ebp], edx

; 1314 : 
; 1315 : 		if( channels[i].entchannel == CHAN_STATIC && looped && !CL_IsQuakeCompatible())

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+32], 6
	jne	SHORT $LN8@S_GetCurre
	cmp	DWORD PTR _looped$[ebp], 0
	je	SHORT $LN8@S_GetCurre
	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN8@S_GetCurre

; 1316 : 			continue;	// never serialize static looped sounds. It will be restoring in game code 

	jmp	$LN2@S_GetCurre
$LN8@S_GetCurre:

; 1317 : 
; 1318 : 		if( channels[i].isSentence && channels[i].name[0] )

	imul	ecx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[ecx+56], 0
	je	SHORT $LN9@S_GetCurre
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _channels[edx+ecx]
	test	edx, edx
	je	SHORT $LN9@S_GetCurre

; 1319 : 			Q_strncpy( pout->name, channels[i].name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	eax, DWORD PTR _i$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	mov	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@S_GetCurre
$LN9@S_GetCurre:

; 1320 : 		else Q_strncpy( pout->name, channels[i].sfx->name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _channels[edx+16]
	push	eax
	mov	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN10@S_GetCurre:

; 1321 : 		pout->entnum = (channels[i].entnum < 0) ? 0 : channels[i].entnum;

	imul	edx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[edx+28], 0
	jge	SHORT $LN14@S_GetCurre
	mov	DWORD PTR tv173[ebp], 0
	jmp	SHORT $LN15@S_GetCurre
$LN14@S_GetCurre:
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+28]
	mov	DWORD PTR tv173[ebp], ecx
$LN15@S_GetCurre:
	mov	edx, DWORD PTR _pout$[ebp]
	mov	ax, WORD PTR tv173[ebp]
	mov	WORD PTR [edx+64], ax

; 1322 : 		VectorCopy( channels[i].origin, pout->origin );

	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	eax, DWORD PTR _channels[ecx+eax+36]
	mov	DWORD PTR [esi+edx+68], eax
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR _channels[ecx+edx+36]
	mov	DWORD PTR [esi+eax+68], ecx
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _pout$[ebp]
	mov	edx, DWORD PTR _channels[edx+eax+36]
	mov	DWORD PTR [esi+ecx+68], edx

; 1323 : 		pout->volume = (float)channels[i].master_vol / 255.0f;

	imul	eax, DWORD PTR _i$[ebp], 2480
	cvtsi2ss xmm0, DWORD PTR _channels[eax+52]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [ecx+80], xmm0

; 1324 : 		pout->attenuation = channels[i].dist_mult * SND_CLIP_DISTANCE;

	imul	edx, DWORD PTR _i$[ebp], 2480
	movss	xmm0, DWORD PTR _channels[edx+48]
	mulss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [eax+84], xmm0

; 1325 : 		pout->pitch = channels[i].basePitch;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _pout$[ebp]
	mov	al, BYTE PTR _channels[ecx+60]
	mov	BYTE PTR [edx+93], al

; 1326 : 		pout->channel = channels[i].entchannel;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _pout$[ebp]
	mov	al, BYTE PTR _channels[ecx+32]
	mov	BYTE PTR [edx+92], al

; 1327 : 		pout->wordIndex = channels[i].wordIndex;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _pout$[ebp]
	mov	al, BYTE PTR _channels[ecx+164]
	mov	BYTE PTR [edx+94], al

; 1328 : 		pout->samplePos = channels[i].pMixer.sample;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[ecx+80]
	movsd	QWORD PTR [edx+96], xmm0

; 1329 : 		pout->forcedEnd = channels[i].pMixer.forcedEndSample;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[eax+96]
	movsd	QWORD PTR [ecx+104], xmm0

; 1330 : 		pout->looping = looped;

	mov	edx, DWORD PTR _pout$[ebp]
	mov	eax, DWORD PTR _looped$[ebp]
	mov	DWORD PTR [edx+88], eax

; 1331 : 
; 1332 : 		sounds_left--;

	mov	ecx, DWORD PTR _sounds_left$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _sounds_left$[ebp], ecx

; 1333 : 		pout++;

	mov	edx, DWORD PTR _pout$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR _pout$[ebp], edx

; 1334 : 	}

	jmp	$LN2@S_GetCurre
$LN3@S_GetCurre:

; 1335 : 
; 1336 : 	return ( size - sounds_left );

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _sounds_left$[ebp]
$LN1@S_GetCurre:

; 1337 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetCurrentDynamicSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch$ = -8						; size = 4
_i$ = -4						; size = 4
_pos$ = 8						; size = 4
_sfx$ = 12						; size = 4
_SND_PickStaticChannel PROC

; 398  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 399  : 	channel_t	*ch = NULL;

	mov	DWORD PTR _ch$[ebp], 0

; 400  : 	int	i;
; 401  : 
; 402  : 	// check for replacement sound, or find the best one to replace
; 403  :  	for( i = MAX_DYNAMIC_CHANNELS; i < total_channels; i++ )

	mov	DWORD PTR _i$[ebp], 64			; 00000040H
	jmp	SHORT $LN4@SND_PickSt
$LN2@SND_PickSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SND_PickSt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _total_channels
	jge	$LN3@SND_PickSt

; 404  :  	{
; 405  : 		if( channels[i].sfx == NULL )

	imul	edx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[edx+16], 0
	jne	SHORT $LN5@SND_PickSt

; 406  : 			break;

	jmp	$LN3@SND_PickSt
$LN5@SND_PickSt:

; 407  : 
; 408  : 		if( VectorCompare( pos, channels[i].origin ) && channels[i].sfx == sfx )

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	ucomiss	xmm0, DWORD PTR _channels[edx+eax+36]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SND_PickSt
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	ucomiss	xmm0, DWORD PTR _channels[edx+eax+36]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SND_PickSt
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	ucomiss	xmm0, DWORD PTR _channels[edx+eax+36]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SND_PickSt
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _channels[ecx+16]
	cmp	edx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN6@SND_PickSt

; 409  : 			break;

	jmp	SHORT $LN3@SND_PickSt
$LN6@SND_PickSt:

; 410  : 	}

	jmp	$LN2@SND_PickSt
$LN3@SND_PickSt:

; 411  : 
; 412  : 	if( i < total_channels ) 

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN7@SND_PickSt

; 413  : 	{
; 414  : 		// reuse an empty static sound channel
; 415  : 		ch = &channels[i];

	imul	ecx, DWORD PTR _i$[ebp], 2480
	add	ecx, OFFSET _channels
	mov	DWORD PTR _ch$[ebp], ecx

; 416  : 	}

	jmp	SHORT $LN8@SND_PickSt
$LN7@SND_PickSt:

; 417  : 	else
; 418  : 	{
; 419  : 		// no empty slots, alloc a new static sound channel
; 420  : 		if( total_channels == MAX_CHANNELS )

	cmp	DWORD PTR _total_channels, 320		; 00000140H
	jne	SHORT $LN9@SND_PickSt

; 421  : 		{
; 422  : 			Con_DPrintf( S_ERROR "S_PickStaticChannel: no free channels\n" );

	push	OFFSET $SG144065
	call	_Con_DPrintf
	add	esp, 4

; 423  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SND_PickSt
$LN9@SND_PickSt:

; 424  : 		}
; 425  : 
; 426  : 		// get a channel for the static sound
; 427  : 		ch = &channels[total_channels];

	imul	edx, DWORD PTR _total_channels, 2480
	add	edx, OFFSET _channels
	mov	DWORD PTR _ch$[ebp], edx

; 428  : 		total_channels++;

	mov	eax, DWORD PTR _total_channels
	add	eax, 1
	mov	DWORD PTR _total_channels, eax
$LN8@SND_PickSt:

; 429  : 	}
; 430  : 	return ch;

	mov	eax, DWORD PTR _ch$[ebp]
$LN1@SND_PickSt:

; 431  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_PickStaticChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_sc$1 = -28						; size = 4
_life_left$ = -24					; size = 4
_ch$2 = -20						; size = 4
_timeleft$ = -16					; size = 4
_ch_idx$ = -12						; size = 4
_ch$3 = -8						; size = 4
_first_to_die$ = -4					; size = 4
_entnum$ = 8						; size = 4
_channel$ = 12						; size = 4
_sfx$ = 16						; size = 4
_ignore$ = 20						; size = 4
_SND_PickDynamicChannel PROC

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 309  : 	int	ch_idx;
; 310  : 	int	first_to_die;
; 311  : 	int	life_left;
; 312  : 	int	timeleft;
; 313  : 
; 314  : 	// check for replacement sound, or find the best one to replace
; 315  : 	first_to_die = -1;

	mov	DWORD PTR _first_to_die$[ebp], -1

; 316  : 	life_left = 0x7fffffff;

	mov	DWORD PTR _life_left$[ebp], 2147483647	; 7fffffffH

; 317  : 	if( ignore ) *ignore = false;

	cmp	DWORD PTR _ignore$[ebp], 0
	je	SHORT $LN5@SND_PickDy
	mov	eax, DWORD PTR _ignore$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SND_PickDy:

; 318  : 
; 319  : 	if( channel == CHAN_STREAM && SND_FStreamIsPlaying( sfx ))

	cmp	DWORD PTR _channel$[ebp], 5
	jne	SHORT $LN6@SND_PickDy
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_SND_FStreamIsPlaying
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@SND_PickDy

; 320  : 	{
; 321  : 		if( ignore )

	cmp	DWORD PTR _ignore$[ebp], 0
	je	SHORT $LN7@SND_PickDy

; 322  : 			*ignore = true;

	mov	edx, DWORD PTR _ignore$[ebp]
	mov	DWORD PTR [edx], 1
$LN7@SND_PickDy:

; 323  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SND_PickDy
$LN6@SND_PickDy:

; 324  : 	}
; 325  : 
; 326  : 	for( ch_idx = NUM_AMBIENTS; ch_idx < MAX_DYNAMIC_CHANNELS; ch_idx++ )

	mov	DWORD PTR _ch_idx$[ebp], 4
	jmp	SHORT $LN4@SND_PickDy
$LN2@SND_PickDy:
	mov	eax, DWORD PTR _ch_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ch_idx$[ebp], eax
$LN4@SND_PickDy:
	cmp	DWORD PTR _ch_idx$[ebp], 64		; 00000040H
	jge	$LN3@SND_PickDy

; 327  : 	{
; 328  : 		channel_t	*ch = &channels[ch_idx];

	imul	ecx, DWORD PTR _ch_idx$[ebp], 2480
	add	ecx, OFFSET _channels
	mov	DWORD PTR _ch$3[ebp], ecx

; 329  : 		
; 330  : 		// Never override a streaming sound that is currently playing or
; 331  : 		// voice over IP data that is playing or any sound on CHAN_VOICE( acting )
; 332  : 		if( ch->sfx && ( ch->entchannel == CHAN_STREAM ))

	mov	edx, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN8@SND_PickDy
	mov	eax, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [eax+32], 5
	jne	SHORT $LN8@SND_PickDy

; 333  : 			continue;

	jmp	SHORT $LN2@SND_PickDy
$LN8@SND_PickDy:

; 334  : 
; 335  : 		if( channel != CHAN_AUTO && ch->entnum == entnum && ( ch->entchannel == channel || channel == -1 ))

	cmp	DWORD PTR _channel$[ebp], 0
	je	SHORT $LN9@SND_PickDy
	mov	ecx, DWORD PTR _ch$3[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@SND_PickDy
	mov	eax, DWORD PTR _ch$3[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _channel$[ebp]
	je	SHORT $LN10@SND_PickDy
	cmp	DWORD PTR _channel$[ebp], -1
	jne	SHORT $LN9@SND_PickDy
$LN10@SND_PickDy:

; 336  : 		{
; 337  : 			// always override sound from same entity
; 338  : 			first_to_die = ch_idx;

	mov	edx, DWORD PTR _ch_idx$[ebp]
	mov	DWORD PTR _first_to_die$[ebp], edx

; 339  : 			break;

	jmp	SHORT $LN3@SND_PickDy
$LN9@SND_PickDy:

; 340  : 		}
; 341  : 
; 342  : 		// don't let monster sounds override player sounds
; 343  : 		if( ch->sfx && S_IsClient( ch->entnum ) && !S_IsClient( entnum ))

	mov	eax, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN11@SND_PickDy
	mov	ecx, DWORD PTR _ch$3[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@SND_PickDy
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SND_PickDy

; 344  : 			continue;

	jmp	$LN2@SND_PickDy
$LN11@SND_PickDy:

; 345  : 
; 346  : 		// try to pick the sound with the least amount of data left to play
; 347  : 		timeleft = 0;

	mov	DWORD PTR _timeleft$[ebp], 0

; 348  : 		if( ch->sfx )

	mov	ecx, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN12@SND_PickDy

; 349  : 		{
; 350  : 			timeleft = 1; // ch->end - paintedtime

	mov	DWORD PTR _timeleft$[ebp], 1
$LN12@SND_PickDy:

; 351  : 		}
; 352  : 
; 353  : 		if( timeleft < life_left )

	mov	edx, DWORD PTR _timeleft$[ebp]
	cmp	edx, DWORD PTR _life_left$[ebp]
	jge	SHORT $LN13@SND_PickDy

; 354  : 		{
; 355  : 			life_left = timeleft;

	mov	eax, DWORD PTR _timeleft$[ebp]
	mov	DWORD PTR _life_left$[ebp], eax

; 356  : 			first_to_die = ch_idx;

	mov	ecx, DWORD PTR _ch_idx$[ebp]
	mov	DWORD PTR _first_to_die$[ebp], ecx
$LN13@SND_PickDy:

; 357  : 		}
; 358  : 	}

	jmp	$LN2@SND_PickDy
$LN3@SND_PickDy:

; 359  : 
; 360  : 	if( first_to_die == -1 )

	cmp	DWORD PTR _first_to_die$[ebp], -1
	jne	SHORT $LN14@SND_PickDy

; 361  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SND_PickDy
$LN14@SND_PickDy:

; 362  : 
; 363  : 	if( channels[first_to_die].sfx )

	imul	edx, DWORD PTR _first_to_die$[ebp], 2480
	cmp	DWORD PTR _channels[edx+16], 0
	je	SHORT $LN15@SND_PickDy

; 364  : 	{
; 365  : 		// don't restart looping sounds for the same entity
; 366  : 		wavdata_t	*sc = channels[first_to_die].sfx->cache;

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _sc$1[ebp], edx

; 367  : 
; 368  : 		if( sc && sc->loopStart != -1 )

	cmp	DWORD PTR _sc$1[ebp], 0
	je	SHORT $LN16@SND_PickDy
	mov	eax, DWORD PTR _sc$1[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN16@SND_PickDy

; 369  : 		{
; 370  : 			channel_t	*ch = &channels[first_to_die];

	imul	ecx, DWORD PTR _first_to_die$[ebp], 2480
	add	ecx, OFFSET _channels
	mov	DWORD PTR _ch$2[ebp], ecx

; 371  : 
; 372  : 			if( ch->entnum == entnum && ch->entchannel == channel && ch->sfx == sfx )

	mov	edx, DWORD PTR _ch$2[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN16@SND_PickDy
	mov	ecx, DWORD PTR _ch$2[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR _channel$[ebp]
	jne	SHORT $LN16@SND_PickDy
	mov	eax, DWORD PTR _ch$2[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN16@SND_PickDy

; 373  : 			{
; 374  : 				if( ignore ) *ignore = true;

	cmp	DWORD PTR _ignore$[ebp], 0
	je	SHORT $LN18@SND_PickDy
	mov	edx, DWORD PTR _ignore$[ebp]
	mov	DWORD PTR [edx], 1
$LN18@SND_PickDy:

; 375  : 				// same looping sound, same ent, same channel, don't restart the sound
; 376  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SND_PickDy
$LN16@SND_PickDy:

; 377  : 			}
; 378  : 		}
; 379  : 
; 380  : 		// be sure and release previous channel if sentence.
; 381  : 		S_FreeChannel( &( channels[first_to_die] ));

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	call	_S_FreeChannel
	add	esp, 4
$LN15@SND_PickDy:

; 382  : 	}
; 383  : 
; 384  : 	return &channels[first_to_die];

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	add	eax, OFFSET _channels
$LN1@SND_PickDy:

; 385  : }       

	mov	esp, ebp
	pop	ebp
	ret	0
_SND_PickDynamicChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_SoundInfo_f PROC

; 2251 : {

	push	ebp
	mov	ebp, esp

; 2252 : 	Con_Printf( "Audio: DirectSound\n" );

	push	OFFSET $SG144838
	call	_Con_Printf
	add	esp, 4

; 2253 : 	Con_Printf( "%5d channel(s)\n", 2 );

	push	2
	push	OFFSET $SG144839
	call	_Con_Printf
	add	esp, 8

; 2254 : 	Con_Printf( "%5d samples\n", dma.samples );

	mov	eax, DWORD PTR _dma
	push	eax
	push	OFFSET $SG144840
	call	_Con_Printf
	add	esp, 8

; 2255 : 	Con_Printf( "%5d bits/sample\n", 16 );

	push	16					; 00000010H
	push	OFFSET $SG144841
	call	_Con_Printf
	add	esp, 8

; 2256 : 	Con_Printf( "%5d bytes/sec\n", SOUND_DMA_SPEED );

	push	44100					; 0000ac44H
	push	OFFSET $SG144842
	call	_Con_Printf
	add	esp, 8

; 2257 : 	Con_Printf( "%5d total_channels\n", total_channels );

	mov	ecx, DWORD PTR _total_channels
	push	ecx
	push	OFFSET $SG144843
	call	_Con_Printf
	add	esp, 8

; 2258 : 
; 2259 : 	S_PrintBackgroundTrackState ();

	call	_S_PrintBackgroundTrackState

; 2260 : }

	pop	ebp
	ret	0
_S_SoundInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_ch$ = 8						; size = 4
_S_FreeChannel PROC

; 140  : {

	push	ebp
	mov	ebp, esp

; 141  : 	ch->sfx = NULL;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+16], 0

; 142  : 	ch->name[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 143  : 	ch->use_loop = false;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 144  : 	ch->isSentence = false;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+56], 0

; 145  : 
; 146  : 	// clear mixer
; 147  : 	memset( &ch->pMixer, 0, sizeof( ch->pMixer ));

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 148  : 
; 149  : 	SND_CloseMouth( ch );

	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_SND_CloseMouth
	add	esp, 4

; 150  : }

	pop	ebp
	ret	0
_S_FreeChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv129 = -16						; size = 4
tv75 = -12						; size = 4
tv74 = -8						; size = 4
_scale$ = -4						; size = 4
_S_GetMasterVolume PROC

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 95   : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 96   : 
; 97   : 	if( !s_listener.inmenu && soundfade.percent != 0 )

	cmp	DWORD PTR _s_listener+76, 0
	jne	$LN2@S_GetMaste
	movss	xmm0, DWORD PTR _soundfade+4
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@S_GetMaste

; 98   : 	{
; 99   : 		scale = bound( 0.0f, soundfade.percent / 100.0f, 1.0f );

	movss	xmm0, DWORD PTR _soundfade+4
	divss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@S_GetMaste
	movss	xmm0, DWORD PTR _soundfade+4
	divss	xmm0, DWORD PTR __real@42c80000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@S_GetMaste
	movss	xmm0, DWORD PTR _soundfade+4
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN5@S_GetMaste
$LN4@S_GetMaste:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv74[ebp], xmm0
$LN5@S_GetMaste:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN7@S_GetMaste
$LN6@S_GetMaste:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
$LN7@S_GetMaste:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0

; 100  : 		scale = 1.0f - scale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN2@S_GetMaste:

; 101  : 	}
; 102  : 	return s_volume->value * scale;

	mov	eax, DWORD PTR _s_volume
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv129[ebp], xmm0
	fld	DWORD PTR tv129[ebp]

; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetMasterVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ambient$ = 8						; size = 4
_S_StopAllSounds PROC

; 1874 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1875 : 	int	i;
; 1876 : 
; 1877 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_StopAllS
	jmp	$LN1@S_StopAllS
$LN5@S_StopAllS:

; 1878 : 	total_channels = MAX_DYNAMIC_CHANNELS;	// no statics

	mov	DWORD PTR _total_channels, 64		; 00000040H

; 1879 : 
; 1880 : 	for( i = 0; i < MAX_CHANNELS; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_StopAllS
$LN2@S_StopAllS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_StopAllS:
	cmp	DWORD PTR _i$[ebp], 320			; 00000140H
	jge	SHORT $LN3@S_StopAllS

; 1881 : 	{
; 1882 : 		if( !channels[i].sfx ) continue;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[ecx+16], 0
	jne	SHORT $LN6@S_StopAllS
	jmp	SHORT $LN2@S_StopAllS
$LN6@S_StopAllS:

; 1883 : 		S_FreeChannel( &channels[i] );

	imul	edx, DWORD PTR _i$[ebp], 2480
	add	edx, OFFSET _channels
	push	edx
	call	_S_FreeChannel
	add	esp, 4

; 1884 : 	}

	jmp	SHORT $LN2@S_StopAllS
$LN3@S_StopAllS:

; 1885 : 
; 1886 : 	DSP_ClearState();

	call	_DSP_ClearState

; 1887 : 
; 1888 : 	// clear all the channels
; 1889 : 	memset( channels, 0, sizeof( channels ));

	push	793600					; 000c1c00H
	push	0
	push	OFFSET _channels
	call	_memset
	add	esp, 12					; 0000000cH

; 1890 : 
; 1891 : 	// restart the ambient sounds
; 1892 : 	if( ambient ) S_InitAmbientChannels ();

	cmp	DWORD PTR _ambient$[ebp], 0
	je	SHORT $LN7@S_StopAllS
	call	_S_InitAmbientChannels
$LN7@S_StopAllS:

; 1893 : 
; 1894 : 	S_ClearBuffer ();

	call	_S_ClearBuffer

; 1895 : 
; 1896 : 	// clear any remaining soundfade
; 1897 : 	memset( &soundfade, 0, sizeof( soundfade ));

	push	24					; 00000018H
	push	0
	push	OFFSET _soundfade
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@S_StopAllS:

; 1898 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopAllSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
tv192 = -12						; size = 4
_sounds_left$ = -8					; size = 4
_i$ = -4						; size = 4
_pout$ = 8						; size = 4
_size$ = 12						; size = 4
_S_GetCurrentStaticSounds PROC

; 1260 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 1261 : 	int	sounds_left = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1262 : 	int	i;
; 1263 : 
; 1264 : 	if( !dma.initialized )

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_GetCurre

; 1265 : 		return 0;

	xor	eax, eax
	jmp	$LN1@S_GetCurre
$LN5@S_GetCurre:

; 1266 : 
; 1267 : 	for( i = MAX_DYNAMIC_CHANNELS; i < total_channels && sounds_left; i++ )

	mov	DWORD PTR _i$[ebp], 64			; 00000040H
	jmp	SHORT $LN4@S_GetCurre
$LN2@S_GetCurre:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@S_GetCurre:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _total_channels
	jge	$LN3@S_GetCurre
	cmp	DWORD PTR _sounds_left$[ebp], 0
	je	$LN3@S_GetCurre

; 1268 : 	{
; 1269 : 		if( channels[i].entchannel == CHAN_STATIC && channels[i].sfx && channels[i].sfx->name[0] )

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+32], 6
	jne	$LN6@S_GetCurre
	imul	ecx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[ecx+16], 0
	je	$LN6@S_GetCurre
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _channels[edx+16]
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR [eax+edx]
	test	eax, eax
	je	$LN6@S_GetCurre

; 1270 : 		{
; 1271 : 			if( channels[i].isSentence && channels[i].name[0] )

	imul	ecx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[ecx+56], 0
	je	SHORT $LN7@S_GetCurre
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _channels[edx+ecx]
	test	edx, edx
	je	SHORT $LN7@S_GetCurre

; 1272 : 				Q_strncpy( pout->name, channels[i].name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	eax, DWORD PTR _i$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	mov	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@S_GetCurre
$LN7@S_GetCurre:

; 1273 : 			else Q_strncpy( pout->name, channels[i].sfx->name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _channels[edx+16]
	push	eax
	mov	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@S_GetCurre:

; 1274 : 			pout->entnum = channels[i].entnum;

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _pout$[ebp]
	mov	cx, WORD PTR _channels[edx+28]
	mov	WORD PTR [eax+64], cx

; 1275 : 			VectorCopy( channels[i].origin, pout->origin );

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR _channels[edx+ecx+36]
	mov	DWORD PTR [esi+eax+68], ecx
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	edx, DWORD PTR _channels[edx+eax+36]
	mov	DWORD PTR [esi+ecx+68], edx
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _pout$[ebp]
	mov	eax, DWORD PTR _channels[eax+ecx+36]
	mov	DWORD PTR [esi+edx+68], eax

; 1276 : 			pout->volume = (float)channels[i].master_vol / 255.0f;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	cvtsi2ss xmm0, DWORD PTR _channels[ecx+52]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [edx+80], xmm0

; 1277 : 			pout->attenuation = channels[i].dist_mult * SND_CLIP_DISTANCE;

	imul	eax, DWORD PTR _i$[ebp], 2480
	movss	xmm0, DWORD PTR _channels[eax+48]
	mulss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [ecx+84], xmm0

; 1278 : 			pout->looping = ( channels[i].use_loop && channels[i].sfx->cache->loopStart != -1 );

	imul	edx, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[edx+68], 0
	je	SHORT $LN10@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	mov	edx, DWORD PTR [ecx+64]
	cmp	DWORD PTR [edx+4], -1
	je	SHORT $LN10@S_GetCurre
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN11@S_GetCurre
$LN10@S_GetCurre:
	mov	DWORD PTR tv192[ebp], 0
$LN11@S_GetCurre:
	mov	eax, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR [eax+88], ecx

; 1279 : 			pout->pitch = channels[i].basePitch;

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _pout$[ebp]
	mov	cl, BYTE PTR _channels[edx+60]
	mov	BYTE PTR [eax+93], cl

; 1280 : 			pout->channel = channels[i].entchannel;

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _pout$[ebp]
	mov	cl, BYTE PTR _channels[edx+32]
	mov	BYTE PTR [eax+92], cl

; 1281 : 			pout->wordIndex = channels[i].wordIndex;

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _pout$[ebp]
	mov	cl, BYTE PTR _channels[edx+164]
	mov	BYTE PTR [eax+94], cl

; 1282 : 			pout->samplePos = channels[i].pMixer.sample;

	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[edx+80]
	movsd	QWORD PTR [eax+96], xmm0

; 1283 : 			pout->forcedEnd = channels[i].pMixer.forcedEndSample;

	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[ecx+96]
	movsd	QWORD PTR [edx+104], xmm0

; 1284 : 
; 1285 : 			sounds_left--;

	mov	eax, DWORD PTR _sounds_left$[ebp]
	sub	eax, 1
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1286 : 			pout++;

	mov	ecx, DWORD PTR _pout$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR _pout$[ebp], ecx
$LN6@S_GetCurre:

; 1287 : 		}
; 1288 : 	}

	jmp	$LN2@S_GetCurre
$LN3@S_GetCurre:

; 1289 : 
; 1290 : 	return ( size - sounds_left );

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _sounds_left$[ebp]
$LN1@S_GetCurre:

; 1291 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetCurrentStaticSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_sfx$ = -4						; size = 4
_entnum$ = 8						; size = 4
_channel$ = 12						; size = 4
_soundname$ = 16					; size = 4
_S_StopSound PROC

; 1860 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1861 : 	sfx_t	*sfx;
; 1862 : 
; 1863 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_StopSoun
	jmp	SHORT $LN1@S_StopSoun
$LN2@S_StopSoun:

; 1864 : 	sfx = S_FindName( soundname, NULL );

	push	0
	mov	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_S_FindName
	add	esp, 8
	mov	DWORD PTR _sfx$[ebp], eax

; 1865 : 	S_AlterChannel( entnum, channel, sfx, 0, 0, SND_STOP );

	push	32					; 00000020H
	push	0
	push	0
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _channel$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_AlterChannel
	add	esp, 24					; 00000018H
$LN1@S_StopSoun:

; 1866 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_Shutdown PROC

; 2333 : {

	push	ebp
	mov	ebp, esp

; 2334 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_Shutdown
	jmp	$LN1@S_Shutdown
$LN2@S_Shutdown:

; 2335 : 
; 2336 : 	Cmd_RemoveCommand( "play" );

	push	OFFSET $SG144931
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2337 : 	Cmd_RemoveCommand( "playvol" );

	push	OFFSET $SG144932
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2338 : 	Cmd_RemoveCommand( "stopsound" );

	push	OFFSET $SG144933
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2339 : 	Cmd_RemoveCommand( "music" );

	push	OFFSET $SG144934
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2340 : 	Cmd_RemoveCommand( "soundlist" );

	push	OFFSET $SG144935
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2341 : 	Cmd_RemoveCommand( "s_info" );

	push	OFFSET $SG144936
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2342 : 	Cmd_RemoveCommand( "s_fade" );

	push	OFFSET $SG144937
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2343 : 	Cmd_RemoveCommand( "+voicerecord" );

	push	OFFSET $SG144938
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2344 : 	Cmd_RemoveCommand( "-voicerecord" );

	push	OFFSET $SG144939
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2345 : 	Cmd_RemoveCommand( "speak" );

	push	OFFSET $SG144940
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2346 : 	Cmd_RemoveCommand( "spk" );

	push	OFFSET $SG144941
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2347 : 
; 2348 : 	S_StopAllSounds (false);

	push	0
	call	_S_StopAllSounds
	add	esp, 4

; 2349 : 	S_FreeRawChannels ();

	call	_S_FreeRawChannels

; 2350 : 	S_FreeSounds ();

	call	_S_FreeSounds

; 2351 : 	VOX_Shutdown ();

	call	_VOX_Shutdown

; 2352 : 	SX_Free ();

	call	_SX_Free

; 2353 : 
; 2354 : 	SNDDMA_Shutdown ();

	call	_SNDDMA_Shutdown

; 2355 : 	MIX_FreeAllPaintbuffers ();

	call	_MIX_FreeAllPaintbuffers

; 2356 : 	Mem_FreePool( &sndpool );

	push	2356					; 00000934H
	push	OFFSET $SG144942
	push	OFFSET _sndpool
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH
$LN1@S_Shutdown:

; 2357 : }

	pop	ebp
	ret	0
_S_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_main.c
_TEXT	SEGMENT
_S_Init	PROC

; 2268 : {

	push	ebp
	mov	ebp, esp

; 2269 : 	if( Sys_CheckParm( "-nosound" ))

	push	OFFSET $SG144847
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@S_Init

; 2270 : 	{
; 2271 : 		Con_Printf( "Audio: Disabled\n" );

	push	OFFSET $SG144848
	call	_Con_Printf
	add	esp, 4

; 2272 : 		return false;

	xor	eax, eax
	jmp	$LN1@S_Init
$LN2@S_Init:

; 2273 : 	}
; 2274 : 
; 2275 : 	s_volume = Cvar_Get( "volume", "0.7", FCVAR_ARCHIVE, "sound volume" );

	push	OFFSET $SG144849
	push	1
	push	OFFSET $SG144850
	push	OFFSET $SG144851
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_volume, eax

; 2276 : 	s_musicvolume = Cvar_Get( "MP3Volume", "1.0", FCVAR_ARCHIVE, "background music volume" );

	push	OFFSET $SG144852
	push	1
	push	OFFSET $SG144853
	push	OFFSET $SG144854
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_musicvolume, eax

; 2277 : 	s_mixahead = Cvar_Get( "_snd_mixahead", "0.12", 0, "how much sound to mix ahead of time" );

	push	OFFSET $SG144855
	push	0
	push	OFFSET $SG144856
	push	OFFSET $SG144857
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_mixahead, eax

; 2278 : 	s_show = Cvar_Get( "s_show", "0", FCVAR_ARCHIVE, "show playing sounds" );

	push	OFFSET $SG144858
	push	1
	push	OFFSET $SG144859
	push	OFFSET $SG144860
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_show, eax

; 2279 : 	s_lerping = Cvar_Get( "s_lerping", "0", FCVAR_ARCHIVE, "apply interpolation to sound output" );

	push	OFFSET $SG144861
	push	1
	push	OFFSET $SG144862
	push	OFFSET $SG144863
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_lerping, eax

; 2280 : 	s_ambient_level = Cvar_Get( "ambient_level", "0.3", FCVAR_ARCHIVE, "volume of environment noises (water and wind)" );

	push	OFFSET $SG144864
	push	1
	push	OFFSET $SG144865
	push	OFFSET $SG144866
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_ambient_level, eax

; 2281 : 	s_ambient_fade = Cvar_Get( "ambient_fade", "1000", FCVAR_ARCHIVE, "rate of volume fading when client is moving" );

	push	OFFSET $SG144867
	push	1
	push	OFFSET $SG144868
	push	OFFSET $SG144869
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_ambient_fade, eax

; 2282 : 	s_combine_sounds = Cvar_Get( "s_combine_channels", "0", FCVAR_ARCHIVE, "combine channels with same sounds" ); 

	push	OFFSET $SG144870
	push	1
	push	OFFSET $SG144871
	push	OFFSET $SG144872
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_combine_sounds, eax

; 2283 : 	snd_foliage_db_loss = Cvar_Get( "snd_foliage_db_loss", "4", 0, "foliage loss factor" ); 

	push	OFFSET $SG144873
	push	0
	push	OFFSET $SG144874
	push	OFFSET $SG144875
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_foliage_db_loss, eax

; 2284 : 	snd_gain_max = Cvar_Get( "snd_gain_max", "1", 0, "gain maximal threshold" );

	push	OFFSET $SG144876
	push	0
	push	OFFSET $SG144877
	push	OFFSET $SG144878
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_gain_max, eax

; 2285 : 	snd_gain_min = Cvar_Get( "snd_gain_min", "0.01", 0, "gain minimal threshold" );

	push	OFFSET $SG144879
	push	0
	push	OFFSET $SG144880
	push	OFFSET $SG144881
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_gain_min, eax

; 2286 : 	s_refdist = Cvar_Get( "s_refdist", "36", 0, "soundlevel reference distance" );

	push	OFFSET $SG144882
	push	0
	push	OFFSET $SG144883
	push	OFFSET $SG144884
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_refdist, eax

; 2287 : 	s_refdb = Cvar_Get( "s_refdb", "60", 0, "soundlevel refernce dB" );

	push	OFFSET $SG144885
	push	0
	push	OFFSET $SG144886
	push	OFFSET $SG144887
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_refdb, eax

; 2288 : 	snd_gain = Cvar_Get( "snd_gain", "1", 0, "sound default gain" );

	push	OFFSET $SG144888
	push	0
	push	OFFSET $SG144889
	push	OFFSET $SG144890
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_gain, eax

; 2289 : 	s_cull = Cvar_Get( "s_cull", "0", FCVAR_ARCHIVE, "cull sounds by geometry" );

	push	OFFSET $SG144891
	push	1
	push	OFFSET $SG144892
	push	OFFSET $SG144893
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_cull, eax

; 2290 : 	s_test = Cvar_Get( "s_test", "0", 0, "engine developer cvar for quick testing new features" );

	push	OFFSET $SG144894
	push	0
	push	OFFSET $SG144895
	push	OFFSET $SG144896
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_test, eax

; 2291 : 	s_phs = Cvar_Get( "s_phs", "0", FCVAR_ARCHIVE, "cull sounds by PHS" );

	push	OFFSET $SG144897
	push	1
	push	OFFSET $SG144898
	push	OFFSET $SG144899
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_phs, eax

; 2292 : 
; 2293 : 	Cmd_AddCommand( "play", S_Play_f, "playing a specified sound file" );

	push	OFFSET $SG144900
	push	OFFSET _S_Play_f
	push	OFFSET $SG144901
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2294 : 	Cmd_AddCommand( "play2", S_Play2_f, "playing a group of specified sound files" ); // nehahra stuff

	push	OFFSET $SG144902
	push	OFFSET _S_Play2_f
	push	OFFSET $SG144903
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2295 : 	Cmd_AddCommand( "playvol", S_PlayVol_f, "playing a specified sound file with specified volume" );

	push	OFFSET $SG144904
	push	OFFSET _S_PlayVol_f
	push	OFFSET $SG144905
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2296 : 	Cmd_AddCommand( "stopsound", S_StopSound_f, "stop all sounds" );

	push	OFFSET $SG144906
	push	OFFSET _S_StopSound_f
	push	OFFSET $SG144907
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2297 : 	Cmd_AddCommand( "music", S_Music_f, "starting a background track" );

	push	OFFSET $SG144908
	push	OFFSET _S_Music_f
	push	OFFSET $SG144909
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2298 : 	Cmd_AddCommand( "soundlist", S_SoundList_f, "display loaded sounds" );

	push	OFFSET $SG144910
	push	OFFSET _S_SoundList_f
	push	OFFSET $SG144911
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2299 : 	Cmd_AddCommand( "s_info", S_SoundInfo_f, "print sound system information" );

	push	OFFSET $SG144912
	push	OFFSET _S_SoundInfo_f
	push	OFFSET $SG144913
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2300 : 	Cmd_AddCommand( "s_fade", S_SoundFade_f, "fade all sounds then stop all" );

	push	OFFSET $SG144914
	push	OFFSET _S_SoundFade_f
	push	OFFSET $SG144915
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2301 : 	Cmd_AddCommand( "+voicerecord", Cmd_Null_f, "start voice recording (non-implemented)" );

	push	OFFSET $SG144916
	push	OFFSET _Cmd_Null_f
	push	OFFSET $SG144917
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2302 : 	Cmd_AddCommand( "-voicerecord", Cmd_Null_f, "stop voice recording (non-implemented)" );

	push	OFFSET $SG144918
	push	OFFSET _Cmd_Null_f
	push	OFFSET $SG144919
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2303 : 	Cmd_AddCommand( "spk", S_SayReliable_f, "reliable play a specified sententce" );

	push	OFFSET $SG144920
	push	OFFSET _S_SayReliable_f
	push	OFFSET $SG144921
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2304 : 	Cmd_AddCommand( "speak", S_Say_f, "playing a specified sententce" );

	push	OFFSET $SG144922
	push	OFFSET _S_Say_f
	push	OFFSET $SG144923
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2305 : 
; 2306 : 	if( !SNDDMA_Init( host.hWnd ))

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	_SNDDMA_Init
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@S_Init

; 2307 : 	{
; 2308 : 		Con_Printf( "Audio: sound system can't be initialized\n" );

	push	OFFSET $SG144925
	call	_Con_Printf
	add	esp, 4

; 2309 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@S_Init
$LN3@S_Init:

; 2310 : 	}
; 2311 : 
; 2312 : 	sndpool = Mem_AllocPool( "Sound Zone" );

	push	2312					; 00000908H
	push	OFFSET $SG144926
	push	OFFSET $SG144927
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sndpool, eax

; 2313 : 	soundtime = 0;

	mov	DWORD PTR _soundtime, 0

; 2314 : 	paintedtime = 0;

	mov	DWORD PTR _paintedtime, 0

; 2315 : 
; 2316 : 	// clear ambient sounds
; 2317 : 	memset( ambient_sfx, 0, sizeof( ambient_sfx ));

	push	16					; 00000010H
	push	0
	push	OFFSET _ambient_sfx
	call	_memset
	add	esp, 12					; 0000000cH

; 2318 : 
; 2319 : 	MIX_InitAllPaintbuffers ();

	call	_MIX_InitAllPaintbuffers

; 2320 : 	SX_Init ();

	call	_SX_Init

; 2321 : 	S_InitScaletable ();

	call	_S_InitScaletable

; 2322 : 	S_StopAllSounds ( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 2323 : 	S_InitSounds ();

	call	_S_InitSounds

; 2324 : 	VOX_Init ();

	call	_VOX_Init

; 2325 : 
; 2326 : 	return true;

	mov	eax, 1
$LN1@S_Init:

; 2327 : }

	pop	ebp
	ret	0
_S_Init	ENDP
_TEXT	ENDS
END
