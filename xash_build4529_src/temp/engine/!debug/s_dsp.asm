; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\client\s_dsp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_rgsxpre
PUBLIC	_paintto
_DATA	SEGMENT
COMM	_idsp_room:DWORD
COMM	_dsp_off:DWORD
COMM	_roomwater_type:DWORD
COMM	_room_type:DWORD
COMM	_hisound:DWORD
COMM	_sxmod_mod:DWORD
COMM	_sxmod_lowpass:DWORD
COMM	_sxste_delay:DWORD
COMM	_sxrvb_lp:DWORD
COMM	_sxrvb_feedback:DWORD
COMM	_sxrvb_size:DWORD
COMM	_sxdly_lp:DWORD
COMM	_sxdly_feedback:DWORD
COMM	_sxdly_delay:DWORD
COMM	_dsp_room:DWORD
COMM	_idsp_dma_speed:DWORD
COMM	_room_typeprev:DWORD
COMM	_sxamodl:DWORD
COMM	_sxamodr:DWORD
COMM	_sxamodlt:DWORD
COMM	_sxamodrt:DWORD
COMM	_sxmod1cur:DWORD
COMM	_sxmod2cur:DWORD
COMM	_sxmod1:DWORD
COMM	_sxmod2:DWORD
COMM	_sxhires:DWORD
_DATA	ENDS
_BSS	SEGMENT
_paintto DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_rgsxdly:BYTE:0e0H
COMM	_rgsxlp:DWORD:0aH
_DATA	ENDS
CONST	SEGMENT
_rgsxpre DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03d851eb8r			; 0.065
	DD	03dcccccdr			; 0.1
	DD	000000000r			; 0
	DD	03c23d70ar			; 0.01
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03ca3d70ar			; 0.02
	DD	03f400000r			; 0.75
	DD	000000000r			; 0
	DD	03c23d70ar			; 0.01
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03cf5c28fr			; 0.03
	DD	03f47ae14r			; 0.78
	DD	000000000r			; 0
	DD	03ca3d70ar			; 0.02
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03d75c28fr			; 0.06
	DD	03f451eb8r			; 0.77
	DD	000000000r			; 0
	DD	03cf5c28fr			; 0.03
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f59999ar			; 0.85
	DD	03f800000r			; 1
	DD	03c03126fr			; 0.008
	DD	03f75c28fr			; 0.96
	DD	040000000r			; 2
	DD	03c23d70ar			; 0.01
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f6147aer			; 0.88
	DD	03f800000r			; 1
	DD	03c23d70ar			; 0.01
	DD	03f7ae148r			; 0.98
	DD	040000000r			; 2
	DD	03ca3d70ar			; 0.02
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f6b851fr			; 0.92
	DD	03f800000r			; 1
	DD	03c75c28fr			; 0.015
	DD	03f7eb852r			; 0.995
	DD	040000000r			; 2
	DD	03d23d70ar			; 0.04
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f570a3dr			; 0.84
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03c449ba6r			; 0.012
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03c03126fr			; 0.008
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f733333r			; 0.95
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03b83126fr			; 0.004
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f333333r			; 0.7
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03c449ba6r			; 0.012
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d6147aer			; 0.055
	DD	03f47ae14r			; 0.78
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03c03126fr			; 0.008
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f5c28f6r			; 0.86
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03b03126fr			; 0.002
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03c23d70ar			; 0.01
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03d75c28fr			; 0.06
	DD	03f59999ar			; 0.85
	DD	040000000r			; 2
	DD	03ca3d70ar			; 0.02
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e4ccccdr			; 0.2
	DD	03f19999ar			; 0.6
	DD	040000000r			; 2
	DD	03d4ccccdr			; 0.05
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f4ccccdr			; 0.8
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03ef5c28fr			; 0.48
	DD	040000000r			; 2
	DD	03c83126fr			; 0.016
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d75c28fr			; 0.06
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f051eb8r			; 0.52
	DD	040000000r			; 2
	DD	03c23d70ar			; 0.01
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d8f5c29r			; 0.07
	DD	03f70a3d7r			; 0.94
	DD	03f800000r			; 1
	DD	03e99999ar			; 0.3
	DD	03f19999ar			; 0.6
	DD	040000000r			; 2
	DD	03c03126fr			; 0.008
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03e99999ar			; 0.3
	DD	03ed70a3dr			; 0.42
	DD	040000000r			; 2
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03eb33333r			; 0.35
	DD	03ef5c28fr			; 0.48
	DD	040000000r			; 2
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03ec28f5cr			; 0.38
	DD	03f19999ar			; 0.6
	DD	040000000r			; 2
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d4ccccdr			; 0.05
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
	DD	03e4ccccdr			; 0.2
	DD	03e8f5c29r			; 0.28
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d8f5c29r			; 0.07
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
	DD	03e99999ar			; 0.3
	DD	03ecccccdr			; 0.4
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03db851ecr			; 0.09
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
	DD	03eb33333r			; 0.35
	DD	03f000000r			; 0.5
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03c23d70ar			; 0.01
	DD	03f666666r			; 0.9
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	040000000r			; 2
	DD	03d4ccccdr			; 0.05
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03c1374bcr			; 0.009
	DD	03f7fbe77r			; 0.999
	DD	040000000r			; 2
	DD	03d23d70ar			; 0.04
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03a83126fr			; 0.001
	DD	03f7fbe77r			; 0.999
	DD	000000000r			; 0
	DD	03e4ccccdr			; 0.2
	DD	03f4ccccdr			; 0.8
	DD	040000000r			; 2
	DD	03d4ccccdr			; 0.05
CONST	ENDS
PUBLIC	_SX_Init
PUBLIC	_SX_Free
PUBLIC	_CheckNewDspPresets
PUBLIC	_DSP_Process
PUBLIC	_DSP_GetGain
PUBLIC	_DSP_ClearState
PUBLIC	_SX_Profiling_f
PUBLIC	_SX_ReloadRoomFX
PUBLIC	_DLY_Free
PUBLIC	_DLY_Init
PUBLIC	_DLY_MovePointer
PUBLIC	_DLY_CheckNewStereoDelayVal
PUBLIC	_DLY_DoStereoDelay
PUBLIC	_DLY_CheckNewDelayVal
PUBLIC	_DLY_DoDelay
PUBLIC	_RVB_SetUpDly
PUBLIC	_RVB_CheckNewReverbVal
PUBLIC	_RVB_DoReverbForOneDly
PUBLIC	_RVB_DoReverb
PUBLIC	_RVB_DoAMod
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f35c28f
PUBLIC	__real@3f800000
PUBLIC	__real@437f0000
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Q_atof:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_cls:BYTE
EXTRN	_s_listener:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f35c28f
CONST	SEGMENT
__real@3f35c28f DD 03f35c28fr			; 0.71
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG138834 DB	'dsp quality. 1 for 22k, 2 for 44k(recommended) and 3 for'
	DB	' 96k', 00H
	ORG $+3
$SG138835 DB	'2', 00H
	ORG $+2
$SG138836 DB	'room_hires', 00H
	ORG $+1
$SG138837 DB	'disable DSP processing', 00H
	ORG $+1
$SG138838 DB	'0', 00H
	ORG $+2
$SG138839 DB	'dsp_off', 00H
$SG138840 DB	'water room type', 00H
$SG138841 DB	'14', 00H
	ORG $+1
$SG138842 DB	'waterroom_type', 00H
	ORG $+1
$SG138843 DB	'current room type preset', 00H
	ORG $+3
$SG138844 DB	'0', 00H
	ORG $+2
$SG138845 DB	'room_type', 00H
	ORG $+2
$SG138846 DB	'for water fx, lowpass for entire room', 00H
	ORG $+2
$SG138847 DB	'0', 00H
	ORG $+2
$SG138848 DB	'room_lp', 00H
$SG138849 DB	'stereo amptitude modulation for room', 00H
	ORG $+3
$SG138850 DB	'0', 00H
	ORG $+2
$SG138851 DB	'room_mod', 00H
	ORG $+3
$SG138852 DB	'reverb: initial reflection size', 00H
$SG138853 DB	'0', 00H
	ORG $+2
$SG138854 DB	'room_size', 00H
	ORG $+2
$SG138855 DB	'reverb: decay time', 00H
	ORG $+1
$SG138856 DB	'0', 00H
	ORG $+2
$SG138857 DB	'room_refl', 00H
	ORG $+2
$SG138858 DB	'reverb: low pass filtering level', 00H
	ORG $+3
$SG138859 DB	'1', 00H
	ORG $+2
$SG138860 DB	'room_rvblp', 00H
	ORG $+1
$SG138861 DB	'mono delay: delay time', 00H
	ORG $+1
$SG138862 DB	'0.8', 00H
$SG138863 DB	'room_delay', 00H
	ORG $+1
$SG138864 DB	'mono delay: decay time', 00H
	ORG $+1
$SG138865 DB	'0.2', 00H
$SG138866 DB	'room_feedback', 00H
	ORG $+2
$SG138867 DB	'mono delay: low pass filtering level', 00H
	ORG $+3
$SG138868 DB	'1', 00H
	ORG $+2
$SG138869 DB	'room_dlylp', 00H
	ORG $+1
$SG138870 DB	'left channel delay time', 00H
$SG138871 DB	'0', 00H
	ORG $+2
$SG138872 DB	'room_left', 00H
	ORG $+2
$SG138873 DB	'dsp stress-test, first argument is room_type', 00H
	ORG $+3
$SG138874 DB	'dsp_profile', 00H
$SG138882 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\s_dsp.c', 00H
	ORG $+2
$SG138883 DB	'idelay >= 0 && idelay < MAXDLY', 00H
	ORG $+1
$SG138893 DB	'dsp_profile', 00H
$SG138886 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\s_dsp.c', 00H
	ORG $+2
$SG138907 DB	'idelay >= 0 && idelay < MAXDLY', 00H
	ORG $+1
$SG138909 DB	'delay > 0.0f && delay <= MAX_DELAY', 00H
	ORG $+1
$SG138906 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\s_dsp.c', 00H
	ORG $+2
$SG139078 DB	'room_type', 00H
	ORG $+2
$SG138908 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\s_dsp.c', 00H
	ORG $+2
$SG139089 DB	'room_lp', 00H
$SG139090 DB	'room_mod', 00H
	ORG $+3
$SG138910 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\s_dsp.c', 00H
	ORG $+2
$SG139091 DB	'room_size', 00H
	ORG $+2
$SG139092 DB	'room_refl', 00H
	ORG $+2
$SG139093 DB	'room_rvblp', 00H
	ORG $+1
$SG139094 DB	'room_delay', 00H
	ORG $+1
$SG139095 DB	'room_feedback', 00H
	ORG $+2
$SG139096 DB	'room_dlylp', 00H
	ORG $+1
$SG139097 DB	'room_left', 00H
	ORG $+2
$SG139116 DB	'room_type', 00H
	ORG $+2
$SG139117 DB	'Profiling 10000 calls to DSP. Sample count is 512, room_'
	DB	'type is %i', 0aH, 00H
$SG139118 DB	'----------', 0aH, 'Took %g seconds.', 0aH, 00H
	ORG $+3
$SG139120 DB	'room_type', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_res$1 = -28						; size = 8
tv211 = -20						; size = 4
tv210 = -16						; size = 4
tv206 = -12						; size = 4
tv205 = -8						; size = 4
_paint$ = -4						; size = 4
_count$ = 8						; size = 4
_RVB_DoAMod PROC

; 703  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 704  : 	portable_samplepair_t	*paint = paintto;

	mov	eax, DWORD PTR _paintto
	mov	DWORD PTR _paint$[ebp], eax

; 705  : 
; 706  : 	if( !sxmod_lowpass->value && !sxmod_mod->value )

	mov	ecx, DWORD PTR _sxmod_lowpass
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@RVB_DoAMod
	mov	edx, DWORD PTR _sxmod_mod
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@RVB_DoAMod

; 707  : 		return;

	jmp	$LN3@RVB_DoAMod
$LN5@RVB_DoAMod:

; 708  : 
; 709  : 	for( ; count; count--, paint++ )

	jmp	SHORT $LN4@RVB_DoAMod
$LN2@RVB_DoAMod:
	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	mov	ecx, DWORD PTR _paint$[ebp]
	add	ecx, 8
	mov	DWORD PTR _paint$[ebp], ecx
$LN4@RVB_DoAMod:
	cmp	DWORD PTR _count$[ebp], 0
	je	$LN3@RVB_DoAMod

; 710  : 	{
; 711  : 		portable_samplepair_t	res = *paint;

	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _res$1[ebp], eax
	mov	DWORD PTR _res$1[ebp+4], ecx

; 712  : 
; 713  : 		if( sxmod_lowpass->value )

	mov	edx, DWORD PTR _sxmod_lowpass
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@RVB_DoAMod

; 714  : 		{
; 715  : 			res.left  = rgsxlp[0] + rgsxlp[1] + rgsxlp[2] + rgsxlp[3] + rgsxlp[4] + res.left;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _rgsxlp[ecx]
	add	eax, DWORD PTR _rgsxlp[edx]
	mov	ecx, 4
	shl	ecx, 1
	add	eax, DWORD PTR _rgsxlp[ecx]
	mov	edx, 4
	imul	ecx, edx, 3
	add	eax, DWORD PTR _rgsxlp[ecx]
	mov	edx, 4
	shl	edx, 2
	add	eax, DWORD PTR _rgsxlp[edx]
	add	eax, DWORD PTR _res$1[ebp]
	mov	DWORD PTR _res$1[ebp], eax

; 716  : 			res.right = rgsxlp[5] + rgsxlp[6] + rgsxlp[7] + rgsxlp[8] + rgsxlp[9] + res.right;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _rgsxlp[ecx]
	add	ecx, DWORD PTR _rgsxlp[eax]
	mov	edx, 4
	imul	eax, edx, 7
	add	ecx, DWORD PTR _rgsxlp[eax]
	mov	edx, 4
	shl	edx, 3
	add	ecx, DWORD PTR _rgsxlp[edx]
	mov	eax, 4
	imul	edx, eax, 9
	add	ecx, DWORD PTR _rgsxlp[edx]
	add	ecx, DWORD PTR _res$1[ebp+4]
	mov	DWORD PTR _res$1[ebp+4], ecx

; 717  : 
; 718  : 			res.left >>= 2;

	mov	eax, DWORD PTR _res$1[ebp]
	sar	eax, 2
	mov	DWORD PTR _res$1[ebp], eax

; 719  : 			res.right >>= 2;

	mov	ecx, DWORD PTR _res$1[ebp+4]
	sar	ecx, 2
	mov	DWORD PTR _res$1[ebp+4], ecx

; 720  : 
; 721  : 			rgsxlp[0] = rgsxlp[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _rgsxlp[edx]
	mov	DWORD PTR _rgsxlp[ecx], edx

; 722  : 			rgsxlp[1] = rgsxlp[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rgsxlp[eax]
	mov	DWORD PTR _rgsxlp[ecx], edx

; 723  : 			rgsxlp[2] = rgsxlp[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _rgsxlp[ecx]
	mov	DWORD PTR _rgsxlp[edx], eax

; 724  : 			rgsxlp[3] = rgsxlp[4];

	mov	ecx, 4
	shl	ecx, 2
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _rgsxlp[ecx]
	mov	DWORD PTR _rgsxlp[eax], ecx

; 725  : 			rgsxlp[4] = paint->left;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _rgsxlp[edx], ecx

; 726  : 
; 727  : 			rgsxlp[5] = rgsxlp[6];

	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _rgsxlp[eax]
	mov	DWORD PTR _rgsxlp[edx], eax

; 728  : 			rgsxlp[6] = rgsxlp[7];

	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _rgsxlp[edx]
	mov	DWORD PTR _rgsxlp[ecx], edx

; 729  : 			rgsxlp[7] = rgsxlp[8];

	mov	eax, 4
	shl	eax, 3
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _rgsxlp[eax]
	mov	DWORD PTR _rgsxlp[edx], eax

; 730  : 			rgsxlp[8] = rgsxlp[9];

	mov	ecx, 4
	imul	edx, ecx, 9
	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _rgsxlp[edx]
	mov	DWORD PTR _rgsxlp[eax], ecx

; 731  : 			rgsxlp[9] = paint->right;

	mov	edx, 4
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _paint$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _rgsxlp[eax], edx
$LN6@RVB_DoAMod:

; 732  : 		}
; 733  : 
; 734  : 		if( sxmod_mod->value )

	mov	eax, DWORD PTR _sxmod_mod
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN17@RVB_DoAMod

; 735  : 		{
; 736  : 			if( --sxmod1cur < 0 )

	mov	ecx, DWORD PTR _sxmod1cur
	sub	ecx, 1
	mov	DWORD PTR _sxmod1cur, ecx
	jns	SHORT $LN8@RVB_DoAMod

; 737  : 				sxmod1cur = sxmod1;

	mov	edx, DWORD PTR _sxmod1
	mov	DWORD PTR _sxmod1cur, edx
$LN8@RVB_DoAMod:

; 738  : 
; 739  : 			if( !sxmod1 )

	cmp	DWORD PTR _sxmod1, 0
	jne	SHORT $LN9@RVB_DoAMod

; 740  : 				sxamodlt = COM_RandomLong( 32, 255 );

	push	255					; 000000ffH
	push	32					; 00000020H
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _sxamodlt, eax
$LN9@RVB_DoAMod:

; 741  : 
; 742  : 			if( --sxmod2cur < 0 )

	mov	eax, DWORD PTR _sxmod2cur
	sub	eax, 1
	mov	DWORD PTR _sxmod2cur, eax
	jns	SHORT $LN10@RVB_DoAMod

; 743  : 				sxmod2cur = sxmod2;

	mov	ecx, DWORD PTR _sxmod2
	mov	DWORD PTR _sxmod2cur, ecx
$LN10@RVB_DoAMod:

; 744  : 
; 745  : 			if( !sxmod2 )

	cmp	DWORD PTR _sxmod2, 0
	jne	SHORT $LN11@RVB_DoAMod

; 746  : 				sxamodrt = COM_RandomLong( 32, 255 );

	push	255					; 000000ffH
	push	32					; 00000020H
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _sxamodrt, eax
$LN11@RVB_DoAMod:

; 747  : 
; 748  : 			res.left = (sxamodl * res.left) >> 8;

	mov	edx, DWORD PTR _sxamodl
	imul	edx, DWORD PTR _res$1[ebp]
	sar	edx, 8
	mov	DWORD PTR _res$1[ebp], edx

; 749  : 			res.right = (sxamodr * res.right) >> 8;

	mov	eax, DWORD PTR _sxamodr
	imul	eax, DWORD PTR _res$1[ebp+4]
	sar	eax, 8
	mov	DWORD PTR _res$1[ebp+4], eax

; 750  : 
; 751  : 			if( sxamodl < sxamodlt )

	mov	ecx, DWORD PTR _sxamodl
	cmp	ecx, DWORD PTR _sxamodlt
	jge	SHORT $LN12@RVB_DoAMod

; 752  : 				sxamodl++;

	mov	edx, DWORD PTR _sxamodl
	add	edx, 1
	mov	DWORD PTR _sxamodl, edx
	jmp	SHORT $LN14@RVB_DoAMod
$LN12@RVB_DoAMod:

; 753  : 			else if( sxamodl > sxamodlt )

	mov	eax, DWORD PTR _sxamodl
	cmp	eax, DWORD PTR _sxamodlt
	jle	SHORT $LN14@RVB_DoAMod

; 754  : 				sxamodl--;

	mov	ecx, DWORD PTR _sxamodl
	sub	ecx, 1
	mov	DWORD PTR _sxamodl, ecx
$LN14@RVB_DoAMod:

; 755  : 
; 756  : 			if( sxamodr < sxamodrt )

	mov	edx, DWORD PTR _sxamodr
	cmp	edx, DWORD PTR _sxamodrt
	jge	SHORT $LN15@RVB_DoAMod

; 757  : 				sxamodr++;

	mov	eax, DWORD PTR _sxamodr
	add	eax, 1
	mov	DWORD PTR _sxamodr, eax
	jmp	SHORT $LN17@RVB_DoAMod
$LN15@RVB_DoAMod:

; 758  : 			else if( sxamodr > sxamodrt )

	mov	ecx, DWORD PTR _sxamodr
	cmp	ecx, DWORD PTR _sxamodrt
	jle	SHORT $LN17@RVB_DoAMod

; 759  : 				sxamodr--;

	mov	edx, DWORD PTR _sxamodr
	sub	edx, 1
	mov	DWORD PTR _sxamodr, edx
$LN17@RVB_DoAMod:

; 760  : 		}
; 761  : 
; 762  : 		paint->left = CLIP(res.left);

	cmp	DWORD PTR _res$1[ebp], 32760		; 00007ff8H
	jle	SHORT $LN21@RVB_DoAMod
	mov	DWORD PTR tv206[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN22@RVB_DoAMod
$LN21@RVB_DoAMod:
	cmp	DWORD PTR _res$1[ebp], -32760		; ffff8008H
	jge	SHORT $LN19@RVB_DoAMod
	mov	DWORD PTR tv205[ebp], -32760		; ffff8008H
	jmp	SHORT $LN20@RVB_DoAMod
$LN19@RVB_DoAMod:
	mov	eax, DWORD PTR _res$1[ebp]
	mov	DWORD PTR tv205[ebp], eax
$LN20@RVB_DoAMod:
	mov	ecx, DWORD PTR tv205[ebp]
	mov	DWORD PTR tv206[ebp], ecx
$LN22@RVB_DoAMod:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR tv206[ebp]
	mov	DWORD PTR [edx], eax

; 763  : 		paint->right = CLIP(res.right);

	cmp	DWORD PTR _res$1[ebp+4], 32760		; 00007ff8H
	jle	SHORT $LN25@RVB_DoAMod
	mov	DWORD PTR tv211[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN26@RVB_DoAMod
$LN25@RVB_DoAMod:
	cmp	DWORD PTR _res$1[ebp+4], -32760		; ffff8008H
	jge	SHORT $LN23@RVB_DoAMod
	mov	DWORD PTR tv210[ebp], -32760		; ffff8008H
	jmp	SHORT $LN24@RVB_DoAMod
$LN23@RVB_DoAMod:
	mov	ecx, DWORD PTR _res$1[ebp+4]
	mov	DWORD PTR tv210[ebp], ecx
$LN24@RVB_DoAMod:
	mov	edx, DWORD PTR tv210[ebp]
	mov	DWORD PTR tv211[ebp], edx
$LN26@RVB_DoAMod:
	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR tv211[ebp]
	mov	DWORD PTR [eax+4], ecx

; 764  : 	}

	jmp	$LN2@RVB_DoAMod
$LN3@RVB_DoAMod:

; 765  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RVB_DoAMod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_dly2$ = -36						; size = 4
tv141 = -32						; size = 4
tv140 = -28						; size = 4
tv130 = -24						; size = 4
tv129 = -20						; size = 4
_vlr$ = -16						; size = 4
_dly1$ = -12						; size = 4
_voutm$ = -8						; size = 4
_paint$ = -4						; size = 4
_count$ = 8						; size = 4
_RVB_DoReverb PROC

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 673  : 	dly_t *const		dly1 = &rgsxdly[REVERBPOS];

	mov	eax, 56					; 00000038H
	shl	eax, 0
	add	eax, OFFSET _rgsxdly
	mov	DWORD PTR _dly1$[ebp], eax

; 674  : 	dly_t *const		dly2 = &rgsxdly[REVERBPOS+1];

	mov	ecx, 56					; 00000038H
	shl	ecx, 1
	add	ecx, OFFSET _rgsxdly
	mov	DWORD PTR _dly2$[ebp], ecx

; 675  : 	portable_samplepair_t	*paint = paintto;

	mov	edx, DWORD PTR _paintto
	mov	DWORD PTR _paint$[ebp], edx

; 676  : 	int			vlr, voutm;
; 677  : 
; 678  : 	if( !dly1->lpdelayline )

	mov	eax, DWORD PTR _dly1$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN5@RVB_DoReve

; 679  : 		return;

	jmp	$LN1@RVB_DoReve
$LN5@RVB_DoReve:

; 680  : 
; 681  : 	for( ; count; count--, paint++ )

	jmp	SHORT $LN4@RVB_DoReve
$LN2@RVB_DoReve:
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _paint$[ebp]
	add	edx, 8
	mov	DWORD PTR _paint$[ebp], edx
$LN4@RVB_DoReve:
	cmp	DWORD PTR _count$[ebp], 0
	je	$LN1@RVB_DoReve

; 682  : 	{
; 683  : 		vlr = ( paint->left + paint->right ) >> 1;

	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _paint$[ebp]
	add	ecx, DWORD PTR [edx+4]
	sar	ecx, 1
	mov	DWORD PTR _vlr$[ebp], ecx

; 684  : 
; 685  : 		voutm = RVB_DoReverbForOneDly( dly1, vlr, paint );

	mov	eax, DWORD PTR _paint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vlr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dly1$[ebp]
	push	edx
	call	_RVB_DoReverbForOneDly
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _voutm$[ebp], eax

; 686  : 		voutm += RVB_DoReverbForOneDly( dly2, vlr, paint );

	mov	eax, DWORD PTR _paint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vlr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dly2$[ebp]
	push	edx
	call	_RVB_DoReverbForOneDly
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _voutm$[ebp]
	mov	DWORD PTR _voutm$[ebp], eax

; 687  : 
; 688  : 		voutm = (11 * voutm) >> 6;

	imul	eax, DWORD PTR _voutm$[ebp], 11
	sar	eax, 6
	mov	DWORD PTR _voutm$[ebp], eax

; 689  : 
; 690  : 		paint->left = CLIP( paint->left + voutm );

	mov	ecx, DWORD PTR _paint$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _voutm$[ebp]
	cmp	edx, 32760				; 00007ff8H
	jle	SHORT $LN9@RVB_DoReve
	mov	DWORD PTR tv130[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN10@RVB_DoReve
$LN9@RVB_DoReve:
	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _voutm$[ebp]
	cmp	ecx, -32760				; ffff8008H
	jge	SHORT $LN7@RVB_DoReve
	mov	DWORD PTR tv129[ebp], -32760		; ffff8008H
	jmp	SHORT $LN8@RVB_DoReve
$LN7@RVB_DoReve:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _voutm$[ebp]
	mov	DWORD PTR tv129[ebp], eax
$LN8@RVB_DoReve:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv130[ebp], ecx
$LN10@RVB_DoReve:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR [edx], eax

; 691  : 		paint->right = CLIP( paint->right + voutm );

	mov	ecx, DWORD PTR _paint$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _voutm$[ebp]
	cmp	edx, 32760				; 00007ff8H
	jle	SHORT $LN13@RVB_DoReve
	mov	DWORD PTR tv141[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN14@RVB_DoReve
$LN13@RVB_DoReve:
	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _voutm$[ebp]
	cmp	ecx, -32760				; ffff8008H
	jge	SHORT $LN11@RVB_DoReve
	mov	DWORD PTR tv140[ebp], -32760		; ffff8008H
	jmp	SHORT $LN12@RVB_DoReve
$LN11@RVB_DoReve:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _voutm$[ebp]
	mov	DWORD PTR tv140[ebp], eax
$LN12@RVB_DoReve:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], ecx
$LN14@RVB_DoReve:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+4], eax

; 692  : 	}

	jmp	$LN2@RVB_DoReve
$LN1@RVB_DoReve:

; 693  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RVB_DoReverb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_samplexf$ = -40					; size = 4
tv165 = -36						; size = 4
tv164 = -32						; size = 4
tv153 = -28						; size = 4
tv147 = -24						; size = 4
tv66 = -20						; size = 4
_voutm$ = -16						; size = 4
_valt$ = -12						; size = 4
_delay$ = -8						; size = 4
_val$ = -4						; size = 4
_dly$ = 8						; size = 4
_vlr$ = 12						; size = 4
_samplepair$ = 16					; size = 4
_RVB_DoReverbForOneDly PROC

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 599  : 	int	delay;
; 600  : 	int	samplexf;
; 601  : 	int	val, valt;
; 602  : 	int	voutm = 0;

	mov	DWORD PTR _voutm$[ebp], 0

; 603  : 
; 604  : 	if( --dly->modcur < 0 )

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	sub	ecx, 1
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR [edx+48], eax
	cmp	DWORD PTR tv66[ebp], 0
	jge	SHORT $LN2@RVB_DoReve

; 605  : 		dly->modcur = dly->mod;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+48], eax
$LN2@RVB_DoReve:

; 606  : 
; 607  : 	delay = dly->lpdelayline[dly->idelayoutput];

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _delay$[ebp], edx

; 608  : 
; 609  : 	if( dly->xfade || delay || samplepair->left || samplepair->right )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN5@RVB_DoReve
	cmp	DWORD PTR _delay$[ebp], 0
	jne	SHORT $LN5@RVB_DoReve
	mov	ecx, DWORD PTR _samplepair$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@RVB_DoReve
	mov	edx, DWORD PTR _samplepair$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN3@RVB_DoReve
$LN5@RVB_DoReve:

; 610  : 	{
; 611  : 		// modulate delay rate
; 612  : 		if( !dly->xfade && !dly->modcur && dly->mod )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN6@RVB_DoReve
	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN6@RVB_DoReve
	mov	edx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN6@RVB_DoReve

; 613  : 		{
; 614  : 			dly->idelayoutputxf = dly->idelayoutput + ((COM_RandomLong( 0, 255 ) * delay) >> 9 );

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	imul	eax, DWORD PTR _delay$[ebp]
	sar	eax, 9
	mov	ecx, DWORD PTR _dly$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN6@RVB_DoReve:

; 615  : 
; 616  : 			//dly->xfade = 32;
; 617  : 		}
; 618  : 
; 619  : 		dly->idelayoutputxf %= dly->cdelaysamplesmax;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+12], edx

; 620  : 
; 621  : 		if( dly->xfade )

	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	$LN7@RVB_DoReve

; 622  : 		{
; 623  : 			samplexf = (dly->lpdelayline[dly->idelayoutputxf] * (REVERB_XFADE - dly->xfade)) / REVERB_XFADE;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	esi, 32					; 00000020H
	sub	esi, DWORD PTR [ecx+16]
	mov	ecx, esi
	imul	ecx, DWORD PTR [edx+eax*4]
	mov	eax, ecx
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	mov	DWORD PTR _samplexf$[ebp], eax

; 624  : 			delay = ((delay * dly->xfade) / REVERB_XFADE) + samplexf;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _delay$[ebp]
	imul	eax, DWORD PTR [edx+16]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	add	eax, DWORD PTR _samplexf$[ebp]
	mov	DWORD PTR _delay$[ebp], eax

; 625  : 
; 626  : 			if( ++dly->idelayoutputxf >= dly->cdelaysamplesmax )

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR tv147[ebp]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN8@RVB_DoReve

; 627  : 				dly->idelayoutputxf = 0;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN8@RVB_DoReve:

; 628  : 
; 629  : 			if( --dly->xfade == 0 )

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, 1
	mov	DWORD PTR tv153[ebp], edx
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax+16], ecx
	cmp	DWORD PTR tv153[ebp], 0
	jne	SHORT $LN7@RVB_DoReve

; 630  : 				dly->idelayoutput = dly->idelayoutputxf;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+8], ecx
$LN7@RVB_DoReve:

; 631  : 		}
; 632  : 
; 633  : 
; 634  : 		if( delay )

	cmp	DWORD PTR _delay$[ebp], 0
	je	SHORT $LN10@RVB_DoReve

; 635  : 		{
; 636  : 			val = vlr + ( ( dly->delayfeedback * delay ) >> 8 );

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, DWORD PTR _delay$[ebp]
	sar	eax, 8
	add	eax, DWORD PTR _vlr$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 637  : 			val = CLIP( val );

	cmp	DWORD PTR _val$[ebp], 32760		; 00007ff8H
	jle	SHORT $LN17@RVB_DoReve
	mov	DWORD PTR tv165[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN18@RVB_DoReve
$LN17@RVB_DoReve:
	cmp	DWORD PTR _val$[ebp], -32760		; ffff8008H
	jge	SHORT $LN15@RVB_DoReve
	mov	DWORD PTR tv164[ebp], -32760		; ffff8008H
	jmp	SHORT $LN16@RVB_DoReve
$LN15@RVB_DoReve:
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR tv164[ebp], ecx
$LN16@RVB_DoReve:
	mov	edx, DWORD PTR tv164[ebp]
	mov	DWORD PTR tv165[ebp], edx
$LN18@RVB_DoReve:
	mov	eax, DWORD PTR tv165[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 638  : 		}

	jmp	SHORT $LN11@RVB_DoReve
$LN10@RVB_DoReve:

; 639  : 		else
; 640  : 			val = vlr;

	mov	ecx, DWORD PTR _vlr$[ebp]
	mov	DWORD PTR _val$[ebp], ecx
$LN11@RVB_DoReve:

; 641  : 
; 642  : 		if( dly->lp )

	mov	edx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN12@RVB_DoReve

; 643  : 		{
; 644  : 			valt = (dly->lp0 + val) >> 1;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _val$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _valt$[ebp], ecx

; 645  : 			dly->lp0 = val;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx+32], eax

; 646  : 		}

	jmp	SHORT $LN13@RVB_DoReve
$LN12@RVB_DoReve:

; 647  : 		else
; 648  : 			valt = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _valt$[ebp], ecx
$LN13@RVB_DoReve:

; 649  : 
; 650  : 		voutm = dly->lpdelayline[dly->idelayinput] = valt;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _valt$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _valt$[ebp]
	mov	DWORD PTR _voutm$[ebp], edx

; 651  : 	}

	jmp	SHORT $LN4@RVB_DoReve
$LN3@RVB_DoReve:

; 652  : 	else
; 653  : 	{
; 654  : 		voutm = dly->lpdelayline[dly->idelayinput] = 0;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [eax+ecx*4], 0
	mov	DWORD PTR _voutm$[ebp], 0

; 655  : 		dly->lp0 = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+32], 0
$LN4@RVB_DoReve:

; 656  : 	}
; 657  : 
; 658  : 	DLY_MovePointer( dly );

	mov	edx, DWORD PTR _dly$[ebp]
	push	edx
	call	_DLY_MovePointer
	add	esp, 4

; 659  : 
; 660  : 	return voutm;

	mov	eax, DWORD PTR _voutm$[ebp]

; 661  : 
; 662  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_RVB_DoReverbForOneDly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_delay$ = -20						; size = 4
tv128 = -16						; size = 4
_dly1$ = -12						; size = 4
_dly2$ = -8						; size = 4
tv90 = -4						; size = 4
_RVB_CheckNewReverbVal PROC

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 567  : 	dly_t *const	dly1 = &rgsxdly[REVERBPOS];

	mov	eax, 56					; 00000038H
	shl	eax, 0
	add	eax, OFFSET _rgsxdly
	mov	DWORD PTR _dly1$[ebp], eax

; 568  : 	dly_t *const	dly2 = &rgsxdly[REVERBPOS + 1];

	mov	ecx, 56					; 00000038H
	shl	ecx, 1
	add	ecx, OFFSET _rgsxdly
	mov	DWORD PTR _dly2$[ebp], ecx

; 569  : 	float		delay = sxrvb_size->value;

	mov	edx, DWORD PTR _sxrvb_size
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _delay$[ebp], xmm0

; 570  : 
; 571  : 	if( FBitSet( sxrvb_size->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _sxrvb_size
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN4@RVB_CheckN

; 572  : 	{
; 573  : 		if( delay == 0.0f )

	movss	xmm0, DWORD PTR _delay$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@RVB_CheckN

; 574  : 		{
; 575  : 			DLY_Free( REVERBPOS );

	push	1
	call	_DLY_Free
	add	esp, 4

; 576  : 			DLY_Free( REVERBPOS + 1 );

	push	2
	call	_DLY_Free
	add	esp, 4

; 577  : 		}

	jmp	SHORT $LN4@RVB_CheckN
$LN3@RVB_CheckN:

; 578  : 		else
; 579  : 		{
; 580  : 			RVB_SetUpDly( REVERBPOS, sxrvb_size->value, 500 );

	push	500					; 000001f4H
	mov	edx, DWORD PTR _sxrvb_size
	push	ecx
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_RVB_SetUpDly
	add	esp, 12					; 0000000cH

; 581  : 			RVB_SetUpDly( REVERBPOS+1, sxrvb_size->value * 0.71f, 700 );

	push	700					; 000002bcH
	mov	eax, DWORD PTR _sxrvb_size
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR __real@3f35c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	call	_RVB_SetUpDly
	add	esp, 12					; 0000000cH
$LN4@RVB_CheckN:

; 582  : 		}
; 583  : 	}
; 584  : 
; 585  : 	ClearBits( sxrvb_size->flags, FCVAR_CHANGED );

	mov	ecx, DWORD PTR _sxrvb_size
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -8193				; ffffdfffH
	mov	eax, DWORD PTR _sxrvb_size
	mov	DWORD PTR [eax+8], edx

; 586  : 	dly1->lp = dly2->lp = sxrvb_lp->value;

	mov	ecx, DWORD PTR _sxrvb_lp
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv90[ebp], edx
	mov	eax, DWORD PTR _dly2$[ebp]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR _dly1$[ebp]
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR [edx+28], eax

; 587  : 	dly1->delayfeedback = dly2->delayfeedback = (int)(255 * sxrvb_feedback->value);

	mov	ecx, DWORD PTR _sxrvb_feedback
	movss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm0, DWORD PTR [ecx+12]
	cvttss2si edx, xmm0
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR _dly2$[ebp]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _dly1$[ebp]
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR [edx+24], eax

; 588  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RVB_CheckNewReverbVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv88 = -12						; size = 4
tv65 = -8						; size = 4
_samples$ = -4						; size = 4
_pos$ = 8						; size = 4
_delay$ = 12						; size = 4
_kmod$ = 16						; size = 4
_RVB_SetUpDly PROC

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 531  : 	int	samples;
; 532  : 
; 533  : 	delay = Q_min( delay, MAX_REVERB_DELAY );

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jbe	SHORT $LN7@RVB_SetUpD
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN8@RVB_SetUpD
$LN7@RVB_SetUpD:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv65[ebp], xmm0
$LN8@RVB_SetUpD:
	movss	xmm0, DWORD PTR tv65[ebp]
	movss	DWORD PTR _delay$[ebp], xmm0

; 534  : 	samples = (int)(delay * idsp_dma_speed) << sxhires;

	cvtsi2ss xmm0, DWORD PTR _idsp_dma_speed
	mulss	xmm0, DWORD PTR _delay$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _sxhires
	shl	eax, cl
	mov	DWORD PTR _samples$[ebp], eax

; 535  : 
; 536  : 	if( !rgsxdly[pos].lpdelayline )

	imul	ecx, DWORD PTR _pos$[ebp], 56
	cmp	DWORD PTR _rgsxdly[ecx+52], 0
	jne	SHORT $LN2@RVB_SetUpD

; 537  : 	{
; 538  : 		rgsxdly[pos].delaysamples = samples;

	imul	edx, DWORD PTR _pos$[ebp], 56
	mov	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _rgsxdly[edx+20], eax

; 539  : 		DLY_Init( pos, MAX_REVERB_DELAY );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_DLY_Init
	add	esp, 8
$LN2@RVB_SetUpD:

; 540  : 	}
; 541  : 
; 542  : 	rgsxdly[pos].modcur = rgsxdly[pos].mod = (int)(kmod * idsp_dma_speed / SOUND_11k) << sxhires;

	mov	eax, DWORD PTR _kmod$[ebp]
	imul	eax, DWORD PTR _idsp_dma_speed
	cdq
	mov	ecx, 11025				; 00002b11H
	idiv	ecx
	mov	ecx, DWORD PTR _sxhires
	shl	eax, cl
	mov	DWORD PTR tv88[ebp], eax
	imul	edx, DWORD PTR _pos$[ebp], 56
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR _rgsxdly[edx+44], eax
	imul	ecx, DWORD PTR _pos$[ebp], 56
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR _rgsxdly[ecx+48], edx

; 543  : 
; 544  : 	// set up crossfade, if delay has changed
; 545  : 	if( rgsxdly[pos].delaysamples != samples )

	imul	eax, DWORD PTR _pos$[ebp], 56
	mov	ecx, DWORD PTR _rgsxdly[eax+20]
	cmp	ecx, DWORD PTR _samples$[ebp]
	je	SHORT $LN3@RVB_SetUpD

; 546  : 	{
; 547  : 		rgsxdly[pos].idelayoutputxf = rgsxdly[pos].idelayinput - samples;

	imul	edx, DWORD PTR _pos$[ebp], 56
	mov	eax, DWORD PTR _rgsxdly[edx+4]
	sub	eax, DWORD PTR _samples$[ebp]
	imul	ecx, DWORD PTR _pos$[ebp], 56
	mov	DWORD PTR _rgsxdly[ecx+12], eax

; 548  : 		if( rgsxdly[pos].idelayoutputxf < 0 )

	imul	edx, DWORD PTR _pos$[ebp], 56
	cmp	DWORD PTR _rgsxdly[edx+12], 0
	jae	SHORT $LN4@RVB_SetUpD

; 549  : 			rgsxdly[pos].idelayoutputxf += rgsxdly[pos].cdelaysamplesmax;

	imul	eax, DWORD PTR _pos$[ebp], 56
	imul	ecx, DWORD PTR _pos$[ebp], 56
	mov	edx, DWORD PTR _rgsxdly[eax+12]
	add	edx, DWORD PTR _rgsxdly[ecx]
	imul	eax, DWORD PTR _pos$[ebp], 56
	mov	DWORD PTR _rgsxdly[eax+12], edx
$LN4@RVB_SetUpD:

; 550  : 		rgsxdly[pos].xfade = 32;

	imul	ecx, DWORD PTR _pos$[ebp], 56
	mov	DWORD PTR _rgsxdly[ecx+16], 32		; 00000020H
$LN3@RVB_SetUpD:

; 551  : 	}
; 552  : 
; 553  : 	if( !rgsxdly[pos].delaysamples )

	imul	edx, DWORD PTR _pos$[ebp], 56
	cmp	DWORD PTR _rgsxdly[edx+20], 0
	jne	SHORT $LN5@RVB_SetUpD

; 554  : 		DLY_Free( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_DLY_Free
	add	esp, 4
$LN5@RVB_SetUpD:

; 555  : 
; 556  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RVB_SetUpDly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv162 = -40						; size = 4
tv161 = -36						; size = 4
tv151 = -32						; size = 4
tv150 = -28						; size = 4
tv92 = -24						; size = 4
tv91 = -20						; size = 4
_delay$ = -16						; size = 4
_paint$ = -12						; size = 4
_val$1 = -8						; size = 4
_dly$ = -4						; size = 4
_count$ = 8						; size = 4
_DLY_DoDelay PROC

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 480  : 	dly_t *const		dly = &rgsxdly[MONODLY];

	mov	eax, 56					; 00000038H
	imul	ecx, eax, 0
	add	ecx, OFFSET _rgsxdly
	mov	DWORD PTR _dly$[ebp], ecx

; 481  : 	portable_samplepair_t	*paint = paintto;

	mov	edx, DWORD PTR _paintto
	mov	DWORD PTR _paint$[ebp], edx

; 482  : 	int			delay;
; 483  : 
; 484  : 	if( !dly->lpdelayline || !count )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN6@DLY_DoDela
	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN5@DLY_DoDela
$LN6@DLY_DoDela:

; 485  : 		return; // inactive

	jmp	$LN1@DLY_DoDela
$LN5@DLY_DoDela:

; 486  : 
; 487  : 	for( ; count; count--, paint++ )

	jmp	SHORT $LN4@DLY_DoDela
$LN2@DLY_DoDela:
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _paint$[ebp]
	add	edx, 8
	mov	DWORD PTR _paint$[ebp], edx
$LN4@DLY_DoDela:
	cmp	DWORD PTR _count$[ebp], 0
	je	$LN1@DLY_DoDela

; 488  : 	{
; 489  : 		delay = dly->lpdelayline[dly->idelayoutput];

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _delay$[ebp], ecx

; 490  : 
; 491  : 		// don't process if delay line and left/right samples are zero
; 492  : 		if( delay || paint->left || paint->right )

	cmp	DWORD PTR _delay$[ebp], 0
	jne	SHORT $LN9@DLY_DoDela
	mov	edx, DWORD PTR _paint$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@DLY_DoDela
	mov	eax, DWORD PTR _paint$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN7@DLY_DoDela
$LN9@DLY_DoDela:

; 493  : 		{
; 494  : 			// calculate delayed value from average
; 495  : 			int val = (( paint->left + paint->right ) >> 1 ) + (( dly->delayfeedback * delay ) >> 8);

	mov	ecx, DWORD PTR _paint$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _paint$[ebp]
	add	edx, DWORD PTR [eax+4]
	sar	edx, 1
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	imul	eax, DWORD PTR _delay$[ebp]
	sar	eax, 8
	add	edx, eax
	mov	DWORD PTR _val$1[ebp], edx

; 496  : 			val = CLIP( val );

	cmp	DWORD PTR _val$1[ebp], 32760		; 00007ff8H
	jle	SHORT $LN14@DLY_DoDela
	mov	DWORD PTR tv92[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN15@DLY_DoDela
$LN14@DLY_DoDela:
	cmp	DWORD PTR _val$1[ebp], -32760		; ffff8008H
	jge	SHORT $LN12@DLY_DoDela
	mov	DWORD PTR tv91[ebp], -32760		; ffff8008H
	jmp	SHORT $LN13@DLY_DoDela
$LN12@DLY_DoDela:
	mov	ecx, DWORD PTR _val$1[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN13@DLY_DoDela:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR tv92[ebp], edx
$LN15@DLY_DoDela:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR _val$1[ebp], eax

; 497  : 
; 498  : 			if( dly->lp ) // lowpass

	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN10@DLY_DoDela

; 499  : 			{
; 500  : 				dly->lp0 = dly->lp1;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+32], ecx

; 501  : 				dly->lp1 = val;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _val$1[ebp]
	mov	DWORD PTR [edx+36], eax

; 502  : 				val = ( dly->lp0 + dly->lp1 + (val << 1) ) >> 2;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dly$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _val$1[ebp]
	lea	edx, DWORD PTR [edx+ecx*2]
	sar	edx, 2
	mov	DWORD PTR _val$1[ebp], edx
$LN10@DLY_DoDela:

; 503  : 			}
; 504  : 
; 505  : 			dly->lpdelayline[dly->idelayinput] = val;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	edx, DWORD PTR _val$1[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 506  : 
; 507  : 			val >>= 2;

	mov	eax, DWORD PTR _val$1[ebp]
	sar	eax, 2
	mov	DWORD PTR _val$1[ebp], eax

; 508  : 
; 509  : 			paint->left = CLIP( paint->left + val );

	mov	ecx, DWORD PTR _paint$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _val$1[ebp]
	cmp	edx, 32760				; 00007ff8H
	jle	SHORT $LN18@DLY_DoDela
	mov	DWORD PTR tv151[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN19@DLY_DoDela
$LN18@DLY_DoDela:
	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _val$1[ebp]
	cmp	ecx, -32760				; ffff8008H
	jge	SHORT $LN16@DLY_DoDela
	mov	DWORD PTR tv150[ebp], -32760		; ffff8008H
	jmp	SHORT $LN17@DLY_DoDela
$LN16@DLY_DoDela:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _val$1[ebp]
	mov	DWORD PTR tv150[ebp], eax
$LN17@DLY_DoDela:
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv151[ebp], ecx
$LN19@DLY_DoDela:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR tv151[ebp]
	mov	DWORD PTR [edx], eax

; 510  : 			paint->right = CLIP( paint->right + val );

	mov	ecx, DWORD PTR _paint$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _val$1[ebp]
	cmp	edx, 32760				; 00007ff8H
	jle	SHORT $LN22@DLY_DoDela
	mov	DWORD PTR tv162[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN23@DLY_DoDela
$LN22@DLY_DoDela:
	mov	eax, DWORD PTR _paint$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _val$1[ebp]
	cmp	ecx, -32760				; ffff8008H
	jge	SHORT $LN20@DLY_DoDela
	mov	DWORD PTR tv161[ebp], -32760		; ffff8008H
	jmp	SHORT $LN21@DLY_DoDela
$LN20@DLY_DoDela:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _val$1[ebp]
	mov	DWORD PTR tv161[ebp], eax
$LN21@DLY_DoDela:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv162[ebp], ecx
$LN23@DLY_DoDela:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR [edx+4], eax

; 511  : 		}

	jmp	SHORT $LN8@DLY_DoDela
$LN7@DLY_DoDela:

; 512  : 		else
; 513  : 		{
; 514  : 			dly->lpdelayline[dly->idelayinput] = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+edx*4], 0

; 515  : 			dly->lp0 = dly->lp1 = 0;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+36], 0
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+32], 0
$LN8@DLY_DoDela:

; 516  : 		}
; 517  : 
; 518  : 		DLY_MovePointer( dly );

	mov	ecx, DWORD PTR _dly$[ebp]
	push	ecx
	call	_DLY_MovePointer
	add	esp, 4

; 519  : 	}

	jmp	$LN2@DLY_DoDela
$LN1@DLY_DoDela:

; 520  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_DoDelay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv73 = -12						; size = 4
_delay$ = -8						; size = 4
_dly$ = -4						; size = 4
_DLY_CheckNewDelayVal PROC

; 432  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 433  : 	float		delay = sxdly_delay->value;

	mov	eax, DWORD PTR _sxdly_delay
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _delay$[ebp], xmm0

; 434  : 	dly_t *const	dly = &rgsxdly[MONODLY];

	mov	ecx, 56					; 00000038H
	imul	edx, ecx, 0
	add	edx, OFFSET _rgsxdly
	mov	DWORD PTR _dly$[ebp], edx

; 435  : 
; 436  : 	if( FBitSet( sxdly_delay->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _sxdly_delay
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	$LN7@DLY_CheckN

; 437  : 	{
; 438  : 		if( delay == 0 )

	movss	xmm0, DWORD PTR _delay$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@DLY_CheckN

; 439  : 		{
; 440  : 			DLY_Free( MONODLY );

	push	0
	call	_DLY_Free
	add	esp, 4

; 441  : 		}

	jmp	$LN7@DLY_CheckN
$LN3@DLY_CheckN:

; 442  : 		else
; 443  : 		{
; 444  : 			delay = min( delay, MAX_MONO_DELAY );

	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jbe	SHORT $LN9@DLY_CheckN
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR tv73[ebp], xmm0
	jmp	SHORT $LN10@DLY_CheckN
$LN9@DLY_CheckN:
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR tv73[ebp], xmm0
$LN10@DLY_CheckN:
	movss	xmm0, DWORD PTR tv73[ebp]
	movss	DWORD PTR _delay$[ebp], xmm0

; 445  : 			dly->delaysamples = (int)(delay * idsp_dma_speed) << sxhires;

	cvtsi2ss xmm0, DWORD PTR _idsp_dma_speed
	mulss	xmm0, DWORD PTR _delay$[ebp]
	cvttss2si edx, xmm0
	mov	ecx, DWORD PTR _sxhires
	shl	edx, cl
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+20], edx

; 446  : 
; 447  : 			// init dly
; 448  : 			if( !dly->lpdelayline )

	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN5@DLY_CheckN

; 449  : 				DLY_Init( MONODLY, MAX_MONO_DELAY );

	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	push	0
	call	_DLY_Init
	add	esp, 8
$LN5@DLY_CheckN:

; 450  : 
; 451  : 			if( dly->lpdelayline )

	mov	edx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN6@DLY_CheckN

; 452  : 			{
; 453  : 				memset( dly->lpdelayline, 0, dly->cdelaysamplesmax * sizeof( int ) );

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 454  : 				dly->lp0 = dly->lp1 = dly->lp2 = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+40], 0
	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+36], 0
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+32], 0
$LN6@DLY_CheckN:

; 455  : 			}
; 456  : 
; 457  : 			dly->idelayinput = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 458  : 			dly->idelayoutput = dly->cdelaysamplesmax - dly->delaysamples;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 459  : 
; 460  : 			if( !dly->delaysamples )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN7@DLY_CheckN

; 461  : 				DLY_Free( MONODLY );

	push	0
	call	_DLY_Free
	add	esp, 4
$LN7@DLY_CheckN:

; 462  : 
; 463  : 		}
; 464  : 	}
; 465  : 
; 466  : 	ClearBits( sxdly_delay->flags, FCVAR_CHANGED );

	mov	ecx, DWORD PTR _sxdly_delay
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -8193				; ffffdfffH
	mov	eax, DWORD PTR _sxdly_delay
	mov	DWORD PTR [eax+8], edx

; 467  : 	dly->lp = sxdly_lp->value;

	mov	ecx, DWORD PTR _sxdly_lp
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+28], edx

; 468  : 	dly->delayfeedback = 255 * sxdly_feedback->value;

	mov	ecx, DWORD PTR _sxdly_feedback
	movss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm0, DWORD PTR [ecx+12]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+24], edx

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_CheckNewDelayVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_samplexf$ = -36					; size = 4
tv176 = -32						; size = 4
tv175 = -28						; size = 4
tv162 = -24						; size = 4
tv156 = -20						; size = 4
tv75 = -16						; size = 4
_delay$ = -12						; size = 4
_paint$ = -8						; size = 4
_dly$ = -4						; size = 4
_count$ = 8						; size = 4
_DLY_DoStereoDelay PROC

; 367  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 368  : 	int			delay, samplexf;
; 369  : 	dly_t *const		dly = &rgsxdly[STEREODLY];

	mov	eax, 56					; 00000038H
	imul	ecx, eax, 3
	add	ecx, OFFSET _rgsxdly
	mov	DWORD PTR _dly$[ebp], ecx

; 370  : 	portable_samplepair_t	*paint = paintto;

	mov	edx, DWORD PTR _paintto
	mov	DWORD PTR _paint$[ebp], edx

; 371  : 
; 372  : 	if( !dly->lpdelayline )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN5@DLY_DoSter

; 373  : 		return; // inactive

	jmp	$LN1@DLY_DoSter
$LN5@DLY_DoSter:

; 374  : 
; 375  : 	for( ; count; count--, paint++ )

	jmp	SHORT $LN4@DLY_DoSter
$LN2@DLY_DoSter:
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _paint$[ebp]
	add	edx, 8
	mov	DWORD PTR _paint$[ebp], edx
$LN4@DLY_DoSter:
	cmp	DWORD PTR _count$[ebp], 0
	je	$LN1@DLY_DoSter

; 376  : 	{
; 377  : 		if( dly->mod && --dly->modcur < 0 )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN6@DLY_DoSter
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 1
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR [eax+48], ecx
	cmp	DWORD PTR tv75[ebp], 0
	jge	SHORT $LN6@DLY_DoSter

; 378  : 			dly->modcur = dly->mod;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+48], ecx
$LN6@DLY_DoSter:

; 379  : 
; 380  : 		delay = dly->lpdelayline[dly->idelayoutput];

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _delay$[ebp], eax

; 381  : 
; 382  : 		// process only if crossfading, active left value or delayline
; 383  : 		if( delay || paint->left || dly->xfade )

	cmp	DWORD PTR _delay$[ebp], 0
	jne	SHORT $LN9@DLY_DoSter
	mov	ecx, DWORD PTR _paint$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN9@DLY_DoSter
	mov	edx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN7@DLY_DoSter
$LN9@DLY_DoSter:

; 384  : 		{
; 385  : 			// set up new crossfade, if not crossfading, not modulating, but going to
; 386  : 			if( !dly->xfade && !dly->modcur && dly->mod )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN10@DLY_DoSter
	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN10@DLY_DoSter
	mov	edx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN10@DLY_DoSter

; 387  : 			{
; 388  : 				dly->idelayoutputxf = dly->idelayoutput + ((COM_RandomLong( 0, 255 ) * dly->delaysamples ) >> 9 );

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _dly$[ebp]
	imul	eax, DWORD PTR [ecx+20]
	sar	eax, 9
	mov	edx, DWORD PTR _dly$[ebp]
	add	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 389  : 
; 390  : 				dly->xfade = 128;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+16], 128			; 00000080H
$LN10@DLY_DoSter:

; 391  : 			}
; 392  : 
; 393  : 			dly->idelayoutputxf %= dly->cdelaysamplesmax;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [eax+12]
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+12], edx

; 394  : 
; 395  : 			// modify delay, if crossfading
; 396  : 			if( dly->xfade )

	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	$LN11@DLY_DoSter

; 397  : 			{
; 398  : 				samplexf = dly->lpdelayline[dly->idelayoutputxf] * (128 - dly->xfade) >> 7;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	esi, 128				; 00000080H
	sub	esi, DWORD PTR [ecx+16]
	imul	esi, DWORD PTR [edx+eax*4]
	sar	esi, 7
	mov	DWORD PTR _samplexf$[ebp], esi

; 399  : 				delay = samplexf + ((delay * dly->xfade) >> 7);

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR _delay$[ebp]
	imul	eax, DWORD PTR [edx+16]
	sar	eax, 7
	add	eax, DWORD PTR _samplexf$[ebp]
	mov	DWORD PTR _delay$[ebp], eax

; 400  : 
; 401  : 				if( ++dly->idelayoutputxf >= dly->cdelaysamplesmax )

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	DWORD PTR tv156[ebp], edx
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR tv156[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR tv156[ebp]
	cmp	eax, DWORD PTR [edx]
	jb	SHORT $LN12@DLY_DoSter

; 402  : 					dly->idelayoutputxf = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN12@DLY_DoSter:

; 403  : 
; 404  : 				if( --dly->xfade == 0 )

	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	mov	DWORD PTR tv162[ebp], eax
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR [ecx+16], edx
	cmp	DWORD PTR tv162[ebp], 0
	jne	SHORT $LN11@DLY_DoSter

; 405  : 					dly->idelayoutput = dly->idelayoutputxf;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx
$LN11@DLY_DoSter:

; 406  : 			}
; 407  : 
; 408  : 			// save left value to delay line
; 409  : 			dly->lpdelayline[dly->idelayinput] = CLIP( paint->left );

	mov	eax, DWORD PTR _paint$[ebp]
	cmp	DWORD PTR [eax], 32760			; 00007ff8H
	jle	SHORT $LN17@DLY_DoSter
	mov	DWORD PTR tv176[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN18@DLY_DoSter
$LN17@DLY_DoSter:
	mov	ecx, DWORD PTR _paint$[ebp]
	cmp	DWORD PTR [ecx], -32760			; ffff8008H
	jge	SHORT $LN15@DLY_DoSter
	mov	DWORD PTR tv175[ebp], -32760		; ffff8008H
	jmp	SHORT $LN16@DLY_DoSter
$LN15@DLY_DoSter:
	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv175[ebp], eax
$LN16@DLY_DoSter:
	mov	ecx, DWORD PTR tv175[ebp]
	mov	DWORD PTR tv176[ebp], ecx
$LN18@DLY_DoSter:
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR tv176[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 410  : 
; 411  : 			// paint new delay value
; 412  : 			paint->left = delay;

	mov	edx, DWORD PTR _paint$[ebp]
	mov	eax, DWORD PTR _delay$[ebp]
	mov	DWORD PTR [edx], eax

; 413  : 		}

	jmp	SHORT $LN8@DLY_DoSter
$LN7@DLY_DoSter:

; 414  : 		else
; 415  : 		{
; 416  : 			// clear delay line
; 417  : 			dly->lpdelayline[dly->idelayinput] = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+edx*4], 0
$LN8@DLY_DoSter:

; 418  :                     }
; 419  : 
; 420  : 		DLY_MovePointer( dly );

	mov	edx, DWORD PTR _dly$[ebp]
	push	edx
	call	_DLY_MovePointer
	add	esp, 4

; 421  : 	}

	jmp	$LN2@DLY_DoSter
$LN1@DLY_DoSter:

; 422  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_DoStereoDelay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv73 = -16						; size = 4
_samples$1 = -12					; size = 4
_delay$ = -8						; size = 4
_dly$ = -4						; size = 4
_DLY_CheckNewStereoDelayVal PROC

; 317  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 318  : 	dly_t *const	dly = &rgsxdly[STEREODLY];

	mov	eax, 56					; 00000038H
	imul	ecx, eax, 3
	add	ecx, OFFSET _rgsxdly
	mov	DWORD PTR _dly$[ebp], ecx

; 319  : 	float		delay = sxste_delay->value;

	mov	edx, DWORD PTR _sxste_delay
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _delay$[ebp], xmm0

; 320  : 
; 321  : 	if( !FBitSet( sxste_delay->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _sxste_delay
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	jne	SHORT $LN2@DLY_CheckN

; 322  : 		return;

	jmp	$LN1@DLY_CheckN
$LN2@DLY_CheckN:

; 323  : 
; 324  : 	if( delay == 0 )

	movss	xmm0, DWORD PTR _delay$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@DLY_CheckN

; 325  : 	{
; 326  : 		DLY_Free( STEREODLY );

	push	3
	call	_DLY_Free
	add	esp, 4

; 327  : 	}

	jmp	$LN8@DLY_CheckN
$LN3@DLY_CheckN:

; 328  : 	else
; 329  : 	{
; 330  : 		int	samples;
; 331  : 
; 332  : 		delay = Q_min( delay, MAX_STEREO_DELAY );

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jbe	SHORT $LN10@DLY_CheckN
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR tv73[ebp], xmm0
	jmp	SHORT $LN11@DLY_CheckN
$LN10@DLY_CheckN:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv73[ebp], xmm0
$LN11@DLY_CheckN:
	movss	xmm0, DWORD PTR tv73[ebp]
	movss	DWORD PTR _delay$[ebp], xmm0

; 333  : 		samples = (int)(delay * idsp_dma_speed) << sxhires;

	cvtsi2ss xmm0, DWORD PTR _idsp_dma_speed
	mulss	xmm0, DWORD PTR _delay$[ebp]
	cvttss2si edx, xmm0
	mov	ecx, DWORD PTR _sxhires
	shl	edx, cl
	mov	DWORD PTR _samples$1[ebp], edx

; 334  : 
; 335  : 		// re-init dly
; 336  : 		if( !dly->lpdelayline )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN5@DLY_CheckN

; 337  : 		{
; 338  : 			dly->delaysamples = samples;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR _samples$1[ebp]
	mov	DWORD PTR [ecx+20], edx

; 339  : 			DLY_Init( STEREODLY, MAX_STEREO_DELAY );

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	push	3
	call	_DLY_Init
	add	esp, 8
$LN5@DLY_CheckN:

; 340  : 		}
; 341  : 
; 342  : 		if( dly->delaysamples != samples )

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _samples$1[ebp]
	je	SHORT $LN7@DLY_CheckN

; 343  : 		{
; 344  : 			dly->xfade = 128;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+16], 128			; 00000080H

; 345  : 			dly->idelayoutputxf = dly->idelayinput - samples;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _samples$1[ebp]
	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 346  : 			if( dly->idelayoutputxf < 0 )

	mov	eax, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jae	SHORT $LN7@DLY_CheckN

; 347  : 				dly->idelayoutputxf += dly->cdelaysamplesmax;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _dly$[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN7@DLY_CheckN:

; 348  : 		}
; 349  : 
; 350  : 		dly->modcur = dly->mod = 0;

	mov	edx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+48], 0

; 351  : 
; 352  : 		if( dly->delaysamples == 0 )

	mov	ecx, DWORD PTR _dly$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN8@DLY_CheckN

; 353  : 			DLY_Free( STEREODLY );

	push	3
	call	_DLY_Free
	add	esp, 4
$LN8@DLY_CheckN:

; 354  : 	}
; 355  : 
; 356  : 	ClearBits( sxste_delay->flags, FCVAR_CHANGED );

	mov	edx, DWORD PTR _sxste_delay
	mov	eax, DWORD PTR [edx+8]
	and	eax, -8193				; ffffdfffH
	mov	ecx, DWORD PTR _sxste_delay
	mov	DWORD PTR [ecx+8], eax
$LN1@DLY_CheckN:

; 357  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_CheckNewStereoDelayVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
;	COMDAT _DLY_MovePointer
_TEXT	SEGMENT
tv72 = -8						; size = 4
tv66 = -4						; size = 4
_dly$ = 8						; size = 4
_DLY_MovePointer PROC					; COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 302  : 	if( ++dly->idelayinput >= dly->cdelaysamplesmax )

	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR tv66[ebp]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN2@DLY_MovePo

; 303  : 		dly->idelayinput = 0;

	mov	eax, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@DLY_MovePo:

; 304  : 
; 305  : 	if( ++dly->idelayoutput >= dly->cdelaysamplesmax )

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR _dly$[ebp]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _dly$[ebp]
	mov	eax, DWORD PTR tv72[ebp]
	cmp	eax, DWORD PTR [edx]
	jb	SHORT $LN1@DLY_MovePo

; 306  : 		dly->idelayoutput = 0;

	mov	ecx, DWORD PTR _dly$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN1@DLY_MovePo:

; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_MovePointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv70 = -8						; size = 4
_cur$ = -4						; size = 4
_idelay$ = 8						; size = 4
_delay$ = 12						; size = 4
_DLY_Init PROC

; 265  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 266  : 	dly_t	*cur;
; 267  : 
; 268  : 	// DLY_Init called anytime with constants. So valid it in debug builds only.
; 269  : 	Assert( idelay >= 0 && idelay < MAXDLY );

	cmp	DWORD PTR _idelay$[ebp], 0
	jl	SHORT $LN3@DLY_Init
	cmp	DWORD PTR _idelay$[ebp], 4
	jge	SHORT $LN3@DLY_Init
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@DLY_Init
$LN3@DLY_Init:
	mov	DWORD PTR tv70[ebp], 0
$LN4@DLY_Init:
	push	0
	push	269					; 0000010dH
	push	OFFSET $SG138906
	push	OFFSET $SG138907
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 270  : 	Assert( delay > 0.0f && delay <= MAX_DELAY );

	movss	xmm0, DWORD PTR _delay$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@DLY_Init
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jb	SHORT $LN5@DLY_Init
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN6@DLY_Init
$LN5@DLY_Init:
	mov	DWORD PTR tv78[ebp], 0
$LN6@DLY_Init:
	push	0
	push	270					; 0000010eH
	push	OFFSET $SG138908
	push	OFFSET $SG138909
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 271  : 
; 272  : 	DLY_Free( idelay ); // free dly if it's allocated

	mov	edx, DWORD PTR _idelay$[ebp]
	push	edx
	call	_DLY_Free
	add	esp, 4

; 273  : 
; 274  : 	cur = &rgsxdly[idelay];

	imul	eax, DWORD PTR _idelay$[ebp], 56
	add	eax, OFFSET _rgsxdly
	mov	DWORD PTR _cur$[ebp], eax

; 275  : 	cur->cdelaysamplesmax = ((int)(delay * idsp_dma_speed) << sxhires) + 1;

	cvtsi2ss xmm0, DWORD PTR _idsp_dma_speed
	mulss	xmm0, DWORD PTR _delay$[ebp]
	cvttss2si edx, xmm0
	mov	ecx, DWORD PTR _sxhires
	shl	edx, cl
	add	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], edx

; 276  : 	cur->lpdelayline = (int *)Z_Calloc( cur->cdelaysamplesmax * sizeof( int ));

	push	276					; 00000114H
	push	OFFSET $SG138910
	push	1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 277  : 	cur->xfade = 0;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+16], 0

; 278  : 
; 279  : 	// init modulation
; 280  : 	cur->mod = cur->modcur = 0;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 281  : 
; 282  : 	// init lowpass
; 283  : 	cur->lp = 1;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+28], 1

; 284  : 	cur->lp0 = cur->lp1 = cur->lp2 = 0;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+36], 0
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+32], 0

; 285  : 
; 286  : 	cur->idelayinput = 0;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], 0

; 287  : 	cur->idelayoutput = cur->cdelaysamplesmax - cur->delaysamples; // NOTE: delaysamples must be set!!!

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 288  : 
; 289  : 
; 290  : 	return 1;

	mov	eax, 1

; 291  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_idelay$ = 8						; size = 4
_DLY_Free PROC

; 229  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 230  : 	Assert( idelay >= 0 && idelay < MAXDLY );

	cmp	DWORD PTR _idelay$[ebp], 0
	jl	SHORT $LN5@DLY_Free
	cmp	DWORD PTR _idelay$[ebp], 4
	jge	SHORT $LN5@DLY_Free
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@DLY_Free
$LN5@DLY_Free:
	mov	DWORD PTR tv70[ebp], 0
$LN6@DLY_Free:
	push	0
	push	230					; 000000e6H
	push	OFFSET $SG138882
	push	OFFSET $SG138883
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 231  : 
; 232  : 	if( rgsxdly[idelay].lpdelayline )

	imul	ecx, DWORD PTR _idelay$[ebp], 56
	cmp	DWORD PTR _rgsxdly[ecx+52], 0
	je	SHORT $LN1@DLY_Free

; 233  : 	{
; 234  : 		Z_Free( rgsxdly[idelay].lpdelayline );

	imul	edx, DWORD PTR _idelay$[ebp], 56
	cmp	DWORD PTR _rgsxdly[edx+52], 0
	je	SHORT $LN3@DLY_Free
	push	234					; 000000eaH
	push	OFFSET $SG138886
	imul	eax, DWORD PTR _idelay$[ebp], 56
	mov	ecx, DWORD PTR _rgsxdly[eax+52]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@DLY_Free:

; 235  : 		rgsxdly[idelay].lpdelayline = NULL;

	imul	edx, DWORD PTR _idelay$[ebp], 56
	mov	DWORD PTR _rgsxdly[edx+52], 0
$LN1@DLY_Free:

; 236  : 	}
; 237  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DLY_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_SX_ReloadRoomFX PROC

; 166  : {

	push	ebp
	mov	ebp, esp

; 167  : 	if( !dsp_room ) return; // not initialized

	cmp	DWORD PTR _dsp_room, 0
	jne	SHORT $LN2@SX_ReloadR
	jmp	SHORT $LN1@SX_ReloadR
$LN2@SX_ReloadR:

; 168  : 
; 169  : 	SetBits( sxste_delay->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _sxste_delay
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _sxste_delay
	mov	DWORD PTR [edx+8], ecx

; 170  : 	SetBits( sxrvb_feedback->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _sxrvb_feedback
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _sxrvb_feedback
	mov	DWORD PTR [edx+8], ecx

; 171  : 	SetBits( sxdly_delay->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _sxdly_delay
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _sxdly_delay
	mov	DWORD PTR [edx+8], ecx

; 172  : 	SetBits( room_type->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _room_type
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _room_type
	mov	DWORD PTR [edx+8], ecx
$LN1@SX_ReloadR:

; 173  : }

	pop	ebp
	ret	0
_SX_ReloadRoomFX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_start$ = -4128						; size = 8
_end$ = -4120						; size = 8
_oldroom$ = -4112					; size = 4
_calls$ = -4108						; size = 4
_i$ = -4104						; size = 4
_testbuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_SX_Profiling_f PROC

; 871  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4128				; 00001020H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 872  : 	portable_samplepair_t	testbuffer[512];
; 873  : 	float			oldroom = room_type->value;

	mov	eax, DWORD PTR _room_type
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _oldroom$[ebp], xmm0

; 874  : 	double			start, end;
; 875  : 	int			i, calls;
; 876  : 
; 877  : 	for( i = 0; i < 512; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SX_Profili
$LN2@SX_Profili:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SX_Profili:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@SX_Profili

; 878  : 	{
; 879  : 		testbuffer[i].left = COM_RandomLong( 0, 3000 );

	push	3000					; 00000bb8H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _testbuffer$[ebp+edx*8], eax

; 880  : 		testbuffer[i].right = COM_RandomLong( 0, 3000 );

	push	3000					; 00000bb8H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _testbuffer$[ebp+ecx*8+4], eax

; 881  : 	}

	jmp	SHORT $LN2@SX_Profili
$LN3@SX_Profili:

; 882  : 
; 883  : 	if( Cmd_Argc() > 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jbe	SHORT $LN8@SX_Profili

; 884  : 	{
; 885  : 		Cvar_SetValue( "room_type", Q_atof( Cmd_Argv( 1 )));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	fstp	DWORD PTR [esp]
	push	OFFSET $SG139116
	call	_Cvar_SetValue
	add	esp, 8

; 886  : 		SX_ReloadRoomFX();

	call	_SX_ReloadRoomFX

; 887  : 		CheckNewDspPresets(); // we just need idsp_room immediately, for message below

	call	_CheckNewDspPresets
$LN8@SX_Profili:

; 888  : 	}
; 889  : 
; 890  : 	Con_Printf( "Profiling 10000 calls to DSP. Sample count is 512, room_type is %i\n", idsp_room );

	mov	edx, DWORD PTR _idsp_room
	push	edx
	push	OFFSET $SG139117
	call	_Con_Printf
	add	esp, 8

; 891  : 
; 892  : 	start = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _start$[ebp]

; 893  : 	for( calls = 10000; calls; calls-- )

	mov	DWORD PTR _calls$[ebp], 10000		; 00002710H
	jmp	SHORT $LN7@SX_Profili
$LN5@SX_Profili:
	mov	eax, DWORD PTR _calls$[ebp]
	sub	eax, 1
	mov	DWORD PTR _calls$[ebp], eax
$LN7@SX_Profili:
	cmp	DWORD PTR _calls$[ebp], 0
	je	SHORT $LN6@SX_Profili

; 894  : 	{
; 895  : 		DSP_Process( idsp_room, testbuffer, 512 );

	push	512					; 00000200H
	lea	ecx, DWORD PTR _testbuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _idsp_room
	push	edx
	call	_DSP_Process
	add	esp, 12					; 0000000cH

; 896  : 	}

	jmp	SHORT $LN5@SX_Profili
$LN6@SX_Profili:

; 897  : 	end = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _end$[ebp]

; 898  : 
; 899  : 	Con_Printf( "----------\nTook %g seconds.\n", end - start );

	movsd	xmm0, QWORD PTR _end$[ebp]
	subsd	xmm0, QWORD PTR _start$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG139118
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 900  : 
; 901  : 	if( Cmd_Argc() > 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jbe	SHORT $LN9@SX_Profili

; 902  : 	{
; 903  : 		Cvar_SetValue( "room_type", oldroom );

	push	ecx
	movss	xmm0, DWORD PTR _oldroom$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139120
	call	_Cvar_SetValue
	add	esp, 8

; 904  : 		SX_ReloadRoomFX();

	call	_SX_ReloadRoomFX

; 905  : 		CheckNewDspPresets();

	call	_CheckNewDspPresets
$LN9@SX_Profili:

; 906  : 	}
; 907  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SX_Profiling_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_DSP_ClearState PROC

; 800  : {

	push	ebp
	mov	ebp, esp

; 801  : 	Cvar_SetValue( "room_type", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139078
	call	_Cvar_SetValue
	add	esp, 8

; 802  : 	SX_ReloadRoomFX();

	call	_SX_ReloadRoomFX

; 803  : }

	pop	ebp
	ret	0
_DSP_ClearState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_idsp$ = 8						; size = 4
_DSP_GetGain PROC

; 866  : {

	push	ebp
	mov	ebp, esp

; 867  : 	return 1.0f;

	fld1

; 868  : }

	pop	ebp
	ret	0
_DSP_GetGain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_idsp$ = 8						; size = 4
_pbfront$ = 12						; size = 4
_sampleCount$ = 16					; size = 4
_DSP_Process PROC

; 775  : {

	push	ebp
	mov	ebp, esp

; 776  : 	if( dsp_off->value )

	mov	eax, DWORD PTR _dsp_off
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@DSP_Proces

; 777  : 		return;

	jmp	SHORT $LN1@DSP_Proces
$LN2@DSP_Proces:

; 778  : 
; 779  : 	// don't process DSP while in menu
; 780  : 	if( cls.key_dest == key_menu || !sampleCount )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN4@DSP_Proces
	cmp	DWORD PTR _sampleCount$[ebp], 0
	jne	SHORT $LN3@DSP_Proces
$LN4@DSP_Proces:

; 781  : 		return;

	jmp	SHORT $LN1@DSP_Proces
$LN3@DSP_Proces:

; 782  : 
; 783  : 	// preset is already installed by CheckNewDspPresets
; 784  : 	paintto = pbfront;

	mov	ecx, DWORD PTR _pbfront$[ebp]
	mov	DWORD PTR _paintto, ecx

; 785  : 
; 786  : 	RVB_DoAMod( sampleCount );

	mov	edx, DWORD PTR _sampleCount$[ebp]
	push	edx
	call	_RVB_DoAMod
	add	esp, 4

; 787  : 	RVB_DoReverb( sampleCount );

	mov	eax, DWORD PTR _sampleCount$[ebp]
	push	eax
	call	_RVB_DoReverb
	add	esp, 4

; 788  : 	DLY_DoDelay( sampleCount );

	mov	ecx, DWORD PTR _sampleCount$[ebp]
	push	ecx
	call	_DLY_DoDelay
	add	esp, 4

; 789  : 	DLY_DoStereoDelay( sampleCount );

	mov	edx, DWORD PTR _sampleCount$[ebp]
	push	edx
	call	_DLY_DoStereoDelay
	add	esp, 4
$LN1@DSP_Proces:

; 790  : }

	pop	ebp
	ret	0
_DSP_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv73 = -8						; size = 4
_cur$1 = -4						; size = 4
_CheckNewDspPresets PROC

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 814  : 	if( dsp_off->value != 0.0f )

	mov	eax, DWORD PTR _dsp_off
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@CheckNewDs

; 815  : 		return;

	jmp	$LN1@CheckNewDs
$LN2@CheckNewDs:

; 816  : 
; 817  : 	if( s_listener.waterlevel > 2 )

	cmp	DWORD PTR _s_listener+64, 2
	jle	SHORT $LN3@CheckNewDs

; 818  : 		idsp_room = roomwater_type->value;

	mov	ecx, DWORD PTR _roomwater_type
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _idsp_room, edx
	jmp	SHORT $LN4@CheckNewDs
$LN3@CheckNewDs:

; 819  : 	else idsp_room = room_type->value;

	mov	eax, DWORD PTR _room_type
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _idsp_room, ecx
$LN4@CheckNewDs:

; 820  : 
; 821  : 	// don't pass invalid presets
; 822  : 	idsp_room = bound( 0, idsp_room, MAXPRESETS - 1 );

	cmp	DWORD PTR _idsp_room, 0
	jl	SHORT $LN12@CheckNewDs
	cmp	DWORD PTR _idsp_room, 28		; 0000001cH
	jge	SHORT $LN10@CheckNewDs
	mov	edx, DWORD PTR _idsp_room
	mov	DWORD PTR tv73[ebp], edx
	jmp	SHORT $LN11@CheckNewDs
$LN10@CheckNewDs:
	mov	DWORD PTR tv73[ebp], 28			; 0000001cH
$LN11@CheckNewDs:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN13@CheckNewDs
$LN12@CheckNewDs:
	mov	DWORD PTR tv74[ebp], 0
$LN13@CheckNewDs:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _idsp_room, ecx

; 823  : 
; 824  : 	if( FBitSet( hisound->flags, FCVAR_CHANGED ))

	mov	edx, DWORD PTR _hisound
	mov	eax, DWORD PTR [edx+8]
	and	eax, 8192				; 00002000H
	je	SHORT $LN5@CheckNewDs

; 825  : 	{
; 826  : 		sxhires = hisound->value;

	mov	ecx, DWORD PTR _hisound
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _sxhires, edx

; 827  : 		ClearBits( hisound->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _hisound
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _hisound
	mov	DWORD PTR [edx+8], ecx
$LN5@CheckNewDs:

; 828  : 	}
; 829  : 
; 830  : 	if( idsp_room == room_typeprev && idsp_room == 0 )

	mov	eax, DWORD PTR _idsp_room
	cmp	eax, DWORD PTR _room_typeprev
	jne	SHORT $LN6@CheckNewDs
	cmp	DWORD PTR _idsp_room, 0
	jne	SHORT $LN6@CheckNewDs

; 831  : 		return;

	jmp	$LN1@CheckNewDs
$LN6@CheckNewDs:

; 832  : 
; 833  : 	if( idsp_room > MAX_ROOM_TYPES )

	cmp	DWORD PTR _idsp_room, 29		; 0000001dH
	jbe	SHORT $LN7@CheckNewDs

; 834  : 		return;

	jmp	$LN1@CheckNewDs
$LN7@CheckNewDs:

; 835  : 
; 836  : 	if( idsp_room != room_typeprev )

	mov	ecx, DWORD PTR _idsp_room
	cmp	ecx, DWORD PTR _room_typeprev
	je	$LN8@CheckNewDs

; 837  : 	{
; 838  : 		const sx_preset_t *cur = rgsxpre + idsp_room;

	imul	edx, DWORD PTR _idsp_room, 36
	add	edx, OFFSET _rgsxpre
	mov	DWORD PTR _cur$1[ebp], edx

; 839  : 
; 840  : 		Cvar_SetValue( "room_lp", cur->room_lp );

	mov	eax, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139089
	call	_Cvar_SetValue
	add	esp, 8

; 841  : 		Cvar_SetValue( "room_mod", cur->room_mod );

	mov	ecx, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139090
	call	_Cvar_SetValue
	add	esp, 8

; 842  : 		Cvar_SetValue( "room_size", cur->room_size );

	mov	edx, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139091
	call	_Cvar_SetValue
	add	esp, 8

; 843  : 		Cvar_SetValue( "room_refl", cur->room_refl );

	mov	eax, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139092
	call	_Cvar_SetValue
	add	esp, 8

; 844  : 		Cvar_SetValue( "room_rvblp", cur->room_rvblp );

	mov	ecx, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139093
	call	_Cvar_SetValue
	add	esp, 8

; 845  : 		Cvar_SetValue( "room_delay", cur->room_delay );

	mov	edx, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139094
	call	_Cvar_SetValue
	add	esp, 8

; 846  : 		Cvar_SetValue( "room_feedback", cur->room_feedback );

	mov	eax, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139095
	call	_Cvar_SetValue
	add	esp, 8

; 847  : 		Cvar_SetValue( "room_dlylp", cur->room_dlylp );

	mov	ecx, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139096
	call	_Cvar_SetValue
	add	esp, 8

; 848  : 		Cvar_SetValue( "room_left", cur->room_left );

	mov	edx, DWORD PTR _cur$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG139097
	call	_Cvar_SetValue
	add	esp, 8
$LN8@CheckNewDs:

; 849  : 	}
; 850  : 
; 851  : 	room_typeprev = idsp_room;

	mov	eax, DWORD PTR _idsp_room
	mov	DWORD PTR _room_typeprev, eax

; 852  : 
; 853  : 	RVB_CheckNewReverbVal( );

	call	_RVB_CheckNewReverbVal

; 854  : 	DLY_CheckNewDelayVal( );

	call	_DLY_CheckNewDelayVal

; 855  : 	DLY_CheckNewStereoDelayVal();

	call	_DLY_CheckNewStereoDelayVal
$LN1@CheckNewDs:

; 856  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CheckNewDspPresets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SX_Free PROC

; 247  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 248  : 	int	i;
; 249  : 
; 250  : 	for( i = 0; i <= 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SX_Free
$LN2@SX_Free:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SX_Free:
	cmp	DWORD PTR _i$[ebp], 3
	jg	SHORT $LN3@SX_Free

; 251  : 		DLY_Free( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_DLY_Free
	add	esp, 4
	jmp	SHORT $LN2@SX_Free
$LN3@SX_Free:

; 252  : 
; 253  : 	Cmd_RemoveCommand( "dsp_profile" );

	push	OFFSET $SG138893
	call	_Cmd_RemoveCommand
	add	esp, 4

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SX_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\s_dsp.c
_TEXT	SEGMENT
_SX_Init PROC

; 183  : {

	push	ebp
	mov	ebp, esp

; 184  : 	memset( rgsxdly, 0, sizeof( rgsxdly ));

	push	224					; 000000e0H
	push	0
	push	OFFSET _rgsxdly
	call	_memset
	add	esp, 12					; 0000000cH

; 185  : 	memset( rgsxlp,  0, sizeof( rgsxlp  ));

	push	40					; 00000028H
	push	0
	push	OFFSET _rgsxlp
	call	_memset
	add	esp, 12					; 0000000cH

; 186  : 
; 187  : 	sxamodr = sxamodl = sxamodrt = sxamodlt = 255;

	mov	DWORD PTR _sxamodlt, 255		; 000000ffH
	mov	eax, DWORD PTR _sxamodlt
	mov	DWORD PTR _sxamodrt, eax
	mov	ecx, DWORD PTR _sxamodrt
	mov	DWORD PTR _sxamodl, ecx
	mov	edx, DWORD PTR _sxamodl
	mov	DWORD PTR _sxamodr, edx

; 188  : 	idsp_dma_speed = SOUND_11k;

	mov	DWORD PTR _idsp_dma_speed, 11025	; 00002b11H

; 189  : 
; 190  : 	hisound = Cvar_Get( "room_hires", "2", FCVAR_ARCHIVE, "dsp quality. 1 for 22k, 2 for 44k(recommended) and 3 for 96k" );

	push	OFFSET $SG138834
	push	1
	push	OFFSET $SG138835
	push	OFFSET $SG138836
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hisound, eax

; 191  : 	sxhires = 2;

	mov	DWORD PTR _sxhires, 2

; 192  : 
; 193  : 	sxmod1cur = sxmod1 = 350 * ( idsp_dma_speed / SOUND_11k );

	mov	eax, DWORD PTR _idsp_dma_speed
	cdq
	mov	ecx, 11025				; 00002b11H
	idiv	ecx
	imul	edx, eax, 350
	mov	DWORD PTR _sxmod1, edx
	mov	eax, DWORD PTR _sxmod1
	mov	DWORD PTR _sxmod1cur, eax

; 194  : 	sxmod2cur = sxmod2 = 450 * ( idsp_dma_speed / SOUND_11k );

	mov	eax, DWORD PTR _idsp_dma_speed
	cdq
	mov	ecx, 11025				; 00002b11H
	idiv	ecx
	imul	edx, eax, 450
	mov	DWORD PTR _sxmod2, edx
	mov	eax, DWORD PTR _sxmod2
	mov	DWORD PTR _sxmod2cur, eax

; 195  : 
; 196  : 	dsp_off          = Cvar_Get( "dsp_off",        "0",  FCVAR_ARCHIVE, "disable DSP processing" );

	push	OFFSET $SG138837
	push	1
	push	OFFSET $SG138838
	push	OFFSET $SG138839
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dsp_off, eax

; 197  : 	roomwater_type   = Cvar_Get( "waterroom_type", "14", 0, "water room type" );

	push	OFFSET $SG138840
	push	0
	push	OFFSET $SG138841
	push	OFFSET $SG138842
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _roomwater_type, eax

; 198  : 	room_type        = Cvar_Get( "room_type",      "0",  0, "current room type preset" );

	push	OFFSET $SG138843
	push	0
	push	OFFSET $SG138844
	push	OFFSET $SG138845
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _room_type, eax

; 199  : 
; 200  : 	sxmod_lowpass    = Cvar_Get( "room_lp",  "0", 0, "for water fx, lowpass for entire room" );

	push	OFFSET $SG138846
	push	0
	push	OFFSET $SG138847
	push	OFFSET $SG138848
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxmod_lowpass, eax

; 201  : 	sxmod_mod        = Cvar_Get( "room_mod", "0", 0, "stereo amptitude modulation for room" );

	push	OFFSET $SG138849
	push	0
	push	OFFSET $SG138850
	push	OFFSET $SG138851
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxmod_mod, eax

; 202  : 
; 203  : 	sxrvb_size       = Cvar_Get( "room_size",  "0", 0, "reverb: initial reflection size" );

	push	OFFSET $SG138852
	push	0
	push	OFFSET $SG138853
	push	OFFSET $SG138854
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxrvb_size, eax

; 204  : 	sxrvb_feedback   = Cvar_Get( "room_refl",  "0", 0, "reverb: decay time" );

	push	OFFSET $SG138855
	push	0
	push	OFFSET $SG138856
	push	OFFSET $SG138857
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxrvb_feedback, eax

; 205  : 	sxrvb_lp         = Cvar_Get( "room_rvblp", "1", 0, "reverb: low pass filtering level" );

	push	OFFSET $SG138858
	push	0
	push	OFFSET $SG138859
	push	OFFSET $SG138860
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxrvb_lp, eax

; 206  : 
; 207  : 	sxdly_delay      = Cvar_Get( "room_delay",    "0.8", 0, "mono delay: delay time" );

	push	OFFSET $SG138861
	push	0
	push	OFFSET $SG138862
	push	OFFSET $SG138863
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxdly_delay, eax

; 208  : 	sxdly_feedback   = Cvar_Get( "room_feedback", "0.2", 0, "mono delay: decay time" );

	push	OFFSET $SG138864
	push	0
	push	OFFSET $SG138865
	push	OFFSET $SG138866
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxdly_feedback, eax

; 209  : 	sxdly_lp         = Cvar_Get( "room_dlylp",    "1",   0, "mono delay: low pass filtering level" );

	push	OFFSET $SG138867
	push	0
	push	OFFSET $SG138868
	push	OFFSET $SG138869
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxdly_lp, eax

; 210  : 
; 211  : 	sxste_delay      = Cvar_Get( "room_left", "0", 0, "left channel delay time" );

	push	OFFSET $SG138870
	push	0
	push	OFFSET $SG138871
	push	OFFSET $SG138872
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sxste_delay, eax

; 212  : 
; 213  : 	Cmd_AddCommand( "dsp_profile", SX_Profiling_f, "dsp stress-test, first argument is room_type" );

	push	OFFSET $SG138873
	push	OFFSET _SX_Profiling_f
	push	OFFSET $SG138874
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 214  : 
; 215  : 	// for compability
; 216  : 	dsp_room         = room_type;

	mov	ecx, DWORD PTR _room_type
	mov	DWORD PTR _dsp_room, ecx

; 217  : 
; 218  : 	SX_ReloadRoomFX();

	call	_SX_ReloadRoomFX

; 219  : }

	pop	ebp
	ret	0
_SX_Init ENDP
_TEXT	ENDS
END
