; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\console.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_color_table
_DATA	SEGMENT
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_con_notifytime:DWORD
COMM	_scr_conspeed:DWORD
COMM	_con_fontsize:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
_DATA	ENDS
_DATA	SEGMENT
_g_color_table DB 00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0f0H
	DB	0b4H
	DB	018H
	DB	0ffH
_DATA	ENDS
PUBLIC	_Con_Reportf
PUBLIC	_Con_DPrintf
PUBLIC	_Con_Printf
PUBLIC	_Con_Init
PUBLIC	_Con_Print
PUBLIC	_Con_NPrintf
PUBLIC	_Con_NXPrintf
PUBLIC	_UI_NPrintf
PUBLIC	_UI_NXPrintf
PUBLIC	_Cmd_AutoComplete
PUBLIC	_Con_Visible
PUBLIC	_Con_FixedFont
PUBLIC	_Con_VidInit
PUBLIC	_Con_Shutdown
PUBLIC	_Con_ToggleConsole_f
PUBLIC	_Con_ClearNotify
PUBLIC	_Con_DrawDebug
PUBLIC	_Con_RunConsole
PUBLIC	_Con_DrawConsole
PUBLIC	_Con_DrawVersion
PUBLIC	_Con_DrawStringLen
PUBLIC	_Con_DrawString
PUBLIC	_Con_DrawCharacter
PUBLIC	_Con_DrawCharacterLen
PUBLIC	_Con_DefaultColor
PUBLIC	_Con_InvalidateFonts
PUBLIC	_Con_SetFont
PUBLIC	_Con_CharEvent
PUBLIC	_Con_RestoreFont
PUBLIC	_Key_Console
PUBLIC	_Key_Message
PUBLIC	_Con_FastClose
PUBLIC	_Field_CharEvent
PUBLIC	_Con_Clear_f
PUBLIC	_Con_SetColor_f
PUBLIC	_Con_ClearField
PUBLIC	_Con_ClearTyping
PUBLIC	_Con_StringLength
PUBLIC	_Con_MessageMode_f
PUBLIC	_Con_MessageMode2_f
PUBLIC	_Con_SetTimes_f
PUBLIC	_Con_FixTimes
PUBLIC	_Con_DeleteLine
PUBLIC	_Con_DeleteLastLine
PUBLIC	_Con_AddLine
PUBLIC	_Con_CheckResize
PUBLIC	_Con_PageUp
PUBLIC	_Con_PageDown
PUBLIC	_Con_Top
PUBLIC	_Con_Bottom
PUBLIC	_Con_DrawGenericString
PUBLIC	_Con_CompleteCommand
PUBLIC	_Field_Paste
PUBLIC	_Field_KeyDownEvent
PUBLIC	_Field_DrawInputLine
PUBLIC	_Con_DrawInput
PUBLIC	_Con_DrawDebugLines
PUBLIC	_Con_DrawNotify
PUBLIC	_Con_DrawConsoleLine
PUBLIC	_Con_DrawSolidConsole
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f866666
PUBLIC	__real@3f99999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@437f0000
PUBLIC	__real@bf800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_GetClipboardData:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Sys_Print:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_LookupCmds:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_atov:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_LookupVars:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Q_buildnum:PROC
EXTRN	_SV_Active:PROC
EXTRN	_Key_IsDown:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_SCR_UpdateScreen:PROC
EXTRN	_Cmd_AutocompleteName:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_fabs:PROC
EXTRN	_CL_IsDevOverviewMode:PROC
EXTRN	_SCR_DrawFPS:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_R_GetTextureParms:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	_Host_InputFrame:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_scr_download:DWORD
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_net_graph:DWORD
EXTRN	_tr:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_con	DB	0140a8H DUP (?)
?cr_pending@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::cr_pending
?buf@?1??Con_Print@@9@9 DB 02000H DUP (?)		; `Con_Print'::`2'::buf
?lastlength@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::lastlength
?inupdate@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::inupdate
?bufpos@?1??Con_Print@@9@9 DD 01H DUP (?)		; `Con_Print'::`2'::bufpos
?buffer@?1??Con_Printf@@9@9 DB 02000H DUP (?)		; `Con_Printf'::`2'::buffer
?buffer@?1??Con_DPrintf@@9@9 DB 02020H DUP (?)		; `Con_DPrintf'::`2'::buffer
?buffer@?1??Con_Reportf@@9@9 DB 02020H DUP (?)		; `Con_Reportf'::`2'::buffer
?timeStart@?1??Con_DrawDebug@@9@9 DQ 01H DUP (?)	; `Con_DrawDebug'::`2'::timeStart
_BSS	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f866666
CONST	SEGMENT
__real@3f866666 DD 03f866666r			; 1.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG143567 DB	'"con_color" is %i %i %i', 0aH, 00H
	ORG $+3
$SG143571 DB	'Usage: con_color "r g b"', 0aH, 00H
	ORG $+2
$SG143592 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG143608 DB	'say', 00H
$SG143612 DB	'say_team', 00H
	ORG $+3
$SG143624 DB	'sv_background', 00H
	ORG $+2
$SG143625 DB	'cl_background', 00H
	ORG $+2
$SG143631 DB	'Usage: contimes <n lines>', 0aH, 00H
	ORG $+1
$SG143683 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG143684 DB	'assert failed at %s:%i', 0aH, 00H
$SG143770 DB	'-oldfont', 00H
	ORG $+3
$SG143760 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG143771 DB	'gfx.wad/conchars.fnt', 00H
	ORG $+3
$SG143772 DB	'fonts.wad/font%i', 00H
	ORG $+3
$SG143774 DB	'gfx/conchars', 00H
	ORG $+3
$SG143945 DB	'console moving speed', 00H
	ORG $+3
$SG143946 DB	'600', 00H
$SG143947 DB	'scr_conspeed', 00H
	ORG $+3
$SG143948 DB	'notify time to live', 00H
$SG143949 DB	'3', 00H
	ORG $+2
$SG143950 DB	'con_notifytime', 00H
	ORG $+1
$SG143951 DB	'console font number (0, 1 or 2)', 00H
$SG143952 DB	'1', 00H
	ORG $+2
$SG143953 DB	'con_fontsize', 00H
	ORG $+3
$SG143954 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG143956 DB	'opens or closes the console', 00H
$SG143955 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG143957 DB	'toggleconsole', 00H
	ORG $+2
$SG143958 DB	'set a custom console color', 00H
	ORG $+1
$SG143959 DB	'con_color', 00H
	ORG $+2
$SG143960 DB	'clear console history', 00H
	ORG $+2
$SG143961 DB	'clear', 00H
	ORG $+2
$SG143962 DB	'enable message mode "say"', 00H
	ORG $+2
$SG143963 DB	'messagemode', 00H
$SG143964 DB	'enable message mode "say_team"', 00H
	ORG $+1
$SG143965 DB	'messagemode2', 00H
	ORG $+3
$SG143966 DB	'change number of console overlay lines (4-64)', 00H
	ORG $+2
$SG143967 DB	'contimes', 00H
	ORG $+3
$SG143968 DB	'Console initialized.', 0aH, 00H
	ORG $+2
$SG143974 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG144190 DB	' ', 00H
	ORG $+2
$SG143976 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG144192 DB	'"', 00H
	ORG $+2
$SG144139 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG144159 DB	'    %s ^3"%s"', 0aH, 00H
	ORG $+1
$SG144160 DB	'    %s', 0aH, 00H
$SG144174 DB	'    %s (%s)   ^3"%s"', 0aH, 00H
	ORG $+2
$SG144175 DB	'    %s  (%s)', 0aH, 00H
	ORG $+2
$SG144194 DB	'"', 00H
	ORG $+2
$SG144231 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
$SG144238 DB	'%s %s', 00H
	ORG $+2
$SG144242 DB	'\%s', 00H
$SG144245 DB	' ', 00H
	ORG $+2
$SG144246 DB	'\%s', 00H
$SG144247 DB	']%s', 0aH, 00H
	ORG $+3
$SG144336 DB	'clear', 0aH, 00H
	ORG $+1
$SG144340 DB	'\%s', 00H
$SG144344 DB	0aH, 00H
	ORG $+2
$SG144345 DB	'>%s', 0aH, 00H
	ORG $+3
$SG144374 DB	'%s "%s"', 0aH, 00H
	ORG $+3
$SG144406 DB	'Downloading [%d remaining]: ^2%s^7 %5.1f%% time %.f secs'
	DB	00H
	ORG $+3
$SG144409 DB	'cl_background', 00H
	ORG $+2
$SG144410 DB	'sv_background', 00H
	ORG $+2
$SG144429 DB	'cl_background', 00H
	ORG $+2
$SG144430 DB	'sv_background', 00H
	ORG $+2
$SG144434 DB	'%s: ', 00H
	ORG $+3
$SG144484 DB	'0.99', 00H
	ORG $+3
$SG144485 DB	'Xash3D %i/%s (hw build %i)', 00H
	ORG $+1
$SG144503 DB	'cl_background', 00H
	ORG $+2
$SG144504 DB	'sv_background', 00H
	ORG $+2
$SG144513 DB	'cl_background', 00H
	ORG $+2
$SG144514 DB	'sv_background', 00H
	ORG $+2
$SG144545 DB	'0.99', 00H
	ORG $+3
$SG144546 DB	'Xash3D v%i/%s (build %i)', 00H
	ORG $+3
$SG144547 DB	'0.99', 00H
	ORG $+3
$SG144548 DB	'v%i/%s (build %i)', 00H
	ORG $+2
$SG144596 DB	'gfx/shell/conback.bmp', 00H
	ORG $+2
$SG144597 DB	'gfx/shell/conback.tga', 00H
	ORG $+2
$SG144598 DB	'gfx/shell/conback', 00H
	ORG $+2
$SG144602 DB	'cached/conback640', 00H
	ORG $+2
$SG144603 DB	'cached/conback640', 00H
	ORG $+2
$SG144605 DB	'cached/conback', 00H
	ORG $+1
$SG144606 DB	'cached/conback', 00H
	ORG $+1
$SG144609 DB	'gfx/shell/loading.bmp', 00H
	ORG $+2
$SG144610 DB	'gfx/shell/loading.tga', 00H
	ORG $+2
$SG144611 DB	'gfx/shell/loading', 00H
	ORG $+2
$SG144615 DB	'cached/loading640', 00H
	ORG $+2
$SG144616 DB	'cached/loading640', 00H
	ORG $+2
$SG144618 DB	'cached/loading', 00H
	ORG $+1
$SG144619 DB	'cached/loading', 00H
	ORG $+1
$SG144622 DB	'id1', 00H
$SG144624 DB	'hipnotic', 00H
	ORG $+3
$SG144626 DB	'rogue', 00H
	ORG $+2
$SG144628 DB	'gfx/conback.lmp', 00H
$SG144630 DB	'%i', 00H
	ORG $+1
$SG144631 DB	'#gfx/conback.lmp', 00H
	ORG $+3
$SG144635 DB	'gfx/conback.lmp', 00H
	ORG $+4
$SG144633 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\console.c', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_charH$1 = -312						; size = 4
_lastline$2 = -308					; size = 4
_ymax$3 = -304						; size = 4
tv207 = -300						; size = 4
_color$4 = -296						; size = 4
tv146 = -292						; size = 4
_fraction$ = -288					; size = 4
_start$ = -284						; size = 4
_width$5 = -280						; size = 4
_stringLen$6 = -276					; size = 4
_i$ = -272						; size = 4
_x$ = -268						; size = 4
_y$ = -264						; size = 4
_curbuild$7 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lines$ = 8						; size = 4
_Con_DrawSolidConsole PROC

; 2131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2132 : 	int	i, x, y;
; 2133 : 	float	fraction;
; 2134 : 	int	start;
; 2135 : 
; 2136 : 	if( lines <= 0 ) return;

	cmp	DWORD PTR _lines$[ebp], 0
	jg	SHORT $LN10@Con_DrawSo
	jmp	$LN1@Con_DrawSo
$LN10@Con_DrawSo:

; 2137 : 
; 2138 : 	// draw the background
; 2139 : 	GL_SetRenderMode( kRenderNormal );

	push	0
	call	_GL_SetRenderMode
	add	esp, 4

; 2140 : 	pglColor4ub( 255, 255, 255, 255 ); // to prevent grab color from screenfade

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 2141 : 	R_DrawStretchPic( 0, lines - glState.height, glState.width, glState.height, 0, 0, 1, 1, con.background );

	mov	eax, DWORD PTR _con+48
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState+4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _lines$[ebp]
	sub	ecx, DWORD PTR _glState+4
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 2142 : 
; 2143 : 	if( !con.curFont || !host.allow_console )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN12@Con_DrawSo
	cmp	DWORD PTR _host+34336, 0
	jne	SHORT $LN11@Con_DrawSo
$LN12@Con_DrawSo:

; 2144 : 		return; // nothing to draw

	jmp	$LN1@Con_DrawSo
$LN11@Con_DrawSo:

; 2145 : 
; 2146 : 	if( host.allow_console )

	cmp	DWORD PTR _host+34336, 0
	je	$LN3@Con_DrawSo

; 2147 : 	{
; 2148 : 		// draw current version
; 2149 : 		int	stringLen, width = 0, charH;

	mov	DWORD PTR _width$5[ebp], 0

; 2150 : 		string	curbuild;
; 2151 : 		byte	color[4];
; 2152 : 
; 2153 : 		memcpy( color, g_color_table[7], sizeof( color ));

	push	4
	mov	edx, 4
	imul	eax, edx, 7
	add	eax, OFFSET _g_color_table
	push	eax
	lea	ecx, DWORD PTR _color$4[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2154 : 
; 2155 : 		Q_snprintf( curbuild, MAX_STRING, "Xash3D %i/%s (hw build %i)", PROTOCOL_VERSION, XASH_VERSION, Q_buildnum( ));

	call	_Q_buildnum
	push	eax
	push	OFFSET $SG144484
	push	49					; 00000031H
	push	OFFSET $SG144485
	push	256					; 00000100H
	lea	edx, DWORD PTR _curbuild$7[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 2156 : 		Con_DrawStringLen( curbuild, &stringLen, &charH );

	lea	eax, DWORD PTR _charH$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _stringLen$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _curbuild$7[ebp]
	push	edx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2157 : 		start = glState.width - stringLen;

	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR _stringLen$6[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 2158 : 		stringLen = Con_StringLength( curbuild );

	lea	ecx, DWORD PTR _curbuild$7[ebp]
	push	ecx
	call	_Con_StringLength
	add	esp, 4
	mov	DWORD PTR _stringLen$6[ebp], eax

; 2159 : 
; 2160 : 		fraction = lines / (float)glState.height;

	cvtsi2ss xmm0, DWORD PTR _lines$[ebp]
	cvtsi2ss xmm1, DWORD PTR _glState+4
	divss	xmm0, xmm1
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2161 : 		color[3] = Q_min( fraction * 2.0f, 1.0f ) * 255; // fadeout version number

	movss	xmm0, DWORD PTR _fraction$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@Con_DrawSo
	movss	xmm0, DWORD PTR _fraction$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv146[ebp], xmm0
	jmp	SHORT $LN20@Con_DrawSo
$LN19@Con_DrawSo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[ebp], xmm0
$LN20@Con_DrawSo:
	movss	xmm0, DWORD PTR tv146[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 1
	imul	eax, edx, 3
	cvttss2si ecx, xmm0
	mov	BYTE PTR _color$4[ebp+eax], cl

; 2162 : 
; 2163 : 		for( i = 0; i < stringLen; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_DrawSo
$LN2@Con_DrawSo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Con_DrawSo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _stringLen$6[ebp]
	jge	SHORT $LN3@Con_DrawSo

; 2164 : 			width += Con_DrawCharacter( start + width, 0, curbuild[i], color );

	lea	ecx, DWORD PTR _color$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _curbuild$7[ebp+edx]
	push	eax
	push	0
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, DWORD PTR _width$5[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _width$5[ebp]
	mov	DWORD PTR _width$5[ebp], eax
	jmp	SHORT $LN2@Con_DrawSo
$LN3@Con_DrawSo:

; 2165 : 	}
; 2166 : 
; 2167 : 	// draw the text
; 2168 : 	if( CON_LINES_COUNT > 0 )

	cmp	DWORD PTR _con+24, 0
	jle	$LN9@Con_DrawSo

; 2169 : 	{
; 2170 : 		int	ymax = lines - (con.curFont->charHeight * 2.0f);

	cvtsi2ss xmm0, DWORD PTR _lines$[ebp]
	mov	edx, DWORD PTR _con+13156
	cvtsi2ss xmm1, DWORD PTR [edx+4356]
	mulss	xmm1, DWORD PTR __real@40000000
	subss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _ymax$3[ebp], eax

; 2171 : 		int	lastline;
; 2172 : 
; 2173 : 		Con_LastVisibleLine( &lastline );

	lea	ecx, DWORD PTR _lastline$2[ebp]
	push	ecx
	call	_Con_LastVisibleLine
	add	esp, 4

; 2174 : 		y = ymax - con.curFont->charHeight;

	mov	edx, DWORD PTR _con+13156
	mov	eax, DWORD PTR _ymax$3[ebp]
	sub	eax, DWORD PTR [edx+4356]
	mov	DWORD PTR _y$[ebp], eax

; 2175 : 
; 2176 : 		if( con.backscroll )

	cmp	DWORD PTR _con+32, 0
	je	$LN15@Con_DrawSo

; 2177 : 		{
; 2178 : 			start = con.curFont->charWidths[' ']; // offset one space at left screen side

	mov	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _con+13156
	movzx	eax, BYTE PTR [edx+ecx+4100]
	mov	DWORD PTR _start$[ebp], eax

; 2179 : 
; 2180 : 			// draw red arrows to show the buffer is backscrolled
; 2181 : 			for( x = 0; x < con.linewidth; x += 4 )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@Con_DrawSo
$LN5@Con_DrawSo:
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 4
	mov	DWORD PTR _x$[ebp], ecx
$LN7@Con_DrawSo:
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR _con+36
	jge	SHORT $LN6@Con_DrawSo

; 2182 : 				Con_DrawCharacter(( x + 1 ) * start, y, '^', g_color_table[1] );

	mov	eax, 4
	shl	eax, 0
	add	eax, OFFSET _g_color_table
	push	eax
	push	94					; 0000005eH
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@Con_DrawSo
$LN6@Con_DrawSo:

; 2183 : 			y -= con.curFont->charHeight;

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, DWORD PTR [eax+4356]
	mov	DWORD PTR _y$[ebp], ecx
$LN15@Con_DrawSo:

; 2184 : 		}
; 2185 : 		x = lastline;

	mov	edx, DWORD PTR _lastline$2[ebp]
	mov	DWORD PTR _x$[ebp], edx
$LN8@Con_DrawSo:

; 2186 : 
; 2187 : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@Con_DrawSo

; 2188 : 		{
; 2189 : 			y -= Con_DrawConsoleLine( y, x );

	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	call	_Con_DrawConsoleLine
	add	esp, 8
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _y$[ebp], ecx

; 2190 : 
; 2191 : 			// top of console buffer or console window
; 2192 : 			if( x == 0 || y < con.curFont->charHeight ) 

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN17@Con_DrawSo
	mov	edx, DWORD PTR _con+13156
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR [edx+4356]
	jge	SHORT $LN16@Con_DrawSo
$LN17@Con_DrawSo:

; 2193 : 				break;

	jmp	SHORT $LN9@Con_DrawSo
$LN16@Con_DrawSo:

; 2194 : 			x--;

	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 2195 : 		}

	jmp	SHORT $LN8@Con_DrawSo
$LN9@Con_DrawSo:

; 2196 : 	}
; 2197 : 
; 2198 : 	// draw the input prompt, user text, and cursor if desired
; 2199 : 	Con_DrawInput( lines );

	mov	edx, DWORD PTR _lines$[ebp]
	push	edx
	call	_Con_DrawInput
	add	esp, 4

; 2200 : 
; 2201 : 	y = lines - ( con.curFont->charHeight * 1.2f );

	cvtsi2ss xmm0, DWORD PTR _lines$[ebp]
	mov	eax, DWORD PTR _con+13156
	cvtsi2ss xmm1, DWORD PTR [eax+4356]
	mulss	xmm1, DWORD PTR __real@3f99999a
	subss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _y$[ebp], ecx

; 2202 : 	SCR_DrawFPS( max( y, 4 )); // to avoid to hide fps counter

	cmp	DWORD PTR _y$[ebp], 4
	jle	SHORT $LN21@Con_DrawSo
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv207[ebp], edx
	jmp	SHORT $LN22@Con_DrawSo
$LN21@Con_DrawSo:
	mov	DWORD PTR tv207[ebp], 4
$LN22@Con_DrawSo:
	mov	eax, DWORD PTR tv207[ebp]
	push	eax
	call	_SCR_DrawFPS
	add	esp, 4

; 2203 : 
; 2204 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@Con_DrawSo:

; 2205 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawSolidConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv65 = -12						; size = 4
_i$ = -8						; size = 4
_lines_seen$ = -4					; size = 4
_lastline$ = 8						; size = 4
_Con_LastVisibleLine PROC

; 2101 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2102 : 	int	i, lines_seen = 0;

	mov	DWORD PTR _lines_seen$[ebp], 0

; 2103 : 
; 2104 : 	con.backscroll = Q_max( 0, con.backscroll );

	cmp	DWORD PTR _con+32, 0
	jge	SHORT $LN7@Con_LastVi
	mov	DWORD PTR tv65[ebp], 0
	jmp	SHORT $LN8@Con_LastVi
$LN7@Con_LastVi:
	mov	eax, DWORD PTR _con+32
	mov	DWORD PTR tv65[ebp], eax
$LN8@Con_LastVi:
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR _con+32, ecx

; 2105 : 	*lastline = 0;

	mov	edx, DWORD PTR _lastline$[ebp]
	mov	DWORD PTR [edx], 0

; 2106 : 
; 2107 : 	// now count until we saw con_backscroll actual lines
; 2108 : 	for( i = CON_LINES_COUNT - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _con+24
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Con_LastVi
$LN2@Con_LastVi:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Con_LastVi:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@Con_LastVi

; 2109 : 	{
; 2110 : 		// line is the last visible line?
; 2111 : 		*lastline = i;

	mov	edx, DWORD PTR _lastline$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 2112 : 
; 2113 : 		if( lines_seen + 1 > con.backscroll && lines_seen <= con.backscroll )

	mov	ecx, DWORD PTR _lines_seen$[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _con+32
	jle	SHORT $LN5@Con_LastVi
	mov	edx, DWORD PTR _lines_seen$[ebp]
	cmp	edx, DWORD PTR _con+32
	jg	SHORT $LN5@Con_LastVi

; 2114 : 			return;

	jmp	SHORT $LN1@Con_LastVi
$LN5@Con_LastVi:

; 2115 : 
; 2116 : 		lines_seen += 1;

	mov	eax, DWORD PTR _lines_seen$[ebp]
	add	eax, 1
	mov	DWORD PTR _lines_seen$[ebp], eax

; 2117 : 	}

	jmp	SHORT $LN2@Con_LastVi
$LN3@Con_LastVi:

; 2118 : 
; 2119 : 	// if we get here, no line was on screen - scroll so that one line is visible then.
; 2120 : 	con.backscroll = lines_seen - 1;

	mov	ecx, DWORD PTR _lines_seen$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _con+32, ecx
$LN1@Con_LastVi:

; 2121 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LastVisibleLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_li$ = -4						; size = 4
_y$ = 8							; size = 4
_lineno$ = 12						; size = 4
_Con_DrawConsoleLine PROC

; 2080 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2081 : 	con_lineinfo_t	*li = &CON_LINES( lineno );

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _lineno$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _li$[ebp], edx

; 2082 : 
; 2083 : 	if( !li || !li->start || *li->start == '\1' )

	je	SHORT $LN3@Con_DrawCo
	mov	eax, DWORD PTR _li$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Con_DrawCo
	mov	ecx, DWORD PTR _li$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	SHORT $LN2@Con_DrawCo
$LN3@Con_DrawCo:

; 2084 : 		return 0;	// this string will be shown only at notify

	xor	eax, eax
	jmp	SHORT $LN1@Con_DrawCo
$LN2@Con_DrawCo:

; 2085 : 
; 2086 : 	if( y >= con.curFont->charHeight )

	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR [ecx+4356]
	jl	SHORT $LN4@Con_DrawCo

; 2087 : 		Con_DrawGenericString( con.curFont->charWidths[' '], y, li->start, g_color_table[7], false, -1 );

	push	-1
	push	0
	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	mov	edx, DWORD PTR _li$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, 1
	shl	edx, 5
	mov	eax, DWORD PTR _con+13156
	movzx	ecx, BYTE PTR [eax+edx+4100]
	push	ecx
	call	_Con_DrawGenericString
	add	esp, 24					; 00000018H
$LN4@Con_DrawCo:

; 2088 : 
; 2089 : 	return con.curFont->charHeight;

	mov	edx, DWORD PTR _con+13156
	mov	eax, DWORD PTR [edx+4356]
$LN1@Con_DrawCo:

; 2090 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawConsoleLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_time$ = -288						; size = 8
_len$1 = -280						; size = 4
_l$2 = -276						; size = 4
_x$ = -272						; size = 4
_i$ = -268						; size = 4
_y$ = -264						; size = 4
_buf$3 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_Con_DrawNotify PROC

; 2028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2029 : 	double	time = cl.time;

	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR _time$[ebp], xmm0

; 2030 : 	int	i, x, y = 0;

	mov	DWORD PTR _y$[ebp], 0

; 2031 : 
; 2032 : 	if( !con.curFont ) return;

	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN5@Con_DrawNo
	jmp	$LN1@Con_DrawNo
$LN5@Con_DrawNo:

; 2033 : 
; 2034 : 	x = con.curFont->charWidths[' ']; // offset one space at left screen side

	mov	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _con+13156
	movzx	edx, BYTE PTR [ecx+eax+4100]
	mov	DWORD PTR _x$[ebp], edx

; 2035 : 
; 2036 : 	if( host_developer.value && ( !Cvar_VariableInteger( "cl_background" ) && !Cvar_VariableInteger( "sv_background" )))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@Con_DrawNo
	push	OFFSET $SG144429
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	$LN3@Con_DrawNo
	push	OFFSET $SG144430
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	$LN3@Con_DrawNo

; 2037 : 	{
; 2038 : 		for( i = CON_LINES_COUNT - con.num_times; i < CON_LINES_COUNT; i++ )

	mov	eax, DWORD PTR _con+24
	sub	eax, DWORD PTR _con+28
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Con_DrawNo
$LN2@Con_DrawNo:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Con_DrawNo:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _con+24
	jge	$LN3@Con_DrawNo

; 2039 : 		{
; 2040 : 			con_lineinfo_t	*l = &CON_LINES( i );

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _l$2[ebp], edx

; 2041 : 
; 2042 : 			if( l->addtime < ( time - con_notifytime->value ))

	mov	eax, DWORD PTR _con_notifytime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _time$[ebp]
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _l$2[ebp]
	comisd	xmm1, QWORD PTR [ecx+8]
	jbe	SHORT $LN7@Con_DrawNo

; 2043 : 				continue;

	jmp	SHORT $LN2@Con_DrawNo
$LN7@Con_DrawNo:

; 2044 : 
; 2045 : 			Con_DrawString( x, y, l->start, g_color_table[7] );

	mov	edx, 4
	imul	eax, edx, 7
	add	eax, OFFSET _g_color_table
	push	eax
	mov	ecx, DWORD PTR _l$2[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 2046 : 			y += con.curFont->charHeight;

	mov	edx, DWORD PTR _con+13156
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR [edx+4356]
	mov	DWORD PTR _y$[ebp], eax

; 2047 : 		}

	jmp	$LN2@Con_DrawNo
$LN3@Con_DrawNo:

; 2048 : 	}
; 2049 : 	
; 2050 : 	if( cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 3
	jne	$LN8@Con_DrawNo

; 2051 : 	{
; 2052 : 		string	buf;
; 2053 : 		int	len;
; 2054 : 
; 2055 : 		// update chatline position from client.dll
; 2056 : 		if( clgame.dllFuncs.pfnChatInputPosition )

	cmp	DWORD PTR _clgame+164, 0
	je	SHORT $LN9@Con_DrawNo

; 2057 : 			clgame.dllFuncs.pfnChatInputPosition( &x, &y );

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	DWORD PTR _clgame+164
	add	esp, 8
$LN9@Con_DrawNo:

; 2058 : 
; 2059 : 		Q_snprintf( buf, sizeof( buf ), "%s: ", con.chat_cmd );

	push	OFFSET _con+13700
	push	OFFSET $SG144434
	push	256					; 00000100H
	lea	eax, DWORD PTR _buf$3[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2060 : 
; 2061 : 		Con_DrawStringLen( buf, &len, NULL );

	push	0
	lea	ecx, DWORD PTR _len$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$3[ebp]
	push	edx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2062 : 		Con_DrawString( x, y, buf, g_color_table[7] );

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	lea	edx, DWORD PTR _buf$3[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 2063 : 
; 2064 : 		Field_DrawInputLine( x + len, y, &con.chat );

	push	OFFSET _con+13432
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _len$1[ebp]
	push	eax
	call	_Field_DrawInputLine
	add	esp, 12					; 0000000cH
$LN8@Con_DrawNo:

; 2065 : 	}
; 2066 : 
; 2067 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@Con_DrawNo:

; 2068 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawNotify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_x$1 = -32						; size = 4
tv83 = -28						; size = 4
_len$2 = -24						; size = 4
_defaultX$ = -20					; size = 4
_y$ = -16						; size = 4
_count$ = -12						; size = 4
_fontTall$3 = -8					; size = 4
_i$ = -4						; size = 4
_Con_DrawDebugLines PROC

; 1954 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1955 : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1956 : 	int	defaultX;
; 1957 : 	int	y = 20;

	mov	DWORD PTR _y$[ebp], 20			; 00000014H

; 1958 : 
; 1959 : 	defaultX = glState.width / 4;

	mov	eax, DWORD PTR _glState
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _defaultX$[ebp], eax

; 1960 : 	
; 1961 : 	for( i = 0; i < MAX_DBG_NOTIFY; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_DrawDe
$LN2@Con_DrawDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_DrawDe:
	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jge	$LN3@Con_DrawDe

; 1962 : 	{
; 1963 : 		if( host.realtime < con.notify[i].expire && con.notify[i].key_dest == cls.key_dest )

	imul	ecx, DWORD PTR _i$[ebp], 268
	cvtss2sd xmm0, DWORD PTR _con[ecx+31372]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	$LN5@Con_DrawDe
	imul	edx, DWORD PTR _i$[ebp], 268
	mov	eax, DWORD PTR _con[edx+31380]
	cmp	eax, DWORD PTR _cls+36
	jne	$LN5@Con_DrawDe

; 1964 : 		{
; 1965 : 			int	x, len;
; 1966 : 			int	fontTall;
; 1967 : 
; 1968 : 			Con_DrawStringLen( con.notify[i].szNotify, &len, &fontTall );

	lea	ecx, DWORD PTR _fontTall$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _len$2[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 1969 : 			x = glState.width - Q_max( defaultX, len ) - 10;

	mov	ecx, DWORD PTR _defaultX$[ebp]
	cmp	ecx, DWORD PTR _len$2[ebp]
	jle	SHORT $LN8@Con_DrawDe
	mov	edx, DWORD PTR _defaultX$[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN9@Con_DrawDe
$LN8@Con_DrawDe:
	mov	eax, DWORD PTR _len$2[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN9@Con_DrawDe:
	mov	ecx, DWORD PTR _glState
	sub	ecx, DWORD PTR tv83[ebp]
	sub	ecx, 10					; 0000000aH
	mov	DWORD PTR _x$1[ebp], ecx

; 1970 : 			fontTall += 1;

	mov	edx, DWORD PTR _fontTall$3[ebp]
	add	edx, 1
	mov	DWORD PTR _fontTall$3[ebp], edx

; 1971 : 
; 1972 : 			if( y + fontTall > glState.height - 20 )

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _fontTall$3[ebp]
	mov	ecx, DWORD PTR _glState+4
	sub	ecx, 20					; 00000014H
	cmp	eax, ecx
	jle	SHORT $LN6@Con_DrawDe

; 1973 : 				return count;

	mov	eax, DWORD PTR _count$[ebp]
	jmp	SHORT $LN1@Con_DrawDe
$LN6@Con_DrawDe:

; 1974 : 
; 1975 : 			count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 1976 : 			y = 20 + fontTall * i;

	mov	eax, DWORD PTR _fontTall$3[ebp]
	imul	eax, DWORD PTR _i$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _y$[ebp], eax

; 1977 : 			Con_DrawString( x, y, con.notify[i].szNotify, con.notify[i].color );

	imul	ecx, DWORD PTR _i$[ebp], 268
	add	ecx, OFFSET _con+31376
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 268
	add	edx, OFFSET _con+31116
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$1[ebp]
	push	ecx
	call	_Con_DrawString
	add	esp, 16					; 00000010H
$LN5@Con_DrawDe:

; 1978 : 		}
; 1979 : 	}

	jmp	$LN2@Con_DrawDe
$LN3@Con_DrawDe:

; 1980 : 
; 1981 : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@Con_DrawDe:

; 1982 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawDebugLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_y$ = -4						; size = 4
_lines$ = 8						; size = 4
_Con_DrawInput PROC

; 1934 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1935 : 	int	y;
; 1936 : 
; 1937 : 	// don't draw anything (always draw if not active)
; 1938 : 	if( cls.key_dest != key_console || !con.curFont )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN3@Con_DrawIn
	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN2@Con_DrawIn
$LN3@Con_DrawIn:

; 1939 : 		return;

	jmp	SHORT $LN1@Con_DrawIn
$LN2@Con_DrawIn:

; 1940 : 
; 1941 : 	y = lines - ( con.curFont->charHeight * 2 );

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax+4356]
	shl	ecx, 1
	mov	edx, DWORD PTR _lines$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _y$[ebp], edx

; 1942 : 	Con_DrawCharacter( 8, y, ']', g_color_table[7] );

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	push	ecx
	push	93					; 0000005dH
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	push	8
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H

; 1943 : 	Field_DrawInputLine( 16, y, &con.input );

	push	OFFSET _con+13164
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	16					; 00000010H
	call	_Field_DrawInputLine
	add	esp, 12					; 0000000cH
$LN1@Con_DrawIn:

; 1944 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_curPos$ = -1068					; size = 4
$T1 = -1064						; size = 4
_hideChar$ = -1060					; size = 4
$T2 = -1056						; size = 4
tv85 = -1052						; size = 4
_colorDefault$ = -1048					; size = 4
_cursorChar$ = -1044					; size = 4
_len$ = -1040						; size = 4
_prestep$ = -1036					; size = 4
_drawLen$ = -1032					; size = 4
_str$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_edit$ = 16						; size = 4
_Field_DrawInputLine PROC

; 1687 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1068				; 0000042cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1688 : 	int	len, cursorChar;
; 1689 : 	int	drawLen, hideChar = -1;

	mov	DWORD PTR _hideChar$[ebp], -1

; 1690 : 	int	prestep, curPos;
; 1691 : 	char	str[MAX_SYSPATH];
; 1692 : 	byte	*colorDefault;
; 1693 : 
; 1694 : 	drawLen = edit->widthInChars;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	DWORD PTR _drawLen$[ebp], ecx

; 1695 : 	len = Q_strlen( edit->buffer ) + 1;

	mov	edx, DWORD PTR _edit$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1696 : 	colorDefault = g_color_table[ColorIndex( COLOR_DEFAULT )];

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	mov	DWORD PTR _colorDefault$[ebp], ecx

; 1697 : 
; 1698 : 	// guarantee that cursor will be visible
; 1699 : 	if( len <= drawLen )

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _drawLen$[ebp]
	jg	SHORT $LN2@Field_Draw

; 1700 : 	{
; 1701 : 		prestep = 0;

	mov	DWORD PTR _prestep$[ebp], 0

; 1702 : 	}

	jmp	SHORT $LN3@Field_Draw
$LN2@Field_Draw:

; 1703 : 	else
; 1704 : 	{
; 1705 : 		if( edit->scroll + drawLen > len )

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, DWORD PTR _drawLen$[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jle	SHORT $LN5@Field_Draw

; 1706 : 		{
; 1707 : 			edit->scroll = len - drawLen;

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR _drawLen$[ebp]
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], edx

; 1708 : 			if( edit->scroll < 0 ) edit->scroll = 0;

	mov	ecx, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [ecx+260], 0
	jge	SHORT $LN5@Field_Draw
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], 0
$LN5@Field_Draw:

; 1709 : 		}
; 1710 : 
; 1711 : 		prestep = edit->scroll;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	DWORD PTR _prestep$[ebp], ecx
$LN3@Field_Draw:

; 1712 : 	}
; 1713 : 
; 1714 : 	if( prestep + drawLen > len )

	mov	edx, DWORD PTR _prestep$[ebp]
	add	edx, DWORD PTR _drawLen$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jle	SHORT $LN6@Field_Draw

; 1715 : 		drawLen = len - prestep;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _prestep$[ebp]
	mov	DWORD PTR _drawLen$[ebp], eax
$LN6@Field_Draw:

; 1716 : 
; 1717 : 	// extract <drawLen> characters from the field at <prestep>
; 1718 : 	drawLen = Q_min( drawLen, MAX_SYSPATH - 1 );

	cmp	DWORD PTR _drawLen$[ebp], 1023		; 000003ffH
	jge	SHORT $LN12@Field_Draw
	mov	ecx, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	jmp	SHORT $LN13@Field_Draw
$LN12@Field_Draw:
	mov	DWORD PTR tv85[ebp], 1023		; 000003ffH
$LN13@Field_Draw:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _drawLen$[ebp], edx

; 1719 : 
; 1720 : 	memcpy( str, edit->buffer + prestep, drawLen );

	mov	eax, DWORD PTR _drawLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR _prestep$[ebp]
	push	ecx
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1721 : 	str[drawLen] = 0;

	mov	eax, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 1024		; 00000400H
	jae	SHORT $LN14@Field_Draw
	jmp	SHORT $LN15@Field_Draw
$LN14@Field_Draw:
	call	___report_rangecheckfailure
$LN15@Field_Draw:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _str$[ebp+ecx], 0

; 1722 : 
; 1723 : 	// save char for overstrike
; 1724 : 	cursorChar = str[edit->cursor - prestep];

	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [edx+256]
	sub	eax, DWORD PTR _prestep$[ebp]
	movsx	ecx, BYTE PTR _str$[ebp+eax]
	mov	DWORD PTR _cursorChar$[ebp], ecx

; 1725 : 
; 1726 : 	if( host.key_overstrike && cursorChar && !((int)( host.realtime * 4 ) & 1 ))

	cmp	DWORD PTR _host+34344, 0
	je	SHORT $LN7@Field_Draw
	cmp	DWORD PTR _cursorChar$[ebp], 0
	je	SHORT $LN7@Field_Draw
	movsd	xmm0, QWORD PTR _host+1440
	mulsd	xmm0, QWORD PTR __real@4010000000000000
	cvttsd2si edx, xmm0
	and	edx, 1
	jne	SHORT $LN7@Field_Draw

; 1727 : 		hideChar = edit->cursor - prestep; // skip this char

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, DWORD PTR _prestep$[ebp]
	mov	DWORD PTR _hideChar$[ebp], ecx
$LN7@Field_Draw:

; 1728 : 	
; 1729 : 	// draw it
; 1730 : 	Con_DrawGenericString( x, y, str, colorDefault, false, hideChar );

	mov	edx, DWORD PTR _hideChar$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _colorDefault$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_DrawGenericString
	add	esp, 24					; 00000018H

; 1731 : 
; 1732 : 	// draw the cursor
; 1733 : 	if((int)( host.realtime * 4 ) & 1 ) return; // off blink

	movsd	xmm0, QWORD PTR _host+1440
	mulsd	xmm0, QWORD PTR __real@4010000000000000
	cvttsd2si ecx, xmm0
	and	ecx, 1
	je	SHORT $LN8@Field_Draw
	jmp	$LN10@Field_Draw
$LN8@Field_Draw:

; 1734 : 
; 1735 : 	// calc cursor position
; 1736 : 	str[edit->cursor - prestep] = 0;

	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [edx+256]
	sub	eax, DWORD PTR _prestep$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN16@Field_Draw
	jmp	SHORT $LN17@Field_Draw
$LN16@Field_Draw:
	call	___report_rangecheckfailure
$LN17@Field_Draw:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _str$[ebp+ecx], 0

; 1737 : 	Con_DrawStringLen( str, &curPos, NULL );

	push	0
	lea	edx, DWORD PTR _curPos$[ebp]
	push	edx
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 1738 : 
; 1739 : 	if( host.key_overstrike && cursorChar )

	cmp	DWORD PTR _host+34344, 0
	je	SHORT $LN9@Field_Draw
	cmp	DWORD PTR _cursorChar$[ebp], 0
	je	SHORT $LN9@Field_Draw

; 1740 : 	{
; 1741 : 		// overstrike cursor
; 1742 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1743 : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1744 : 		pglBlendFunc( GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA );

	push	770					; 00000302H
	push	771					; 00000303H
	call	DWORD PTR _pglBlendFunc

; 1745 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1746 : 		Con_DrawGenericChar( x + curPos, y, cursorChar, colorDefault );

	mov	ecx, DWORD PTR _colorDefault$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cursorChar$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _curPos$[ebp]
	push	ecx
	call	_Con_DrawGenericChar
	add	esp, 16					; 00000010H

; 1747 : 	}

	jmp	SHORT $LN10@Field_Draw
$LN9@Field_Draw:

; 1748 : 	else Con_DrawCharacter( x + curPos, y, '_', colorDefault );

	mov	edx, DWORD PTR _colorDefault$[ebp]
	push	edx
	push	95					; 0000005fH
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _curPos$[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
$LN10@Field_Draw:

; 1749 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Field_DrawInputLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv198 = -8						; size = 4
_len$ = -4						; size = 4
_edit$ = 8						; size = 4
_key$ = 12						; size = 4
_Field_KeyDownEvent PROC

; 1554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1555 : 	int	len;
; 1556 : 
; 1557 : 	// shift-insert is paste
; 1558 : 	if((( key == K_INS ) || ( key == K_KP_INS )) && Key_IsDown( K_SHIFT ))

	cmp	DWORD PTR _key$[ebp], 147		; 00000093H
	je	SHORT $LN3@Field_KeyD
	cmp	DWORD PTR _key$[ebp], 170		; 000000aaH
	jne	SHORT $LN2@Field_KeyD
$LN3@Field_KeyD:
	push	134					; 00000086H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Field_KeyD

; 1559 : 	{
; 1560 : 		Field_Paste( edit );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Field_Paste
	add	esp, 4

; 1561 : 		return;

	jmp	$LN1@Field_KeyD
$LN2@Field_KeyD:

; 1562 : 	}
; 1563 : 
; 1564 : 	len = Q_strlen( edit->buffer );

	mov	ecx, DWORD PTR _edit$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1565 : 
; 1566 : 	if( key == K_DEL )

	cmp	DWORD PTR _key$[ebp], 148		; 00000094H
	jne	SHORT $LN4@Field_KeyD

; 1567 : 	{
; 1568 : 		if( edit->cursor < len )

	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [edx+256]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN5@Field_KeyD

; 1569 : 			memmove( edit->buffer + edit->cursor, edit->buffer + edit->cursor + 1, len - edit->cursor );

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR [ecx+256]
	push	edx
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR _edit$[ebp]
	add	edx, DWORD PTR [ecx+256]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN5@Field_KeyD:

; 1570 : 		return;

	jmp	$LN1@Field_KeyD
$LN4@Field_KeyD:

; 1571 : 	}
; 1572 : 
; 1573 : 	if( key == K_BACKSPACE )

	cmp	DWORD PTR _key$[ebp], 127		; 0000007fH
	jne	SHORT $LN6@Field_KeyD

; 1574 : 	{
; 1575 : 		if( edit->cursor > 0 )

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], 0
	jle	SHORT $LN7@Field_KeyD

; 1576 : 		{
; 1577 : 			memmove( edit->buffer + edit->cursor - 1, edit->buffer + edit->cursor, len - edit->cursor + 1 );

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR [ecx+256]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR [eax+256]
	push	ecx
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [edx+256]
	mov	ecx, DWORD PTR _edit$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1578 : 			edit->cursor--;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	sub	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx

; 1579 : 			if( edit->scroll ) edit->scroll--;

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN7@Field_KeyD
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	sub	edx, 1
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], edx
$LN7@Field_KeyD:

; 1580 : 		}
; 1581 : 		return;

	jmp	$LN1@Field_KeyD
$LN6@Field_KeyD:

; 1582 : 	}
; 1583 : 
; 1584 : 	if( key == K_RIGHTARROW ) 

	cmp	DWORD PTR _key$[ebp], 131		; 00000083H
	jne	SHORT $LN9@Field_KeyD

; 1585 : 	{
; 1586 : 		if( edit->cursor < len ) edit->cursor++;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN10@Field_KeyD
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+256], ecx
$LN10@Field_KeyD:

; 1587 : 		if( edit->cursor >= edit->scroll + edit->widthInChars && edit->cursor <= len )

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	edx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR [edx+264]
	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], ecx
	jl	SHORT $LN11@Field_KeyD
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	cmp	edx, DWORD PTR _len$[ebp]
	jg	SHORT $LN11@Field_KeyD

; 1588 : 			edit->scroll++;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], ecx
$LN11@Field_KeyD:

; 1589 : 		return;

	jmp	$LN1@Field_KeyD
$LN9@Field_KeyD:

; 1590 : 	}
; 1591 : 
; 1592 : 	if( key == K_LEFTARROW ) 

	cmp	DWORD PTR _key$[ebp], 130		; 00000082H
	jne	SHORT $LN12@Field_KeyD

; 1593 : 	{
; 1594 : 		if( edit->cursor > 0 ) edit->cursor--;

	mov	eax, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [eax+256], 0
	jle	SHORT $LN13@Field_KeyD
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	sub	edx, 1
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], edx
$LN13@Field_KeyD:

; 1595 : 		if( edit->cursor < edit->scroll ) edit->scroll--;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [ecx+256]
	cmp	eax, DWORD PTR [edx+260]
	jge	SHORT $LN14@Field_KeyD
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	sub	edx, 1
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], edx
$LN14@Field_KeyD:

; 1596 : 		return;

	jmp	$LN1@Field_KeyD
$LN12@Field_KeyD:

; 1597 : 	}
; 1598 : 
; 1599 : 	if( key == K_HOME || ( Q_tolower(key) == 'a' && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 151		; 00000097H
	je	SHORT $LN16@Field_KeyD
	movzx	ecx, BYTE PTR _key$[ebp]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	cmp	edx, 97					; 00000061H
	jne	SHORT $LN15@Field_KeyD
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@Field_KeyD
$LN16@Field_KeyD:

; 1600 : 	{
; 1601 : 		edit->cursor = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], 0

; 1602 : 		return;

	jmp	SHORT $LN1@Field_KeyD
$LN15@Field_KeyD:

; 1603 : 	}
; 1604 : 
; 1605 : 	if( key == K_END || ( Q_tolower(key) == 'e' && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 152		; 00000098H
	je	SHORT $LN18@Field_KeyD
	movzx	ecx, BYTE PTR _key$[ebp]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	cmp	edx, 101				; 00000065H
	jne	SHORT $LN17@Field_KeyD
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@Field_KeyD
$LN18@Field_KeyD:

; 1606 : 	{
; 1607 : 		edit->cursor = len;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+256], ecx

; 1608 : 		return;

	jmp	SHORT $LN1@Field_KeyD
$LN17@Field_KeyD:

; 1609 : 	}
; 1610 : 
; 1611 : 	if( key == K_INS )

	cmp	DWORD PTR _key$[ebp], 147		; 00000093H
	jne	SHORT $LN1@Field_KeyD

; 1612 : 	{
; 1613 : 		host.key_overstrike = !host.key_overstrike;

	cmp	DWORD PTR _host+34344, 0
	jne	SHORT $LN21@Field_KeyD
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN22@Field_KeyD
$LN21@Field_KeyD:
	mov	DWORD PTR tv198[ebp], 0
$LN22@Field_KeyD:
	mov	edx, DWORD PTR tv198[ebp]
	mov	DWORD PTR _host+34344, edx
$LN1@Field_KeyD:

; 1614 : 		return;
; 1615 : 	}
; 1616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Field_KeyDownEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_pasteLen$ = -12					; size = 4
_cbd$ = -8						; size = 4
_i$ = -4						; size = 4
_edit$ = 8						; size = 4
_Field_Paste PROC

; 1530 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1531 : 	char	*cbd;
; 1532 : 	int	i, pasteLen;
; 1533 : 
; 1534 : 	cbd = Sys_GetClipboardData();

	call	_Sys_GetClipboardData
	mov	DWORD PTR _cbd$[ebp], eax

; 1535 : 	if( !cbd ) return;

	cmp	DWORD PTR _cbd$[ebp], 0
	jne	SHORT $LN5@Field_Past
	jmp	SHORT $LN1@Field_Past
$LN5@Field_Past:

; 1536 : 
; 1537 : 	// send as if typed, so insert / overstrike works properly
; 1538 : 	pasteLen = Q_strlen( cbd );

	mov	eax, DWORD PTR _cbd$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _pasteLen$[ebp], eax

; 1539 : 	for( i = 0; i < pasteLen; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Field_Past
$LN2@Field_Past:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Field_Past:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _pasteLen$[ebp]
	jge	SHORT $LN1@Field_Past

; 1540 : 		Field_CharEvent( edit, cbd[i] );

	mov	eax, DWORD PTR _cbd$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _edit$[ebp]
	push	edx
	call	_Field_CharEvent
	add	esp, 8
	jmp	SHORT $LN2@Field_Past
$LN1@Field_Past:

; 1541 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Field_Paste ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_nextcmd$ = -552					; size = 4
tv75 = -548						; size = 4
_last$1 = -544						; size = 4
_first$2 = -540						; size = 4
_len$3 = -536						; size = 4
_i$ = -532						; size = 4
_temp$ = -528						; size = 268
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_field$ = 8						; size = 4
_Con_CompleteCommand PROC

; 1412 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1413 : 	field_t	temp;
; 1414 : 	string	filename;
; 1415 : 	qboolean	nextcmd;
; 1416 : 	int	i;
; 1417 : 
; 1418 : 	// setup the completion field
; 1419 : 	con.completionField = field;

	mov	eax, DWORD PTR _field$[ebp]
	mov	DWORD PTR _con+65680, eax

; 1420 : 
; 1421 : 	// only look at the first token for completion purposes
; 1422 : 	Cmd_TokenizeString( con.completionField->buffer );

	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Cmd_TokenizeString
	add	esp, 4

; 1423 : 
; 1424 : 	nextcmd = ( con.completionField->buffer[Q_strlen( con.completionField->buffer ) - 1] == ' ' ) ? true : false;

	mov	edx, DWORD PTR _con+65680
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _con+65680
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN27@Con_Comple
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN28@Con_Comple
$LN27@Con_Comple:
	mov	DWORD PTR tv75[ebp], 0
$LN28@Con_Comple:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _nextcmd$[ebp], eax

; 1425 : 
; 1426 : 	con.completionString = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _con+65684, eax

; 1427 : 	con.completionBuffer = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _con+65688, eax
$LN2@Con_Comple:

; 1428 : 
; 1429 : 	// skip backslash
; 1430 : 	while( *con.completionString && ( *con.completionString == '\\' || *con.completionString == '/' ))

	mov	ecx, DWORD PTR _con+65684
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN4@Con_Comple
	mov	eax, DWORD PTR _con+65684
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN11@Con_Comple
	mov	edx, DWORD PTR _con+65684
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN4@Con_Comple
$LN11@Con_Comple:

; 1431 : 		con.completionString++;

	mov	ecx, DWORD PTR _con+65684
	add	ecx, 1
	mov	DWORD PTR _con+65684, ecx
	jmp	SHORT $LN2@Con_Comple
$LN4@Con_Comple:

; 1432 : 
; 1433 : 	// skip backslash
; 1434 : 	while( *con.completionBuffer && ( *con.completionBuffer == '\\' || *con.completionBuffer == '/' ))

	mov	edx, DWORD PTR _con+65688
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@Con_Comple
	mov	ecx, DWORD PTR _con+65688
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN12@Con_Comple
	mov	eax, DWORD PTR _con+65688
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN5@Con_Comple
$LN12@Con_Comple:

; 1435 : 		con.completionBuffer++;

	mov	edx, DWORD PTR _con+65688
	add	edx, 1
	mov	DWORD PTR _con+65688, edx
	jmp	SHORT $LN4@Con_Comple
$LN5@Con_Comple:

; 1436 : 
; 1437 : 	if( !Q_strlen( con.completionString ))

	mov	eax, DWORD PTR _con+65684
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@Con_Comple

; 1438 : 		return;

	jmp	$LN1@Con_Comple
$LN13@Con_Comple:

; 1439 : 
; 1440 : 	// free the old autocomplete list
; 1441 : 	for( i = 0; i < con.matchCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@Con_Comple
$LN6@Con_Comple:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN8@Con_Comple:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _con+82076
	jge	SHORT $LN7@Con_Comple

; 1442 : 	{
; 1443 : 		if( con.cmds[i] != NULL )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _con[eax*4+65692], 0
	je	SHORT $LN14@Con_Comple

; 1444 : 		{
; 1445 : 			Mem_Free( con.cmds[i] );

	push	1445					; 000005a5H
	push	OFFSET $SG144231
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _con[ecx*4+65692]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1446 : 			con.cmds[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _con[eax*4+65692], 0
$LN14@Con_Comple:

; 1447 : 		}
; 1448 : 	}

	jmp	SHORT $LN6@Con_Comple
$LN7@Con_Comple:

; 1449 : 
; 1450 : 	con.matchCount = 0;

	mov	DWORD PTR _con+82076, 0

; 1451 : 	con.shortestMatch[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _con[edx+65424], 0

; 1452 : 
; 1453 : 	// find matching commands and variables
; 1454 : 	Cmd_LookupCmds( NULL, NULL, Con_AddCommandToList );

	push	OFFSET _Con_AddCommandToList
	push	0
	push	0
	call	_Cmd_LookupCmds
	add	esp, 12					; 0000000cH

; 1455 : 	Cvar_LookupVars( 0, NULL, NULL, Con_AddCommandToList );

	push	OFFSET _Con_AddCommandToList
	push	0
	push	0
	push	0
	call	_Cvar_LookupVars
	add	esp, 16					; 00000010H

; 1456 : 
; 1457 : 	if( !con.matchCount ) return; // no matches

	cmp	DWORD PTR _con+82076, 0
	jne	SHORT $LN15@Con_Comple
	jmp	$LN1@Con_Comple
$LN15@Con_Comple:

; 1458 : 
; 1459 : 	memcpy( &temp, con.completionField, sizeof( field_t ));

	push	268					; 0000010cH
	mov	eax, DWORD PTR _con+65680
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1460 : 
; 1461 : 	// autocomplete second arg
; 1462 : 	if(( Cmd_Argc() == 2 ) || (( Cmd_Argc() == 1 ) && nextcmd ))

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN18@Con_Comple
	call	_Cmd_Argc
	cmp	eax, 1
	jne	$LN16@Con_Comple
	cmp	DWORD PTR _nextcmd$[ebp], 0
	je	SHORT $LN16@Con_Comple
$LN18@Con_Comple:

; 1463 : 	{
; 1464 : 		if( !Q_strlen( con.completionBuffer ))

	mov	edx, DWORD PTR _con+65688
	push	edx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@Con_Comple

; 1465 : 			return;

	jmp	$LN1@Con_Comple
$LN19@Con_Comple:

; 1466 : 
; 1467 : 		if( Cmd_AutocompleteName( con.completionBuffer, filename, sizeof( filename )))

	push	256					; 00000100H
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _con+65688
	push	ecx
	call	_Cmd_AutocompleteName
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@Con_Comple

; 1468 : 		{         
; 1469 : 			Q_sprintf( con.completionField->buffer, "%s %s", Cmd_Argv( 0 ), filename ); 

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG144238
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 1470 : 			con.completionField->cursor = Q_strlen( con.completionField->buffer );

	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _con+65680
	mov	DWORD PTR [edx+256], eax
$LN20@Con_Comple:

; 1471 : 		}
; 1472 : 
; 1473 : 		// don't adjusting cursor pos if we nothing found
; 1474 : 		return;

	jmp	$LN1@Con_Comple

; 1475 : 	}  

	jmp	SHORT $LN17@Con_Comple
$LN16@Con_Comple:

; 1476 : 	else if( Cmd_Argc() >= 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	jb	SHORT $LN17@Con_Comple

; 1477 : 	{
; 1478 : 		// disable autocomplete for all next args
; 1479 : 		return;

	jmp	$LN1@Con_Comple
$LN17@Con_Comple:

; 1480 : 	}
; 1481 : 
; 1482 : 	if( con.matchCount == 1 )

	cmp	DWORD PTR _con+82076, 1
	jne	SHORT $LN22@Con_Comple

; 1483 : 	{
; 1484 : 		Q_sprintf( con.completionField->buffer, "\\%s", con.cmds[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _con[ecx+65692]
	push	edx
	push	OFFSET $SG144242
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1485 : 		if( Cmd_Argc() == 1 ) Q_strncat( con.completionField->buffer, " ", sizeof( con.completionField->buffer ));

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN24@Con_Comple
	push	256					; 00000100H
	push	OFFSET $SG144245
	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN25@Con_Comple
$LN24@Con_Comple:

; 1486 : 		else Con_ConcatRemaining( temp.buffer, con.completionString );

	mov	edx, DWORD PTR _con+65684
	push	edx
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Con_ConcatRemaining
	add	esp, 8
$LN25@Con_Comple:

; 1487 : 		con.completionField->cursor = Q_strlen( con.completionField->buffer );

	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _con+65680
	mov	DWORD PTR [edx+256], eax

; 1488 : 	}

	jmp	$LN1@Con_Comple
$LN22@Con_Comple:

; 1489 : 	else
; 1490 : 	{
; 1491 : 		char	*first, *last;
; 1492 : 		int	len = 0;

	mov	DWORD PTR _len$3[ebp], 0

; 1493 : 
; 1494 : 		qsort( con.cmds, con.matchCount, sizeof( char* ), Con_SortCmds );

	push	OFFSET _Con_SortCmds
	push	4
	mov	eax, DWORD PTR _con+82076
	push	eax
	push	OFFSET _con+65692
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 1495 : 
; 1496 : 		// find the number of matching characters between the first and
; 1497 : 		// the last element in the list and copy it
; 1498 : 		first = con.cmds[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _con[edx+65692]
	mov	DWORD PTR _first$2[ebp], eax

; 1499 : 		last = con.cmds[con.matchCount-1];

	mov	ecx, DWORD PTR _con+82076
	mov	edx, DWORD PTR _con[ecx*4+65688]
	mov	DWORD PTR _last$1[ebp], edx
$LN9@Con_Comple:

; 1500 : 
; 1501 : 		while( *first && *last && Q_tolower( *first ) == Q_tolower( *last ))

	mov	eax, DWORD PTR _first$2[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN10@Con_Comple
	mov	edx, DWORD PTR _last$1[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN10@Con_Comple
	mov	ecx, DWORD PTR _first$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	eax, DWORD PTR _last$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	cmp	esi, edx
	jne	SHORT $LN10@Con_Comple

; 1502 : 		{
; 1503 : 			first++;

	mov	eax, DWORD PTR _first$2[ebp]
	add	eax, 1
	mov	DWORD PTR _first$2[ebp], eax

; 1504 : 			last++;

	mov	ecx, DWORD PTR _last$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _last$1[ebp], ecx

; 1505 : 
; 1506 : 			con.shortestMatch[len] = con.cmds[0][len];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _con[eax+65692]
	mov	edx, DWORD PTR _len$3[ebp]
	mov	eax, DWORD PTR _len$3[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _con[edx+65424], cl

; 1507 : 			len++;

	mov	edx, DWORD PTR _len$3[ebp]
	add	edx, 1
	mov	DWORD PTR _len$3[ebp], edx

; 1508 : 		}

	jmp	$LN9@Con_Comple
$LN10@Con_Comple:

; 1509 : 		con.shortestMatch[len] = 0;

	mov	eax, DWORD PTR _len$3[ebp]
	mov	BYTE PTR _con[eax+65424], 0

; 1510 : 
; 1511 : 		// multiple matches, complete to shortest
; 1512 : 		Q_sprintf( con.completionField->buffer, "\\%s", con.shortestMatch );

	push	OFFSET _con+65424
	push	OFFSET $SG144246
	mov	ecx, DWORD PTR _con+65680
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1513 : 		con.completionField->cursor = Q_strlen( con.completionField->buffer );

	mov	edx, DWORD PTR _con+65680
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _con+65680
	mov	DWORD PTR [ecx+256], eax

; 1514 : 		Con_ConcatRemaining( temp.buffer, con.completionString );

	mov	edx, DWORD PTR _con+65684
	push	edx
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Con_ConcatRemaining
	add	esp, 8

; 1515 : 
; 1516 : 		Con_Printf( "]%s\n", con.completionField->buffer );

	mov	ecx, DWORD PTR _con+65680
	push	ecx
	push	OFFSET $SG144247
	call	_Con_Printf
	add	esp, 8

; 1517 : 
; 1518 : 		// run through again, printing matches
; 1519 : 		Cmd_LookupCmds( NULL, NULL, Con_PrintCmdMatches );

	push	OFFSET _Con_PrintCmdMatches
	push	0
	push	0
	call	_Cmd_LookupCmds
	add	esp, 12					; 0000000cH

; 1520 : 		Cvar_LookupVars( 0, NULL, NULL, Con_PrintCvarMatches );

	push	OFFSET _Con_PrintCvarMatches
	push	0
	push	0
	push	0
	call	_Cvar_LookupVars
	add	esp, 16					; 00000010H
$LN1@Con_Comple:

; 1521 : 	}
; 1522 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_CompleteCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_arg$ = -4						; size = 4
_src$ = 8						; size = 4
_start$ = 12						; size = 4
_Con_ConcatRemaining PROC

; 1372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1373 : 	char	*arg;
; 1374 : 	int	i;
; 1375 : 
; 1376 : 	arg = Q_strstr( src, start );

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 1377 : 
; 1378 : 	if( !arg )

	cmp	DWORD PTR _arg$[ebp], 0
	jne	$LN7@Con_Concat

; 1379 : 	{
; 1380 : 		for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Con_Concat
$LN2@Con_Concat:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Con_Concat:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN3@Con_Concat

; 1381 : 		{
; 1382 : 			Q_strncat( con.completionField->buffer, " ", sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	push	OFFSET $SG144190
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1383 : 			arg = Cmd_Argv( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _arg$[ebp], eax
$LN5@Con_Concat:

; 1384 : 			while( *arg )

	mov	edx, DWORD PTR _arg$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@Con_Concat

; 1385 : 			{
; 1386 : 				if( *arg == ' ' )

	mov	ecx, DWORD PTR _arg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN8@Con_Concat

; 1387 : 				{
; 1388 : 					Q_strncat( con.completionField->buffer, "\"", sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	push	OFFSET $SG144192
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1389 : 					break;

	jmp	SHORT $LN6@Con_Concat
$LN8@Con_Concat:

; 1390 : 				}
; 1391 : 				arg++;

	mov	ecx, DWORD PTR _arg$[ebp]
	add	ecx, 1
	mov	DWORD PTR _arg$[ebp], ecx

; 1392 : 			}

	jmp	SHORT $LN5@Con_Concat
$LN6@Con_Concat:

; 1393 : 
; 1394 : 			Q_strncat( con.completionField->buffer, Cmd_Argv( i ), sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1395 : 			if( *arg == ' ' ) Q_strncat( con.completionField->buffer, "\"", sizeof( con.completionField->buffer ));

	mov	ecx, DWORD PTR _arg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN9@Con_Concat
	push	256					; 00000100H
	push	OFFSET $SG144194
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN9@Con_Concat:

; 1396 : 		}

	jmp	$LN2@Con_Concat
$LN3@Con_Concat:

; 1397 : 		return;

	jmp	SHORT $LN1@Con_Concat
$LN7@Con_Concat:

; 1398 : 	}
; 1399 : 
; 1400 : 	arg += Q_strlen( start );

	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	add	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _arg$[ebp], eax

; 1401 : 	Q_strncat( con.completionField->buffer, arg, sizeof( con.completionField->buffer ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	mov	eax, DWORD PTR _con+65680
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN1@Con_Concat:

; 1402 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ConcatRemaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_value$ = 12						; size = 4
_m$ = 16						; size = 4
_unused2$ = 20						; size = 4
_Con_PrintCvarMatches PROC

; 1358 : {

	push	ebp
	mov	ebp, esp

; 1359 : 	if( !Q_strnicmp( s, con.shortestMatch, Q_strlen( con.shortestMatch )))

	push	OFFSET _con+65424
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET _con+65424
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@Con_PrintC

; 1360 : 	{
; 1361 : 		if( COM_CheckString( m )) Con_Printf( "    %s (%s)   ^3\"%s\"\n", s, value, m );

	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Con_PrintC
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET $SG144174
	call	_Con_Printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@Con_PrintC
$LN3@Con_PrintC:

; 1362 : 		else Con_Printf( "    %s  (%s)\n", s, value ); // variable or command without description

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG144175
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN1@Con_PrintC:

; 1363 : 	}
; 1364 : }

	pop	ebp
	ret	0
_Con_PrintCvarMatches ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_unused1$ = 12						; size = 4
_m$ = 16						; size = 4
_unused2$ = 20						; size = 4
_Con_PrintCmdMatches PROC

; 1344 : {

	push	ebp
	mov	ebp, esp

; 1345 : 	if( !Q_strnicmp( s, con.shortestMatch, Q_strlen( con.shortestMatch )))

	push	OFFSET _con+65424
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET _con+65424
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@Con_PrintC

; 1346 : 	{
; 1347 : 		if( COM_CheckString( m )) Con_Printf( "    %s ^3\"%s\"\n", s, m );

	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Con_PrintC
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG144159
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Con_PrintC
$LN3@Con_PrintC:

; 1348 : 		else Con_Printf( "    %s\n", s ); // variable or command without description

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET $SG144160
	call	_Con_Printf
	add	esp, 8
$LN1@Con_PrintC:

; 1349 : 	}
; 1350 : }

	pop	ebp
	ret	0
_Con_PrintCmdMatches ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
_Con_SortCmds PROC

; 1334 : {

	push	ebp
	mov	ebp, esp

; 1335 : 	return Q_stricmp( *arg1, *arg2 );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _arg2$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _arg1$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH

; 1336 : }

	pop	ebp
	ret	0
_Con_SortCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_unused1$ = 12						; size = 4
_unused2$ = 16						; size = 4
_unused3$ = 20						; size = 4
_Con_AddCommandToList PROC

; 1318 : {

	push	ebp
	mov	ebp, esp

; 1319 : 	if( *s == '@' ) return; // never show system cvars or cmds

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN2@Con_AddCom
	jmp	SHORT $LN1@Con_AddCom
$LN2@Con_AddCom:

; 1320 : 	if( con.matchCount >= CON_MAXCMDS ) return; // list is full

	cmp	DWORD PTR _con+82076, 4096		; 00001000H
	jl	SHORT $LN3@Con_AddCom
	jmp	SHORT $LN1@Con_AddCom
$LN3@Con_AddCom:

; 1321 : 
; 1322 : 	if( Q_strnicmp( s, con.completionString, Q_strlen( con.completionString )))

	mov	edx, DWORD PTR _con+65684
	push	edx
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _con+65684
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@Con_AddCom

; 1323 : 		return; // no match

	jmp	SHORT $LN1@Con_AddCom
$LN4@Con_AddCom:

; 1324 : 
; 1325 : 	con.cmds[con.matchCount++] = copystring( s );

	push	1325					; 0000052dH
	push	OFFSET $SG144139
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _con+82076
	mov	DWORD PTR _con[ecx*4+65692], eax
	mov	edx, DWORD PTR _con+82076
	add	edx, 1
	mov	DWORD PTR _con+82076, edx
$LN1@Con_AddCom:

; 1326 : }

	pop	ebp
	ret	0
_Con_AddCommandToList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_color$ = -16						; size = 4
_numDraws$ = -12					; size = 4
_drawLen$ = -8						; size = 4
_s$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_setColor$ = 20						; size = 4
_forceColor$ = 24					; size = 4
_hideChar$ = 28						; size = 4
_Con_DrawGenericString PROC

; 895  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 896  : 	rgba_t		color;
; 897  : 	int		drawLen = 0;

	mov	DWORD PTR _drawLen$[ebp], 0

; 898  : 	int		numDraws = 0;

	mov	DWORD PTR _numDraws$[ebp], 0

; 899  : 	const char	*s;
; 900  : 
; 901  : 	if( !con.curFont ) return 0; // no font set

	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN4@Con_DrawGe
	xor	eax, eax
	jmp	$LN1@Con_DrawGe
$LN4@Con_DrawGe:

; 902  : 
; 903  : 	// draw the colored text
; 904  : 	*(uint *)color = *(uint *)setColor;

	mov	eax, DWORD PTR _setColor$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _color$[ebp], ecx

; 905  : 	s = string;

	mov	edx, DWORD PTR _string$[ebp]
	mov	DWORD PTR _s$[ebp], edx
$LN2@Con_DrawGe:

; 906  : 
; 907  : 	while( *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Con_DrawGe

; 908  : 	{
; 909  : 		if( *s == '\n' )

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN5@Con_DrawGe

; 910  : 		{
; 911  : 			s++;

	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 912  : 			if( !*s ) break; // at end the string

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN6@Con_DrawGe
	jmp	$LN3@Con_DrawGe
$LN6@Con_DrawGe:

; 913  : 			drawLen = 0; // begin new row

	mov	DWORD PTR _drawLen$[ebp], 0

; 914  : 			y += con.curFont->charHeight;

	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR [ecx+4356]
	mov	DWORD PTR _y$[ebp], edx
$LN5@Con_DrawGe:

; 915  : 		}
; 916  : 
; 917  : 		if( IsColorString( s ))

	cmp	DWORD PTR _s$[ebp], 0
	je	$LN7@Con_DrawGe
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN7@Con_DrawGe
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	test	eax, eax
	je	SHORT $LN7@Con_DrawGe
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN7@Con_DrawGe
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN7@Con_DrawGe

; 918  : 		{
; 919  : 			if( !forceColor )

	cmp	DWORD PTR _forceColor$[ebp], 0
	jne	SHORT $LN8@Con_DrawGe

; 920  : 			{
; 921  : 				memcpy( color, g_color_table[ColorIndex(*(s+1))], sizeof( color ));

	push	4
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sub	eax, 48					; 00000030H
	and	eax, 7
	lea	ecx, DWORD PTR _g_color_table[eax*4]
	push	ecx
	lea	edx, DWORD PTR _color$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 922  : 				color[3] = setColor[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _setColor$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _color$[ebp+eax], cl
$LN8@Con_DrawGe:

; 923  : 			}
; 924  : 
; 925  : 			s += 2;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2
	mov	DWORD PTR _s$[ebp], edx

; 926  : 			numDraws++;

	mov	eax, DWORD PTR _numDraws$[ebp]
	add	eax, 1
	mov	DWORD PTR _numDraws$[ebp], eax

; 927  : 			continue;

	jmp	$LN2@Con_DrawGe
$LN7@Con_DrawGe:

; 928  : 		}
; 929  : 
; 930  : 		// hide char for overstrike mode
; 931  : 		if( hideChar == numDraws )

	mov	ecx, DWORD PTR _hideChar$[ebp]
	cmp	ecx, DWORD PTR _numDraws$[ebp]
	jne	SHORT $LN9@Con_DrawGe

; 932  : 			drawLen += con.curFont->charWidths[*s];

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _con+13156
	movzx	edx, BYTE PTR [ecx+eax+4100]
	add	edx, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR _drawLen$[ebp], edx
	jmp	SHORT $LN10@Con_DrawGe
$LN9@Con_DrawGe:

; 933  : 		else drawLen += Con_DrawCharacter( x + drawLen, y, *s, color );

	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _drawLen$[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _drawLen$[ebp]
	mov	DWORD PTR _drawLen$[ebp], eax
$LN10@Con_DrawGe:

; 934  : 
; 935  : 		numDraws++;

	mov	edx, DWORD PTR _numDraws$[ebp]
	add	edx, 1
	mov	DWORD PTR _numDraws$[ebp], edx

; 936  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 937  : 	}

	jmp	$LN2@Con_DrawGe
$LN3@Con_DrawGe:

; 938  :           
; 939  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 940  : 	return drawLen;

	mov	eax, DWORD PTR _drawLen$[ebp]
$LN1@Con_DrawGe:

; 941  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawGenericString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_s1$ = -32						; size = 4
_t1$ = -28						; size = 4
_s2$ = -24						; size = 4
_t2$ = -20						; size = 4
_glt$ = -16						; size = 4
_width$ = -12						; size = 4
_height$ = -8						; size = 4
_rc$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_color$ = 20						; size = 4
_Con_DrawGenericChar PROC

; 747  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 748  : 	int		width, height;
; 749  : 	float		s1, t1, s2, t2;
; 750  : 	gl_texture_t	*glt;
; 751  : 	wrect_t		*rc;
; 752  : 
; 753  : 	number &= 255;

	mov	eax, DWORD PTR _number$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _number$[ebp], eax

; 754  : 
; 755  : 	if( !con.curFont || !con.curFont->valid )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN3@Con_DrawGe
	mov	ecx, DWORD PTR _con+13156
	cmp	DWORD PTR [ecx+4364], 0
	jne	SHORT $LN2@Con_DrawGe
$LN3@Con_DrawGe:

; 756  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Con_DrawGe
$LN2@Con_DrawGe:

; 757  : 
; 758  : 	if( y < -con.curFont->charHeight )

	mov	edx, DWORD PTR _con+13156
	mov	eax, DWORD PTR [edx+4356]
	neg	eax
	cmp	DWORD PTR _y$[ebp], eax
	jge	SHORT $LN4@Con_DrawGe

; 759  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Con_DrawGe
$LN4@Con_DrawGe:

; 760  : 
; 761  : 	rc = &con.curFont->fontRc[number];

	mov	ecx, DWORD PTR _number$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _con+13156
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _rc$[ebp], eax

; 762  : 	glt = R_GetTexture( con.curFont->hFontTexture );

	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 763  : 	width = glt->srcWidth;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+256]
	mov	DWORD PTR _width$[ebp], ecx

; 764  : 	height = glt->srcHeight;

	mov	edx, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [edx+258]
	mov	DWORD PTR _height$[ebp], eax

; 765  : 
; 766  : 	if( !width || !height )

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN6@Con_DrawGe
	cmp	DWORD PTR _height$[ebp], 0
	jne	SHORT $LN5@Con_DrawGe
$LN6@Con_DrawGe:

; 767  : 		return con.curFont->charWidths[number];

	mov	ecx, DWORD PTR _con+13156
	add	ecx, DWORD PTR _number$[ebp]
	movzx	eax, BYTE PTR [ecx+4100]
	jmp	$LN1@Con_DrawGe
$LN5@Con_DrawGe:

; 768  : 
; 769  : 	// don't apply color to fixed fonts it's already colored
; 770  : 	if( con.curFont->type != FONT_FIXED || glt->format == GL_LUMINANCE8_ALPHA8 )

	mov	edx, DWORD PTR _con+13156
	cmp	DWORD PTR [edx+4360], 0
	jne	SHORT $LN9@Con_DrawGe
	mov	eax, DWORD PTR _glt$[ebp]
	cmp	DWORD PTR [eax+276], 32837		; 00008045H
	jne	SHORT $LN7@Con_DrawGe
$LN9@Con_DrawGe:

; 771  : 		pglColor4ubv( color );

	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	call	DWORD PTR _pglColor4ubv
	jmp	SHORT $LN8@Con_DrawGe
$LN7@Con_DrawGe:

; 772  : 	else pglColor4ub( 255, 255, 255, color[3] );

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _color$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN8@Con_DrawGe:

; 773  : 	R_GetTextureParms( &width, &height, con.curFont->hFontTexture );

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _height$[ebp]
	push	edx
	lea	eax, DWORD PTR _width$[ebp]
	push	eax
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 774  : 
; 775  : 	// calc rectangle
; 776  : 	s1 = (float)rc->left / width;

	mov	ecx, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s1$[ebp], xmm0

; 777  : 	t1 = (float)rc->top / height;

	mov	edx, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+8]
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 778  : 	s2 = (float)rc->right / width;

	mov	eax, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s2$[ebp], xmm0

; 779  : 	t2 = (float)rc->bottom / height;

	mov	ecx, DWORD PTR _rc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+12]
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 780  : 	width = rc->right - rc->left;

	mov	edx, DWORD PTR _rc$[ebp]
	mov	eax, DWORD PTR _rc$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _width$[ebp], ecx

; 781  : 	height = rc->bottom - rc->top;

	mov	edx, DWORD PTR _rc$[ebp]
	mov	eax, DWORD PTR _rc$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _height$[ebp], ecx

; 782  : 
; 783  : 	if( clgame.ds.adjust_size )

	cmp	DWORD PTR _clgame+122680, 0
	je	SHORT $LN10@Con_DrawGe

; 784  : 		Con_TextAdjustSize( &x, &y, &width, &height );

	lea	edx, DWORD PTR _height$[ebp]
	push	edx
	lea	eax, DWORD PTR _width$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_Con_TextAdjustSize
	add	esp, 16					; 00000010H
$LN10@Con_DrawGe:

; 785  : 	R_DrawStretchPic( x, y, width, height, s1, t1, s2, t2, con.curFont->hFontTexture );		

	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 786  : 	pglColor4ub( 255, 255, 255, 255 ); // don't forget reset color

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 787  : 
; 788  : 	return con.curFont->charWidths[number];

	mov	edx, DWORD PTR _con+13156
	add	edx, DWORD PTR _number$[ebp]
	movzx	eax, BYTE PTR [edx+4100]
$LN1@Con_DrawGe:

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawGenericChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_yscale$ = -8						; size = 4
_xscale$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_Con_TextAdjustSize PROC

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 725  : 	float	xscale, yscale;
; 726  : 
; 727  : 	if( !x && !y && !w && !h ) return;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN2@Con_TextAd
	jmp	$LN6@Con_TextAd
$LN2@Con_TextAd:

; 728  : 
; 729  : 	// scale for screen sizes
; 730  : 	xscale = (float)glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+124888
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 731  : 	yscale = (float)glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+124892
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 732  : 
; 733  : 	if( x ) *x *= xscale;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@Con_TextAd
	mov	eax, DWORD PTR _x$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@Con_TextAd:

; 734  : 	if( y ) *y *= yscale;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@Con_TextAd
	mov	eax, DWORD PTR _y$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@Con_TextAd:

; 735  : 	if( w ) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN5@Con_TextAd
	mov	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@Con_TextAd:

; 736  : 	if( h ) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN6@Con_TextAd
	mov	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@Con_TextAd:

; 737  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_TextAdjustSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv72 = -24						; size = 4
_col$ = -20						; size = 4
_row$ = -16						; size = 4
_drawline$ = -12					; size = 4
_source$ = -8						; size = 4
_x$ = -4						; size = 4
_num$ = 8						; size = 4
_conchars$ = 12						; size = 4
_dest$ = 16						; size = 4
_Con_DrawCharToConback PROC

; 693  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 694  : 	int	row, col;
; 695  : 	byte	*source;
; 696  : 	int	drawline;
; 697  : 	int	x;
; 698  : 
; 699  : 	row = num >> 4;

	mov	eax, DWORD PTR _num$[ebp]
	sar	eax, 4
	mov	DWORD PTR _row$[ebp], eax

; 700  : 	col = num & 15;

	mov	ecx, DWORD PTR _num$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _col$[ebp], ecx

; 701  : 	source = conchars + (row << 10) + (col << 3);

	mov	edx, DWORD PTR _row$[ebp]
	shl	edx, 10					; 0000000aH
	add	edx, DWORD PTR _conchars$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _source$[ebp], ecx

; 702  : 
; 703  : 	drawline = 8;

	mov	DWORD PTR _drawline$[ebp], 8
$LN2@Con_DrawCh:

; 704  : 
; 705  : 	while( drawline-- )

	mov	edx, DWORD PTR _drawline$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR _drawline$[ebp]
	sub	eax, 1
	mov	DWORD PTR _drawline$[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN1@Con_DrawCh

; 706  : 	{
; 707  : 		for( x = 0; x < 8; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN6@Con_DrawCh
$LN4@Con_DrawCh:
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx
$LN6@Con_DrawCh:
	cmp	DWORD PTR _x$[ebp], 8
	jge	SHORT $LN5@Con_DrawCh

; 708  : 			if( source[x] != 255 )

	mov	edx, DWORD PTR _source$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN7@Con_DrawCh

; 709  : 				dest[x] = 0x60 + source[x];

	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	edx, 96					; 00000060H
	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	BYTE PTR [eax], dl
$LN7@Con_DrawCh:
	jmp	SHORT $LN4@Con_DrawCh
$LN5@Con_DrawCh:

; 710  : 		source += 128;

	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR _source$[ebp], ecx

; 711  : 		dest += 320;

	mov	edx, DWORD PTR _dest$[ebp]
	add	edx, 320				; 00000140H
	mov	DWORD PTR _dest$[ebp], edx

; 712  : 	}

	jmp	SHORT $LN2@Con_DrawCh
$LN1@Con_DrawCh:

; 713  : 
; 714  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawCharToConback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_fontSize$ = -8						; size = 4
_i$ = -4						; size = 4
_Con_LoadConchars PROC

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 674  : 	int	i, fontSize;
; 675  : 
; 676  : 	// load all the console fonts
; 677  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_LoadCo
$LN2@Con_LoadCo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_LoadCo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@Con_LoadCo

; 678  : 		Con_LoadConsoleFont( i, con.chars + i );

	imul	ecx, DWORD PTR _i$[ebp], 4368
	add	ecx, OFFSET _con+52
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Con_LoadConsoleFont
	add	esp, 8
	jmp	SHORT $LN2@Con_LoadCo
$LN3@Con_LoadCo:

; 679  : 
; 680  : 	// select properly fontsize
; 681  : 	if( glState.width <= 640 )

	cmp	DWORD PTR _glState, 640			; 00000280H
	jg	SHORT $LN5@Con_LoadCo

; 682  : 		fontSize = 0;

	mov	DWORD PTR _fontSize$[ebp], 0
	jmp	SHORT $LN6@Con_LoadCo
$LN5@Con_LoadCo:

; 683  : 	else if( glState.width >= 1280 )

	cmp	DWORD PTR _glState, 1280		; 00000500H
	jl	SHORT $LN7@Con_LoadCo

; 684  : 		fontSize = 2;

	mov	DWORD PTR _fontSize$[ebp], 2
	jmp	SHORT $LN6@Con_LoadCo
$LN7@Con_LoadCo:

; 685  : 	else fontSize = 1;

	mov	DWORD PTR _fontSize$[ebp], 1
$LN6@Con_LoadCo:

; 686  : 
; 687  : 	// sets the current font
; 688  : 	con.lastUsedFont = con.curFont = &con.chars[fontSize];

	imul	eax, DWORD PTR _fontSize$[ebp], 4368
	add	eax, OFFSET _con+52
	mov	DWORD PTR _con+13156, eax
	mov	ecx, DWORD PTR _con+13156
	mov	DWORD PTR _con+13160, ecx

; 689  : 	
; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadConchars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_fontNumber$ = 8					; size = 4
_font$ = 12						; size = 4
_Con_LoadConsoleFont PROC

; 655  : {

	push	ebp
	mov	ebp, esp

; 656  : 	if( font->valid ) return; // already loaded

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN2@Con_LoadCo
	jmp	SHORT $LN1@Con_LoadCo
$LN2@Con_LoadCo:

; 657  : 
; 658  : 	// loading conchars
; 659  : 	if( Sys_CheckParm( "-oldfont" ))

	push	OFFSET $SG143770
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Con_LoadCo

; 660  : 		Con_LoadVariableWidthFont( "gfx.wad/conchars.fnt", font );

	mov	ecx, DWORD PTR _font$[ebp]
	push	ecx
	push	OFFSET $SG143771
	call	_Con_LoadVariableWidthFont
	add	esp, 8
	jmp	SHORT $LN4@Con_LoadCo
$LN3@Con_LoadCo:

; 661  : 	else Con_LoadVariableWidthFont( va( "fonts.wad/font%i", fontNumber ), font );

	mov	edx, DWORD PTR _font$[ebp]
	push	edx
	mov	eax, DWORD PTR _fontNumber$[ebp]
	push	eax
	push	OFFSET $SG143772
	call	_va
	add	esp, 8
	push	eax
	call	_Con_LoadVariableWidthFont
	add	esp, 8
$LN4@Con_LoadCo:

; 662  : 
; 663  : 	// quake fixed font as fallback
; 664  : 	if( !font->valid ) Con_LoadFixedWidthFont( "gfx/conchars", font );

	mov	ecx, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [ecx+4364], 0
	jne	SHORT $LN1@Con_LoadCo
	mov	edx, DWORD PTR _font$[ebp]
	push	edx
	push	OFFSET $SG143774
	call	_Con_LoadFixedWidthFont
	add	esp, 8
$LN1@Con_LoadCo:

; 665  : }

	pop	ebp
	ret	0
_Con_LoadConsoleFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_length$ = -20						; size = 4
_fontWidth$ = -16					; size = 4
_buffer$ = -12						; size = 4
_src$ = -8						; size = 4
_i$ = -4						; size = 4
_fontname$ = 8						; size = 4
_font$ = 12						; size = 4
_Con_LoadVariableWidthFont PROC

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 604  : 	int	i, fontWidth;
; 605  : 	byte	*buffer;
; 606  : 	size_t	length;
; 607  : 	qfont_t	*src;
; 608  : 
; 609  : 	if( font->valid )

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN5@Con_LoadVa

; 610  : 		return true; // already loaded

	mov	eax, 1
	jmp	$LN1@Con_LoadVa
$LN5@Con_LoadVa:

; 611  : 
; 612  : 	if( !FS_FileExists( fontname, false ))

	push	0
	mov	ecx, DWORD PTR _fontname$[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@Con_LoadVa

; 613  : 		return false;

	xor	eax, eax
	jmp	$LN1@Con_LoadVa
$LN6@Con_LoadVa:

; 614  : 
; 615  : 	font->hFontTexture = GL_LoadTexture( fontname, NULL, 0, TF_FONT|TF_NEAREST );

	push	6145					; 00001801H
	push	0
	push	0
	mov	edx, DWORD PTR _fontname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx], eax

; 616  : 	R_GetTextureParms( &fontWidth, NULL, font->hFontTexture );

	mov	edx, DWORD PTR _font$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	lea	ecx, DWORD PTR _fontWidth$[ebp]
	push	ecx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 617  : 
; 618  : 	// setup consolefont
; 619  : 	if( font->hFontTexture && fontWidth != 0 )

	mov	edx, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN7@Con_LoadVa
	cmp	DWORD PTR _fontWidth$[ebp], 0
	je	$LN7@Con_LoadVa

; 620  : 	{
; 621  : 		// half-life font with variable chars witdh
; 622  : 		buffer = FS_LoadFile( fontname, &length, false );

	push	0
	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fontname$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer$[ebp], eax

; 623  : 
; 624  : 		if( buffer && length >= sizeof( qfont_t ))

	cmp	DWORD PTR _buffer$[ebp], 0
	je	$LN8@Con_LoadVa
	cmp	DWORD PTR _length$[ebp], 1044		; 00000414H
	jb	$LN8@Con_LoadVa

; 625  : 		{
; 626  : 			src = (qfont_t *)buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _src$[ebp], edx

; 627  : 			font->charHeight = src->rowheight;

	mov	eax, DWORD PTR _font$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4356], edx

; 628  : 			font->type = FONT_VARIABLE;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+4360], 1

; 629  : 
; 630  : 			// build rectangles
; 631  : 			for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_LoadVa
$LN2@Con_LoadVa:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Con_LoadVa:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@Con_LoadVa

; 632  : 			{
; 633  : 				font->fontRc[i].left = (word)src->fontinfo[i].startoffset % fontWidth;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [eax+edx*4+16]
	cdq
	idiv	DWORD PTR _fontWidth$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+ecx+4], edx

; 634  : 				font->fontRc[i].right = font->fontRc[i].left + src->fontinfo[i].charwidth;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	movsx	edx, WORD PTR [eax+edx*4+18]
	mov	eax, DWORD PTR _font$[ebp]
	add	edx, DWORD PTR [eax+ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+ecx+8], edx

; 635  : 				font->fontRc[i].top = (word)src->fontinfo[i].startoffset / fontWidth;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+16]
	cdq
	idiv	DWORD PTR _fontWidth$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+ecx+12], eax

; 636  : 				font->fontRc[i].bottom = font->fontRc[i].top + src->rowheight;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	eax, DWORD PTR _src$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+ecx+16], edx

; 637  : 				font->charWidths[i] = src->fontinfo[i].charwidth;

	mov	ecx, DWORD PTR _font$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	dl, BYTE PTR [eax+edx*4+18]
	mov	BYTE PTR [ecx+4100], dl

; 638  : 			}

	jmp	$LN2@Con_LoadVa
$LN3@Con_LoadVa:

; 639  : 			font->valid = true;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+4364], 1
$LN8@Con_LoadVa:

; 640  : 		}
; 641  : 		if( buffer ) Mem_Free( buffer );

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN7@Con_LoadVa
	push	641					; 00000281H
	push	OFFSET $SG143760
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@Con_LoadVa:

; 642  : 	}
; 643  : 
; 644  : 	return true;

	mov	eax, 1
$LN1@Con_LoadVa:

; 645  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadVariableWidthFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_fontWidth$ = -8					; size = 4
_i$ = -4						; size = 4
_fontname$ = 8						; size = 4
_font$ = 12						; size = 4
_Con_LoadFixedWidthFont PROC

; 569  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 570  : 	int	i, fontWidth;
; 571  : 
; 572  : 	if( font->valid )

	mov	eax, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN5@Con_LoadFi

; 573  : 		return true; // already loaded

	mov	eax, 1
	jmp	$LN1@Con_LoadFi
$LN5@Con_LoadFi:

; 574  : 
; 575  : 	if( !FS_FileExists( fontname, false ))

	push	0
	mov	ecx, DWORD PTR _fontname$[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@Con_LoadFi

; 576  : 		return false;

	xor	eax, eax
	jmp	$LN1@Con_LoadFi
$LN6@Con_LoadFi:

; 577  : 
; 578  : 	// keep source to print directly into conback image
; 579  : 	font->hFontTexture = GL_LoadTexture( fontname, NULL, 0, TF_FONT|TF_KEEP_SOURCE );

	push	6146					; 00001802H
	push	0
	push	0
	mov	edx, DWORD PTR _fontname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx], eax

; 580  : 	R_GetTextureParms( &fontWidth, NULL, font->hFontTexture );

	mov	edx, DWORD PTR _font$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	lea	ecx, DWORD PTR _fontWidth$[ebp]
	push	ecx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 581  : 
; 582  : 	if( font->hFontTexture && fontWidth != 0 )

	mov	edx, DWORD PTR _font$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN7@Con_LoadFi
	cmp	DWORD PTR _fontWidth$[ebp], 0
	je	$LN7@Con_LoadFi

; 583  : 	{
; 584  : 		font->charHeight = fontWidth / 16;

	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [ecx+4356], eax

; 585  : 		font->type = FONT_FIXED;

	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+4360], 0

; 586  : 
; 587  : 		// build fixed rectangles
; 588  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_LoadFi
$LN2@Con_LoadFi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_LoadFi:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@Con_LoadFi

; 589  : 		{
; 590  : 			font->fontRc[i].left = (i * (fontWidth / 16)) % fontWidth;

	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	imul	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _fontWidth$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+ecx+4], edx

; 591  : 			font->fontRc[i].right = font->fontRc[i].left + fontWidth / 16;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	edx, DWORD PTR _font$[ebp]
	add	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 592  : 			font->fontRc[i].top = (i / 16) * (fontWidth / 16);

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 4
	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	imul	ecx, eax
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR [eax+edx+12], ecx

; 593  : 			font->fontRc[i].bottom = font->fontRc[i].top + fontWidth / 16;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	edx, DWORD PTR _font$[ebp]
	add	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+ecx+16], eax

; 594  : 			font->charWidths[i] = fontWidth / 16;

	mov	eax, DWORD PTR _fontWidth$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _font$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+4100], al

; 595  : 		}

	jmp	$LN2@Con_LoadFi
$LN3@Con_LoadFi:

; 596  : 		font->valid = true;

	mov	edx, DWORD PTR _font$[ebp]
	mov	DWORD PTR [edx+4364], 1
$LN7@Con_LoadFi:

; 597  : 	}
; 598  : 
; 599  : 	return true;

	mov	eax, 1
$LN1@Con_LoadFi:

; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_LoadFixedWidthFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_Bottom PROC

; 542  : {

	push	ebp
	mov	ebp, esp

; 543  : 	con.backscroll = 0;

	mov	DWORD PTR _con+32, 0

; 544  : }

	pop	ebp
	ret	0
_Con_Bottom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_Top PROC

; 532  : {

	push	ebp
	mov	ebp, esp

; 533  : 	con.backscroll = CON_MAXLINES;

	mov	DWORD PTR _con+32, 16384		; 00004000H

; 534  : }

	pop	ebp
	ret	0
_Con_Top ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_lines$ = 8						; size = 4
_Con_PageDown PROC

; 522  : {

	push	ebp
	mov	ebp, esp

; 523  : 	con.backscroll -= abs( lines );

	mov	eax, DWORD PTR _lines$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	ecx, DWORD PTR _con+32
	sub	ecx, eax
	mov	DWORD PTR _con+32, ecx

; 524  : }

	pop	ebp
	ret	0
_Con_PageDown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_lines$ = 8						; size = 4
_Con_PageUp PROC

; 512  : {

	push	ebp
	mov	ebp, esp

; 513  : 	con.backscroll += abs( lines );

	mov	eax, DWORD PTR _lines$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	add	eax, DWORD PTR _con+32
	mov	DWORD PTR _con+32, eax

; 514  : }

	pop	ebp
	ret	0
_Con_PageUp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_charWidth$ = -12					; size = 4
_width$ = -8						; size = 4
_i$ = -4						; size = 4
_Con_CheckResize PROC

; 483  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 484  : 	int	charWidth = 8;

	mov	DWORD PTR _charWidth$[ebp], 8

; 485  : 	int	i, width;
; 486  : 
; 487  : 	if( con.curFont && con.curFont->hFontTexture )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN5@Con_CheckR
	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Con_CheckR

; 488  : 		charWidth = con.curFont->charWidths['O'] - 1;

	mov	ecx, 1
	imul	edx, ecx, 79
	mov	eax, DWORD PTR _con+13156
	movzx	ecx, BYTE PTR [eax+edx+4100]
	sub	ecx, 1
	mov	DWORD PTR _charWidth$[ebp], ecx
$LN5@Con_CheckR:

; 489  : 
; 490  : 	width = ( glState.width / charWidth ) - 2;

	mov	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _charWidth$[ebp]
	sub	eax, 2
	mov	DWORD PTR _width$[ebp], eax

; 491  : 	if( !glw_state.initialized ) width = (640 / 5);

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN6@Con_CheckR
	mov	DWORD PTR _width$[ebp], 128		; 00000080H
$LN6@Con_CheckR:

; 492  : 
; 493  : 	if( width == con.linewidth )

	mov	edx, DWORD PTR _width$[ebp]
	cmp	edx, DWORD PTR _con+36
	jne	SHORT $LN7@Con_CheckR

; 494  : 		return;

	jmp	SHORT $LN1@Con_CheckR
$LN7@Con_CheckR:

; 495  : 
; 496  : 	Con_ClearNotify();

	call	_Con_ClearNotify

; 497  : 	con.linewidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _con+36, eax

; 498  : 	con.backscroll = 0;

	mov	DWORD PTR _con+32, 0

; 499  : 
; 500  : 	con.input.widthInChars = con.linewidth;

	mov	ecx, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, ecx

; 501  : 
; 502  : 	for( i = 0; i < CON_HISTORY; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_CheckR
$LN2@Con_CheckR:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Con_CheckR:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN1@Con_CheckR

; 503  : 		con.historyLines[i].widthInChars = con.linewidth;

	imul	eax, DWORD PTR _i$[ebp], 268
	mov	ecx, DWORD PTR _con+36
	mov	DWORD PTR _con[eax+14220], ecx
	jmp	SHORT $LN2@Con_CheckR
$LN1@Con_CheckR:

; 504  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_CheckResize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_putpos$ = -8						; size = 4
_p$ = -4						; size = 4
_line$ = 8						; size = 4
_length$ = 12						; size = 4
_newline$ = 16						; size = 4
_Con_AddLine PROC

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 438  : 	byte		*putpos;
; 439  : 	con_lineinfo_t	*p;
; 440  : 
; 441  : 	if( !con.initialized || !con.buffer )

	cmp	DWORD PTR _con, 0
	je	SHORT $LN5@Con_AddLin
	cmp	DWORD PTR _con+4, 0
	jne	SHORT $LN4@Con_AddLin
$LN5@Con_AddLin:

; 442  : 		return;

	jmp	$LN9@Con_AddLin
$LN4@Con_AddLin:

; 443  : 
; 444  : 	Con_FixTimes();

	call	_Con_FixTimes

; 445  : 	length++;	// reserve space for term

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 446  : 
; 447  : 	ASSERT( length < CON_TEXTSIZE );

	cmp	DWORD PTR _length$[ebp], 1048576	; 00100000H
	jl	SHORT $LN6@Con_AddLin
	push	447					; 000001bfH
	push	OFFSET $SG143683
	push	OFFSET $SG143684
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN6@Con_AddLin:

; 448  : 
; 449  : 	while( !( putpos = Con_BytesLeft( length )) || con.lines_count >= con.maxlines )

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	call	_Con_BytesLeft
	add	esp, 4
	mov	DWORD PTR _putpos$[ebp], eax
	cmp	DWORD PTR _putpos$[ebp], 0
	je	SHORT $LN7@Con_AddLin
	mov	edx, DWORD PTR _con+24
	cmp	edx, DWORD PTR _con+16
	jl	SHORT $LN3@Con_AddLin
$LN7@Con_AddLin:

; 450  : 		Con_DeleteLine();

	call	_Con_DeleteLine
	jmp	SHORT $LN6@Con_AddLin
$LN3@Con_AddLin:

; 451  : 
; 452  : 	if( newline )

	cmp	DWORD PTR _newline$[ebp], 0
	je	SHORT $LN8@Con_AddLin

; 453  : 	{
; 454  : 		memcpy( putpos, line, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _putpos$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 455  : 		putpos[length - 1] = '\0';

	mov	eax, DWORD PTR _putpos$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR [eax-1], 0

; 456  : 		con.lines_count++;

	mov	ecx, DWORD PTR _con+24
	add	ecx, 1
	mov	DWORD PTR _con+24, ecx

; 457  : 
; 458  : 		p = &CON_LINES_LAST();

	mov	edx, DWORD PTR _con+24
	mov	eax, DWORD PTR _con+20
	lea	eax, DWORD PTR [eax+edx-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _p$[ebp], edx

; 459  : 		p->start = putpos;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _putpos$[ebp]
	mov	DWORD PTR [ecx], edx

; 460  : 		p->length = length;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 461  : 		p->addtime = cl.time;

	mov	edx, DWORD PTR _p$[ebp]
	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR [edx+8], xmm0

; 462  : 	}

	jmp	$LN9@Con_AddLin
$LN8@Con_AddLin:

; 463  : 	else
; 464  : 	{
; 465  : 		p = &CON_LINES_LAST();

	mov	eax, DWORD PTR _con+24
	mov	ecx, DWORD PTR _con+20
	lea	eax, DWORD PTR [ecx+eax-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	add	edx, DWORD PTR _con+12
	mov	DWORD PTR _p$[ebp], edx

; 466  : 		putpos = p->start + Q_strlen( p->start );

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _putpos$[ebp], eax

; 467  : 		memcpy( putpos, line, length - 1 );

	mov	edx, DWORD PTR _length$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _putpos$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 468  : 		p->length = Q_strlen( p->start );

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 469  : 		putpos[p->length] = '\0';

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _putpos$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 470  : 		p->addtime = cl.time;

	mov	edx, DWORD PTR _p$[ebp]
	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR [edx+8], xmm0

; 471  : 		p->length++;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN9@Con_AddLin:

; 472  : 	}
; 473  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_AddLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_firstline_start$1 = -8					; size = 4
_lastline_onepastend$2 = -4				; size = 4
_length$ = 8						; size = 4
_Con_BytesLeft PROC

; 393  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 394  : 	if( length > con.bufsize )

	mov	eax, DWORD PTR _length$[ebp]
	cmp	eax, DWORD PTR _con+8
	jle	SHORT $LN2@Con_BytesL

; 395  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Con_BytesL
$LN2@Con_BytesL:

; 396  : 
; 397  : 	if( con.lines_count == 0 )

	cmp	DWORD PTR _con+24, 0
	jne	SHORT $LN3@Con_BytesL

; 398  : 	{
; 399  : 		return con.buffer;

	mov	eax, DWORD PTR _con+4
	jmp	$LN1@Con_BytesL

; 400  : 	}

	jmp	$LN1@Con_BytesL
$LN3@Con_BytesL:

; 401  : 	else
; 402  : 	{
; 403  : 		char	*firstline_start = con.lines[con.lines_first].start;

	mov	ecx, DWORD PTR _con+20
	shl	ecx, 4
	mov	edx, DWORD PTR _con+12
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _firstline_start$1[ebp], eax

; 404  : 		char	*lastline_onepastend = CON_LINES_LAST().start + CON_LINES_LAST().length;

	mov	ecx, DWORD PTR _con+24
	mov	edx, DWORD PTR _con+20
	lea	eax, DWORD PTR [edx+ecx-1]
	cdq
	idiv	DWORD PTR _con+16
	mov	ecx, edx
	shl	ecx, 4
	mov	edx, DWORD PTR _con+24
	mov	eax, DWORD PTR _con+20
	lea	eax, DWORD PTR [eax+edx-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	mov	ecx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _con+12
	add	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _lastline_onepastend$2[ebp], ecx

; 405  : 
; 406  : 		// the buffer is cyclic, so we first have two cases...
; 407  : 		if( firstline_start < lastline_onepastend ) // buffer is contiguous

	mov	ecx, DWORD PTR _firstline_start$1[ebp]
	cmp	ecx, DWORD PTR _lastline_onepastend$2[ebp]
	jae	SHORT $LN5@Con_BytesL

; 408  : 		{
; 409  : 			// put at end?
; 410  : 			if( length <= con.buffer + con.bufsize - lastline_onepastend )

	mov	edx, DWORD PTR _con+4
	add	edx, DWORD PTR _con+8
	sub	edx, DWORD PTR _lastline_onepastend$2[ebp]
	cmp	DWORD PTR _length$[ebp], edx
	jg	SHORT $LN7@Con_BytesL

; 411  : 				return lastline_onepastend;

	mov	eax, DWORD PTR _lastline_onepastend$2[ebp]
	jmp	SHORT $LN1@Con_BytesL
	jmp	SHORT $LN8@Con_BytesL
$LN7@Con_BytesL:

; 412  : 			// put at beginning?
; 413  : 			else if( length <= firstline_start - con.buffer )

	mov	eax, DWORD PTR _firstline_start$1[ebp]
	sub	eax, DWORD PTR _con+4
	cmp	DWORD PTR _length$[ebp], eax
	jg	SHORT $LN8@Con_BytesL

; 414  : 				return con.buffer;

	mov	eax, DWORD PTR _con+4
	jmp	SHORT $LN1@Con_BytesL
$LN8@Con_BytesL:

; 415  : 
; 416  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Con_BytesL

; 417  : 		}

	jmp	SHORT $LN1@Con_BytesL
$LN5@Con_BytesL:

; 418  : 		else
; 419  : 		{
; 420  : 			// buffer has a contiguous hole
; 421  : 			if( length <= firstline_start - lastline_onepastend )

	mov	ecx, DWORD PTR _firstline_start$1[ebp]
	sub	ecx, DWORD PTR _lastline_onepastend$2[ebp]
	cmp	DWORD PTR _length$[ebp], ecx
	jg	SHORT $LN10@Con_BytesL

; 422  : 				return lastline_onepastend;

	mov	eax, DWORD PTR _lastline_onepastend$2[ebp]
	jmp	SHORT $LN1@Con_BytesL
$LN10@Con_BytesL:

; 423  : 
; 424  : 			return NULL;

	xor	eax, eax
$LN1@Con_BytesL:

; 425  : 		}
; 426  : 	}
; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_BytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_DeleteLastLine PROC

; 378  : {

	push	ebp
	mov	ebp, esp

; 379  : 	if( con.lines_count == 0 )

	cmp	DWORD PTR _con+24, 0
	jne	SHORT $LN2@Con_Delete

; 380  : 		return;

	jmp	SHORT $LN1@Con_Delete
$LN2@Con_Delete:

; 381  : 	con.lines_count--;

	mov	eax, DWORD PTR _con+24
	sub	eax, 1
	mov	DWORD PTR _con+24, eax
$LN1@Con_Delete:

; 382  : }

	pop	ebp
	ret	0
_Con_DeleteLastLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_DeleteLine PROC

; 363  : {

	push	ebp
	mov	ebp, esp

; 364  : 	if( con.lines_count == 0 )

	cmp	DWORD PTR _con+24, 0
	jne	SHORT $LN2@Con_Delete

; 365  : 		return;

	jmp	SHORT $LN1@Con_Delete
$LN2@Con_Delete:

; 366  : 	con.lines_count--;

	mov	eax, DWORD PTR _con+24
	sub	eax, 1
	mov	DWORD PTR _con+24, eax

; 367  : 	con.lines_first = (con.lines_first + 1) % con.maxlines;

	mov	eax, DWORD PTR _con+20
	add	eax, 1
	cdq
	idiv	DWORD PTR _con+16
	mov	DWORD PTR _con+20, edx
$LN1@Con_Delete:

; 368  : }

	pop	ebp
	ret	0
_Con_DeleteLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_diff$ = -12						; size = 8
_i$ = -4						; size = 4
_Con_FixTimes PROC

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 343  : 	double	diff;
; 344  : 	int	i;
; 345  : 
; 346  : 	if( con.lines_count <= 0 ) return;

	cmp	DWORD PTR _con+24, 0
	jg	SHORT $LN5@Con_FixTim
	jmp	$LN3@Con_FixTim
$LN5@Con_FixTim:

; 347  : 
; 348  : 	diff = cl.time - CON_LINES_LAST().addtime;

	mov	eax, DWORD PTR _con+24
	mov	ecx, DWORD PTR _con+20
	lea	eax, DWORD PTR [ecx+eax-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR [eax+edx+8]
	movsd	QWORD PTR _diff$[ebp], xmm0

; 349  : 	if( diff >= 0.0 ) return; // nothing to fix

	movsd	xmm0, QWORD PTR _diff$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN6@Con_FixTim
	jmp	SHORT $LN3@Con_FixTim
$LN6@Con_FixTim:

; 350  : 
; 351  : 	for( i = 0; i < con.lines_count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_FixTim
$LN2@Con_FixTim:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Con_FixTim:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _con+24
	jge	SHORT $LN3@Con_FixTim

; 352  : 		CON_LINES( i ).addtime += diff;

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	movsd	xmm0, QWORD PTR [eax+edx+8]
	addsd	xmm0, QWORD PTR _diff$[ebp]
	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	ecx, DWORD PTR _con+12
	movsd	QWORD PTR [ecx+edx+8], xmm0
	jmp	SHORT $LN2@Con_FixTim
$LN3@Con_FixTim:

; 353  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_FixTimes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv73 = -8						; size = 4
_newtimes$ = -4						; size = 4
_Con_SetTimes_f PROC

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 320  : 	int	newtimes;
; 321  : 
; 322  : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@Con_SetTim

; 323  : 	{
; 324  : 		Con_Printf( S_USAGE "contimes <n lines>\n" );

	push	OFFSET $SG143631
	call	_Con_Printf
	add	esp, 4

; 325  : 		return;

	jmp	SHORT $LN1@Con_SetTim
$LN2@Con_SetTim:

; 326  : 	}
; 327  : 
; 328  : 	newtimes = Q_atoi( Cmd_Argv( 1 ) );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _newtimes$[ebp], eax

; 329  : 	con.num_times = bound( CON_TIMES, newtimes, CON_MAX_TIMES );

	cmp	DWORD PTR _newtimes$[ebp], 4
	jl	SHORT $LN6@Con_SetTim
	cmp	DWORD PTR _newtimes$[ebp], 64		; 00000040H
	jge	SHORT $LN4@Con_SetTim
	mov	eax, DWORD PTR _newtimes$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN5@Con_SetTim
$LN4@Con_SetTim:
	mov	DWORD PTR tv73[ebp], 64			; 00000040H
$LN5@Con_SetTim:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN7@Con_SetTim
$LN6@Con_SetTim:
	mov	DWORD PTR tv74[ebp], 4
$LN7@Con_SetTim:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _con+28, edx
$LN1@Con_SetTim:

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SetTimes_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_MessageMode2_f PROC

; 278  : {

	push	ebp
	mov	ebp, esp

; 279  : 	Q_strncpy( con.chat_cmd, "say_team", sizeof( con.chat_cmd ));

	push	256					; 00000100H
	push	OFFSET $SG143612
	push	OFFSET _con+13700
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 280  : 	Key_SetKeyDest( key_message );

	push	3
	call	_Key_SetKeyDest
	add	esp, 4

; 281  : }

	pop	ebp
	ret	0
_Con_MessageMode2_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_MessageMode_f PROC

; 264  : {

	push	ebp
	mov	ebp, esp

; 265  : 	if( Cmd_Argc() == 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jne	SHORT $LN2@Con_Messag

; 266  : 		Q_strncpy( con.chat_cmd, Cmd_Argv( 1 ), sizeof( con.chat_cmd ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET _con+13700
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@Con_Messag
$LN2@Con_Messag:

; 267  : 	else Q_strncpy( con.chat_cmd, "say", sizeof( con.chat_cmd ));

	push	256					; 00000100H
	push	OFFSET $SG143608
	push	OFFSET _con+13700
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN3@Con_Messag:

; 268  : 
; 269  : 	Key_SetKeyDest( key_message );

	push	3
	call	_Key_SetKeyDest
	add	esp, 4

; 270  : }

	pop	ebp
	ret	0
_Con_MessageMode_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_len$ = -8						; size = 4
_p$ = -4						; size = 4
_string$ = 8						; size = 4
_Con_StringLength PROC

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 236  : 	int		len;
; 237  : 	const char	*p;
; 238  : 
; 239  : 	if( !string ) return 0;

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@Con_String
	xor	eax, eax
	jmp	SHORT $LN1@Con_String
$LN4@Con_String:

; 240  : 
; 241  : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 242  : 	p = string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@Con_String:

; 243  : 
; 244  : 	while( *p )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Con_String

; 245  : 	{
; 246  : 		if( IsColorString( p ))

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN5@Con_String
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN5@Con_String
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	test	eax, eax
	je	SHORT $LN5@Con_String
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN5@Con_String
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN5@Con_String

; 247  : 		{
; 248  : 			p += 2;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 2
	mov	DWORD PTR _p$[ebp], edx

; 249  : 			continue;

	jmp	SHORT $LN2@Con_String
$LN5@Con_String:

; 250  : 		}
; 251  : 		len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 252  : 		p++;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 253  : 	}

	jmp	SHORT $LN2@Con_String
$LN3@Con_String:

; 254  : 
; 255  : 	return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@Con_String:

; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_StringLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Con_ClearTyping PROC

; 212  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 213  : 	int	i;
; 214  : 
; 215  : 	Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 216  : 	con.input.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, eax

; 217  : 
; 218  : 	// free the old autocomplete list
; 219  : 	for( i = 0; i < con.matchCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_ClearT
$LN2@Con_ClearT:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Con_ClearT:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _con+82076
	jge	SHORT $LN3@Con_ClearT

; 220  : 	{
; 221  : 		freestring( con.cmds[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _con[eax*4+65692], 0
	je	SHORT $LN5@Con_ClearT
	push	221					; 000000ddH
	push	OFFSET $SG143592
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _con[ecx*4+65692]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _con[eax*4+65692], 0
$LN5@Con_ClearT:

; 222  : 	}

	jmp	SHORT $LN2@Con_ClearT
$LN3@Con_ClearT:

; 223  : 
; 224  : 	con.matchCount = 0;

	mov	DWORD PTR _con+82076, 0

; 225  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ClearTyping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_edit$ = 8						; size = 4
_Con_ClearField PROC

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  : 	memset( edit->buffer, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 202  : 	edit->cursor = 0;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [ecx+256], 0

; 203  : 	edit->scroll = 0;

	mov	edx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [edx+260], 0

; 204  : }

	pop	ebp
	ret	0
_Con_ClearField ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv178 = -28						; size = 4
tv140 = -24						; size = 4
tv65 = -20						; size = 4
_color$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_Con_SetColor_f PROC

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 159  : 	vec3_t	color;
; 160  : 
; 161  : 	switch( Cmd_Argc( ))

	call	_Cmd_Argc
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN4@Con_SetCol
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN5@Con_SetCol
	cmp	DWORD PTR tv65[ebp], 4
	je	$LN6@Con_SetCol
	jmp	$LN7@Con_SetCol
$LN4@Con_SetCol:

; 162  : 	{
; 163  : 	case 1:
; 164  : 		Con_Printf( "\"con_color\" is %i %i %i\n", g_color_table[7][0], g_color_table[7][1], g_color_table[7][2] );

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR _g_color_table[ecx+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _g_color_table[edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR _g_color_table[eax+edx]
	push	eax
	push	OFFSET $SG143567
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 165  : 		break;

	jmp	$LN2@Con_SetCol
$LN5@Con_SetCol:

; 166  : 	case 2:
; 167  : 		VectorSet( color, g_color_table[7][0], g_color_table[7][1], g_color_table[7][2] );

	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movzx	ecx, BYTE PTR _g_color_table[edx+ecx]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _color$[ebp+eax], xmm0
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movzx	eax, BYTE PTR _g_color_table[eax+ecx]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _color$[ebp+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR _g_color_table[edx+eax]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR tv140[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _color$[ebp+edx], xmm0

; 168  : 		Q_atov( color, Cmd_Argv( 1 ), 3 );

	push	3
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_Q_atov
	add	esp, 12					; 0000000cH

; 169  : 		Con_DefaultColor( color[0], color[1], color[2] );

	mov	ecx, 4
	shl	ecx, 1
	cvttss2si edx, DWORD PTR _color$[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	cvttss2si ecx, DWORD PTR _color$[ebp+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	cvttss2si ecx, DWORD PTR _color$[ebp+eax]
	push	ecx
	call	_Con_DefaultColor
	add	esp, 12					; 0000000cH

; 170  : 		break;

	jmp	$LN2@Con_SetCol
$LN6@Con_SetCol:

; 171  : 	case 4:
; 172  : 		VectorSet( color, Q_atof( Cmd_Argv( 1 )), Q_atof( Cmd_Argv( 2 )), Q_atof( Cmd_Argv( 3 )));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _color$[ebp+eax]
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _color$[ebp+ecx]
	push	3
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv178[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR _color$[ebp+edx], xmm0

; 173  : 		Con_DefaultColor( color[0], color[1], color[2] );

	mov	eax, 4
	shl	eax, 1
	cvttss2si ecx, DWORD PTR _color$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	cvttss2si eax, DWORD PTR _color$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	cvttss2si eax, DWORD PTR _color$[ebp+edx]
	push	eax
	call	_Con_DefaultColor
	add	esp, 12					; 0000000cH

; 174  : 		break;

	jmp	SHORT $LN2@Con_SetCol
$LN7@Con_SetCol:

; 175  : 	default:
; 176  : 		Con_Printf( S_USAGE "con_color \"r g b\"\n" );

	push	OFFSET $SG143571
	call	_Con_Printf
	add	esp, 4
$LN2@Con_SetCol:

; 177  : 		break;
; 178  : 	}
; 179  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SetColor_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_Clear_f PROC

; 147  : {

	push	ebp
	mov	ebp, esp

; 148  : 	con.lines_count = 0;

	mov	DWORD PTR _con+24, 0

; 149  : 	con.backscroll = 0; // go to end

	mov	DWORD PTR _con+32, 0

; 150  : }

	pop	ebp
	ret	0
_Con_Clear_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_len$ = -4						; size = 4
_edit$ = 8						; size = 4
_ch$ = 12						; size = 4
_Field_CharEvent PROC

; 1624 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1625 : 	int	len;
; 1626 : 
; 1627 : 	if( ch == 'v' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 22			; 00000016H
	jne	SHORT $LN2@Field_Char

; 1628 : 	{
; 1629 : 		// ctrl-v is paste
; 1630 : 		Field_Paste( edit );

	mov	eax, DWORD PTR _edit$[ebp]
	push	eax
	call	_Field_Paste
	add	esp, 4

; 1631 : 		return;

	jmp	$LN1@Field_Char
$LN2@Field_Char:

; 1632 : 	}
; 1633 : 
; 1634 : 	if( ch == 'c' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 3
	jne	SHORT $LN3@Field_Char

; 1635 : 	{
; 1636 : 		// ctrl-c clears the field
; 1637 : 		Con_ClearField( edit );

	mov	ecx, DWORD PTR _edit$[ebp]
	push	ecx
	call	_Con_ClearField
	add	esp, 4

; 1638 : 		return;

	jmp	$LN1@Field_Char
$LN3@Field_Char:

; 1639 : 	}
; 1640 : 
; 1641 : 	len = Q_strlen( edit->buffer );

	mov	edx, DWORD PTR _edit$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1642 : 
; 1643 : 	if( ch == 'a' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 1
	jne	SHORT $LN4@Field_Char

; 1644 : 	{
; 1645 : 		// ctrl-a is home
; 1646 : 		edit->cursor = 0;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], 0

; 1647 : 		edit->scroll = 0;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [ecx+260], 0

; 1648 : 		return;

	jmp	$LN1@Field_Char
$LN4@Field_Char:

; 1649 : 	}
; 1650 : 
; 1651 : 	if( ch == 'e' - 'a' + 1 )

	cmp	DWORD PTR _ch$[ebp], 5
	jne	SHORT $LN5@Field_Char

; 1652 : 	{
; 1653 : 		// ctrl-e is end
; 1654 : 		edit->cursor = len;

	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx+256], eax

; 1655 : 		edit->scroll = edit->cursor - edit->widthInChars;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [ecx+256]
	sub	eax, DWORD PTR [edx+264]
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 1656 : 		return;

	jmp	$LN1@Field_Char
$LN5@Field_Char:

; 1657 : 	}
; 1658 : 
; 1659 : 	// ignore any other non printable chars
; 1660 : 	if( ch < 32 ) return;

	cmp	DWORD PTR _ch$[ebp], 32			; 00000020H
	jge	SHORT $LN6@Field_Char
	jmp	$LN1@Field_Char
$LN6@Field_Char:

; 1661 : 
; 1662 : 	if( host.key_overstrike )

	cmp	DWORD PTR _host+34344, 0
	je	SHORT $LN7@Field_Char

; 1663 : 	{	
; 1664 : 		if ( edit->cursor == MAX_STRING - 1 ) return;

	mov	edx, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [edx+256], 255		; 000000ffH
	jne	SHORT $LN9@Field_Char
	jmp	$LN1@Field_Char
$LN9@Field_Char:

; 1665 : 		edit->buffer[edit->cursor] = ch;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1666 : 		edit->cursor++;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	add	edx, 1
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], edx

; 1667 : 	}

	jmp	SHORT $LN8@Field_Char
$LN7@Field_Char:

; 1668 : 	else
; 1669 : 	{
; 1670 : 		// insert mode
; 1671 : 		if ( len == MAX_STRING - 1 ) return; // all full

	cmp	DWORD PTR _len$[ebp], 255		; 000000ffH
	jne	SHORT $LN10@Field_Char
	jmp	$LN1@Field_Char
$LN10@Field_Char:

; 1672 : 		memmove( edit->buffer + edit->cursor + 1, edit->buffer + edit->cursor, len + 1 - edit->cursor );

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	sub	ecx, DWORD PTR [edx+256]
	push	ecx
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR _edit$[ebp]
	add	ecx, DWORD PTR [eax+256]
	push	ecx
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [edx+256]
	mov	ecx, DWORD PTR _edit$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1673 : 		edit->buffer[edit->cursor] = ch;

	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1674 : 		edit->cursor++;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	add	edx, 1
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+256], edx
$LN8@Field_Char:

; 1675 : 	}
; 1676 : 
; 1677 : 	if( edit->cursor >= edit->widthInChars ) edit->scroll++;

	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	eax, DWORD PTR [ecx+256]
	cmp	eax, DWORD PTR [edx+264]
	jl	SHORT $LN11@Field_Char
	mov	ecx, DWORD PTR _edit$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	add	edx, 1
	mov	eax, DWORD PTR _edit$[ebp]
	mov	DWORD PTR [eax+260], edx
$LN11@Field_Char:

; 1678 : 	if( edit->cursor == len + 1 ) edit->buffer[edit->cursor] = 0;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _edit$[ebp]
	cmp	DWORD PTR [edx+256], ecx
	jne	SHORT $LN1@Field_Char
	mov	eax, DWORD PTR _edit$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR _edit$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN1@Field_Char:

; 1679 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Field_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_FastClose PROC

; 2513 : {

	push	ebp
	mov	ebp, esp

; 2514 : 	Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 2515 : 	Con_ClearNotify();

	call	_Con_ClearNotify

; 2516 : 	con.showlines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0

; 2517 : 	con.vislines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+44, xmm0

; 2518 : }

	pop	ebp
	ret	0
_Con_FastClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_buffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_Key_Message PROC

; 1893 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1028				; 00000404H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1894 : 	char	buffer[MAX_SYSPATH];
; 1895 : 
; 1896 : 	if( key == K_ESCAPE )

	cmp	DWORD PTR _key$[ebp], 27		; 0000001bH
	jne	SHORT $LN2@Key_Messag

; 1897 : 	{
; 1898 : 		Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4

; 1899 : 		Con_ClearField( &con.chat );

	push	OFFSET _con+13432
	call	_Con_ClearField
	add	esp, 4

; 1900 : 		return;

	jmp	$LN1@Key_Messag
$LN2@Key_Messag:

; 1901 : 	}
; 1902 : 
; 1903 : 	if( key == K_ENTER || key == K_KP_ENTER )

	cmp	DWORD PTR _key$[ebp], 13		; 0000000dH
	je	SHORT $LN4@Key_Messag
	cmp	DWORD PTR _key$[ebp], 169		; 000000a9H
	jne	SHORT $LN3@Key_Messag
$LN4@Key_Messag:

; 1904 : 	{
; 1905 : 		if( con.chat.buffer[0] && cls.state == ca_active )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13432]
	test	edx, edx
	je	SHORT $LN5@Key_Messag
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN5@Key_Messag

; 1906 : 		{
; 1907 : 			Q_snprintf( buffer, sizeof( buffer ), "%s \"%s\"\n", con.chat_cmd, con.chat.buffer );

	push	OFFSET _con+13432
	push	OFFSET _con+13700
	push	OFFSET $SG144374
	push	1024					; 00000400H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1908 : 			Cbuf_AddText( buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Cbuf_AddText
	add	esp, 4
$LN5@Key_Messag:

; 1909 : 		}
; 1910 : 
; 1911 : 		Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4

; 1912 : 		Con_ClearField( &con.chat );

	push	OFFSET _con+13432
	call	_Con_ClearField
	add	esp, 4

; 1913 : 		return;

	jmp	SHORT $LN1@Key_Messag
$LN3@Key_Messag:

; 1914 : 	}
; 1915 : 
; 1916 : 	Field_KeyDownEvent( &con.chat, key );

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	push	OFFSET _con+13432
	call	_Field_KeyDownEvent
	add	esp, 8
$LN1@Key_Messag:

; 1917 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_temp$1 = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_Key_Console PROC

; 1766 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1028				; 00000404H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1767 : 	// ctrl-L clears screen
; 1768 : 	if( key == 'l' && Key_IsDown( K_CTRL ))

	cmp	DWORD PTR _key$[ebp], 108		; 0000006cH
	jne	SHORT $LN2@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Key_Consol

; 1769 : 	{
; 1770 : 		Cbuf_AddText( "clear\n" );

	push	OFFSET $SG144336
	call	_Cbuf_AddText
	add	esp, 4

; 1771 : 		return;

	jmp	$LN1@Key_Consol
$LN2@Key_Consol:

; 1772 : 	}
; 1773 : 
; 1774 : 	// enter finishes the line
; 1775 : 	if( key == K_ENTER || key == K_KP_ENTER )

	cmp	DWORD PTR _key$[ebp], 13		; 0000000dH
	je	SHORT $LN4@Key_Consol
	cmp	DWORD PTR _key$[ebp], 169		; 000000a9H
	jne	$LN3@Key_Consol
$LN4@Key_Consol:

; 1776 : 	{
; 1777 : 		// if not in the game explicitly prepent a slash if needed
; 1778 : 		if( cls.state != ca_active && con.input.buffer[0] != '\\' && con.input.buffer[0] != '/' )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN5@Key_Consol
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN5@Key_Consol
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN5@Key_Consol

; 1779 : 		{
; 1780 : 			char	temp[MAX_SYSPATH];
; 1781 : 
; 1782 : 			Q_strncpy( temp, con.input.buffer, sizeof( temp ));

	push	1024					; 00000400H
	push	OFFSET _con+13164
	lea	eax, DWORD PTR _temp$1[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1783 : 			Q_sprintf( con.input.buffer, "\\%s", temp );

	lea	ecx, DWORD PTR _temp$1[ebp]
	push	ecx
	push	OFFSET $SG144340
	push	OFFSET _con+13164
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1784 : 			con.input.cursor++;

	mov	edx, DWORD PTR _con+13420
	add	edx, 1
	mov	DWORD PTR _con+13420, edx
$LN5@Key_Consol:

; 1785 : 		}
; 1786 : 
; 1787 : 		// backslash text are commands, else chat
; 1788 : 		if( con.input.buffer[0] == '\\' || con.input.buffer[0] == '/' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN8@Key_Consol
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _con[ecx+13164]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN6@Key_Consol
$LN8@Key_Consol:

; 1789 : 			Cbuf_AddText( con.input.buffer + 1 ); // skip backslash

	push	OFFSET _con+13165
	call	_Cbuf_AddText
	add	esp, 4
	jmp	SHORT $LN7@Key_Consol
$LN6@Key_Consol:

; 1790 : 		else Cbuf_AddText( con.input.buffer ); // valid command

	push	OFFSET _con+13164
	call	_Cbuf_AddText
	add	esp, 4
$LN7@Key_Consol:

; 1791 : 		Cbuf_AddText( "\n" );

	push	OFFSET $SG144344
	call	_Cbuf_AddText
	add	esp, 4

; 1792 : 
; 1793 : 		// echo to console
; 1794 : 		Con_Printf( ">%s\n", con.input.buffer );

	push	OFFSET _con+13164
	push	OFFSET $SG144345
	call	_Con_Printf
	add	esp, 8

; 1795 : 
; 1796 : 		// copy line to history buffer
; 1797 : 		con.historyLines[con.nextHistoryLine % CON_HISTORY] = con.input;

	mov	eax, DWORD PTR _con+31112
	and	eax, -2147483585			; 8000003fH
	jns	SHORT $LN30@Key_Consol
	dec	eax
	or	eax, -64				; ffffffc0H
	inc	eax
$LN30@Key_Consol:
	imul	edi, eax, 268
	add	edi, OFFSET _con+13956
	mov	ecx, 67					; 00000043H
	mov	esi, OFFSET _con+13164
	rep movsd

; 1798 : 		con.nextHistoryLine++;

	mov	ecx, DWORD PTR _con+31112
	add	ecx, 1
	mov	DWORD PTR _con+31112, ecx

; 1799 : 		con.historyLine = con.nextHistoryLine;

	mov	edx, DWORD PTR _con+31112
	mov	DWORD PTR _con+31108, edx

; 1800 : 
; 1801 : 		Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 1802 : 		con.input.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, eax

; 1803 : 		Con_Bottom();

	call	_Con_Bottom

; 1804 : 
; 1805 : 		if( cls.state == ca_disconnected )

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN9@Key_Consol

; 1806 : 		{
; 1807 : 			// force an update, because the command may take some time
; 1808 : 			SCR_UpdateScreen ();

	call	_SCR_UpdateScreen
$LN9@Key_Consol:

; 1809 : 		}
; 1810 : 		return;

	jmp	$LN1@Key_Consol
$LN3@Key_Consol:

; 1811 : 	}
; 1812 : 
; 1813 : 	// command completion
; 1814 : 	if( key == K_TAB )

	cmp	DWORD PTR _key$[ebp], 9
	jne	SHORT $LN10@Key_Consol

; 1815 : 	{
; 1816 : 		Con_CompleteCommand( &con.input );

	push	OFFSET _con+13164
	call	_Con_CompleteCommand
	add	esp, 4

; 1817 : 		Con_Bottom();

	call	_Con_Bottom

; 1818 : 		return;

	jmp	$LN1@Key_Consol
$LN10@Key_Consol:

; 1819 : 	}
; 1820 : 
; 1821 : 	// command history (ctrl-p ctrl-n for unix style)
; 1822 : 	if(( key == K_MWHEELUP && Key_IsDown( K_SHIFT )) || ( key == K_UPARROW ) || (( Q_tolower(key) == 'p' ) && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 240		; 000000f0H
	jne	SHORT $LN13@Key_Consol
	push	134					; 00000086H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@Key_Consol
$LN13@Key_Consol:
	cmp	DWORD PTR _key$[ebp], 128		; 00000080H
	je	SHORT $LN12@Key_Consol
	movzx	ecx, BYTE PTR _key$[ebp]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	cmp	edx, 112				; 00000070H
	jne	SHORT $LN11@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@Key_Consol
$LN12@Key_Consol:

; 1823 : 	{
; 1824 : 		if( con.nextHistoryLine - con.historyLine < CON_HISTORY && con.historyLine > 0 )

	mov	eax, DWORD PTR _con+31112
	sub	eax, DWORD PTR _con+31108
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN14@Key_Consol
	cmp	DWORD PTR _con+31108, 0
	jle	SHORT $LN14@Key_Consol

; 1825 : 			con.historyLine--;

	mov	ecx, DWORD PTR _con+31108
	sub	ecx, 1
	mov	DWORD PTR _con+31108, ecx
$LN14@Key_Consol:

; 1826 : 		con.input = con.historyLines[con.historyLine % CON_HISTORY];

	mov	edx, DWORD PTR _con+31108
	and	edx, -2147483585			; 8000003fH
	jns	SHORT $LN31@Key_Consol
	dec	edx
	or	edx, -64				; ffffffc0H
	inc	edx
$LN31@Key_Consol:
	imul	esi, edx, 268
	add	esi, OFFSET _con+13956
	mov	ecx, 67					; 00000043H
	mov	edi, OFFSET _con+13164
	rep movsd

; 1827 : 		return;

	jmp	$LN1@Key_Consol
$LN11@Key_Consol:

; 1828 : 	}
; 1829 : 
; 1830 : 	if(( key == K_MWHEELDOWN && Key_IsDown( K_SHIFT )) || ( key == K_DOWNARROW ) || (( Q_tolower(key) == 'n' ) && Key_IsDown( K_CTRL )))

	cmp	DWORD PTR _key$[ebp], 239		; 000000efH
	jne	SHORT $LN17@Key_Consol
	push	134					; 00000086H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@Key_Consol
$LN17@Key_Consol:
	cmp	DWORD PTR _key$[ebp], 129		; 00000081H
	je	SHORT $LN16@Key_Consol
	movzx	eax, BYTE PTR _key$[ebp]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	ecx, 110				; 0000006eH
	jne	SHORT $LN15@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@Key_Consol
$LN16@Key_Consol:

; 1831 : 	{
; 1832 : 		if( con.historyLine == con.nextHistoryLine ) return;

	mov	edx, DWORD PTR _con+31108
	cmp	edx, DWORD PTR _con+31112
	jne	SHORT $LN18@Key_Consol
	jmp	$LN1@Key_Consol
$LN18@Key_Consol:

; 1833 : 		con.historyLine++;

	mov	eax, DWORD PTR _con+31108
	add	eax, 1
	mov	DWORD PTR _con+31108, eax

; 1834 : 		con.input = con.historyLines[con.historyLine % CON_HISTORY];

	mov	ecx, DWORD PTR _con+31108
	and	ecx, -2147483585			; 8000003fH
	jns	SHORT $LN32@Key_Consol
	dec	ecx
	or	ecx, -64				; ffffffc0H
	inc	ecx
$LN32@Key_Consol:
	imul	esi, ecx, 268
	add	esi, OFFSET _con+13956
	mov	ecx, 67					; 00000043H
	mov	edi, OFFSET _con+13164
	rep movsd

; 1835 : 		return;

	jmp	$LN1@Key_Consol
$LN15@Key_Consol:

; 1836 : 	}
; 1837 : 
; 1838 : 	// console scrolling
; 1839 : 	if( key == K_PGUP )

	cmp	DWORD PTR _key$[ebp], 150		; 00000096H
	jne	SHORT $LN19@Key_Consol

; 1840 : 	{
; 1841 : 		Con_PageUp( 1 );

	push	1
	call	_Con_PageUp
	add	esp, 4

; 1842 : 		return;

	jmp	$LN1@Key_Consol
$LN19@Key_Consol:

; 1843 : 	}
; 1844 : 
; 1845 : 	if( key == K_PGDN )

	cmp	DWORD PTR _key$[ebp], 149		; 00000095H
	jne	SHORT $LN20@Key_Consol

; 1846 : 	{
; 1847 : 		Con_PageDown( 1 );

	push	1
	call	_Con_PageDown
	add	esp, 4

; 1848 : 		return;

	jmp	$LN1@Key_Consol
$LN20@Key_Consol:

; 1849 : 	}
; 1850 : 
; 1851 : 	if( key == K_MWHEELUP )

	cmp	DWORD PTR _key$[ebp], 240		; 000000f0H
	jne	SHORT $LN21@Key_Consol

; 1852 : 	{
; 1853 : 		if( Key_IsDown( K_CTRL ))

	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN22@Key_Consol

; 1854 : 			Con_PageUp( 8 );

	push	8
	call	_Con_PageUp
	add	esp, 4
	jmp	SHORT $LN23@Key_Consol
$LN22@Key_Consol:

; 1855 : 		else Con_PageUp( 2 );

	push	2
	call	_Con_PageUp
	add	esp, 4
$LN23@Key_Consol:

; 1856 : 		return;

	jmp	$LN1@Key_Consol
$LN21@Key_Consol:

; 1857 : 	}
; 1858 : 
; 1859 : 	if( key == K_MWHEELDOWN )

	cmp	DWORD PTR _key$[ebp], 239		; 000000efH
	jne	SHORT $LN24@Key_Consol

; 1860 : 	{	
; 1861 : 		if( Key_IsDown( K_CTRL ))

	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@Key_Consol

; 1862 : 			Con_PageDown( 8 );

	push	8
	call	_Con_PageDown
	add	esp, 4
	jmp	SHORT $LN26@Key_Consol
$LN25@Key_Consol:

; 1863 : 		else Con_PageDown( 2 );

	push	2
	call	_Con_PageDown
	add	esp, 4
$LN26@Key_Consol:

; 1864 : 		return;

	jmp	SHORT $LN1@Key_Consol
$LN24@Key_Consol:

; 1865 : 	}
; 1866 : 
; 1867 : 	// ctrl-home = top of console
; 1868 : 	if( key == K_HOME && Key_IsDown( K_CTRL ))

	cmp	DWORD PTR _key$[ebp], 151		; 00000097H
	jne	SHORT $LN27@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@Key_Consol

; 1869 : 	{
; 1870 : 		Con_Top();

	call	_Con_Top

; 1871 : 		return;

	jmp	SHORT $LN1@Key_Consol
$LN27@Key_Consol:

; 1872 : 	}
; 1873 : 
; 1874 : 	// ctrl-end = bottom of console
; 1875 : 	if( key == K_END && Key_IsDown( K_CTRL ))

	cmp	DWORD PTR _key$[ebp], 152		; 00000098H
	jne	SHORT $LN28@Key_Consol
	push	133					; 00000085H
	call	_Key_IsDown
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@Key_Consol

; 1876 : 	{
; 1877 : 		Con_Bottom();

	call	_Con_Bottom

; 1878 : 		return;

	jmp	SHORT $LN1@Key_Consol
$LN28@Key_Consol:

; 1879 : 	}
; 1880 : 
; 1881 : 	// pass to the normal editline routine
; 1882 : 	Field_KeyDownEvent( &con.input, key );

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	push	OFFSET _con+13164
	call	_Field_KeyDownEvent
	add	esp, 8
$LN1@Key_Consol:

; 1883 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_Console ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_RestoreFont PROC

; 813  : {

	push	ebp
	mov	ebp, esp

; 814  : 	con.curFont = con.lastUsedFont;

	mov	eax, DWORD PTR _con+13160
	mov	DWORD PTR _con+13156, eax

; 815  : }

	pop	ebp
	ret	0
_Con_RestoreFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_key$ = 8						; size = 4
_Con_CharEvent PROC

; 2367 : {

	push	ebp
	mov	ebp, esp

; 2368 : 	// distribute the key down event to the apropriate handler
; 2369 : 	if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN2@Con_CharEv

; 2370 : 	{
; 2371 : 		Field_CharEvent( &con.input, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _con+13164
	call	_Field_CharEvent
	add	esp, 8

; 2372 : 	}

	jmp	SHORT $LN1@Con_CharEv
$LN2@Con_CharEv:

; 2373 : 	else if( cls.key_dest == key_message )

	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN1@Con_CharEv

; 2374 : 	{
; 2375 : 		Field_CharEvent( &con.chat, key );

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET _con+13432
	call	_Field_CharEvent
	add	esp, 8
$LN1@Con_CharEv:

; 2376 : 	}
; 2377 : }

	pop	ebp
	ret	0
_Con_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_fontNum$ = 8						; size = 4
_Con_SetFont PROC

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 800  : 	fontNum = bound( 0, fontNum, 2 ); 

	cmp	DWORD PTR _fontNum$[ebp], 0
	jl	SHORT $LN5@Con_SetFon
	cmp	DWORD PTR _fontNum$[ebp], 2
	jge	SHORT $LN3@Con_SetFon
	mov	eax, DWORD PTR _fontNum$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@Con_SetFon
$LN3@Con_SetFon:
	mov	DWORD PTR tv66[ebp], 2
$LN4@Con_SetFon:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@Con_SetFon
$LN5@Con_SetFon:
	mov	DWORD PTR tv67[ebp], 0
$LN6@Con_SetFon:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _fontNum$[ebp], edx

; 801  : 	con.curFont = &con.chars[fontNum];

	imul	eax, DWORD PTR _fontNum$[ebp], 4368
	add	eax, OFFSET _con+52
	mov	DWORD PTR _con+13156, eax

; 802  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_SetFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_InvalidateFonts PROC

; 2474 : {

	push	ebp
	mov	ebp, esp

; 2475 : 	memset( con.chars, 0, sizeof( con.chars ));

	push	13104					; 00003330H
	push	0
	push	OFFSET _con+52
	call	_memset
	add	esp, 12					; 0000000cH

; 2476 : 	con.curFont = con.lastUsedFont = NULL;

	mov	DWORD PTR _con+13160, 0
	mov	eax, DWORD PTR _con+13160
	mov	DWORD PTR _con+13156, eax

; 2477 : }

	pop	ebp
	ret	0
_Con_InvalidateFonts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv75 = -24						; size = 4
tv74 = -20						; size = 4
tv71 = -16						; size = 4
tv70 = -12						; size = 4
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_Con_DefaultColor PROC

; 2528 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2529 : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@Con_Defaul
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@Con_Defaul
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@Con_Defaul
$LN3@Con_Defaul:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@Con_Defaul:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@Con_Defaul
$LN5@Con_Defaul:
	mov	DWORD PTR tv67[ebp], 0
$LN6@Con_Defaul:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 2530 : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@Con_Defaul
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@Con_Defaul
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@Con_Defaul
$LN7@Con_Defaul:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@Con_Defaul:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@Con_Defaul
$LN9@Con_Defaul:
	mov	DWORD PTR tv71[ebp], 0
$LN10@Con_Defaul:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 2531 : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@Con_Defaul
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@Con_Defaul
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@Con_Defaul
$LN11@Con_Defaul:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@Con_Defaul:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@Con_Defaul
$LN13@Con_Defaul:
	mov	DWORD PTR tv75[ebp], 0
$LN14@Con_Defaul:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 2532 : 	MakeRGBA( g_color_table[7], r, g, b, 255 );

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	imul	eax, edx, 0
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _g_color_table[ecx+eax], dl
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR _g$[ebp]
	mov	BYTE PTR _g_color_table[ecx+edx], al
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _g_color_table[edx+eax], cl
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _g_color_table[eax+edx], 255	; 000000ffH

; 2533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DefaultColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_number$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_Con_DrawCharacterLen PROC

; 838  : {

	push	ebp
	mov	ebp, esp

; 839  : 	if( width && con.curFont ) *width = con.curFont->charWidths[number];

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN2@Con_DrawCh
	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN2@Con_DrawCh
	mov	eax, DWORD PTR _con+13156
	add	eax, DWORD PTR _number$[ebp]
	movzx	ecx, BYTE PTR [eax+4100]
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@Con_DrawCh:

; 840  : 	if( height && con.curFont ) *height = con.curFont->charHeight;

	cmp	DWORD PTR _height$[ebp], 0
	je	SHORT $LN1@Con_DrawCh
	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN1@Con_DrawCh
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR [ecx+4356]
	mov	DWORD PTR [eax], edx
$LN1@Con_DrawCh:

; 841  : }

	pop	ebp
	ret	0
_Con_DrawCharacterLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_color$ = 20						; size = 4
_Con_DrawCharacter PROC

; 825  : {

	push	ebp
	mov	ebp, esp

; 826  : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 827  : 	return Con_DrawGenericChar( x, y, number, color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_DrawGenericChar
	add	esp, 16					; 00000010H

; 828  : }

	pop	ebp
	ret	0
_Con_DrawCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_setColor$ = 20						; size = 4
_Con_DrawString PROC

; 951  : {

	push	ebp
	mov	ebp, esp

; 952  : 	return Con_DrawGenericString( x, y, string, setColor, false, -1 );

	push	-1
	push	0
	mov	eax, DWORD PTR _setColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_DrawGenericString
	add	esp, 24					; 00000018H

; 953  : }

	pop	ebp
	ret	0
_Con_DrawString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_curLength$ = -8					; size = 4
_c$1 = -1						; size = 1
_pText$ = 8						; size = 4
_length$ = 12						; size = 4
_height$ = 16						; size = 4
_Con_DrawStringLen PROC

; 851  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 852  : 	int	curLength = 0;

	mov	DWORD PTR _curLength$[ebp], 0

; 853  : 
; 854  : 	if( !con.curFont ) return;

	cmp	DWORD PTR _con+13156, 0
	jne	SHORT $LN4@Con_DrawSt
	jmp	$LN1@Con_DrawSt
$LN4@Con_DrawSt:

; 855  : 
; 856  : 	if( height ) *height = con.curFont->charHeight;

	cmp	DWORD PTR _height$[ebp], 0
	je	SHORT $LN5@Con_DrawSt
	mov	eax, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _con+13156
	mov	edx, DWORD PTR [ecx+4356]
	mov	DWORD PTR [eax], edx
$LN5@Con_DrawSt:

; 857  : 	if( !length ) return;

	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN6@Con_DrawSt
	jmp	$LN1@Con_DrawSt
$LN6@Con_DrawSt:

; 858  : 
; 859  : 	*length = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Con_DrawSt:

; 860  : 
; 861  : 	while( *pText )

	mov	ecx, DWORD PTR _pText$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN1@Con_DrawSt

; 862  : 	{
; 863  : 		byte	c = *pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$1[ebp], cl

; 864  : 
; 865  : 		if( *pText == '\n' )

	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN7@Con_DrawSt

; 866  : 		{
; 867  : 			pText++;

	mov	ecx, DWORD PTR _pText$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pText$[ebp], ecx

; 868  : 			curLength = 0;

	mov	DWORD PTR _curLength$[ebp], 0
$LN7@Con_DrawSt:

; 869  : 		}
; 870  : 
; 871  : 		// skip color strings they are not drawing
; 872  : 		if( IsColorString( pText ))

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN8@Con_DrawSt
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN8@Con_DrawSt
	mov	ecx, DWORD PTR _pText$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	test	edx, edx
	je	SHORT $LN8@Con_DrawSt
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN8@Con_DrawSt
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN8@Con_DrawSt

; 873  : 		{
; 874  : 			pText += 2;

	mov	ecx, DWORD PTR _pText$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pText$[ebp], ecx

; 875  : 			continue;

	jmp	SHORT $LN2@Con_DrawSt
$LN8@Con_DrawSt:

; 876  : 		}
; 877  : 
; 878  : 		curLength += con.curFont->charWidths[c];

	movzx	edx, BYTE PTR _c$1[ebp]
	mov	eax, DWORD PTR _con+13156
	movzx	ecx, BYTE PTR [eax+edx+4100]
	add	ecx, DWORD PTR _curLength$[ebp]
	mov	DWORD PTR _curLength$[ebp], ecx

; 879  : 		pText++;

	mov	edx, DWORD PTR _pText$[ebp]
	add	edx, 1
	mov	DWORD PTR _pText$[ebp], edx

; 880  : 
; 881  : 		if( curLength > *length )

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _curLength$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN9@Con_DrawSt

; 882  : 			*length = curLength;

	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _curLength$[ebp]
	mov	DWORD PTR [edx], eax
$LN9@Con_DrawSt:

; 883  : 	}

	jmp	$LN2@Con_DrawSt
$LN1@Con_DrawSt:

; 884  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawStringLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_start$ = -296						; size = 4
_color$ = -292						; size = 4
_charH$ = -288						; size = 4
tv66 = -284						; size = 4
_width$ = -280						; size = 4
_height$ = -276						; size = 4
_stringLen$ = -272					; size = 4
_draw_version$ = -268					; size = 4
_i$ = -264						; size = 4
_curbuild$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_Con_DrawVersion PROC

; 2282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2283 : 	// draws the current build
; 2284 : 	byte	*color = g_color_table[7];

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	mov	DWORD PTR _color$[ebp], ecx

; 2285 : 	int	i, stringLen, width = 0, charH;

	mov	DWORD PTR _width$[ebp], 0

; 2286 : 	int	start, height = glState.height;

	mov	edx, DWORD PTR _glState+4
	mov	DWORD PTR _height$[ebp], edx

; 2287 : 	qboolean	draw_version = false;

	mov	DWORD PTR _draw_version$[ebp], 0

; 2288 : 	string	curbuild;
; 2289 : 
; 2290 : 	switch( cls.scrshot_action )

	mov	eax, DWORD PTR _cls+293060
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	jle	SHORT $LN2@Con_DrawVe
	cmp	DWORD PTR tv66[ebp], 2
	jle	SHORT $LN7@Con_DrawVe
	jmp	SHORT $LN2@Con_DrawVe
$LN7@Con_DrawVe:

; 2291 : 	{
; 2292 : 	case scrshot_normal:
; 2293 : 	case scrshot_snapshot:
; 2294 : 		draw_version = true;

	mov	DWORD PTR _draw_version$[ebp], 1
$LN2@Con_DrawVe:

; 2295 : 		break;
; 2296 : 	}
; 2297 : 
; 2298 : 	if( !host.force_draw_version )

	cmp	DWORD PTR _host+34380, 0
	jne	SHORT $LN9@Con_DrawVe

; 2299 : 	{
; 2300 : 		if(( cls.key_dest != key_menu && !draw_version ) || CL_IsDevOverviewMode() == 2 || net_graph->value )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN11@Con_DrawVe
	cmp	DWORD PTR _draw_version$[ebp], 0
	je	SHORT $LN10@Con_DrawVe
$LN11@Con_DrawVe:
	call	_CL_IsDevOverviewMode
	cmp	eax, 2
	je	SHORT $LN10@Con_DrawVe
	mov	ecx, DWORD PTR _net_graph
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@Con_DrawVe
$LN10@Con_DrawVe:

; 2301 : 			return;

	jmp	$LN5@Con_DrawVe
$LN9@Con_DrawVe:

; 2302 : 	}
; 2303 : 
; 2304 : 	if( host.force_draw_version || draw_version )

	cmp	DWORD PTR _host+34380, 0
	jne	SHORT $LN14@Con_DrawVe
	cmp	DWORD PTR _draw_version$[ebp], 0
	je	SHORT $LN12@Con_DrawVe
$LN14@Con_DrawVe:

; 2305 : 		Q_snprintf( curbuild, MAX_STRING, "Xash3D v%i/%s (build %i)", PROTOCOL_VERSION, XASH_VERSION, Q_buildnum( ));

	call	_Q_buildnum
	push	eax
	push	OFFSET $SG144545
	push	49					; 00000031H
	push	OFFSET $SG144546
	push	256					; 00000100H
	lea	edx, DWORD PTR _curbuild$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN13@Con_DrawVe
$LN12@Con_DrawVe:

; 2306 : 	else Q_snprintf( curbuild, MAX_STRING, "v%i/%s (build %i)", PROTOCOL_VERSION, XASH_VERSION, Q_buildnum( )); 

	call	_Q_buildnum
	push	eax
	push	OFFSET $SG144547
	push	49					; 00000031H
	push	OFFSET $SG144548
	push	256					; 00000100H
	lea	eax, DWORD PTR _curbuild$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN13@Con_DrawVe:

; 2307 : 	Con_DrawStringLen( curbuild, &stringLen, &charH );

	lea	ecx, DWORD PTR _charH$[ebp]
	push	ecx
	lea	edx, DWORD PTR _stringLen$[ebp]
	push	edx
	lea	eax, DWORD PTR _curbuild$[ebp]
	push	eax
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2308 : 	start = glState.width - stringLen * 1.05f;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _stringLen$[ebp]
	mulss	xmm1, DWORD PTR __real@3f866666
	subss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _start$[ebp], ecx

; 2309 : 	stringLen = Con_StringLength( curbuild );

	lea	edx, DWORD PTR _curbuild$[ebp]
	push	edx
	call	_Con_StringLength
	add	esp, 4
	mov	DWORD PTR _stringLen$[ebp], eax

; 2310 : 	height -= charH * 1.05f;

	cvtsi2ss xmm0, DWORD PTR _charH$[ebp]
	mulss	xmm0, DWORD PTR __real@3f866666
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _height$[ebp], eax

; 2311 : 
; 2312 : 	for( i = 0; i < stringLen; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Con_DrawVe
$LN4@Con_DrawVe:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@Con_DrawVe:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _stringLen$[ebp]
	jge	SHORT $LN5@Con_DrawVe

; 2313 : 		width += Con_DrawCharacter( start + width, height, curbuild[i], color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _curbuild$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], eax
	jmp	SHORT $LN4@Con_DrawVe
$LN5@Con_DrawVe:

; 2314 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawVersion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv80 = -4						; size = 4
_Con_DrawConsole PROC

; 2213 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2214 : 	// never draw console when changelevel in-progress
; 2215 : 	if( cls.state != ca_disconnected && ( cls.changelevel || cls.changedemo ))

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN4@Con_DrawCo
	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN5@Con_DrawCo
	cmp	DWORD PTR _cls+12, 0
	je	SHORT $LN4@Con_DrawCo
$LN5@Con_DrawCo:

; 2216 : 		return;

	jmp	$LN26@Con_DrawCo
$LN4@Con_DrawCo:

; 2217 : 
; 2218 : 	// check for console width changes from a vid mode change
; 2219 : 	Con_CheckResize ();

	call	_Con_CheckResize

; 2220 : 
; 2221 : 	if( cls.state == ca_connecting || cls.state == ca_connected )

	cmp	DWORD PTR _cls, 1
	je	SHORT $LN7@Con_DrawCo
	cmp	DWORD PTR _cls, 2
	jne	$LN13@Con_DrawCo
$LN7@Con_DrawCo:

; 2222 : 	{
; 2223 : 		if( !cl_allow_levelshots->value )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@Con_DrawCo

; 2224 : 		{
; 2225 : 			if(( Cvar_VariableInteger( "cl_background" ) || Cvar_VariableInteger( "sv_background" )) && cls.key_dest != key_console )

	push	OFFSET $SG144503
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@Con_DrawCo
	push	OFFSET $SG144504
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@Con_DrawCo
$LN12@Con_DrawCo:
	cmp	DWORD PTR _cls+36, 0
	je	SHORT $LN10@Con_DrawCo

; 2226 : 				con.vislines = con.showlines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0
	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
	jmp	SHORT $LN11@Con_DrawCo
$LN10@Con_DrawCo:

; 2227 : 			else con.vislines = con.showlines = glState.height;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	movss	DWORD PTR _con+40, xmm0
	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
$LN11@Con_DrawCo:

; 2228 : 		}

	jmp	SHORT $LN13@Con_DrawCo
$LN8@Con_DrawCo:

; 2229 : 		else
; 2230 : 		{
; 2231 : 			con.showlines = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0

; 2232 : 
; 2233 : 			if( host_developer.value >= DEV_EXTENDED )

	movss	xmm0, DWORD PTR _host_developer+12
	comiss	xmm0, DWORD PTR __real@40000000
	jb	SHORT $LN13@Con_DrawCo

; 2234 : 				Con_DrawNotify(); // draw notify lines

	call	_Con_DrawNotify
$LN13@Con_DrawCo:

; 2235 : 		}
; 2236 : 	}
; 2237 : 
; 2238 : 	// if disconnected, render console full screen
; 2239 : 	switch( cls.state )

	mov	ecx, DWORD PTR _cls
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 5
	ja	$LN2@Con_DrawCo
	mov	edx, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN28@Con_DrawCo[edx*4]
$LN14@Con_DrawCo:

; 2240 : 	{
; 2241 : 	case ca_disconnected:
; 2242 : 		if( cls.key_dest != key_menu )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN15@Con_DrawCo

; 2243 : 		{
; 2244 : 			Con_DrawSolidConsole( glState.height );

	mov	eax, DWORD PTR _glState+4
	push	eax
	call	_Con_DrawSolidConsole
	add	esp, 4

; 2245 : 			Key_SetKeyDest( key_console );

	push	0
	call	_Key_SetKeyDest
	add	esp, 4
$LN15@Con_DrawCo:

; 2246 : 		}
; 2247 : 		break;

	jmp	$LN2@Con_DrawCo
$LN16@Con_DrawCo:

; 2248 : 	case ca_connecting:
; 2249 : 	case ca_connected:
; 2250 : 	case ca_validate:
; 2251 : 		// force to show console always for -dev 3 and higher 
; 2252 : 		Con_DrawSolidConsole( con.vislines );

	cvttss2si ecx, DWORD PTR _con+44
	push	ecx
	call	_Con_DrawSolidConsole
	add	esp, 4

; 2253 : 		break;

	jmp	$LN2@Con_DrawCo
$LN17@Con_DrawCo:

; 2254 : 	case ca_active:
; 2255 : 	case ca_cinematic: 
; 2256 : 		if( Cvar_VariableInteger( "cl_background" ) || Cvar_VariableInteger( "sv_background" ))

	push	OFFSET $SG144513
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@Con_DrawCo
	push	OFFSET $SG144514
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@Con_DrawCo
$LN20@Con_DrawCo:

; 2257 : 		{
; 2258 : 			if( cls.key_dest == key_console ) 

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN21@Con_DrawCo

; 2259 : 				Con_DrawSolidConsole( glState.height );

	mov	edx, DWORD PTR _glState+4
	push	edx
	call	_Con_DrawSolidConsole
	add	esp, 4
$LN21@Con_DrawCo:

; 2260 : 		}

	jmp	SHORT $LN24@Con_DrawCo
$LN18@Con_DrawCo:

; 2261 : 		else
; 2262 : 		{
; 2263 : 			if( con.vislines )

	movss	xmm0, DWORD PTR _con+44
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@Con_DrawCo

; 2264 : 				Con_DrawSolidConsole( con.vislines );

	cvttss2si eax, DWORD PTR _con+44
	push	eax
	call	_Con_DrawSolidConsole
	add	esp, 4
	jmp	SHORT $LN24@Con_DrawCo
$LN22@Con_DrawCo:

; 2265 : 			else if( cls.state == ca_active && ( cls.key_dest == key_game || cls.key_dest == key_message ))

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN24@Con_DrawCo
	cmp	DWORD PTR _cls+36, 1
	je	SHORT $LN25@Con_DrawCo
	cmp	DWORD PTR _cls+36, 3
	jne	SHORT $LN24@Con_DrawCo
$LN25@Con_DrawCo:

; 2266 : 				Con_DrawNotify(); // draw notify lines

	call	_Con_DrawNotify
$LN24@Con_DrawCo:
$LN2@Con_DrawCo:

; 2267 : 		}
; 2268 : 		break;
; 2269 : 	}
; 2270 : 
; 2271 : 	if( !Con_Visible( )) SCR_DrawFPS( 4 );

	call	_Con_Visible
	test	eax, eax
	jne	SHORT $LN26@Con_DrawCo
	push	4
	call	_SCR_DrawFPS
	add	esp, 4
$LN26@Con_DrawCo:

; 2272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@Con_DrawCo:
	DD	$LN14@Con_DrawCo
	DD	$LN16@Con_DrawCo
	DD	$LN16@Con_DrawCo
	DD	$LN16@Con_DrawCo
	DD	$LN17@Con_DrawCo
	DD	$LN17@Con_DrawCo
_Con_DrawConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv90 = -12						; size = 8
_lines_per_frame$ = -4					; size = 4
_Con_RunConsole PROC

; 2324 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2325 : 	float	lines_per_frame;
; 2326 : 
; 2327 : 	// decide on the destination height of the console
; 2328 : 	if( host.allow_console && cls.key_dest == key_console )

	cmp	DWORD PTR _host+34336, 0
	je	SHORT $LN2@Con_RunCon
	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN2@Con_RunCon

; 2329 : 	{
; 2330 : 		if( cls.state < ca_active || cl.first_frame )

	cmp	DWORD PTR _cls, 4
	jl	SHORT $LN6@Con_RunCon
	cmp	DWORD PTR _cl+68, 0
	je	SHORT $LN4@Con_RunCon
$LN6@Con_RunCon:

; 2331 : 			con.showlines = glState.height;	// full screen

	cvtsi2ss xmm0, DWORD PTR _glState+4
	movss	DWORD PTR _con+40, xmm0
	jmp	SHORT $LN5@Con_RunCon
$LN4@Con_RunCon:

; 2332 : 		else con.showlines = (glState.height >> 1);	// half screen	

	mov	eax, DWORD PTR _glState+4
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _con+40, xmm0
$LN5@Con_RunCon:

; 2333 : 	}

	jmp	SHORT $LN3@Con_RunCon
$LN2@Con_RunCon:

; 2334 : 	else con.showlines = 0; // none visible

	xorps	xmm0, xmm0
	movss	DWORD PTR _con+40, xmm0
$LN3@Con_RunCon:

; 2335 : 
; 2336 : 	lines_per_frame = fabs( scr_conspeed->value ) * host.realframetime;

	mov	ecx, DWORD PTR _scr_conspeed
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv90[ebp]
	movsd	xmm0, QWORD PTR tv90[ebp]
	mulsd	xmm0, QWORD PTR _host+1456
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _lines_per_frame$[ebp], xmm0

; 2337 : 
; 2338 : 	if( con.showlines < con.vislines )

	movss	xmm0, DWORD PTR _con+44
	comiss	xmm0, DWORD PTR _con+40
	jbe	SHORT $LN7@Con_RunCon

; 2339 : 	{
; 2340 : 		con.vislines -= lines_per_frame;

	movss	xmm0, DWORD PTR _con+44
	subss	xmm0, DWORD PTR _lines_per_frame$[ebp]
	movss	DWORD PTR _con+44, xmm0

; 2341 : 		if( con.showlines > con.vislines )

	movss	xmm0, DWORD PTR _con+40
	comiss	xmm0, DWORD PTR _con+44
	jbe	SHORT $LN9@Con_RunCon

; 2342 : 			con.vislines = con.showlines;

	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
$LN9@Con_RunCon:

; 2343 : 	}

	jmp	SHORT $LN11@Con_RunCon
$LN7@Con_RunCon:

; 2344 : 	else if( con.showlines > con.vislines )

	movss	xmm0, DWORD PTR _con+40
	comiss	xmm0, DWORD PTR _con+44
	jbe	SHORT $LN11@Con_RunCon

; 2345 : 	{
; 2346 : 		con.vislines += lines_per_frame;

	movss	xmm0, DWORD PTR _con+44
	addss	xmm0, DWORD PTR _lines_per_frame$[ebp]
	movss	DWORD PTR _con+44, xmm0

; 2347 : 		if( con.showlines < con.vislines )

	movss	xmm0, DWORD PTR _con+44
	comiss	xmm0, DWORD PTR _con+40
	jbe	SHORT $LN11@Con_RunCon

; 2348 : 			con.vislines = con.showlines;

	movss	xmm0, DWORD PTR _con+40
	movss	DWORD PTR _con+44, xmm0
$LN11@Con_RunCon:

; 2349 : 	}
; 2350 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_RunConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv140 = -276						; size = 8
_x$ = -268						; size = 4
_y$ = -264						; size = 4
_dlstring$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_Con_DrawDebug PROC

; 1992 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1993 : 	static double	timeStart;
; 1994 : 	string		dlstring;
; 1995 : 	int		x, y;
; 1996 : 
; 1997 : 	if( scr_download->value != -1.0f )

	mov	eax, DWORD PTR _scr_download
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@Con_DrawDe

; 1998 : 	{
; 1999 : 		Q_snprintf( dlstring, sizeof( dlstring ), "Downloading [%d remaining]: ^2%s^7 %5.1f%% time %.f secs",

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv140[ebp]
	movsd	xmm0, QWORD PTR tv140[ebp]
	subsd	xmm0, QWORD PTR ?timeStart@?1??Con_DrawDebug@@9@9
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _scr_download
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET _host+496
	mov	edx, DWORD PTR _host+752
	push	edx
	push	OFFSET $SG144406
	push	256					; 00000100H
	lea	eax, DWORD PTR _dlstring$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 36					; 00000024H

; 2000 : 		host.downloadcount, host.downloadfile, scr_download->value, Sys_DoubleTime() - timeStart ); 
; 2001 : 		x = glState.width - 500;

	mov	ecx, DWORD PTR _glState
	sub	ecx, 500				; 000001f4H
	mov	DWORD PTR _x$[ebp], ecx

; 2002 : 		y = con.curFont->charHeight * 1.05f;

	mov	edx, DWORD PTR _con+13156
	cvtsi2ss xmm0, DWORD PTR [edx+4356]
	mulss	xmm0, DWORD PTR __real@3f866666
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 2003 : 		Con_DrawString( x, y, dlstring, g_color_table[7] );

	mov	ecx, 4
	imul	edx, ecx, 7
	add	edx, OFFSET _g_color_table
	push	edx
	lea	eax, DWORD PTR _dlstring$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 2004 : 	}

	jmp	SHORT $LN3@Con_DrawDe
$LN2@Con_DrawDe:

; 2005 : 	else
; 2006 : 	{
; 2007 : 		timeStart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR ?timeStart@?1??Con_DrawDebug@@9@9
$LN3@Con_DrawDe:

; 2008 : 	}
; 2009 : 
; 2010 : 	if( !host_developer.value || Cvar_VariableInteger( "cl_background" ) || Cvar_VariableInteger( "sv_background" ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@Con_DrawDe
	push	OFFSET $SG144409
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Con_DrawDe
	push	OFFSET $SG144410
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Con_DrawDe
$LN5@Con_DrawDe:

; 2011 : 		return;

	jmp	SHORT $LN7@Con_DrawDe
$LN4@Con_DrawDe:

; 2012 : 
; 2013 : 	if( con.draw_notify && !Con_Visible( ))

	cmp	DWORD PTR _con+65420, 0
	je	SHORT $LN7@Con_DrawDe
	call	_Con_Visible
	test	eax, eax
	jne	SHORT $LN7@Con_DrawDe

; 2014 : 	{
; 2015 : 		if( Con_DrawDebugLines() == 0 )

	call	_Con_DrawDebugLines
	test	eax, eax
	jne	SHORT $LN7@Con_DrawDe

; 2016 : 			con.draw_notify = false;

	mov	DWORD PTR _con+65420, 0
$LN7@Con_DrawDe:

; 2017 : 	}
; 2018 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DrawDebug ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Con_ClearNotify PROC

; 187  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 188  : 	int	i;
; 189  : 	
; 190  : 	for( i = 0; i < CON_LINES_COUNT; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_ClearN
$LN2@Con_ClearN:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Con_ClearN:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _con+24
	jge	SHORT $LN3@Con_ClearN

; 191  : 		CON_LINES( i ).addtime = 0.0;

	mov	eax, DWORD PTR _con+20
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+edx+8], xmm0
	jmp	SHORT $LN2@Con_ClearN
$LN3@Con_ClearN:

; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_ClearNotify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_ToggleConsole_f PROC

; 289  : {

	push	ebp
	mov	ebp, esp

; 290  : 	if( !host.allow_console || UI_CreditsActive( ))

	cmp	DWORD PTR _host+34336, 0
	je	SHORT $LN3@Con_Toggle
	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN2@Con_Toggle
$LN3@Con_Toggle:

; 291  : 		return; // disabled

	jmp	SHORT $LN1@Con_Toggle
$LN2@Con_Toggle:

; 292  : 
; 293  : 	// show console only in game or by special call from menu
; 294  : 	if( cls.state != ca_active || cls.key_dest == key_menu )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN5@Con_Toggle
	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN4@Con_Toggle
$LN5@Con_Toggle:

; 295  : 		return;

	jmp	SHORT $LN1@Con_Toggle
$LN4@Con_Toggle:

; 296  : 
; 297  : 	Con_ClearTyping();

	call	_Con_ClearTyping

; 298  : 	Con_ClearNotify();

	call	_Con_ClearNotify

; 299  : 
; 300  : 	if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN6@Con_Toggle

; 301  : 	{
; 302  : 		if( Cvar_VariableInteger( "sv_background" ) || Cvar_VariableInteger( "cl_background" ))

	push	OFFSET $SG143624
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@Con_Toggle
	push	OFFSET $SG143625
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Con_Toggle
$LN10@Con_Toggle:

; 303  : 			UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
	jmp	SHORT $LN9@Con_Toggle
$LN8@Con_Toggle:

; 304  : 		else UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4
$LN9@Con_Toggle:

; 305  : 	}

	jmp	SHORT $LN1@Con_Toggle
$LN6@Con_Toggle:

; 306  : 	else
; 307  : 	{
; 308  : 		UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4

; 309  : 		Key_SetKeyDest( key_console );

	push	0
	call	_Key_SetKeyDest
	add	esp, 4
$LN1@Con_Toggle:

; 310  : 	}
; 311  : }

	pop	ebp
	ret	0
_Con_ToggleConsole_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_Shutdown PROC

; 1011 : {

	push	ebp
	mov	ebp, esp

; 1012 : 	con.initialized = false;

	mov	DWORD PTR _con, 0

; 1013 : 
; 1014 : 	if( con.buffer )

	cmp	DWORD PTR _con+4, 0
	je	SHORT $LN2@Con_Shutdo

; 1015 : 		Mem_Free( con.buffer );

	push	1015					; 000003f7H
	push	OFFSET $SG143974
	mov	eax, DWORD PTR _con+4
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@Con_Shutdo:

; 1016 : 
; 1017 : 	if( con.lines )

	cmp	DWORD PTR _con+12, 0
	je	SHORT $LN3@Con_Shutdo

; 1018 : 		Mem_Free( con.lines );

	push	1018					; 000003faH
	push	OFFSET $SG143976
	mov	ecx, DWORD PTR _con+12
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@Con_Shutdo:

; 1019 : 
; 1020 : 	con.buffer = NULL;

	mov	DWORD PTR _con+4, 0

; 1021 : 	con.lines = NULL;

	mov	DWORD PTR _con+12, 0

; 1022 : }

	pop	ebp
	ret	0
_Con_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_dest$1 = -96						; size = 4
_y$2 = -92						; size = 4
_length$3 = -88						; size = 4
_chars$4 = -84						; size = 4
_draw_to_console$5 = -80				; size = 4
_x$6 = -76						; size = 4
_cb$7 = -72						; size = 4
_ver$8 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_Con_VidInit PROC

; 2387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2388 : 	Con_CheckResize();

	call	_Con_CheckResize

; 2389 : 
; 2390 : 	Con_LoadConchars();

	call	_Con_LoadConchars

; 2391 : 
; 2392 : 	// loading console image
; 2393 : 	if( host.allow_console )

	cmp	DWORD PTR _host+34336, 0
	je	$LN5@Con_VidIni

; 2394 : 	{
; 2395 : 		// trying to load truecolor image first
; 2396 : 		if( FS_FileExists( "gfx/shell/conback.bmp", false ) || FS_FileExists( "gfx/shell/conback.tga", false ))

	push	0
	push	OFFSET $SG144596
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@Con_VidIni
	push	0
	push	OFFSET $SG144597
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@Con_VidIni
$LN8@Con_VidIni:

; 2397 : 			con.background = GL_LoadTexture( "gfx/shell/conback", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144598
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN7@Con_VidIni:

; 2398 : 
; 2399 : 		if( !con.background )

	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN9@Con_VidIni

; 2400 : 		{
; 2401 : 			if( FS_FileExists( "cached/conback640", false ))

	push	0
	push	OFFSET $SG144602
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@Con_VidIni

; 2402 : 				con.background = GL_LoadTexture( "cached/conback640", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144603
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
	jmp	SHORT $LN9@Con_VidIni
$LN10@Con_VidIni:

; 2403 : 			else if( FS_FileExists( "cached/conback", false ))

	push	0
	push	OFFSET $SG144605
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@Con_VidIni

; 2404 : 				con.background = GL_LoadTexture( "cached/conback", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144606
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN9@Con_VidIni:

; 2405 : 		}
; 2406 : 	}

	jmp	$LN6@Con_VidIni
$LN5@Con_VidIni:

; 2407 : 	else
; 2408 : 	{
; 2409 : 		// trying to load truecolor image first
; 2410 : 		if( FS_FileExists( "gfx/shell/loading.bmp", false ) || FS_FileExists( "gfx/shell/loading.tga", false ))

	push	0
	push	OFFSET $SG144609
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@Con_VidIni
	push	0
	push	OFFSET $SG144610
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@Con_VidIni
$LN14@Con_VidIni:

; 2411 : 			con.background = GL_LoadTexture( "gfx/shell/loading", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144611
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN13@Con_VidIni:

; 2412 : 
; 2413 : 		if( !con.background )

	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN6@Con_VidIni

; 2414 : 		{
; 2415 : 			if( FS_FileExists( "cached/loading640", false ))

	push	0
	push	OFFSET $SG144615
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@Con_VidIni

; 2416 : 				con.background = GL_LoadTexture( "cached/loading640", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144616
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
	jmp	SHORT $LN6@Con_VidIni
$LN16@Con_VidIni:

; 2417 : 			else if( FS_FileExists( "cached/loading", false ))

	push	0
	push	OFFSET $SG144618
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Con_VidIni

; 2418 : 				con.background = GL_LoadTexture( "cached/loading", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144619
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN6@Con_VidIni:

; 2419 : 		}
; 2420 : 	}
; 2421 : 
; 2422 : 
; 2423 : 	if( !con.background ) // last chance - quake conback image

	cmp	DWORD PTR _con+48, 0
	jne	$LN19@Con_VidIni

; 2424 : 	{
; 2425 : 		qboolean		draw_to_console = false;

	mov	DWORD PTR _draw_to_console$5[ebp], 0

; 2426 : 		int		length = 0;

	mov	DWORD PTR _length$3[ebp], 0

; 2427 : 		gl_texture_t	*chars;
; 2428 : 
; 2429 : 		// NOTE: only these games want to draw build number into console background
; 2430 : 		if( !Q_stricmp( FS_Gamedir(), "id1" ))

	push	99999					; 0001869fH
	push	OFFSET $SG144622
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@Con_VidIni

; 2431 : 			draw_to_console = true;

	mov	DWORD PTR _draw_to_console$5[ebp], 1
$LN20@Con_VidIni:

; 2432 : 
; 2433 : 		if( !Q_stricmp( FS_Gamedir(), "hipnotic" ))

	push	99999					; 0001869fH
	push	OFFSET $SG144624
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Con_VidIni

; 2434 : 			draw_to_console = true;

	mov	DWORD PTR _draw_to_console$5[ebp], 1
$LN21@Con_VidIni:

; 2435 : 
; 2436 : 		if( !Q_stricmp( FS_Gamedir(), "rogue" ))

	push	99999					; 0001869fH
	push	OFFSET $SG144626
	mov	edx, DWORD PTR _SI+768
	add	edx, 128				; 00000080H
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@Con_VidIni

; 2437 : 			draw_to_console = true;

	mov	DWORD PTR _draw_to_console$5[ebp], 1
$LN22@Con_VidIni:

; 2438 : 
; 2439 : 		if( draw_to_console && con.curFont && ( chars = R_GetTexture( con.curFont->hFontTexture )) != NULL && chars->original )

	cmp	DWORD PTR _draw_to_console$5[ebp], 0
	je	$LN23@Con_VidIni
	cmp	DWORD PTR _con+13156, 0
	je	$LN23@Con_VidIni
	mov	eax, DWORD PTR _con+13156
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _chars$4[ebp], eax
	cmp	DWORD PTR _chars$4[ebp], 0
	je	$LN23@Con_VidIni
	mov	edx, DWORD PTR _chars$4[ebp]
	cmp	DWORD PTR [edx+292], 0
	je	$LN23@Con_VidIni

; 2440 : 		{
; 2441 : 			lmp_t	*cb = (lmp_t *)FS_LoadFile( "gfx/conback.lmp", &length, false );

	push	0
	lea	eax, DWORD PTR _length$3[ebp]
	push	eax
	push	OFFSET $SG144628
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cb$7[ebp], eax

; 2442 : 			char	ver[64];
; 2443 : 			byte	*dest;
; 2444 : 			int	x, y;
; 2445 : 
; 2446 : 			if( cb && cb->width == 320 && cb->height == 200 )

	cmp	DWORD PTR _cb$7[ebp], 0
	je	$LN24@Con_VidIni
	mov	ecx, DWORD PTR _cb$7[ebp]
	cmp	DWORD PTR [ecx], 320			; 00000140H
	jne	$LN24@Con_VidIni
	mov	edx, DWORD PTR _cb$7[ebp]
	cmp	DWORD PTR [edx+4], 200			; 000000c8H
	jne	$LN24@Con_VidIni

; 2447 : 			{
; 2448 : 				Q_snprintf( ver, 64, "%i", Q_buildnum( )); // can store only buildnum

	call	_Q_buildnum
	push	eax
	push	OFFSET $SG144630
	push	64					; 00000040H
	lea	eax, DWORD PTR _ver$8[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2449 : 				dest = (byte *)(cb + 1) + 320 * 186 + 320 - 11 - 8 * Q_strlen( ver );

	mov	esi, DWORD PTR _cb$7[ebp]
	add	esi, 59837				; 0000e9bdH
	lea	ecx, DWORD PTR _ver$8[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	shl	eax, 3
	sub	esi, eax
	mov	DWORD PTR _dest$1[ebp], esi

; 2450 : 				y = Q_strlen( ver );

	lea	edx, DWORD PTR _ver$8[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _y$2[ebp], eax

; 2451 : 				for( x = 0; x < y; x++ )

	mov	DWORD PTR _x$6[ebp], 0
	jmp	SHORT $LN4@Con_VidIni
$LN2@Con_VidIni:
	mov	eax, DWORD PTR _x$6[ebp]
	add	eax, 1
	mov	DWORD PTR _x$6[ebp], eax
$LN4@Con_VidIni:
	mov	ecx, DWORD PTR _x$6[ebp]
	cmp	ecx, DWORD PTR _y$2[ebp]
	jge	SHORT $LN3@Con_VidIni

; 2452 : 					Con_DrawCharToConback( ver[x], chars->original->buffer, dest + (x << 3));

	mov	edx, DWORD PTR _x$6[ebp]
	mov	eax, DWORD PTR _dest$1[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR _chars$4[ebp]
	mov	eax, DWORD PTR [edx+292]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _x$6[ebp]
	movsx	eax, BYTE PTR _ver$8[ebp+edx]
	push	eax
	call	_Con_DrawCharToConback
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Con_VidIni
$LN3@Con_VidIni:

; 2453 : 				con.background = GL_LoadTexture( "#gfx/conback.lmp", (byte *)cb, length, TF_IMAGE );

	push	6144					; 00001800H
	mov	ecx, DWORD PTR _length$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _cb$7[ebp]
	push	edx
	push	OFFSET $SG144631
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN24@Con_VidIni:

; 2454 : 			}
; 2455 : 			if( cb ) Mem_Free( cb );

	cmp	DWORD PTR _cb$7[ebp], 0
	je	SHORT $LN23@Con_VidIni
	push	2455					; 00000997H
	push	OFFSET $SG144633
	mov	eax, DWORD PTR _cb$7[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@Con_VidIni:

; 2456 : 		}
; 2457 : 
; 2458 : 		if( !con.background ) // trying the load unmodified conback

	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN19@Con_VidIni

; 2459 : 			con.background = GL_LoadTexture( "gfx/conback.lmp", NULL, 0, TF_IMAGE );

	push	6144					; 00001800H
	push	0
	push	0
	push	OFFSET $SG144635
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con+48, eax
$LN19@Con_VidIni:

; 2460 : 	}
; 2461 : 
; 2462 : 	// missed console image will be replaced as gray background like X-Ray or Crysis
; 2463 : 	if( con.background == tr.defaultTexture || con.background == 0 )

	mov	ecx, DWORD PTR _con+48
	cmp	ecx, DWORD PTR _tr
	je	SHORT $LN28@Con_VidIni
	cmp	DWORD PTR _con+48, 0
	jne	SHORT $LN1@Con_VidIni
$LN28@Con_VidIni:

; 2464 : 		con.background = tr.grayTexture;

	mov	edx, DWORD PTR _tr+12
	mov	DWORD PTR _con+48, edx
$LN1@Con_VidIni:

; 2465 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Con_VidInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_Con_FixedFont PROC

; 562  : {

	push	ebp
	mov	ebp, esp

; 563  : 	if( con.curFont && con.curFont->valid && con.curFont->type == FONT_FIXED )

	cmp	DWORD PTR _con+13156, 0
	je	SHORT $LN2@Con_FixedF
	mov	eax, DWORD PTR _con+13156
	cmp	DWORD PTR [eax+4364], 0
	je	SHORT $LN2@Con_FixedF
	mov	ecx, DWORD PTR _con+13156
	cmp	DWORD PTR [ecx+4360], 0
	jne	SHORT $LN2@Con_FixedF

; 564  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Con_FixedF
$LN2@Con_FixedF:

; 565  : 	return false;

	xor	eax, eax
$LN1@Con_FixedF:

; 566  : }

	pop	ebp
	ret	0
_Con_FixedFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_Con_Visible PROC

; 552  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 553  : 	return (con.vislines > 0);

	movss	xmm0, DWORD PTR _con+44
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@Con_Visibl
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@Con_Visibl
$LN3@Con_Visibl:
	mov	DWORD PTR tv65[ebp], 0
$LN4@Con_Visibl:
	mov	eax, DWORD PTR tv65[ebp]

; 554  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Visible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_input$ = -272						; size = 268
__$ArrayPad$ = -4					; size = 4
_complete_string$ = 8					; size = 4
_Cmd_AutoComplete PROC

; 2487 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2488 : 	field_t	input;
; 2489 : 
; 2490 : 	if( !complete_string || !*complete_string )

	cmp	DWORD PTR _complete_string$[ebp], 0
	je	SHORT $LN3@Cmd_AutoCo
	mov	eax, DWORD PTR _complete_string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Cmd_AutoCo
$LN3@Cmd_AutoCo:

; 2491 : 		return;

	jmp	$LN1@Cmd_AutoCo
$LN2@Cmd_AutoCo:

; 2492 : 
; 2493 : 	// setup input
; 2494 : 	Q_strncpy( input.buffer, complete_string, sizeof( input.buffer ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _complete_string$[ebp]
	push	edx
	lea	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2495 : 	input.cursor = input.scroll = 0;

	mov	DWORD PTR _input$[ebp+260], 0
	mov	ecx, DWORD PTR _input$[ebp+260]
	mov	DWORD PTR _input$[ebp+256], ecx

; 2496 : 
; 2497 : 	Con_CompleteCommand( &input );

	lea	edx, DWORD PTR _input$[ebp]
	push	edx
	call	_Con_CompleteCommand
	add	esp, 4

; 2498 : 
; 2499 : 	// setup output
; 2500 : 	if( input.buffer[0] == '\\' || input.buffer[0] == '/' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _input$[ebp+ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN6@Cmd_AutoCo
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _input$[ebp+ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN4@Cmd_AutoCo
$LN6@Cmd_AutoCo:

; 2501 : 		Q_strncpy( complete_string, input.buffer + 1, sizeof( input.buffer ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _input$[ebp+1]
	push	eax
	mov	ecx, DWORD PTR _complete_string$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Cmd_AutoCo
$LN4@Cmd_AutoCo:

; 2502 : 	else Q_strncpy( complete_string, input.buffer, sizeof( input.buffer ));

	push	256					; 00000100H
	lea	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	eax, DWORD PTR _complete_string$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@Cmd_AutoCo:

; 2503 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AutoComplete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_info$ = 8						; size = 4
_fmt$ = 12						; size = 4
_UI_NXPrintf PROC

; 1283 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1284 : 	va_list	args;
; 1285 : 
; 1286 : 	if( !info ) return;

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN2@UI_NXPrint
	jmp	$LN1@UI_NXPrint
$LN2@UI_NXPrint:

; 1287 : 
; 1288 : 	if( info->index < 0 || info->index >= MAX_DBG_NOTIFY )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN4@UI_NXPrint
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx], 128			; 00000080H
	jl	SHORT $LN3@UI_NXPrint
$LN4@UI_NXPrint:

; 1289 : 		return;

	jmp	$LN1@UI_NXPrint
$LN3@UI_NXPrint:

; 1290 : 
; 1291 : 	memset( con.notify[info->index].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1292 : 
; 1293 : 	va_start( args, fmt );

	lea	ecx, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], ecx

; 1294 : 	Q_vsnprintf( con.notify[info->index].szNotify, MAX_STRING, fmt, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	add	edx, OFFSET _con+31116
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1295 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1296 : 
; 1297 : 	// setup values
; 1298 : 	con.notify[info->index].key_dest = key_menu;

	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	DWORD PTR _con[ecx+31380], 2

; 1299 : 	con.notify[info->index].expire = host.realtime + info->time_to_live;

	mov	edx, DWORD PTR _info$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+4]
	addsd	xmm0, QWORD PTR _host+1440
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[ecx+31372], xmm0

; 1300 : 	MakeRGBA( con.notify[info->index].color, (byte)(info->color[0] * 255), (byte)(info->color[1] * 255), (byte)(info->color[2] * 255), 255 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	eax, 1
	imul	eax, eax, 0
	mov	BYTE PTR _con[ecx+eax+31376], dl
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _con[edx+ecx+31376], al
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR _con[eax+edx+31376], cl
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _con[ecx+eax+31376], 255	; 000000ffH

; 1301 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@UI_NXPrint:

; 1302 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_UI_NXPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_idx$ = 8						; size = 4
_fmt$ = 12						; size = 4
_UI_NPrintf PROC

; 1256 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1257 : 	va_list	args;
; 1258 : 
; 1259 : 	if( idx < 0 || idx >= MAX_DBG_NOTIFY )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN3@UI_NPrintf
	cmp	DWORD PTR _idx$[ebp], 128		; 00000080H
	jl	SHORT $LN2@UI_NPrintf
$LN3@UI_NPrintf:

; 1260 : 		return;

	jmp	$LN1@UI_NPrintf
$LN2@UI_NPrintf:

; 1261 : 
; 1262 : 	memset( con.notify[idx].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	imul	eax, DWORD PTR _idx$[ebp], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1263 : 
; 1264 : 	va_start( args, fmt );

	lea	ecx, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], ecx

; 1265 : 	Q_vsnprintf( con.notify[idx].szNotify, MAX_STRING, fmt, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	push	256					; 00000100H
	imul	ecx, DWORD PTR _idx$[ebp], 268
	add	ecx, OFFSET _con+31116
	push	ecx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1266 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1267 : 
; 1268 : 	// reset values
; 1269 : 	con.notify[idx].key_dest = key_menu;

	imul	edx, DWORD PTR _idx$[ebp], 268
	mov	DWORD PTR _con[edx+31380], 2

; 1270 : 	con.notify[idx].expire = host.realtime + 4.0f;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4010000000000000
	imul	eax, DWORD PTR _idx$[ebp], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[eax+31372], xmm0

; 1271 : 	MakeRGBA( con.notify[idx].color, 255, 255, 255, 255 );

	imul	ecx, DWORD PTR _idx$[ebp], 268
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _con[ecx+eax+31376], 255	; 000000ffH
	imul	ecx, DWORD PTR _idx$[ebp], 268
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _con[ecx+edx+31376], 255	; 000000ffH
	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _con[eax+ecx+31376], 255	; 000000ffH
	imul	edx, DWORD PTR _idx$[ebp], 268
	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _con[edx+ecx+31376], 255	; 000000ffH

; 1272 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@UI_NPrintf:

; 1273 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_UI_NPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_info$ = 8						; size = 4
_fmt$ = 12						; size = 4
_Con_NXPrintf PROC

; 1227 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1228 : 	va_list	args;
; 1229 : 
; 1230 : 	if( !info ) return;

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN2@Con_NXPrin
	jmp	$LN1@Con_NXPrin
$LN2@Con_NXPrin:

; 1231 : 
; 1232 : 	if( info->index < 0 || info->index >= MAX_DBG_NOTIFY )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN4@Con_NXPrin
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx], 128			; 00000080H
	jl	SHORT $LN3@Con_NXPrin
$LN4@Con_NXPrin:

; 1233 : 		return;

	jmp	$LN1@Con_NXPrin
$LN3@Con_NXPrin:

; 1234 : 
; 1235 : 	memset( con.notify[info->index].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1236 : 
; 1237 : 	va_start( args, fmt );

	lea	ecx, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], ecx

; 1238 : 	Q_vsnprintf( con.notify[info->index].szNotify, MAX_STRING, fmt, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	add	edx, OFFSET _con+31116
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1239 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1240 : 
; 1241 : 	// setup values
; 1242 : 	con.notify[info->index].key_dest = key_game;

	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	DWORD PTR _con[ecx+31380], 1

; 1243 : 	con.notify[info->index].expire = host.realtime + info->time_to_live;

	mov	edx, DWORD PTR _info$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+4]
	addsd	xmm0, QWORD PTR _host+1440
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[ecx+31372], xmm0

; 1244 : 	MakeRGBA( con.notify[info->index].color, (byte)(info->color[0] * 255), (byte)(info->color[1] * 255), (byte)(info->color[2] * 255), 255 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	eax, 1
	imul	eax, eax, 0
	mov	BYTE PTR _con[ecx+eax+31376], dl
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [ecx], 268
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _con[edx+ecx+31376], al
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _info$[ebp]
	imul	eax, DWORD PTR [edx], 268
	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR _con[eax+edx+31376], cl
	mov	eax, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [eax], 268
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _con[ecx+eax+31376], 255	; 000000ffH

; 1245 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@Con_NXPrin:

; 1246 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_NXPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_idx$ = 8						; size = 4
_fmt$ = 12						; size = 4
_Con_NPrintf PROC

; 1200 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 	va_list	args;
; 1202 : 
; 1203 : 	if( idx < 0 || idx >= MAX_DBG_NOTIFY )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN3@Con_NPrint
	cmp	DWORD PTR _idx$[ebp], 128		; 00000080H
	jl	SHORT $LN2@Con_NPrint
$LN3@Con_NPrint:

; 1204 : 		return;

	jmp	$LN1@Con_NPrint
$LN2@Con_NPrint:

; 1205 : 
; 1206 : 	memset( con.notify[idx].szNotify, 0, MAX_STRING );

	push	256					; 00000100H
	push	0
	imul	eax, DWORD PTR _idx$[ebp], 268
	add	eax, OFFSET _con+31116
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1207 : 
; 1208 : 	va_start( args, fmt );

	lea	ecx, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], ecx

; 1209 : 	Q_vsnprintf( con.notify[idx].szNotify, MAX_STRING, fmt, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	push	256					; 00000100H
	imul	ecx, DWORD PTR _idx$[ebp], 268
	add	ecx, OFFSET _con+31116
	push	ecx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1210 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1211 : 
; 1212 : 	// reset values
; 1213 : 	con.notify[idx].key_dest = key_game;

	imul	edx, DWORD PTR _idx$[ebp], 268
	mov	DWORD PTR _con[edx+31380], 1

; 1214 : 	con.notify[idx].expire = host.realtime + 4.0f;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4010000000000000
	imul	eax, DWORD PTR _idx$[ebp], 268
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _con[eax+31372], xmm0

; 1215 : 	MakeRGBA( con.notify[idx].color, 255, 255, 255, 255 );

	imul	ecx, DWORD PTR _idx$[ebp], 268
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _con[ecx+eax+31376], 255	; 000000ffH
	imul	ecx, DWORD PTR _idx$[ebp], 268
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _con[ecx+edx+31376], 255	; 000000ffH
	imul	eax, DWORD PTR _idx$[ebp], 268
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _con[eax+ecx+31376], 255	; 000000ffH
	imul	edx, DWORD PTR _idx$[ebp], 268
	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _con[edx+ecx+31376], 255	; 000000ffH

; 1216 : 	con.draw_notify = true;

	mov	DWORD PTR _con+65420, 1
$LN1@Con_NPrint:

; 1217 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_NPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
tv227 = -36						; size = 8
tv223 = -28						; size = 8
tv162 = -20						; size = 4
_norefresh$ = -16					; size = 4
_mask$ = -12						; size = 4
_c$ = -8						; size = 4
tv83 = -4						; size = 4
_txt$ = 8						; size = 4
_Con_Print PROC

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1035 : 	static int	cr_pending = 0;
; 1036 : 	static char	buf[MAX_PRINT_MSG];
; 1037 : 	qboolean		norefresh = false;

	mov	DWORD PTR _norefresh$[ebp], 0

; 1038 : 	static int	lastlength = 0;
; 1039 : 	static qboolean	inupdate;
; 1040 : 	static int	bufpos = 0;
; 1041 : 	int		c, mask = 0;

	mov	DWORD PTR _mask$[ebp], 0

; 1042 : 
; 1043 : 	// client not running
; 1044 : 	if( !con.initialized || !con.buffer )

	cmp	DWORD PTR _con, 0
	je	SHORT $LN8@Con_Print
	cmp	DWORD PTR _con+4, 0
	jne	SHORT $LN7@Con_Print
$LN8@Con_Print:

; 1045 : 		return;

	jmp	$LN23@Con_Print
$LN7@Con_Print:

; 1046 : 
; 1047 : 	if( txt[0] == 2 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _txt$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 2
	jne	SHORT $LN9@Con_Print

; 1048 : 	{
; 1049 : 		// go to colored text
; 1050 : 		if( Con_FixedFont( ))

	call	_Con_FixedFont
	test	eax, eax
	je	SHORT $LN10@Con_Print

; 1051 : 			mask = 128;

	mov	DWORD PTR _mask$[ebp], 128		; 00000080H
$LN10@Con_Print:

; 1052 : 		txt++;

	mov	ecx, DWORD PTR _txt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _txt$[ebp], ecx
$LN9@Con_Print:

; 1053 : 	}
; 1054 : 
; 1055 : 	if( txt[0] == 3 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _txt$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 3
	jne	SHORT $LN11@Con_Print

; 1056 : 	{
; 1057 : 		norefresh = true;

	mov	DWORD PTR _norefresh$[ebp], 1

; 1058 : 		txt++;

	mov	eax, DWORD PTR _txt$[ebp]
	add	eax, 1
	mov	DWORD PTR _txt$[ebp], eax
$LN11@Con_Print:

; 1059 : 	}
; 1060 : 
; 1061 : 	for( ; *txt; txt++ )

	jmp	SHORT $LN4@Con_Print
$LN2@Con_Print:
	mov	ecx, DWORD PTR _txt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _txt$[ebp], ecx
$LN4@Con_Print:
	mov	edx, DWORD PTR _txt$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@Con_Print

; 1062 : 	{
; 1063 : 		if( cr_pending )

	cmp	DWORD PTR ?cr_pending@?1??Con_Print@@9@9, 0
	je	SHORT $LN12@Con_Print

; 1064 : 		{
; 1065 : 			Con_DeleteLastLine();

	call	_Con_DeleteLastLine

; 1066 : 			cr_pending = 0;

	mov	DWORD PTR ?cr_pending@?1??Con_Print@@9@9, 0
$LN12@Con_Print:

; 1067 : 		}
; 1068 : 
; 1069 : 		c = *txt;

	mov	ecx, DWORD PTR _txt$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx

; 1070 : 
; 1071 : 		switch( c )

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 0
	je	SHORT $LN13@Con_Print
	cmp	DWORD PTR tv83[ebp], 10			; 0000000aH
	je	SHORT $LN15@Con_Print
	cmp	DWORD PTR tv83[ebp], 13			; 0000000dH
	je	SHORT $LN14@Con_Print
	jmp	$LN16@Con_Print
$LN13@Con_Print:

; 1072 : 		{
; 1073 : 		case '\0':
; 1074 : 			break;

	jmp	$LN5@Con_Print
$LN14@Con_Print:

; 1075 : 		case '\r':
; 1076 : 			Con_AddLine( buf, bufpos, true );

	push	1
	mov	ecx, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	ecx
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 12					; 0000000cH

; 1077 : 			lastlength = CON_LINES_LAST().length;

	mov	edx, DWORD PTR _con+24
	mov	eax, DWORD PTR _con+20
	lea	eax, DWORD PTR [eax+edx-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	ecx, DWORD PTR _con+12
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR ?lastlength@?1??Con_Print@@9@9, edx

; 1078 : 			cr_pending = 1;

	mov	DWORD PTR ?cr_pending@?1??Con_Print@@9@9, 1

; 1079 : 			bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0

; 1080 : 			break;

	jmp	$LN5@Con_Print
$LN15@Con_Print:

; 1081 : 		case '\n':
; 1082 : 			Con_AddLine( buf, bufpos, true );

	push	1
	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	eax
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 12					; 0000000cH

; 1083 : 			lastlength = CON_LINES_LAST().length;

	mov	ecx, DWORD PTR _con+24
	mov	edx, DWORD PTR _con+20
	lea	eax, DWORD PTR [edx+ecx-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR ?lastlength@?1??Con_Print@@9@9, ecx

; 1084 : 			bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0

; 1085 : 			break;

	jmp	$LN5@Con_Print
$LN16@Con_Print:

; 1086 : 		default:
; 1087 : 			buf[bufpos++] = c | mask;

	mov	edx, DWORD PTR _c$[ebp]
	or	edx, DWORD PTR _mask$[ebp]
	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	mov	BYTE PTR ?buf@?1??Con_Print@@9@9[eax], dl
	mov	ecx, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	add	ecx, 1
	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, ecx

; 1088 : 			if(( bufpos >= sizeof( buf ) - 1 ) || bufpos >= ( con.linewidth - 1 ))

	cmp	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 8191 ; 00001fffH
	jae	SHORT $LN18@Con_Print
	mov	edx, DWORD PTR _con+36
	sub	edx, 1
	cmp	DWORD PTR ?bufpos@?1??Con_Print@@9@9, edx
	jl	SHORT $LN17@Con_Print
$LN18@Con_Print:

; 1089 : 			{
; 1090 : 				Con_AddLine( buf, bufpos, true );

	push	1
	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	eax
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 12					; 0000000cH

; 1091 : 				lastlength = CON_LINES_LAST().length;

	mov	ecx, DWORD PTR _con+24
	mov	edx, DWORD PTR _con+20
	lea	eax, DWORD PTR [edx+ecx-1]
	cdq
	idiv	DWORD PTR _con+16
	shl	edx, 4
	mov	eax, DWORD PTR _con+12
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR ?lastlength@?1??Con_Print@@9@9, ecx

; 1092 : 				bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0
$LN17@Con_Print:
$LN5@Con_Print:

; 1093 : 			}
; 1094 : 			break;
; 1095 : 		}
; 1096 : 	}

	jmp	$LN2@Con_Print
$LN3@Con_Print:

; 1097 : 
; 1098 : 	if( norefresh ) return;

	cmp	DWORD PTR _norefresh$[ebp], 0
	je	SHORT $LN19@Con_Print
	jmp	$LN23@Con_Print
$LN19@Con_Print:

; 1099 : 
; 1100 : 	// custom renderer cause problems while updates screen on-loading
; 1101 : 	if( SV_Active() && cls.state < ca_active && !cl.video_prepped && !cls.disable_screen )

	call	_SV_Active
	test	eax, eax
	je	$LN23@Con_Print
	cmp	DWORD PTR _cls, 4
	jge	$LN23@Con_Print
	cmp	DWORD PTR _cl+16, 0
	jne	$LN23@Con_Print
	movss	xmm0, DWORD PTR _cls+24
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN23@Con_Print

; 1102 : 	{
; 1103 : 		if( bufpos != 0 )

	cmp	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0
	je	SHORT $LN21@Con_Print

; 1104 : 		{
; 1105 : 			Con_AddLine( buf, bufpos, lastlength != 0 );

	cmp	DWORD PTR ?lastlength@?1??Con_Print@@9@9, 0
	je	SHORT $LN25@Con_Print
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN26@Con_Print
$LN25@Con_Print:
	mov	DWORD PTR tv162[ebp], 0
$LN26@Con_Print:
	mov	edx, DWORD PTR tv162[ebp]
	push	edx
	mov	eax, DWORD PTR ?bufpos@?1??Con_Print@@9@9
	push	eax
	push	OFFSET ?buf@?1??Con_Print@@9@9
	call	_Con_AddLine
	add	esp, 12					; 0000000cH

; 1106 : 			lastlength = 0;

	mov	DWORD PTR ?lastlength@?1??Con_Print@@9@9, 0

; 1107 : 			bufpos = 0;

	mov	DWORD PTR ?bufpos@?1??Con_Print@@9@9, 0
$LN21@Con_Print:

; 1108 : 		}
; 1109 : 
; 1110 : 		// pump messages to avoid window hanging
; 1111 : 		if( con.lastupdate < Sys_DoubleTime( ))

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv223[ebp]
	movsd	xmm0, QWORD PTR tv223[ebp]
	comisd	xmm0, QWORD PTR _con+82080
	jbe	SHORT $LN22@Con_Print

; 1112 : 		{
; 1113 : 			con.lastupdate = Sys_DoubleTime() + 1.0;

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv227[ebp]
	movsd	xmm0, QWORD PTR tv227[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _con+82080, xmm0

; 1114 : 			Host_InputFrame();

	call	_Host_InputFrame
$LN22@Con_Print:

; 1115 : 		}
; 1116 : 
; 1117 : 		if( !inupdate )

	cmp	DWORD PTR ?inupdate@?1??Con_Print@@9@9, 0
	jne	SHORT $LN23@Con_Print

; 1118 : 		{
; 1119 : 			inupdate = true;

	mov	DWORD PTR ?inupdate@?1??Con_Print@@9@9, 1

; 1120 : 			SCR_UpdateScreen ();

	call	_SCR_UpdateScreen

; 1121 : 			inupdate = false;

	mov	DWORD PTR ?inupdate@?1??Con_Print@@9@9, 0
$LN23@Con_Print:

; 1122 : 		}
; 1123 : 	}
; 1124 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Con_Init PROC

; 961  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 962  : 	int	i;
; 963  : 
; 964  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@Con_Init

; 965  : 		return; // dedicated server already have console

	jmp	$LN1@Con_Init
$LN5@Con_Init:

; 966  : 
; 967  : 	// must be init before startup video subsystem
; 968  : 	scr_conspeed = Cvar_Get( "scr_conspeed", "600", FCVAR_ARCHIVE, "console moving speed" );

	push	OFFSET $SG143945
	push	1
	push	OFFSET $SG143946
	push	OFFSET $SG143947
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _scr_conspeed, eax

; 969  : 	con_notifytime = Cvar_Get( "con_notifytime", "3", FCVAR_ARCHIVE, "notify time to live" );

	push	OFFSET $SG143948
	push	1
	push	OFFSET $SG143949
	push	OFFSET $SG143950
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con_notifytime, eax

; 970  : 	con_fontsize = Cvar_Get( "con_fontsize", "1", FCVAR_ARCHIVE, "console font number (0, 1 or 2)" );

	push	OFFSET $SG143951
	push	1
	push	OFFSET $SG143952
	push	OFFSET $SG143953
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _con_fontsize, eax

; 971  : 
; 972  : 	// init the console buffer
; 973  : 	con.bufsize = CON_TEXTSIZE;

	mov	DWORD PTR _con+8, 1048576		; 00100000H

; 974  : 	con.buffer = (char *)Z_Calloc( con.bufsize );

	push	974					; 000003ceH
	push	OFFSET $SG143954
	push	1
	mov	eax, DWORD PTR _con+8
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _con+4, eax

; 975  : 	con.maxlines = CON_MAXLINES;

	mov	DWORD PTR _con+16, 16384		; 00004000H

; 976  : 	con.lines = (con_lineinfo_t *)Z_Calloc( con.maxlines * sizeof( *con.lines ));

	push	976					; 000003d0H
	push	OFFSET $SG143955
	push	1
	mov	edx, DWORD PTR _con+16
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _con+12, eax

; 977  : 	con.lines_first = con.lines_count = 0;

	mov	DWORD PTR _con+24, 0
	mov	ecx, DWORD PTR _con+24
	mov	DWORD PTR _con+20, ecx

; 978  : 	con.num_times = CON_TIMES; // default as 4

	mov	DWORD PTR _con+28, 4

; 979  : 
; 980  : 	Con_CheckResize();

	call	_Con_CheckResize

; 981  : 
; 982  : 	Con_ClearField( &con.input );

	push	OFFSET _con+13164
	call	_Con_ClearField
	add	esp, 4

; 983  : 	con.input.widthInChars = con.linewidth;

	mov	edx, DWORD PTR _con+36
	mov	DWORD PTR _con+13428, edx

; 984  : 
; 985  : 	Con_ClearField( &con.chat );

	push	OFFSET _con+13432
	call	_Con_ClearField
	add	esp, 4

; 986  : 	con.chat.widthInChars = con.linewidth;

	mov	eax, DWORD PTR _con+36
	mov	DWORD PTR _con+13696, eax

; 987  : 
; 988  : 	for( i = 0; i < CON_HISTORY; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Con_Init
$LN2@Con_Init:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Con_Init:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@Con_Init

; 989  : 	{
; 990  : 		Con_ClearField( &con.historyLines[i] );

	imul	edx, DWORD PTR _i$[ebp], 268
	add	edx, OFFSET _con+13956
	push	edx
	call	_Con_ClearField
	add	esp, 4

; 991  : 		con.historyLines[i].widthInChars = con.linewidth;

	imul	eax, DWORD PTR _i$[ebp], 268
	mov	ecx, DWORD PTR _con+36
	mov	DWORD PTR _con[eax+14220], ecx

; 992  : 	}

	jmp	SHORT $LN2@Con_Init
$LN3@Con_Init:

; 993  : 
; 994  : 	Cmd_AddCommand( "toggleconsole", Con_ToggleConsole_f, "opens or closes the console" );

	push	OFFSET $SG143956
	push	OFFSET _Con_ToggleConsole_f
	push	OFFSET $SG143957
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 995  : 	Cmd_AddCommand( "con_color", Con_SetColor_f, "set a custom console color" );

	push	OFFSET $SG143958
	push	OFFSET _Con_SetColor_f
	push	OFFSET $SG143959
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 996  : 	Cmd_AddCommand( "clear", Con_Clear_f, "clear console history" );

	push	OFFSET $SG143960
	push	OFFSET _Con_Clear_f
	push	OFFSET $SG143961
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 997  : 	Cmd_AddCommand( "messagemode", Con_MessageMode_f, "enable message mode \"say\"" );

	push	OFFSET $SG143962
	push	OFFSET _Con_MessageMode_f
	push	OFFSET $SG143963
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 998  : 	Cmd_AddCommand( "messagemode2", Con_MessageMode2_f, "enable message mode \"say_team\"" );

	push	OFFSET $SG143964
	push	OFFSET _Con_MessageMode2_f
	push	OFFSET $SG143965
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 999  : 	Cmd_AddCommand( "contimes", Con_SetTimes_f, "change number of console overlay lines (4-64)" );

	push	OFFSET $SG143966
	push	OFFSET _Con_SetTimes_f
	push	OFFSET $SG143967
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1000 : 	con.initialized = true;

	mov	DWORD PTR _con, 1

; 1001 : 
; 1002 : 	Con_Printf( "Console initialized.\n" );

	push	OFFSET $SG143968
	call	_Con_Printf
	add	esp, 4
$LN1@Con_Init:

; 1003 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
_Con_Printf PROC

; 1133 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1134 : 	static char	buffer[MAX_PRINT_MSG];
; 1135 : 	va_list		args;
; 1136 : 
; 1137 : 	if( !host.allow_console )

	cmp	DWORD PTR _host+34336, 0
	jne	SHORT $LN2@Con_Printf

; 1138 : 		return;

	jmp	SHORT $LN1@Con_Printf
$LN2@Con_Printf:

; 1139 : 
; 1140 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1141 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	8192					; 00002000H
	push	OFFSET ?buffer@?1??Con_Printf@@9@9
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1142 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1143 : 
; 1144 : 	Sys_Print( buffer );

	push	OFFSET ?buffer@?1??Con_Printf@@9@9
	call	_Sys_Print
	add	esp, 4
$LN1@Con_Printf:

; 1145 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Printf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
_Con_DPrintf PROC

; 1154 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1155 : 	static char	buffer[MAX_PRINT_MSG];
; 1156 : 	va_list		args;
; 1157 : 
; 1158 : 	if( host_developer.value < DEV_NORMAL )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN2@Con_DPrint

; 1159 : 		return;

	jmp	SHORT $LN1@Con_DPrint
$LN2@Con_DPrint:

; 1160 : 
; 1161 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1162 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	8192					; 00002000H
	push	OFFSET ?buffer@?1??Con_DPrintf@@9@9
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1163 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1164 : 
; 1165 : 	if( buffer[0] == '0' && buffer[1] == '\n' && buffer[2] == '\0' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR ?buffer@?1??Con_DPrintf@@9@9[ecx]
	cmp	edx, 48					; 00000030H
	jne	SHORT $LN3@Con_DPrint
	mov	eax, 1
	shl	eax, 0
	movsx	ecx, BYTE PTR ?buffer@?1??Con_DPrintf@@9@9[eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN3@Con_DPrint
	mov	edx, 1
	shl	edx, 1
	movsx	eax, BYTE PTR ?buffer@?1??Con_DPrintf@@9@9[edx]
	test	eax, eax
	jne	SHORT $LN3@Con_DPrint

; 1166 : 		return; // hlrally spam

	jmp	SHORT $LN1@Con_DPrint
$LN3@Con_DPrint:

; 1167 : 
; 1168 : 	Sys_Print( buffer );

	push	OFFSET ?buffer@?1??Con_DPrintf@@9@9
	call	_Sys_Print
	add	esp, 4
$LN1@Con_DPrint:

; 1169 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_DPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\console.c
_TEXT	SEGMENT
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
_Con_Reportf PROC

; 1178 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1179 : 	static char	buffer[MAX_PRINT_MSG];
; 1180 : 	va_list		args;
; 1181 : 
; 1182 : 	if( host_developer.value < DEV_EXTENDED )

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN2@Con_Report

; 1183 : 		return;

	jmp	SHORT $LN1@Con_Report
$LN2@Con_Report:

; 1184 : 
; 1185 : 	va_start( args, szFmt );

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 1186 : 	Q_vsnprintf( buffer, sizeof( buffer ), szFmt, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	8192					; 00002000H
	push	OFFSET ?buffer@?1??Con_Reportf@@9@9
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 1187 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 1188 : 
; 1189 : 	Sys_Print( buffer );

	push	OFFSET ?buffer@?1??Con_Reportf@@9@9
	call	_Sys_Print
	add	esp, 4
$LN1@Con_Report:

; 1190 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Con_Reportf ENDP
_TEXT	ENDS
END
