; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\cl_main.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_dev_overview
PUBLIC	_cl_resend
PUBLIC	_cl_test_bandwidth
PUBLIC	_mp_decals
PUBLIC	_cl_logofile
PUBLIC	_cl_logocolor
PUBLIC	_cl_allow_download
PUBLIC	_cl_allow_upload
PUBLIC	_cl_download_ingame
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_rcon_client_password:DWORD
COMM	_rcon_address:DWORD
COMM	_cl_cmdbackup:DWORD
COMM	_cl_dlmax:DWORD
COMM	_name:DWORD
COMM	_model:DWORD
COMM	_topcolor:DWORD
COMM	_bottomcolor:DWORD
COMM	_cl:BYTE:028fe78H
COMM	_cls:BYTE:048b90H
COMM	_clgame:BYTE:0254e0H
COMM	_cl_nopred:DWORD
COMM	_cl_showfps:DWORD
COMM	_cl_timeout:DWORD
COMM	_cl_nodelta:DWORD
COMM	_cl_interp:DWORD
COMM	_cl_showerror:DWORD
COMM	_cl_nosmooth:DWORD
COMM	_cl_smoothtime:DWORD
COMM	_cl_crosshair:DWORD
COMM	_cl_cmdrate:DWORD
COMM	_cl_updaterate:DWORD
COMM	_cl_solid_players:DWORD
COMM	_cl_idealpitchscale:DWORD
COMM	_cl_lightstyle_lerping:DWORD
COMM	_cl_draw_particles:DWORD
COMM	_cl_draw_tracers:DWORD
COMM	_cl_draw_beams:DWORD
COMM	_cl_clockreset:DWORD
COMM	_cl_fixtimerate:DWORD
COMM	_cl_bmodelinterp:DWORD
COMM	_cl_lw:DWORD
COMM	_cl_showevents:DWORD
COMM	_rate:DWORD
_DATA	ENDS
_DATA	SEGMENT
$SG144548 DB	'mp_decals', 00H
	ORG $+2
$SG144549 DB	'300', 00H
$SG144550 DB	'decals limit in multiplayer', 00H
_dev_overview DD FLAT:$SG144553
	DD	FLAT:$SG144554
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144555
	ORG $+4
$SG144553 DB	'dev_overview', 00H
	ORG $+3
$SG144554 DB	'0', 00H
	ORG $+2
$SG144555 DB	'draw level in overview-mode', 00H
_cl_resend DD	FLAT:$SG144558
	DD	FLAT:$SG144559
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144560
	ORG $+4
$SG144558 DB	'cl_resend', 00H
	ORG $+2
$SG144559 DB	'6.0', 00H
$SG144560 DB	'time to resend connect', 00H
	ORG $+1
$SG144562 DB	'cl_allow_download', 00H
	ORG $+2
$SG144563 DB	'1', 00H
	ORG $+2
$SG144564 DB	'allow to downloading resources from the server', 00H
	ORG $+1
$SG144566 DB	'cl_allow_upload', 00H
$SG144567 DB	'1', 00H
	ORG $+2
$SG144568 DB	'allow to uploading resources to the server', 00H
	ORG $+1
$SG144570 DB	'cl_download_ingame', 00H
	ORG $+1
$SG144571 DB	'1', 00H
	ORG $+2
$SG144572 DB	'allow to downloading resources while client is active', 00H
	ORG $+2
$SG144574 DB	'cl_logofile', 00H
$SG144575 DB	'lambda', 00H
	ORG $+1
$SG144576 DB	'player logo name', 00H
	ORG $+3
$SG144578 DB	'cl_logocolor', 00H
	ORG $+3
$SG144579 DB	'orange', 00H
	ORG $+1
$SG144580 DB	'player logo color', 00H
	ORG $+2
_cl_test_bandwidth DD FLAT:$SG144583
	DD	FLAT:$SG144584
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144585
	ORG $+4
$SG144583 DB	'cl_test_bandwidth', 00H
	ORG $+2
$SG144584 DB	'1', 00H
	ORG $+2
$SG144585 DB	'test network bandwith before connection', 00H
_mp_decals DD	FLAT:$SG144548
	DD	FLAT:$SG144549
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144550
	ORG $+4
_cl_logofile DD	FLAT:$SG144574
	DD	FLAT:$SG144575
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144576
	ORG $+4
_cl_logocolor DD FLAT:$SG144578
	DD	FLAT:$SG144579
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144580
	ORG $+4
_cl_allow_download DD FLAT:$SG144562
	DD	FLAT:$SG144563
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144564
	ORG $+4
_cl_allow_upload DD FLAT:$SG144566
	DD	FLAT:$SG144567
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144568
	ORG $+4
_cl_download_ingame DD FLAT:$SG144570
	DD	FLAT:$SG144571
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:$SG144572
	ORG $+4
_DATA	ENDS
PUBLIC	_CL_Init
PUBLIC	_CL_Shutdown
PUBLIC	_Host_ClientBegin
PUBLIC	_Host_ClientFrame
PUBLIC	_CL_Active
PUBLIC	_CL_IsInGame
PUBLIC	_CL_IsInMenu
PUBLIC	_CL_IsInConsole
PUBLIC	_CL_IsIntermission
PUBLIC	_CL_Initialized
PUBLIC	_CL_Userinfo
PUBLIC	_CL_DisableVisibility
PUBLIC	_CL_ServerCommand
PUBLIC	_CL_IsRecordDemo
PUBLIC	_CL_IsTimeDemo
PUBLIC	_CL_IsPlaybackDemo
PUBLIC	_CL_IsBackgroundDemo
PUBLIC	_CL_IsBackgroundMap
PUBLIC	_CL_IsQuakeCompatible
PUBLIC	_CL_Disconnect
PUBLIC	_CL_Crashed
PUBLIC	_CL_Drop
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetRealBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetMaxBytes
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetData
PUBLIC	_CL_Quit_f
PUBLIC	_CL_SendCommand
PUBLIC	_CL_Disconnect_f
PUBLIC	_CL_ProcessFile
PUBLIC	_CL_WriteUsercmd
PUBLIC	_CL_GetFragmentSize
PUBLIC	_CL_PrecacheResources
PUBLIC	_CL_SetupOverviewParams
PUBLIC	_CL_UpdateFrameLerp
PUBLIC	_CL_IsDevOverviewMode
PUBLIC	_CL_SignonReply
PUBLIC	_CL_ClearState
PUBLIC	_CL_CheckClientState
PUBLIC	_CL_DriftInterpolationAmount
PUBLIC	_CL_ComputeClientInterpolationAmount
PUBLIC	_CL_ComputePacketLoss
PUBLIC	_CL_FindInterpolatedAddAngle
PUBLIC	_CL_ApplyAddAngle
PUBLIC	_CL_ProcessShowTexturesCmds
PUBLIC	_CL_ProcessOverviewCmds
PUBLIC	_CL_UpdateClientData
PUBLIC	_CL_CreateCmd
PUBLIC	_CL_WritePacket
PUBLIC	_CL_BeginUpload_f
PUBLIC	_CL_GetCDKeyHash
PUBLIC	_CL_SendConnectPacket
PUBLIC	_CL_CheckForResend
PUBLIC	_CL_AddResource
PUBLIC	_CL_CreateResourceList
PUBLIC	_CL_Connect_f
PUBLIC	_CL_Rcon_f
PUBLIC	_CL_SendDisconnectMessage
PUBLIC	_CL_Reconnect
PUBLIC	_CL_LocalServers_f
PUBLIC	_CL_InternetServers_f
PUBLIC	_CL_Reconnect_f
PUBLIC	_CL_FixupColorStringsForInfoString
PUBLIC	_CL_ParseStatusMessage
PUBLIC	_CL_ParseNETInfoMessage
PUBLIC	_CL_ProcessNetRequests
PUBLIC	_CL_ConnectionlessPacket
PUBLIC	_CL_GetMessage
PUBLIC	_CL_ReadNetMessage
PUBLIC	_CL_ReadPackets
PUBLIC	_CL_CleanFileName
PUBLIC	_CL_RegisterCustomization
PUBLIC	_CL_SetInfo_f
PUBLIC	_CL_Physinfo_f
PUBLIC	_CL_FullServerinfo_f
PUBLIC	_CL_Escape_f
PUBLIC	_CL_InitLocal
PUBLIC	_CL_AdjustClock
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f50624de0000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff028f5c28f5c29
PUBLIC	__real@40000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@402e000000000000
PUBLIC	__real@4059800000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40f00000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42cc0000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@46000000
PUBLIC	__real@bf800000
PUBLIC	__real@bf847ae147ae147b
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_GetCurrentUser:PROC
EXTRN	_Sys_GetMachineKey:PROC
EXTRN	_Sys_Quit:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Cmd_ForwardToServer:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_PrintStats:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_RegisterVariable:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_NET_Config:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_GetPacket:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Host_EndGame:PROC
EXTRN	_Host_WriteOpenGLConfig:PROC
EXTRN	_Host_WriteVideoConfig:PROC
EXTRN	_Host_WriteConfig:PROC
EXTRN	_Host_IsLocalGame:PROC
EXTRN	_Host_IsLocalClient:PROC
EXTRN	_Host_ShutdownServer:PROC
EXTRN	_Host_Error:PROC
EXTRN	_SV_Active:PROC
EXTRN	_COM_HexConvert:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_BlockSequence:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_MD5Init:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5_HashFile:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_COM_CreateCustomization:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_HPAK_ResourceForHash:PROC
EXTRN	_HPAK_AddLump:PROC
EXTRN	_HPAK_RemoveLump:PROC
EXTRN	_HPAK_FlushHostQueue:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_CL_GetMaxClients:PROC
EXTRN	_CL_LoadProgs:PROC
EXTRN	_SCR_UpdateScreen:PROC
EXTRN	_SCR_Shutdown:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Info_Print:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_Init:PROC
EXTRN	_S_Shutdown:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	_fabs:PROC
EXTRN	_Mod_LoadWorld:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_BigShort:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_Setup:PROC
EXTRN	_Netchan_CreateFileFragmentsFromBuffer:PROC
EXTRN	_Netchan_CopyNormalFragments:PROC
EXTRN	_Netchan_CopyFileFragments:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_TransmitBits:PROC
EXTRN	_Netchan_OutOfBand:PROC
EXTRN	_Netchan_OutOfBandPrint:PROC
EXTRN	_Netchan_Process:PROC
EXTRN	_Netchan_UpdateProgress:PROC
EXTRN	_Netchan_IncomingReady:PROC
EXTRN	_Netchan_CanPacket:PROC
EXTRN	_Netchan_IsLocal:PROC
EXTRN	_Netchan_ReportFlow:PROC
EXTRN	_Netchan_FragSend:PROC
EXTRN	_Netchan_Clear:PROC
EXTRN	_CL_ScreenShot_f:PROC
EXTRN	_CL_SnapShot_f:PROC
EXTRN	_CL_PlayCDTrack_f:PROC
EXTRN	_CL_EnvShot_f:PROC
EXTRN	_CL_SkyShot_f:PROC
EXTRN	_CL_SaveShot_f:PROC
EXTRN	_CL_LevelShot_f:PROC
EXTRN	_CL_MoveToOnHandList:PROC
EXTRN	_CL_ClearResourceLists:PROC
EXTRN	_CL_StartupDemoHeader:PROC
EXTRN	_CL_WriteDemoUserCmd:PROC
EXTRN	_CL_DemoReadMessage:PROC
EXTRN	_CL_CloseDemoHeader:PROC
EXTRN	_CL_PlayDemo_f:PROC
EXTRN	_CL_TimeDemo_f:PROC
EXTRN	_CL_StartDemos_f:PROC
EXTRN	_CL_Demos_f:PROC
EXTRN	_CL_DeleteDemo_f:PROC
EXTRN	_CL_Record_f:PROC
EXTRN	_CL_Stop_f:PROC
EXTRN	_CL_SetEventIndex:PROC
EXTRN	_CL_BatchResourceRequest:PROC
EXTRN	_CL_EstimateNeededResources:PROC
EXTRN	_CL_UnloadProgs:PROC
EXTRN	_CL_FreeEdicts:PROC
EXTRN	_CL_ClearSpriteTextures:PROC
EXTRN	_NetAPI_CancelAllRequests:PROC
EXTRN	_CL_LoadClientSprite:PROC
EXTRN	_CL_ParseServerMessage:PROC
EXTRN	_CL_RequestMissingResources:PROC
EXTRN	_CL_RegisterResources:PROC
EXTRN	_SCR_EndLoadingPlaque:PROC
EXTRN	_SCR_MakeLevelShot:PROC
EXTRN	_CL_SetSolidEntities:PROC
EXTRN	_CL_SetSolidPlayers:PROC
EXTRN	_CL_PredictMovement:PROC
EXTRN	_CL_MoveSpectatorCamera:PROC
EXTRN	_CL_SetLastUpdate:PROC
EXTRN	_CL_RedoPrediction:PROC
EXTRN	_CL_ClearPhysEnts:PROC
EXTRN	_CL_PushPMStates:PROC
EXTRN	_CL_PopPMStates:PROC
EXTRN	_CL_ParseQuakeMessage:PROC
EXTRN	_CL_MoveThirdpersonCamera:PROC
EXTRN	_CL_EmitEntities:PROC
EXTRN	_CL_ClearEffects:PROC
EXTRN	_CL_ReadPointFile_f:PROC
EXTRN	_CL_ReadLineFile_f:PROC
EXTRN	_Con_Shutdown:PROC
EXTRN	_S_BeginRegistration:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_EndRegistration:PROC
EXTRN	_SND_UpdateSound:PROC
EXTRN	_UI_AddServerToList:PROC
EXTRN	_SCR_FreeCinematic:PROC
EXTRN	_SCR_NextMovie:PROC
EXTRN	_SCR_RunCinematic:PROC
EXTRN	_CL_PlayVideo_f:PROC
EXTRN	_MSG_WriteDeltaUsercmd:PROC
EXTRN	_VID_CheckChanges:PROC
EXTRN	_R_Init:PROC
EXTRN	_R_Shutdown:PROC
EXTRN	_IN_Shutdown:PROC
EXTRN	_VGui_RunFrame:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host_limitlocal:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_world:BYTE
EXTRN	_net_from:BYTE
EXTRN	_net_message:BYTE
EXTRN	_net_message_buffer:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_gl_showtextures:DWORD
EXTRN	_glState:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?oldbuttons@?1??CL_ProcessShowTexturesCmds@@9@9 DD 01H DUP (?) ; `CL_ProcessShowTexturesCmds'::`2'::oldbuttons
?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9 DB 0100H DUP (?) ; `CL_GetCDKeyHash'::`2'::szHashedKeyBuffer
?infostring@?1??CL_ParseStatusMessage@@9@9 DB 0108H DUP (?) ; `CL_ParseStatusMessage'::`2'::infostring
?infostring@?1??CL_ParseNETInfoMessage@@9@9 DB 0108H DUP (?) ; `CL_ParseNETInfoMessage'::`2'::infostring
$SG145574 DB	01H DUP (?)
	ALIGN	4

$SG145577 DB	01H DUP (?)
	ALIGN	4

$SG145585 DB	01H DUP (?)
	ALIGN	4

$SG145609 DB	01H DUP (?)
	ALIGN	4

$SG145612 DB	01H DUP (?)
	ALIGN	4

$SG145615 DB	01H DUP (?)
	ALIGN	4

$SG145666 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bf847ae147ae147b
CONST	SEGMENT
__real@bf847ae147ae147b DQ 0bf847ae147ae147br	; -0.01
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42cc0000
CONST	SEGMENT
__real@42cc0000 DD 042cc0000r			; 102
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40f00000
CONST	SEGMENT
__real@40f00000 DD 040f00000r			; 7.5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4059800000000000
CONST	SEGMENT
__real@4059800000000000 DQ 04059800000000000r	; 102
CONST	ENDS
;	COMDAT __real@402e000000000000
CONST	SEGMENT
__real@402e000000000000 DQ 0402e000000000000r	; 15
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff028f5c28f5c29
CONST	SEGMENT
__real@3ff028f5c28f5c29 DQ 03ff028f5c28f5c29r	; 1.01
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f50624de0000000
CONST	SEGMENT
__real@3f50624de0000000 DQ 03f50624de0000000r	; 0.001
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG144638 DB	'scr_loading', 00H
$SG144639 DB	'client connected at %.2f sec', 0aH, 00H
	ORG $+2
$SG144650 DB	'CL_SignonReply: %i', 0aH, 00H
$SG144652 DB	'begin', 00H
	ORG $+2
$SG144689 DB	'cl_updaterate minimum is %f, resetting to default (20)', 0aH
	DB	00H
$SG144690 DB	'cl_updaterate', 00H
	ORG $+2
$SG144692 DB	'cl_updaterate clamped at maximum (%f)', 0aH, 00H
	ORG $+1
$SG144693 DB	'cl_updaterate', 00H
	ORG $+2
$SG144697 DB	'ex_interp forced up to %i msec', 0aH, 00H
$SG144699 DB	'ex_interp forced down to %i msec', 0aH, 00H
	ORG $+2
$SG144701 DB	'ex_interp', 00H
	ORG $+2
$SG144769 DB	'r_showtextures', 00H
	ORG $+1
$SG144771 DB	'r_showtextures', 00H
	ORG $+1
$SG144843 DB	'from == -1 || ( from >= 0 && from < MULTIPLAYER_BACKUP )'
	DB	00H
	ORG $+3
$SG144842 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG144845 DB	'to >= 0 && to < MULTIPLAYER_BACKUP', 00H
	ORG $+1
$SG144844 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG144871 DB	'ClientData', 00H
	ORG $+1
$SG144875 DB	'cl_cmdrate', 00H
	ORG $+1
$SG144877 DB	'cl_cmdrate', 00H
	ORG $+1
$SG144887 DB	'^3Warning:^1 Connection Problem^7', 0aH, 00H
	ORG $+1
$SG144897 DB	'CL_WritePacket: overflowed command buffer (%i bytes)', 0aH
	DB	00H
	ORG $+2
$SG144902 DB	'CL_WritePacket: overflowed command buffer (%i bytes)', 0aH
	DB	00H
	ORG $+2
$SG144922 DB	'!MD5', 00H
	ORG $+3
$SG144923 DB	'Ingoring upload of non-customization', 0aH, 00H
	ORG $+2
$SG144925 DB	'custom.hpk', 00H
	ORG $+1
$SG144927 DB	'custom.hpk', 00H
	ORG $+1
$SG144928 DB	'Bogus data retrieved from %s, attempting to delete entry'
	DB	0aH, 00H
	ORG $+2
$SG144929 DB	'custom.hpk', 00H
	ORG $+1
$SG144931 DB	'custom.hpk', 00H
	ORG $+1
$SG144933 DB	'HPAK_AddLump called with bogus lump, md5 mismatch', 0aH, 00H
	ORG $+1
$SG144934 DB	'Purported:  %s', 0aH, 00H
$SG144935 DB	'Actual   :  %s', 0aH, 00H
$SG144936 DB	'Removing conflicting lump', 0aH, 00H
	ORG $+1
$SG144937 DB	'custom.hpk', 00H
	ORG $+1
$SG144964 DB	'CL_SendConnectPacket: bad server address', 0aH, 00H
	ORG $+2
$SG144939 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG144966 DB	'net_qport', 00H
	ORG $+2
$SG144967 DB	'uuid', 00H
	ORG $+3
$SG144968 DB	'qport', 00H
	ORG $+2
$SG144969 DB	'connect %i %i "%s" "%s"', 0aH, 00H
	ORG $+3
$SG144975 DB	'localhost', 00H
	ORG $+2
$SG144980 DB	'cl_resend', 00H
	ORG $+2
$SG144982 DB	'cl_resend', 00H
	ORG $+2
$SG144986 DB	'^1Error:^7 CL_CheckForResend: couldn''t connected', 0aH, 00H
	ORG $+2
$SG144989 DB	'hi-speed connection is failed, use default method', 0aH, 00H
	ORG $+1
$SG144990 DB	'getchallenge', 0aH, 00H
	ORG $+2
$SG144991 DB	'cl_dlmax', 00H
	ORG $+3
$SG144992 DB	'Connecting to %s... [retry #%i]', 0aH, 00H
	ORG $+3
$SG144995 DB	'bandwidth %i %i', 0aH, 00H
	ORG $+3
$SG144996 DB	'getchallenge', 0aH, 00H
	ORG $+2
$SG145011 DB	'Too many resources on client', 0aH, 00H
	ORG $+2
$SG145022 DB	'logos/remapped.bmp', 00H
	ORG $+1
$SG145023 DB	'rb', 00H
	ORG $+1
$SG145027 DB	'custom.hpk', 00H
	ORG $+1
$SG145033 DB	'Usage: connect <server>', 0aH, 00H
	ORG $+3
$SG145035 DB	'server %s', 0aH, 00H
	ORG $+1
$SG145051 DB	'You must set ''rcon_password'' before issuing an rcon co'
	DB	'mmand.', 0aH, 00H
	ORG $+2
$SG145052 DB	'rcon ', 00H
	ORG $+2
$SG145053 DB	' ', 00H
	ORG $+2
$SG145054 DB	' ', 00H
	ORG $+2
$SG145058 DB	'You must either be connected or set the ''rcon_address'''
	DB	' cvar to issue rcon commands', 0aH, 00H
$SG145066 DB	'0', 00H
	ORG $+2
$SG145067 DB	'cl_background', 00H
	ORG $+2
$SG145068 DB	'scr_download', 00H
	ORG $+3
$SG145069 DB	'scr_loading', 00H
$SG145077 DB	'LastMessage', 00H
$SG145078 DB	'disconnect', 00H
	ORG $+1
$SG145087 DB	'net_qport', 00H
	ORG $+2
$SG145088 DB	'new', 00H
$SG145098 DB	'disconnected from server', 0aH, 00H
	ORG $+2
$SG145108 DB	'Scanning for servers on the local network area...', 0aH, 00H
	ORG $+1
$SG145109 DB	'info %i', 00H
$SG145119 DB	'1', 0ffH, '0.0.0.0:0', 00H, 00H
	ORG $+3
$SG145121 DB	'ms.xash.su:27010', 00H
	ORG $+3
$SG145122 DB	'ms.xash.su:27010', 00H
	ORG $+3
$SG145123 DB	'^1Error:^7 Can''t resolve adr: %s', 0aH, 00H
	ORG $+2
$SG145124 DB	'Scanning for servers on the internet area...', 0aH, 00H
	ORG $+2
$SG145125 DB	'gamedir', 00H
$SG145126 DB	'0.99', 00H
	ORG $+3
$SG145127 DB	'clver', 00H
	ORG $+2
$SG145136 DB	'reconnecting...', 0aH, 00H
	ORG $+3
$SG145167 DB	'gamedir', 00H
$SG145168 DB	'^1Server^7: %s, Info: %s', 0aH, 00H
	ORG $+2
$SG145169 DB	'gamedir', 00H
$SG145170 DB	'^2Server^7: %s, Game: %s', 0aH, 00H
	ORG $+2
$SG145192 DB	'neterror', 00H
	ORG $+3
$SG145195 DB	'protocol', 00H
	ORG $+3
$SG145197 DB	'undefined', 00H
	ORG $+2
$SG145249 DB	'CL_ConnectionlessPacket: %s : %s', 0aH, 00H
	ORG $+2
$SG145252 DB	'client_connect', 00H
	ORG $+1
$SG145254 DB	'^1Error:^7 dup connect received. ignored', 0aH, 00H
	ORG $+2
$SG145257 DB	'info', 00H
	ORG $+3
$SG145260 DB	'netinfo', 00H
$SG145263 DB	'cmd', 00H
$SG145265 DB	'Command packet from remote host. Ignored.', 0aH, 00H
	ORG $+1
$SG145266 DB	0aH, 00H
	ORG $+2
$SG145269 DB	'print', 00H
	ORG $+2
$SG145270 DB	'%s', 00H
	ORG $+1
$SG145273 DB	'testpacket', 00H
	ORG $+1
$SG145276 DB	'hi-speed connection is failed, use default method', 0aH, 00H
	ORG $+1
$SG145277 DB	'getchallenge', 0aH, 00H
	ORG $+2
$SG145278 DB	'cl_dlmax', 00H
	ORG $+3
$SG145281 DB	'CRC %p is matched, get challenge, fragment size %d', 0aH
	DB	00H
$SG145282 DB	'getchallenge', 0aH, 00H
	ORG $+2
$SG145283 DB	'cl_dlmax', 00H
	ORG $+3
$SG145285 DB	'hi-speed connection is failed, use default method', 0aH, 00H
	ORG $+1
$SG145286 DB	'getchallenge', 0aH, 00H
	ORG $+2
$SG145287 DB	'cl_dlmax', 00H
	ORG $+3
$SG145290 DB	'ping', 00H
	ORG $+3
$SG145291 DB	'ack', 00H
$SG145294 DB	'challenge', 00H
	ORG $+2
$SG145297 DB	'echo', 00H
	ORG $+3
$SG145298 DB	'%s', 00H
	ORG $+1
$SG145301 DB	'disconnect', 00H
	ORG $+1
$SG145304 DB	'f', 00H
	ORG $+2
$SG145308 DB	'serverlist call: %s', 0aH, 00H
	ORG $+3
$SG145310 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG145315 DB	'info %i', 00H
$SG145319 DB	'^1Error:^7 bad connectionless packet from %s:', 0aH, '%s'
	DB	0aH, 00H
	ORG $+2
$SG145313 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG145336 DB	'ServerData', 00H
	ORG $+1
$SG145340 DB	'^3Warning:^7 CL_ReadPackets: %s:runt packet', 0aH, 00H
	ORG $+3
$SG145342 DB	'^1Error:^7 CL_ReadPackets: %s:sequenced packet without c'
	DB	'onnection', 0aH, 00H
	ORG $+1
$SG145348 DB	'ServerData', 00H
	ORG $+1
$SG145362 DB	0aH, 'Server connection timed out.', 0aH, 00H
	ORG $+1
$SG145369 DB	'customization', 00H
	ORG $+2
$SG145386 DB	'Unable to create custom decal for player %i', 0aH, 00H
	ORG $+3
$SG145387 DB	'Duplicate resource received and ignored.', 0aH, 00H
	ORG $+2
$SG145408 DB	'sound/', 00H
	ORG $+1
$SG145412 DB	'processing %s', 0aH, 00H
	ORG $+1
$SG145414 DB	'^1Error:^7 server failed to transmit file ''%s''', 0aH, 00H
$SG145416 DB	'sound/', 00H
	ORG $+1
$SG145419 DB	'!MD5', 00H
	ORG $+3
$SG145432 DB	'custom.hpk', 00H
	ORG $+1
$SG145433 DB	'Downloaded %i bytes for purported %i byte file, ignoring'
	DB	' download', 0aH, 00H
	ORG $+1
$SG145469 DB	'Total %i symbols', 0aH, 00H
	ORG $+2
$SG145435 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG145438 DB	'Resource Registration', 00H
	ORG $+2
$SG145471 DB	'Usage: setinfo [ <key> <value> ]', 0aH, 00H
	ORG $+2
$SG145442 DB	'Received a decal %s, but didn''t find it in resources ne'
	DB	'eded list!', 0aH, 00H
	ORG $+1
$SG145479 DB	'Total %i symbols', 0aH, 00H
	ORG $+2
$SG145443 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_main.c', 00H
	ORG $+1
$SG145468 DB	'User info settings:', 0aH, 00H
	ORG $+3
$SG145478 DB	'Phys info settings:', 0aH, 00H
	ORG $+3
$SG145502 DB	'^1Error:^7 submodel %s not found', 0aH, 00H
	ORG $+2
$SG145511 DB	'sound/', 00H
	ORG $+1
$SG145512 DB	'^1Error:^7 %s%s couldn''t load', 0aH, 00H
	ORG $+1
$SG145532 DB	'Usage: fullserverinfo <complete info string>', 0aH, 00H
	ORG $+2
$SG145555 DB	'show weapon chrosshair', 00H
	ORG $+1
$SG145556 DB	'1', 00H
	ORG $+2
$SG145557 DB	'crosshair', 00H
	ORG $+2
$SG145558 DB	'disable delta-compression for server messages', 00H
	ORG $+2
$SG145559 DB	'0', 00H
	ORG $+2
$SG145560 DB	'cl_nodelta', 00H
	ORG $+1
$SG145561 DB	'how much to look up/down slopes and stairs when not usin'
	DB	'g freelook', 00H
	ORG $+1
$SG145562 DB	'0.8', 00H
$SG145563 DB	'cl_idealpitchscale', 00H
	ORG $+1
$SG145564 DB	'Make all players not solid (can''t traceline them)', 00H
	ORG $+2
$SG145565 DB	'1', 00H
	ORG $+2
$SG145566 DB	'cl_solid_players', 00H
	ORG $+3
$SG145567 DB	'Interpolate object positions starting this many seconds '
	DB	'in past', 00H
$SG145568 DB	'0.1', 00H
$SG145569 DB	'ex_interp', 00H
	ORG $+2
$SG145570 DB	'connect timeout (in-seconds)', 00H
	ORG $+3
$SG145571 DB	'60', 00H
	ORG $+1
$SG145572 DB	'cl_timeout', 00H
	ORG $+1
$SG145573 DB	'remote control client password', 00H
	ORG $+1
$SG145575 DB	'rcon_password', 00H
	ORG $+2
$SG145576 DB	'remote control address', 00H
	ORG $+1
$SG145578 DB	'rcon_address', 00H
	ORG $+3
$SG145579 DB	'disable client movement prediction', 00H
	ORG $+1
$SG145580 DB	'0', 00H
	ORG $+2
$SG145581 DB	'cl_nopred', 00H
	ORG $+2
$SG145582 DB	'player name', 00H
$SG145583 DB	'name', 00H
	ORG $+3
$SG145584 DB	'player model (''player'' is a singleplayer model)', 00H
$SG145586 DB	'model', 00H
	ORG $+2
$SG145587 DB	'refresh rate of server messages', 00H
$SG145588 DB	'20', 00H
	ORG $+1
$SG145589 DB	'cl_updaterate', 00H
	ORG $+2
$SG145590 DB	'max allowed fragment size on download resources', 00H
$SG145591 DB	'0', 00H
	ORG $+2
$SG145592 DB	'cl_dlmax', 00H
	ORG $+3
$SG145593 DB	'player network rate', 00H
$SG145594 DB	'3500', 00H
	ORG $+3
$SG145595 DB	'rate', 00H
	ORG $+3
$SG145596 DB	'player top color', 00H
	ORG $+3
$SG145597 DB	'0', 00H
	ORG $+2
$SG145598 DB	'topcolor', 00H
	ORG $+3
$SG145599 DB	'player bottom color', 00H
$SG145600 DB	'0', 00H
	ORG $+2
$SG145601 DB	'bottomcolor', 00H
$SG145602 DB	'enable client weapon predicting', 00H
$SG145603 DB	'1', 00H
	ORG $+2
$SG145604 DB	'cl_lw', 00H
	ORG $+2
$SG145605 DB	'enable lag compensation', 00H
$SG145606 DB	'1', 00H
	ORG $+2
$SG145607 DB	'cl_lc', 00H
	ORG $+2
$SG145608 DB	'server password', 00H
$SG145610 DB	'password', 00H
	ORG $+3
$SG145611 DB	'player team', 00H
$SG145613 DB	'team', 00H
	ORG $+3
$SG145614 DB	'player skin', 00H
$SG145616 DB	'skin', 00H
	ORG $+3
$SG145617 DB	'show client fps', 00H
$SG145618 DB	'1', 00H
	ORG $+2
$SG145619 DB	'cl_showfps', 00H
	ORG $+1
$SG145621 DB	'0', 00H
	ORG $+2
$SG145620 DB	'disable smooth up stair climbing and interpolate positio'
	DB	'n in multiplayer', 00H
	ORG $+3
$SG145622 DB	'cl_nosmooth', 00H
$SG145623 DB	'time to smooth up', 00H
	ORG $+2
$SG145624 DB	'0', 00H
	ORG $+2
$SG145625 DB	'cl_smoothtime', 00H
	ORG $+2
$SG145626 DB	'how many additional history commands are sent', 00H
	ORG $+2
$SG145627 DB	'10', 00H
	ORG $+1
$SG145628 DB	'cl_cmdbackup', 00H
	ORG $+3
$SG145629 DB	'Max number of command packets sent to server per second', 00H
$SG145630 DB	'30', 00H
	ORG $+1
$SG145631 DB	'cl_cmdrate', 00H
	ORG $+1
$SG145632 DB	'render particles', 00H
	ORG $+3
$SG145633 DB	'1', 00H
	ORG $+2
$SG145634 DB	'r_drawparticles', 00H
$SG145635 DB	'render tracers', 00H
	ORG $+1
$SG145636 DB	'1', 00H
	ORG $+2
$SG145637 DB	'r_drawtracers', 00H
	ORG $+2
$SG145638 DB	'render beams', 00H
	ORG $+3
$SG145639 DB	'1', 00H
	ORG $+2
$SG145640 DB	'r_drawbeams', 00H
$SG145641 DB	'enables animated light lerping (perfomance option)', 00H
	ORG $+1
$SG145642 DB	'0', 00H
	ORG $+2
$SG145643 DB	'cl_lightstyle_lerping', 00H
	ORG $+2
$SG145644 DB	'show prediction error', 00H
	ORG $+2
$SG145645 DB	'0', 00H
	ORG $+2
$SG145646 DB	'cl_showerror', 00H
	ORG $+3
$SG145647 DB	'enable bmodel interpolation', 00H
$SG145648 DB	'1', 00H
	ORG $+2
$SG145649 DB	'cl_bmodelinterp', 00H
$SG145650 DB	'frametime delta maximum value before reset', 00H
	ORG $+1
$SG145651 DB	'0.1', 00H
$SG145652 DB	'cl_clockreset', 00H
	ORG $+2
$SG145653 DB	'time in msec to client clock adjusting', 00H
	ORG $+1
$SG145654 DB	'7.5', 00H
$SG145655 DB	'cl_fixtimerate', 00H
	ORG $+1
$SG145656 DB	'scale hud at current resolution', 00H
$SG145657 DB	'0', 00H
	ORG $+2
$SG145658 DB	'hud_scale', 00H
	ORG $+2
$SG145659 DB	'indicate what background map is running', 00H
$SG145660 DB	'0', 00H
	ORG $+2
$SG145661 DB	'cl_background', 00H
	ORG $+2
$SG145662 DB	'show events playback', 00H
	ORG $+3
$SG145663 DB	'0', 00H
	ORG $+2
$SG145664 DB	'cl_showevents', 00H
	ORG $+2
$SG145665 DB	'last played demo', 00H
	ORG $+3
$SG145667 DB	'lastdemo', 00H
	ORG $+3
$SG145668 DB	'ambient lighting level (legacy, unused)', 00H
$SG145669 DB	'1', 00H
	ORG $+2
$SG145670 DB	'lightgamma', 00H
	ORG $+1
$SG145671 DB	'direct lighting level (legacy, unused)', 00H
	ORG $+1
$SG145672 DB	'1', 00H
	ORG $+2
$SG145673 DB	'direct', 00H
	ORG $+1
$SG145674 DB	'enable or disable no clipping mode', 00H
	ORG $+1
$SG145675 DB	'noclip', 00H
	ORG $+1
$SG145676 DB	'notarget mode (monsters do not see you)', 00H
$SG145677 DB	'notarget', 00H
	ORG $+3
$SG145678 DB	're-init HUD on start demo recording', 00H
$SG145679 DB	'fullupdate', 00H
	ORG $+1
$SG145680 DB	'give specified item or weapon', 00H
	ORG $+2
$SG145681 DB	'give', 00H
	ORG $+3
$SG145682 DB	'drop current/specified item or weapon', 00H
	ORG $+2
$SG145683 DB	'drop', 00H
	ORG $+3
$SG145684 DB	'show game logo', 00H
	ORG $+1
$SG145685 DB	'gametitle', 00H
	ORG $+2
$SG145686 DB	'die instantly', 00H
	ORG $+2
$SG145687 DB	'kill', 00H
	ORG $+3
$SG145688 DB	'enable godmode', 00H
	ORG $+1
$SG145689 DB	'god', 00H
$SG145690 DB	'set client field of view', 00H
	ORG $+3
$SG145691 DB	'fov', 00H
$SG145692 DB	'logging server events', 00H
	ORG $+2
$SG145693 DB	'log', 00H
$SG145694 DB	'pause the game (if the server allows pausing)', 00H
	ORG $+2
$SG145695 DB	'pause', 00H
	ORG $+2
$SG145696 DB	'collect info about local servers', 00H
	ORG $+3
$SG145697 DB	'localservers', 00H
	ORG $+3
$SG145698 DB	'collect info about internet servers', 00H
$SG145699 DB	'internetservers', 00H
$SG145700 DB	'Play cd-track (not real cd-player of course)', 00H
	ORG $+3
$SG145701 DB	'cd', 00H
	ORG $+1
$SG145702 DB	'Play mp3-track (based on virtual cd-player)', 00H
$SG145703 DB	'mp3', 00H
$SG145704 DB	'examine or change the userinfo string (alias of userinfo'
	DB	')', 00H
	ORG $+2
$SG145705 DB	'setinfo', 00H
$SG145706 DB	'examine or change the userinfo string (alias of setinfo)'
	DB	00H
	ORG $+3
$SG145707 DB	'userinfo', 00H
	ORG $+3
$SG145708 DB	'print current client physinfo', 00H
	ORG $+2
$SG145709 DB	'physinfo', 00H
	ORG $+3
$SG145710 DB	'disconnect from server', 00H
	ORG $+1
$SG145711 DB	'disconnect', 00H
	ORG $+1
$SG145712 DB	'record a demo', 00H
	ORG $+2
$SG145713 DB	'record', 00H
	ORG $+1
$SG145714 DB	'play a demo', 00H
$SG145715 DB	'playdemo', 00H
	ORG $+3
$SG145716 DB	'demo benchmark', 00H
	ORG $+1
$SG145717 DB	'timedemo', 00H
	ORG $+3
$SG145718 DB	'delete a specified demo file', 00H
	ORG $+3
$SG145719 DB	'killdemo', 00H
	ORG $+3
$SG145720 DB	'start playing back the selected demos sequentially', 00H
	ORG $+1
$SG145721 DB	'startdemos', 00H
	ORG $+1
$SG145722 DB	'restart looping demos defined by the last startdemos com'
	DB	'mand', 00H
	ORG $+3
$SG145723 DB	'demos', 00H
	ORG $+2
$SG145724 DB	'play a movie', 00H
	ORG $+3
$SG145725 DB	'movie', 00H
	ORG $+2
$SG145726 DB	'stop playing or recording a demo', 00H
	ORG $+3
$SG145727 DB	'stop', 00H
	ORG $+3
$SG145728 DB	'collect info about local servers with specified protocol'
	DB	00H
	ORG $+3
$SG145729 DB	'info', 00H
	ORG $+3
$SG145730 DB	'escape from game to menu', 00H
	ORG $+3
$SG145731 DB	'escape', 00H
	ORG $+1
$SG145732 DB	'toggle between game and menu', 00H
	ORG $+3
$SG145733 DB	'togglemenu', 00H
	ORG $+1
$SG145734 DB	'show leaks on a map (if present of course)', 00H
	ORG $+1
$SG145735 DB	'pointfile', 00H
	ORG $+2
$SG145736 DB	'show leaks on a map (if present of course)', 00H
	ORG $+1
$SG145737 DB	'linefile', 00H
	ORG $+3
$SG145738 DB	'sent by server when serverinfo changes', 00H
	ORG $+1
$SG145739 DB	'fullserverinfo', 00H
	ORG $+1
$SG145740 DB	'uploading file to the server', 00H
	ORG $+3
$SG145741 DB	'upload', 00H
	ORG $+1
$SG145742 DB	'quit from game', 00H
	ORG $+1
$SG145743 DB	'quit', 00H
	ORG $+3
$SG145744 DB	'quit from game', 00H
	ORG $+1
$SG145745 DB	'exit', 00H
	ORG $+3
$SG145746 DB	'takes a screenshot of the next rendered frame', 00H
	ORG $+2
$SG145747 DB	'screenshot', 00H
	ORG $+1
$SG145748 DB	'takes a snapshot of the next rendered frame', 00H
$SG145749 DB	'snapshot', 00H
	ORG $+3
$SG145750 DB	'takes a six-sides cubemap shot with specified name', 00H
	ORG $+1
$SG145751 DB	'envshot', 00H
$SG145752 DB	'takes a six-sides envmap (skybox) shot with specified na'
	DB	'me', 00H
	ORG $+1
$SG145753 DB	'skyshot', 00H
$SG145754 DB	'same as "screenshot", used for create plaque images', 00H
$SG145755 DB	'levelshot', 00H
	ORG $+2
$SG145756 DB	'used for create save previews with LoadGame menu', 00H
	ORG $+3
$SG145757 DB	'saveshot', 00H
	ORG $+3
$SG145758 DB	'connect to a server by hostname', 00H
$SG145759 DB	'connect', 00H
$SG145760 DB	'reconnect to current level', 00H
	ORG $+1
$SG145761 DB	'reconnect', 00H
	ORG $+2
$SG145773 DB	'cl_fixtimerate', 00H
	ORG $+5
$SG145762 DB	'sends a command to the server console (rcon_password and'
	DB	' rcon_address required)', 00H
$SG145763 DB	'rcon', 00H
	ORG $+3
$SG145790 DB	'cls.datagram', 00H
	ORG $+3
$SG145792 DB	'%s/client.dll', 00H
	ORG $+2
$SG145793 DB	'can''t initialize client.dll', 0aH, 00H
	ORG $+3
$SG145797 DB	'CL_Shutdown()', 0aH, 00H
	ORG $+1
$SG145798 DB	'demoheader.tmp', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv174 = -64						; size = 8
tv169 = -56						; size = 8
tv164 = -48						; size = 8
_sign$1 = -40						; size = 8
tv148 = -32						; size = 8
tv79 = -24						; size = 8
_adjust$2 = -16						; size = 8
_msec$3 = -8						; size = 8
_CL_AdjustClock PROC

; 2703 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 2704 : 	if( cl.timedelta == 0.0f || !cl_fixtimerate->value )

	movss	xmm0, DWORD PTR _cl+1525864
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_AdjustC
	mov	eax, DWORD PTR _cl_fixtimerate
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_AdjustC
$LN3@CL_AdjustC:

; 2705 : 		return;

	jmp	$LN7@CL_AdjustC
$LN2@CL_AdjustC:

; 2706 : 
; 2707 : 	if( cl_fixtimerate->value < 0.0f )

	mov	ecx, DWORD PTR _cl_fixtimerate
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN4@CL_AdjustC

; 2708 : 		Cvar_SetValue( "cl_fixtimerate", 7.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40f00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145773
	call	_Cvar_SetValue
	add	esp, 8
$LN4@CL_AdjustC:

; 2709 : 
; 2710 : 	if( fabs( cl.timedelta ) >= 0.001f )

	cvtss2sd xmm0, DWORD PTR _cl+1525864
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv148[ebp]
	movsd	xmm0, QWORD PTR tv148[ebp]
	comisd	xmm0, QWORD PTR __real@3f50624de0000000
	jb	$LN7@CL_AdjustC

; 2711 : 	{
; 2712 : 		double	msec, adjust, sign;
; 2713 : 
; 2714 : 		msec = ( cl.timedelta * 1000.0 );

	cvtss2sd xmm0, DWORD PTR _cl+1525864
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _msec$3[ebp], xmm0

; 2715 : 		sign = ( msec < 0 ) ? 1.0 : -1.0;

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _msec$3[ebp]
	jbe	SHORT $LN9@CL_AdjustC
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN10@CL_AdjustC
$LN9@CL_AdjustC:
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR tv79[ebp], xmm0
$LN10@CL_AdjustC:
	movsd	xmm0, QWORD PTR tv79[ebp]
	movsd	QWORD PTR _sign$1[ebp], xmm0

; 2716 : 		msec = fabs( msec );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _msec$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR _msec$3[ebp]

; 2717 : 		adjust = sign * ( cl_fixtimerate->value / 1000.0 );

	mov	edx, DWORD PTR _cl_fixtimerate
	cvtss2sd xmm0, DWORD PTR [edx+12]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	mulsd	xmm0, QWORD PTR _sign$1[ebp]
	movsd	QWORD PTR _adjust$2[ebp], xmm0

; 2718 : 
; 2719 : 		if( fabs( adjust ) < fabs( cl.timedelta ))

	sub	esp, 8
	movsd	xmm0, QWORD PTR _adjust$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv164[ebp]
	movsd	xmm0, QWORD PTR tv164[ebp]
	cvtss2sd xmm1, DWORD PTR _cl+1525864
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv174[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv169[ebp]
	movsd	xmm0, QWORD PTR tv169[ebp]
	movsd	xmm1, QWORD PTR tv174[ebp]
	comisd	xmm0, xmm1
	jbe	SHORT $LN6@CL_AdjustC

; 2720 : 		{
; 2721 : 			cl.timedelta += adjust;

	cvtss2sd xmm0, DWORD PTR _cl+1525864
	addsd	xmm0, QWORD PTR _adjust$2[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl+1525864, xmm0

; 2722 : 			cl.time += adjust;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR _adjust$2[ebp]
	movsd	QWORD PTR _cl+1525848, xmm0
$LN6@CL_AdjustC:

; 2723 : 		}
; 2724 : 
; 2725 : 		if( cl.oldtime > cl.time )

	movsd	xmm0, QWORD PTR _cl+1525856
	comisd	xmm0, QWORD PTR _cl+1525848
	jbe	SHORT $LN7@CL_AdjustC

; 2726 : 			cl.oldtime = cl.time;

	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR _cl+1525856, xmm0
$LN7@CL_AdjustC:

; 2727 : 	}
; 2728 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AdjustClock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_InitLocal PROC

; 2573 : {

	push	ebp
	mov	ebp, esp

; 2574 : 	cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0

; 2575 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 2576 : 
; 2577 : 	cl.resourcesneeded.pNext = cl.resourcesneeded.pPrev = &cl.resourcesneeded;

	mov	DWORD PTR _cl+1985128, OFFSET _cl+1984996
	mov	eax, DWORD PTR _cl+1985128
	mov	DWORD PTR _cl+1985124, eax

; 2578 : 	cl.resourcesonhand.pNext = cl.resourcesonhand.pPrev = &cl.resourcesonhand;

	mov	DWORD PTR _cl+1984992, OFFSET _cl+1984860
	mov	ecx, DWORD PTR _cl+1984992
	mov	DWORD PTR _cl+1984988, ecx

; 2579 : 
; 2580 : 	Cvar_RegisterVariable( &mp_decals );

	push	OFFSET _mp_decals
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2581 : 	Cvar_RegisterVariable( &dev_overview );

	push	OFFSET _dev_overview
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2582 : 	Cvar_RegisterVariable( &cl_resend );

	push	OFFSET _cl_resend
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2583 : 	Cvar_RegisterVariable( &cl_allow_upload );

	push	OFFSET _cl_allow_upload
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2584 : 	Cvar_RegisterVariable( &cl_allow_download );

	push	OFFSET _cl_allow_download
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2585 : 	Cvar_RegisterVariable( &cl_download_ingame );

	push	OFFSET _cl_download_ingame
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2586 : 	Cvar_RegisterVariable( &cl_logofile );

	push	OFFSET _cl_logofile
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2587 : 	Cvar_RegisterVariable( &cl_logocolor );

	push	OFFSET _cl_logocolor
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2588 : 	Cvar_RegisterVariable( &cl_test_bandwidth );

	push	OFFSET _cl_test_bandwidth
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2589 : 
; 2590 : 	// register our variables
; 2591 : 	cl_crosshair = Cvar_Get( "crosshair", "1", FCVAR_ARCHIVE, "show weapon chrosshair" );

	push	OFFSET $SG145555
	push	1
	push	OFFSET $SG145556
	push	OFFSET $SG145557
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_crosshair, eax

; 2592 : 	cl_nodelta = Cvar_Get ("cl_nodelta", "0", 0, "disable delta-compression for server messages" );

	push	OFFSET $SG145558
	push	0
	push	OFFSET $SG145559
	push	OFFSET $SG145560
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_nodelta, eax

; 2593 : 	cl_idealpitchscale = Cvar_Get( "cl_idealpitchscale", "0.8", 0, "how much to look up/down slopes and stairs when not using freelook" );

	push	OFFSET $SG145561
	push	0
	push	OFFSET $SG145562
	push	OFFSET $SG145563
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_idealpitchscale, eax

; 2594 : 	cl_solid_players = Cvar_Get( "cl_solid_players", "1", 0, "Make all players not solid (can't traceline them)" );

	push	OFFSET $SG145564
	push	0
	push	OFFSET $SG145565
	push	OFFSET $SG145566
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_solid_players, eax

; 2595 : 	cl_interp = Cvar_Get( "ex_interp", "0.1", FCVAR_ARCHIVE, "Interpolate object positions starting this many seconds in past" ); 

	push	OFFSET $SG145567
	push	1
	push	OFFSET $SG145568
	push	OFFSET $SG145569
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_interp, eax

; 2596 : 	cl_timeout = Cvar_Get( "cl_timeout", "60", 0, "connect timeout (in-seconds)" );

	push	OFFSET $SG145570
	push	0
	push	OFFSET $SG145571
	push	OFFSET $SG145572
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_timeout, eax

; 2597 : 
; 2598 : 	rcon_client_password = Cvar_Get( "rcon_password", "", 0, "remote control client password" );

	push	OFFSET $SG145573
	push	0
	push	OFFSET $SG145574
	push	OFFSET $SG145575
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rcon_client_password, eax

; 2599 : 	rcon_address = Cvar_Get( "rcon_address", "", 0, "remote control address" );

	push	OFFSET $SG145576
	push	0
	push	OFFSET $SG145577
	push	OFFSET $SG145578
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rcon_address, eax

; 2600 : 
; 2601 : 	// userinfo
; 2602 : 	cl_nopred = Cvar_Get( "cl_nopred", "0", FCVAR_ARCHIVE|FCVAR_USERINFO, "disable client movement prediction" );

	push	OFFSET $SG145579
	push	3
	push	OFFSET $SG145580
	push	OFFSET $SG145581
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_nopred, eax

; 2603 : 	name = Cvar_Get( "name", Sys_GetCurrentUser(), FCVAR_USERINFO|FCVAR_ARCHIVE|FCVAR_PRINTABLEONLY, "player name" );

	push	OFFSET $SG145582
	push	131					; 00000083H
	call	_Sys_GetCurrentUser
	push	eax
	push	OFFSET $SG145583
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _name, eax

; 2604 : 	model = Cvar_Get( "model", "", FCVAR_USERINFO|FCVAR_ARCHIVE, "player model ('player' is a singleplayer model)" );

	push	OFFSET $SG145584
	push	3
	push	OFFSET $SG145585
	push	OFFSET $SG145586
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _model, eax

; 2605 : 	cl_updaterate = Cvar_Get( "cl_updaterate", "20", FCVAR_USERINFO|FCVAR_ARCHIVE, "refresh rate of server messages" );

	push	OFFSET $SG145587
	push	3
	push	OFFSET $SG145588
	push	OFFSET $SG145589
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_updaterate, eax

; 2606 : 	cl_dlmax = Cvar_Get( "cl_dlmax", "0", FCVAR_USERINFO|FCVAR_ARCHIVE, "max allowed fragment size on download resources" );

	push	OFFSET $SG145590
	push	3
	push	OFFSET $SG145591
	push	OFFSET $SG145592
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_dlmax, eax

; 2607 : 	rate = Cvar_Get( "rate", "3500", FCVAR_USERINFO|FCVAR_ARCHIVE, "player network rate" );

	push	OFFSET $SG145593
	push	3
	push	OFFSET $SG145594
	push	OFFSET $SG145595
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rate, eax

; 2608 : 	topcolor = Cvar_Get( "topcolor", "0", FCVAR_USERINFO|FCVAR_ARCHIVE, "player top color" );

	push	OFFSET $SG145596
	push	3
	push	OFFSET $SG145597
	push	OFFSET $SG145598
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _topcolor, eax

; 2609 : 	bottomcolor = Cvar_Get( "bottomcolor", "0", FCVAR_USERINFO|FCVAR_ARCHIVE, "player bottom color" );

	push	OFFSET $SG145599
	push	3
	push	OFFSET $SG145600
	push	OFFSET $SG145601
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _bottomcolor, eax

; 2610 : 	cl_lw = Cvar_Get( "cl_lw", "1", FCVAR_ARCHIVE|FCVAR_USERINFO, "enable client weapon predicting" );

	push	OFFSET $SG145602
	push	3
	push	OFFSET $SG145603
	push	OFFSET $SG145604
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_lw, eax

; 2611 : 	Cvar_Get( "cl_lc", "1", FCVAR_ARCHIVE|FCVAR_USERINFO, "enable lag compensation" );

	push	OFFSET $SG145605
	push	3
	push	OFFSET $SG145606
	push	OFFSET $SG145607
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2612 : 	Cvar_Get( "password", "", FCVAR_USERINFO, "server password" );

	push	OFFSET $SG145608
	push	2
	push	OFFSET $SG145609
	push	OFFSET $SG145610
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2613 : 	Cvar_Get( "team", "", FCVAR_USERINFO, "player team" );

	push	OFFSET $SG145611
	push	2
	push	OFFSET $SG145612
	push	OFFSET $SG145613
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2614 : 	Cvar_Get( "skin", "", FCVAR_USERINFO, "player skin" );

	push	OFFSET $SG145614
	push	2
	push	OFFSET $SG145615
	push	OFFSET $SG145616
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2615 : 
; 2616 : 	cl_showfps = Cvar_Get( "cl_showfps", "1", FCVAR_ARCHIVE, "show client fps" );

	push	OFFSET $SG145617
	push	1
	push	OFFSET $SG145618
	push	OFFSET $SG145619
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_showfps, eax

; 2617 : 	cl_nosmooth = Cvar_Get( "cl_nosmooth", "0", FCVAR_ARCHIVE, "disable smooth up stair climbing and interpolate position in multiplayer" );

	push	OFFSET $SG145620
	push	1
	push	OFFSET $SG145621
	push	OFFSET $SG145622
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_nosmooth, eax

; 2618 : 	cl_smoothtime = Cvar_Get( "cl_smoothtime", "0", FCVAR_ARCHIVE, "time to smooth up" );

	push	OFFSET $SG145623
	push	1
	push	OFFSET $SG145624
	push	OFFSET $SG145625
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_smoothtime, eax

; 2619 : 	cl_cmdbackup = Cvar_Get( "cl_cmdbackup", "10", FCVAR_ARCHIVE, "how many additional history commands are sent" );

	push	OFFSET $SG145626
	push	1
	push	OFFSET $SG145627
	push	OFFSET $SG145628
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_cmdbackup, eax

; 2620 : 	cl_cmdrate = Cvar_Get( "cl_cmdrate", "30", FCVAR_ARCHIVE, "Max number of command packets sent to server per second" );

	push	OFFSET $SG145629
	push	1
	push	OFFSET $SG145630
	push	OFFSET $SG145631
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_cmdrate, eax

; 2621 : 	cl_draw_particles = Cvar_Get( "r_drawparticles", "1", FCVAR_CHEAT, "render particles" );

	push	OFFSET $SG145632
	push	32768					; 00008000H
	push	OFFSET $SG145633
	push	OFFSET $SG145634
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_draw_particles, eax

; 2622 : 	cl_draw_tracers = Cvar_Get( "r_drawtracers", "1", FCVAR_CHEAT, "render tracers" );

	push	OFFSET $SG145635
	push	32768					; 00008000H
	push	OFFSET $SG145636
	push	OFFSET $SG145637
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_draw_tracers, eax

; 2623 : 	cl_draw_beams = Cvar_Get( "r_drawbeams", "1", FCVAR_CHEAT, "render beams" );

	push	OFFSET $SG145638
	push	32768					; 00008000H
	push	OFFSET $SG145639
	push	OFFSET $SG145640
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_draw_beams, eax

; 2624 : 	cl_lightstyle_lerping = Cvar_Get( "cl_lightstyle_lerping", "0", FCVAR_ARCHIVE, "enables animated light lerping (perfomance option)" );

	push	OFFSET $SG145641
	push	1
	push	OFFSET $SG145642
	push	OFFSET $SG145643
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_lightstyle_lerping, eax

; 2625 : 	cl_showerror = Cvar_Get( "cl_showerror", "0", FCVAR_ARCHIVE, "show prediction error" );

	push	OFFSET $SG145644
	push	1
	push	OFFSET $SG145645
	push	OFFSET $SG145646
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_showerror, eax

; 2626 : 	cl_bmodelinterp = Cvar_Get( "cl_bmodelinterp", "1", FCVAR_ARCHIVE, "enable bmodel interpolation" );

	push	OFFSET $SG145647
	push	1
	push	OFFSET $SG145648
	push	OFFSET $SG145649
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_bmodelinterp, eax

; 2627 : 	cl_clockreset = Cvar_Get( "cl_clockreset", "0.1", FCVAR_ARCHIVE, "frametime delta maximum value before reset" );

	push	OFFSET $SG145650
	push	1
	push	OFFSET $SG145651
	push	OFFSET $SG145652
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_clockreset, eax

; 2628 : 	cl_fixtimerate = Cvar_Get( "cl_fixtimerate", "7.5", FCVAR_ARCHIVE, "time in msec to client clock adjusting" );

	push	OFFSET $SG145653
	push	1
	push	OFFSET $SG145654
	push	OFFSET $SG145655
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_fixtimerate, eax

; 2629 : 	Cvar_Get( "hud_scale", "0", FCVAR_ARCHIVE|FCVAR_LATCH, "scale hud at current resolution" );

	push	OFFSET $SG145656
	push	2049					; 00000801H
	push	OFFSET $SG145657
	push	OFFSET $SG145658
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2630 : 	Cvar_Get( "cl_background", "0", FCVAR_READ_ONLY, "indicate what background map is running" );

	push	OFFSET $SG145659
	push	131072					; 00020000H
	push	OFFSET $SG145660
	push	OFFSET $SG145661
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2631 : 	cl_showevents = Cvar_Get( "cl_showevents", "0", FCVAR_ARCHIVE, "show events playback" );

	push	OFFSET $SG145662
	push	1
	push	OFFSET $SG145663
	push	OFFSET $SG145664
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_showevents, eax

; 2632 : 	Cvar_Get( "lastdemo", "", FCVAR_ARCHIVE, "last played demo" );

	push	OFFSET $SG145665
	push	1
	push	OFFSET $SG145666
	push	OFFSET $SG145667
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2633 : 
; 2634 : 	// these two added to shut up CS 1.5 about 'unknown' commands
; 2635 : 	Cvar_Get( "lightgamma", "1", FCVAR_ARCHIVE, "ambient lighting level (legacy, unused)" );

	push	OFFSET $SG145668
	push	1
	push	OFFSET $SG145669
	push	OFFSET $SG145670
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2636 : 	Cvar_Get( "direct", "1", FCVAR_ARCHIVE, "direct lighting level (legacy, unused)" );

	push	OFFSET $SG145671
	push	1
	push	OFFSET $SG145672
	push	OFFSET $SG145673
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2637 : 
; 2638 : 	// server commands
; 2639 : 	Cmd_AddCommand ("noclip", NULL, "enable or disable no clipping mode" );

	push	OFFSET $SG145674
	push	0
	push	OFFSET $SG145675
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2640 : 	Cmd_AddCommand ("notarget", NULL, "notarget mode (monsters do not see you)" );

	push	OFFSET $SG145676
	push	0
	push	OFFSET $SG145677
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2641 : 	Cmd_AddCommand ("fullupdate", NULL, "re-init HUD on start demo recording" );

	push	OFFSET $SG145678
	push	0
	push	OFFSET $SG145679
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2642 : 	Cmd_AddCommand ("give", NULL, "give specified item or weapon" );

	push	OFFSET $SG145680
	push	0
	push	OFFSET $SG145681
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2643 : 	Cmd_AddCommand ("drop", NULL, "drop current/specified item or weapon" );

	push	OFFSET $SG145682
	push	0
	push	OFFSET $SG145683
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2644 : 	Cmd_AddCommand ("gametitle", NULL, "show game logo" );

	push	OFFSET $SG145684
	push	0
	push	OFFSET $SG145685
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2645 : 	Cmd_AddCommand( "kill", NULL, "die instantly" );

	push	OFFSET $SG145686
	push	0
	push	OFFSET $SG145687
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2646 : 	Cmd_AddCommand ("god", NULL, "enable godmode" );

	push	OFFSET $SG145688
	push	0
	push	OFFSET $SG145689
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2647 : 	Cmd_AddCommand ("fov", NULL, "set client field of view" );

	push	OFFSET $SG145690
	push	0
	push	OFFSET $SG145691
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2648 : 	Cmd_AddCommand ("log", NULL, "logging server events" );

	push	OFFSET $SG145692
	push	0
	push	OFFSET $SG145693
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2649 : 		
; 2650 : 	// register our commands
; 2651 : 	Cmd_AddCommand ("pause", NULL, "pause the game (if the server allows pausing)" );

	push	OFFSET $SG145694
	push	0
	push	OFFSET $SG145695
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2652 : 	Cmd_AddCommand ("localservers", CL_LocalServers_f, "collect info about local servers" );

	push	OFFSET $SG145696
	push	OFFSET _CL_LocalServers_f
	push	OFFSET $SG145697
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2653 : 	Cmd_AddCommand ("internetservers", CL_InternetServers_f, "collect info about internet servers" );

	push	OFFSET $SG145698
	push	OFFSET _CL_InternetServers_f
	push	OFFSET $SG145699
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2654 : 	Cmd_AddCommand ("cd", CL_PlayCDTrack_f, "Play cd-track (not real cd-player of course)" );

	push	OFFSET $SG145700
	push	OFFSET _CL_PlayCDTrack_f
	push	OFFSET $SG145701
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2655 : 	Cmd_AddCommand ("mp3", CL_PlayCDTrack_f, "Play mp3-track (based on virtual cd-player)" );

	push	OFFSET $SG145702
	push	OFFSET _CL_PlayCDTrack_f
	push	OFFSET $SG145703
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2656 : 
; 2657 : 	Cmd_AddCommand ("setinfo", CL_SetInfo_f, "examine or change the userinfo string (alias of userinfo)" );

	push	OFFSET $SG145704
	push	OFFSET _CL_SetInfo_f
	push	OFFSET $SG145705
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2658 : 	Cmd_AddCommand ("userinfo", CL_SetInfo_f, "examine or change the userinfo string (alias of setinfo)" );

	push	OFFSET $SG145706
	push	OFFSET _CL_SetInfo_f
	push	OFFSET $SG145707
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2659 : 	Cmd_AddCommand ("physinfo", CL_Physinfo_f, "print current client physinfo" );

	push	OFFSET $SG145708
	push	OFFSET _CL_Physinfo_f
	push	OFFSET $SG145709
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2660 : 	Cmd_AddCommand ("disconnect", CL_Disconnect_f, "disconnect from server" );

	push	OFFSET $SG145710
	push	OFFSET _CL_Disconnect_f
	push	OFFSET $SG145711
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2661 : 	Cmd_AddCommand ("record", CL_Record_f, "record a demo" );

	push	OFFSET $SG145712
	push	OFFSET _CL_Record_f
	push	OFFSET $SG145713
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2662 : 	Cmd_AddCommand ("playdemo", CL_PlayDemo_f, "play a demo" );

	push	OFFSET $SG145714
	push	OFFSET _CL_PlayDemo_f
	push	OFFSET $SG145715
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2663 : 	Cmd_AddCommand ("timedemo", CL_TimeDemo_f, "demo benchmark" );

	push	OFFSET $SG145716
	push	OFFSET _CL_TimeDemo_f
	push	OFFSET $SG145717
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2664 : 	Cmd_AddCommand ("killdemo", CL_DeleteDemo_f, "delete a specified demo file" );

	push	OFFSET $SG145718
	push	OFFSET _CL_DeleteDemo_f
	push	OFFSET $SG145719
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2665 : 	Cmd_AddCommand ("startdemos", CL_StartDemos_f, "start playing back the selected demos sequentially" );

	push	OFFSET $SG145720
	push	OFFSET _CL_StartDemos_f
	push	OFFSET $SG145721
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2666 : 	Cmd_AddCommand ("demos", CL_Demos_f, "restart looping demos defined by the last startdemos command" );

	push	OFFSET $SG145722
	push	OFFSET _CL_Demos_f
	push	OFFSET $SG145723
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2667 : 	Cmd_AddCommand ("movie", CL_PlayVideo_f, "play a movie" );

	push	OFFSET $SG145724
	push	OFFSET _CL_PlayVideo_f
	push	OFFSET $SG145725
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2668 : 	Cmd_AddCommand ("stop", CL_Stop_f, "stop playing or recording a demo" );

	push	OFFSET $SG145726
	push	OFFSET _CL_Stop_f
	push	OFFSET $SG145727
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2669 : 	Cmd_AddCommand ("info", NULL, "collect info about local servers with specified protocol" );

	push	OFFSET $SG145728
	push	0
	push	OFFSET $SG145729
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2670 : 	Cmd_AddCommand ("escape", CL_Escape_f, "escape from game to menu" );

	push	OFFSET $SG145730
	push	OFFSET _CL_Escape_f
	push	OFFSET $SG145731
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2671 : 	Cmd_AddCommand ("togglemenu", CL_Escape_f, "toggle between game and menu" );

	push	OFFSET $SG145732
	push	OFFSET _CL_Escape_f
	push	OFFSET $SG145733
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2672 : 	Cmd_AddCommand ("pointfile", CL_ReadPointFile_f, "show leaks on a map (if present of course)" );

	push	OFFSET $SG145734
	push	OFFSET _CL_ReadPointFile_f
	push	OFFSET $SG145735
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2673 : 	Cmd_AddCommand ("linefile", CL_ReadLineFile_f, "show leaks on a map (if present of course)" );

	push	OFFSET $SG145736
	push	OFFSET _CL_ReadLineFile_f
	push	OFFSET $SG145737
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2674 : 	Cmd_AddCommand ("fullserverinfo", CL_FullServerinfo_f, "sent by server when serverinfo changes" );

	push	OFFSET $SG145738
	push	OFFSET _CL_FullServerinfo_f
	push	OFFSET $SG145739
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2675 : 	Cmd_AddCommand ("upload", CL_BeginUpload_f, "uploading file to the server" );

	push	OFFSET $SG145740
	push	OFFSET _CL_BeginUpload_f
	push	OFFSET $SG145741
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2676 : 	
; 2677 : 	Cmd_AddCommand ("quit", CL_Quit_f, "quit from game" );

	push	OFFSET $SG145742
	push	OFFSET _CL_Quit_f
	push	OFFSET $SG145743
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2678 : 	Cmd_AddCommand ("exit", CL_Quit_f, "quit from game" );

	push	OFFSET $SG145744
	push	OFFSET _CL_Quit_f
	push	OFFSET $SG145745
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2679 : 
; 2680 : 	Cmd_AddCommand ("screenshot", CL_ScreenShot_f, "takes a screenshot of the next rendered frame" );

	push	OFFSET $SG145746
	push	OFFSET _CL_ScreenShot_f
	push	OFFSET $SG145747
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2681 : 	Cmd_AddCommand ("snapshot", CL_SnapShot_f, "takes a snapshot of the next rendered frame" );

	push	OFFSET $SG145748
	push	OFFSET _CL_SnapShot_f
	push	OFFSET $SG145749
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2682 : 	Cmd_AddCommand ("envshot", CL_EnvShot_f, "takes a six-sides cubemap shot with specified name" );

	push	OFFSET $SG145750
	push	OFFSET _CL_EnvShot_f
	push	OFFSET $SG145751
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2683 : 	Cmd_AddCommand ("skyshot", CL_SkyShot_f, "takes a six-sides envmap (skybox) shot with specified name" );

	push	OFFSET $SG145752
	push	OFFSET _CL_SkyShot_f
	push	OFFSET $SG145753
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2684 : 	Cmd_AddCommand ("levelshot", CL_LevelShot_f, "same as \"screenshot\", used for create plaque images" );

	push	OFFSET $SG145754
	push	OFFSET _CL_LevelShot_f
	push	OFFSET $SG145755
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2685 : 	Cmd_AddCommand ("saveshot", CL_SaveShot_f, "used for create save previews with LoadGame menu" );

	push	OFFSET $SG145756
	push	OFFSET _CL_SaveShot_f
	push	OFFSET $SG145757
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2686 : 
; 2687 : 	Cmd_AddCommand ("connect", CL_Connect_f, "connect to a server by hostname" );

	push	OFFSET $SG145758
	push	OFFSET _CL_Connect_f
	push	OFFSET $SG145759
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2688 : 	Cmd_AddCommand ("reconnect", CL_Reconnect_f, "reconnect to current level" );

	push	OFFSET $SG145760
	push	OFFSET _CL_Reconnect_f
	push	OFFSET $SG145761
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2689 : 
; 2690 : 	Cmd_AddCommand ("rcon", CL_Rcon_f, "sends a command to the server console (rcon_password and rcon_address required)" );

	push	OFFSET $SG145762
	push	OFFSET _CL_Rcon_f
	push	OFFSET $SG145763
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2691 : }

	pop	ebp
	ret	0
_CL_InitLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Escape_f PROC

; 2555 : {

	push	ebp
	mov	ebp, esp

; 2556 : 	if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN2@CL_Escape_

; 2557 : 		return;

	jmp	SHORT $LN1@CL_Escape_
$LN2@CL_Escape_:

; 2558 : 
; 2559 : 	// the final credits is running
; 2560 : 	if( UI_CreditsActive( )) return;

	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN3@CL_Escape_
	jmp	SHORT $LN1@CL_Escape_
$LN3@CL_Escape_:

; 2561 : 
; 2562 : 	if( cls.state == ca_cinematic )

	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN4@CL_Escape_

; 2563 : 		SCR_NextMovie(); // jump to next movie

	call	_SCR_NextMovie
	jmp	SHORT $LN1@CL_Escape_
$LN4@CL_Escape_:

; 2564 : 	else UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN1@CL_Escape_:

; 2565 : }

	pop	ebp
	ret	0
_CL_Escape_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_FullServerinfo_f PROC

; 2537 : {

	push	ebp
	mov	ebp, esp

; 2538 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@CL_FullSer

; 2539 : 	{
; 2540 : 		Con_Printf( S_USAGE "fullserverinfo <complete info string>\n" );

	push	OFFSET $SG145532
	call	_Con_Printf
	add	esp, 4

; 2541 : 		return;

	jmp	SHORT $LN1@CL_FullSer
$LN2@CL_FullSer:

; 2542 : 	}
; 2543 : 
; 2544 : 	Q_strncpy( cl.serverinfo, Cmd_Argv( 1 ), sizeof( cl.serverinfo ));

	push	512					; 00000200H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET _cl+1525868
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@CL_FullSer:

; 2545 : }

	pop	ebp
	ret	0
_CL_FullServerinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Physinfo_f PROC

; 2382 : {

	push	ebp
	mov	ebp, esp

; 2383 : 	Con_Printf( "Phys info settings:\n" );

	push	OFFSET $SG145478
	call	_Con_Printf
	add	esp, 4

; 2384 : 	Info_Print( cls.physinfo );

	push	OFFSET _cls+6860
	call	_Info_Print
	add	esp, 4

; 2385 : 	Con_Printf( "Total %i symbols\n", Q_strlen( cls.physinfo ));

	push	OFFSET _cls+6860
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET $SG145479
	call	_Con_Printf
	add	esp, 8

; 2386 : }

	pop	ebp
	ret	0
_CL_Physinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_var$ = -4						; size = 4
_CL_SetInfo_f PROC

; 2342 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2343 : 	convar_t	*var;
; 2344 : 
; 2345 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@CL_SetInfo

; 2346 : 	{
; 2347 : 		Con_Printf( "User info settings:\n" );

	push	OFFSET $SG145468
	call	_Con_Printf
	add	esp, 4

; 2348 : 		Info_Print( cls.userinfo );

	push	OFFSET _cls+6604
	call	_Info_Print
	add	esp, 4

; 2349 : 		Con_Printf( "Total %i symbols\n", Q_strlen( cls.userinfo ));

	push	OFFSET _cls+6604
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET $SG145469
	call	_Con_Printf
	add	esp, 8

; 2350 : 		return;

	jmp	$LN1@CL_SetInfo
$LN2@CL_SetInfo:

; 2351 : 	}
; 2352 : 
; 2353 : 	if( Cmd_Argc() != 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	je	SHORT $LN3@CL_SetInfo

; 2354 : 	{
; 2355 : 		Con_Printf( S_USAGE "setinfo [ <key> <value> ]\n" );

	push	OFFSET $SG145471
	call	_Con_Printf
	add	esp, 4

; 2356 : 		return;

	jmp	SHORT $LN1@CL_SetInfo
$LN3@CL_SetInfo:

; 2357 : 	}
; 2358 : 
; 2359 : 	// NOTE: some userinfo comed from cvars, e.g. cl_lw but we can call "setinfo cl_lw 1"
; 2360 : 	// without real cvar changing. So we need to lookup for cvar first to make sure what
; 2361 : 	// our key is not linked with console variable
; 2362 : 	var = Cvar_FindVar( Cmd_Argv( 1 ));

	push	0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _var$[ebp], eax

; 2363 : 
; 2364 : 	// make sure what cvar is existed and really part of userinfo
; 2365 : 	if( var && FBitSet( var->flags, FCVAR_USERINFO ))

	cmp	DWORD PTR _var$[ebp], 0
	je	SHORT $LN4@CL_SetInfo
	mov	eax, DWORD PTR _var$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	SHORT $LN4@CL_SetInfo

; 2366 : 	{
; 2367 : 		Cvar_DirectSet( var, Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _var$[ebp]
	push	edx
	call	_Cvar_DirectSet
	add	esp, 8

; 2368 : 	}

	jmp	SHORT $LN1@CL_SetInfo
$LN4@CL_SetInfo:

; 2369 : 	else if( Info_SetValueForKey( cls.userinfo, Cmd_Argv( 1 ), Cmd_Argv( 2 ), MAX_INFO_STRING ))

	push	256					; 00000100H
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET _cls+6604
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@CL_SetInfo

; 2370 : 	{
; 2371 : 		// send update only on successfully changed userinfo
; 2372 : 		Cmd_ForwardToServer ();

	call	_Cmd_ForwardToServer
$LN1@CL_SetInfo:

; 2373 : 	}
; 2374 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_player$1 = -12						; size = 4
_bFound$ = -8						; size = 4
_pList$ = -4						; size = 4
_resource$ = 8						; size = 4
_CL_RegisterCustomization PROC

; 2154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2155 : 	qboolean		bFound = false;

	mov	DWORD PTR _bFound$[ebp], 0

; 2156 : 	customization_t	*pList;
; 2157 : 
; 2158 : 	for( pList = cl.players[resource->playernum].customdata.pNext; pList; pList = pList->pNext )

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	imul	edx, ecx, 584
	mov	eax, DWORD PTR _cl[edx+1543712]
	mov	DWORD PTR _pList$[ebp], eax
	jmp	SHORT $LN4@CL_Registe
$LN2@CL_Registe:
	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR _pList$[ebp], edx
$LN4@CL_Registe:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN3@CL_Registe

; 2159 : 	{
; 2160 : 		if( !memcmp( pList->resource.rgucMD5_hash, resource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _resource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@CL_Registe

; 2161 : 		{
; 2162 : 			bFound = true;

	mov	DWORD PTR _bFound$[ebp], 1

; 2163 : 			break;

	jmp	SHORT $LN3@CL_Registe
$LN5@CL_Registe:

; 2164 : 		}
; 2165 : 	}

	jmp	SHORT $LN2@CL_Registe
$LN3@CL_Registe:

; 2166 : 
; 2167 : 	if( !bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	jne	SHORT $LN6@CL_Registe

; 2168 : 	{
; 2169 : 		player_info_t	*player =  &cl.players[resource->playernum];

	mov	edx, DWORD PTR _resource$[ebp]
	movzx	eax, BYTE PTR [edx+93]
	imul	ecx, eax, 584
	add	ecx, OFFSET _cl+1543148
	mov	DWORD PTR _player$1[ebp], ecx

; 2170 : 
; 2171 : 		if( !COM_CreateCustomization( &player->customdata, resource, resource->playernum, FCUST_FROMHPAK, NULL, NULL ))

	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _resource$[ebp]
	movzx	eax, BYTE PTR [edx+93]
	push	eax
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$1[ebp]
	add	edx, 404				; 00000194H
	push	edx
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN8@CL_Registe

; 2172 : 			Con_Printf( "Unable to create custom decal for player %i\n", resource->playernum );

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	push	ecx
	push	OFFSET $SG145386
	call	_Con_Printf
	add	esp, 8
$LN8@CL_Registe:

; 2173 : 	}

	jmp	SHORT $LN1@CL_Registe
$LN6@CL_Registe:

; 2174 : 	else
; 2175 : 	{
; 2176 : 		Con_DPrintf( "Duplicate resource received and ignored.\n" );

	push	OFFSET $SG145387
	call	_Con_DPrintf
	add	esp, 4
$LN1@CL_Registe:

; 2177 : 	}
; 2178 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_pfilename$ = -4					; size = 4
_filename$ = 8						; size = 4
_CL_CleanFileName PROC

; 2137 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2138 : 	const char	*pfilename = filename;

	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _pfilename$[ebp], eax

; 2139 : 
; 2140 : 	if( COM_CheckString( filename ) && filename[0] == '!' )

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_CleanFi
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN2@CL_CleanFi

; 2141 : 		pfilename = "customization";

	mov	DWORD PTR _pfilename$[ebp], OFFSET $SG145369
$LN2@CL_CleanFi:

; 2142 : 	return pfilename;

	mov	eax, DWORD PTR _pfilename$[ebp]

; 2143 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CleanFileName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_checktime$1 = -16					; size = 8
tv74 = -8						; size = 8
_CL_ReadPackets PROC

; 2073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2074 : 	// decide the simulation time
; 2075 : 	cl.oldtime = cl.time;

	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR _cl+1525856, xmm0

; 2076 : 
; 2077 : 	if( cls.demoplayback != DEMO_XASH3D && !cl.paused )

	cmp	DWORD PTR _cls+297580, 1
	je	SHORT $LN2@CL_ReadPac
	cmp	DWORD PTR _cl+24, 0
	jne	SHORT $LN2@CL_ReadPac

; 2078 : 		cl.time += host.frametime;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _cl+1525848, xmm0
$LN2@CL_ReadPac:

; 2079 : 
; 2080 : 	// demo time
; 2081 : 	if( cls.demorecording && !cls.demowaiting )

	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN3@CL_ReadPac
	cmp	DWORD PTR _cls+297584, 0
	jne	SHORT $LN3@CL_ReadPac

; 2082 : 		cls.demotime += host.frametime;

	movsd	xmm0, QWORD PTR _cls+297848
	addsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _cls+297848, xmm0
$LN3@CL_ReadPac:

; 2083 : 
; 2084 : 	CL_ReadNetMessage();

	call	_CL_ReadNetMessage

; 2085 : 
; 2086 : 	CL_ApplyAddAngle();

	call	_CL_ApplyAddAngle

; 2087 : #if 0
; 2088 : 	// keep cheat cvars are unchanged
; 2089 : 	if( cl.maxclients > 1 && cls.state == ca_active && !host_developer.value )
; 2090 : 		Cvar_SetCheatState();
; 2091 : #endif
; 2092 : 	// hot precache and downloading resources
; 2093 : 	if( cls.signon == SIGNONS && cl.lastresourcecheck < host.realtime )

	cmp	DWORD PTR _cls+64, 2
	jne	$LN4@CL_ReadPac
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR _cl+1561840
	jbe	SHORT $LN4@CL_ReadPac

; 2094 : 	{
; 2095 : 		double checktime = Host_IsLocalGame() ? 0.1 : 1.0;

	call	_Host_IsLocalGame
	test	eax, eax
	je	SHORT $LN11@CL_ReadPac
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	movsd	QWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN12@CL_ReadPac
$LN11@CL_ReadPac:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv74[ebp], xmm0
$LN12@CL_ReadPac:
	movsd	xmm0, QWORD PTR tv74[ebp]
	movsd	QWORD PTR _checktime$1[ebp], xmm0

; 2096 : 
; 2097 : 		if( !cls.dl.custom && cl.resourcesneeded.pNext != &cl.resourcesneeded )

	cmp	DWORD PTR _cls+293460, 0
	jne	SHORT $LN5@CL_ReadPac
	cmp	DWORD PTR _cl+1985124, OFFSET _cl+1984996
	je	SHORT $LN5@CL_ReadPac

; 2098 : 		{
; 2099 : 			// check resource for downloading and precache
; 2100 : 			CL_EstimateNeededResources();

	call	_CL_EstimateNeededResources

; 2101 : 			CL_BatchResourceRequest( false );

	push	0
	call	_CL_BatchResourceRequest
	add	esp, 4

; 2102 : 			cls.dl.doneregistering = false;

	mov	DWORD PTR _cls+293332, 0

; 2103 : 			cls.dl.custom = true;

	mov	DWORD PTR _cls+293460, 1
$LN5@CL_ReadPac:

; 2104 : 		}
; 2105 : 
; 2106 : 		cl.lastresourcecheck = host.realtime + checktime;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR _checktime$1[ebp]
	movsd	QWORD PTR _cl+1561840, xmm0
$LN4@CL_ReadPac:

; 2107 : 	}
; 2108 : 
; 2109 : 	// singleplayer never has connection timeout
; 2110 : 	if( NET_IsLocalAddress( cls.netchan.remote_address ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _cls+23524
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cls+23528
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cls+23532
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _cls+23536
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _cls+23540
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN6@CL_ReadPac

; 2111 : 		return;

	jmp	SHORT $LN9@CL_ReadPac
$LN6@CL_ReadPac:

; 2112 : 
; 2113 : 	// if in the debugger last frame, don't timeout
; 2114 : 	if( host.frametime > 5.0f ) cls.netchan.last_received = Sys_DoubleTime();

	movsd	xmm0, QWORD PTR _host+1448
	comisd	xmm0, QWORD PTR __real@4014000000000000
	jbe	SHORT $LN7@CL_ReadPac
	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+23552
$LN7@CL_ReadPac:

; 2115 :           
; 2116 : 	// check timeout
; 2117 : 	if( cls.state >= ca_connected && cls.state != ca_cinematic && !cls.demoplayback )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN9@CL_ReadPac
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN9@CL_ReadPac
	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN9@CL_ReadPac

; 2118 : 	{
; 2119 : 		if( host.realtime - cls.netchan.last_received > cl_timeout->value )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+23552
	mov	edx, DWORD PTR _cl_timeout
	cvtss2sd xmm1, DWORD PTR [edx+12]
	comisd	xmm0, xmm1
	jbe	SHORT $LN9@CL_ReadPac

; 2120 : 		{
; 2121 : 			Con_Printf( "\nServer connection timed out.\n" );

	push	OFFSET $SG145362
	call	_Con_Printf
	add	esp, 4

; 2122 : 			CL_Disconnect();

	call	_CL_Disconnect
$LN9@CL_ReadPac:

; 2123 : 			return;
; 2124 : 		}
; 2125 : 	}
; 2126 : 	
; 2127 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadPackets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_curSize$ = -4						; size = 4
_CL_ReadNetMessage PROC

; 1998 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@CL_ReadNet:

; 1999 : 	size_t	curSize;
; 2000 : 
; 2001 : 	while( CL_GetMessage( net_message_buffer, &curSize ))

	lea	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message_buffer
	call	_CL_GetMessage
	add	esp, 8
	test	eax, eax
	je	$LN3@CL_ReadNet

; 2002 : 	{
; 2003 : 		MSG_Init( &net_message, "ServerData", net_message_buffer, curSize );

	push	-1
	mov	ecx, DWORD PTR _curSize$[ebp]
	push	ecx
	push	OFFSET _net_message_buffer
	push	OFFSET $SG145336
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2004 : 
; 2005 : 		// check for connectionless packet (0xffffffff) first
; 2006 : 		if( MSG_GetMaxBytes( &net_message ) >= 4 && *(int *)net_message.pData == -1 )

	push	OFFSET _net_message
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	eax, 4
	jl	SHORT $LN4@CL_ReadNet
	mov	edx, DWORD PTR _net_message+8
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN4@CL_ReadNet

; 2007 : 		{
; 2008 : 			CL_ConnectionlessPacket( net_from, &net_message );

	push	OFFSET _net_message
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	call	_CL_ConnectionlessPacket
	add	esp, 24					; 00000018H

; 2009 : 			continue;

	jmp	$LN2@CL_ReadNet
$LN4@CL_ReadNet:

; 2010 : 		}
; 2011 : 
; 2012 : 		// can't be a valid sequenced packet	
; 2013 : 		if( cls.state < ca_connected ) continue;

	cmp	DWORD PTR _cls, 2
	jge	SHORT $LN5@CL_ReadNet
	jmp	$LN2@CL_ReadNet
$LN5@CL_ReadNet:

; 2014 : 
; 2015 : 		if( !cls.demoplayback && MSG_GetMaxBytes( &net_message ) < 8 )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN6@CL_ReadNet
	push	OFFSET _net_message
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN6@CL_ReadNet

; 2016 : 		{
; 2017 : 			Con_Printf( S_WARN "CL_ReadPackets: %s:runt packet\n", NET_AdrToString( net_from ));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _net_from
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _net_from+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _net_from+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _net_from+12
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _net_from+16
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145340
	call	_Con_Printf
	add	esp, 8

; 2018 : 			continue;

	jmp	$LN2@CL_ReadNet
$LN6@CL_ReadNet:

; 2019 : 		}
; 2020 : 
; 2021 : 		// packet from server
; 2022 : 		if( !cls.demoplayback && !NET_CompareAdr( net_from, cls.netchan.remote_address ))

	cmp	DWORD PTR _cls+297580, 0
	jne	$LN7@CL_ReadNet
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _cls+23524
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _cls+23528
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _cls+23532
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _cls+23536
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _cls+23540
	mov	DWORD PTR [ecx+16], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN7@CL_ReadNet

; 2023 : 		{
; 2024 : 			Con_DPrintf( S_ERROR "CL_ReadPackets: %s:sequenced packet without connection\n", NET_AdrToString( net_from ));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _net_from
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _net_from+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _net_from+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _net_from+12
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _net_from+16
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145342
	call	_Con_DPrintf
	add	esp, 8

; 2025 : 			continue;

	jmp	$LN2@CL_ReadNet
$LN7@CL_ReadNet:

; 2026 : 		}
; 2027 : 
; 2028 : 		if( !cls.demoplayback && !Netchan_Process( &cls.netchan, &net_message ))

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN8@CL_ReadNet
	push	OFFSET _net_message
	push	OFFSET _cls+23520
	call	_Netchan_Process
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@CL_ReadNet

; 2029 : 			continue;	// wasn't accepted for some reason

	jmp	$LN2@CL_ReadNet
$LN8@CL_ReadNet:

; 2030 : 
; 2031 : 		// run special handler for quake demos
; 2032 : 		if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	SHORT $LN9@CL_ReadNet

; 2033 : 			CL_ParseQuakeMessage( &net_message, true );

	push	1
	push	OFFSET _net_message
	call	_CL_ParseQuakeMessage
	add	esp, 8
	jmp	SHORT $LN10@CL_ReadNet
$LN9@CL_ReadNet:

; 2034 : 		else CL_ParseServerMessage( &net_message, true );

	push	1
	push	OFFSET _net_message
	call	_CL_ParseServerMessage
	add	esp, 8
$LN10@CL_ReadNet:

; 2035 : 		cl.send_reply = true;

	mov	DWORD PTR _cl+60, 1

; 2036 : 	}

	jmp	$LN2@CL_ReadNet
$LN3@CL_ReadNet:

; 2037 : 
; 2038 : 	// build list of all solid entities per next frame (exclude clients)
; 2039 : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 2040 : 
; 2041 : 	// check for fragmentation/reassembly related packets.
; 2042 : 	if( cls.state != ca_disconnected && Netchan_IncomingReady( &cls.netchan ))

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN11@CL_ReadNet
	push	OFFSET _cls+23520
	call	_Netchan_IncomingReady
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@CL_ReadNet

; 2043 : 	{
; 2044 : 		// process the incoming buffer(s)
; 2045 : 		if( Netchan_CopyNormalFragments( &cls.netchan, &net_message, &curSize ))

	lea	ecx, DWORD PTR _curSize$[ebp]
	push	ecx
	push	OFFSET _net_message
	push	OFFSET _cls+23520
	call	_Netchan_CopyNormalFragments
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@CL_ReadNet

; 2046 : 		{
; 2047 : 			MSG_Init( &net_message, "ServerData", net_message_buffer, curSize );

	push	-1
	mov	edx, DWORD PTR _curSize$[ebp]
	push	edx
	push	OFFSET _net_message_buffer
	push	OFFSET $SG145348
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2048 : 			CL_ParseServerMessage( &net_message, false );

	push	0
	push	OFFSET _net_message
	call	_CL_ParseServerMessage
	add	esp, 8
$LN12@CL_ReadNet:

; 2049 : 		}
; 2050 : 		
; 2051 : 		if( Netchan_CopyFileFragments( &cls.netchan, &net_message ))

	push	OFFSET _net_message
	push	OFFSET _cls+23520
	call	_Netchan_CopyFileFragments
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@CL_ReadNet

; 2052 : 		{
; 2053 : 			// remove from resource request stuff.
; 2054 : 			CL_ProcessFile( true, cls.netchan.incomingfilename );

	push	OFFSET _cls+285956
	push	1
	call	_CL_ProcessFile
	add	esp, 8
$LN11@CL_ReadNet:

; 2055 : 		}
; 2056 : 	}
; 2057 : 
; 2058 : 	Netchan_UpdateProgress( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_UpdateProgress
	add	esp, 4

; 2059 : 
; 2060 : 	// check requests for time-expire
; 2061 : 	CL_ProcessNetRequests();

	call	_CL_ProcessNetRequests

; 2062 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadNetMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_CL_GetMessage PROC

; 1979 : {

	push	ebp
	mov	ebp, esp

; 1980 : 	if( cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN2@CL_GetMess

; 1981 : 	{
; 1982 : 		if( CL_DemoReadMessage( data, length ))

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_CL_DemoReadMessage
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@CL_GetMess

; 1983 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_GetMess
$LN3@CL_GetMess:

; 1984 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetMess
$LN2@CL_GetMess:

; 1985 : 	}
; 1986 : 
; 1987 : 	if( NET_GetPacket( NS_CLIENT, &net_from, data, length ))

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET _net_from
	push	0
	call	_NET_GetPacket
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@CL_GetMess

; 1988 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_GetMess
$LN4@CL_GetMess:

; 1989 : 	return false;

	xor	eax, eax
$LN1@CL_GetMess:

; 1990 : }

	pop	ebp
	ret	0
_CL_GetMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_dataoffset$ = -66632					; size = 4
_nr$1 = -66628						; size = 4
_prev$2 = -66624					; size = 4
_crcValue$3 = -66620					; size = 4
_crcValue2$4 = -66616					; size = 4
_realsize$5 = -66612					; size = 4
_len$ = -66608						; size = 4
_list$6 = -66604					; size = 4
_list$7 = -66600					; size = 4
_args$ = -66596						; size = 4
_nr$8 = -66592						; size = 4
_c$ = -66588						; size = 4
_servadr$ = -66584					; size = 20
_recv_buf$9 = -66564					; size = 65536
_buf$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_CL_ConnectionlessPacket PROC

; 1762 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 66632				; 00010448H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1763 : 	char	*args;
; 1764 : 	char	*c, buf[MAX_SYSPATH];
; 1765 : 	int	len = sizeof( buf );

	mov	DWORD PTR _len$[ebp], 1024		; 00000400H

; 1766 : 	int	dataoffset = 0;

	mov	DWORD PTR _dataoffset$[ebp], 0

; 1767 : 	netadr_t	servadr;
; 1768 : 	
; 1769 : 	MSG_Clear( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 1770 : 	MSG_ReadLong( msg ); // skip the -1

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4

; 1771 : 
; 1772 : 	args = MSG_ReadStringLine( msg );

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$[ebp], eax

; 1773 : 
; 1774 : 	Cmd_TokenizeString( args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 1775 : 	c = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 1776 : 
; 1777 : 	Con_Reportf( "CL_ConnectionlessPacket: %s : %s\n", NET_AdrToString( from ), c );

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145249
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 1778 : 
; 1779 : 	// server connection
; 1780 : 	if( !Q_strcmp( c, "client_connect" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145252
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_Connect

; 1781 : 	{
; 1782 : 		if( cls.state == ca_connected )

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN8@CL_Connect

; 1783 : 		{
; 1784 : 			Con_DPrintf( S_ERROR "dup connect received. ignored\n");

	push	OFFSET $SG145254
	call	_Con_DPrintf
	add	esp, 4

; 1785 : 			return;

	jmp	$LN43@CL_Connect
$LN8@CL_Connect:

; 1786 : 		}
; 1787 : 
; 1788 : 		CL_Reconnect( true );

	push	1
	call	_CL_Reconnect
	add	esp, 4

; 1789 : 		UI_SetActiveMenu( cl.background );

	mov	edx, DWORD PTR _cl+64
	push	edx
	call	_UI_SetActiveMenu
	add	esp, 4

; 1790 : 	}

	jmp	$LN43@CL_Connect
$LN6@CL_Connect:

; 1791 : 	else if( !Q_strcmp( c, "info" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145257
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_Connect

; 1792 : 	{
; 1793 : 		// server responding to a status broadcast
; 1794 : 		CL_ParseStatusMessage( from, msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_CL_ParseStatusMessage
	add	esp, 24					; 00000018H

; 1795 : 	}

	jmp	$LN43@CL_Connect
$LN9@CL_Connect:

; 1796 : 	else if( !Q_strcmp( c, "netinfo" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145260
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@CL_Connect

; 1797 : 	{
; 1798 : 		// server responding to a status broadcast
; 1799 : 		CL_ParseNETInfoMessage( from, msg, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_CL_ParseNETInfoMessage
	add	esp, 28					; 0000001cH

; 1800 : 	}

	jmp	$LN43@CL_Connect
$LN11@CL_Connect:

; 1801 : 	else if( !Q_strcmp( c, "cmd" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145263
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN13@CL_Connect

; 1802 : 	{
; 1803 : 		// remote command from gui front end
; 1804 : 		if( !NET_IsLocalAddress( from ))

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN15@CL_Connect

; 1805 : 		{
; 1806 : 			Con_Printf( "Command packet from remote host. Ignored.\n" );

	push	OFFSET $SG145265
	call	_Con_Printf
	add	esp, 4

; 1807 : 			return;

	jmp	$LN43@CL_Connect
$LN15@CL_Connect:

; 1808 : 		}
; 1809 : 
; 1810 : 		ShowWindow( host.hWnd, SW_RESTORE );

	push	9
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1811 : 		SetForegroundWindow ( host.hWnd );

	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__SetForegroundWindow@4

; 1812 : 		args = MSG_ReadString( msg );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$[ebp], eax

; 1813 : 		Cbuf_AddText( args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 1814 : 		Cbuf_AddText( "\n" );

	push	OFFSET $SG145266
	call	_Cbuf_AddText
	add	esp, 4

; 1815 : 	}

	jmp	$LN43@CL_Connect
$LN13@CL_Connect:

; 1816 : 	else if( !Q_strcmp( c, "print" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145269
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@CL_Connect

; 1817 : 	{
; 1818 : 		// print command from somewhere
; 1819 : 		Con_Printf( "%s", MSG_ReadString( msg ));

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET $SG145270
	call	_Con_Printf
	add	esp, 8

; 1820 : 	}

	jmp	$LN43@CL_Connect
$LN16@CL_Connect:

; 1821 : 	else if( !Q_strcmp( c, "testpacket" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145273
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN18@CL_Connect

; 1822 : 	{
; 1823 : 		byte	recv_buf[NET_MAX_FRAGMENT];
; 1824 : 		dword	crcValue = MSG_ReadLong( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _crcValue$3[ebp], eax

; 1825 : 		int	realsize = MSG_GetMaxBytes( msg ) - MSG_GetNumBytesRead( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetMaxBytes
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	esi, eax
	mov	DWORD PTR _realsize$5[ebp], esi

; 1826 : 		dword	crcValue2 = 0;

	mov	DWORD PTR _crcValue2$4[ebp], 0

; 1827 : 
; 1828 : 		if( cls.max_fragment_size != MSG_GetMaxBytes( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	DWORD PTR _cls+144, eax
	je	$LN20@CL_Connect

; 1829 : 		{
; 1830 : 			if( cls.connect_retry >= CL_TEST_RETRIES )

	cmp	DWORD PTR _cls+148, 5
	jl	SHORT $LN21@CL_Connect

; 1831 : 			{
; 1832 : 				// too many fails use default connection method
; 1833 : 				Con_Printf( "hi-speed connection is failed, use default method\n" );

	push	OFFSET $SG145276
	call	_Con_Printf
	add	esp, 4

; 1834 : 				Netchan_OutOfBandPrint( NS_CLIENT, from, "getchallenge\n" );

	push	OFFSET $SG145277
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	0
	call	_Netchan_OutOfBandPrint

; 1835 : 				Cvar_SetValue( "cl_dlmax", FRAGMENT_MIN_SIZE );

	add	esp, 24					; 00000018H
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145278
	call	_Cvar_SetValue
	add	esp, 8

; 1836 : 				cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1837 : 				return;

	jmp	$LN43@CL_Connect
$LN21@CL_Connect:

; 1838 : 			}
; 1839 : 
; 1840 : 			// if we waiting more than cl_timeout or packet was trashed
; 1841 : 			cls.connect_time = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0

; 1842 : 			return; // just wait for a next responce

	jmp	$LN43@CL_Connect
$LN20@CL_Connect:

; 1843 : 		}
; 1844 : 
; 1845 : 		// reading test buffer
; 1846 : 		MSG_ReadBytes( msg, recv_buf, realsize );

	mov	ecx, DWORD PTR _realsize$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _recv_buf$9[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1847 : 
; 1848 : 		// procssing the CRC
; 1849 : 		CRC32_ProcessBuffer( &crcValue2, recv_buf, realsize );

	mov	ecx, DWORD PTR _realsize$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _recv_buf$9[ebp]
	push	edx
	lea	eax, DWORD PTR _crcValue2$4[ebp]
	push	eax
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 1850 : 
; 1851 : 		if( crcValue == crcValue2 )

	mov	ecx, DWORD PTR _crcValue$3[ebp]
	cmp	ecx, DWORD PTR _crcValue2$4[ebp]
	jne	SHORT $LN22@CL_Connect

; 1852 : 		{
; 1853 : 			// packet was sucessfully delivered, adjust the fragment size and get challenge
; 1854 : 			Con_DPrintf( "CRC %p is matched, get challenge, fragment size %d\n", crcValue, cls.max_fragment_size );

	mov	edx, DWORD PTR _cls+144
	push	edx
	mov	eax, DWORD PTR _crcValue$3[ebp]
	push	eax
	push	OFFSET $SG145281
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1855 : 			Netchan_OutOfBandPrint( NS_CLIENT, from, "getchallenge\n" );

	push	OFFSET $SG145282
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1856 : 			Cvar_SetValue( "cl_dlmax", cls.max_fragment_size );

	cvtsi2ss xmm0, DWORD PTR _cls+144
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145283
	call	_Cvar_SetValue
	add	esp, 8

; 1857 : 			cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1858 : 		}

	jmp	$LN23@CL_Connect
$LN22@CL_Connect:

; 1859 : 		else
; 1860 : 		{
; 1861 : 			if( cls.connect_retry >= CL_TEST_RETRIES )

	cmp	DWORD PTR _cls+148, 5
	jl	SHORT $LN24@CL_Connect

; 1862 : 			{
; 1863 : 				// too many fails use default connection method
; 1864 : 				Con_Printf( "hi-speed connection is failed, use default method\n" );

	push	OFFSET $SG145285
	call	_Con_Printf
	add	esp, 4

; 1865 : 				Netchan_OutOfBandPrint( NS_CLIENT, from, "getchallenge\n" );

	push	OFFSET $SG145286
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint

; 1866 : 				Cvar_SetValue( "cl_dlmax", FRAGMENT_MIN_SIZE );

	add	esp, 24					; 00000018H
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145287
	call	_Cvar_SetValue
	add	esp, 8

; 1867 : 				cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1868 : 				return;

	jmp	$LN43@CL_Connect
$LN24@CL_Connect:

; 1869 : 			}
; 1870 : 
; 1871 : 			// trying the next size of packet
; 1872 : 			cls.connect_time = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0
$LN23@CL_Connect:

; 1873 : 		}
; 1874 : 	}

	jmp	$LN43@CL_Connect
$LN18@CL_Connect:

; 1875 : 	else if( !Q_strcmp( c, "ping" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145290
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@CL_Connect

; 1876 : 	{
; 1877 : 		// ping from somewhere
; 1878 : 		Netchan_OutOfBandPrint( NS_CLIENT, from, "ack" );

	push	OFFSET $SG145291
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1879 : 	}

	jmp	$LN43@CL_Connect
$LN25@CL_Connect:

; 1880 : 	else if( !Q_strcmp( c, "challenge" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145294
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@CL_Connect

; 1881 : 	{
; 1882 : 		// challenge from the server we are connecting to
; 1883 : 		cls.challenge = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _cls+287320, eax

; 1884 : 		CL_SendConnectPacket();

	call	_CL_SendConnectPacket

; 1885 : 		return;

	jmp	$LN43@CL_Connect

; 1886 : 	}

	jmp	$LN43@CL_Connect
$LN27@CL_Connect:

; 1887 : 	else if( !Q_strcmp( c, "echo" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145297
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@CL_Connect

; 1888 : 	{
; 1889 : 		// echo request from server
; 1890 : 		Netchan_OutOfBandPrint( NS_CLIENT, from, "%s", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG145298
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 1891 : 	}

	jmp	$LN43@CL_Connect
$LN29@CL_Connect:

; 1892 : 	else if( !Q_strcmp( c, "disconnect" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145301
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@CL_Connect

; 1893 : 	{
; 1894 : 		// a disconnect message from the server, which will happen if the server
; 1895 : 		// dropped the connection but it is still getting packets from us
; 1896 : 		CL_Disconnect_f();

	call	_CL_Disconnect_f

; 1897 : 	}

	jmp	$LN43@CL_Connect
$LN31@CL_Connect:

; 1898 : 	else if( !Q_strcmp( c, "f" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145304
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN33@CL_Connect
$LN2@CL_Connect:

; 1899 : 	{
; 1900 : 		// serverlist got from masterserver
; 1901 : 		while( MSG_GetNumBitsLeft( msg ) > 8 )

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jle	$LN3@CL_Connect

; 1902 : 		{
; 1903 : 			MSG_ReadBytes( msg, servadr.ip, sizeof( servadr.ip ));	// 4 bytes for IP

	push	4
	lea	eax, DWORD PTR _servadr$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1904 : 			servadr.port = MSG_ReadShort( msg );			// 2 bytes for Port

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	mov	WORD PTR _servadr$[ebp+18], ax

; 1905 : 			servadr.type = NA_IP;

	mov	DWORD PTR _servadr$[ebp], 3

; 1906 : 
; 1907 : 			// list is ends here
; 1908 : 			if( !servadr.port )

	movzx	eax, WORD PTR _servadr$[ebp+18]
	test	eax, eax
	jne	$LN35@CL_Connect

; 1909 : 			{
; 1910 : 				if( clgame.request_type == NET_REQUEST_CLIENT && clgame.master_request != NULL )

	cmp	DWORD PTR _clgame+144668, 2
	jne	$LN36@CL_Connect
	cmp	DWORD PTR _clgame+149792, 0
	je	$LN36@CL_Connect

; 1911 : 				{
; 1912 : 					net_request_t	*nr = clgame.master_request;

	mov	ecx, DWORD PTR _clgame+149792
	mov	DWORD PTR _nr$8[ebp], ecx

; 1913 : 					net_adrlist_t	*list, **prev;
; 1914 : 
; 1915 : 					// setup the answer
; 1916 : 					nr->resp.remote_address = from;

	mov	edx, DWORD PTR _nr$8[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax

; 1917 : 					nr->resp.error = NET_SUCCESS;

	mov	ecx, DWORD PTR _nr$8[ebp]
	mov	DWORD PTR [ecx], 0

; 1918 : 					nr->resp.ping = host.realtime - nr->timesend;

	mov	edx, DWORD PTR _nr$8[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [edx+64]
	mov	eax, DWORD PTR _nr$8[ebp]
	movsd	QWORD PTR [eax+32], xmm0

; 1919 : 
; 1920 : 					if( nr->timeout <= host.realtime )

	mov	ecx, DWORD PTR _nr$8[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [ecx+56]
	jb	SHORT $LN37@CL_Connect

; 1921 : 						SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	edx, DWORD PTR _nr$8[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR _nr$8[ebp]
	mov	DWORD PTR [ecx], eax
$LN37@CL_Connect:

; 1922 : 
; 1923 : 					Con_Printf( "serverlist call: %s\n", NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145308
	call	_Con_Printf
	add	esp, 8

; 1924 : 					nr->pfnFunc( &nr->resp );

	mov	ecx, DWORD PTR _nr$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _nr$8[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	add	esp, 4

; 1925 : 
; 1926 : 					// throw the list, now it will be stored in user area
; 1927 : 					prev = &((net_adrlist_t *)nr->resp.response);

	mov	ecx, DWORD PTR _nr$8[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _prev$2[ebp], ecx
$LN4@CL_Connect:

; 1928 : 
; 1929 : 					while( 1 )

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@CL_Connect

; 1930 : 					{
; 1931 : 						list = *prev;

	mov	eax, DWORD PTR _prev$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _list$7[ebp], ecx

; 1932 : 						if( !list ) break;

	cmp	DWORD PTR _list$7[ebp], 0
	jne	SHORT $LN38@CL_Connect
	jmp	SHORT $LN5@CL_Connect
$LN38@CL_Connect:

; 1933 : 
; 1934 : 						// throw out any variables the game created
; 1935 : 						*prev = list->next;

	mov	edx, DWORD PTR _prev$2[ebp]
	mov	eax, DWORD PTR _list$7[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 1936 : 						Mem_Free( list );

	push	1936					; 00000790H
	push	OFFSET $SG145310
	mov	edx, DWORD PTR _list$7[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1937 : 					}

	jmp	SHORT $LN4@CL_Connect
$LN5@CL_Connect:

; 1938 : 					memset( nr, 0, sizeof( *nr )); // done

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$8[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1939 : 					clgame.request_type = NET_REQUEST_CANCEL;

	mov	DWORD PTR _clgame+144668, 0

; 1940 : 					clgame.master_request = NULL;

	mov	DWORD PTR _clgame+149792, 0
$LN36@CL_Connect:

; 1941 : 				}
; 1942 : 				break;

	jmp	$LN3@CL_Connect
$LN35@CL_Connect:

; 1943 : 			}
; 1944 : 
; 1945 : 			if( clgame.request_type == NET_REQUEST_CLIENT && clgame.master_request != NULL )

	cmp	DWORD PTR _clgame+144668, 2
	jne	$LN39@CL_Connect
	cmp	DWORD PTR _clgame+149792, 0
	je	$LN39@CL_Connect

; 1946 : 			{
; 1947 : 				net_request_t	*nr = clgame.master_request;

	mov	ecx, DWORD PTR _clgame+149792
	mov	DWORD PTR _nr$1[ebp], ecx

; 1948 : 				net_adrlist_t	*list;
; 1949 : 
; 1950 : 				// adding addresses into list
; 1951 : 				list = Z_Malloc( sizeof( *list ));

	push	1951					; 0000079fH
	push	OFFSET $SG145313
	push	0
	push	24					; 00000018H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _list$6[ebp], eax

; 1952 : 				list->remote_address = servadr;

	mov	eax, DWORD PTR _list$6[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _servadr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _servadr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _servadr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _servadr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _servadr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 1953 : 				list->next = nr->resp.response;

	mov	edx, DWORD PTR _list$6[ebp]
	mov	eax, DWORD PTR _nr$1[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx], ecx

; 1954 : 				nr->resp.response = list;

	mov	edx, DWORD PTR _nr$1[ebp]
	mov	eax, DWORD PTR _list$6[ebp]
	mov	DWORD PTR [edx+40], eax

; 1955 : 			}

	jmp	SHORT $LN41@CL_Connect
$LN39@CL_Connect:

; 1956 : 			else if( clgame.request_type == NET_REQUEST_GAMEUI )

	cmp	DWORD PTR _clgame+144668, 1
	jne	SHORT $LN41@CL_Connect

; 1957 : 			{
; 1958 : 				NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1959 : 				Netchan_OutOfBandPrint( NS_CLIENT, servadr, "info %i", PROTOCOL_VERSION );

	push	49					; 00000031H
	push	OFFSET $SG145315
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _servadr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _servadr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _servadr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _servadr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _servadr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H
$LN41@CL_Connect:

; 1960 : 			}
; 1961 : 		}

	jmp	$LN2@CL_Connect
$LN3@CL_Connect:

; 1962 : 	}

	jmp	$LN43@CL_Connect
$LN33@CL_Connect:

; 1963 : 	else if( clgame.dllFuncs.pfnConnectionlessPacket( &from, args, buf, &len ))

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	DWORD PTR _clgame+128
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN42@CL_Connect

; 1964 : 	{
; 1965 : 		// user out of band message (must be handled in CL_ConnectionlessPacket)
; 1966 : 		if( len > 0 ) Netchan_OutOfBand( NS_SERVER, from, len, buf );

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN44@CL_Connect
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBand
	add	esp, 32					; 00000020H
$LN44@CL_Connect:

; 1967 : 	}

	jmp	SHORT $LN43@CL_Connect
$LN42@CL_Connect:

; 1968 : 	else Con_DPrintf( S_ERROR "bad connectionless packet from %s:\n%s\n", NET_AdrToString( from ), args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145319
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN43@CL_Connect:

; 1969 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ConnectionlessPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_nr$ = -4						; size = 4
_CL_ProcessNetRequests PROC

; 1693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1694 : 	net_request_t	*nr;
; 1695 : 	int		i;
; 1696 : 
; 1697 : 	// find a request with specified context
; 1698 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_Process
$LN2@CL_Process:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Process:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_Process

; 1699 : 	{
; 1700 : 		nr = &clgame.net_requests[i];

	imul	ecx, DWORD PTR _i$[ebp], 80
	add	ecx, OFFSET _clgame+144672
	mov	DWORD PTR _nr$[ebp], ecx

; 1701 : 		if( !nr->pfnFunc ) continue;	// not used

	mov	edx, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN5@CL_Process
	jmp	SHORT $LN2@CL_Process
$LN5@CL_Process:

; 1702 : 
; 1703 : 		if( nr->timeout <= host.realtime )

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jb	SHORT $LN6@CL_Process

; 1704 : 		{
; 1705 : 			// setup the answer
; 1706 : 			SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax], edx

; 1707 : 			nr->resp.ping = host.realtime - nr->timesend;

	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx+64]
	mov	edx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [edx+32], xmm0

; 1708 : 
; 1709 : 			nr->pfnFunc( &nr->resp );

	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4

; 1710 : 			memset( nr, 0, sizeof( *nr )); // done

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@CL_Process:

; 1711 : 		}
; 1712 : 	}

	jmp	SHORT $LN2@CL_Process
$LN3@CL_Process:

; 1713 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessNetRequests ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_type$ = -24						; size = 4
_context$ = -20						; size = 4
_val$ = -16						; size = 4
_i$ = -12						; size = 4
_errorBits$ = -8					; size = 4
_nr$ = -4						; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_s$ = 32						; size = 4
_CL_ParseNETInfoMessage PROC

; 1638 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1639 : 	net_request_t	*nr;
; 1640 : 	static char	infostring[MAX_INFO_STRING+8];
; 1641 : 	int		i, context, type;
; 1642 : 	int		errorBits = 0;

	mov	DWORD PTR _errorBits$[ebp], 0

; 1643 : 	char		*val;
; 1644 : 
; 1645 : 	context = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _context$[ebp], eax

; 1646 : 	type = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax
$LN2@CL_ParseNE:

; 1647 : 	while( *s != '\\' ) s++; // fetching infostring

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN3@CL_ParseNE
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
	jmp	SHORT $LN2@CL_ParseNE
$LN3@CL_ParseNE:

; 1648 : 
; 1649 : 	// check for errors
; 1650 : 	val = Info_ValueForKey( s, "neterror" );

	push	OFFSET $SG145192
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1651 : 
; 1652 : 	if( !Q_stricmp( val, "protocol" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145195
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@CL_ParseNE

; 1653 : 		SetBits( errorBits, NET_ERROR_PROTO_UNSUPPORTED );

	mov	edx, DWORD PTR _errorBits$[ebp]
	or	edx, 2
	mov	DWORD PTR _errorBits$[ebp], edx
	jmp	SHORT $LN9@CL_ParseNE
$LN7@CL_ParseNE:

; 1654 : 	else if( !Q_stricmp( val, "undefined" ))

	push	99999					; 0001869fH
	push	OFFSET $SG145197
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_ParseNE

; 1655 : 		SetBits( errorBits, NET_ERROR_UNDEFINED );

	mov	ecx, DWORD PTR _errorBits$[ebp]
	or	ecx, 4
	mov	DWORD PTR _errorBits$[ebp], ecx
$LN9@CL_ParseNE:

; 1656 : 
; 1657 : 	CL_FixupColorStringsForInfoString( s, infostring );

	push	OFFSET ?infostring@?1??CL_ParseNETInfoMessage@@9@9
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_CL_FixupColorStringsForInfoString
	add	esp, 8

; 1658 : 
; 1659 : 	// find a request with specified context
; 1660 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_ParseNE
$LN4@CL_ParseNE:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CL_ParseNE:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN5@CL_ParseNE

; 1661 : 	{
; 1662 : 		nr = &clgame.net_requests[i];

	imul	ecx, DWORD PTR _i$[ebp], 80
	add	ecx, OFFSET _clgame+144672
	mov	DWORD PTR _nr$[ebp], ecx

; 1663 : 
; 1664 : 		if( nr->resp.context == context && nr->resp.type == type )

	mov	edx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _context$[ebp]
	jne	$LN10@CL_ParseNE
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _type$[ebp]
	jne	$LN10@CL_ParseNE

; 1665 : 		{
; 1666 : 			// setup the answer
; 1667 : 			nr->resp.response = infostring;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax+40], OFFSET ?infostring@?1??CL_ParseNETInfoMessage@@9@9

; 1668 : 			nr->resp.remote_address = from;

	mov	ecx, DWORD PTR _nr$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx

; 1669 : 			nr->resp.error = NET_SUCCESS;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax], 0

; 1670 : 			nr->resp.ping = host.realtime - nr->timesend;

	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx+64]
	mov	edx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [edx+32], xmm0

; 1671 : 
; 1672 : 			if( nr->timeout <= host.realtime )

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jb	SHORT $LN11@CL_ParseNE

; 1673 : 				SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax], edx
$LN11@CL_ParseNE:

; 1674 : 			SetBits( nr->resp.error, errorBits ); // misc error bits

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, DWORD PTR _errorBits$[ebp]
	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax], edx

; 1675 : 
; 1676 : 			nr->pfnFunc( &nr->resp );

	mov	ecx, DWORD PTR _nr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	add	esp, 4

; 1677 : 
; 1678 : 			if( !FBitSet( nr->flags, FNETAPI_MULTIPLE_RESPONSE ))

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	and	edx, 1
	jne	SHORT $LN12@CL_ParseNE

; 1679 : 				memset( nr, 0, sizeof( *nr )); // done

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN12@CL_ParseNE:

; 1680 : 			return;

	jmp	SHORT $LN5@CL_ParseNE
$LN10@CL_ParseNE:

; 1681 : 		}
; 1682 : 	}

	jmp	$LN4@CL_ParseNE
$LN5@CL_ParseNE:

; 1683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseNETInfoMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_s$ = -4						; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_CL_ParseStatusMessage PROC

; 1612 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1613 : 	static char	infostring[MAX_INFO_STRING+8];
; 1614 : 	char		*s = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 1615 : 
; 1616 : 	CL_FixupColorStringsForInfoString( s, infostring );

	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_CL_FixupColorStringsForInfoString
	add	esp, 8

; 1617 : 
; 1618 : 	if( !COM_CheckString( Info_ValueForKey( infostring, "gamedir" )))

	push	OFFSET $SG145167
	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_ParseSt

; 1619 : 	{
; 1620 : 		Con_Printf( "^1Server^7: %s, Info: %s\n", NET_AdrToString( from ), infostring );

	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145168
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1621 : 		return; // unsupported proto

	jmp	SHORT $LN1@CL_ParseSt
$LN2@CL_ParseSt:

; 1622 : 	}
; 1623 : 
; 1624 : 	// more info about servers
; 1625 : 	Con_Printf( "^2Server^7: %s, Game: %s\n", NET_AdrToString( from ), Info_ValueForKey( infostring, "gamedir" ));

	push	OFFSET $SG145169
	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG145170
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1626 : 
; 1627 : 	UI_AddServerToList( from, infostring );

	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_UI_AddServerToList
	add	esp, 24					; 00000018H
$LN1@CL_ParseSt:

; 1628 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseStatusMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_endOfKeyVal$ = -16					; size = 4
_hasPrefix$ = -12					; size = 4
_color$ = -8						; size = 4
_count$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_CL_FixupColorStringsForInfoString PROC

; 1548 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1549 : 	qboolean	hasPrefix = false;

	mov	DWORD PTR _hasPrefix$[ebp], 0

; 1550 : 	qboolean	endOfKeyVal = false;

	mov	DWORD PTR _endOfKeyVal$[ebp], 0

; 1551 : 	int	color = 7;

	mov	DWORD PTR _color$[ebp], 7

; 1552 : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1553 : 
; 1554 : 	if( *in == '\\' )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@CL_FixupCo

; 1555 : 	{
; 1556 : 		*out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 1557 : 		count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
$LN2@CL_FixupCo:

; 1558 : 	}
; 1559 : 
; 1560 : 	while( *in && count < MAX_INFO_STRING )

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@CL_FixupCo
	cmp	DWORD PTR _count$[ebp], 256		; 00000100H
	jge	$LN3@CL_FixupCo

; 1561 : 	{
; 1562 : 		if( IsColorString( in ))

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN5@CL_FixupCo
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 94					; 0000005eH
	jne	SHORT $LN5@CL_FixupCo
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN5@CL_FixupCo
	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@CL_FixupCo
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN5@CL_FixupCo

; 1563 : 			color = ColorIndex( *(in+1));

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	sub	ecx, 48					; 00000030H
	and	ecx, 7
	mov	DWORD PTR _color$[ebp], ecx
$LN5@CL_FixupCo:

; 1564 : 
; 1565 : 		// color the not reset while end of key (or value) was found!
; 1566 : 		if( *in == '\\' && color != 7 )

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN6@CL_FixupCo
	cmp	DWORD PTR _color$[ebp], 7
	je	SHORT $LN6@CL_FixupCo

; 1567 : 		{
; 1568 : 			if( IsColorString( out - 2 ))

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, 2
	je	SHORT $LN7@CL_FixupCo
	mov	edx, DWORD PTR _out$[ebp]
	movsx	eax, BYTE PTR [edx-2]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN7@CL_FixupCo
	mov	ecx, DWORD PTR _out$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	test	edx, edx
	je	SHORT $LN7@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN7@CL_FixupCo
	mov	edx, DWORD PTR _out$[ebp]
	movsx	eax, BYTE PTR [edx-1]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN7@CL_FixupCo

; 1569 : 			{
; 1570 : 				*(out - 1) = '7';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx-1], 55			; 00000037H

; 1571 : 			}

	jmp	SHORT $LN8@CL_FixupCo
$LN7@CL_FixupCo:

; 1572 : 			else
; 1573 : 			{
; 1574 : 				*out++ = '^';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 94			; 0000005eH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1575 : 				*out++ = '7';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 55			; 00000037H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 1576 : 				count += 2;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 2
	mov	DWORD PTR _count$[ebp], eax
$LN8@CL_FixupCo:

; 1577 : 			}
; 1578 : 			color = 7;

	mov	DWORD PTR _color$[ebp], 7
$LN6@CL_FixupCo:

; 1579 : 		}
; 1580 : 
; 1581 : 		*out++ = *in++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 1582 : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 1583 : 	}

	jmp	$LN2@CL_FixupCo
$LN3@CL_FixupCo:

; 1584 : 
; 1585 : 	// check the remaining value
; 1586 : 	if( color != 7 )

	cmp	DWORD PTR _color$[ebp], 7
	je	SHORT $LN9@CL_FixupCo

; 1587 : 	{
; 1588 : 		// if the ends with another color rewrite it
; 1589 : 		if( IsColorString( out - 2 ))

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, 2
	je	SHORT $LN10@CL_FixupCo
	mov	edx, DWORD PTR _out$[ebp]
	movsx	eax, BYTE PTR [edx-2]
	cmp	eax, 94					; 0000005eH
	jne	SHORT $LN10@CL_FixupCo
	mov	ecx, DWORD PTR _out$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	test	edx, edx
	je	SHORT $LN10@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@CL_FixupCo
	mov	edx, DWORD PTR _out$[ebp]
	movsx	eax, BYTE PTR [edx-1]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN10@CL_FixupCo

; 1590 : 		{
; 1591 : 			*(out - 1) = '7';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx-1], 55			; 00000037H

; 1592 : 		}

	jmp	SHORT $LN9@CL_FixupCo
$LN10@CL_FixupCo:

; 1593 : 		else
; 1594 : 		{
; 1595 : 			*out++ = '^';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 94			; 0000005eH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1596 : 			*out++ = '7';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 55			; 00000037H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 1597 : 			count += 2;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 2
	mov	DWORD PTR _count$[ebp], eax
$LN9@CL_FixupCo:

; 1598 : 		}
; 1599 : 	}
; 1600 : 
; 1601 : 	*out = '\0';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 0

; 1602 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FixupColorStringsForInfoString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Reconnect_f PROC

; 1514 : {

	push	ebp
	mov	ebp, esp

; 1515 : 	if( cls.state == ca_disconnected )

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_Reconne

; 1516 : 		return;

	jmp	$LN4@CL_Reconne
$LN2@CL_Reconne:

; 1517 : 
; 1518 : 	S_StopAllSounds ( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 1519 : 
; 1520 : 	if( cls.state == ca_connected )

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN3@CL_Reconne

; 1521 : 	{
; 1522 : 		CL_Reconnect( false );

	push	0
	call	_CL_Reconnect
	add	esp, 4

; 1523 : 		return;

	jmp	SHORT $LN4@CL_Reconne
$LN3@CL_Reconne:

; 1524 : 	}
; 1525 : 
; 1526 : 	if( COM_CheckString( cls.servername ))

	push	OFFSET _cls+72
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@CL_Reconne

; 1527 : 	{
; 1528 : 		if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN5@CL_Reconne

; 1529 : 			CL_Disconnect();

	call	_CL_Disconnect
$LN5@CL_Reconne:

; 1530 : 
; 1531 : 		cls.connect_time = MAX_HEARTBEAT;	// fire immediately

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0

; 1532 : 		cls.demonum = cls.movienum = -1;	// not in the demo loop now

	mov	DWORD PTR _cls+295524, -1
	mov	eax, DWORD PTR _cls+295524
	mov	DWORD PTR _cls+293464, eax

; 1533 : 		cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1

; 1534 : 		cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1535 : 
; 1536 : 		Con_Printf( "reconnecting...\n" );

	push	OFFSET $SG145136
	call	_Con_Printf
	add	esp, 4
$LN4@CL_Reconne:

; 1537 : 	}
; 1538 : }

	pop	ebp
	ret	0
_CL_Reconnect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_remaining$ = -544					; size = 4
_info$ = -540						; size = 4
_adr$ = -536						; size = 20
_fullquery$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_CL_InternetServers_f PROC

; 1480 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1481 : 	char	fullquery[512] = MS_SCAN_REQUEST;

	mov	eax, DWORD PTR $SG145119
	mov	DWORD PTR _fullquery$[ebp], eax
	mov	ecx, DWORD PTR $SG145119+4
	mov	DWORD PTR _fullquery$[ebp+4], ecx
	mov	edx, DWORD PTR $SG145119+8
	mov	DWORD PTR _fullquery$[ebp+8], edx
	mov	al, BYTE PTR $SG145119+12
	mov	BYTE PTR _fullquery$[ebp+12], al
	push	499					; 000001f3H
	push	0
	lea	ecx, DWORD PTR _fullquery$[ebp+13]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1482 : 	char	*info = fullquery + sizeof( MS_SCAN_REQUEST ) - 1;

	lea	edx, DWORD PTR _fullquery$[ebp+12]
	mov	DWORD PTR _info$[ebp], edx

; 1483 : 	int	remaining = sizeof( fullquery ) - sizeof( MS_SCAN_REQUEST );

	mov	DWORD PTR _remaining$[ebp], 499		; 000001f3H

; 1484 : 	netadr_t	adr;
; 1485 : 
; 1486 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1487 : 
; 1488 : 	if( !NET_StringToAdr( MASTERSERVER_ADR, &adr ) )

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET $SG145121
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@CL_Interne

; 1489 : 	{
; 1490 : 		Con_DPrintf( S_ERROR "Can't resolve adr: %s\n", MASTERSERVER_ADR );

	push	OFFSET $SG145122
	push	OFFSET $SG145123
	call	_Con_DPrintf
	add	esp, 8

; 1491 : 		return;

	jmp	$LN1@CL_Interne
$LN2@CL_Interne:

; 1492 : 	}
; 1493 : 
; 1494 : 	Con_Printf( "Scanning for servers on the internet area...\n" );

	push	OFFSET $SG145124
	call	_Con_Printf
	add	esp, 4

; 1495 : 	Info_SetValueForKey( info, "gamedir", GI->gamefolder, remaining );

	mov	ecx, DWORD PTR _remaining$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SI+768
	push	edx
	push	OFFSET $SG145125
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1496 : 	Info_SetValueForKey( info, "clver", XASH_VERSION, remaining ); // let master know about client version

	mov	ecx, DWORD PTR _remaining$[ebp]
	push	ecx
	push	OFFSET $SG145126
	push	OFFSET $SG145127
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_Info_SetValueForKey

; 1497 : 
; 1498 : 	NET_SendPacket( NS_CLIENT, sizeof( MS_SCAN_REQUEST ) + Q_strlen( info ), fullquery, adr );

	add	esp, -4					; fffffffcH
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _fullquery$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 13					; 0000000dH
	push	eax
	push	0
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 1499 : 
; 1500 : 	// now we clearing the vgui request
; 1501 : 	if( clgame.master_request != NULL )

	cmp	DWORD PTR _clgame+149792, 0
	je	SHORT $LN3@CL_Interne

; 1502 : 		memset( clgame.master_request, 0, sizeof( net_request_t ));

	push	80					; 00000050H
	push	0
	mov	ecx, DWORD PTR _clgame+149792
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@CL_Interne:

; 1503 : 	clgame.request_type = NET_REQUEST_GAMEUI;

	mov	DWORD PTR _clgame+144668, 1
$LN1@CL_Interne:

; 1504 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InternetServers_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_adr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_CL_LocalServers_f PROC

; 1461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1462 : 	netadr_t	adr;
; 1463 : 
; 1464 : 	Con_Printf( "Scanning for servers on the local network area...\n" );

	push	OFFSET $SG145108
	call	_Con_Printf
	add	esp, 4

; 1465 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1466 : 	
; 1467 : 	// send a broadcast packet
; 1468 : 	adr.type = NA_BROADCAST;

	mov	DWORD PTR _adr$[ebp], 2

; 1469 : 	adr.port = MSG_BigShort( PORT_SERVER );

	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _adr$[ebp+18], ax

; 1470 : 
; 1471 : 	Netchan_OutOfBandPrint( NS_CLIENT, adr, "info %i", PROTOCOL_VERSION );

	push	49					; 00000031H
	push	OFFSET $SG145109
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 1472 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LocalServers_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_setup_netchan$ = 8					; size = 4
_CL_Reconnect PROC

; 1362 : {

	push	ebp
	mov	ebp, esp

; 1363 : 	if( setup_netchan )

	cmp	DWORD PTR _setup_netchan$[ebp], 0
	je	SHORT $LN2@CL_Reconne

; 1364 : 	{
; 1365 : 		Netchan_Setup( NS_CLIENT, &cls.netchan, net_from, Cvar_VariableInteger( "net_qport" ), NULL, CL_GetFragmentSize );

	push	OFFSET _CL_GetFragmentSize
	push	0
	push	OFFSET $SG145087
	call	_Cvar_VariableInteger
	add	esp, 4
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	push	OFFSET _cls+23520
	push	0
	call	_Netchan_Setup
	add	esp, 40					; 00000028H

; 1366 : 	}

	jmp	SHORT $LN3@CL_Reconne
$LN2@CL_Reconne:

; 1367 : 	else
; 1368 : 	{
; 1369 : 		// clear channel and stuff
; 1370 : 		Netchan_Clear( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_Clear
	add	esp, 4

; 1371 : 		MSG_Clear( &cls.netchan.message );

	push	OFFSET _cls+23620
	call	_MSG_Clear
	add	esp, 4
$LN3@CL_Reconne:

; 1372 : 	}
; 1373 : 
; 1374 : 	cls.demonum = cls.movienum = -1;	// not in the demo loop now

	mov	DWORD PTR _cls+295524, -1
	mov	edx, DWORD PTR _cls+295524
	mov	DWORD PTR _cls+293464, edx

; 1375 : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 1376 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1377 : 
; 1378 : 	CL_ServerCommand( true, "new" );

	push	OFFSET $SG145088
	push	1
	call	_CL_ServerCommand
	add	esp, 8

; 1379 : 
; 1380 : 	cl.validsequence = 0;		// haven't gotten a valid frame update yet

	mov	DWORD PTR _cl+4, 0

; 1381 : 	cl.delta_sequence = -1;		// we'll request a full delta from the baseline

	mov	DWORD PTR _cl+28, -1

; 1382 : 	cls.lastoutgoingcommand = -1;		// we don't have a backed up cmd history yet

	mov	DWORD PTR _cls+287344, -1

; 1383 : 	cls.nextcmdtime = host.realtime;	// we can send a cmd right away

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+287340, xmm0

; 1384 : 	cl.last_command_ack = -1;

	mov	DWORD PTR _cl+52, -1

; 1385 : 
; 1386 : 	CL_StartupDemoHeader ();

	call	_CL_StartupDemoHeader

; 1387 : }

	pop	ebp
	ret	0
_CL_Reconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_buf$ = -56						; size = 20
_data$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_CL_SendDisconnectMessage PROC

; 1335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1336 : 	sizebuf_t	buf;
; 1337 : 	byte	data[32];
; 1338 : 
; 1339 : 	if( cls.state == ca_disconnected ) return;

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_SendDis
	jmp	$LN1@CL_SendDis
$LN2@CL_SendDis:

; 1340 : 
; 1341 : 	MSG_Init( &buf, "LastMessage", data, sizeof( data ));

	push	-1
	push	32					; 00000020H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET $SG145077
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1342 : 	MSG_BeginClientCmd( &buf, clc_stringcmd );

	push	0
	push	0
	push	3
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1343 : 	MSG_WriteString( &buf, "disconnect" );

	push	OFFSET $SG145078
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1344 : 
; 1345 : 	if( !cls.netchan.remote_address.type )

	cmp	DWORD PTR _cls+23524, 0
	jne	SHORT $LN3@CL_SendDis

; 1346 : 		cls.netchan.remote_address.type = NA_LOOPBACK;

	mov	DWORD PTR _cls+23524, 1
$LN3@CL_SendDis:

; 1347 : 
; 1348 : 	// make sure message will be delivered
; 1349 : 	Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+23520
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 1350 : 	Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+23520
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 1351 : 	Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+23520
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN1@CL_SendDis:

; 1352 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendDisconnectMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
$T1 = -1056						; size = 4
_i$ = -1052						; size = 4
_to$ = -1048						; size = 20
_message$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_CL_Rcon_f PROC

; 1232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1056				; 00000420H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1233 : 	char	message[1024];
; 1234 : 	netadr_t	to;
; 1235 : 	int	i;
; 1236 : 
; 1237 : 	if( !COM_CheckString( rcon_client_password->string ))

	mov	eax, DWORD PTR _rcon_client_password
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_Rcon_f

; 1238 : 	{
; 1239 : 		Con_Printf( "You must set 'rcon_password' before issuing an rcon command.\n" );

	push	OFFSET $SG145051
	call	_Con_Printf
	add	esp, 4

; 1240 : 		return;

	jmp	$LN10@CL_Rcon_f
$LN5@CL_Rcon_f:

; 1241 : 	}
; 1242 : 
; 1243 : 	message[0] = (char)255;

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _message$[ebp+eax], -1

; 1244 : 	message[1] = (char)255;

	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _message$[ebp+ecx], -1

; 1245 : 	message[2] = (char)255;

	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR _message$[ebp+edx], -1

; 1246 : 	message[3] = (char)255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _message$[ebp+ecx], -1

; 1247 : 	message[4] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN11@CL_Rcon_f
	jmp	SHORT $LN12@CL_Rcon_f
$LN11@CL_Rcon_f:
	call	___report_rangecheckfailure
$LN12@CL_Rcon_f:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _message$[ebp+eax], 0

; 1248 : 
; 1249 : 	NET_Config( true );	// allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1250 : 
; 1251 : 	Q_strcat( message, "rcon " );

	push	99999					; 0001869fH
	push	OFFSET $SG145052
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1252 : 	Q_strcat( message, rcon_client_password->string );

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _rcon_client_password
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1253 : 	Q_strcat( message, " " );

	push	99999					; 0001869fH
	push	OFFSET $SG145053
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1254 : 
; 1255 : 	for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_Rcon_f
$LN2@CL_Rcon_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Rcon_f:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@CL_Rcon_f

; 1256 : 	{
; 1257 : 		Q_strcat( message, Cmd_Argv( i ));

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1258 : 		Q_strcat( message, " " );

	push	99999					; 0001869fH
	push	OFFSET $SG145054
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1259 : 	}

	jmp	SHORT $LN2@CL_Rcon_f
$LN3@CL_Rcon_f:

; 1260 : 
; 1261 : 	if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN6@CL_Rcon_f

; 1262 : 	{
; 1263 : 		to = cls.netchan.remote_address;

	mov	ecx, DWORD PTR _cls+23524
	mov	DWORD PTR _to$[ebp], ecx
	mov	edx, DWORD PTR _cls+23528
	mov	DWORD PTR _to$[ebp+4], edx
	mov	eax, DWORD PTR _cls+23532
	mov	DWORD PTR _to$[ebp+8], eax
	mov	ecx, DWORD PTR _cls+23536
	mov	DWORD PTR _to$[ebp+12], ecx
	mov	edx, DWORD PTR _cls+23540
	mov	DWORD PTR _to$[ebp+16], edx

; 1264 : 	}

	jmp	SHORT $LN7@CL_Rcon_f
$LN6@CL_Rcon_f:

; 1265 : 	else
; 1266 : 	{
; 1267 : 		if( !COM_CheckString( rcon_address->string ))

	mov	eax, DWORD PTR _rcon_address
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@CL_Rcon_f

; 1268 : 		{
; 1269 : 			Con_Printf( "You must either be connected or set the 'rcon_address' cvar to issue rcon commands\n" );

	push	OFFSET $SG145058
	call	_Con_Printf
	add	esp, 4

; 1270 : 			return;

	jmp	$LN10@CL_Rcon_f
$LN8@CL_Rcon_f:

; 1271 : 		}
; 1272 : 
; 1273 : 		NET_StringToAdr( rcon_address->string, &to );

	lea	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _rcon_address
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_NET_StringToAdr
	add	esp, 8

; 1274 : 		if( to.port == 0 ) to.port = MSG_BigShort( PORT_SERVER );

	movzx	edx, WORD PTR _to$[ebp+18]
	test	edx, edx
	jne	SHORT $LN7@CL_Rcon_f
	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _to$[ebp+18], ax
$LN7@CL_Rcon_f:

; 1275 : 	}
; 1276 : 	
; 1277 : 	NET_SendPacket( NS_CLIENT, Q_strlen( message ) + 1, message, to );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	push	0
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN10@CL_Rcon_f:

; 1278 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Rcon_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_server$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_CL_Connect_f PROC

; 1192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1193 : 	string	server;
; 1194 : 
; 1195 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@CL_Connect

; 1196 : 	{
; 1197 : 		Con_Printf( S_USAGE "connect <server>\n" );

	push	OFFSET $SG145033
	call	_Con_Printf
	add	esp, 4

; 1198 : 		return;	

	jmp	$LN1@CL_Connect
$LN2@CL_Connect:

; 1199 : 	}
; 1200 : 
; 1201 : 	Q_strncpy( server, Cmd_Argv( 1 ), sizeof( server ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _server$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1202 : 
; 1203 : 	// if running a local server, kill it and reissue
; 1204 : 	if( SV_Active( )) Host_ShutdownServer();

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN3@CL_Connect
	call	_Host_ShutdownServer
$LN3@CL_Connect:

; 1205 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1206 : 
; 1207 : 	Con_Printf( "server %s\n", server );

	lea	ecx, DWORD PTR _server$[ebp]
	push	ecx
	push	OFFSET $SG145035
	call	_Con_Printf
	add	esp, 8

; 1208 : 	CL_Disconnect();

	call	_CL_Disconnect

; 1209 : 
; 1210 : 	// TESTTEST: a see console during connection
; 1211 : 	UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4

; 1212 : 	Key_SetKeyDest( key_console );

	push	0
	call	_Key_SetKeyDest
	add	esp, 4

; 1213 : 
; 1214 : 	cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1

; 1215 : 	Q_strncpy( cls.servername, server, sizeof( cls.servername ));

	push	64					; 00000040H
	lea	edx, DWORD PTR _server$[ebp]
	push	edx
	push	OFFSET _cls+72
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1216 : 	cls.connect_time = MAX_HEARTBEAT; // CL_CheckForResend() will fire immediately

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0

; 1217 : 	cls.max_fragment_size = FRAGMENT_MAX_SIZE; // guess a we can establish connection with maximum fragment size

	mov	DWORD PTR _cls+144, 64000		; 0000fa00H

; 1218 : 	cls.connect_retry = 0;

	mov	DWORD PTR _cls+148, 0

; 1219 : 	cls.spectator = false;

	mov	DWORD PTR _cls+152, 0

; 1220 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0
$LN1@CL_Connect:

; 1221 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Connect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_nSize$ = -292						; size = 4
_fp$ = -288						; size = 4
_pNewResource$ = -284					; size = 4
_szFileName$ = -280					; size = 260
_rgucMD5_hash$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_CL_CreateResourceList PROC

; 1150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1151 : 	char		szFileName[MAX_OSPATH];
; 1152 : 	byte		rgucMD5_hash[16];
; 1153 : 	resource_t	*pNewResource;
; 1154 : 	int		nSize;
; 1155 : 	file_t		*fp;
; 1156 : 
; 1157 : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 1158 : 	cl.num_resources = 0;

	mov	DWORD PTR _cl+2681452, 0

; 1159 : 
; 1160 : 	Q_snprintf( szFileName, sizeof( szFileName ), "logos/remapped.bmp" );

	push	OFFSET $SG145022
	push	260					; 00000104H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 12					; 0000000cH

; 1161 : 	memset( rgucMD5_hash, 0, sizeof( rgucMD5_hash ));

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _rgucMD5_hash$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1162 : 
; 1163 : 	fp = FS_Open( szFileName, "rb", true );

	push	1
	push	OFFSET $SG145023
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1164 : 
; 1165 : 	if( fp )

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN1@CL_CreateR

; 1166 : 	{
; 1167 : 		MD5_HashFile( rgucMD5_hash, szFileName, NULL );

	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgucMD5_hash$[ebp]
	push	ecx
	call	_MD5_HashFile
	add	esp, 12					; 0000000cH

; 1168 : 		nSize = FS_FileLength( fp );

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_FS_FileLength
	add	esp, 4
	mov	DWORD PTR _nSize$[ebp], eax

; 1169 : 
; 1170 : 		if( nSize != 0 )

	cmp	DWORD PTR _nSize$[ebp], 0
	je	SHORT $LN3@CL_CreateR

; 1171 : 		{
; 1172 : 			pNewResource = CL_AddResource( t_decal, szFileName, nSize, false, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	3
	call	_CL_AddResource
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pNewResource$[ebp], eax

; 1173 : 
; 1174 : 			if( pNewResource )

	cmp	DWORD PTR _pNewResource$[ebp], 0
	je	SHORT $LN3@CL_CreateR

; 1175 : 			{
; 1176 : 				SetBits( pNewResource->ucFlags, RES_CUSTOM );

	mov	edx, DWORD PTR _pNewResource$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	or	eax, 4
	mov	ecx, DWORD PTR _pNewResource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 1177 : 				memcpy( pNewResource->rgucMD5_hash, rgucMD5_hash, 16 );

	push	16					; 00000010H
	lea	edx, DWORD PTR _rgucMD5_hash$[ebp]
	push	edx
	mov	eax, DWORD PTR _pNewResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1178 : 				HPAK_AddLump( false, CUSTOM_RES_PATH, pNewResource, NULL, fp );

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pNewResource$[ebp]
	push	edx
	push	OFFSET $SG145027
	push	0
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H
$LN3@CL_CreateR:

; 1179 : 			}
; 1180 : 		}
; 1181 : 		FS_Close( fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@CL_CreateR:

; 1182 : 	}
; 1183 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv75 = -8						; size = 4
_r$ = -4						; size = 4
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_size$ = 16						; size = 4
_bFatalIfMissing$ = 20					; size = 4
_index$ = 24						; size = 4
_CL_AddResource PROC

; 1133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1134 : 	resource_t	*r = &cl.resourcelist[cl.num_resources];

	imul	eax, DWORD PTR _cl+2681452, 136
	add	eax, OFFSET _cl+1985132
	mov	DWORD PTR _r$[ebp], eax

; 1135 : 
; 1136 : 	if( cl.num_resources >= MAX_RESOURCES )

	cmp	DWORD PTR _cl+2681452, 5120		; 00001400H
	jl	SHORT $LN2@CL_AddReso

; 1137 : 		Host_Error( "Too many resources on client\n" );

	push	OFFSET $SG145011
	call	_Host_Error
	add	esp, 4
$LN2@CL_AddReso:

; 1138 : 	cl.num_resources++;

	mov	ecx, DWORD PTR _cl+2681452
	add	ecx, 1
	mov	DWORD PTR _cl+2681452, ecx

; 1139 : 
; 1140 : 	Q_strncpy( r->szFileName, name, sizeof( r->szFileName ));

	push	64					; 00000040H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1141 : 	r->ucFlags |= bFatalIfMissing ? RES_FATALIFMISSING : 0;

	cmp	DWORD PTR _bFatalIfMissing$[ebp], 0
	je	SHORT $LN4@CL_AddReso
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN5@CL_AddReso
$LN4@CL_AddReso:
	mov	DWORD PTR tv75[ebp], 0
$LN5@CL_AddReso:
	mov	ecx, DWORD PTR _r$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	or	edx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	BYTE PTR [eax+76], dl

; 1142 : 	r->nDownloadSize = size;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 1143 : 	r->nIndex = index;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1144 : 	r->type = type;

	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1145 : 
; 1146 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 1147 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv139 = -36						; size = 4
tv137 = -32						; size = 4
tv133 = -28						; size = 4
_adr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_CL_CheckForResend PROC

; 1068 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1069 : 	netadr_t	adr;
; 1070 : 
; 1071 : 	// if the local server is running and we aren't then connect
; 1072 : 	if( cls.state == ca_disconnected && SV_Active( ))

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_CheckFo
	call	_SV_Active
	test	eax, eax
	je	SHORT $LN2@CL_CheckFo

; 1073 : 	{
; 1074 : 		cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1075 : 		cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1

; 1076 : 		Q_strncpy( cls.servername, "localhost", sizeof( cls.servername ));

	push	64					; 00000040H
	push	OFFSET $SG144975
	push	OFFSET _cls+72
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1077 : 		// we don't need a challenge on the localhost
; 1078 : 		CL_SendConnectPacket();

	call	_CL_SendConnectPacket

; 1079 : 		return;

	jmp	$LN14@CL_CheckFo
$LN2@CL_CheckFo:

; 1080 : 	}
; 1081 : 
; 1082 : 	// resend if we haven't gotten a reply yet
; 1083 : 	if( cls.demoplayback || cls.state != ca_connecting )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN4@CL_CheckFo
	cmp	DWORD PTR _cls, 1
	je	SHORT $LN3@CL_CheckFo
$LN4@CL_CheckFo:

; 1084 : 		return;

	jmp	$LN14@CL_CheckFo
$LN3@CL_CheckFo:

; 1085 : 
; 1086 : 	if( cl_resend.value < CL_MIN_RESEND_TIME )

	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR _cl_resend+12
	jbe	SHORT $LN5@CL_CheckFo

; 1087 : 		Cvar_SetValue( "cl_resend", CL_MIN_RESEND_TIME );

	push	ecx
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144980
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN7@CL_CheckFo
$LN5@CL_CheckFo:

; 1088 : 	else if( cl_resend.value > CL_MAX_RESEND_TIME )

	movss	xmm0, DWORD PTR _cl_resend+12
	comiss	xmm0, DWORD PTR __real@41a00000
	jbe	SHORT $LN7@CL_CheckFo

; 1089 : 		Cvar_SetValue( "cl_resend", CL_MAX_RESEND_TIME );

	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144982
	call	_Cvar_SetValue
	add	esp, 8
$LN7@CL_CheckFo:

; 1090 : 
; 1091 : 	if(( host.realtime - cls.connect_time ) < cl_resend.value )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+136
	cvtss2sd xmm1, DWORD PTR _cl_resend+12
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@CL_CheckFo

; 1092 : 		return;

	jmp	$LN14@CL_CheckFo
$LN8@CL_CheckFo:

; 1093 : 
; 1094 : 	if( !NET_StringToAdr( cls.servername, &adr ))

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET _cls+72
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@CL_CheckFo

; 1095 : 	{
; 1096 : 		CL_Disconnect();

	call	_CL_Disconnect

; 1097 : 		return;

	jmp	$LN14@CL_CheckFo
$LN9@CL_CheckFo:

; 1098 : 	}
; 1099 : 
; 1100 : 	// only retry so many times before failure.
; 1101 : 	if( cls.connect_retry >= CL_CONNECTION_RETRIES )

	cmp	DWORD PTR _cls+148, 10			; 0000000aH
	jl	SHORT $LN10@CL_CheckFo

; 1102 : 	{
; 1103 : 		Con_DPrintf( S_ERROR "CL_CheckForResend: couldn't connected\n" );

	push	OFFSET $SG144986
	call	_Con_DPrintf
	add	esp, 4

; 1104 : 		CL_Disconnect();

	call	_CL_Disconnect

; 1105 : 		return;

	jmp	$LN14@CL_CheckFo
$LN10@CL_CheckFo:

; 1106 : 	}
; 1107 : 
; 1108 : 	if( adr.port == 0 ) adr.port = MSG_BigShort( PORT_SERVER );

	movzx	ecx, WORD PTR _adr$[ebp+18]
	test	ecx, ecx
	jne	SHORT $LN11@CL_CheckFo
	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _adr$[ebp+18], ax
$LN11@CL_CheckFo:

; 1109 : 
; 1110 : 	if( cls.connect_retry == CL_TEST_RETRIES_NORESPONCE )

	cmp	DWORD PTR _cls+148, 2
	jne	SHORT $LN12@CL_CheckFo

; 1111 : 	{
; 1112 : 		// too many fails use default connection method
; 1113 : 		Con_Printf( "hi-speed connection is failed, use default method\n" );

	push	OFFSET $SG144989
	call	_Con_Printf
	add	esp, 4

; 1114 : 		Netchan_OutOfBandPrint( NS_CLIENT, adr, "getchallenge\n" );

	push	OFFSET $SG144990
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	0
	call	_Netchan_OutOfBandPrint

; 1115 : 		Cvar_SetValue( "cl_dlmax", FRAGMENT_MIN_SIZE );

	add	esp, 24					; 00000018H
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144991
	call	_Cvar_SetValue
	add	esp, 8

; 1116 : 		cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1117 : 		cls.connect_retry++;

	mov	ecx, DWORD PTR _cls+148
	add	ecx, 1
	mov	DWORD PTR _cls+148, ecx

; 1118 : 		return;

	jmp	$LN14@CL_CheckFo
$LN12@CL_CheckFo:

; 1119 : 	}
; 1120 : 
; 1121 : 	cls.max_fragment_size = Q_max( FRAGMENT_MAX_SIZE, cls.max_fragment_size >> Q_min( 1, cls.connect_retry ));

	cmp	DWORD PTR _cls+148, 1
	jle	SHORT $LN16@CL_CheckFo
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN17@CL_CheckFo
$LN16@CL_CheckFo:
	mov	edx, DWORD PTR _cls+148
	mov	DWORD PTR tv133[ebp], edx
$LN17@CL_CheckFo:
	mov	eax, DWORD PTR _cls+144
	mov	ecx, DWORD PTR tv133[ebp]
	sar	eax, cl
	cmp	eax, 64000				; 0000fa00H
	jge	SHORT $LN20@CL_CheckFo
	mov	DWORD PTR tv139[ebp], 64000		; 0000fa00H
	jmp	SHORT $LN21@CL_CheckFo
$LN20@CL_CheckFo:
	cmp	DWORD PTR _cls+148, 1
	jle	SHORT $LN18@CL_CheckFo
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN19@CL_CheckFo
$LN18@CL_CheckFo:
	mov	ecx, DWORD PTR _cls+148
	mov	DWORD PTR tv137[ebp], ecx
$LN19@CL_CheckFo:
	mov	edx, DWORD PTR _cls+144
	mov	ecx, DWORD PTR tv137[ebp]
	sar	edx, cl
	mov	DWORD PTR tv139[ebp], edx
$LN21@CL_CheckFo:
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _cls+144, eax

; 1122 : 	cls.connect_time = host.realtime; // for retransmit requests

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1123 : 	cls.connect_retry++;

	mov	ecx, DWORD PTR _cls+148
	add	ecx, 1
	mov	DWORD PTR _cls+148, ecx

; 1124 : 
; 1125 : 	Con_Printf( "Connecting to %s... [retry #%i]\n", cls.servername, cls.connect_retry );

	mov	edx, DWORD PTR _cls+148
	push	edx
	push	OFFSET _cls+72
	push	OFFSET $SG144992
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1126 : 
; 1127 : 	if( cl_test_bandwidth.value )

	movss	xmm0, DWORD PTR _cl_test_bandwidth+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@CL_CheckFo

; 1128 : 		Netchan_OutOfBandPrint( NS_CLIENT, adr, "bandwidth %i %i\n", PROTOCOL_VERSION, cls.max_fragment_size );

	mov	eax, DWORD PTR _cls+144
	push	eax
	push	49					; 00000031H
	push	OFFSET $SG144995
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 36					; 00000024H
	jmp	SHORT $LN14@CL_CheckFo
$LN13@CL_CheckFo:

; 1129 : 	else Netchan_OutOfBandPrint( NS_CLIENT, adr, "getchallenge\n" );

	push	OFFSET $SG144996
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH
$LN14@CL_CheckFo:

; 1130 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckForResend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_qport$ = -288						; size = 4
_key$ = -284						; size = 4
_adr$ = -280						; size = 20
_protinfo$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_CL_SendConnectPacket PROC

; 1035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1036 : 	char	protinfo[MAX_INFO_STRING];
; 1037 : 	char	*qport;
; 1038 : 	char	*key;
; 1039 : 	netadr_t	adr;
; 1040 : 
; 1041 : 	if( !NET_StringToAdr( cls.servername, &adr ))

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET _cls+72
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@CL_SendCon

; 1042 : 	{
; 1043 : 		Con_Printf( "CL_SendConnectPacket: bad server address\n");

	push	OFFSET $SG144964
	call	_Con_Printf
	add	esp, 4

; 1044 : 		cls.connect_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+136, xmm0

; 1045 : 		return;

	jmp	$LN1@CL_SendCon
$LN2@CL_SendCon:

; 1046 : 	}
; 1047 : 
; 1048 : 	if( adr.port == 0 ) adr.port = MSG_BigShort( PORT_SERVER );

	movzx	ecx, WORD PTR _adr$[ebp+18]
	test	ecx, ecx
	jne	SHORT $LN3@CL_SendCon
	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _adr$[ebp+18], ax
$LN3@CL_SendCon:

; 1049 : 	qport = Cvar_VariableString( "net_qport" );

	push	OFFSET $SG144966
	call	_Cvar_VariableString
	add	esp, 4
	mov	DWORD PTR _qport$[ebp], eax

; 1050 : 	key = CL_GetCDKeyHash();

	call	_CL_GetCDKeyHash
	mov	DWORD PTR _key$[ebp], eax

; 1051 : 
; 1052 : 	memset( protinfo, 0, sizeof( protinfo ));

	push	256					; 00000100H
	push	0
	lea	edx, DWORD PTR _protinfo$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1053 : 	Info_SetValueForKey( protinfo, "uuid", key, sizeof( protinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET $SG144967
	lea	ecx, DWORD PTR _protinfo$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1054 : 	Info_SetValueForKey( protinfo, "qport", qport, sizeof( protinfo ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _qport$[ebp]
	push	edx
	push	OFFSET $SG144968
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1055 : 
; 1056 : 	Netchan_OutOfBandPrint( NS_CLIENT, adr, "connect %i %i \"%s\" \"%s\"\n", PROTOCOL_VERSION, cls.challenge, protinfo, cls.userinfo );

	push	OFFSET _cls+6604
	lea	ecx, DWORD PTR _protinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+287320
	push	edx
	push	49					; 00000031H
	push	OFFSET $SG144969
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 44					; 0000002cH

; 1057 : 	cls.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+16
$LN1@CL_SendCon:

; 1058 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendConnectPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_keyBuffer$ = -124					; size = 4
$T1 = -120						; size = 4
_nKeyLength$ = -116					; size = 4
_ctx$ = -112						; size = 88
_digest$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_CL_GetCDKeyHash PROC

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1003 : 	const char	*keyBuffer;
; 1004 : 	static char	szHashedKeyBuffer[256];
; 1005 : 	int		nKeyLength = 0;

	mov	DWORD PTR _nKeyLength$[ebp], 0

; 1006 : 	byte		digest[17]; // The MD5 Hash
; 1007 : 	MD5Context_t	ctx;
; 1008 : 
; 1009 : 	keyBuffer = Sys_GetMachineKey( &nKeyLength );

	lea	eax, DWORD PTR _nKeyLength$[ebp]
	push	eax
	call	_Sys_GetMachineKey
	add	esp, 4
	mov	DWORD PTR _keyBuffer$[ebp], eax

; 1010 : 
; 1011 : 	// now get the md5 hash of the key
; 1012 : 	memset( &ctx, 0, sizeof( ctx ));

	push	88					; 00000058H
	push	0
	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1013 : 	memset( digest, 0, sizeof( digest ));

	push	17					; 00000011H
	push	0
	lea	edx, DWORD PTR _digest$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1014 : 	
; 1015 : 	MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 1016 : 	MD5Update( &ctx, (byte *)keyBuffer, nKeyLength );

	mov	ecx, DWORD PTR _nKeyLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _keyBuffer$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 1017 : 	MD5Final( digest, &ctx );

	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _digest$[ebp]
	push	edx
	call	_MD5Final
	add	esp, 8

; 1018 : 	digest[16] = '\0';

	mov	eax, 1
	shl	eax, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 17			; 00000011H
	jae	SHORT $LN3@CL_GetCDKe
	jmp	SHORT $LN4@CL_GetCDKe
$LN3@CL_GetCDKe:
	call	___report_rangecheckfailure
$LN4@CL_GetCDKe:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _digest$[ebp+ecx], 0

; 1019 : 
; 1020 : 	memset( szHashedKeyBuffer, 0, 256 );

	push	256					; 00000100H
	push	0
	push	OFFSET ?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9
	call	_memset
	add	esp, 12					; 0000000cH

; 1021 : 	Q_strncpy( szHashedKeyBuffer, MD5_Print( digest ), sizeof( szHashedKeyBuffer ));

	push	256					; 00000100H
	lea	edx, DWORD PTR _digest$[ebp]
	push	edx
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET ?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1022 : 
; 1023 : 	return szHashedKeyBuffer;

	mov	eax, OFFSET ?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9
$LN2@CL_GetCDKe:

; 1024 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetCDKeyHash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_size$ = -272						; size = 4
_buf$ = -268						; size = 4
_name$ = -264						; size = 4
_ctx$1 = -260						; size = 88
_custResource$ = -172					; size = 136
_md5$2 = -36						; size = 16
_md5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_CL_BeginUpload_f PROC

; 906  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 907  : 	char		*name;
; 908  : 	resource_t	custResource;
; 909  : 	byte		*buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 910  : 	int		size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 911  : 	byte		md5[16];
; 912  : 
; 913  : 	name = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 914  : 
; 915  : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_BeginUp

; 916  : 		return;

	jmp	$LN10@CL_BeginUp
$LN2@CL_BeginUp:

; 917  : 
; 918  : 	if( !cl_allow_upload.value )

	movss	xmm0, DWORD PTR _cl_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_BeginUp

; 919  : 		return;

	jmp	$LN10@CL_BeginUp
$LN3@CL_BeginUp:

; 920  : 
; 921  : 	if( Q_strlen( name ) != 36 || Q_strnicmp( name, "!MD5", 4 ))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN5@CL_BeginUp
	push	4
	push	OFFSET $SG144922
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@CL_BeginUp
$LN5@CL_BeginUp:

; 922  : 	{
; 923  : 		Con_Printf( "Ingoring upload of non-customization\n" );

	push	OFFSET $SG144923
	call	_Con_Printf
	add	esp, 4

; 924  : 		return;

	jmp	$LN10@CL_BeginUp
$LN4@CL_BeginUp:

; 925  : 	}
; 926  : 
; 927  : 	memset( &custResource, 0, sizeof( custResource ));

	push	136					; 00000088H
	push	0
	lea	eax, DWORD PTR _custResource$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 928  : 	COM_HexConvert( name + 4, 32, md5 );

	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	push	32					; 00000020H
	mov	edx, DWORD PTR _name$[ebp]
	add	edx, 4
	push	edx
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 929  : 
; 930  : 	if( HPAK_ResourceForHash( CUSTOM_RES_PATH, md5, &custResource ))

	lea	eax, DWORD PTR _custResource$[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	push	OFFSET $SG144925
	call	_HPAK_ResourceForHash
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN9@CL_BeginUp

; 931  : 	{
; 932  : 		if( memcmp( md5, custResource.rgucMD5_hash, 16 ))

	push	16					; 00000010H
	lea	edx, DWORD PTR _custResource$[ebp+77]
	push	edx
	lea	eax, DWORD PTR _md5$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@CL_BeginUp

; 933  : 		{
; 934  : 			Con_Reportf( "Bogus data retrieved from %s, attempting to delete entry\n", CUSTOM_RES_PATH );

	push	OFFSET $SG144927
	push	OFFSET $SG144928
	call	_Con_Reportf
	add	esp, 8

; 935  : 			HPAK_RemoveLump( CUSTOM_RES_PATH, &custResource );

	lea	ecx, DWORD PTR _custResource$[ebp]
	push	ecx
	push	OFFSET $SG144929
	call	_HPAK_RemoveLump
	add	esp, 8

; 936  : 			return;

	jmp	$LN10@CL_BeginUp
$LN7@CL_BeginUp:

; 937  : 		}
; 938  : 
; 939  : 		if( HPAK_GetDataPointer( CUSTOM_RES_PATH, &custResource, &buf, &size ))

	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _custResource$[ebp]
	push	ecx
	push	OFFSET $SG144931
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN9@CL_BeginUp

; 940  : 		{
; 941  : 			byte		md5[16];
; 942  : 			MD5Context_t	ctx;
; 943  : 
; 944  : 			memset( &ctx, 0, sizeof( ctx ));

	push	88					; 00000058H
	push	0
	lea	edx, DWORD PTR _ctx$1[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 945  : 			MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$1[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 946  : 			MD5Update( &ctx, buf, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$1[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 947  : 			MD5Final( md5, &ctx );

	lea	ecx, DWORD PTR _ctx$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _md5$2[ebp]
	push	edx
	call	_MD5Final
	add	esp, 8

; 948  : 
; 949  : 			if( memcmp( custResource.rgucMD5_hash, md5, 16 ))

	push	16					; 00000010H
	lea	eax, DWORD PTR _md5$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _custResource$[ebp+77]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@CL_BeginUp

; 950  : 			{
; 951  : 				Con_Reportf( "HPAK_AddLump called with bogus lump, md5 mismatch\n" );

	push	OFFSET $SG144933
	call	_Con_Reportf
	add	esp, 4

; 952  : 				Con_Reportf( "Purported:  %s\n", MD5_Print( custResource.rgucMD5_hash ) );

	lea	edx, DWORD PTR _custResource$[ebp+77]
	push	edx
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET $SG144934
	call	_Con_Reportf
	add	esp, 8

; 953  : 				Con_Reportf( "Actual   :  %s\n", MD5_Print( md5 ) );

	lea	eax, DWORD PTR _md5$2[ebp]
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET $SG144935
	call	_Con_Reportf
	add	esp, 8

; 954  : 				Con_Reportf( "Removing conflicting lump\n" );

	push	OFFSET $SG144936
	call	_Con_Reportf
	add	esp, 4

; 955  : 				HPAK_RemoveLump( CUSTOM_RES_PATH, &custResource );

	lea	ecx, DWORD PTR _custResource$[ebp]
	push	ecx
	push	OFFSET $SG144937
	call	_HPAK_RemoveLump
	add	esp, 8

; 956  : 				return;

	jmp	SHORT $LN10@CL_BeginUp
$LN9@CL_BeginUp:

; 957  : 			}
; 958  : 		}
; 959  : 	}
; 960  : 
; 961  : 	if( buf && size > 0 )

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN10@CL_BeginUp
	cmp	DWORD PTR _size$[ebp], 0
	jle	SHORT $LN10@CL_BeginUp

; 962  : 	{
; 963  : 		Netchan_CreateFileFragmentsFromBuffer( &cls.netchan, name, buf, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET _cls+23520
	call	_Netchan_CreateFileFragmentsFromBuffer
	add	esp, 16					; 00000010H

; 964  : 		Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_FragSend
	add	esp, 4

; 965  : 		Mem_Free( buf );

	push	965					; 000003c5H
	push	OFFSET $SG144939
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN10@CL_BeginUp:

; 966  : 	}
; 967  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_BeginUpload_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_size$ = -8092						; size = 4
_numcmds$ = -8088					; size = 4
_outgoing_sequence$1 = -8084				; size = 4
_from$ = -8080						; size = 4
_to$ = -8076						; size = 4
tv229 = -8072						; size = 4
tv228 = -8068						; size = 4
tv205 = -8064						; size = 4
tv204 = -8060						; size = 4
tv81 = -8056						; size = 4
tv80 = -8052						; size = 4
_buf$ = -8048						; size = 20
_cmdnumber$ = -8028					; size = 4
_key$ = -8024						; size = 4
_send_command$ = -8020					; size = 4
_numbackup$ = -8016					; size = 4
_i$ = -8012						; size = 4
_newcmds$ = -8008					; size = 4
_data$ = -8004						; size = 8000
__$ArrayPad$ = -4					; size = 4
_CL_WritePacket PROC

; 712  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8092				; 00001f9cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 713  : 	sizebuf_t		buf;
; 714  : 	qboolean		send_command = false;

	mov	DWORD PTR _send_command$[ebp], 0

; 715  : 	byte		data[MAX_CMD_BUFFER];
; 716  : 	int		i, from, to, key, size;
; 717  : 	int		numbackup = 2;

	mov	DWORD PTR _numbackup$[ebp], 2

; 718  : 	int		numcmds;
; 719  : 	int		newcmds;
; 720  : 	int		cmdnumber;
; 721  : 	
; 722  : 	// don't send anything if playing back a demo
; 723  : 	if( cls.demoplayback || cls.state < ca_connected || cls.state == ca_cinematic )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN6@CL_WritePa
	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN6@CL_WritePa
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN5@CL_WritePa
$LN6@CL_WritePa:

; 724  : 		return;

	jmp	$LN1@CL_WritePa
$LN5@CL_WritePa:

; 725  : 
; 726  : 	CL_ComputePacketLoss ();

	call	_CL_ComputePacketLoss

; 727  : 
; 728  : 	MSG_Init( &buf, "ClientData", data, sizeof( data ));

	push	-1
	push	8000					; 00001f40H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET $SG144871
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 729  : 
; 730  : 	// Determine number of backup commands to send along
; 731  : 	numbackup = bound( 0, cl_cmdbackup->value, MAX_BACKUP_COMMANDS );

	mov	edx, DWORD PTR _cl_cmdbackup
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN38@CL_WritePa
	mov	eax, DWORD PTR _cl_cmdbackup
	movss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN36@CL_WritePa
	mov	ecx, DWORD PTR _cl_cmdbackup
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN37@CL_WritePa
$LN36@CL_WritePa:
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv80[ebp], xmm0
$LN37@CL_WritePa:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR tv81[ebp], xmm0
	jmp	SHORT $LN39@CL_WritePa
$LN38@CL_WritePa:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv81[ebp], xmm0
$LN39@CL_WritePa:
	cvttss2si edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _numbackup$[ebp], edx

; 732  : 	if( cls.state == ca_connected ) numbackup = 0;

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN7@CL_WritePa
	mov	DWORD PTR _numbackup$[ebp], 0
$LN7@CL_WritePa:

; 733  : 
; 734  : 	// clamp cmdrate
; 735  : 	if( cl_cmdrate->value < 0.0f ) Cvar_SetValue( "cl_cmdrate", 0.0f );

	mov	eax, DWORD PTR _cl_cmdrate
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN8@CL_WritePa
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144875
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN10@CL_WritePa
$LN8@CL_WritePa:

; 736  : 	else if( cl_cmdrate->value > 100.0f ) Cvar_SetValue( "cl_cmdrate", 100.0f );

	mov	ecx, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN10@CL_WritePa
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144877
	call	_Cvar_SetValue
	add	esp, 8
$LN10@CL_WritePa:

; 737  : 
; 738  : 	// Check to see if we can actually send this command
; 739  : 
; 740  : 	// In single player, send commands as fast as possible
; 741  : 	// Otherwise, only send when ready and when not choking bandwidth
; 742  : 	if( cl.maxclients == 1 || ( NET_IsLocalAddress( cls.netchan.remote_address ) && !host_limitlocal->value ))

	cmp	DWORD PTR _cl+1568832, 1
	je	SHORT $LN12@CL_WritePa
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _cls+23524
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _cls+23528
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _cls+23532
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _cls+23536
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _cls+23540
	mov	DWORD PTR [edx+16], eax
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN11@CL_WritePa
	mov	ecx, DWORD PTR _host_limitlocal
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@CL_WritePa
$LN12@CL_WritePa:

; 743  : 		send_command = true;

	mov	DWORD PTR _send_command$[ebp], 1
$LN11@CL_WritePa:

; 744  : 
; 745  : 	if(( host.realtime >= cls.nextcmdtime ) && Netchan_CanPacket( &cls.netchan, true ))

	cvtss2sd xmm0, DWORD PTR _cls+287340
	movsd	xmm1, QWORD PTR _host+1440
	comisd	xmm1, xmm0
	jb	SHORT $LN13@CL_WritePa
	push	1
	push	OFFSET _cls+23520
	call	_Netchan_CanPacket
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@CL_WritePa

; 746  : 		send_command = true;

	mov	DWORD PTR _send_command$[ebp], 1
$LN13@CL_WritePa:

; 747  : 
; 748  : 	if( cl.send_reply )

	cmp	DWORD PTR _cl+60, 0
	je	SHORT $LN14@CL_WritePa

; 749  : 	{
; 750  : 		cl.send_reply = false;

	mov	DWORD PTR _cl+60, 0

; 751  : 		send_command = true;

	mov	DWORD PTR _send_command$[ebp], 1
$LN14@CL_WritePa:

; 752  : 	}
; 753  : 
; 754  : 	// spectator is not sending cmds to server
; 755  : 	if( cls.spectator && cls.state == ca_active && cl.delta_sequence == cl.validsequence )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN16@CL_WritePa
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN16@CL_WritePa
	mov	edx, DWORD PTR _cl+28
	cmp	edx, DWORD PTR _cl+4
	jne	SHORT $LN16@CL_WritePa

; 756  : 	{
; 757  : 		if( !( cls.demorecording && cls.demowaiting ) && cls.nextcmdtime + 1.0f > host.realtime )

	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN17@CL_WritePa
	cmp	DWORD PTR _cls+297584, 0
	jne	SHORT $LN16@CL_WritePa
$LN17@CL_WritePa:
	movss	xmm0, DWORD PTR _cls+287340
	addss	xmm0, DWORD PTR __real@3f800000
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN16@CL_WritePa

; 758  : 			return;

	jmp	$LN1@CL_WritePa
$LN16@CL_WritePa:

; 759  : 	}
; 760  : 
; 761  : 	if(( cls.netchan.outgoing_sequence - cls.netchan.incoming_acknowledged ) >= CL_UPDATE_MASK )

	mov	eax, DWORD PTR _cls+23600
	sub	eax, DWORD PTR _cls+23588
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	cmp	eax, ecx
	jl	SHORT $LN19@CL_WritePa

; 762  : 	{
; 763  : 		if(( host.realtime - cls.netchan.last_received ) > CONNECTION_PROBLEM_TIME )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+23552
	comisd	xmm0, QWORD PTR __real@402e000000000000
	jbe	SHORT $LN19@CL_WritePa

; 764  : 		{
; 765  : 			Con_NPrintf( 1, "^3Warning:^1 Connection Problem^7\n" );

	push	OFFSET $SG144887
	push	1
	call	_Con_NPrintf
	add	esp, 8

; 766  : 			cl.validsequence = 0;

	mov	DWORD PTR _cl+4, 0
$LN19@CL_WritePa:

; 767  : 		}
; 768  : 	}
; 769  : 
; 770  : 	if( cl_nodelta->value )

	mov	edx, DWORD PTR _cl_nodelta
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@CL_WritePa

; 771  : 		cl.validsequence = 0;

	mov	DWORD PTR _cl+4, 0
$LN20@CL_WritePa:

; 772  : 
; 773  : 	if( send_command )

	cmp	DWORD PTR _send_command$[ebp], 0
	je	$LN21@CL_WritePa

; 774  : 	{
; 775  : 		int	outgoing_sequence;
; 776  : 	
; 777  : 		if( cl_cmdrate->value > 0 ) // clamped between 10 and 100 fps

	mov	eax, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN23@CL_WritePa

; 778  : 			cls.nextcmdtime = host.realtime + bound( 0.1f, ( 1.0f / cl_cmdrate->value ), 0.01f );

	mov	ecx, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN42@CL_WritePa
	mov	edx, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [edx+12]
	movss	xmm1, DWORD PTR __real@3c23d70a
	comiss	xmm1, xmm0
	jbe	SHORT $LN40@CL_WritePa
	mov	eax, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR tv204[ebp], xmm0
	jmp	SHORT $LN41@CL_WritePa
$LN40@CL_WritePa:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv204[ebp], xmm0
$LN41@CL_WritePa:
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR tv205[ebp], xmm0
	jmp	SHORT $LN43@CL_WritePa
$LN42@CL_WritePa:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv205[ebp], xmm0
$LN43@CL_WritePa:
	cvtss2sd xmm0, DWORD PTR tv205[ebp]
	addsd	xmm0, QWORD PTR _host+1440
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cls+287340, xmm0
	jmp	SHORT $LN24@CL_WritePa
$LN23@CL_WritePa:

; 779  : 		else cls.nextcmdtime = host.realtime; // always able to send right away

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+287340, xmm0
$LN24@CL_WritePa:

; 780  : 
; 781  : 		if( cls.lastoutgoingcommand == -1 )

	cmp	DWORD PTR _cls+287344, -1
	jne	SHORT $LN25@CL_WritePa

; 782  : 		{
; 783  : 			outgoing_sequence = cls.netchan.outgoing_sequence;

	mov	ecx, DWORD PTR _cls+23600
	mov	DWORD PTR _outgoing_sequence$1[ebp], ecx

; 784  : 			cls.lastoutgoingcommand = cls.netchan.outgoing_sequence;

	mov	edx, DWORD PTR _cls+23600
	mov	DWORD PTR _cls+287344, edx

; 785  : 		}

	jmp	SHORT $LN26@CL_WritePa
$LN25@CL_WritePa:

; 786  : 		else outgoing_sequence = cls.lastoutgoingcommand + 1;

	mov	eax, DWORD PTR _cls+287344
	add	eax, 1
	mov	DWORD PTR _outgoing_sequence$1[ebp], eax
$LN26@CL_WritePa:

; 787  : 
; 788  : 		// begin a client move command
; 789  : 		MSG_BeginClientCmd( &buf, clc_move );

	push	0
	push	0
	push	2
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 790  : 
; 791  : 		// save the position for a checksum byte
; 792  : 		key = MSG_GetRealBytesWritten( &buf );

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	mov	DWORD PTR _key$[ebp], eax

; 793  : 		MSG_WriteByte( &buf, 0 );

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 794  : 
; 795  : 		// write packet lossage percentation
; 796  : 		MSG_WriteByte( &buf, cls.packet_loss );

	cvttss2si ecx, DWORD PTR _cls+287324
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 797  : 
; 798  : 		// say how many backups we'll be sending
; 799  : 		MSG_WriteByte( &buf, numbackup );

	mov	eax, DWORD PTR _numbackup$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 800  : 
; 801  : 		// how many real commands have queued up
; 802  : 		newcmds = ( cls.netchan.outgoing_sequence - cls.lastoutgoingcommand );

	mov	edx, DWORD PTR _cls+23600
	sub	edx, DWORD PTR _cls+287344
	mov	DWORD PTR _newcmds$[ebp], edx

; 803  : 
; 804  : 		// put an upper/lower bound on this
; 805  : 		newcmds = bound( 0, newcmds, MAX_TOTAL_CMDS );

	js	SHORT $LN46@CL_WritePa
	cmp	DWORD PTR _newcmds$[ebp], 32		; 00000020H
	jge	SHORT $LN44@CL_WritePa
	mov	eax, DWORD PTR _newcmds$[ebp]
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN45@CL_WritePa
$LN44@CL_WritePa:
	mov	DWORD PTR tv228[ebp], 32		; 00000020H
$LN45@CL_WritePa:
	mov	ecx, DWORD PTR tv228[ebp]
	mov	DWORD PTR tv229[ebp], ecx
	jmp	SHORT $LN47@CL_WritePa
$LN46@CL_WritePa:
	mov	DWORD PTR tv229[ebp], 0
$LN47@CL_WritePa:
	mov	edx, DWORD PTR tv229[ebp]
	mov	DWORD PTR _newcmds$[ebp], edx

; 806  : 		if( cls.state == ca_connected ) newcmds = 0;

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN27@CL_WritePa
	mov	DWORD PTR _newcmds$[ebp], 0
$LN27@CL_WritePa:

; 807  : 	
; 808  : 		MSG_WriteByte( &buf, newcmds );

	mov	eax, DWORD PTR _newcmds$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 809  : 
; 810  : 		numcmds = newcmds + numbackup;

	mov	edx, DWORD PTR _newcmds$[ebp]
	add	edx, DWORD PTR _numbackup$[ebp]
	mov	DWORD PTR _numcmds$[ebp], edx

; 811  : 		from = -1;

	mov	DWORD PTR _from$[ebp], -1

; 812  : 
; 813  : 		for( i = numcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@CL_WritePa
$LN2@CL_WritePa:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_WritePa:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@CL_WritePa

; 814  : 		{
; 815  : 			cmdnumber = ( cls.netchan.outgoing_sequence - i ) & CL_UPDATE_MASK;

	mov	edx, DWORD PTR _cls+23600
	sub	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	edx, eax
	mov	DWORD PTR _cmdnumber$[ebp], edx

; 816  : 
; 817  : 			to = cmdnumber;

	mov	ecx, DWORD PTR _cmdnumber$[ebp]
	mov	DWORD PTR _to$[ebp], ecx

; 818  : 			CL_WriteUsercmd( &buf, from, to );

	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_CL_WriteUsercmd
	add	esp, 12					; 0000000cH

; 819  : 			from = to;

	mov	edx, DWORD PTR _to$[ebp]
	mov	DWORD PTR _from$[ebp], edx

; 820  : 
; 821  : 			if( MSG_CheckOverflow( &buf ))

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@CL_WritePa

; 822  : 				Host_Error( "CL_WritePacket: overflowed command buffer (%i bytes)\n", MAX_CMD_BUFFER );

	push	8000					; 00001f40H
	push	OFFSET $SG144897
	call	_Host_Error
	add	esp, 8
$LN28@CL_WritePa:

; 823  : 		}

	jmp	$LN2@CL_WritePa
$LN3@CL_WritePa:

; 824  : 
; 825  : 		// calculate a checksum over the move commands
; 826  : 		size = MSG_GetRealBytesWritten( &buf ) - key - 1;

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _key$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 827  : 		buf.pData[key] = CRC32_BlockSequence( buf.pData + key + 1, size, cls.netchan.outgoing_sequence );

	mov	edx, DWORD PTR _cls+23600
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	mov	edx, DWORD PTR _buf$[ebp+8]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	call	_CRC32_BlockSequence
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _buf$[ebp+8]
	add	ecx, DWORD PTR _key$[ebp]
	mov	BYTE PTR [ecx], al

; 828  : 
; 829  : 		// message we are constructing.
; 830  : 		i = cls.netchan.outgoing_sequence & CL_UPDATE_MASK;

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _cls+23600
	mov	DWORD PTR _i$[ebp], edx

; 831  : 	
; 832  : 		// determine if we need to ask for a new set of delta's.
; 833  : 		if( cl.validsequence && (cls.state == ca_active) && !( cls.demorecording && cls.demowaiting ))

	cmp	DWORD PTR _cl+4, 0
	je	SHORT $LN29@CL_WritePa
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN29@CL_WritePa
	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN31@CL_WritePa
	cmp	DWORD PTR _cls+297584, 0
	jne	SHORT $LN29@CL_WritePa
$LN31@CL_WritePa:

; 834  : 		{
; 835  : 			cl.delta_sequence = cl.validsequence;

	mov	eax, DWORD PTR _cl+4
	mov	DWORD PTR _cl+28, eax

; 836  : 
; 837  : 			MSG_BeginClientCmd( &buf, clc_delta );

	push	0
	push	0
	push	4
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 838  : 			MSG_WriteByte( &buf, cl.validsequence & 0xFF );

	mov	edx, DWORD PTR _cl+4
	and	edx, 255				; 000000ffH
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 839  : 		}

	jmp	SHORT $LN30@CL_WritePa
$LN29@CL_WritePa:

; 840  : 		else
; 841  : 		{
; 842  : 			// request delta compression of entities
; 843  : 			cl.delta_sequence = -1;

	mov	DWORD PTR _cl+28, -1
$LN30@CL_WritePa:

; 844  : 		}
; 845  : 
; 846  : 		if( MSG_CheckOverflow( &buf ))

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@CL_WritePa

; 847  : 			Host_Error( "CL_WritePacket: overflowed command buffer (%i bytes)\n", MAX_CMD_BUFFER );

	push	8000					; 00001f40H
	push	OFFSET $SG144902
	call	_Host_Error
	add	esp, 8
$LN32@CL_WritePa:

; 848  : 
; 849  : 		// remember outgoing command that we are sending
; 850  : 		cls.lastoutgoingcommand = cls.netchan.outgoing_sequence;

	mov	edx, DWORD PTR _cls+23600
	mov	DWORD PTR _cls+287344, edx

; 851  : 
; 852  : 		// update size counter for netgraph
; 853  : 		cl.commands[cls.netchan.outgoing_sequence & CL_UPDATE_MASK].sendsize = MSG_GetNumBytesWritten( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _cls+23600
	imul	edx, ecx, 88
	mov	DWORD PTR _cl[edx+1107624], eax

; 854  : 		cl.commands[cls.netchan.outgoing_sequence & CL_UPDATE_MASK].heldback = false;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23600
	imul	ecx, eax, 88
	mov	DWORD PTR _cl[ecx+1107620], 0

; 855  : 
; 856  : 		// composite the rest of the datagram..
; 857  : 		if( MSG_GetNumBitsWritten( &cls.datagram ) <= MSG_GetNumBitsLeft( &buf ))

	push	OFFSET _cls+7116
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	esi, eax
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	esi, eax
	jg	SHORT $LN33@CL_WritePa

; 858  : 			MSG_WriteBits( &buf, MSG_GetData( &cls.datagram ), MSG_GetNumBitsWritten( &cls.datagram ));

	push	OFFSET _cls+7116
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+7116
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
$LN33@CL_WritePa:

; 859  : 		MSG_Clear( &cls.datagram );

	push	OFFSET _cls+7116
	call	_MSG_Clear
	add	esp, 4

; 860  : 
; 861  : 		// deliver the message (or update reliable)
; 862  : 		Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+23520
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 863  : 	}

	jmp	SHORT $LN22@CL_WritePa
$LN21@CL_WritePa:

; 864  : 	else
; 865  : 	{
; 866  : 		// mark command as held back so we'll send it next time
; 867  : 		cl.commands[cls.netchan.outgoing_sequence & CL_UPDATE_MASK].heldback = true;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23600
	imul	ecx, eax, 88
	mov	DWORD PTR _cl[ecx+1107620], 1

; 868  : 
; 869  : 		// increment sequence number so we can detect that we've held back packets.
; 870  : 		cls.netchan.outgoing_sequence++;

	mov	edx, DWORD PTR _cls+23600
	add	edx, 1
	mov	DWORD PTR _cls+23600, edx
$LN22@CL_WritePa:

; 871  : 	}
; 872  : 
; 873  : 	if( cls.demorecording && numbackup > 0 )

	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN34@CL_WritePa
	cmp	DWORD PTR _numbackup$[ebp], 0
	jle	SHORT $LN34@CL_WritePa

; 874  : 	{
; 875  : 		// Back up one because we've incremented outgoing_sequence each frame by 1 unit
; 876  : 		cmdnumber = ( cls.netchan.outgoing_sequence - 1 ) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _cls+23600
	sub	eax, 1
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	mov	DWORD PTR _cmdnumber$[ebp], eax

; 877  : 		CL_WriteDemoUserCmd( cmdnumber );

	mov	edx, DWORD PTR _cmdnumber$[ebp]
	push	edx
	call	_CL_WriteDemoUserCmd
	add	esp, 4
$LN34@CL_WritePa:

; 878  : 	}
; 879  : 
; 880  : 	// update download/upload slider.
; 881  : 	Netchan_UpdateProgress( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_UpdateProgress
	add	esp, 4
$LN1@CL_WritePa:

; 882  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WritePacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv87 = -108						; size = 8
tv86 = -100						; size = 8
_ms$ = -92						; size = 4
_active$ = -88						; size = 4
_i$ = -84						; size = 4
tv142 = -80						; size = 4
_input_override$ = -76					; size = 4
_pcmd$ = -72						; size = 4
_cmd$ = -68						; size = 52
_angles$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_CL_CreateCmd PROC

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 616  : 	usercmd_t		cmd;
; 617  : 	runcmd_t		*pcmd;
; 618  : 	vec3_t		angles;
; 619  : 	qboolean		active;
; 620  : 	int		input_override;
; 621  : 	int		i, ms;
; 622  : 
; 623  : 	if( cls.state < ca_connected || cls.state == ca_cinematic )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN3@CL_CreateC
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN2@CL_CreateC
$LN3@CL_CreateC:

; 624  : 		return;

	jmp	$LN1@CL_CreateC
$LN2@CL_CreateC:

; 625  : 
; 626  : 	// store viewangles in case it's will be freeze
; 627  : 	VectorCopy( cl.viewangles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+1568612]
	mov	DWORD PTR _angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+1568612]
	mov	DWORD PTR _angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+1568612]
	mov	DWORD PTR _angles$[ebp+eax], ecx

; 628  : 	ms = bound( 1, host.frametime * 1000, 255 );

	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN14@CL_CreateC
	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN12@CL_CreateC
	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN13@CL_CreateC
$LN12@CL_CreateC:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv86[ebp], xmm0
$LN13@CL_CreateC:
	movsd	xmm0, QWORD PTR tv86[ebp]
	movsd	QWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN15@CL_CreateC
$LN14@CL_CreateC:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv87[ebp], xmm0
$LN15@CL_CreateC:
	cvttsd2si edx, QWORD PTR tv87[ebp]
	mov	DWORD PTR _ms$[ebp], edx

; 629  : 	memset( &cmd, 0, sizeof( cmd ));

	push	52					; 00000034H
	push	0
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 630  : 	input_override = 0;

	mov	DWORD PTR _input_override$[ebp], 0

; 631  : 
; 632  : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 633  : 	CL_PushPMStates();

	call	_CL_PushPMStates

; 634  : 	CL_SetSolidPlayers( cl.playernum );

	mov	ecx, DWORD PTR _cl+1568828
	push	ecx
	call	_CL_SetSolidPlayers
	add	esp, 4

; 635  : 
; 636  : 	// message we are constructing.
; 637  : 	i = cls.netchan.outgoing_sequence & CL_UPDATE_MASK;   

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _cls+23600
	mov	DWORD PTR _i$[ebp], edx

; 638  : 	pcmd = &cl.commands[i];

	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, OFFSET _cl+1107544
	mov	DWORD PTR _pcmd$[ebp], eax

; 639  : 	pcmd->processedfuncs = false;

	mov	ecx, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 640  : 
; 641  : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN4@CL_CreateC

; 642  : 	{
; 643  : 		pcmd->senttime = host.realtime;      

	mov	edx, DWORD PTR _pcmd$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx], xmm0

; 644  : 		memset( &pcmd->cmd, 0, sizeof( pcmd->cmd ));

	push	52					; 00000034H
	push	0
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 645  : 		pcmd->receivedtime = -1.0;

	mov	ecx, DWORD PTR _pcmd$[ebp]
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR [ecx+8], xmm0

; 646  : 		pcmd->heldback = false;

	mov	edx, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [edx+76], 0

; 647  : 		pcmd->sendsize = 0;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+80], 0
$LN4@CL_CreateC:

; 648  : 	}
; 649  : 
; 650  : 	active = (( cls.signon == SIGNONS ) && !cl.paused && !cls.demoplayback );

	cmp	DWORD PTR _cls+64, 2
	jne	SHORT $LN16@CL_CreateC
	cmp	DWORD PTR _cl+24, 0
	jne	SHORT $LN16@CL_CreateC
	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN16@CL_CreateC
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN17@CL_CreateC
$LN16@CL_CreateC:
	mov	DWORD PTR tv142[ebp], 0
$LN17@CL_CreateC:
	mov	ecx, DWORD PTR tv142[ebp]
	mov	DWORD PTR _active$[ebp], ecx

; 651  : 	clgame.dllFuncs.CL_CreateMove( host.frametime, &pcmd->cmd, active );

	mov	edx, DWORD PTR _active$[ebp]
	push	edx
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	cvtsd2ss xmm0, QWORD PTR _host+1448
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+60
	add	esp, 12					; 0000000cH

; 652  : 
; 653  : 	CL_PopPMStates();

	call	_CL_PopPMStates

; 654  : 
; 655  : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN5@CL_CreateC

; 656  : 	{
; 657  : 		CL_ComputeClientInterpolationAmount( &pcmd->cmd );

	mov	ecx, DWORD PTR _pcmd$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_CL_ComputeClientInterpolationAmount
	add	esp, 4

; 658  : 		pcmd->cmd.lightlevel = cl.local.light_level;

	mov	edx, DWORD PTR _pcmd$[ebp]
	mov	al, BYTE PTR _cl+1568564
	mov	BYTE PTR [edx+48], al

; 659  : 		pcmd->cmd.msec = ms;

	mov	ecx, DWORD PTR _pcmd$[ebp]
	mov	dl, BYTE PTR _ms$[ebp]
	mov	BYTE PTR [ecx+22], dl
$LN5@CL_CreateC:

; 660  : 	}
; 661  : 
; 662  : 	input_override |= CL_ProcessOverviewCmds( &pcmd->cmd );

	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_CL_ProcessOverviewCmds
	add	esp, 4
	or	eax, DWORD PTR _input_override$[ebp]
	mov	DWORD PTR _input_override$[ebp], eax

; 663  : 	input_override |= CL_ProcessShowTexturesCmds( &pcmd->cmd );

	mov	ecx, DWORD PTR _pcmd$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_CL_ProcessShowTexturesCmds
	add	esp, 4
	or	eax, DWORD PTR _input_override$[ebp]
	mov	DWORD PTR _input_override$[ebp], eax

; 664  : 
; 665  : 	if(( cl.background && !cls.demoplayback ) || input_override || cls.changelevel )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN8@CL_CreateC
	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN7@CL_CreateC
$LN8@CL_CreateC:
	cmp	DWORD PTR _input_override$[ebp], 0
	jne	SHORT $LN7@CL_CreateC
	cmp	DWORD PTR _cls+8, 0
	je	$LN9@CL_CreateC
$LN7@CL_CreateC:

; 666  : 	{
; 667  : 		VectorCopy( angles, pcmd->cmd.viewangles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pcmd$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [ecx+edx+24], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [eax+edx+24], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pcmd$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+24], edx

; 668  : 		VectorCopy( angles, cl.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR _cl[eax+1568612], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR _cl[eax+1568612], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR _cl[eax+1568612], ecx

; 669  : 		if( !cl.background ) pcmd->cmd.msec = 0;

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN9@CL_CreateC
	mov	edx, DWORD PTR _pcmd$[ebp]
	mov	BYTE PTR [edx+22], 0
$LN9@CL_CreateC:

; 670  : 	}
; 671  : 
; 672  : 	// demo always have commands so don't overwrite them
; 673  : 	if( !cls.demoplayback ) cl.cmd = &pcmd->cmd;

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN10@CL_CreateC
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _cl+1568604, eax
$LN10@CL_CreateC:

; 674  : 
; 675  : 	// predict all unacknowledged movements
; 676  : 	CL_PredictMovement( false );

	push	0
	call	_CL_PredictMovement
	add	esp, 4
$LN1@CL_CreateC:

; 677  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_cdat$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_CL_UpdateClientData PROC

; 588  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 589  : 	client_data_t	cdat;
; 590  : 
; 591  : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN2@CL_UpdateC

; 592  : 		return;

	jmp	$LN3@CL_UpdateC
$LN2@CL_UpdateC:

; 593  : 
; 594  : 	memset( &cdat, 0, sizeof( cdat ) );

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _cdat$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 595  : 
; 596  : 	VectorCopy( cl.viewangles, cdat.viewangles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl[edx+1568612]
	mov	DWORD PTR _cdat$[ebp+ecx+12], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cl[eax+1568612]
	mov	DWORD PTR _cdat$[ebp+ecx+12], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cl[eax+1568612]
	mov	DWORD PTR _cdat$[ebp+ecx+12], edx

; 597  : 	VectorCopy( clgame.entities[cl.viewentity].origin, cdat.origin );

	imul	eax, DWORD PTR _cl+1568608, 3000
	add	eax, DWORD PTR _clgame+1000
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx+2888]
	mov	DWORD PTR _cdat$[ebp+ecx], edx
	imul	eax, DWORD PTR _cl+1568608, 3000
	add	eax, DWORD PTR _clgame+1000
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx+2888]
	mov	DWORD PTR _cdat$[ebp+edx], eax
	imul	ecx, DWORD PTR _cl+1568608, 3000
	add	ecx, DWORD PTR _clgame+1000
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx+2888]
	mov	DWORD PTR _cdat$[ebp+eax], ecx

; 598  : 	cdat.iWeaponBits = cl.local.weapons;

	mov	edx, DWORD PTR _cl+1568584
	mov	DWORD PTR _cdat$[ebp+24], edx

; 599  : 	cdat.fov = cl.local.scr_fov;

	movss	xmm0, DWORD PTR _cl+1568592
	movss	DWORD PTR _cdat$[ebp+28], xmm0

; 600  : 
; 601  : 	if( clgame.dllFuncs.pfnUpdateClientData( &cdat, cl.time ))

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _cdat$[ebp]
	push	eax
	call	DWORD PTR _clgame+20
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@CL_UpdateC

; 602  : 	{
; 603  : 		// grab changes if successful
; 604  : 		VectorCopy( cdat.viewangles, cl.viewangles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cdat$[ebp+edx+12]
	mov	DWORD PTR _cl[ecx+1568612], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cdat$[ebp+eax+12]
	mov	DWORD PTR _cl[ecx+1568612], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cdat$[ebp+eax+12]
	mov	DWORD PTR _cl[ecx+1568612], edx

; 605  : 		cl.local.scr_fov = cdat.fov;

	movss	xmm0, DWORD PTR _cdat$[ebp+28]
	movss	DWORD PTR _cl+1568592, xmm0
$LN3@CL_UpdateC:

; 606  : 	}
; 607  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateClientData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_size$ = -24						; size = 4
tv66 = -20						; size = 4
_step2$ = -16						; size = 4
_step$ = -12						; size = 4
_sign$ = -8						; size = 4
_ov$ = -4						; size = 4
_cmd$ = 8						; size = 4
_CL_ProcessOverviewCmds PROC

; 536  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 537  : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+125416

; 538  : 	int		sign = 1;

	mov	DWORD PTR _sign$[ebp], 1

; 539  : 	float		size = world.size[!ov->rotated] / world.size[ov->rotated];

	mov	eax, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN27@CL_Process
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN28@CL_Process
$LN27@CL_Process:
	mov	DWORD PTR tv66[ebp], 0
$LN28@CL_Process:
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR tv66[ebp]
	movss	xmm0, DWORD PTR _world[eax*4+2624]
	divss	xmm0, DWORD PTR _world[edx*4+2624]
	movss	DWORD PTR _size$[ebp], xmm0

; 540  : 	float		step = (2.0f / size) * host.realframetime;

	movss	xmm0, DWORD PTR __real@40000000
	divss	xmm0, DWORD PTR _size$[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR _host+1456
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _step$[ebp], xmm0

; 541  : 	float		step2 = step * 100.0f * (2.0f / ov->flZoom);

	movss	xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	divss	xmm1, DWORD PTR [ecx+40]
	mulss	xmm0, xmm1
	movss	DWORD PTR _step2$[ebp], xmm0

; 542  : 
; 543  : 	if( !CL_IsDevOverviewMode() || gl_showtextures->value )

	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN3@CL_Process
	mov	edx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@CL_Process
$LN3@CL_Process:

; 544  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Process
$LN2@CL_Process:

; 545  : 
; 546  : 	if( ov->flZoom < 0.0f ) sign = -1;

	mov	eax, DWORD PTR _ov$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+40]
	jbe	SHORT $LN4@CL_Process
	mov	DWORD PTR _sign$[ebp], -1
$LN4@CL_Process:

; 547  : 
; 548  : 	if( cmd->upmove > 0.0f ) ov->zNear += step;

	mov	ecx, DWORD PTR _cmd$[ebp]
	movss	xmm0, DWORD PTR [ecx+24]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@CL_Process
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	addss	xmm0, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+36], xmm0
	jmp	SHORT $LN7@CL_Process
$LN5@CL_Process:

; 549  : 	else if( cmd->upmove < 0.0f ) ov->zNear -= step;

	mov	ecx, DWORD PTR _cmd$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+24]
	jbe	SHORT $LN7@CL_Process
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	subss	xmm0, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+36], xmm0
$LN7@CL_Process:

; 550  : 
; 551  : 	if( cmd->buttons & IN_JUMP ) ov->zFar += step;

	mov	ecx, DWORD PTR _cmd$[ebp]
	movzx	edx, WORD PTR [ecx+30]
	and	edx, 2
	je	SHORT $LN8@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
	jmp	SHORT $LN10@CL_Process
$LN8@CL_Process:

; 552  : 	else if( cmd->buttons & IN_DUCK ) ov->zFar -= step;

	mov	edx, DWORD PTR _cmd$[ebp]
	movzx	eax, WORD PTR [edx+30]
	and	eax, 4
	je	SHORT $LN10@CL_Process
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	subss	xmm0, DWORD PTR _step$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+32], xmm0
$LN10@CL_Process:

; 553  : 
; 554  : 	if( cmd->buttons & IN_FORWARD ) ov->origin[ov->rotated] -= sign * step2;

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	and	ecx, 8
	je	SHORT $LN11@CL_Process
	mov	edx, DWORD PTR _ov$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax*4]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _ov$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm1
	jmp	SHORT $LN13@CL_Process
$LN11@CL_Process:

; 555  : 	else if( cmd->buttons & IN_BACK ) ov->origin[ov->rotated] += sign * step2;

	mov	edx, DWORD PTR _cmd$[ebp]
	movzx	eax, WORD PTR [edx+30]
	and	eax, 16					; 00000010H
	je	SHORT $LN13@CL_Process
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
$LN13@CL_Process:

; 556  : 
; 557  : 	if( ov->rotated )

	mov	ecx, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN14@CL_Process

; 558  : 	{
; 559  : 		if( cmd->buttons & ( IN_RIGHT|IN_MOVERIGHT ))

	mov	edx, DWORD PTR _cmd$[ebp]
	movzx	eax, WORD PTR [edx+30]
	and	eax, 1280				; 00000500H
	je	SHORT $LN16@CL_Process

; 560  : 			ov->origin[0] -= sign * step2;

	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	subss	xmm1, xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+edx], xmm1
	jmp	SHORT $LN18@CL_Process
$LN16@CL_Process:

; 561  : 		else if( cmd->buttons & ( IN_LEFT|IN_MOVELEFT ))

	mov	ecx, DWORD PTR _cmd$[ebp]
	movzx	edx, WORD PTR [ecx+30]
	and	edx, 640				; 00000280H
	je	SHORT $LN18@CL_Process

; 562  : 			ov->origin[0] += sign * step2;

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
$LN18@CL_Process:

; 563  : 	}

	jmp	SHORT $LN21@CL_Process
$LN14@CL_Process:

; 564  : 	else
; 565  : 	{
; 566  : 		if( cmd->buttons & ( IN_RIGHT|IN_MOVERIGHT ))

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	and	ecx, 1280				; 00000500H
	je	SHORT $LN19@CL_Process

; 567  : 			ov->origin[1] += sign * step2;

	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	jmp	SHORT $LN21@CL_Process
$LN19@CL_Process:

; 568  : 		else if( cmd->buttons & ( IN_LEFT|IN_MOVELEFT ))

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	and	ecx, 640				; 00000280H
	je	SHORT $LN21@CL_Process

; 569  : 			ov->origin[1] -= sign * step2;

	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx], xmm1
$LN21@CL_Process:

; 570  : 	}
; 571  : 
; 572  : 	if( cmd->buttons & IN_ATTACK ) ov->flZoom += step;

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	and	ecx, 1
	je	SHORT $LN22@CL_Process
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	addss	xmm0, DWORD PTR _step$[ebp]
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+40], xmm0
	jmp	SHORT $LN24@CL_Process
$LN22@CL_Process:

; 573  : 	else if( cmd->buttons & IN_ATTACK2 ) ov->flZoom -= step;

	mov	ecx, DWORD PTR _cmd$[ebp]
	movzx	edx, WORD PTR [ecx+30]
	and	edx, 2048				; 00000800H
	je	SHORT $LN24@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	subss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+40], xmm0
$LN24@CL_Process:

; 574  : 
; 575  : 	if( ov->flZoom == 0.0f ) ov->flZoom = 0.0001f; // to prevent disivion by zero

	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR __real@38d1b717
	movss	DWORD PTR [eax+40], xmm0
$LN25@CL_Process:

; 576  : 
; 577  : 	return true;

	mov	eax, 1
$LN1@CL_Process:

; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessOverviewCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_pressed$ = -16						; size = 4
tv93 = -12						; size = 4
_released$ = -8						; size = 4
_changed$ = -4						; size = 4
_cmd$ = 8						; size = 4
_CL_ProcessShowTexturesCmds PROC

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 508  : 	static int	oldbuttons;
; 509  : 	int		changed;
; 510  : 	int		pressed, released;
; 511  : 
; 512  : 	if( !gl_showtextures->value || CL_IsDevOverviewMode( ))

	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_Process
	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN2@CL_Process
$LN3@CL_Process:

; 513  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Process
$LN2@CL_Process:

; 514  : 
; 515  : 	changed = (oldbuttons ^ cmd->buttons);

	mov	ecx, DWORD PTR _cmd$[ebp]
	movzx	edx, WORD PTR [ecx+30]
	xor	edx, DWORD PTR ?oldbuttons@?1??CL_ProcessShowTexturesCmds@@9@9
	mov	DWORD PTR _changed$[ebp], edx

; 516  : 	pressed =  changed & cmd->buttons;

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	and	ecx, DWORD PTR _changed$[ebp]
	mov	DWORD PTR _pressed$[ebp], ecx

; 517  : 	released = changed & (~cmd->buttons);

	mov	edx, DWORD PTR _cmd$[ebp]
	movzx	eax, WORD PTR [edx+30]
	not	eax
	and	eax, DWORD PTR _changed$[ebp]
	mov	DWORD PTR _released$[ebp], eax

; 518  : 
; 519  : 	if( released & ( IN_RIGHT|IN_MOVERIGHT ))

	mov	ecx, DWORD PTR _released$[ebp]
	and	ecx, 1280				; 00000500H
	je	SHORT $LN4@CL_Process

; 520  : 		Cvar_SetValue( "r_showtextures", gl_showtextures->value + 1 );

	mov	edx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [edx+12]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144769
	call	_Cvar_SetValue
	add	esp, 8
$LN4@CL_Process:

; 521  : 	if( released & ( IN_LEFT|IN_MOVELEFT ))

	mov	eax, DWORD PTR _released$[ebp]
	and	eax, 640				; 00000280H
	je	SHORT $LN5@CL_Process

; 522  : 		Cvar_SetValue( "r_showtextures", max( 1, gl_showtextures->value - 1 ));

	mov	ecx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@CL_Process
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv93[ebp], xmm0
	jmp	SHORT $LN8@CL_Process
$LN7@CL_Process:
	mov	edx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [edx+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv93[ebp], xmm0
$LN8@CL_Process:
	push	ecx
	movss	xmm0, DWORD PTR tv93[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144771
	call	_Cvar_SetValue
	add	esp, 8
$LN5@CL_Process:

; 523  : 	oldbuttons = cmd->buttons;

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	mov	DWORD PTR ?oldbuttons@?1??CL_ProcessShowTexturesCmds@@9@9, ecx

; 524  : 
; 525  : 	return true;

	mov	eax, 1
$LN1@CL_Process:

; 526  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessShowTexturesCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_amove$ = -20						; size = 4
_frac$ = -16						; size = 4
_next$ = -12						; size = 4
_addangletotal$ = -8					; size = 4
_prev$ = -4						; size = 4
_CL_ApplyAddAngle PROC

; 471  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 472  : 	pred_viewangle_t	*prev = NULL, *next = NULL;

	mov	DWORD PTR _prev$[ebp], 0
	mov	DWORD PTR _next$[ebp], 0

; 473  : 	float		addangletotal = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _addangletotal$[ebp], xmm0

; 474  : 	float		amove, frac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 475  : 
; 476  : 	CL_FindInterpolatedAddAngle( cl.time, &frac, &prev, &next );

	lea	eax, DWORD PTR _next$[ebp]
	push	eax
	lea	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	lea	edx, DWORD PTR _frac$[ebp]
	push	edx
	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_CL_FindInterpolatedAddAngle
	add	esp, 16					; 00000010H

; 477  : 
; 478  : 	if( prev && next )

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN2@CL_ApplyAd
	cmp	DWORD PTR _next$[ebp], 0
	je	SHORT $LN2@CL_ApplyAd

; 479  : 		addangletotal = prev->total + frac * ( next->total - prev->total );

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR _prev$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	edx, DWORD PTR _prev$[ebp]
	addss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR _addangletotal$[ebp], xmm0
	jmp	SHORT $LN3@CL_ApplyAd
$LN2@CL_ApplyAd:

; 480  : 	else addangletotal = cl.prevaddangletotal;

	movss	xmm0, DWORD PTR _cl+1568800
	movss	DWORD PTR _addangletotal$[ebp], xmm0
$LN3@CL_ApplyAd:

; 481  : 
; 482  : 	amove = addangletotal - cl.prevaddangletotal;

	movss	xmm0, DWORD PTR _addangletotal$[ebp]
	subss	xmm0, DWORD PTR _cl+1568800
	movss	DWORD PTR _amove$[ebp], xmm0

; 483  : 
; 484  : 	// update input angles
; 485  : 	cl.viewangles[YAW] += amove;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+1568612]
	addss	xmm0, DWORD PTR _amove$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _cl[ecx+1568612], xmm0

; 486  : 
; 487  : 	// remember last total
; 488  : 	cl.prevaddangletotal = addangletotal;

	movss	xmm0, DWORD PTR _addangletotal$[ebp]
	movss	DWORD PTR _cl+1568800, xmm0

; 489  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ApplyAddAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv134 = -28						; size = 4
tv133 = -24						; size = 4
_i1$ = -20						; size = 4
_at$ = -16						; size = 4
_i0$ = -12						; size = 4
_i$ = -8						; size = 4
_imod$ = -4						; size = 4
_t$ = 8							; size = 4
_frac$ = 12						; size = 4
_prev$ = 16						; size = 4
_next$ = 20						; size = 4
_CL_FindInterpolatedAddAngle PROC

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 430  : 	int	i, i0, i1, imod;
; 431  : 	float	at;
; 432  : 
; 433  : 	imod = cl.angle_position - 1;

	mov	eax, DWORD PTR _cl+1568792
	sub	eax, 1
	mov	DWORD PTR _imod$[ebp], eax

; 434  : 	i0 = (imod + 1) & ANGLE_MASK;

	mov	ecx, DWORD PTR _imod$[ebp]
	add	ecx, 1
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _i0$[ebp], ecx

; 435  : 	i1 = (imod + 0) & ANGLE_MASK;

	mov	edx, DWORD PTR _imod$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _i1$[ebp], edx

; 436  : 
; 437  : 	if( cl.predicted_angle[i0].starttime >= t )

	mov	eax, DWORD PTR _i0$[ebp]
	movss	xmm0, DWORD PTR _cl[eax*8+1568664]
	comiss	xmm0, DWORD PTR _t$[ebp]
	jb	SHORT $LN3@CL_FindInt

; 438  : 	{
; 439  : 		for( i = 0; i < ANGLE_BACKUP - 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FindInt
$LN2@CL_FindInt:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_FindInt:
	cmp	DWORD PTR _i$[ebp], 14			; 0000000eH
	jge	SHORT $LN3@CL_FindInt

; 440  : 		{
; 441  : 			at = cl.predicted_angle[imod & ANGLE_MASK].starttime;

	mov	edx, DWORD PTR _imod$[ebp]
	and	edx, 15					; 0000000fH
	movss	xmm0, DWORD PTR _cl[edx*8+1568664]
	movss	DWORD PTR _at$[ebp], xmm0

; 442  : 			if( at == 0.0f ) break;

	movss	xmm0, DWORD PTR _at$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@CL_FindInt
	jmp	SHORT $LN3@CL_FindInt
$LN6@CL_FindInt:

; 443  : 
; 444  : 			if( at < t )

	movss	xmm0, DWORD PTR _t$[ebp]
	comiss	xmm0, DWORD PTR _at$[ebp]
	jbe	SHORT $LN7@CL_FindInt

; 445  : 			{
; 446  : 				i0 = (imod + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i0$[ebp], eax

; 447  : 				i1 = (imod + 0) & ANGLE_MASK;

	mov	ecx, DWORD PTR _imod$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _i1$[ebp], ecx

; 448  : 				break;

	jmp	SHORT $LN3@CL_FindInt
$LN7@CL_FindInt:

; 449  : 			}
; 450  : 			imod--;

	mov	edx, DWORD PTR _imod$[ebp]
	sub	edx, 1
	mov	DWORD PTR _imod$[ebp], edx

; 451  : 		}

	jmp	SHORT $LN2@CL_FindInt
$LN3@CL_FindInt:

; 452  : 	}
; 453  : 
; 454  : 	*next = &cl.predicted_angle[i0];

	mov	eax, DWORD PTR _i0$[ebp]
	lea	ecx, DWORD PTR _cl[eax*8+1568664]
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [edx], ecx

; 455  : 	*prev = &cl.predicted_angle[i1];

	mov	eax, DWORD PTR _i1$[ebp]
	lea	ecx, DWORD PTR _cl[eax*8+1568664]
	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [edx], ecx

; 456  : 
; 457  : 	// avoid division by zero (probably this should never happens)
; 458  : 	if((*prev)->starttime == (*next)->starttime )

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, DWORD PTR [eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_FindInt

; 459  : 	{
; 460  : 		*prev = *next;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 461  : 		*frac = 0.0f;

	mov	ecx, DWORD PTR _frac$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx], xmm0

; 462  : 		return;

	jmp	$LN1@CL_FindInt
$LN8@CL_FindInt:

; 463  : 	}
; 464  : 
; 465  : 	// time spans the two entries
; 466  : 	*frac = ( t - (*prev)->starttime ) / ((*next)->starttime - (*prev)->starttime );

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [edx]
	subss	xmm1, DWORD PTR [ecx]
	divss	xmm0, xmm1
	mov	edx, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [edx], xmm0

; 467  : 	*frac = bound( 0.0f, *frac, 1.0f );

	mov	eax, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@CL_FindInt
	mov	ecx, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx]
	jbe	SHORT $LN10@CL_FindInt
	mov	edx, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN11@CL_FindInt
$LN10@CL_FindInt:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv133[ebp], xmm0
$LN11@CL_FindInt:
	movss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN13@CL_FindInt
$LN12@CL_FindInt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv134[ebp], xmm0
$LN13@CL_FindInt:
	mov	eax, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR [eax], xmm0
$LN1@CL_FindInt:

; 468  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindInterpolatedAddAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_frame$ = -20						; size = 4
_frm$ = -16						; size = 4
_lost$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_ComputePacketLoss PROC

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 385  : 	int	i, frm;
; 386  : 	frame_t	*frame;
; 387  : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 388  : 	int	lost = 0;

	mov	DWORD PTR _lost$[ebp], 0

; 389  : 
; 390  : 	if( host.realtime < cls.packet_loss_recalc_time )

	movsd	xmm0, QWORD PTR _cls+287328
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN5@CL_Compute

; 391  : 		return;

	jmp	$LN8@CL_Compute
$LN5@CL_Compute:

; 392  : 
; 393  : 	// recalc every second
; 394  : 	cls.packet_loss_recalc_time = host.realtime + 1.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _cls+287328, xmm0

; 395  : 
; 396  : 	// compuate packet loss
; 397  : 	for( i = cls.netchan.incoming_sequence - CL_UPDATE_BACKUP + 1; i <= cls.netchan.incoming_sequence; i++ )

	mov	eax, DWORD PTR _cls+23584
	sub	eax, DWORD PTR _CL_UPDATE_BACKUP
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@CL_Compute
$LN2@CL_Compute:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_Compute:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cls+23584
	jg	SHORT $LN3@CL_Compute

; 398  : 	{
; 399  : 		frm = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _frm$[ebp], eax

; 400  : 		frame = &cl.frames[frm & CL_UPDATE_MASK];

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _frm$[ebp]
	imul	edx, ecx, 17304
	add	edx, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], edx

; 401  : 
; 402  : 		if( frame->receivedtime == -1.0 )

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@CL_Compute

; 403  : 			lost++;

	mov	ecx, DWORD PTR _lost$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lost$[ebp], ecx
$LN6@CL_Compute:

; 404  : 		count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 405  : 	}

	jmp	SHORT $LN2@CL_Compute
$LN3@CL_Compute:

; 406  : 
; 407  : 	if( count <= 0 ) cls.packet_loss = 0.0f;

	cmp	DWORD PTR _count$[ebp], 0
	jg	SHORT $LN7@CL_Compute
	xorps	xmm0, xmm0
	movss	DWORD PTR _cls+287324, xmm0
	jmp	SHORT $LN8@CL_Compute
$LN7@CL_Compute:

; 408  : 	else cls.packet_loss = ( 100.0f * (float)lost ) / (float)count;

	cvtsi2ss xmm0, DWORD PTR _lost$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _cls+287324, xmm0
$LN8@CL_Compute:

; 409  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ComputePacketLoss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv132 = -28						; size = 4
tv131 = -24						; size = 4
tv80 = -20						; size = 4
_forced$ = -16						; size = 4
_max_interp$ = -12					; size = 4
_min_interp$ = -8					; size = 4
_interpolation_msec$ = -4				; size = 4
_cmd$ = 8						; size = 4
_CL_ComputeClientInterpolationAmount PROC

; 333  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 334  : 	int	min_interp = MIN_EX_INTERP;

	mov	DWORD PTR _min_interp$[ebp], 50		; 00000032H

; 335  : 	int	max_interp = MAX_EX_INTERP;

	mov	DWORD PTR _max_interp$[ebp], 100	; 00000064H

; 336  : 	int	interpolation_msec;
; 337  : 	qboolean	forced = false;

	mov	DWORD PTR _forced$[ebp], 0

; 338  : 
; 339  : 	if( cl_updaterate->value < MIN_UPDATERATE )

	mov	eax, DWORD PTR _cl_updaterate
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN2@CL_Compute

; 340  : 	{
; 341  : 		Con_Printf( "cl_updaterate minimum is %f, resetting to default (20)\n", MIN_UPDATERATE );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG144689
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 342  : 		Cvar_Reset( "cl_updaterate" );

	push	OFFSET $SG144690
	call	_Cvar_Reset
	add	esp, 4
$LN2@CL_Compute:

; 343  : 	}
; 344  : 
; 345  : 	if( cl_updaterate->value > MAX_UPDATERATE )

	mov	ecx, DWORD PTR _cl_updaterate
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR __real@42cc0000
	jbe	SHORT $LN3@CL_Compute

; 346  : 	{
; 347  : 		Con_Printf( "cl_updaterate clamped at maximum (%f)\n", MAX_UPDATERATE );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4059800000000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG144692
	call	_Con_Printf

; 348  : 		Cvar_SetValue( "cl_updaterate", MAX_UPDATERATE );

	add	esp, 8
	movss	xmm0, DWORD PTR __real@42cc0000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144693
	call	_Cvar_SetValue
	add	esp, 8
$LN3@CL_Compute:

; 349  : 	}
; 350  : 
; 351  : 	if( cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN4@CL_Compute

; 352  : 		max_interp = 200;

	mov	DWORD PTR _max_interp$[ebp], 200	; 000000c8H
$LN4@CL_Compute:

; 353  : 
; 354  : 	min_interp = 1000.0f / cl_updaterate->value;

	mov	edx, DWORD PTR _cl_updaterate
	movss	xmm0, DWORD PTR __real@447a0000
	divss	xmm0, DWORD PTR [edx+12]
	cvttss2si eax, xmm0
	mov	DWORD PTR _min_interp$[ebp], eax

; 355  : 	min_interp = Q_max( 1, min_interp );

	cmp	DWORD PTR _min_interp$[ebp], 1
	jge	SHORT $LN10@CL_Compute
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN11@CL_Compute
$LN10@CL_Compute:
	mov	ecx, DWORD PTR _min_interp$[ebp]
	mov	DWORD PTR tv80[ebp], ecx
$LN11@CL_Compute:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _min_interp$[ebp], edx

; 356  : 	interpolation_msec = cl_interp->value * 1000.0f;

	mov	eax, DWORD PTR _cl_interp
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _interpolation_msec$[ebp], ecx

; 357  : 
; 358  : 	if(( interpolation_msec + 1 ) < min_interp )

	mov	edx, DWORD PTR _interpolation_msec$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _min_interp$[ebp]
	jge	SHORT $LN5@CL_Compute

; 359  : 	{
; 360  : 		Con_Printf( "ex_interp forced up to %i msec\n", interpolation_msec );

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	push	eax
	push	OFFSET $SG144697
	call	_Con_Printf
	add	esp, 8

; 361  : 		interpolation_msec = min_interp;

	mov	ecx, DWORD PTR _min_interp$[ebp]
	mov	DWORD PTR _interpolation_msec$[ebp], ecx

; 362  : 		forced = true;

	mov	DWORD PTR _forced$[ebp], 1

; 363  : 	}

	jmp	SHORT $LN7@CL_Compute
$LN5@CL_Compute:

; 364  : 	else if(( interpolation_msec - 1 ) > max_interp )

	mov	edx, DWORD PTR _interpolation_msec$[ebp]
	sub	edx, 1
	cmp	edx, DWORD PTR _max_interp$[ebp]
	jle	SHORT $LN7@CL_Compute

; 365  : 	{
; 366  : 		Con_Printf( "ex_interp forced down to %i msec\n", interpolation_msec );

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	push	eax
	push	OFFSET $SG144699
	call	_Con_Printf
	add	esp, 8

; 367  : 		interpolation_msec = max_interp;

	mov	ecx, DWORD PTR _max_interp$[ebp]
	mov	DWORD PTR _interpolation_msec$[ebp], ecx

; 368  : 		forced = true;

	mov	DWORD PTR _forced$[ebp], 1
$LN7@CL_Compute:

; 369  : 	}
; 370  : 
; 371  : 	if( forced ) Cvar_SetValue( "ex_interp", (float)interpolation_msec * 0.001f );

	cmp	DWORD PTR _forced$[ebp], 0
	je	SHORT $LN8@CL_Compute
	cvtsi2ss xmm0, DWORD PTR _interpolation_msec$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144701
	call	_Cvar_SetValue
	add	esp, 8
$LN8@CL_Compute:

; 372  : 	interpolation_msec = bound( min_interp, interpolation_msec, max_interp );	

	mov	edx, DWORD PTR _interpolation_msec$[ebp]
	cmp	edx, DWORD PTR _min_interp$[ebp]
	jl	SHORT $LN14@CL_Compute
	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	cmp	eax, DWORD PTR _max_interp$[ebp]
	jge	SHORT $LN12@CL_Compute
	mov	ecx, DWORD PTR _interpolation_msec$[ebp]
	mov	DWORD PTR tv131[ebp], ecx
	jmp	SHORT $LN13@CL_Compute
$LN12@CL_Compute:
	mov	edx, DWORD PTR _max_interp$[ebp]
	mov	DWORD PTR tv131[ebp], edx
$LN13@CL_Compute:
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN15@CL_Compute
$LN14@CL_Compute:
	mov	ecx, DWORD PTR _min_interp$[ebp]
	mov	DWORD PTR tv132[ebp], ecx
$LN15@CL_Compute:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR _interpolation_msec$[ebp], edx

; 373  : 
; 374  : 	cmd->lerp_msec = CL_DriftInterpolationAmount( interpolation_msec );

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	push	eax
	call	_CL_DriftInterpolationAmount
	add	esp, 4
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	WORD PTR [ecx], ax

; 375  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ComputeClientInterpolationAmount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv84 = -32						; size = 4
tv83 = -28						; size = 4
tv77 = -24						; size = 4
tv74 = -20						; size = 4
_fgoal$ = -16						; size = 4
_maxmove$ = -12						; size = 4
_msec$ = -8						; size = 4
_diff$ = -4						; size = 4
_goal$ = 8						; size = 4
_CL_DriftInterpolationAmount PROC

; 305  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 306  : 	float	fgoal, maxmove, diff;
; 307  : 	int	msec;
; 308  : 
; 309  : 	fgoal = (float)goal / 1000.0f;

	cvtsi2ss xmm0, DWORD PTR _goal$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fgoal$[ebp], xmm0

; 310  : 
; 311  : 	if( fgoal != cl.local.interp_amount )

	movss	xmm0, DWORD PTR _fgoal$[ebp]
	ucomiss	xmm0, DWORD PTR _cl+1568532
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@CL_DriftIn

; 312  : 	{
; 313  : 		maxmove = host.frametime * 0.05;

	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxmove$[ebp], xmm0

; 314  : 		diff = fgoal - cl.local.interp_amount;

	movss	xmm0, DWORD PTR _fgoal$[ebp]
	subss	xmm0, DWORD PTR _cl+1568532
	movss	DWORD PTR _diff$[ebp], xmm0

; 315  : 		diff = bound( -maxmove, diff, maxmove );

	movss	xmm0, DWORD PTR _maxmove$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _diff$[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN6@CL_DriftIn
	movss	xmm0, DWORD PTR _maxmove$[ebp]
	comiss	xmm0, DWORD PTR _diff$[ebp]
	jbe	SHORT $LN4@CL_DriftIn
	movss	xmm0, DWORD PTR _diff$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN5@CL_DriftIn
$LN4@CL_DriftIn:
	movss	xmm0, DWORD PTR _maxmove$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
$LN5@CL_DriftIn:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN7@CL_DriftIn
$LN6@CL_DriftIn:
	movss	xmm0, DWORD PTR _maxmove$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv77[ebp], xmm0
$LN7@CL_DriftIn:
	movss	xmm0, DWORD PTR tv77[ebp]
	movss	DWORD PTR _diff$[ebp], xmm0

; 316  : 		cl.local.interp_amount += diff;

	movss	xmm0, DWORD PTR _cl+1568532
	addss	xmm0, DWORD PTR _diff$[ebp]
	movss	DWORD PTR _cl+1568532, xmm0
$LN2@CL_DriftIn:

; 317  : 	}
; 318  : 
; 319  : 	msec = cl.local.interp_amount * 1000.0f;

	movss	xmm0, DWORD PTR _cl+1568532
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si eax, xmm0
	mov	DWORD PTR _msec$[ebp], eax

; 320  : 	msec = bound( 0, msec, 100 );

	cmp	DWORD PTR _msec$[ebp], 0
	jl	SHORT $LN10@CL_DriftIn
	cmp	DWORD PTR _msec$[ebp], 100		; 00000064H
	jge	SHORT $LN8@CL_DriftIn
	mov	ecx, DWORD PTR _msec$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN9@CL_DriftIn
$LN8@CL_DriftIn:
	mov	DWORD PTR tv83[ebp], 100		; 00000064H
$LN9@CL_DriftIn:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN11@CL_DriftIn
$LN10@CL_DriftIn:
	mov	DWORD PTR tv84[ebp], 0
$LN11@CL_DriftIn:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _msec$[ebp], eax

; 321  : 
; 322  : 	return msec;

	mov	eax, DWORD PTR _msec$[ebp]

; 323  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DriftInterpolationAmount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_f$ = -8						; size = 4
_frac$ = -4						; size = 4
_CL_LerpPoint PROC

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 251  : 	float	f, frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0

; 252  : 
; 253  : 	f = cl_serverframetime();

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	subsd	xmm0, QWORD PTR _cl[edx+32]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 254  : 	
; 255  : 	if( f == 0.0f || cls.timedemo )

	movss	xmm0, DWORD PTR _f$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_LerpPoi
	cmp	DWORD PTR _cls+297588, 0
	je	SHORT $LN2@CL_LerpPoi
$LN3@CL_LerpPoi:

; 256  : 	{
; 257  : 		cl.time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl+1525848, xmm0

; 258  : 		return 1.0f;

	fld1
	jmp	$LN1@CL_LerpPoi
$LN2@CL_LerpPoi:

; 259  : 	}
; 260  : 
; 261  : 	if( f > 0.1f )

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN4@CL_LerpPoi

; 262  : 	{	
; 263  : 		// dropped packet, or start of demo
; 264  : 		cl.mtime[1] = cl.mtime[0] - 0.1f;

	mov	edx, 8
	imul	eax, edx, 0
	movsd	xmm0, QWORD PTR _cl[eax+32]
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	mov	ecx, 8
	shl	ecx, 0
	movsd	QWORD PTR _cl[ecx+32], xmm0

; 265  : 		f = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _f$[ebp], xmm0
$LN4@CL_LerpPoi:

; 266  : 	}
; 267  : #if 1
; 268  : 	frac = (cl.time - cl.mtime[1]) / f;

	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR _cl[edx+32]
	cvtss2sd xmm1, DWORD PTR _f$[ebp]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 269  : 
; 270  : 	if( frac < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN5@CL_LerpPoi

; 271  : 	{
; 272  : 		if( frac < -0.01 )

	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	movsd	xmm1, QWORD PTR __real@bf847ae147ae147b
	comisd	xmm1, xmm0
	jbe	SHORT $LN7@CL_LerpPoi

; 273  : 			cl.time = cl.mtime[1];

	mov	eax, 8
	shl	eax, 0
	movsd	xmm0, QWORD PTR _cl[eax+32]
	movsd	QWORD PTR _cl+1525848, xmm0
$LN7@CL_LerpPoi:

; 274  : 		frac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 275  : 	}

	jmp	SHORT $LN8@CL_LerpPoi
$LN5@CL_LerpPoi:

; 276  : 	else if( frac > 1.0f )

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN8@CL_LerpPoi

; 277  : 	{
; 278  : 		if( frac > 1.01 )

	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff028f5c28f5c29
	jbe	SHORT $LN9@CL_LerpPoi

; 279  : 			cl.time = cl.mtime[0];

	mov	ecx, 8
	imul	edx, ecx, 0
	movsd	xmm0, QWORD PTR _cl[edx+32]
	movsd	QWORD PTR _cl+1525848, xmm0
$LN9@CL_LerpPoi:

; 280  : 		frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN8@CL_LerpPoi:

; 281  : 	}
; 282  : #else
; 283  : 	if( cl_interp->value > 0.001f )
; 284  : 	{
; 285  : 		// manual lerp value (goldsrc mode)
; 286  : 		frac = ( cl.time - cl.mtime[0] ) / cl_interp->value;
; 287  : 	}
; 288  : 	else if( f > 0.001f )
; 289  : 	{
; 290  : 		// automatic lerp (classic mode)
; 291  : 		frac = ( cl.time - cl.mtime[1] ) / f;
; 292  : 	}
; 293  : #endif
; 294  : 	return frac;

	fld	DWORD PTR _frac$[ebp]
$LN1@CL_LerpPoi:

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LerpPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv82 = -8						; size = 8
_CL_CheckClientState PROC

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 188  : 	// first update is the pre-final signon stage
; 189  : 	if(( cls.state == ca_connected || cls.state == ca_validate ) && ( cls.signon == SIGNONS ))

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN3@CL_CheckCl
	cmp	DWORD PTR _cls, 3
	jne	$LN4@CL_CheckCl
$LN3@CL_CheckCl:
	cmp	DWORD PTR _cls+64, 2
	jne	$LN4@CL_CheckCl

; 190  : 	{	
; 191  : 		cls.state = ca_active;

	mov	DWORD PTR _cls, 4

; 192  : 		cls.changelevel = false;		// changelevel is done

	mov	DWORD PTR _cls+8, 0

; 193  : 		cls.changedemo = false;		// changedemo is done

	mov	DWORD PTR _cls+12, 0

; 194  : 		cl.first_frame = true;		// first rendering frame

	mov	DWORD PTR _cl+68, 1

; 195  : 
; 196  : 		SCR_MakeLevelShot();		// make levelshot if needs

	call	_SCR_MakeLevelShot

; 197  : 		Cvar_SetValue( "scr_loading", 0.0f );	// reset progress bar	

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144638
	call	_Cvar_SetValue
	add	esp, 8

; 198  : 		Netchan_ReportFlow( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_ReportFlow
	add	esp, 4

; 199  : 
; 200  : 		Con_DPrintf( "client connected at %.2f sec\n", Sys_DoubleTime() - cls.timestart ); 

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv82[ebp]
	movsd	xmm0, QWORD PTR tv82[ebp]
	subsd	xmm0, QWORD PTR _cls+16
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG144639
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 201  : 		if(( cls.demoplayback || cls.disable_servercount != cl.servercount ) && cl.video_prepped )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN5@CL_CheckCl
	mov	eax, DWORD PTR _cls+28
	cmp	eax, DWORD PTR _cl
	je	SHORT $LN4@CL_CheckCl
$LN5@CL_CheckCl:
	cmp	DWORD PTR _cl+16, 0
	je	SHORT $LN4@CL_CheckCl

; 202  : 			SCR_EndLoadingPlaque(); // get rid of loading plaque

	call	_SCR_EndLoadingPlaque
$LN4@CL_CheckCl:

; 203  : 	}
; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckClientState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearState PROC

; 1288 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1289 : 	int	i;
; 1290 : 
; 1291 : 	CL_ClearResourceLists();

	call	_CL_ClearResourceLists

; 1292 : 
; 1293 : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearSt
$LN2@CL_ClearSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearSt:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@CL_ClearSt

; 1294 : 		COM_ClearCustomizationList( &cl.players[i].customdata, false );

	push	0
	imul	ecx, DWORD PTR _i$[ebp], 584
	add	ecx, OFFSET _cl+1543552
	push	ecx
	call	_COM_ClearCustomizationList
	add	esp, 8
	jmp	SHORT $LN2@CL_ClearSt
$LN3@CL_ClearSt:

; 1295 : 
; 1296 : 	S_StopAllSounds ( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 1297 : 	CL_ClearEffects ();

	call	_CL_ClearEffects

; 1298 : 	CL_FreeEdicts ();

	call	_CL_FreeEdicts

; 1299 : 
; 1300 : 	CL_ClearPhysEnts ();

	call	_CL_ClearPhysEnts

; 1301 : 	NetAPI_CancelAllRequests();

	call	_NetAPI_CancelAllRequests

; 1302 : 
; 1303 : 	// wipe the entire cl structure
; 1304 : 	memset( &cl, 0, sizeof( cl ));

	push	2686584					; 0028fe78H
	push	0
	push	OFFSET _cl
	call	_memset
	add	esp, 12					; 0000000cH

; 1305 : 	MSG_Clear( &cls.netchan.message );

	push	OFFSET _cls+23620
	call	_MSG_Clear
	add	esp, 4

; 1306 : 	memset( &clgame.fade, 0, sizeof( clgame.fade ));

	push	24					; 00000018H
	push	0
	push	OFFSET _clgame+122740
	call	_memset
	add	esp, 12					; 0000000cH

; 1307 : 	memset( &clgame.shake, 0, sizeof( clgame.shake ));

	push	52					; 00000034H
	push	0
	push	OFFSET _clgame+122764
	call	_memset
	add	esp, 12					; 0000000cH

; 1308 : 	Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG145066
	push	OFFSET $SG145067
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1309 : 	cl.maxclients = 1; // allow to drawing player in menu

	mov	DWORD PTR _cl+1568832, 1

; 1310 : 	cl.mtime[0] = cl.mtime[1] = 1.0f; // because level starts from 1.0f second

	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _cl[edx+32], xmm0
	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _cl[ecx+32], xmm0

; 1311 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1312 : 
; 1313 : 	cl.resourcesneeded.pNext = cl.resourcesneeded.pPrev = &cl.resourcesneeded;

	mov	DWORD PTR _cl+1985128, OFFSET _cl+1984996
	mov	edx, DWORD PTR _cl+1985128
	mov	DWORD PTR _cl+1985124, edx

; 1314 : 	cl.resourcesonhand.pNext = cl.resourcesonhand.pPrev = &cl.resourcesonhand;

	mov	DWORD PTR _cl+1984992, OFFSET _cl+1984860
	mov	eax, DWORD PTR _cl+1984992
	mov	DWORD PTR _cl+1984988, eax

; 1315 : 
; 1316 : 	CL_CreateResourceList();

	call	_CL_CreateResourceList

; 1317 : 	CL_ClearSpriteTextures();	// now all hud sprites are invalid

	call	_CL_ClearSpriteTextures

; 1318 : 
; 1319 : 	cl.local.interp_amount = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _cl+1568532, xmm0

; 1320 : 	cl.local.scr_fov = 90.0f;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _cl+1568592, xmm0

; 1321 : 
; 1322 : 	Cvar_SetValue( "scr_download", -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145068
	call	_Cvar_SetValue

; 1323 : 	Cvar_SetValue( "scr_loading", 0.0f );

	add	esp, 4
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG145069
	call	_Cvar_SetValue
	add	esp, 8

; 1324 : 	host.allow_console = host.allow_console_init;

	mov	ecx, DWORD PTR _host+34340
	mov	DWORD PTR _host+34336, ecx

; 1325 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_CL_SignonReply PROC

; 222  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 223  : 	// g-cont. my favorite message :-)
; 224  : 	Con_Reportf( "CL_SignonReply: %i\n", cls.signon );

	mov	eax, DWORD PTR _cls+64
	push	eax
	push	OFFSET $SG144650
	call	_Con_Reportf
	add	esp, 8

; 225  : 
; 226  : 	switch( cls.signon )

	mov	ecx, DWORD PTR _cls+64
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@CL_SignonR
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN6@CL_SignonR
	jmp	SHORT $LN2@CL_SignonR
$LN4@CL_SignonR:

; 227  : 	{
; 228  : 	case 1:
; 229  : 		CL_ServerCommand( true, "begin" );

	push	OFFSET $SG144652
	push	1
	call	_CL_ServerCommand
	add	esp, 8

; 230  : 		if( host_developer.value >= DEV_EXTENDED )

	movss	xmm0, DWORD PTR _host_developer+12
	comiss	xmm0, DWORD PTR __real@40000000
	jb	SHORT $LN5@CL_SignonR

; 231  : 			Mem_PrintStats();

	call	_Mem_PrintStats
$LN5@CL_SignonR:

; 232  : 		break;

	jmp	SHORT $LN2@CL_SignonR
$LN6@CL_SignonR:

; 233  : 	case 2:
; 234  : 		if( cl.proxy_redirect && !cls.spectator )

	cmp	DWORD PTR _cl+72, 0
	je	SHORT $LN7@CL_SignonR
	cmp	DWORD PTR _cls+152, 0
	jne	SHORT $LN7@CL_SignonR

; 235  : 			CL_Disconnect();

	call	_CL_Disconnect
$LN7@CL_SignonR:

; 236  : 		cl.proxy_redirect = false;

	mov	DWORD PTR _cl+72, 0
$LN2@CL_SignonR:

; 237  : 		break;
; 238  : 	}
; 239  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SignonReply ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_IsDevOverviewMode PROC

; 168  : {

	push	ebp
	mov	ebp, esp

; 169  : 	if( dev_overview.value > 0.0f )

	movss	xmm0, DWORD PTR _dev_overview+12
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@CL_IsDevOv

; 170  : 	{
; 171  : 		if( host_developer.value || cls.spectator )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@CL_IsDevOv
	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN3@CL_IsDevOv
$LN4@CL_IsDevOv:

; 172  : 			return (int)dev_overview.value;

	cvttss2si eax, DWORD PTR _dev_overview+12
	jmp	SHORT $LN1@CL_IsDevOv
$LN3@CL_IsDevOv:

; 173  : 	}
; 174  : 
; 175  : 	return 0;

	xor	eax, eax
$LN1@CL_IsDevOv:

; 176  : }

	pop	ebp
	ret	0
_CL_IsDevOverviewMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_UpdateFrameLerp PROC

; 418  : {

	push	ebp
	mov	ebp, esp

; 419  : 	if( cls.state != ca_active || !cl.validsequence )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN3@CL_UpdateF
	cmp	DWORD PTR _cl+4, 0
	jne	SHORT $LN2@CL_UpdateF
$LN3@CL_UpdateF:

; 420  : 		return;

	jmp	SHORT $LN1@CL_UpdateF
$LN2@CL_UpdateF:

; 421  : 
; 422  : 	// compute last interpolation amount
; 423  : 	cl.lerpFrac = CL_LerpPoint();

	call	_CL_LerpPoint
	fstp	DWORD PTR _cl+48

; 424  : 
; 425  : 	cl.commands[(cls.netchan.outgoing_sequence - 1) & CL_UPDATE_MASK].frame_lerp = cl.lerpFrac;

	mov	eax, DWORD PTR _cls+23600
	sub	eax, 1
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	imul	edx, eax, 88
	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR _cl[edx+1107560], xmm0
$LN1@CL_UpdateF:

; 426  : }

	pop	ebp
	ret	0
_CL_UpdateFrameLerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv165 = -32						; size = 4
_aspect$ = -28						; size = 4
tv84 = -24						; size = 4
_screenAspect$ = -20					; size = 4
_mapAspect$ = -16					; size = 4
tv73 = -12						; size = 4
tv70 = -8						; size = 4
_ov$ = -4						; size = 4
_CL_SetupOverviewParams PROC

; 1724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1725 : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+125416

; 1726 : 	float		mapAspect, screenAspect, aspect;
; 1727 : 
; 1728 : 	ov->rotated = ( world.size[1] <= world.size[0] ) ? true : false;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _world[edx+2624]
	comiss	xmm0, DWORD PTR _world[eax+2624]
	jb	SHORT $LN4@CL_SetupOv
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@CL_SetupOv
$LN4@CL_SetupOv:
	mov	DWORD PTR tv70[ebp], 0
$LN5@CL_SetupOv:
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1729 : 
; 1730 : 	// calculate nearest aspect
; 1731 : 	mapAspect = world.size[!ov->rotated] / world.size[ov->rotated];

	mov	edx, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN6@CL_SetupOv
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN7@CL_SetupOv
$LN6@CL_SetupOv:
	mov	DWORD PTR tv73[ebp], 0
$LN7@CL_SetupOv:
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR tv73[ebp]
	movss	xmm0, DWORD PTR _world[edx*4+2624]
	divss	xmm0, DWORD PTR _world[ecx*4+2624]
	movss	DWORD PTR _mapAspect$[ebp], xmm0

; 1732 : 	screenAspect = (float)glState.width / (float)glState.height;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _glState+4
	divss	xmm0, xmm1
	movss	DWORD PTR _screenAspect$[ebp], xmm0

; 1733 : 	aspect = Q_max( mapAspect, screenAspect );

	movss	xmm0, DWORD PTR _mapAspect$[ebp]
	comiss	xmm0, DWORD PTR _screenAspect$[ebp]
	jbe	SHORT $LN8@CL_SetupOv
	movss	xmm0, DWORD PTR _mapAspect$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN9@CL_SetupOv
$LN8@CL_SetupOv:
	movss	xmm0, DWORD PTR _screenAspect$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
$LN9@CL_SetupOv:
	movss	xmm0, DWORD PTR tv84[ebp]
	movss	DWORD PTR _aspect$[ebp], xmm0

; 1734 : 
; 1735 : 	ov->zNear = world.maxs[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR _world[eax+2612]
	mov	DWORD PTR [ecx+36], edx

; 1736 : 	ov->zFar = world.mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR _world[eax+2600]
	mov	DWORD PTR [ecx+32], edx

; 1737 : 	ov->flZoom = ( 8192.0f / world.size[ov->rotated] ) / aspect;

	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR _world[ecx*4+2624]
	divss	xmm0, DWORD PTR _aspect$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+40], xmm0

; 1738 : 
; 1739 : 	VectorAverage( world.mins, world.maxs, ov->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _world[ecx+2600]
	addss	xmm0, DWORD PTR _world[eax+2612]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _world[ecx+2600]
	addss	xmm0, DWORD PTR _world[edx+2612]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _world[edx+2600]
	addss	xmm0, DWORD PTR _world[eax+2612]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv165[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1740 : 
; 1741 : 	memset( &cls.spectator_state, 0, sizeof( cls.spectator_state ));

	push	6448					; 00001930H
	push	0
	push	OFFSET _cls+156
	call	_memset
	add	esp, 12					; 0000000cH

; 1742 : 
; 1743 : 	if( cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN2@CL_SetupOv

; 1744 : 	{
; 1745 : 		cls.spectator_state.playerstate.friction = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cls+312, xmm0

; 1746 : 		cls.spectator_state.playerstate.gravity = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cls+316, xmm0

; 1747 : 		cls.spectator_state.playerstate.number = cl.playernum + 1;

	mov	eax, DWORD PTR _cl+1568828
	add	eax, 1
	mov	DWORD PTR _cls+160, eax

; 1748 : 		cls.spectator_state.playerstate.usehull = 1;

	mov	DWORD PTR _cls+356, 1

; 1749 : 		cls.spectator_state.playerstate.movetype = MOVETYPE_NOCLIP;

	mov	DWORD PTR _cls+244, 8

; 1750 : 		cls.spectator_state.client.maxspeed = clgame.movevars.spectatormaxspeed;

	movss	xmm0, DWORD PTR _clgame+1040
	movss	DWORD PTR _cls+588, xmm0
$LN2@CL_SetupOv:

; 1751 : 	}
; 1752 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetupOverviewParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv297 = -36						; size = 4
tv296 = -32						; size = 4
tv293 = -28						; size = 4
tv292 = -24						; size = 4
tv270 = -20						; size = 4
tv221 = -16						; size = 4
tv172 = -12						; size = 4
tv146 = -8						; size = 4
_pRes$ = -4						; size = 4
_CL_PrecacheResources PROC

; 2389 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2390 : 	resource_t	*pRes;
; 2391 : 
; 2392 : 	// NOTE: world need to be loaded as first model
; 2393 : 	for( pRes = cl.resourcesonhand.pNext; pRes && pRes != &cl.resourcesonhand; pRes = pRes->pNext )

	mov	eax, DWORD PTR _cl+1984988
	mov	DWORD PTR _pRes$[ebp], eax
	jmp	SHORT $LN4@CL_Precach
$LN2@CL_Precach:
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _pRes$[ebp], edx
$LN4@CL_Precach:
	cmp	DWORD PTR _pRes$[ebp], 0
	je	SHORT $LN3@CL_Precach
	cmp	DWORD PTR _pRes$[ebp], OFFSET _cl+1984860
	je	SHORT $LN3@CL_Precach

; 2394 : 	{
; 2395 : 		if( FBitSet( pRes->ucFlags, RES_PRECACHED ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 16					; 00000010H
	je	SHORT $LN13@CL_Precach

; 2396 : 			continue;

	jmp	SHORT $LN2@CL_Precach
$LN13@CL_Precach:

; 2397 : 
; 2398 : 		if( pRes->type != t_model || pRes->nIndex != WORLD_INDEX )

	mov	edx, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [edx+64], 2
	jne	SHORT $LN15@CL_Precach
	mov	eax, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [eax+68], 1
	je	SHORT $LN14@CL_Precach
$LN15@CL_Precach:

; 2399 : 			continue;

	jmp	SHORT $LN2@CL_Precach
$LN14@CL_Precach:

; 2400 : 
; 2401 : 		cl.models[pRes->nIndex] = Mod_LoadWorld( pRes->szFileName, true );

	push	1
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	_Mod_LoadWorld
	add	esp, 8
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR _cl[ecx*4+1935688], eax

; 2402 : 		SetBits( pRes->ucFlags, RES_PRECACHED );

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [ecx+76], al

; 2403 : 		cl.nummodels = 1;

	mov	DWORD PTR _cl+1939788, 1

; 2404 : 		break;

	jmp	SHORT $LN3@CL_Precach

; 2405 : 	}

	jmp	SHORT $LN2@CL_Precach
$LN3@CL_Precach:

; 2406 : 
; 2407 : 	// then we set up all the world submodels
; 2408 : 	for( pRes = cl.resourcesonhand.pNext; pRes && pRes != &cl.resourcesonhand; pRes = pRes->pNext )

	mov	edx, DWORD PTR _cl+1984988
	mov	DWORD PTR _pRes$[ebp], edx
	jmp	SHORT $LN7@CL_Precach
$LN5@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pRes$[ebp], ecx
$LN7@CL_Precach:
	cmp	DWORD PTR _pRes$[ebp], 0
	je	$LN6@CL_Precach
	cmp	DWORD PTR _pRes$[ebp], OFFSET _cl+1984860
	je	$LN6@CL_Precach

; 2409 : 	{
; 2410 : 		if( FBitSet( pRes->ucFlags, RES_PRECACHED ))

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 16					; 00000010H
	je	SHORT $LN16@CL_Precach

; 2411 : 			continue;

	jmp	SHORT $LN5@CL_Precach
$LN16@CL_Precach:

; 2412 : 
; 2413 : 		if( pRes->type == t_model && pRes->szFileName[0] == '*' )

	mov	ecx, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [ecx+64], 2
	jne	$LN17@CL_Precach
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pRes$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 42					; 0000002aH
	jne	$LN17@CL_Precach

; 2414 : 		{
; 2415 : 			cl.models[pRes->nIndex] = Mod_ForName( pRes->szFileName, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _cl[edx*4+1935688], eax

; 2416 : 			cl.nummodels = Q_max( cl.nummodels, pRes->nIndex + 1 );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	cmp	DWORD PTR _cl+1939788, ecx
	jle	SHORT $LN43@CL_Precach
	mov	edx, DWORD PTR _cl+1939788
	mov	DWORD PTR tv146[ebp], edx
	jmp	SHORT $LN44@CL_Precach
$LN43@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	DWORD PTR tv146[ebp], ecx
$LN44@CL_Precach:
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR _cl+1939788, edx

; 2417 : 			SetBits( pRes->ucFlags, RES_PRECACHED );

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [edx+76], cl

; 2418 : 
; 2419 : 			if( cl.models[pRes->nIndex] == NULL )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	cmp	DWORD PTR _cl[ecx*4+1935688], 0
	jne	SHORT $LN17@CL_Precach

; 2420 : 			{
; 2421 : 				Con_Printf( S_ERROR "submodel %s not found\n", pRes->szFileName );

	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	push	OFFSET $SG145502
	call	_Con_Printf
	add	esp, 8

; 2422 : 
; 2423 : 				if( FBitSet( pRes->ucFlags, RES_FATALIFMISSING ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 1
	je	SHORT $LN17@CL_Precach

; 2424 : 				{
; 2425 : 					CL_Disconnect_f();

	call	_CL_Disconnect_f

; 2426 : 					return false;

	xor	eax, eax
	jmp	$LN1@CL_Precach
$LN17@CL_Precach:

; 2427 : 				}
; 2428 : 			}
; 2429 : 		}
; 2430 : 	}

	jmp	$LN5@CL_Precach
$LN6@CL_Precach:

; 2431 : 
; 2432 : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN20@CL_Precach

; 2433 : 		S_BeginRegistration();

	call	_S_BeginRegistration
$LN20@CL_Precach:

; 2434 : 
; 2435 : 	// precache all the remaining resources where order is doesn't matter
; 2436 : 	for( pRes = cl.resourcesonhand.pNext; pRes && pRes != &cl.resourcesonhand; pRes = pRes->pNext )

	mov	edx, DWORD PTR _cl+1984988
	mov	DWORD PTR _pRes$[ebp], edx
	jmp	SHORT $LN10@CL_Precach
$LN8@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pRes$[ebp], ecx
$LN10@CL_Precach:
	cmp	DWORD PTR _pRes$[ebp], 0
	je	$LN9@CL_Precach
	cmp	DWORD PTR _pRes$[ebp], OFFSET _cl+1984860
	je	$LN9@CL_Precach

; 2437 : 	{
; 2438 : 		if( FBitSet( pRes->ucFlags, RES_PRECACHED ))

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 16					; 00000010H
	je	SHORT $LN21@CL_Precach

; 2439 : 			continue;

	jmp	SHORT $LN8@CL_Precach
$LN21@CL_Precach:

; 2440 : 
; 2441 : 		switch( pRes->type )

	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR tv172[ebp], edx
	cmp	DWORD PTR tv172[ebp], 5
	ja	$LN11@CL_Precach
	mov	eax, DWORD PTR tv172[ebp]
	jmp	DWORD PTR $LN57@CL_Precach[eax*4]
$LN22@CL_Precach:

; 2442 : 		{
; 2443 : 		case t_sound:
; 2444 : 			if( pRes->nIndex != -1 )

	mov	ecx, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [ecx+68], -1
	je	$LN23@CL_Precach

; 2445 : 			{
; 2446 : 				if( FBitSet( pRes->ucFlags, RES_WASMISSING ))

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 2
	je	SHORT $LN25@CL_Precach

; 2447 : 				{
; 2448 : 					Con_Printf( S_ERROR "%s%s couldn't load\n", DEFAULT_SOUNDPATH, pRes->szFileName );

	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	push	OFFSET $SG145511
	push	OFFSET $SG145512
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2449 : 					cl.sound_precache[pRes->nIndex][0] = 0;

	mov	edx, DWORD PTR _pRes$[ebp]
	mov	eax, DWORD PTR [edx+68]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _cl[eax+edx+1590600], 0

; 2450 : 					cl.sound_index[pRes->nIndex] = 0;

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	xor	edx, edx
	mov	WORD PTR _cl[ecx*2+2681456], dx

; 2451 : 				}

	jmp	SHORT $LN26@CL_Precach
$LN25@CL_Precach:

; 2452 : 				else
; 2453 : 				{
; 2454 : 					Q_strncpy( cl.sound_precache[pRes->nIndex], pRes->szFileName, sizeof( cl.sound_precache[0] )); 

	push	64					; 00000040H
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	shl	edx, 6
	add	edx, OFFSET _cl+1590600
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2455 : 					cl.sound_index[pRes->nIndex] = S_RegisterSound( pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	WORD PTR _cl[edx*2+2681456], ax

; 2456 : 
; 2457 : 					if( !cl.sound_index[pRes->nIndex] )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	movsx	edx, WORD PTR _cl[ecx*2+2681456]
	test	edx, edx
	jne	SHORT $LN26@CL_Precach

; 2458 : 					{
; 2459 : 						if( FBitSet( pRes->ucFlags, RES_FATALIFMISSING ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 1
	je	SHORT $LN26@CL_Precach

; 2460 : 						{
; 2461 : 							S_EndRegistration();

	call	_S_EndRegistration

; 2462 : 							CL_Disconnect_f();

	call	_CL_Disconnect_f

; 2463 : 							return false;

	xor	eax, eax
	jmp	$LN1@CL_Precach
$LN26@CL_Precach:

; 2464 : 						}
; 2465 : 					}
; 2466 : 				}
; 2467 : 			}

	jmp	SHORT $LN24@CL_Precach
$LN23@CL_Precach:

; 2468 : 			else
; 2469 : 			{
; 2470 : 				// client sounds
; 2471 : 				S_RegisterSound( pRes->szFileName );

	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	call	_S_RegisterSound
	add	esp, 4
$LN24@CL_Precach:

; 2472 : 			}
; 2473 : 			break;

	jmp	$LN11@CL_Precach

; 2474 : 		case t_skin:
; 2475 : 			break;

	jmp	$LN11@CL_Precach
$LN30@CL_Precach:

; 2476 : 		case t_model:
; 2477 : 			cl.nummodels = Q_max( cl.nummodels, pRes->nIndex + 1 );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	cmp	DWORD PTR _cl+1939788, ecx
	jle	SHORT $LN45@CL_Precach
	mov	edx, DWORD PTR _cl+1939788
	mov	DWORD PTR tv221[ebp], edx
	jmp	SHORT $LN46@CL_Precach
$LN45@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	DWORD PTR tv221[ebp], ecx
$LN46@CL_Precach:
	mov	edx, DWORD PTR tv221[ebp]
	mov	DWORD PTR _cl+1939788, edx

; 2478 : 			if( pRes->szFileName[0] != '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pRes$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN31@CL_Precach

; 2479 : 			{
; 2480 : 				if( pRes->nIndex != -1 )

	mov	ecx, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [ecx+68], -1
	je	SHORT $LN32@CL_Precach

; 2481 : 				{
; 2482 : 					cl.models[pRes->nIndex] = Mod_ForName( pRes->szFileName, false, true );

	push	1
	push	0
	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _cl[edx*4+1935688], eax

; 2483 : 
; 2484 : 					if( cl.models[pRes->nIndex] == NULL )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	cmp	DWORD PTR _cl[ecx*4+1935688], 0
	jne	SHORT $LN34@CL_Precach

; 2485 : 					{
; 2486 : 						if( FBitSet( pRes->ucFlags, RES_FATALIFMISSING ))

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 1
	je	SHORT $LN34@CL_Precach

; 2487 : 						{
; 2488 : 							S_EndRegistration();

	call	_S_EndRegistration

; 2489 : 							CL_Disconnect_f();

	call	_CL_Disconnect_f

; 2490 : 							return false;

	xor	eax, eax
	jmp	$LN1@CL_Precach
$LN34@CL_Precach:

; 2491 : 						}
; 2492 : 					}
; 2493 : 				}

	jmp	SHORT $LN31@CL_Precach
$LN32@CL_Precach:

; 2494 : 				else
; 2495 : 				{
; 2496 : 					CL_LoadClientSprite( pRes->szFileName );

	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
$LN31@CL_Precach:

; 2497 : 				}
; 2498 : 			}
; 2499 : 			break;

	jmp	$LN11@CL_Precach
$LN36@CL_Precach:

; 2500 : 		case t_decal:
; 2501 : 			if( !FBitSet( pRes->ucFlags, RES_CUSTOM ))

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	and	eax, 4
	jne	SHORT $LN37@CL_Precach

; 2502 : 				Q_strncpy( host.draw_decals[pRes->nIndex], pRes->szFileName, sizeof( host.draw_decals[0] ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	eax, DWORD PTR [edx+68]
	shl	eax, 6
	add	eax, OFFSET _host+1468
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN37@CL_Precach:

; 2503 : 			break;

	jmp	$LN11@CL_Precach
$LN38@CL_Precach:

; 2504 : 		case t_generic:
; 2505 : 			Q_strncpy( cl.files_precache[pRes->nIndex], pRes->szFileName, sizeof( cl.files_precache[0] ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	eax, DWORD PTR [edx+68]
	shl	eax, 6
	add	eax, OFFSET _cl+1787208
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2506 : 			cl.numfiles = Q_max( cl.numfiles, pRes->nIndex + 1 );

	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	add	edx, 1
	cmp	DWORD PTR _cl+1939792, edx
	jle	SHORT $LN47@CL_Precach
	mov	eax, DWORD PTR _cl+1939792
	mov	DWORD PTR tv270[ebp], eax
	jmp	SHORT $LN48@CL_Precach
$LN47@CL_Precach:
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	add	edx, 1
	mov	DWORD PTR tv270[ebp], edx
$LN48@CL_Precach:
	mov	eax, DWORD PTR tv270[ebp]
	mov	DWORD PTR _cl+1939792, eax

; 2507 : 			break;

	jmp	SHORT $LN11@CL_Precach
$LN39@CL_Precach:

; 2508 : 		case t_eventscript:
; 2509 : 			Q_strncpy( cl.event_precache[pRes->nIndex], pRes->szFileName, sizeof( cl.event_precache[0] ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	eax, DWORD PTR [edx+68]
	shl	eax, 6
	add	eax, OFFSET _cl+1721672
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2510 : 			CL_SetEventIndex( cl.event_precache[pRes->nIndex], pRes->nIndex );

	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	shl	ecx, 6
	add	ecx, OFFSET _cl+1721672
	push	ecx
	call	_CL_SetEventIndex
	add	esp, 8
$LN11@CL_Precach:

; 2511 : 			break;
; 2512 : 		default:
; 2513 : 			break;
; 2514 : 		}
; 2515 : 
; 2516 : 		SetBits( pRes->ucFlags, RES_PRECACHED );

	mov	edx, DWORD PTR _pRes$[ebp]
	movzx	eax, BYTE PTR [edx+76]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [ecx+76], al

; 2517 : 	}

	jmp	$LN8@CL_Precach
$LN9@CL_Precach:

; 2518 : 
; 2519 : 	// make sure modelcount is in-range
; 2520 : 	cl.nummodels = bound( 0, cl.nummodels, MAX_MODELS );

	cmp	DWORD PTR _cl+1939788, 0
	jl	SHORT $LN51@CL_Precach
	cmp	DWORD PTR _cl+1939788, 1024		; 00000400H
	jge	SHORT $LN49@CL_Precach
	mov	edx, DWORD PTR _cl+1939788
	mov	DWORD PTR tv292[ebp], edx
	jmp	SHORT $LN50@CL_Precach
$LN49@CL_Precach:
	mov	DWORD PTR tv292[ebp], 1024		; 00000400H
$LN50@CL_Precach:
	mov	eax, DWORD PTR tv292[ebp]
	mov	DWORD PTR tv293[ebp], eax
	jmp	SHORT $LN52@CL_Precach
$LN51@CL_Precach:
	mov	DWORD PTR tv293[ebp], 0
$LN52@CL_Precach:
	mov	ecx, DWORD PTR tv293[ebp]
	mov	DWORD PTR _cl+1939788, ecx

; 2521 : 	cl.numfiles = bound( 0, cl.numfiles, MAX_CUSTOM );

	cmp	DWORD PTR _cl+1939792, 0
	jl	SHORT $LN55@CL_Precach
	cmp	DWORD PTR _cl+1939792, 1024		; 00000400H
	jge	SHORT $LN53@CL_Precach
	mov	edx, DWORD PTR _cl+1939792
	mov	DWORD PTR tv296[ebp], edx
	jmp	SHORT $LN54@CL_Precach
$LN53@CL_Precach:
	mov	DWORD PTR tv296[ebp], 1024		; 00000400H
$LN54@CL_Precach:
	mov	eax, DWORD PTR tv296[ebp]
	mov	DWORD PTR tv297[ebp], eax
	jmp	SHORT $LN56@CL_Precach
$LN55@CL_Precach:
	mov	DWORD PTR tv297[ebp], 0
$LN56@CL_Precach:
	mov	ecx, DWORD PTR tv297[ebp]
	mov	DWORD PTR _cl+1939792, ecx

; 2522 : 
; 2523 : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN41@CL_Precach

; 2524 : 		S_EndRegistration();

	call	_S_EndRegistration
$LN41@CL_Precach:

; 2525 : 
; 2526 : 	return true;

	mov	eax, 1
$LN1@CL_Precach:

; 2527 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@CL_Precach:
	DD	$LN22@CL_Precach
	DD	$LN11@CL_Precach
	DD	$LN30@CL_Precach
	DD	$LN36@CL_Precach
	DD	$LN38@CL_Precach
	DD	$LN39@CL_Precach
_CL_PrecacheResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_unused$ = 8						; size = 4
_CL_GetFragmentSize PROC

; 207  : {

	push	ebp
	mov	ebp, esp

; 208  : 	if( Netchan_IsLocal( &cls.netchan ))

	push	OFFSET _cls+23520
	call	_Netchan_IsLocal
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_GetFrag

; 209  : 		return FRAGMENT_LOCAL_SIZE;

	mov	eax, 64000				; 0000fa00H
	jmp	SHORT $LN1@CL_GetFrag
$LN2@CL_GetFrag:

; 210  : 
; 211  : 	return FRAGMENT_MIN_SIZE;

	mov	eax, 1200				; 000004b0H
$LN1@CL_GetFrag:

; 212  : }

	pop	ebp
	ret	0
_CL_GetFragmentSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_t$ = -72						; size = 4
_f$ = -68						; size = 4
tv79 = -64						; size = 4
tv71 = -60						; size = 4
_nullcmd$ = -56						; size = 52
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_CL_WriteUsercmd PROC

; 680  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 681  : 	usercmd_t	nullcmd;
; 682  : 	usercmd_t	*f, *t;
; 683  : 
; 684  : 	Assert( from == -1 || ( from >= 0 && from < MULTIPLAYER_BACKUP ));

	cmp	DWORD PTR _from$[ebp], -1
	je	SHORT $LN6@CL_WriteUs
	cmp	DWORD PTR _from$[ebp], 0
	jl	SHORT $LN5@CL_WriteUs
	cmp	DWORD PTR _from$[ebp], 64		; 00000040H
	jl	SHORT $LN6@CL_WriteUs
$LN5@CL_WriteUs:
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN7@CL_WriteUs
$LN6@CL_WriteUs:
	mov	DWORD PTR tv71[ebp], 1
$LN7@CL_WriteUs:
	push	0
	push	684					; 000002acH
	push	OFFSET $SG144842
	push	OFFSET $SG144843
	mov	eax, DWORD PTR tv71[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 685  : 	Assert( to >= 0 && to < MULTIPLAYER_BACKUP );

	cmp	DWORD PTR _to$[ebp], 0
	jl	SHORT $LN8@CL_WriteUs
	cmp	DWORD PTR _to$[ebp], 64			; 00000040H
	jge	SHORT $LN8@CL_WriteUs
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN9@CL_WriteUs
$LN8@CL_WriteUs:
	mov	DWORD PTR tv79[ebp], 0
$LN9@CL_WriteUs:
	push	0
	push	685					; 000002adH
	push	OFFSET $SG144844
	push	OFFSET $SG144845
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 686  : 
; 687  : 	if( from == -1 )

	cmp	DWORD PTR _from$[ebp], -1
	jne	SHORT $LN2@CL_WriteUs

; 688  : 	{
; 689  : 		memset( &nullcmd, 0, sizeof( nullcmd ));

	push	52					; 00000034H
	push	0
	lea	edx, DWORD PTR _nullcmd$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 690  : 		f = &nullcmd;

	lea	eax, DWORD PTR _nullcmd$[ebp]
	mov	DWORD PTR _f$[ebp], eax

; 691  : 	}

	jmp	SHORT $LN3@CL_WriteUs
$LN2@CL_WriteUs:

; 692  : 	else
; 693  : 	{
; 694  : 		f = &cl.commands[from].cmd;

	imul	ecx, DWORD PTR _from$[ebp], 88
	add	ecx, OFFSET _cl+1107564
	mov	DWORD PTR _f$[ebp], ecx
$LN3@CL_WriteUs:

; 695  : 	}
; 696  : 
; 697  : 	t = &cl.commands[to].cmd;

	imul	edx, DWORD PTR _to$[ebp], 88
	add	edx, OFFSET _cl+1107564
	mov	DWORD PTR _t$[ebp], edx

; 698  : 
; 699  : 	// write it into the buffer
; 700  : 	MSG_WriteDeltaUsercmd( msg, f, t );

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteDeltaUsercmd
	add	esp, 12					; 0000000cH

; 701  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteUsercmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_msg$1 = -131124					; size = 20
_sound_len$ = -131104					; size = 4
_pfilename$ = -131100					; size = 4
_p$ = -131096						; size = 4
_msg_buf$2 = -131092					; size = 131072
_rgucMD5_hash$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_successfully_received$ = 8				; size = 4
_filename$ = 12						; size = 4
_CL_ProcessFile PROC

; 2189 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131124				; 00020034H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2190 : 	int		sound_len = Q_strlen( DEFAULT_SOUNDPATH );

	push	OFFSET $SG145408
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _sound_len$[ebp], eax

; 2191 : 	byte		rgucMD5_hash[16];
; 2192 : 	const char	*pfilename;
; 2193 : 	resource_t	*p;
; 2194 : 
; 2195 : 	if( COM_CheckString( filename ) && successfully_received )

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@CL_Process
	cmp	DWORD PTR _successfully_received$[ebp], 0
	je	SHORT $LN8@CL_Process

; 2196 : 	{
; 2197 : 		if( filename[0] != '!' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN10@CL_Process

; 2198 : 			Con_Printf( "processing %s\n", filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG145412
	call	_Con_Printf
	add	esp, 8
$LN10@CL_Process:

; 2199 : 	}

	jmp	SHORT $LN9@CL_Process
$LN8@CL_Process:

; 2200 : 	else if( !successfully_received )

	cmp	DWORD PTR _successfully_received$[ebp], 0
	jne	SHORT $LN9@CL_Process

; 2201 : 	{
; 2202 : 		Con_Printf( S_ERROR "server failed to transmit file '%s'\n", CL_CleanFileName( filename ));

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_CL_CleanFileName
	add	esp, 4
	push	eax
	push	OFFSET $SG145414
	call	_Con_Printf
	add	esp, 8
$LN9@CL_Process:

; 2203 : 	}
; 2204 : 
; 2205 : 	pfilename = filename;

	mov	ecx, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _pfilename$[ebp], ecx

; 2206 : 
; 2207 : 	if( !Q_strnicmp( filename, DEFAULT_SOUNDPATH, sound_len ))

	mov	edx, DWORD PTR _sound_len$[ebp]
	push	edx
	push	OFFSET $SG145416
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@CL_Process

; 2208 : 		pfilename += sound_len;

	mov	ecx, DWORD PTR _pfilename$[ebp]
	add	ecx, DWORD PTR _sound_len$[ebp]
	mov	DWORD PTR _pfilename$[ebp], ecx
$LN12@CL_Process:

; 2209 : 
; 2210 : 	for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	edx, DWORD PTR _cl+1985124
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN4@CL_Process
$LN2@CL_Process:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@CL_Process:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	$LN3@CL_Process

; 2211 : 	{
; 2212 : 		if( !Q_strnicmp( filename, "!MD5", 4 ))

	push	4
	push	OFFSET $SG145419
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@CL_Process

; 2213 : 		{
; 2214 : 			COM_HexConvert( filename + 4, 32, rgucMD5_hash );

	lea	eax, DWORD PTR _rgucMD5_hash$[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _filename$[ebp]
	add	ecx, 4
	push	ecx
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 2215 : 
; 2216 : 			if( !memcmp( p->rgucMD5_hash, rgucMD5_hash, 16 ))

	push	16					; 00000010H
	lea	edx, DWORD PTR _rgucMD5_hash$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_Process

; 2217 : 				break;

	jmp	SHORT $LN3@CL_Process
$LN15@CL_Process:

; 2218 : 		}

	jmp	SHORT $LN14@CL_Process
$LN13@CL_Process:

; 2219 : 		else
; 2220 : 		{
; 2221 : 			if( p->type == t_generic )

	mov	ecx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [ecx+64], 4
	jne	SHORT $LN16@CL_Process

; 2222 : 			{
; 2223 : 				if( !Q_stricmp( p->szFileName, filename ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@CL_Process

; 2224 : 					break;

	jmp	SHORT $LN3@CL_Process
$LN18@CL_Process:

; 2225 : 			}

	jmp	SHORT $LN14@CL_Process
$LN16@CL_Process:

; 2226 : 			else
; 2227 : 			{
; 2228 : 				if( !Q_stricmp( p->szFileName, pfilename ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _pfilename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@CL_Process

; 2229 : 					break;

	jmp	SHORT $LN3@CL_Process
$LN14@CL_Process:

; 2230 : 			}
; 2231 : 		}
; 2232 : 	}

	jmp	$LN2@CL_Process
$LN3@CL_Process:

; 2233 : 
; 2234 : 	if( p != &cl.resourcesneeded )

	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	$LN20@CL_Process

; 2235 : 	{
; 2236 : 		if( successfully_received )

	cmp	DWORD PTR _successfully_received$[ebp], 0
	je	SHORT $LN21@CL_Process

; 2237 : 			ClearBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl
$LN21@CL_Process:

; 2238 : 
; 2239 : 		if( filename[0] == '!' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	$LN22@CL_Process

; 2240 : 		{
; 2241 : 			if( cls.netchan.tempbuffer )

	cmp	DWORD PTR _cls+286216, 0
	je	$LN23@CL_Process

; 2242 : 			{
; 2243 : 				if( p->nDownloadSize == cls.netchan.tempbuffersize )

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	edx, DWORD PTR _cls+286220
	jne	SHORT $LN24@CL_Process

; 2244 : 				{
; 2245 : 					if( p->ucFlags & RES_CUSTOM )

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN26@CL_Process

; 2246 : 					{
; 2247 : 						HPAK_AddLump( true, CUSTOM_RES_PATH, p, cls.netchan.tempbuffer, NULL );

	push	0
	mov	edx, DWORD PTR _cls+286216
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET $SG145432
	push	1
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H

; 2248 : 						CL_RegisterCustomization( p );

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_CL_RegisterCustomization
	add	esp, 4
$LN26@CL_Process:

; 2249 : 					}
; 2250 : 				}

	jmp	SHORT $LN25@CL_Process
$LN24@CL_Process:

; 2251 : 				else
; 2252 : 				{
; 2253 : 					Con_Printf( "Downloaded %i bytes for purported %i byte file, ignoring download\n", 

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _cls+286220
	push	ecx
	push	OFFSET $SG145433
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN25@CL_Process:

; 2254 : 					cls.netchan.tempbuffersize, p->nDownloadSize );
; 2255 : 				}
; 2256 : 
; 2257 : 				if( cls.netchan.tempbuffer )

	cmp	DWORD PTR _cls+286216, 0
	je	SHORT $LN23@CL_Process

; 2258 : 					Mem_Free( cls.netchan.tempbuffer );

	push	2258					; 000008d2H
	push	OFFSET $SG145435
	mov	edx, DWORD PTR _cls+286216
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@CL_Process:

; 2259 : 			}
; 2260 : 
; 2261 : 			cls.netchan.tempbuffersize = 0;

	mov	DWORD PTR _cls+286220, 0

; 2262 : 			cls.netchan.tempbuffer = NULL;

	mov	DWORD PTR _cls+286216, 0
$LN22@CL_Process:

; 2263 : 		}
; 2264 : 
; 2265 : 		// moving to 'onhandle' list even if file was missed
; 2266 : 		CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4
$LN20@CL_Process:

; 2267 : 	}
; 2268 : 
; 2269 : 	if( cls.state != ca_disconnected )

	cmp	DWORD PTR _cls, 0
	je	$LN1@CL_Process

; 2270 : 	{
; 2271 : 		host.downloadcount = 0;

	mov	DWORD PTR _host+752, 0

; 2272 : 
; 2273 : 		for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	ecx, DWORD PTR _cl+1985124
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN7@CL_Process
$LN5@CL_Process:
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR _p$[ebp], eax
$LN7@CL_Process:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+1984996
	je	SHORT $LN6@CL_Process

; 2274 : 			host.downloadcount++;

	mov	ecx, DWORD PTR _host+752
	add	ecx, 1
	mov	DWORD PTR _host+752, ecx
	jmp	SHORT $LN5@CL_Process
$LN6@CL_Process:

; 2275 : 
; 2276 : 		if( cl.resourcesneeded.pNext == &cl.resourcesneeded )

	cmp	DWORD PTR _cl+1985124, OFFSET _cl+1984996
	jne	SHORT $LN29@CL_Process

; 2277 : 		{
; 2278 : 			byte	msg_buf[MAX_INIT_MSG];
; 2279 : 			sizebuf_t msg;
; 2280 : 
; 2281 : 			MSG_Init( &msg, "Resource Registration", msg_buf, sizeof( msg_buf ));

	push	-1
	push	131072					; 00020000H
	lea	edx, DWORD PTR _msg_buf$2[ebp]
	push	edx
	push	OFFSET $SG145438
	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2282 : 
; 2283 : 			if( CL_PrecacheResources( ))

	call	_CL_PrecacheResources
	test	eax, eax
	je	SHORT $LN30@CL_Process

; 2284 : 				CL_RegisterResources( &msg );

	lea	ecx, DWORD PTR _msg$1[ebp]
	push	ecx
	call	_CL_RegisterResources
	add	esp, 4
$LN30@CL_Process:

; 2285 : 
; 2286 : 			if( MSG_GetNumBytesWritten( &msg ) > 0 )

	lea	edx, DWORD PTR _msg$1[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN29@CL_Process

; 2287 : 			{
; 2288 : 				Netchan_CreateFragments( &cls.netchan, &msg );

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	OFFSET _cls+23520
	call	_Netchan_CreateFragments
	add	esp, 8

; 2289 : 				Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_FragSend
	add	esp, 4
$LN29@CL_Process:

; 2290 : 			}
; 2291 : 		}
; 2292 : 
; 2293 : 		if( cls.netchan.tempbuffer )

	cmp	DWORD PTR _cls+286216, 0
	je	SHORT $LN32@CL_Process

; 2294 : 		{
; 2295 : 			Con_Printf( "Received a decal %s, but didn't find it in resources needed list!\n", pfilename );

	mov	ecx, DWORD PTR _pfilename$[ebp]
	push	ecx
	push	OFFSET $SG145442
	call	_Con_Printf
	add	esp, 8

; 2296 : 			Mem_Free( cls.netchan.tempbuffer );

	push	2296					; 000008f8H
	push	OFFSET $SG145443
	mov	edx, DWORD PTR _cls+286216
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN32@CL_Process:

; 2297 : 		}
; 2298 : 
; 2299 : 		cls.netchan.tempbuffer = NULL;

	mov	DWORD PTR _cls+286216, 0

; 2300 : 		cls.netchan.tempbuffersize = 0;

	mov	DWORD PTR _cls+286220, 0
$LN1@CL_Process:

; 2301 : 	}
; 2302 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Disconnect_f PROC

; 1431 : {

	push	ebp
	mov	ebp, esp

; 1432 : 	if( Host_IsLocalClient( ))

	call	_Host_IsLocalClient
	test	eax, eax
	je	SHORT $LN2@CL_Disconn

; 1433 : 		Host_EndGame( true, "disconnected from server\n" );

	push	OFFSET $SG145098
	push	1
	call	_Host_EndGame
	add	esp, 8
	jmp	SHORT $LN1@CL_Disconn
$LN2@CL_Disconn:

; 1434 : 	else CL_Disconnect();

	call	_CL_Disconnect
$LN1@CL_Disconn:

; 1435 : }

	pop	ebp
	ret	0
_CL_Disconnect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_SendCommand PROC

; 892  : {

	push	ebp
	mov	ebp, esp

; 893  : 	// we create commands even if a demo is playing,
; 894  : 	CL_CreateCmd();

	call	_CL_CreateCmd

; 895  : 
; 896  : 	// clc_move, userinfo etc
; 897  : 	CL_WritePacket();

	call	_CL_WritePacket

; 898  : }

	pop	ebp
	ret	0
_CL_SendCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Quit_f PROC

; 975  : {

	push	ebp
	mov	ebp, esp

; 976  : 	CL_Disconnect();

	call	_CL_Disconnect

; 977  : 	Sys_Quit();

	call	_Sys_Quit

; 978  : }

	pop	ebp
	ret	0
_CL_Quit_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 106  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetMaxBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetMaxBytes PROC					; COMDAT

; 103  : _inline int MSG_GetMaxBytes( sizebuf_t *sb ) { return sb->nDataBits >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetMaxBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 101  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetRealBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetRealBytesWritten PROC				; COMDAT

; 100  : _inline int MSG_GetRealBytesWritten( sizebuf_t *sb ) { return sb->iCurBit >> 3; }	// unpadded

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetRealBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Drop PROC

; 988  : {

	push	ebp
	mov	ebp, esp

; 989  : 	if( !cls.initialized )

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN2@CL_Drop

; 990  : 		return;

	jmp	SHORT $LN1@CL_Drop
$LN2@CL_Drop:

; 991  : 	CL_Disconnect();

	call	_CL_Disconnect
$LN1@CL_Drop:

; 992  : }

	pop	ebp
	ret	0
_CL_Drop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Crashed PROC

; 1438 : {

	push	ebp
	mov	ebp, esp

; 1439 : 	// already freed
; 1440 : 	if( host.status == HOST_CRASHED ) return;

	cmp	DWORD PTR _host+12, 6
	jne	SHORT $LN2@CL_Crashed
	jmp	SHORT $LN1@CL_Crashed
$LN2@CL_Crashed:

; 1441 : 	if( host.type != HOST_NORMAL ) return;

	cmp	DWORD PTR _host+164, 0
	je	SHORT $LN3@CL_Crashed
	jmp	SHORT $LN1@CL_Crashed
$LN3@CL_Crashed:

; 1442 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN4@CL_Crashed
	jmp	SHORT $LN1@CL_Crashed
$LN4@CL_Crashed:

; 1443 : 
; 1444 : 	host.status = HOST_CRASHED;

	mov	DWORD PTR _host+12, 6

; 1445 : 
; 1446 : 	CL_Stop_f(); // stop any demos

	call	_CL_Stop_f

; 1447 : 
; 1448 : 	// send a disconnect message to the server
; 1449 : 	CL_SendDisconnectMessage();

	call	_CL_SendDisconnectMessage

; 1450 : 
; 1451 : 	Host_WriteOpenGLConfig();

	call	_Host_WriteOpenGLConfig

; 1452 : 	Host_WriteConfig();	// write config

	call	_Host_WriteConfig
$LN1@CL_Crashed:

; 1453 : }

	pop	ebp
	ret	0
_CL_Crashed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Disconnect PROC

; 1399 : {

	push	ebp
	mov	ebp, esp

; 1400 : 	if( cls.state == ca_disconnected )

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_Disconn

; 1401 : 		return;

	jmp	$LN1@CL_Disconn
$LN2@CL_Disconn:

; 1402 : 
; 1403 : 	cls.connect_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+136, xmm0

; 1404 : 	cls.changedemo = false;

	mov	DWORD PTR _cls+12, 0

; 1405 : 	cls.max_fragment_size = FRAGMENT_MAX_SIZE; // reset fragment size

	mov	DWORD PTR _cls+144, 64000		; 0000fa00H

; 1406 : 	CL_Stop_f();

	call	_CL_Stop_f

; 1407 : 
; 1408 : 	// send a disconnect message to the server
; 1409 : 	CL_SendDisconnectMessage();

	call	_CL_SendDisconnectMessage

; 1410 : 	CL_ClearState ();

	call	_CL_ClearState

; 1411 : 
; 1412 : 	S_StopBackgroundTrack ();

	call	_S_StopBackgroundTrack

; 1413 : 	SCR_EndLoadingPlaque (); // get rid of loading plaque

	call	_SCR_EndLoadingPlaque

; 1414 : 
; 1415 : 	// clear the network channel, too.
; 1416 : 	Netchan_Clear( &cls.netchan );

	push	OFFSET _cls+23520
	call	_Netchan_Clear
	add	esp, 4

; 1417 : 
; 1418 : 	cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0

; 1419 : 	cls.set_lastdemo = false;

	mov	DWORD PTR _cls+297856, 0

; 1420 : 	cls.connect_retry = 0;

	mov	DWORD PTR _cls+148, 0

; 1421 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1422 : 
; 1423 : 	// back to menu in non-developer mode
; 1424 : 	if( host_developer.value || CL_IsInMenu( ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@CL_Disconn
	call	_CL_IsInMenu
	test	eax, eax
	je	SHORT $LN3@CL_Disconn
$LN4@CL_Disconn:

; 1425 : 		return;

	jmp	SHORT $LN1@CL_Disconn
$LN3@CL_Disconn:

; 1426 : 
; 1427 : 	UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN1@CL_Disconn:

; 1428 : }

	pop	ebp
	ret	0
_CL_Disconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_IsQuakeCompatible PROC

; 150  : {

	push	ebp
	mov	ebp, esp

; 151  : 	// feature set
; 152  : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 2
	je	SHORT $LN2@CL_IsQuake

; 153  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsQuake
$LN2@CL_IsQuake:

; 154  : 
; 155  : 	// quake demo playing
; 156  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	SHORT $LN3@CL_IsQuake

; 157  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsQuake
$LN3@CL_IsQuake:

; 158  : 
; 159  : 	return false;

	xor	eax, eax
$LN1@CL_IsQuake:

; 160  : }

	pop	ebp
	ret	0
_CL_IsQuakeCompatible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_CL_IsBackgroundMap PROC

; 145  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 146  : 	return ( cl.background && !cls.demoplayback );

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN3@CL_IsBackg
	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN3@CL_IsBackg
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@CL_IsBackg
$LN3@CL_IsBackg:
	mov	DWORD PTR tv66[ebp], 0
$LN4@CL_IsBackg:
	mov	eax, DWORD PTR tv66[ebp]

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsBackgroundMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_CL_IsBackgroundDemo PROC

; 140  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 141  : 	return ( cls.demoplayback && cls.demonum != -1 );

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN3@CL_IsBackg
	cmp	DWORD PTR _cls+293464, -1
	je	SHORT $LN3@CL_IsBackg
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@CL_IsBackg
$LN3@CL_IsBackg:
	mov	DWORD PTR tv66[ebp], 0
$LN4@CL_IsBackg:
	mov	eax, DWORD PTR tv66[ebp]

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsBackgroundDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_IsPlaybackDemo PROC

; 120  : {

	push	ebp
	mov	ebp, esp

; 121  : 	return cls.demoplayback;

	mov	eax, DWORD PTR _cls+297580

; 122  : }

	pop	ebp
	ret	0
_CL_IsPlaybackDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_IsTimeDemo PROC

; 130  : {

	push	ebp
	mov	ebp, esp

; 131  : 	return cls.timedemo;

	mov	eax, DWORD PTR _cls+297588

; 132  : }

	pop	ebp
	ret	0
_CL_IsTimeDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_IsRecordDemo PROC

; 125  : {

	push	ebp
	mov	ebp, esp

; 126  : 	return cls.demorecording;

	mov	eax, DWORD PTR _cls+297576

; 127  : }

	pop	ebp
	ret	0
_CL_IsRecordDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_argptr$ = -1032					; size = 4
_string$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_reliable$ = 8						; size = 4
_fmt$ = 12						; size = 4
_CL_ServerCommand PROC

; 2312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1032				; 00000408H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2313 : 	char		string[MAX_SYSPATH];
; 2314 : 	va_list		argptr;
; 2315 : 
; 2316 : 	if( cls.state < ca_connecting )

	cmp	DWORD PTR _cls, 1
	jge	SHORT $LN2@CL_ServerC

; 2317 : 		return;

	jmp	$LN1@CL_ServerC
$LN2@CL_ServerC:

; 2318 : 
; 2319 : 	va_start( argptr, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 2320 : 	Q_vsprintf( string, fmt, argptr );

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	push	99999					; 0001869fH
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2321 : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 2322 : 
; 2323 : 	if( reliable )

	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN3@CL_ServerC

; 2324 : 	{
; 2325 : 		MSG_BeginClientCmd( &cls.netchan.message, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+23620
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2326 : 		MSG_WriteString( &cls.netchan.message, string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8

; 2327 : 	}

	jmp	SHORT $LN1@CL_ServerC
$LN3@CL_ServerC:

; 2328 : 	else
; 2329 : 	{
; 2330 : 		MSG_BeginClientCmd( &cls.datagram, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+7116
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2331 : 		MSG_WriteString( &cls.datagram, string );

	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	push	OFFSET _cls+7116
	call	_MSG_WriteString
	add	esp, 8
$LN1@CL_ServerC:

; 2332 : 	}
; 2333 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ServerCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_DisableVisibility PROC

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  : 	return cls.envshot_disable_vis;

	mov	eax, DWORD PTR _cls+293072

; 137  : }

	pop	ebp
	ret	0
_CL_DisableVisibility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Userinfo PROC

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  : 	return cls.userinfo;

	mov	eax, OFFSET _cls+6604

; 165  : }

	pop	ebp
	ret	0
_CL_Userinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Initialized PROC

; 88   : {

	push	ebp
	mov	ebp, esp

; 89   : 	return cls.initialized;

	mov	eax, DWORD PTR _cls+4

; 90   : }

	pop	ebp
	ret	0
_CL_Initialized ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_IsIntermission PROC

; 115  : {

	push	ebp
	mov	ebp, esp

; 116  : 	return cl.intermission;

	mov	eax, DWORD PTR _cl+1568648

; 117  : }

	pop	ebp
	ret	0
_CL_IsIntermission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_CL_IsInConsole PROC

; 110  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 111  : 	return ( cls.key_dest == key_console );

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN3@CL_IsInCon
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@CL_IsInCon
$LN3@CL_IsInCon:
	mov	DWORD PTR tv65[ebp], 0
$LN4@CL_IsInCon:
	mov	eax, DWORD PTR tv65[ebp]

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsInConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_CL_IsInMenu PROC

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 106  : 	return ( cls.key_dest == key_menu );

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN3@CL_IsInMen
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@CL_IsInMen
$LN3@CL_IsInMen:
	mov	DWORD PTR tv65[ebp], 0
$LN4@CL_IsInMen:
	mov	eax, DWORD PTR tv65[ebp]

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsInMenu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_CL_IsInGame PROC

; 94   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 95   : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@CL_IsInGam

; 96   : 		return true; // always active for dedicated servers

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsInGam
$LN2@CL_IsInGam:

; 97   : 
; 98   : 	if( cl.background || CL_GetMaxClients() > 1 )

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN4@CL_IsInGam
	call	_CL_GetMaxClients
	cmp	eax, 1
	jle	SHORT $LN3@CL_IsInGam
$LN4@CL_IsInGam:

; 99   : 		return true; // always active for multiplayer or background map

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsInGam
$LN3@CL_IsInGam:

; 100  : 
; 101  : 	return ( cls.key_dest == key_game ); // active if not menu or console

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN6@CL_IsInGam
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@CL_IsInGam
$LN6@CL_IsInGam:
	mov	DWORD PTR tv69[ebp], 0
$LN7@CL_IsInGam:
	mov	eax, DWORD PTR tv69[ebp]
$LN1@CL_IsInGam:

; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsInGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_CL_Active PROC

; 83   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 84   : 	return ( cls.state == ca_active );

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN3@CL_Active
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@CL_Active
$LN3@CL_Active:
	mov	DWORD PTR tv65[ebp], 0
$LN4@CL_Active:
	mov	eax, DWORD PTR tv65[ebp]

; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Active ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_Host_ClientFrame PROC

; 2761 : {

	push	ebp
	mov	ebp, esp

; 2762 : 	// if client is not active, do nothing
; 2763 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN4@Host_Clien
	jmp	SHORT $LN1@Host_Clien
$LN4@Host_Clien:

; 2764 : 
; 2765 : 	// if running the server remotely, send intentions now after
; 2766 : 	// the incoming messages have been read
; 2767 : 	if( !SV_Active( )) CL_SendCommand ();

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN5@Host_Clien
	call	_CL_SendCommand
$LN5@Host_Clien:

; 2768 : 
; 2769 : 	clgame.dllFuncs.pfnFrame( host.frametime );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+136
	add	esp, 8

; 2770 : 
; 2771 : 	// remember last received framenum
; 2772 : 	CL_SetLastUpdate ();

	call	_CL_SetLastUpdate

; 2773 : 
; 2774 : 	// read updates from server
; 2775 : 	CL_ReadPackets ();

	call	_CL_ReadPackets

; 2776 : 
; 2777 : 	// do prediction again in case we got
; 2778 : 	// a new portion updates from server
; 2779 : 	CL_RedoPrediction ();

	call	_CL_RedoPrediction

; 2780 : 
; 2781 : 	// TODO: implement
; 2782 : //	Voice_Idle( host.frametime );
; 2783 : 
; 2784 : 	// emit visible entities
; 2785 : 	CL_EmitEntities ();

	call	_CL_EmitEntities

; 2786 : 
; 2787 : 	// in case we lost connection
; 2788 : 	CL_CheckForResend ();

	call	_CL_CheckForResend
$LN2@Host_Clien:

; 2789 : 
; 2790 : 	// procssing resources on handle
; 2791 : 	while( CL_RequestMissingResources( ));

	call	_CL_RequestMissingResources
	test	eax, eax
	je	SHORT $LN3@Host_Clien
	jmp	SHORT $LN2@Host_Clien
$LN3@Host_Clien:

; 2792 : 
; 2793 : 	// handle thirdperson camera
; 2794 : 	CL_MoveThirdpersonCamera();

	call	_CL_MoveThirdpersonCamera

; 2795 : 
; 2796 : 	// handle spectator movement
; 2797 : 	CL_MoveSpectatorCamera();

	call	_CL_MoveSpectatorCamera

; 2798 : 
; 2799 : 	// catch changes video settings
; 2800 : 	VID_CheckChanges();

	call	_VID_CheckChanges

; 2801 : 
; 2802 : 	// process VGUI
; 2803 : 	VGui_RunFrame ();

	call	_VGui_RunFrame

; 2804 : 
; 2805 : 	// update the screen
; 2806 : 	SCR_UpdateScreen ();

	call	_SCR_UpdateScreen

; 2807 : 
; 2808 : 	// update audio
; 2809 : 	SND_UpdateSound ();

	call	_SND_UpdateSound

; 2810 : 
; 2811 : 	// play avi-files
; 2812 : 	SCR_RunCinematic ();

	call	_SCR_RunCinematic

; 2813 : 
; 2814 : 	// adjust client time
; 2815 : 	CL_AdjustClock ();

	call	_CL_AdjustClock
$LN1@Host_Clien:

; 2816 : }

	pop	ebp
	ret	0
_Host_ClientFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_Host_ClientBegin PROC

; 2737 : {

	push	ebp
	mov	ebp, esp

; 2738 : 	// if client is not active, do nothing
; 2739 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN2@Host_Clien
	jmp	SHORT $LN1@Host_Clien
$LN2@Host_Clien:

; 2740 : 
; 2741 : 	// exec console commands
; 2742 : 	Cbuf_Execute ();

	call	_Cbuf_Execute

; 2743 : 
; 2744 : 	// finalize connection process if needs
; 2745 : 	CL_CheckClientState();

	call	_CL_CheckClientState

; 2746 : 
; 2747 : 	// tell the client.dll about client data
; 2748 : 	CL_UpdateClientData();

	call	_CL_UpdateClientData

; 2749 : 
; 2750 : 	// if running the server locally, make intentions now
; 2751 : 	if( SV_Active( )) CL_SendCommand ();

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN1@Host_Clien
	call	_CL_SendCommand
$LN1@Host_Clien:

; 2752 : }

	pop	ebp
	ret	0
_Host_ClientBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Shutdown PROC

; 2854 : {

	push	ebp
	mov	ebp, esp

; 2855 : 	// already freed
; 2856 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN2@CL_Shutdow
	jmp	SHORT $LN1@CL_Shutdow
$LN2@CL_Shutdow:

; 2857 : 	cls.initialized = false;

	mov	DWORD PTR _cls+4, 0

; 2858 : 
; 2859 : 	Con_Printf( "CL_Shutdown()\n" );

	push	OFFSET $SG145797
	call	_Con_Printf
	add	esp, 4

; 2860 : 
; 2861 : 	Host_WriteOpenGLConfig ();

	call	_Host_WriteOpenGLConfig

; 2862 : 	Host_WriteVideoConfig ();

	call	_Host_WriteVideoConfig

; 2863 : 
; 2864 : 	CL_CloseDemoHeader();

	call	_CL_CloseDemoHeader

; 2865 : 	IN_Shutdown ();

	call	_IN_Shutdown

; 2866 : 	SCR_Shutdown ();

	call	_SCR_Shutdown

; 2867 : 	CL_UnloadProgs ();

	call	_CL_UnloadProgs

; 2868 : 
; 2869 : 	FS_Delete( "demoheader.tmp" ); // remove tmp file

	push	OFFSET $SG145798
	call	_FS_Delete
	add	esp, 4

; 2870 : 	SCR_FreeCinematic (); // release AVI's *after* client.dll because custom renderer may use them

	call	_SCR_FreeCinematic

; 2871 : 	S_Shutdown ();

	call	_S_Shutdown

; 2872 : 	R_Shutdown ();

	call	_R_Shutdown

; 2873 : 
; 2874 : 	Con_Shutdown ();

	call	_Con_Shutdown
$LN1@CL_Shutdow:

; 2875 : }

	pop	ebp
	ret	0
_CL_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_main.c
_TEXT	SEGMENT
_CL_Init PROC

; 2826 : {

	push	ebp
	mov	ebp, esp

; 2827 : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@CL_Init

; 2828 : 		return; // nothing running on the client

	jmp	$LN1@CL_Init
$LN2@CL_Init:

; 2829 : 
; 2830 : 	CL_InitLocal();

	call	_CL_InitLocal

; 2831 : 
; 2832 : 	R_Init();	// init renderer

	call	_R_Init

; 2833 : 	S_Init();	// init sound

	call	_S_Init

; 2834 : 
; 2835 : 	// unreliable buffer. unsed for unreliable commands and voice stream
; 2836 : 	MSG_Init( &cls.datagram, "cls.datagram", cls.datagram_buf, sizeof( cls.datagram_buf ));

	push	-1
	push	16384					; 00004000H
	push	OFFSET _cls+7136
	push	OFFSET $SG145790
	push	OFFSET _cls+7116
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2837 : 
; 2838 : 	if( !CL_LoadProgs( va( "%s/client.dll", GI->dll_path )))

	mov	eax, DWORD PTR _SI+768
	add	eax, 452				; 000001c4H
	push	eax
	push	OFFSET $SG145792
	call	_va
	add	esp, 8
	push	eax
	call	_CL_LoadProgs
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@CL_Init

; 2839 : 		Host_Error( "can't initialize client.dll\n" );

	push	OFFSET $SG145793
	call	_Host_Error
	add	esp, 4
$LN3@CL_Init:

; 2840 : 
; 2841 : 	cls.initialized = true;

	mov	DWORD PTR _cls+4, 1

; 2842 : 	cl.maxclients = 1; // allow to drawing player in menu

	mov	DWORD PTR _cl+1568832, 1

; 2843 : 	cls.olddemonum = -1;

	mov	DWORD PTR _cls+293468, -1

; 2844 : 	cls.demonum = -1;

	mov	DWORD PTR _cls+293464, -1
$LN1@CL_Init:

; 2845 : }

	pop	ebp
	ret	0
_CL_Init ENDP
_TEXT	ENDS
END
