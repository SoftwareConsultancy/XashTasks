; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\net_buffer.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_MSG_InitExt
PUBLIC	_MSG_InitMasks
PUBLIC	_MSG_SeekToBit
PUBLIC	_MSG_ExciseBits
PUBLIC	_MSG_CheckOverflow
PUBLIC	_MSG_BigShort
PUBLIC	_MSG_StartWriting
PUBLIC	_MSG_Clear
PUBLIC	_MSG_WriteOneBit
PUBLIC	_MSG_WriteUBitLong
PUBLIC	_MSG_WriteSBitLong
PUBLIC	_MSG_WriteBitLong
PUBLIC	_MSG_WriteBits
PUBLIC	_MSG_WriteBitAngle
PUBLIC	_MSG_WriteBitFloat
PUBLIC	_MSG_WriteCmdExt
PUBLIC	_MSG_WriteChar
PUBLIC	_MSG_WriteByte
PUBLIC	_MSG_WriteShort
PUBLIC	_MSG_WriteWord
PUBLIC	_MSG_WriteLong
PUBLIC	_MSG_WriteDword
PUBLIC	_MSG_WriteCoord
PUBLIC	_MSG_WriteFloat
PUBLIC	_MSG_WriteVec3Coord
PUBLIC	_MSG_WriteVec3Angles
PUBLIC	_MSG_WriteBytes
PUBLIC	_MSG_WriteString
PUBLIC	_MSG_GetMaxBytes
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_ReadOneBit
PUBLIC	_MSG_ReadBitFloat
PUBLIC	_MSG_ReadBits
PUBLIC	_MSG_ReadBitAngle
PUBLIC	_MSG_ReadSBitLong
PUBLIC	_MSG_ReadUBitLong
PUBLIC	_MSG_ReadBitLong
PUBLIC	_MSG_ReadCmd
PUBLIC	_MSG_ReadChar
PUBLIC	_MSG_ReadByte
PUBLIC	_MSG_ReadShort
PUBLIC	_MSG_ReadWord
PUBLIC	_MSG_ReadLong
PUBLIC	_MSG_ReadDword
PUBLIC	_MSG_ReadCoord
PUBLIC	_MSG_ReadFloat
PUBLIC	_MSG_ReadVec3Coord
PUBLIC	_MSG_ReadVec3Angles
PUBLIC	_MSG_ReadBytes
PUBLIC	_MSG_ReadStringExt
PUBLIC	_MSG_SeekToByte
PUBLIC	__real@00000000
PUBLIC	__real@3e000000
PUBLIC	__real@3f000000
PUBLIC	__real@4076800000000000
PUBLIC	__real@41000000
PUBLIC	__real@43340000
PUBLIC	__real@43b40000
PUBLIC	__real@c3340000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_fmod:PROC
EXTRN	_host:BYTE
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_BitWriteMasks DD 0420H DUP (?)
_ExtraMasks DD	020H DUP (?)
?string@?1??MSG_ReadStringExt@@9@9 DB 0800H DUP (?)	; `MSG_ReadStringExt'::`2'::string
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG131961 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG131962 DB	'((dword)pData & 3 ) == 0', 00H
	ORG $+3
$SG131963 DB	'Unnamed', 00H
	ORG $+4
$SG131966 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG131967 DB	'nBits <= nBytes * 8', 00H
	ORG $+4
$SG132030 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132031 DB	'numbits >= 0 && numbits <= 32', 00H
	ORG $+2
$SG132034 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132035 DB	'( iDWord * 4 + sizeof( long )) <= (uint)MSG_GetMaxBytes('
	DB	' sb )', 00H
	ORG $+2
$SG132047 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132048 DB	'numbits >= 1 && numbits <= 32', 00H
	ORG $+2
$SG132128 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132129 DB	'sizeof( long ) == sizeof( float )', 00H
	ORG $+6
$SG132130 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132131 DB	'sizeof( float ) == 4', 00H
	ORG $+3
$SG132222 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132223 DB	'numbits > 0 && numbits <= 32', 00H
	ORG $+3
$SG132243 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132244 DB	'sizeof( float ) == sizeof( long )', 00H
	ORG $+6
$SG132245 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132246 DB	'sizeof( float ) == 4', 00H
	ORG $+3
$SG132352 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_buffer.c', 00H
	ORG $+2
$SG132353 DB	'sizeof( ret ) == 4', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_bytePos$ = 12						; size = 4
_MSG_SeekToByte PROC

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  : 	sb->iCurBit = bytePos << 3;

	mov	eax, DWORD PTR _bytePos$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 137  : }

	pop	ebp
	ret	0
_MSG_SeekToByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_nBits$ = 12						; size = 4
_MSG_Overflow PROC

; 98   : {

	push	ebp
	mov	ebp, esp

; 99   : 	if( sb->iCurBit + nBits > sb->nDataBits )

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _nBits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jle	SHORT $LN2@MSG_Overfl

; 100  : 		sb->bOverflow = true;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 1
$LN2@MSG_Overfl:

; 101  : 	return sb->bOverflow;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [ecx]

; 102  : }

	pop	ebp
	ret	0
_MSG_Overflow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
$T1 = -12						; size = 4
_l$ = -8						; size = 4
_c$ = -4						; size = 4
_sb$ = 8						; size = 4
_bLine$ = 12						; size = 4
_MSG_ReadStringExt PROC

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 647  : 	static char	string[2048];
; 648  : 	int		l = 0, c;

	mov	DWORD PTR _l$[ebp], 0
$LN4@MSG_ReadSt:

; 649  : 	
; 650  : 	do
; 651  : 	{
; 652  : 		// use MSG_ReadByte so -1 is out of bounds
; 653  : 		c = MSG_ReadByte( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 654  : 
; 655  : 		if( c == 0 ) break;

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN5@MSG_ReadSt
	jmp	SHORT $LN3@MSG_ReadSt
	jmp	SHORT $LN6@MSG_ReadSt
$LN5@MSG_ReadSt:

; 656  : 		else if( bLine && c == '\n' )

	cmp	DWORD PTR _bLine$[ebp], 0
	je	SHORT $LN6@MSG_ReadSt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jne	SHORT $LN6@MSG_ReadSt

; 657  : 			break;

	jmp	SHORT $LN3@MSG_ReadSt
$LN6@MSG_ReadSt:

; 658  : 
; 659  : 		// translate all fmt spec to avoid crash bugs
; 660  : 		// NOTE: but game strings leave unchanged. see pfnWriteString for details
; 661  : 		if( c == '%' ) c = '.';

	cmp	DWORD PTR _c$[ebp], 37			; 00000025H
	jne	SHORT $LN8@MSG_ReadSt
	mov	DWORD PTR _c$[ebp], 46			; 0000002eH
$LN8@MSG_ReadSt:

; 662  : 
; 663  : 		string[l] = c;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR ?string@?1??MSG_ReadStringExt@@9@9[ecx], dl

; 664  : 		l++;

	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 665  : 	} while( l < sizeof( string ) - 1 );

	cmp	DWORD PTR _l$[ebp], 2047		; 000007ffH
	jb	SHORT $LN4@MSG_ReadSt
$LN3@MSG_ReadSt:

; 666  : 	string[l] = 0; // terminator

	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN10@MSG_ReadSt
	jmp	SHORT $LN11@MSG_ReadSt
$LN10@MSG_ReadSt:
	call	___report_rangecheckfailure
$LN11@MSG_ReadSt:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?string@?1??MSG_ReadStringExt@@9@9[edx], 0

; 667  : 
; 668  : 	return string;

	mov	eax, OFFSET ?string@?1??MSG_ReadStringExt@@9@9
$LN9@MSG_ReadSt:

; 669  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadStringExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_pOut$ = 12						; size = 4
_nBytes$ = 16						; size = 4
_MSG_ReadBytes PROC

; 641  : {

	push	ebp
	mov	ebp, esp

; 642  : 	return MSG_ReadBits( sb, pOut, nBytes << 3 );

	mov	eax, DWORD PTR _nBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadBits
	add	esp, 12					; 0000000cH

; 643  : }

	pop	ebp
	ret	0
_MSG_ReadBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_ReadVec3Angles PROC

; 613  : {

	push	ebp
	mov	ebp, esp

; 614  : 	fa[0] = MSG_ReadBitAngle( sb, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 615  : 	fa[1] = MSG_ReadBitAngle( sb, 16 );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 616  : 	fa[2] = MSG_ReadBitAngle( sb, 16 );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 617  : }

	pop	ebp
	ret	0
_MSG_ReadVec3Angles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_ReadVec3Coord PROC

; 606  : {

	push	ebp
	mov	ebp, esp

; 607  : 	fa[0] = MSG_ReadCoord( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 608  : 	fa[1] = MSG_ReadCoord( sb );

	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 609  : 	fa[2] = MSG_ReadCoord( sb );

	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 610  : }

	pop	ebp
	ret	0
_MSG_ReadVec3Coord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadFloat PROC

; 630  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 631  : 	float	ret;
; 632  : 
; 633  : 	Assert( sizeof( ret ) == 4 );

	push	0
	push	633					; 00000279H
	push	OFFSET $SG132352
	push	OFFSET $SG132353
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 634  : 
; 635  : 	MSG_ReadBits( sb, &ret, 32 );

	push	32					; 00000020H
	lea	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadBits
	add	esp, 12					; 0000000cH

; 636  : 
; 637  : 	return ret;

	fld	DWORD PTR _ret$[ebp]

; 638  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv85 = -12						; size = 4
tv79 = -8						; size = 4
tv78 = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadCoord PROC

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 599  : 	// g-cont. we loose precision here but keep old size of coord variable!
; 600  : 	if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 1
	je	SHORT $LN2@MSG_ReadCo

; 601  : 		return (float)(MSG_ReadShort( sb ));

	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	fild	DWORD PTR tv78[ebp]
	fstp	DWORD PTR tv79[ebp]
	fld	DWORD PTR tv79[ebp]
	jmp	SHORT $LN1@MSG_ReadCo
$LN2@MSG_ReadCo:

; 602  : 	return (float)(MSG_ReadShort( sb ) * ( 1.0f / 8.0f ));

	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e000000
	movss	DWORD PTR tv85[ebp], xmm0
	fld	DWORD PTR tv85[ebp]
$LN1@MSG_ReadCo:

; 603  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadCoord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadDword PROC

; 625  : {

	push	ebp
	mov	ebp, esp

; 626  : 	return MSG_ReadUBitLong( sb, sizeof( dword ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8

; 627  : }

	pop	ebp
	ret	0
_MSG_ReadDword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadLong PROC

; 620  : {

	push	ebp
	mov	ebp, esp

; 621  : 	return MSG_ReadSBitLong( sb, sizeof( long ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8

; 622  : }

	pop	ebp
	ret	0
_MSG_ReadLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadWord PROC

; 593  : {

	push	ebp
	mov	ebp, esp

; 594  : 	return MSG_ReadUBitLong( sb, sizeof( word ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8

; 595  : }

	pop	ebp
	ret	0
_MSG_ReadWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadShort PROC

; 588  : {

	push	ebp
	mov	ebp, esp

; 589  : 	return MSG_ReadSBitLong( sb, sizeof( short ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8

; 590  : }

	pop	ebp
	ret	0
_MSG_ReadShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadByte PROC

; 583  : {

	push	ebp
	mov	ebp, esp

; 584  : 	return MSG_ReadUBitLong( sb, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8

; 585  : }

	pop	ebp
	ret	0
_MSG_ReadByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadChar PROC

; 578  : {

	push	ebp
	mov	ebp, esp

; 579  : 	return MSG_ReadSBitLong( sb, sizeof( char ) << 3 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8

; 580  : }

	pop	ebp
	ret	0
_MSG_ReadChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_cmd$ = -4						; size = 4
_sb$ = 8						; size = 4
_type$ = 12						; size = 4
_MSG_ReadCmd PROC

; 561  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 562  : 	int	cmd = MSG_ReadUBitLong( sb, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _cmd$[ebp], eax

; 563  : 
; 564  : #ifdef DEBUG_NET_MESSAGES_READ
; 565  : 	if( type == NS_SERVER )
; 566  : 	{
; 567  : 		Con_Printf( "^1cl^7 read: %s\n", CL_MsgInfo( cmd ));
; 568  : 	}
; 569  : 	else if( cmd >= 0 && cmd <= clc_lastmsg )
; 570  : 	{
; 571  : 		Con_Printf( "^1sv^7 read: %s\n", clc_strings[cmd] );
; 572  : 	}
; 573  : #endif
; 574  : 	return cmd;

	mov	eax, DWORD PTR _cmd$[ebp]

; 575  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_bSigned$ = 16						; size = 4
_MSG_ReadBitLong PROC

; 554  : {

	push	ebp
	mov	ebp, esp

; 555  : 	if( bSigned )

	cmp	DWORD PTR _bSigned$[ebp], 0
	je	SHORT $LN2@MSG_ReadBi

; 556  : 		return (uint)MSG_ReadSBitLong( sb, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadSBitLong
	add	esp, 8
	jmp	SHORT $LN1@MSG_ReadBi
$LN2@MSG_ReadBi:

; 557  : 	return MSG_ReadUBitLong( sb, numbits );

	mov	edx, DWORD PTR _numbits$[ebp]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
$LN1@MSG_ReadBi:

; 558  : }

	pop	ebp
	ret	0
_MSG_ReadBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_dword2$1 = -28						; size = 4
_nExtraBits$2 = -24					; size = 4
tv82 = -20						; size = 4
_leftBits$3 = -16					; size = 4
_idword1$ = -12						; size = 4
_dword1$ = -8						; size = 4
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadUBitLong PROC

; 410  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 411  : 	int	idword1;
; 412  : 	uint	dword1, ret;
; 413  : 
; 414  : 	if( numbits == 8 )

	cmp	DWORD PTR _numbits$[ebp], 8
	jne	SHORT $LN2@MSG_ReadUB

; 415  : 	{
; 416  : 		int leftBits = MSG_GetNumBitsLeft( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	mov	DWORD PTR _leftBits$3[ebp], eax

; 417  : 
; 418  : 		if( leftBits >= 0 && leftBits < 8 )

	cmp	DWORD PTR _leftBits$3[ebp], 0
	jl	SHORT $LN2@MSG_ReadUB
	cmp	DWORD PTR _leftBits$3[ebp], 8
	jge	SHORT $LN2@MSG_ReadUB

; 419  : 			return 0;	// end of message

	xor	eax, eax
	jmp	$LN1@MSG_ReadUB
$LN2@MSG_ReadUB:

; 420  : 	}
; 421  : 
; 422  : 	if(( sb->iCurBit + numbits ) > sb->nDataBits )

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _numbits$[ebp]
	mov	eax, DWORD PTR _sb$[ebp]
	cmp	edx, DWORD PTR [eax+16]
	jle	SHORT $LN4@MSG_ReadUB

; 423  : 	{
; 424  : 		sb->bOverflow = true;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx], 1

; 425  : 		sb->iCurBit = sb->nDataBits;

	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+12], ecx

; 426  : 		return 0;

	xor	eax, eax
	jmp	$LN1@MSG_ReadUB
$LN4@MSG_ReadUB:

; 427  : 	}
; 428  : 
; 429  : 	Assert( numbits > 0 && numbits <= 32 );

	cmp	DWORD PTR _numbits$[ebp], 0
	jle	SHORT $LN9@MSG_ReadUB
	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	jg	SHORT $LN9@MSG_ReadUB
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN10@MSG_ReadUB
$LN9@MSG_ReadUB:
	mov	DWORD PTR tv82[ebp], 0
$LN10@MSG_ReadUB:
	push	0
	push	429					; 000001adH
	push	OFFSET $SG132222
	push	OFFSET $SG132223
	mov	edx, DWORD PTR tv82[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 430  : 
; 431  : 	// Read the current dword.
; 432  : 	idword1 = sb->iCurBit >> 5;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	mov	DWORD PTR _idword1$[ebp], ecx

; 433  : 	dword1 = ((uint *)sb->pData)[idword1];

	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _idword1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _dword1$[ebp], edx

; 434  : 	dword1 >>= ( sb->iCurBit & 31 );	// get the bits we're interested in.

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR _dword1$[ebp]
	shr	edx, cl
	mov	DWORD PTR _dword1$[ebp], edx

; 435  : 
; 436  : 	sb->iCurBit += numbits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 437  : 	ret = dword1;

	mov	eax, DWORD PTR _dword1$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 438  : 
; 439  : 	// Does it span this dword?
; 440  : 	if(( sb->iCurBit - 1 ) >> 5 == idword1 )

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	sar	edx, 5
	cmp	edx, DWORD PTR _idword1$[ebp]
	jne	SHORT $LN5@MSG_ReadUB

; 441  : 	{
; 442  : 		if( numbits != 32 )

	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	je	SHORT $LN7@MSG_ReadUB

; 443  : 			ret &= ExtraMasks[numbits];

	mov	eax, DWORD PTR _numbits$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	and	ecx, DWORD PTR _ExtraMasks[eax*4]
	mov	DWORD PTR _ret$[ebp], ecx
$LN7@MSG_ReadUB:

; 444  : 	}

	jmp	SHORT $LN6@MSG_ReadUB
$LN5@MSG_ReadUB:

; 445  : 	else
; 446  : 	{
; 447  : 		int	nExtraBits = sb->iCurBit & 31;

	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _nExtraBits$2[ebp], eax

; 448  : 		uint	dword2 = ((uint *)sb->pData)[idword1+1] & ExtraMasks[nExtraBits];

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _idword1$[ebp]
	mov	ecx, DWORD PTR _nExtraBits$2[ebp]
	mov	edx, DWORD PTR [edx+eax*4+4]
	and	edx, DWORD PTR _ExtraMasks[ecx*4]
	mov	DWORD PTR _dword2$1[ebp], edx

; 449  : 		
; 450  : 		// no need to mask since we hit the end of the dword.
; 451  : 		// shift the second dword's part into the high bits.
; 452  : 		ret |= (dword2 << ( numbits - nExtraBits ));

	mov	ecx, DWORD PTR _numbits$[ebp]
	sub	ecx, DWORD PTR _nExtraBits$2[ebp]
	mov	eax, DWORD PTR _dword2$1[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN6@MSG_ReadUB:

; 453  : 	}
; 454  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@MSG_ReadUB:

; 455  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadUBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sign$ = -8						; size = 4
_r$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadSBitLong PROC

; 540  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 541  : 	int	r, sign;
; 542  : 
; 543  : 	r = MSG_ReadUBitLong( sb, numbits - 1 );

	mov	eax, DWORD PTR _numbits$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 544  : 
; 545  : 	// NOTE: it does this wierdness here so it's bit-compatible with regular integer data in the buffer.
; 546  : 	// (Some old code writes direct integers right into the buffer).
; 547  : 	sign = MSG_ReadOneBit( sb );

	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _sign$[ebp], eax

; 548  : 	if( sign ) r = -( BIT( numbits - 1 ) - r );

	cmp	DWORD PTR _sign$[ebp], 0
	je	SHORT $LN2@MSG_ReadSB
	mov	ecx, DWORD PTR _numbits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	sub	eax, DWORD PTR _r$[ebp]
	neg	eax
	mov	DWORD PTR _r$[ebp], eax
$LN2@MSG_ReadSB:

; 549  : 
; 550  : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 551  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadSBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_shift$ = -12						; size = 4
_i$ = -8						; size = 4
_fReturn$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadBitAngle PROC

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 523  : 	float	fReturn, shift;
; 524  : 	int	i;
; 525  : 
; 526  : 	shift = (float)( 1 << numbits );

	mov	eax, 1
	mov	ecx, DWORD PTR _numbits$[ebp]
	shl	eax, cl
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _shift$[ebp], xmm0

; 527  : 
; 528  : 	i = MSG_ReadUBitLong( sb, numbits );

	mov	ecx, DWORD PTR _numbits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _i$[ebp], eax

; 529  : 	fReturn = (float)i * ( 360.0f / shift );

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR __real@43b40000
	divss	xmm1, DWORD PTR _shift$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _fReturn$[ebp], xmm0

; 530  : 
; 531  : 	// clamp the finale angle
; 532  : 	if( fReturn < -180.0f ) fReturn += 360.0f; 

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _fReturn$[ebp]
	jbe	SHORT $LN2@MSG_ReadBi
	movss	xmm0, DWORD PTR _fReturn$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fReturn$[ebp], xmm0
	jmp	SHORT $LN4@MSG_ReadBi
$LN2@MSG_ReadBi:

; 533  : 	else if( fReturn > 180.0f ) fReturn -= 360.0f;

	movss	xmm0, DWORD PTR _fReturn$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN4@MSG_ReadBi
	movss	xmm0, DWORD PTR _fReturn$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fReturn$[ebp], xmm0
$LN4@MSG_ReadBi:

; 534  : 
; 535  : 	return fReturn;

	fld	DWORD PTR _fReturn$[ebp]

; 536  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBitAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv93 = -12						; size = 4
_pOut$ = -8						; size = 4
_nBitsLeft$ = -4					; size = 4
_sb$ = 8						; size = 4
_pOutData$ = 12						; size = 4
_nBits$ = 16						; size = 4
_MSG_ReadBits PROC

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 485  : 	byte	*pOut = (byte *)pOutData;

	mov	eax, DWORD PTR _pOutData$[ebp]
	mov	DWORD PTR _pOut$[ebp], eax

; 486  : 	int	nBitsLeft = nBits;

	mov	ecx, DWORD PTR _nBits$[ebp]
	mov	DWORD PTR _nBitsLeft$[ebp], ecx
$LN2@MSG_ReadBi:

; 487  : 	
; 488  : 	// get output dword-aligned.
; 489  : 	while((( dword )pOut & 3) != 0 && nBitsLeft >= 8 )

	mov	edx, DWORD PTR _pOut$[ebp]
	and	edx, 3
	je	SHORT $LN4@MSG_ReadBi
	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN4@MSG_ReadBi

; 490  : 	{
; 491  : 		*pOut = (byte)MSG_ReadUBitLong( sb, 8 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	BYTE PTR [ecx], al

; 492  : 		++pOut;

	mov	edx, DWORD PTR _pOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pOut$[ebp], edx

; 493  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 494  : 	}

	jmp	SHORT $LN2@MSG_ReadBi
$LN4@MSG_ReadBi:

; 495  : 
; 496  : 	// read dwords.
; 497  : 	while( nBitsLeft >= 32 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 32		; 00000020H
	jl	SHORT $LN6@MSG_ReadBi

; 498  : 	{
; 499  : 		*((dword *)pOut) = MSG_ReadUBitLong( sb, 32 );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	edx, DWORD PTR _pOut$[ebp]
	mov	DWORD PTR [edx], eax

; 500  : 		pOut += sizeof( dword );

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 4
	mov	DWORD PTR _pOut$[ebp], eax

; 501  : 		nBitsLeft -= 32;

	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR _nBitsLeft$[ebp], ecx

; 502  : 	}

	jmp	SHORT $LN4@MSG_ReadBi
$LN6@MSG_ReadBi:

; 503  : 
; 504  : 	// read the remaining bytes.
; 505  : 	while( nBitsLeft >= 8 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN7@MSG_ReadBi

; 506  : 	{
; 507  : 		*pOut = MSG_ReadUBitLong( sb, 8 );

	push	8
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	BYTE PTR [ecx], al

; 508  : 		++pOut;

	mov	edx, DWORD PTR _pOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pOut$[ebp], edx

; 509  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 510  : 	}

	jmp	SHORT $LN6@MSG_ReadBi
$LN7@MSG_ReadBi:

; 511  : 	
; 512  : 	// read the remaining bits.
; 513  : 	if( nBitsLeft )

	cmp	DWORD PTR _nBitsLeft$[ebp], 0
	je	SHORT $LN8@MSG_ReadBi

; 514  : 	{
; 515  : 		*pOut = MSG_ReadUBitLong( sb, nBitsLeft );

	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	BYTE PTR [ecx], al
$LN8@MSG_ReadBi:

; 516  : 	}
; 517  : 
; 518  : 	return !sb->bOverflow;

	mov	edx, DWORD PTR _sb$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN10@MSG_ReadBi
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN11@MSG_ReadBi
$LN10@MSG_ReadBi:
	mov	DWORD PTR tv93[ebp], 0
$LN11@MSG_ReadBi:
	mov	eax, DWORD PTR tv93[ebp]

; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_byte$ = -12						; size = 4
_bit$ = -8						; size = 4
_val$ = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadBitFloat PROC

; 458  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 459  : 	long	val;
; 460  : 	int	bit, byte;
; 461  : 
; 462  : 	Assert( sizeof( float ) == sizeof( long ));

	push	0
	push	462					; 000001ceH
	push	OFFSET $SG132243
	push	OFFSET $SG132244
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 463  : 	Assert( sizeof( float ) == 4 );

	push	0
	push	463					; 000001cfH
	push	OFFSET $SG132245
	push	OFFSET $SG132246
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 464  : 
; 465  : 	if( MSG_Overflow( sb, 32 ))

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@MSG_ReadBi

; 466  : 		return 0.0f;

	fldz
	jmp	$LN1@MSG_ReadBi
$LN2@MSG_ReadBi:

; 467  : 
; 468  : 	bit = sb->iCurBit & 0x7;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 7
	mov	DWORD PTR _bit$[ebp], edx

; 469  : 	byte = sb->iCurBit >> 3;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	DWORD PTR _byte$[ebp], ecx

; 470  : 
; 471  : 	val = sb->pData[byte] >> bit;

	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _byte$[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	ecx, DWORD PTR _bit$[ebp]
	sar	edx, cl
	mov	DWORD PTR _val$[ebp], edx

; 472  : 	val |= ((int)sb->pData[byte + 1]) << ( 8 - bit );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+1]
	mov	ecx, 8
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 473  : 	val |= ((int)sb->pData[byte + 2]) << ( 16 - bit );

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _byte$[ebp]
	movzx	edx, BYTE PTR [edx+eax+2]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], edx

; 474  : 	val |= ((int)sb->pData[byte + 3]) << ( 24 - bit );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+3]
	mov	ecx, 24					; 00000018H
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 475  : 
; 476  : 	if( bit != 0 )

	cmp	DWORD PTR _bit$[ebp], 0
	je	SHORT $LN3@MSG_ReadBi

; 477  : 		val |= ((int)sb->pData[byte + 4]) << ( 32 - bit );

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _byte$[ebp]
	movzx	edx, BYTE PTR [edx+eax+4]
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], edx
$LN3@MSG_ReadBi:

; 478  : 	sb->iCurBit += 32;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 479  : 
; 480  : 	return *((float *)&val);

	fld	DWORD PTR _val$[ebp]
$LN1@MSG_ReadBi:

; 481  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBitFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_value$1 = -8						; size = 4
tv83 = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadOneBit PROC

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 400  : 	if( !MSG_Overflow( sb, 1 ))

	push	1
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@MSG_ReadOn

; 401  : 	{
; 402  : 		int value = sb->pData[sb->iCurBit >> 3] & (1 << ( sb->iCurBit & 7 ));

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sar	edx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, BYTE PTR [ecx+edx]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	mov	DWORD PTR _value$1[ebp], edx

; 403  : 		sb->iCurBit++;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+12], edx

; 404  : 		return !!value;

	cmp	DWORD PTR _value$1[ebp], 0
	je	SHORT $LN4@MSG_ReadOn
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN5@MSG_ReadOn
$LN4@MSG_ReadOn:
	mov	DWORD PTR tv83[ebp], 0
$LN5@MSG_ReadOn:
	mov	eax, DWORD PTR tv83[ebp]
	jmp	SHORT $LN1@MSG_ReadOn
$LN2@MSG_ReadOn:

; 405  : 	}
; 406  : 	return 0;

	xor	eax, eax
$LN1@MSG_ReadOn:

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadOneBit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetMaxBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetMaxBytes PROC					; COMDAT

; 103  : _inline int MSG_GetMaxBytes( sizebuf_t *sb ) { return sb->nDataBits >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetMaxBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv76 = -4						; size = 4
_sb$ = 8						; size = 4
_pStr$ = 12						; size = 4
_MSG_WriteString PROC

; 384  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 385  : 	if( pStr )

	cmp	DWORD PTR _pStr$[ebp], 0
	je	SHORT $LN5@MSG_WriteS
$LN4@MSG_WriteS:

; 386  : 	{
; 387  : 		do
; 388  : 		{
; 389  : 			MSG_WriteChar( sb, *pStr );

	mov	eax, DWORD PTR _pStr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteChar
	add	esp, 8

; 390  : 			pStr++;

	mov	eax, DWORD PTR _pStr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pStr$[ebp], eax

; 391  : 		} while( *( pStr - 1 ));

	mov	ecx, DWORD PTR _pStr$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	test	edx, edx
	jne	SHORT $LN4@MSG_WriteS

; 392  : 	}

	jmp	SHORT $LN6@MSG_WriteS
$LN5@MSG_WriteS:

; 393  : 	else MSG_WriteChar( sb, 0 );

	push	0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteChar
	add	esp, 8
$LN6@MSG_WriteS:

; 394  : 	
; 395  : 	return !sb->bOverflow;

	mov	ecx, DWORD PTR _sb$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN8@MSG_WriteS
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN9@MSG_WriteS
$LN8@MSG_WriteS:
	mov	DWORD PTR tv76[ebp], 0
$LN9@MSG_WriteS:
	mov	eax, DWORD PTR tv76[ebp]

; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nBytes$ = 16						; size = 4
_MSG_WriteBytes PROC

; 379  : {

	push	ebp
	mov	ebp, esp

; 380  : 	return MSG_WriteBits( sb, pBuf, nBytes << 3 );

	mov	eax, DWORD PTR _nBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 381  : }

	pop	ebp
	ret	0
_MSG_WriteBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_WriteVec3Angles PROC

; 299  : {

	push	ebp
	mov	ebp, esp

; 300  : 	MSG_WriteBitAngle( sb, fa[0], 16 );

	push	16					; 00000010H
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 301  : 	MSG_WriteBitAngle( sb, fa[1], 16 );

	push	16					; 00000010H
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 302  : 	MSG_WriteBitAngle( sb, fa[2], 16 );

	push	16					; 00000010H
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 303  : }

	pop	ebp
	ret	0
_MSG_WriteVec3Angles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_WriteVec3Coord PROC

; 292  : {

	push	ebp
	mov	ebp, esp

; 293  : 	MSG_WriteCoord( sb, fa[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteCoord
	add	esp, 8

; 294  : 	MSG_WriteCoord( sb, fa[1] );

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteCoord
	add	esp, 8

; 295  : 	MSG_WriteCoord( sb, fa[2] );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteCoord
	add	esp, 8

; 296  : }

	pop	ebp
	ret	0
_MSG_WriteVec3Coord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteFloat PROC

; 374  : {

	push	ebp
	mov	ebp, esp

; 375  : 	MSG_WriteBits( sb, &val, sizeof( val ) << 3 );

	push	32					; 00000020H
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 376  : }

	pop	ebp
	ret	0
_MSG_WriteFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv73 = -4						; size = 4
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteCoord PROC

; 284  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 285  : 	// g-cont. we loose precision here but keep old size of coord variable!
; 286  : 	if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 1
	je	SHORT $LN2@MSG_WriteC

; 287  : 		MSG_WriteShort( sb, Q_rint( val ));

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN5@MSG_WriteC
	movss	xmm0, DWORD PTR _val$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN6@MSG_WriteC
$LN5@MSG_WriteC:
	movss	xmm0, DWORD PTR _val$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv73[ebp], edx
$LN6@MSG_WriteC:
	mov	eax, DWORD PTR tv73[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteShort
	add	esp, 8
	jmp	SHORT $LN3@MSG_WriteC
$LN2@MSG_WriteC:

; 288  : 	else MSG_WriteShort( sb, (int)( val * 8.0f ));

	movss	xmm0, DWORD PTR _val$[ebp]
	mulss	xmm0, DWORD PTR __real@41000000
	cvttss2si edx, xmm0
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteShort
	add	esp, 8
$LN3@MSG_WriteC:

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteCoord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteDword PROC

; 369  : {

	push	ebp
	mov	ebp, esp

; 370  : 	MSG_WriteUBitLong( sb, val, sizeof( dword ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 371  : }

	pop	ebp
	ret	0
_MSG_WriteDword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteLong PROC

; 364  : {

	push	ebp
	mov	ebp, esp

; 365  : 	MSG_WriteSBitLong( sb, val, sizeof( long ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 366  : }

	pop	ebp
	ret	0
_MSG_WriteLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteWord PROC

; 359  : {

	push	ebp
	mov	ebp, esp

; 360  : 	MSG_WriteUBitLong( sb, val, sizeof( word ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 361  : }

	pop	ebp
	ret	0
_MSG_WriteWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteShort PROC

; 354  : {

	push	ebp
	mov	ebp, esp

; 355  : 	MSG_WriteSBitLong( sb, val, sizeof(short ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 356  : }

	pop	ebp
	ret	0
_MSG_WriteShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteByte PROC

; 349  : {

	push	ebp
	mov	ebp, esp

; 350  : 	MSG_WriteUBitLong( sb, val, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 351  : }

	pop	ebp
	ret	0
_MSG_WriteByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteChar PROC

; 344  : {

	push	ebp
	mov	ebp, esp

; 345  : 	MSG_WriteSBitLong( sb, val, sizeof( char ) << 3 );

	push	8
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 346  : }

	pop	ebp
	ret	0
_MSG_WriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_cmd$ = 12						; size = 4
_type$ = 16						; size = 4
_name$ = 20						; size = 4
_MSG_WriteCmdExt PROC

; 317  : {

	push	ebp
	mov	ebp, esp

; 318  : #ifdef DEBUG_NET_MESSAGES_SEND
; 319  : 	if( name != NULL )
; 320  : 	{
; 321  : 		// get custom name
; 322  : 		Con_Printf( "^1sv^7 write: %s\n", name );
; 323  : 	}
; 324  : 	else if( type == NS_SERVER )
; 325  : 	{
; 326  : 		if( cmd >= 0 && cmd <= svc_lastmsg )
; 327  : 		{
; 328  : 			// get engine message name
; 329  : 			Con_Printf( "^1sv^7 write: %s\n", svc_strings[cmd] );
; 330  : 		}
; 331  : 	}
; 332  : 	else if( type == NS_CLIENT )
; 333  : 	{
; 334  : 		if( cmd >= 0 && cmd <= clc_lastmsg )
; 335  : 		{
; 336  : 			Con_Printf( "^1cl^7 write: %s\n", clc_strings[cmd] );
; 337  : 		}
; 338  : 	}
; 339  : #endif
; 340  : 	MSG_WriteUBitLong( sb, cmd, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 341  : }

	pop	ebp
	ret	0
_MSG_WriteCmdExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_intVal$ = -4						; size = 4
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteBitFloat PROC

; 306  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 307  : 	long	intVal;
; 308  : 
; 309  : 	Assert( sizeof( long ) == sizeof( float ));

	push	0
	push	309					; 00000135H
	push	OFFSET $SG132128
	push	OFFSET $SG132129
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 310  : 	Assert( sizeof( float ) == 4 );

	push	0
	push	310					; 00000136H
	push	OFFSET $SG132130
	push	OFFSET $SG132131
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 311  : 
; 312  : 	intVal = *((long *)&val );

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _intVal$[ebp], eax

; 313  : 	MSG_WriteUBitLong( sb, intVal, 32 );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _intVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 314  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBitFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv131 = -24						; size = 8
_mask$ = -16						; size = 4
tv95 = -12						; size = 4
_shift$ = -8						; size = 4
_d$ = -4						; size = 4
_sb$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_numbits$ = 16						; size = 4
_MSG_WriteBitAngle PROC

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 267  : 	uint	mask, shift;
; 268  : 	int	d;
; 269  : 
; 270  : 	// clamp the angle before receiving
; 271  : 	fAngle = fmod( fAngle, 360.0f );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _fAngle$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _fAngle$[ebp]

; 272  : 	if( fAngle < 0 ) fAngle += 360.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _fAngle$[ebp]
	jbe	SHORT $LN2@MSG_WriteB
	movss	xmm0, DWORD PTR _fAngle$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fAngle$[ebp], xmm0
$LN2@MSG_WriteB:

; 273  : 
; 274  : 	shift = ( 1 << numbits );

	mov	eax, 1
	mov	ecx, DWORD PTR _numbits$[ebp]
	shl	eax, cl
	mov	DWORD PTR _shift$[ebp], eax

; 275  : 	mask = shift - 1;

	mov	ecx, DWORD PTR _shift$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx

; 276  : 
; 277  : 	d = (int)(( fAngle * shift ) / 360.0f );

	mov	edx, DWORD PTR _shift$[ebp]
	mov	DWORD PTR tv95[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR tv95[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv131[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv131[ebp]
	mulss	xmm0, DWORD PTR _fAngle$[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _d$[ebp], ecx

; 278  : 	d &= mask;

	mov	edx, DWORD PTR _d$[ebp]
	and	edx, DWORD PTR _mask$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 279  : 
; 280  : 	MSG_WriteUBitLong( sb, (uint)d, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBitAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv93 = -12						; size = 4
_pOut$ = -8						; size = 4
_nBitsLeft$ = -4					; size = 4
_sb$ = 8						; size = 4
_pData$ = 12						; size = 4
_nBits$ = 16						; size = 4
_MSG_WriteBits PROC

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 226  : 	byte	*pOut = (byte *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pOut$[ebp], eax

; 227  : 	int	nBitsLeft = nBits;

	mov	ecx, DWORD PTR _nBits$[ebp]
	mov	DWORD PTR _nBitsLeft$[ebp], ecx
$LN2@MSG_WriteB:

; 228  : 
; 229  : 	// get output dword-aligned.
; 230  : 	while((( dword )pOut & 3 ) != 0 && nBitsLeft >= 8 )

	mov	edx, DWORD PTR _pOut$[ebp]
	and	edx, 3
	je	SHORT $LN4@MSG_WriteB
	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN4@MSG_WriteB

; 231  : 	{
; 232  : 		MSG_WriteUBitLong( sb, *pOut, 8 );

	push	8
	mov	eax, DWORD PTR _pOut$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 233  : 
; 234  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 235  : 		++pOut;

	mov	ecx, DWORD PTR _pOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pOut$[ebp], ecx

; 236  : 	}

	jmp	SHORT $LN2@MSG_WriteB
$LN4@MSG_WriteB:

; 237  : 
; 238  : 	// read dwords.
; 239  : 	while( nBitsLeft >= 32 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 32		; 00000020H
	jl	SHORT $LN6@MSG_WriteB

; 240  : 	{
; 241  : 		MSG_WriteUBitLong( sb, *(( dword *)pOut ), 32 );

	push	32					; 00000020H
	mov	edx, DWORD PTR _pOut$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 242  : 
; 243  : 		pOut += sizeof( dword );

	mov	edx, DWORD PTR _pOut$[ebp]
	add	edx, 4
	mov	DWORD PTR _pOut$[ebp], edx

; 244  : 		nBitsLeft -= 32;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 245  : 	}

	jmp	SHORT $LN4@MSG_WriteB
$LN6@MSG_WriteB:

; 246  : 
; 247  : 	// read the remaining bytes.
; 248  : 	while( nBitsLeft >= 8 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN7@MSG_WriteB

; 249  : 	{
; 250  : 		MSG_WriteUBitLong( sb, *pOut, 8 );

	push	8
	mov	ecx, DWORD PTR _pOut$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 251  : 
; 252  : 		nBitsLeft -= 8;

	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _nBitsLeft$[ebp], ecx

; 253  : 		++pOut;

	mov	edx, DWORD PTR _pOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pOut$[ebp], edx

; 254  : 	}

	jmp	SHORT $LN6@MSG_WriteB
$LN7@MSG_WriteB:

; 255  : 	
; 256  : 	// Read the remaining bits.
; 257  : 	if( nBitsLeft )

	cmp	DWORD PTR _nBitsLeft$[ebp], 0
	je	SHORT $LN8@MSG_WriteB

; 258  : 	{
; 259  : 		MSG_WriteUBitLong( sb, *pOut, nBitsLeft );

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOut$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN8@MSG_WriteB:

; 260  : 	}
; 261  : 
; 262  : 	return !sb->bOverflow;

	mov	ecx, DWORD PTR _sb$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN10@MSG_WriteB
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN11@MSG_WriteB
$LN10@MSG_WriteB:
	mov	DWORD PTR tv93[ebp], 0
$LN11@MSG_WriteB:
	mov	eax, DWORD PTR tv93[ebp]

; 263  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_data$ = 12						; size = 4
_numbits$ = 16						; size = 4
_bSigned$ = 20						; size = 4
_MSG_WriteBitLong PROC

; 218  : {

	push	ebp
	mov	ebp, esp

; 219  : 	if( bSigned )

	cmp	DWORD PTR _bSigned$[ebp], 0
	je	SHORT $LN2@MSG_WriteB

; 220  : 		MSG_WriteSBitLong( sb, data, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@MSG_WriteB
$LN2@MSG_WriteB:

; 221  : 	else MSG_WriteUBitLong( sb, (uint)data, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN1@MSG_WriteB:

; 222  : }

	pop	ebp
	ret	0
_MSG_WriteBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_sb$ = 8						; size = 4
_data$ = 12						; size = 4
_numbits$ = 16						; size = 4
_MSG_WriteSBitLong PROC

; 199  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 200  : 	// do we have a valid # of bits to encode with?
; 201  : 	Assert( numbits >= 1 && numbits <= 32 );

	cmp	DWORD PTR _numbits$[ebp], 1
	jl	SHORT $LN5@MSG_WriteS
	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	jg	SHORT $LN5@MSG_WriteS
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@MSG_WriteS
$LN5@MSG_WriteS:
	mov	DWORD PTR tv70[ebp], 0
$LN6@MSG_WriteS:
	push	0
	push	201					; 000000c9H
	push	OFFSET $SG132047
	push	OFFSET $SG132048
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 202  : 
; 203  : 	// NOTE: it does this wierdness here so it's bit-compatible with regular integer data in the buffer.
; 204  : 	// (Some old code writes direct integers right into the buffer).
; 205  : 	if( data < 0 )

	cmp	DWORD PTR _data$[ebp], 0
	jge	SHORT $LN2@MSG_WriteS

; 206  : 	{
; 207  : 		MSG_WriteUBitLong( sb, (uint)( 0x80000000 + data ), numbits - 1 );

	mov	ecx, DWORD PTR _numbits$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	sub	edx, -2147483648			; 80000000H
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 208  : 		MSG_WriteOneBit( sb, 1 );

	push	1
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 209  : 	}

	jmp	SHORT $LN1@MSG_WriteS
$LN2@MSG_WriteS:

; 210  : 	else
; 211  : 	{
; 212  : 		MSG_WriteUBitLong( sb, (uint)data, numbits - 1 );

	mov	edx, DWORD PTR _numbits$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 213  : 		MSG_WriteOneBit( sb, 0 );

	push	0
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@MSG_WriteS:

; 214  : 	}
; 215  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteSBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv90 = -28						; size = 4
tv70 = -24						; size = 4
_nBitsWritten$1 = -20					; size = 4
_nBitsLeft$2 = -16					; size = 4
_iCurBit$3 = -12					; size = 4
_iCurBitMasked$4 = -8					; size = 4
_iDWord$5 = -4						; size = 4
_sb$ = 8						; size = 4
_curData$ = 12						; size = 4
_numbits$ = 16						; size = 4
_MSG_WriteUBitLong PROC

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 152  : 	Assert( numbits >= 0 && numbits <= 32 );

	cmp	DWORD PTR _numbits$[ebp], 0
	jl	SHORT $LN6@MSG_WriteU
	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	jg	SHORT $LN6@MSG_WriteU
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@MSG_WriteU
$LN6@MSG_WriteU:
	mov	DWORD PTR tv70[ebp], 0
$LN7@MSG_WriteU:
	push	0
	push	152					; 00000098H
	push	OFFSET $SG132030
	push	OFFSET $SG132031
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 153  : 
; 154  : 	// bounds checking..
; 155  : 	if(( sb->iCurBit + numbits ) > sb->nDataBits )

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _numbits$[ebp]
	mov	eax, DWORD PTR _sb$[ebp]
	cmp	edx, DWORD PTR [eax+16]
	jle	SHORT $LN2@MSG_WriteU

; 156  : 	{
; 157  : 		sb->bOverflow = true;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx], 1

; 158  : 		sb->iCurBit = sb->nDataBits;

	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+12], ecx

; 159  : 	}

	jmp	$LN1@MSG_WriteU
$LN2@MSG_WriteU:

; 160  : 	else
; 161  : 	{
; 162  : 		int	nBitsLeft = numbits;

	mov	edx, DWORD PTR _numbits$[ebp]
	mov	DWORD PTR _nBitsLeft$2[ebp], edx

; 163  : 		int	iCurBit = sb->iCurBit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iCurBit$3[ebp], ecx

; 164  : 		uint	iDWord = iCurBit >> 5;	// Mask in a dword.

	mov	edx, DWORD PTR _iCurBit$3[ebp]
	sar	edx, 5
	mov	DWORD PTR _iDWord$5[ebp], edx

; 165  : 		dword	iCurBitMasked;
; 166  : 		int	nBitsWritten;
; 167  : 
; 168  : 		Assert(( iDWord * 4 + sizeof( long )) <= (uint)MSG_GetMaxBytes( sb ));

	mov	eax, DWORD PTR _iDWord$5[ebp]
	lea	esi, DWORD PTR [eax*4+4]
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	esi, eax
	ja	SHORT $LN8@MSG_WriteU
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN9@MSG_WriteU
$LN8@MSG_WriteU:
	mov	DWORD PTR tv90[ebp], 0
$LN9@MSG_WriteU:
	push	0
	push	168					; 000000a8H
	push	OFFSET $SG132034
	push	OFFSET $SG132035
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 169  : 
; 170  : 		iCurBitMasked = iCurBit & 31;

	mov	eax, DWORD PTR _iCurBit$3[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _iCurBitMasked$4[ebp], eax

; 171  : 		((dword *)sb->pData)[iDWord] &= BitWriteMasks[iCurBitMasked][nBitsLeft];

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR _iCurBitMasked$4[ebp], 132
	mov	ecx, DWORD PTR _iDWord$5[ebp]
	mov	esi, DWORD PTR _nBitsLeft$2[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	and	edx, DWORD PTR _BitWriteMasks[eax+esi*4]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iDWord$5[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 172  : 		((dword *)sb->pData)[iDWord] |= curData << iCurBitMasked;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _curData$[ebp]
	mov	ecx, DWORD PTR _iCurBitMasked$4[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iDWord$5[ebp]
	or	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$5[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 173  : 
; 174  : 		// did it span a dword?
; 175  : 		nBitsWritten = 32 - iCurBitMasked;

	mov	eax, 32					; 00000020H
	sub	eax, DWORD PTR _iCurBitMasked$4[ebp]
	mov	DWORD PTR _nBitsWritten$1[ebp], eax

; 176  : 
; 177  : 		if( nBitsWritten < nBitsLeft )

	mov	ecx, DWORD PTR _nBitsWritten$1[ebp]
	cmp	ecx, DWORD PTR _nBitsLeft$2[ebp]
	jge	SHORT $LN4@MSG_WriteU

; 178  : 		{
; 179  : 			nBitsLeft -= nBitsWritten;

	mov	edx, DWORD PTR _nBitsLeft$2[ebp]
	sub	edx, DWORD PTR _nBitsWritten$1[ebp]
	mov	DWORD PTR _nBitsLeft$2[ebp], edx

; 180  : 			iCurBit += nBitsWritten;

	mov	eax, DWORD PTR _iCurBit$3[ebp]
	add	eax, DWORD PTR _nBitsWritten$1[ebp]
	mov	DWORD PTR _iCurBit$3[ebp], eax

; 181  : 			curData >>= nBitsWritten;

	mov	edx, DWORD PTR _curData$[ebp]
	mov	ecx, DWORD PTR _nBitsWritten$1[ebp]
	shr	edx, cl
	mov	DWORD PTR _curData$[ebp], edx

; 182  : 
; 183  : 			iCurBitMasked = iCurBit & 31;

	mov	eax, DWORD PTR _iCurBit$3[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _iCurBitMasked$4[ebp], eax

; 184  : 			((dword *)sb->pData)[iDWord+1] &= BitWriteMasks[iCurBitMasked][nBitsLeft];

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR _iCurBitMasked$4[ebp], 132
	mov	ecx, DWORD PTR _iDWord$5[ebp]
	mov	esi, DWORD PTR _nBitsLeft$2[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+4]
	and	edx, DWORD PTR _BitWriteMasks[eax+esi*4]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iDWord$5[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 185  : 			((dword *)sb->pData)[iDWord+1] |= curData << iCurBitMasked;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _curData$[ebp]
	mov	ecx, DWORD PTR _iCurBitMasked$4[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iDWord$5[ebp]
	or	eax, DWORD PTR [edx+ecx*4+4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$5[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax
$LN4@MSG_WriteU:

; 186  : 		}
; 187  : 		sb->iCurBit += numbits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN1@MSG_WriteU:

; 188  : 	}
; 189  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteUBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_nValue$ = 12						; size = 4
_MSG_WriteOneBit PROC

; 140  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 141  : 	if( !MSG_Overflow( sb, 1 ))

	push	1
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8
	test	eax, eax
	jne	$LN1@MSG_WriteO

; 142  : 	{
; 143  : 		if( nValue ) sb->pData[sb->iCurBit>>3] |= BIT( sb->iCurBit & 7 );

	cmp	DWORD PTR _nValue$[ebp], 0
	je	SHORT $LN3@MSG_WriteO
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sar	edx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, 7
	mov	esi, 1
	shl	esi, cl
	movzx	edx, BYTE PTR [eax+edx]
	or	edx, esi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN4@MSG_WriteO
$LN3@MSG_WriteO:

; 144  : 		else sb->pData[sb->iCurBit>>3] &= ~BIT( sb->iCurBit & 7 );

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sar	edx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, 7
	mov	esi, 1
	shl	esi, cl
	not	esi
	movzx	edx, BYTE PTR [eax+edx]
	and	edx, esi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
$LN4@MSG_WriteO:

; 145  : 
; 146  : 		sb->iCurBit++;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN1@MSG_WriteO:

; 147  : 	}
; 148  : }

	pop	esi
	pop	ebp
	ret	0
_MSG_WriteOneBit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_Clear PROC

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   : 	sb->iCurBit = 0;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+12], 0

; 94   : 	sb->bOverflow = false;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx], 0

; 95   : }

	pop	ebp
	ret	0
_MSG_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv83 = -8						; size = 4
tv70 = -4						; size = 4
_sb$ = 8						; size = 4
_pData$ = 12						; size = 4
_nBytes$ = 16						; size = 4
_iStartBit$ = 20					; size = 4
_nBits$ = 24						; size = 4
_MSG_StartWriting PROC

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 64   : 	// make sure it's dword aligned and padded.
; 65   : 	Assert(((dword)pData & 3 ) == 0 );

	mov	eax, DWORD PTR _pData$[ebp]
	and	eax, 3
	jne	SHORT $LN5@MSG_StartW
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@MSG_StartW
$LN5@MSG_StartW:
	mov	DWORD PTR tv70[ebp], 0
$LN6@MSG_StartW:
	push	0
	push	65					; 00000041H
	push	OFFSET $SG131961
	push	OFFSET $SG131962
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 66   : 
; 67   : 	sb->pDebugName = "Unnamed";

	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+4], OFFSET $SG131963

; 68   : 	sb->pData = (byte *)pData;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 69   : 
; 70   : 	if( nBits == -1 )

	cmp	DWORD PTR _nBits$[ebp], -1
	jne	SHORT $LN2@MSG_StartW

; 71   : 	{
; 72   : 		sb->nDataBits = nBytes << 3;

	mov	edx, DWORD PTR _nBytes$[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+16], edx

; 73   : 	}

	jmp	SHORT $LN3@MSG_StartW
$LN2@MSG_StartW:

; 74   : 	else
; 75   : 	{
; 76   : 		Assert( nBits <= nBytes * 8 );

	mov	ecx, DWORD PTR _nBytes$[ebp]
	shl	ecx, 3
	cmp	DWORD PTR _nBits$[ebp], ecx
	jg	SHORT $LN7@MSG_StartW
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN8@MSG_StartW
$LN7@MSG_StartW:
	mov	DWORD PTR tv83[ebp], 0
$LN8@MSG_StartW:
	push	0
	push	76					; 0000004cH
	push	OFFSET $SG131966
	push	OFFSET $SG131967
	mov	edx, DWORD PTR tv83[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 77   : 		sb->nDataBits = nBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _nBits$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN3@MSG_StartW:

; 78   : 	}
; 79   : 
; 80   : 	sb->iCurBit = iStartBit;

	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR _iStartBit$[ebp]
	mov	DWORD PTR [edx+12], eax

; 81   : 	sb->bOverflow = false;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx], 0

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_StartWriting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_swap$ = 8						; size = 2
_MSG_BigShort PROC

; 31   : {

	push	ebp
	mov	ebp, esp

; 32   : 	return (swap >> 8)|(swap << 8);

	movsx	eax, WORD PTR _swap$[ebp]
	sar	eax, 8
	movsx	ecx, WORD PTR _swap$[ebp]
	shl	ecx, 8
	or	eax, ecx

; 33   : }

	pop	ebp
	ret	0
_MSG_BigShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_CheckOverflow PROC

; 105  : {

	push	ebp
	mov	ebp, esp

; 106  : 	return MSG_Overflow( sb, 0 );

	push	0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8

; 107  : }

	pop	ebp
	ret	0
_MSG_CheckOverflow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_temp$ = -32						; size = 20
_remaining_to_end$ = -12				; size = 4
_endbit$ = -8						; size = 4
_i$ = -4						; size = 4
_sb$ = 8						; size = 4
_startbit$ = 12						; size = 4
_bitstoremove$ = 16					; size = 4
_MSG_ExciseBits PROC

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 673  : 	int	i, endbit = startbit + bitstoremove;

	mov	eax, DWORD PTR _startbit$[ebp]
	add	eax, DWORD PTR _bitstoremove$[ebp]
	mov	DWORD PTR _endbit$[ebp], eax

; 674  : 	int	remaining_to_end = sb->nDataBits - endbit;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR _endbit$[ebp]
	mov	DWORD PTR _remaining_to_end$[ebp], edx

; 675  : 	sizebuf_t	temp;
; 676  : 
; 677  : 	MSG_StartWriting( &temp, sb->pData, MSG_GetMaxBytes( sb ), startbit, -1 );

	push	-1
	mov	eax, DWORD PTR _startbit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_MSG_StartWriting
	add	esp, 20					; 00000014H

; 678  : 	MSG_SeekToBit( sb, endbit, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _endbit$[ebp]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 679  : 
; 680  : 	for( i = 0; i < remaining_to_end; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MSG_Excise
$LN2@MSG_Excise:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@MSG_Excise:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _remaining_to_end$[ebp]
	jge	SHORT $LN3@MSG_Excise

; 681  : 	{
; 682  : 		MSG_WriteOneBit( &temp, MSG_ReadOneBit( sb ));

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 683  : 	}

	jmp	SHORT $LN2@MSG_Excise
$LN3@MSG_Excise:

; 684  : 
; 685  : 	MSG_SeekToBit( sb, startbit, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _startbit$[ebp]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 686  : 	sb->nDataBits -= bitstoremove;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR _bitstoremove$[ebp]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+16], edx

; 687  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ExciseBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_sb$ = 8						; size = 4
_bitPos$ = 12						; size = 4
_whence$ = 16						; size = 4
_MSG_SeekToBit PROC

; 110  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 111  : 	// compute the file offset
; 112  : 	switch( whence )

	mov	eax, DWORD PTR _whence$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN5@MSG_SeekTo
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN4@MSG_SeekTo
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN6@MSG_SeekTo
	jmp	SHORT $LN7@MSG_SeekTo
$LN4@MSG_SeekTo:

; 113  : 	{
; 114  : 	case SEEK_CUR:
; 115  : 		bitPos += sb->iCurBit;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR _bitPos$[ebp]
	add	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _bitPos$[ebp], edx

; 116  : 		break;

	jmp	SHORT $LN2@MSG_SeekTo
$LN5@MSG_SeekTo:

; 117  : 	case SEEK_SET:
; 118  : 		break;

	jmp	SHORT $LN2@MSG_SeekTo
$LN6@MSG_SeekTo:

; 119  : 	case SEEK_END:
; 120  : 		bitPos += sb->nDataBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _bitPos$[ebp]
	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _bitPos$[ebp], ecx

; 121  : 		break;

	jmp	SHORT $LN2@MSG_SeekTo
$LN7@MSG_SeekTo:

; 122  : 	default: 
; 123  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@MSG_SeekTo
$LN2@MSG_SeekTo:

; 124  : 	}
; 125  : 
; 126  : 	if( bitPos < 0 || bitPos > sb->nDataBits )

	cmp	DWORD PTR _bitPos$[ebp], 0
	jl	SHORT $LN9@MSG_SeekTo
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR _bitPos$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jle	SHORT $LN8@MSG_SeekTo
$LN9@MSG_SeekTo:

; 127  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@MSG_SeekTo
$LN8@MSG_SeekTo:

; 128  : 
; 129  : 	sb->iCurBit = bitPos;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR _bitPos$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 130  : 
; 131  : 	return 0;

	xor	eax, eax
$LN1@MSG_SeekTo:

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_SeekToBit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_endbit$ = -16						; size = 4
_maskBit$ = -12						; size = 4
_nBitsLeft$ = -8					; size = 4
_startbit$ = -4						; size = 4
_MSG_InitMasks PROC

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	uint	startbit, endbit;
; 38   : 	uint	maskBit, nBitsLeft;
; 39   : 
; 40   : 	for( startbit = 0; startbit < 32; startbit++ )

	mov	DWORD PTR _startbit$[ebp], 0
	jmp	SHORT $LN4@MSG_InitMa
$LN2@MSG_InitMa:
	mov	eax, DWORD PTR _startbit$[ebp]
	add	eax, 1
	mov	DWORD PTR _startbit$[ebp], eax
$LN4@MSG_InitMa:
	cmp	DWORD PTR _startbit$[ebp], 32		; 00000020H
	jae	SHORT $LN3@MSG_InitMa

; 41   : 	{
; 42   : 		for( nBitsLeft = 0; nBitsLeft < 33; nBitsLeft++ )

	mov	DWORD PTR _nBitsLeft$[ebp], 0
	jmp	SHORT $LN7@MSG_InitMa
$LN5@MSG_InitMa:
	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nBitsLeft$[ebp], ecx
$LN7@MSG_InitMa:
	cmp	DWORD PTR _nBitsLeft$[ebp], 33		; 00000021H
	jae	SHORT $LN6@MSG_InitMa

; 43   : 		{
; 44   : 			endbit = startbit + nBitsLeft;

	mov	edx, DWORD PTR _startbit$[ebp]
	add	edx, DWORD PTR _nBitsLeft$[ebp]
	mov	DWORD PTR _endbit$[ebp], edx

; 45   : 
; 46   : 			BitWriteMasks[startbit][nBitsLeft] = (uint)BIT( startbit ) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _startbit$[ebp]
	shl	eax, cl
	sub	eax, 1
	imul	ecx, DWORD PTR _startbit$[ebp], 132
	mov	edx, DWORD PTR _nBitsLeft$[ebp]
	mov	DWORD PTR _BitWriteMasks[ecx+edx*4], eax

; 47   : 			if( endbit < 32 ) BitWriteMasks[startbit][nBitsLeft] |= ~((uint)BIT( endbit ) - 1 );

	cmp	DWORD PTR _endbit$[ebp], 32		; 00000020H
	jae	SHORT $LN11@MSG_InitMa
	imul	eax, DWORD PTR _startbit$[ebp], 132
	mov	edx, 1
	mov	ecx, DWORD PTR _endbit$[ebp]
	shl	edx, cl
	sub	edx, 1
	not	edx
	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	or	edx, DWORD PTR _BitWriteMasks[eax+ecx*4]
	imul	eax, DWORD PTR _startbit$[ebp], 132
	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	mov	DWORD PTR _BitWriteMasks[eax+ecx*4], edx
$LN11@MSG_InitMa:

; 48   : 		}

	jmp	SHORT $LN5@MSG_InitMa
$LN6@MSG_InitMa:

; 49   : 	}

	jmp	$LN2@MSG_InitMa
$LN3@MSG_InitMa:

; 50   : 
; 51   : 	for( maskBit = 0; maskBit < 32; maskBit++ )

	mov	DWORD PTR _maskBit$[ebp], 0
	jmp	SHORT $LN10@MSG_InitMa
$LN8@MSG_InitMa:
	mov	edx, DWORD PTR _maskBit$[ebp]
	add	edx, 1
	mov	DWORD PTR _maskBit$[ebp], edx
$LN10@MSG_InitMa:
	cmp	DWORD PTR _maskBit$[ebp], 32		; 00000020H
	jae	SHORT $LN1@MSG_InitMa

; 52   : 		ExtraMasks[maskBit] = (uint)BIT( maskBit ) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _maskBit$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR _maskBit$[ebp]
	mov	DWORD PTR _ExtraMasks[ecx*4], eax
	jmp	SHORT $LN8@MSG_InitMa
$LN1@MSG_InitMa:

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_InitMasks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.c
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_pDebugName$ = 12					; size = 4
_pData$ = 16						; size = 4
_nBytes$ = 20						; size = 4
_nMaxBits$ = 24						; size = 4
_MSG_InitExt PROC

; 56   : {

	push	ebp
	mov	ebp, esp

; 57   : 	MSG_StartWriting( sb, pData, nBytes, 0, nMaxBits );

	mov	eax, DWORD PTR _nMaxBits$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _nBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_StartWriting
	add	esp, 20					; 00000014H

; 58   : 
; 59   : 	sb->pDebugName = pDebugName;

	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR _pDebugName$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 60   : }

	pop	ebp
	ret	0
_MSG_InitExt ENDP
_TEXT	ENDS
END
