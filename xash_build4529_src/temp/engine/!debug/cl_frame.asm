; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\cl_frame.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_CL_ExtraUpdate
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_CL_EDICT_NUM
PUBLIC	_CL_ParsePacketEntities
PUBLIC	_CL_AddVisibleEntity
PUBLIC	_CL_ResetLatchedVars
PUBLIC	_CL_GetEntitySpatialization
PUBLIC	_CL_GetMovieSpatialization
PUBLIC	_CL_ProcessPlayerState
PUBLIC	_CL_ComputePlayerOrigin
PUBLIC	_CL_ProcessPacket
PUBLIC	_CL_MoveThirdpersonCamera
PUBLIC	_CL_IsPlayerIndex
PUBLIC	_CL_EmitEntities
PUBLIC	_CL_UpdatePositions
PUBLIC	_CL_ResetPositions
PUBLIC	_CL_EntityTeleported
PUBLIC	_CL_CompareTimestamps
PUBLIC	_CL_EntityIgnoreLerp
PUBLIC	_CL_EntityCustomLerp
PUBLIC	_CL_ParametricMove
PUBLIC	_CL_UpdateLatchedVars
PUBLIC	_CL_ProcessEntityUpdate
PUBLIC	_CL_FindInterpolationUpdates
PUBLIC	_CL_PureOrigin
PUBLIC	_CL_InterpolateModel
PUBLIC	_CL_ResetLatchedState
PUBLIC	_CL_FlushEntityPacket
PUBLIC	_CL_DeltaEntity
PUBLIC	_CL_LinkCustomEntity
PUBLIC	_CL_LinkPlayers
PUBLIC	_CL_LinkPacketEntities
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@447a0000
PUBLIC	__real@c0400000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_COM_NormalizeAngles:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_CL_IsThirdPerson:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_sqrt:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_AngleQuaternion:PROC
EXTRN	_QuaternionAngle:PROC
EXTRN	_QuaternionSlerp:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_CL_RunLightStyles:PROC
EXTRN	_CL_DecayLights:PROC
EXTRN	_CL_UpdateFrameLerp:PROC
EXTRN	_CL_SignonReply:PROC
EXTRN	_CL_WriteDemoJumpTime:PROC
EXTRN	_CL_FireEvents:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_GetLocalPlayer:PROC
EXTRN	_CL_SetSolidEntities:PROC
EXTRN	_CL_CheckPredictionError:PROC
EXTRN	_CL_MoveSpectatorCamera:PROC
EXTRN	_CL_SetIdealPitch:PROC
EXTRN	_CL_TestLights:PROC
EXTRN	_CL_TempEntUpdate:PROC
EXTRN	_CL_AddCustomBeam:PROC
EXTRN	_CL_KillDeadBeams:PROC
EXTRN	_S_ExtraUpdate:PROC
EXTRN	_MSG_ReadDeltaEntity:PROC
EXTRN	_R_ClearScene:PROC
EXTRN	_R_StudioLerpMovement:PROC
EXTRN	_CL_GetStudioEstimatedFrame:PROC
EXTRN	_R_AddEntity:PROC
EXTRN	_CL_AddEntityEffects:PROC
EXTRN	_CL_AddModelEffects:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_interp:DWORD
EXTRN	_cl_bmodelinterp:DWORD
EXTRN	_RI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
$SG145650 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG145563 DB	'CL_FlushEntityPacket: overflow', 0aH, 00H
$SG145589 DB	'^1Error:^7 CL_DeltaEntity: invalid newnum: %d', 0aH, 00H
	ORG $+1
$SG145626 DB	'^3Warning:^1 update too old', 0aH, '^7', 0aH, 00H
$SG145628 DB	'^3Warning:^1 delta frame is too old^7', 0aH, 00H
	ORG $+1
$SG145630 DB	'^3Warning:^1 delta frame is too old^7', 0aH, 00H
	ORG $+1
$SG145637 DB	'CL_ParsePacketEntities: overflow', 0aH, 00H
	ORG $+2
$SG145649 DB	'Delta', 00H
	ORG $+2
$SG145651 DB	'^3Warning:^7 CL_Parse%sPacketEntities: (%i should be %i)'
	DB	0aH, 00H
	ORG $+2
$SG145679 DB	'^3Warning:^7 bad model on beam ( %s )', 0aH, 00H
	ORG $+1
$SG145719 DB	'^1Error:^7 CL_LinkPacketEntity: bad entity %i', 0aH, 00H
_DATA	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
_DATA	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_interpolate$ = -24					; size = 4
_parametric$ = -20					; size = 4
tv140 = -16						; size = 4
_i$ = -12						; size = 4
_state$ = -8						; size = 4
_ent$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_LinkPacketEntities PROC

; 1075 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 1076 : 	cl_entity_t	*ent;
; 1077 : 	entity_state_t	*state;
; 1078 : 	qboolean		parametric;
; 1079 : 	qboolean		interpolate;
; 1080 : 	int		i;
; 1081 : 
; 1082 : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_LinkPac
$LN2@CL_LinkPac:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_LinkPac:
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+17296]
	jge	$LN3@CL_LinkPac

; 1083 : 	{
; 1084 : 		state = &cls.packet_entities[(frame->first_entity + i) % cls.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+17300]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _cls+291764
	mov	DWORD PTR _state$[ebp], ecx

; 1085 : 
; 1086 : 		// clients are should be done in CL_LinkPlayers
; 1087 : 		if( state->number >= 1 && state->number <= cl.maxclients )

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jl	SHORT $LN5@CL_LinkPac
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _cl+1568832
	jg	SHORT $LN5@CL_LinkPac

; 1088 : 			continue;

	jmp	SHORT $LN2@CL_LinkPac
$LN5@CL_LinkPac:

; 1089 : 
; 1090 : 		// if set to invisible, skip
; 1091 : 		if( !state->modelindex || FBitSet( state->effects, EF_NODRAW ))

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN7@CL_LinkPac
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 128				; 00000080H
	je	SHORT $LN6@CL_LinkPac
$LN7@CL_LinkPac:

; 1092 : 			continue;

	jmp	SHORT $LN2@CL_LinkPac
$LN6@CL_LinkPac:

; 1093 : 
; 1094 : 		ent = CL_GetEntityByIndex( state->number );

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1095 : 
; 1096 : 		if( !ent )

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN8@CL_LinkPac

; 1097 : 		{
; 1098 : 			Con_Reportf( S_ERROR "CL_LinkPacketEntity: bad entity %i\n", state->number );

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET $SG145719
	call	_Con_Reportf
	add	esp, 8

; 1099 : 			continue;

	jmp	$LN2@CL_LinkPac
$LN8@CL_LinkPac:

; 1100 : 		}
; 1101 : 
; 1102 : 		// animtime must keep an actual
; 1103 : 		ent->curstate.animtime = state->animtime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+780], edx

; 1104 : 		ent->curstate.frame = state->frame;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+736], edx

; 1105 : 		interpolate = false;

	mov	DWORD PTR _interpolate$[ebp], 0

; 1106 : 
; 1107 : 		if( !ent->model ) continue;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	jne	SHORT $LN9@CL_LinkPac
	jmp	$LN2@CL_LinkPac
$LN9@CL_LinkPac:

; 1108 : 
; 1109 : 		if( ent->curstate.rendermode == kRenderNormal )

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+760], 0
	jne	SHORT $LN11@CL_LinkPac

; 1110 : 		{
; 1111 : 			// auto 'solid' faces
; 1112 : 			if( FBitSet( ent->model->flags, MODEL_TRANSPARENT ) && CL_IsQuakeCompatible( ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 8
	je	SHORT $LN11@CL_LinkPac
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN11@CL_LinkPac

; 1113 : 			{
; 1114 : 				ent->curstate.rendermode = kRenderTransAlpha;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+760], 4

; 1115 : 				ent->curstate.renderamt = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+764], 255		; 000000ffH
$LN11@CL_LinkPac:

; 1116 : 			}
; 1117 : 		}
; 1118 : 
; 1119 : 		parametric = ( ent->curstate.impacttime != 0.0f && ent->curstate.starttime != 0.0f );

	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+940]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@CL_LinkPac
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+944]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@CL_LinkPac
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN42@CL_LinkPac
$LN41@CL_LinkPac:
	mov	DWORD PTR tv140[ebp], 0
$LN42@CL_LinkPac:
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR _parametric$[ebp], eax

; 1120 : 
; 1121 : 		if( !parametric && ent->curstate.movetype != MOVETYPE_COMPOUND )

	cmp	DWORD PTR _parametric$[ebp], 0
	jne	$LN20@CL_LinkPac
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+776], 14			; 0000000eH
	je	$LN20@CL_LinkPac

; 1122 : 		{
; 1123 : 			if( ent->curstate.animtime == ent->prevstate.animtime && !VectorCompare( ent->curstate.origin, ent->prevstate.origin ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+780]
	ucomiss	xmm0, DWORD PTR [eax+440]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@CL_LinkPac
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+704]
	ucomiss	xmm0, DWORD PTR [esi+ecx+364]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_LinkPac
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+704]
	ucomiss	xmm0, DWORD PTR [esi+edx+364]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_LinkPac
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+704]
	ucomiss	xmm0, DWORD PTR [esi+edx+364]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@CL_LinkPac
$LN14@CL_LinkPac:

; 1124 : 				ent->lastmove = cl.time + 0.2;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fc999999999999a
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+2884], xmm0
$LN13@CL_LinkPac:

; 1125 : 
; 1126 : 			if( FBitSet( ent->curstate.eflags, EFLAG_SLERP ))

	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+756]
	and	eax, 1
	je	$LN20@CL_LinkPac

; 1127 : 			{
; 1128 : 				if( ent->curstate.animtime != 0.0f && ( ent->model->type == mod_alias || ent->model->type == mod_studio ))

	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+780]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN20@CL_LinkPac
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	cmp	DWORD PTR [eax+68], 2
	je	SHORT $LN17@CL_LinkPac
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 3
	jne	$LN20@CL_LinkPac
$LN17@CL_LinkPac:

; 1129 : 				{
; 1130 : #ifdef STUDIO_INTERPOLATION_FIX
; 1131 : 					if( ent->lastmove >= cl.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+2884]
	comisd	xmm0, QWORD PTR _cl+1525848
	jb	SHORT $LN18@CL_LinkPac

; 1132 : 						VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [eax+ecx+2844], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2844], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2844], ecx
$LN18@CL_LinkPac:

; 1133 : 					if( FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP ))

	mov	edx, DWORD PTR _host+34748
	and	edx, 128				; 00000080H
	je	SHORT $LN19@CL_LinkPac

; 1134 : 						interpolate = true;

	mov	DWORD PTR _interpolate$[ebp], 1
	jmp	SHORT $LN20@CL_LinkPac
$LN19@CL_LinkPac:

; 1135 : 					else ent->curstate.movetype = MOVETYPE_STEP;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+776], 4
$LN20@CL_LinkPac:

; 1136 : #else
; 1137 : 					if( ent->lastmove >= cl.time )
; 1138 : 					{
; 1139 : 						CL_ResetLatchedVars( ent, true );
; 1140 : 						VectorCopy( ent->curstate.origin, ent->latched.prevorigin );
; 1141 : 						VectorCopy( ent->curstate.angles, ent->latched.prevangles );
; 1142 : 
; 1143 : 						// disable step interpolation in client.dll
; 1144 : 						ent->curstate.movetype = MOVETYPE_NONE;
; 1145 : 					}
; 1146 : 					else
; 1147 : 					{
; 1148 : 						// restore step interpolation in client.dll
; 1149 : 						ent->curstate.movetype = MOVETYPE_STEP;
; 1150 : 					}
; 1151 : #endif
; 1152 : 				}
; 1153 : 			}
; 1154 : 		}
; 1155 : 
; 1156 : 		if( ent->model->type == mod_brush )

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 0
	jne	SHORT $LN21@CL_LinkPac

; 1157 : 		{
; 1158 : 			CL_InterpolateModel( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_InterpolateModel
	add	esp, 4

; 1159 : 		}

	jmp	$LN32@CL_LinkPac
$LN21@CL_LinkPac:

; 1160 : 		else
; 1161 : 		{
; 1162 : 			if( parametric )

	cmp	DWORD PTR _parametric$[ebp], 0
	je	$LN23@CL_LinkPac

; 1163 : 			{
; 1164 : 				CL_ParametricMove( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_ParametricMove
	add	esp, 4

; 1165 : 
; 1166 : 				VectorCopy( ent->curstate.origin, ent->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [ecx+edx+2888], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2888], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2888], edx

; 1167 : 				VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [edx+eax+2900], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2900], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2900], eax

; 1168 : 			}

	jmp	$LN29@CL_LinkPac
$LN23@CL_LinkPac:

; 1169 : 			else if( CL_EntityCustomLerp( ent ))

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_EntityCustomLerp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@CL_LinkPac

; 1170 : 			{
; 1171 : 				if ( !CL_InterpolateModel( ent ))

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_InterpolateModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN27@CL_LinkPac

; 1172 : 					continue;

	jmp	$LN2@CL_LinkPac
$LN27@CL_LinkPac:

; 1173 : 			}

	jmp	$LN29@CL_LinkPac
$LN25@CL_LinkPac:

; 1174 : 			else if( ent->curstate.movetype == MOVETYPE_STEP && !NET_IsLocalAddress( cls.netchan.remote_address ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+776], 4
	jne	SHORT $LN28@CL_LinkPac
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _cls+23524
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _cls+23528
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _cls+23532
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _cls+23536
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _cls+23540
	mov	DWORD PTR [ecx+16], edx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN28@CL_LinkPac

; 1175 : 			{
; 1176 : 				if( !CL_InterpolateModel( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_InterpolateModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN30@CL_LinkPac

; 1177 : 					continue;

	jmp	$LN2@CL_LinkPac
$LN30@CL_LinkPac:

; 1178 : 			}

	jmp	$LN29@CL_LinkPac
$LN28@CL_LinkPac:

; 1179 : 			else
; 1180 : 			{
; 1181 : 				// no interpolation right now
; 1182 : 				VectorCopy( ent->curstate.origin, ent->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [eax+ecx+2888], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2888], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2888], ecx

; 1183 : 				VectorCopy( ent->curstate.angles, ent->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [ecx+edx+2900], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2900], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2900], edx
$LN29@CL_LinkPac:

; 1184 : 			}
; 1185 : 
; 1186 : 			if( ent->model->type == mod_studio )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 3
	jne	SHORT $LN32@CL_LinkPac

; 1187 : 			{
; 1188 : 				if( interpolate && FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP )) 

	cmp	DWORD PTR _interpolate$[ebp], 0
	je	SHORT $LN32@CL_LinkPac
	mov	edx, DWORD PTR _host+34748
	and	edx, 128				; 00000080H
	je	SHORT $LN32@CL_LinkPac

; 1189 : 					R_StudioLerpMovement( ent, cl.time, ent->origin, ent->angles );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 2900				; 00000b54H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 2888				; 00000b48H
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cl+1525848
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_R_StudioLerpMovement
	add	esp, 20					; 00000014H
$LN32@CL_LinkPac:

; 1190 : 			}
; 1191 : 		}
; 1192 : 
; 1193 : 		if( !FBitSet( state->entityType, ENTITY_NORMAL ))

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $LN33@CL_LinkPac

; 1194 : 		{
; 1195 : 			CL_LinkCustomEntity( ent, state );

	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_LinkCustomEntity
	add	esp, 8

; 1196 : 			continue;

	jmp	$LN2@CL_LinkPac
$LN33@CL_LinkPac:

; 1197 : 		}
; 1198 : 
; 1199 : 		if( ent->model->type != mod_brush )

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN35@CL_LinkPac

; 1200 : 		{
; 1201 : 			// NOTE: never pass sprites with rendercolor '0 0 0' it's a stupid Valve Hammer Editor bug
; 1202 : 			if( !ent->curstate.rendercolor.r && !ent->curstate.rendercolor.g && !ent->curstate.rendercolor.b )

	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+768]
	test	ecx, ecx
	jne	SHORT $LN35@CL_LinkPac
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+769]
	test	eax, eax
	jne	SHORT $LN35@CL_LinkPac
	mov	ecx, DWORD PTR _ent$[ebp]
	movzx	edx, BYTE PTR [ecx+770]
	test	edx, edx
	jne	SHORT $LN35@CL_LinkPac

; 1203 : 				ent->curstate.rendercolor.r = ent->curstate.rendercolor.g = ent->curstate.rendercolor.b = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	BYTE PTR [eax+770], 255			; 000000ffH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	BYTE PTR [ecx+769], 255			; 000000ffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	BYTE PTR [edx+768], 255			; 000000ffH
$LN35@CL_LinkPac:

; 1204 : 		}
; 1205 : 
; 1206 : 		// XASH SPECIFIC
; 1207 : 		if( ent->curstate.rendermode == kRenderNormal && ent->curstate.renderfx == kRenderFxNone )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+760], 0
	jne	SHORT $LN36@CL_LinkPac
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+772], 0
	jne	SHORT $LN36@CL_LinkPac

; 1208 : 			ent->curstate.renderamt = 255.0f;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+764], 255		; 000000ffH
$LN36@CL_LinkPac:

; 1209 : 
; 1210 : 		if( ent->curstate.aiment != 0 && ent->curstate.movetype != MOVETYPE_COMPOUND )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+836], 0
	je	SHORT $LN37@CL_LinkPac
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+776], 14			; 0000000eH
	je	SHORT $LN37@CL_LinkPac

; 1211 : 			ent->curstate.movetype = MOVETYPE_FOLLOW;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+776], 12			; 0000000cH
$LN37@CL_LinkPac:

; 1212 : 
; 1213 : 		if( FBitSet( ent->curstate.effects, EF_NOINTERP ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, 32					; 00000020H
	je	SHORT $LN38@CL_LinkPac

; 1214 : 			CL_ResetLatchedVars( ent, false );

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_ResetLatchedVars
	add	esp, 8
$LN38@CL_LinkPac:

; 1215 : 
; 1216 : 		if( CL_EntityTeleported( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_EntityTeleported
	add	esp, 4
	test	eax, eax
	je	$LN39@CL_LinkPac

; 1217 : 		{
; 1218 : 			VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [eax+ecx+2844], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2844], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2844], ecx

; 1219 : 			VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [ecx+edx+2856], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2856], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2856], edx

; 1220 : 			CL_ResetPositions( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetPositions
	add	esp, 4
$LN39@CL_LinkPac:

; 1221 : 		}
; 1222 : 
; 1223 : 		VectorCopy( ent->origin, ent->attachment[0] );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx

; 1224 : 		VectorCopy( ent->origin, ent->attachment[1] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+2912]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2912]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx

; 1225 : 		VectorCopy( ent->origin, ent->attachment[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax

; 1226 : 		VectorCopy( ent->origin, ent->attachment[3] );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx

; 1227 : 
; 1228 : 		CL_AddVisibleEntity( ent, ET_NORMAL );

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_AddVisibleEntity
	add	esp, 8

; 1229 : 	}

	jmp	$LN2@CL_LinkPac
$LN3@CL_LinkPac:

; 1230 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkPacketEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv286 = -16						; size = 4
_i$ = -12						; size = 4
_state$ = -8						; size = 4
_ent$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_LinkPlayers PROC

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi

; 995  : 	entity_state_t	*state;
; 996  : 	cl_entity_t	*ent;
; 997  : 	int		i;
; 998  : 
; 999  : 	ent = CL_GetLocalPlayer();

	call	_CL_GetLocalPlayer
	mov	DWORD PTR _ent$[ebp], eax

; 1000 : 
; 1001 : 	// apply muzzleflash to weaponmodel
; 1002 : 	if( ent && FBitSet( ent->curstate.effects, EF_MUZZLEFLASH ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@CL_LinkPla
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	and	ecx, 2
	je	SHORT $LN5@CL_LinkPla

; 1003 : 		SetBits( clgame.viewent.curstate.effects, EF_MUZZLEFLASH );

	mov	edx, DWORD PTR _clgame+150548
	or	edx, 2
	mov	DWORD PTR _clgame+150548, edx
$LN5@CL_LinkPla:

; 1004 : 	cl.local.apply_effects = true;

	mov	DWORD PTR _cl+1568544, 1

; 1005 : 
; 1006 : 	// check all the clients but add only visible
; 1007 : 	for( i = 0, state = frame->playerstate; i < MAX_CLIENTS; i++, state++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 508				; 000001fcH
	mov	DWORD PTR _state$[ebp], eax
	jmp	SHORT $LN4@CL_LinkPla
$LN2@CL_LinkPla:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 340				; 00000154H
	mov	DWORD PTR _state$[ebp], edx
$LN4@CL_LinkPla:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_LinkPla

; 1008 : 	{
; 1009 : 		if( state->messagenum != cl.parsecount )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _cl+8
	je	SHORT $LN6@CL_LinkPla

; 1010 : 			continue;	// not present this frame

	jmp	SHORT $LN2@CL_LinkPla
$LN6@CL_LinkPla:

; 1011 : 
; 1012 : 		if( !state->modelindex || FBitSet( state->effects, EF_NODRAW ))

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN8@CL_LinkPla
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 128				; 00000080H
	je	SHORT $LN7@CL_LinkPla
$LN8@CL_LinkPla:

; 1013 : 			continue;

	jmp	SHORT $LN2@CL_LinkPla
$LN7@CL_LinkPla:

; 1014 : 
; 1015 : 		ent = &clgame.entities[i + 1];

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	imul	eax, edx, 3000
	add	eax, DWORD PTR _clgame+1000
	mov	DWORD PTR _ent$[ebp], eax

; 1016 : 
; 1017 : 		// fixup the player indexes...
; 1018 : 		if( ent->index != ( i + 1 )) ent->index = (i + 1);

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx], ecx
	je	SHORT $LN9@CL_LinkPla
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx], eax
$LN9@CL_LinkPla:

; 1019 : 
; 1020 : 		if( i == cl.playernum )

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cl+1568828
	jne	$LN10@CL_LinkPla

; 1021 : 		{
; 1022 : 			if( cls.demoplayback != DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	je	$LN11@CL_LinkPla

; 1023 : 			{
; 1024 : 				VectorCopy( state->origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+2888], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+2888], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+2888], eax

; 1025 : 				VectorCopy( state->origin, ent->prevstate.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [eax+ecx+364], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+364], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+364], ecx

; 1026 : 				VectorCopy( state->origin, ent->curstate.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+edx+704], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+704], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+704], edx
$LN11@CL_LinkPla:

; 1027 : 			}
; 1028 : 			VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [edx+eax+2900], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2900], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2900], eax
$LN10@CL_LinkPla:

; 1029 : 		}
; 1030 : 
; 1031 : 		if( FBitSet( ent->curstate.effects, EF_NOINTERP ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+748]
	and	edx, 32					; 00000020H
	je	SHORT $LN12@CL_LinkPla

; 1032 : 			CL_ResetLatchedVars( ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8
$LN12@CL_LinkPla:

; 1033 : 
; 1034 : 		if( CL_EntityTeleported( ent ))

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_EntityTeleported
	add	esp, 4
	test	eax, eax
	je	$LN13@CL_LinkPla

; 1035 : 		{
; 1036 : 			VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [ecx+edx+2844], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2844], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2844], edx

; 1037 : 			VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [edx+eax+2856], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2856], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2856], eax

; 1038 : 			CL_ResetPositions( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_ResetPositions
	add	esp, 4
$LN13@CL_LinkPla:

; 1039 : 		}
; 1040 : 
; 1041 : 		if ( i == cl.playernum )

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cl+1568828
	jne	$LN14@CL_LinkPla

; 1042 : 		{
; 1043 : 			if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	$LN16@CL_LinkPla

; 1044 : 				VectorLerp( ent->prevstate.origin, cl.lerpFrac, ent->curstate.origin, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+704]
	subss	xmm0, DWORD PTR [edi+edx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+364]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _cl[edx+1568804], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+704]
	subss	xmm0, DWORD PTR [edi+edx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+364]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _cl[edx+1568804], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+704]
	subss	xmm0, DWORD PTR [edi+edx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+364]
	addss	xmm1, xmm0
	movss	DWORD PTR tv286[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv286[ebp]
	movss	DWORD PTR _cl[edx+1568804], xmm0
$LN16@CL_LinkPla:

; 1045 : 			VectorCopy( cl.simorg, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cl[ecx+1568804]
	mov	DWORD PTR [edx+eax+2888], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _cl[edx+1568804]
	mov	DWORD PTR [ecx+eax+2888], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _cl[eax+1568804]
	mov	DWORD PTR [edx+ecx+2888], eax

; 1046 : 		}

	jmp	$LN15@CL_LinkPla
$LN14@CL_LinkPla:

; 1047 : 		else
; 1048 : 		{
; 1049 : 			VectorCopy( ent->curstate.origin, ent->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [eax+ecx+2888], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2888], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2888], ecx

; 1050 : 			VectorCopy( ent->curstate.angles, ent->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [ecx+edx+2900], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2900], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2900], edx

; 1051 : 
; 1052 : 			// interpolate non-local clients
; 1053 : 			CL_ComputePlayerOrigin( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ComputePlayerOrigin
	add	esp, 4
$LN15@CL_LinkPla:

; 1054 : 		}
; 1055 : 
; 1056 : 		VectorCopy( ent->origin, ent->attachment[0] );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx

; 1057 : 		VectorCopy( ent->origin, ent->attachment[1] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+2912]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2912]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx

; 1058 : 		VectorCopy( ent->origin, ent->attachment[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax

; 1059 : 		VectorCopy( ent->origin, ent->attachment[3] );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx

; 1060 : 
; 1061 : 		CL_AddVisibleEntity( ent, ET_PLAYER );

	push	1
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_AddVisibleEntity
	add	esp, 8

; 1062 : 	}

	jmp	$LN2@CL_LinkPla
$LN3@CL_LinkPla:

; 1063 : 
; 1064 : 	// apply local player effects if entity is not added
; 1065 : 	if( cl.local.apply_effects ) CL_AddEntityEffects( CL_GetLocalPlayer( ));

	cmp	DWORD PTR _cl+1568544, 0
	je	SHORT $LN17@CL_LinkPla
	call	_CL_GetLocalPlayer
	push	eax
	call	_CL_AddEntityEffects
	add	esp, 4
$LN17@CL_LinkPla:

; 1066 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkPlayers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_state$ = 12						; size = 4
_CL_LinkCustomEntity PROC

; 971  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 972  : 	ent->curstate.movetype = state->modelindex; // !!!

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+776], edx

; 973  : 
; 974  : 	if( ent->model->type != mod_sprite )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 1
	je	SHORT $LN2@CL_LinkCus

; 975  : 		Con_Reportf( S_WARN "bad model on beam ( %s )\n", ent->model->name );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	push	eax
	push	OFFSET $SG145679
	call	_Con_Reportf
	add	esp, 8
$LN2@CL_LinkCus:

; 976  : 
; 977  : 	ent->latched.prevsequence = ent->curstate.sequence;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR [ecx+2868], eax

; 978  : 	VectorCopy( ent->origin, ent->latched.prevorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx+2844], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx+2844], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx+2844], ecx

; 979  : 	VectorCopy( ent->angles, ent->latched.prevangles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2900]
	mov	DWORD PTR [ecx+edx+2856], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2900]
	mov	DWORD PTR [eax+edx+2856], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2900]
	mov	DWORD PTR [ecx+eax+2856], edx

; 980  : 	ent->prevstate = ent->curstate;

	mov	esi, DWORD PTR _ent$[ebp]
	add	esi, 688				; 000002b0H
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 348				; 0000015cH
	mov	ecx, 85					; 00000055H
	rep movsd

; 981  : 
; 982  : 	CL_AddVisibleEntity( ent, ET_BEAM );

	push	3
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8

; 983  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_CL_LinkCustomEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv156 = -36						; size = 4
tv153 = -32						; size = 4
_newent$ = -28						; size = 4
_alive$ = -24						; size = 4
tv65 = -20						; size = 4
_state$ = -16						; size = 4
_delta_type$ = -12					; size = 4
_ent$ = -8						; size = 4
_pack$ = -4						; size = 4
_msg$ = 8						; size = 4
_frame$ = 12						; size = 4
_newnum$ = 16						; size = 4
_old$ = 20						; size = 4
_has_update$ = 24					; size = 4
_CL_DeltaEntity PROC

; 654  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 655  : 	cl_entity_t	*ent;
; 656  : 	entity_state_t	*state;
; 657  : 	qboolean		newent = (old) ? false : true;

	cmp	DWORD PTR _old$[ebp], 0
	je	SHORT $LN12@CL_DeltaEn
	mov	DWORD PTR tv65[ebp], 0
	jmp	SHORT $LN13@CL_DeltaEn
$LN12@CL_DeltaEn:
	mov	DWORD PTR tv65[ebp], 1
$LN13@CL_DeltaEn:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _newent$[ebp], eax

; 658  : 	int		pack = frame->num_entities;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+17296]
	mov	DWORD PTR _pack$[ebp], edx

; 659  : 	int		delta_type = DELTA_ENTITY;

	mov	DWORD PTR _delta_type$[ebp], 0

; 660  : 	qboolean		alive = true;

	mov	DWORD PTR _alive$[ebp], 1

; 661  : 
; 662  : 	// alloc next slot to store update
; 663  : 	state = &cls.packet_entities[cls.next_client_entities % cls.num_client_entities];

	mov	eax, DWORD PTR _cls+291760
	cdq
	idiv	DWORD PTR _cls+291756
	imul	eax, edx, 340
	add	eax, DWORD PTR _cls+291764
	mov	DWORD PTR _state$[ebp], eax

; 664  : 	if( CL_IsPlayerIndex( newnum )) delta_type = DELTA_PLAYER;

	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	call	_CL_IsPlayerIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_DeltaEn
	mov	DWORD PTR _delta_type$[ebp], 1
$LN2@CL_DeltaEn:

; 665  : 
; 666  : 	if(( newnum < 0 ) || ( newnum >= clgame.maxEntities ))

	cmp	DWORD PTR _newnum$[ebp], 0
	jl	SHORT $LN4@CL_DeltaEn
	mov	edx, DWORD PTR _newnum$[ebp]
	cmp	edx, DWORD PTR _clgame+1012
	jl	SHORT $LN3@CL_DeltaEn
$LN4@CL_DeltaEn:

; 667  : 	{
; 668  : 		Con_DPrintf( S_ERROR "CL_DeltaEntity: invalid newnum: %d\n", newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	push	OFFSET $SG145589
	call	_Con_DPrintf
	add	esp, 8

; 669  : 		if( has_update )

	cmp	DWORD PTR _has_update$[ebp], 0
	je	SHORT $LN5@CL_DeltaEn

; 670  : 			MSG_ReadDeltaEntity( msg, old, state, newnum, delta_type, cl.mtime[0] );

	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[edx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _delta_type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H
$LN5@CL_DeltaEn:

; 671  : 		return;

	jmp	$LN1@CL_DeltaEn
$LN3@CL_DeltaEn:

; 672  : 	}
; 673  : 
; 674  : 	ent = CL_EDICT_NUM( newnum );

	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 675  : 	ent->index = newnum; // enumerate entity index

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 676  : 	if( newent ) old = &ent->baseline;

	cmp	DWORD PTR _newent$[ebp], 0
	je	SHORT $LN6@CL_DeltaEn
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 8
	mov	DWORD PTR _old$[ebp], edx
$LN6@CL_DeltaEn:

; 677  : 
; 678  : 	if( has_update )

	cmp	DWORD PTR _has_update$[ebp], 0
	je	SHORT $LN7@CL_DeltaEn

; 679  : 		alive = MSG_ReadDeltaEntity( msg, old, state, newnum, delta_type, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _delta_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _old$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _alive$[ebp], eax
	jmp	SHORT $LN8@CL_DeltaEn
$LN7@CL_DeltaEn:

; 680  : 	else memcpy( state, old, sizeof( entity_state_t ));

	push	340					; 00000154H
	mov	ecx, DWORD PTR _old$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@CL_DeltaEn:

; 681  : 
; 682  : 	if( !alive )

	cmp	DWORD PTR _alive$[ebp], 0
	jne	SHORT $LN9@CL_DeltaEn

; 683  : 	{
; 684  : 		CL_KillDeadBeams( ent ); // release dead beams

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_KillDeadBeams
	add	esp, 4

; 685  : #if 0
; 686  : 		// this is for reference
; 687  : 		if( state->number == -1 )
; 688  : 			Con_DPrintf( "Entity %i was removed from server\n", newnum );
; 689  : 		else Con_Dprintf( "Entity %i was removed from delta-message\n", newnum );
; 690  : #endif
; 691  : 		return;

	jmp	$LN1@CL_DeltaEn
$LN9@CL_DeltaEn:

; 692  : 	}
; 693  : 
; 694  : 	if( newent )

	cmp	DWORD PTR _newent$[ebp], 0
	je	SHORT $LN10@CL_DeltaEn

; 695  : 	{
; 696  : 		// interpolation must be reset
; 697  : 		SETVISBIT( frame->flags, pack );

	cmp	DWORD PTR _pack$[ebp], 0
	jl	SHORT $LN14@CL_DeltaEn
	mov	edx, DWORD PTR _pack$[ebp]
	sar	edx, 3
	mov	ecx, DWORD PTR _pack$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _frame$[ebp]
	movzx	edx, BYTE PTR [ecx+edx+17038]
	or	edx, eax
	mov	DWORD PTR tv153[ebp], edx
	mov	eax, DWORD PTR _pack$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	dl, BYTE PTR tv153[ebp]
	mov	BYTE PTR [ecx+eax+17038], dl
	movzx	eax, BYTE PTR tv153[ebp]
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN15@CL_DeltaEn
$LN14@CL_DeltaEn:
	mov	DWORD PTR tv156[ebp], 0
$LN15@CL_DeltaEn:

; 698  : 
; 699  : 		// release beams from previous entity
; 700  : 		CL_KillDeadBeams( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_KillDeadBeams
	add	esp, 4
$LN10@CL_DeltaEn:

; 701  : 	}
; 702  : 
; 703  : 	// add entity to packet
; 704  : 	cls.next_client_entities++;

	mov	edx, DWORD PTR _cls+291760
	add	edx, 1
	mov	DWORD PTR _cls+291760, edx

; 705  : 	frame->num_entities++;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+17296]
	add	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+17296], ecx
$LN1@CL_DeltaEn:

; 706  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DeltaEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv87 = -692						; size = 4
_newnum$ = -688						; size = 4
_to$ = -684						; size = 340
_from$ = -344						; size = 340
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_FlushEntityPacket PROC

; 624  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 692				; 000002b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 625  : 	int		newnum;
; 626  : 	entity_state_t	from, to;
; 627  : 
; 628  : 	memset( &from, 0, sizeof( from ));

	push	340					; 00000154H
	push	0
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 629  : 
; 630  : 	cl.frames[cl.parsecountmod].valid = false;

	imul	ecx, DWORD PTR _cl+12, 17304
	mov	DWORD PTR _cl[ecx+112], 0

; 631  : 	cl.validsequence = 0; // can't render a frame

	mov	DWORD PTR _cl+4, 0
$LN2@CL_FlushEn:

; 632  : 
; 633  : 	// read it all, but ignore it
; 634  : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN3@CL_FlushEn

; 635  : 	{
; 636  : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 637  : 		if( newnum == LAST_EDICT ) break; // done

	cmp	DWORD PTR _newnum$[ebp], 8191		; 00001fffH
	jne	SHORT $LN4@CL_FlushEn
	jmp	$LN3@CL_FlushEn
$LN4@CL_FlushEn:

; 638  : 
; 639  : 		if( MSG_CheckOverflow( msg ))

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@CL_FlushEn

; 640  : 			Host_Error( "CL_FlushEntityPacket: overflow\n" );

	push	OFFSET $SG145563
	call	_Host_Error
	add	esp, 4
$LN5@CL_FlushEn:

; 641  : 
; 642  : 		MSG_ReadDeltaEntity( msg, &from, &to, newnum, CL_IsPlayerIndex( newnum ) ? DELTA_PLAYER : DELTA_ENTITY, cl.mtime[0] );

	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	call	_CL_IsPlayerIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@CL_FlushEn
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN8@CL_FlushEn
$LN7@CL_FlushEn:
	mov	DWORD PTR tv87[ebp], 0
$LN8@CL_FlushEn:
	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR tv87[ebp]
	push	edx
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _to$[ebp]
	push	ecx
	lea	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 643  : 	}

	jmp	$LN2@CL_FlushEn
$LN3@CL_FlushEn:

; 644  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FlushEntityPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv75 = -4						; size = 4
_pnum$ = 8						; size = 4
_frame$ = 12						; size = 4
_ent$ = 16						; size = 4
_CL_ResetLatchedState PROC

; 552  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 553  : 	if( CHECKVISBIT( frame->flags, pnum ))

	cmp	DWORD PTR _pnum$[ebp], 0
	jl	SHORT $LN5@CL_ResetLa
	mov	eax, DWORD PTR _pnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _frame$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+17038]
	mov	ecx, DWORD PTR _pnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN6@CL_ResetLa
$LN5@CL_ResetLa:
	mov	DWORD PTR tv75[ebp], 0
$LN6@CL_ResetLa:
	cmp	DWORD PTR tv75[ebp], 0
	je	$LN3@CL_ResetLa

; 554  : 	{
; 555  : 		VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [ecx+edx+2844], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2844], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2844], edx

; 556  : 		VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [edx+eax+2856], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2856], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2856], eax

; 557  : 
; 558  : 		CL_ResetLatchedVars( ent, true );

	push	1
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_ResetLatchedVars
	add	esp, 8

; 559  : 		CL_ResetPositions( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_ResetPositions
	add	esp, 4

; 560  : 
; 561  : 		// parametric interpolation will starts at this point
; 562  : 		if( ent->curstate.starttime != 0.0f && ent->curstate.impacttime != 0.0f )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+944]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_ResetLa
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+940]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_ResetLa

; 563  : 			ent->lastmove = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+2884], xmm0
$LN3@CL_ResetLa:

; 564  : 	}
; 565  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetLatchedState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv356 = -124						; size = 4
tv322 = -120						; size = 4
tv183 = -116						; size = 4
_t2$ = -112						; size = 4
_t$ = -108						; size = 4
_t1$ = -104						; size = 4
_frac$ = -100						; size = 4
_ph1$ = -96						; size = 4
_ph0$ = -92						; size = 4
_q$ = -88						; size = 16
_q2$ = -72						; size = 16
_q1$ = -56						; size = 16
_angles$ = -40						; size = 12
_origin$ = -28						; size = 12
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_CL_InterpolateModel PROC

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 410  : 	position_history_t  *ph0 = NULL, *ph1 = NULL;

	mov	DWORD PTR _ph0$[ebp], 0
	mov	DWORD PTR _ph1$[ebp], 0

; 411  : 	vec3_t		origin, angles, delta;
; 412  : 	float		t, t1, t2, frac;
; 413  : 	vec4_t		q, q1, q2;
; 414  : 
; 415  : 	VectorCopy( e->curstate.origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [edx+eax+2888], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2888], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2888], eax

; 416  : 	VectorCopy( e->curstate.angles, e->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [eax+ecx+2900], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2900], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2900], ecx

; 417  : 
; 418  : 	if( cls.timedemo || !e->model )

	cmp	DWORD PTR _cls+297588, 0
	jne	SHORT $LN3@CL_Interpo
	mov	edx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [edx+2964], 0
	jne	SHORT $LN2@CL_Interpo
$LN3@CL_Interpo:

; 419  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN2@CL_Interpo:

; 420  : 
; 421  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	$LN4@CL_Interpo

; 422  : 	{
; 423  : 		// quake lerping is easy
; 424  : 		VectorLerp( e->prevstate.origin, cl.lerpFrac, e->curstate.origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+704]
	subss	xmm0, DWORD PTR [edi+edx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+364]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _e$[ebp]
	movss	DWORD PTR [eax+edx+2888], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+704]
	subss	xmm0, DWORD PTR [edi+eax+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	edx, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+364]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [ecx+eax+2888], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+704]
	subss	xmm0, DWORD PTR [edi+ecx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+364]
	addss	xmm1, xmm0
	movss	DWORD PTR tv183[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR tv183[ebp]
	movss	DWORD PTR [edx+ecx+2888], xmm0

; 425  : 		AngleQuaternion( e->prevstate.angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 376				; 00000178H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 426  : 		AngleQuaternion( e->curstate.angles, q2, false );

	push	0
	lea	edx, DWORD PTR _q2$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 716				; 000002ccH
	push	eax
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 427  : 		QuaternionSlerp( q1, q2, cl.lerpFrac, q );

	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _q2$[ebp]
	push	edx
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 428  : 		QuaternionAngle( q, e->angles );

	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 2900				; 00000b54H
	push	ecx
	lea	edx, DWORD PTR _q$[ebp]
	push	edx
	call	_QuaternionAngle
	add	esp, 8

; 429  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN4@CL_Interpo:

; 430  : 	}
; 431  : 
; 432  : 	if( cl.maxclients <= 1 )

	cmp	DWORD PTR _cl+1568832, 1
	jg	SHORT $LN5@CL_Interpo

; 433  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN5@CL_Interpo:

; 434  : 
; 435  : 	if( e->model->type == mod_brush && !cl_bmodelinterp->value )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN6@CL_Interpo
	mov	edx, DWORD PTR _cl_bmodelinterp
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@CL_Interpo

; 436  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN6@CL_Interpo:

; 437  : 
; 438  : 	if( cl.local.moving && cl.local.onground == e->index )

	cmp	DWORD PTR _cl+1568576, 0
	je	SHORT $LN7@CL_Interpo
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _cl+1568560
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN7@CL_Interpo

; 439  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN7@CL_Interpo:

; 440  : 
; 441  : 	t = cl.time - cl_interp->value;

	mov	edx, DWORD PTR _cl_interp
	cvtss2sd xmm0, DWORD PTR [edx+12]
	movsd	xmm1, QWORD PTR _cl+1525848
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 442  : 	CL_FindInterpolationUpdates( e, t, &ph0, &ph1 );

	lea	eax, DWORD PTR _ph1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ph0$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_CL_FindInterpolationUpdates
	add	esp, 16					; 00000010H

; 443  : 
; 444  : 	if( ph0 == NULL || ph1 == NULL )

	cmp	DWORD PTR _ph0$[ebp], 0
	je	SHORT $LN9@CL_Interpo
	cmp	DWORD PTR _ph1$[ebp], 0
	jne	SHORT $LN8@CL_Interpo
$LN9@CL_Interpo:

; 445  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN8@CL_Interpo:

; 446  : 
; 447  : 	t1 = ph1->animtime;

	mov	eax, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _t1$[ebp], xmm0

; 448  : 	t2 = ph0->animtime;

	mov	ecx, DWORD PTR _ph0$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _t2$[ebp], xmm0

; 449  : 
; 450  : 	if( t - t1 < 0.0f )

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _t1$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN10@CL_Interpo

; 451  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN10@CL_Interpo:

; 452  : 
; 453  : 	if( t1 == 0.0f )

	movss	xmm0, DWORD PTR _t1$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@CL_Interpo

; 454  : 	{
; 455  : 		VectorCopy( ph0->origin, e->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [ecx+edx+2888], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [eax+edx+2888], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+2888], edx

; 456  : 		VectorCopy( ph0->angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+2900], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+2900], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+2900], eax

; 457  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN11@CL_Interpo:

; 458  : 	}
; 459  : 
; 460  : 	if( t2 == t1 )

	movss	xmm0, DWORD PTR _t2$[ebp]
	ucomiss	xmm0, DWORD PTR _t1$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@CL_Interpo

; 461  : 	{
; 462  : 		VectorCopy( ph0->origin, e->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [eax+ecx+2888], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+2888], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [eax+edx+2888], ecx

; 463  : 		VectorCopy( ph0->angles, e->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+edx+2900], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+2900], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+2900], edx

; 464  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN12@CL_Interpo:

; 465  : 	}
; 466  : 
; 467  : 	VectorSubtract( ph0->origin, ph1->origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+4]
	subss	xmm0, DWORD PTR [esi+ecx+4]
	movss	DWORD PTR tv322[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv322[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 468  : 	frac = (t - t1) / (t2 - t1);

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _t1$[ebp]
	movss	xmm1, DWORD PTR _t2$[ebp]
	subss	xmm1, DWORD PTR _t1$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0

; 469  : 
; 470  : 	if( frac < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN13@CL_Interpo

; 471  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN13@CL_Interpo:

; 472  : 
; 473  : 	if( frac > 1.0f )

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@CL_Interpo

; 474  : 		frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN14@CL_Interpo:

; 475  : 
; 476  : 	VectorMA( ph1->origin, frac, delta, origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	eax, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [eax+edx+4]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [edx+eax+4]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _origin$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	eax, DWORD PTR _ph1$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+4]
	addss	xmm1, xmm0
	movss	DWORD PTR tv356[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 477  : 
; 478  : 	AngleQuaternion( ph0->angles, q1, false );

	push	0
	lea	edx, DWORD PTR _q1$[ebp]
	push	edx
	mov	eax, DWORD PTR _ph0$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 479  : 	AngleQuaternion( ph1->angles, q2, false );

	push	0
	lea	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ph1$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 480  : 	QuaternionSlerp( q2, q1, frac, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _q2$[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 481  : 	QuaternionAngle( q, angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 482  : 
; 483  : 	VectorCopy( origin, e->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+edx+2888], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [eax+edx+2888], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR [ecx+eax+2888], edx

; 484  : 	VectorCopy( angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+2900], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+2900], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+2900], eax

; 485  : 
; 486  : 	return 1;

	mov	eax, 1
$LN1@CL_Interpo:

; 487  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InterpolateModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_extrapolate$ = -104					; size = 4
tv169 = -100						; size = 4
tv132 = -96						; size = 4
tv142 = -92						; size = 4
tv141 = -88						; size = 4
_t1$ = -84						; size = 4
_t0$ = -80						; size = 4
_ph0$ = -76						; size = 4
_frac$ = -72						; size = 4
_ph1$ = -68						; size = 4
_q$1 = -64						; size = 16
_q2$2 = -48						; size = 16
_q1$3 = -32						; size = 16
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_t$ = 12						; size = 4
_outorigin$ = 16					; size = 4
_outangles$ = 20					; size = 4
_CL_PureOrigin PROC

; 359  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 360  : 	qboolean		extrapolate;
; 361  : 	float		t1, t0, frac;
; 362  : 	position_history_t	*ph0, *ph1;
; 363  : 	vec3_t		delta;
; 364  : 
; 365  : 	// NOTE: ph0 is next, ph1 is a prev
; 366  : 	extrapolate = CL_FindInterpolationUpdates( ent, t, &ph0, &ph1 );

	lea	eax, DWORD PTR _ph1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ph0$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_FindInterpolationUpdates
	add	esp, 16					; 00000010H
	mov	DWORD PTR _extrapolate$[ebp], eax

; 367  : 
; 368  : 	if ( !ph0 || !ph1 )

	cmp	DWORD PTR _ph0$[ebp], 0
	je	SHORT $LN3@CL_PureOri
	cmp	DWORD PTR _ph1$[ebp], 0
	jne	SHORT $LN2@CL_PureOri
$LN3@CL_PureOri:

; 369  : 		return;

	jmp	$LN5@CL_PureOri
$LN2@CL_PureOri:

; 370  : 
; 371  : 	t0 = ph0->animtime;

	mov	eax, DWORD PTR _ph0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _t0$[ebp], xmm0

; 372  : 	t1 = ph1->animtime;

	mov	ecx, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _t1$[ebp], xmm0

; 373  : 
; 374  : 	if( t0 != 0.0f )

	movss	xmm0, DWORD PTR _t0$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@CL_PureOri

; 375  : 	{
; 376  : 		vec4_t	q, q1, q2;
; 377  : 
; 378  : 		VectorSubtract( ph0->origin, ph1->origin, delta );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+4]
	subss	xmm0, DWORD PTR [esi+edx+4]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+4]
	subss	xmm0, DWORD PTR [esi+edx+4]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	movss	DWORD PTR tv132[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _delta$[ebp+edx], xmm0

; 379  : 
; 380  : 		if( t0 != t1 )

	movss	xmm0, DWORD PTR _t0$[ebp]
	ucomiss	xmm0, DWORD PTR _t1$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_PureOri

; 381  : 			frac = ( t - t1 ) / ( t0 - t1 );

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _t1$[ebp]
	movss	xmm1, DWORD PTR _t0$[ebp]
	subss	xmm1, DWORD PTR _t1$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0
	jmp	SHORT $LN7@CL_PureOri
$LN6@CL_PureOri:

; 382  : 		else frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN7@CL_PureOri:

; 383  : 
; 384  : 		frac = bound( 0.0f, frac, 1.2f );

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN11@CL_PureOri
	movss	xmm0, DWORD PTR __real@3f99999a
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN9@CL_PureOri
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR tv141[ebp], xmm0
	jmp	SHORT $LN10@CL_PureOri
$LN9@CL_PureOri:
	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR tv141[ebp], xmm0
$LN10@CL_PureOri:
	movss	xmm0, DWORD PTR tv141[ebp]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN12@CL_PureOri
$LN11@CL_PureOri:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv142[ebp], xmm0
$LN12@CL_PureOri:
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 385  : 
; 386  : 		VectorMA( ph1->origin, frac, delta, outorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	edx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _outorigin$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [edx+eax+4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _outorigin$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _ph1$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+4]
	addss	xmm1, xmm0
	movss	DWORD PTR tv169[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _outorigin$[ebp]
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 387  : 
; 388  : 		AngleQuaternion( ph0->angles, q1, false );

	push	0
	lea	ecx, DWORD PTR _q1$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _ph0$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 389  : 		AngleQuaternion( ph1->angles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _ph1$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 390  : 		QuaternionSlerp( q2, q1, frac, q );

	lea	edx, DWORD PTR _q$1[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _q1$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _q2$2[ebp]
	push	ecx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 391  : 		QuaternionAngle( q, outangles );

	mov	edx, DWORD PTR _outangles$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$1[ebp]
	push	eax
	call	_QuaternionAngle
	add	esp, 8

; 392  : 	}

	jmp	$LN5@CL_PureOri
$LN4@CL_PureOri:

; 393  : 	else
; 394  : 	{
; 395  : 		// no backup found
; 396  : 		VectorCopy( ph1->origin, outorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _outorigin$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _outorigin$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _outorigin$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [eax+edx], ecx

; 397  : 		VectorCopy( ph1->angles, outangles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _outangles$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _outangles$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _outangles$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax], edx
$LN5@CL_PureOri:

; 398  : 	}
; 399  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PureOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_extrapolate$ = -24					; size = 4
_i1$ = -20						; size = 4
_i0$ = -16						; size = 4
_at$ = -12						; size = 4
_imod$ = -8						; size = 4
_i$ = -4						; size = 4
_ent$ = 8						; size = 4
_targettime$ = 12					; size = 4
_ph0$ = 16						; size = 4
_ph1$ = 20						; size = 4
_CL_FindInterpolationUpdates PROC

; 321  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 322  : 	qboolean	extrapolate = true;

	mov	DWORD PTR _extrapolate$[ebp], 1

; 323  : 	int	i, i0, i1, imod;
; 324  : 	float	at;
; 325  : 
; 326  : 	imod = ent->current_position;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+1028]
	mov	DWORD PTR _imod$[ebp], ecx

; 327  : 	i0 = (imod - 0) & HISTORY_MASK;	// curpos (lerp end)

	mov	edx, DWORD PTR _imod$[ebp]
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _i0$[ebp], edx

; 328  : 	i1 = (imod - 1) & HISTORY_MASK;	// oldpos (lerp start)

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, 1
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _i1$[ebp], eax

; 329  : 
; 330  : 	for( i = 1; i < HISTORY_MAX - 1; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_FindInt
$LN2@CL_FindInt:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_FindInt:
	cmp	DWORD PTR _i$[ebp], 63			; 0000003fH
	jge	SHORT $LN3@CL_FindInt

; 331  : 	{
; 332  : 		at = ent->ph[( imod - i ) & HISTORY_MASK].animtime;

	mov	edx, DWORD PTR _imod$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	and	edx, 63					; 0000003fH
	imul	eax, edx, 28
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+1032]
	movss	DWORD PTR _at$[ebp], xmm0

; 333  : 		if( at == 0.0 ) break;

	cvtss2sd xmm0, DWORD PTR _at$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_FindInt
	jmp	SHORT $LN3@CL_FindInt
$LN5@CL_FindInt:

; 334  : 
; 335  : 		if( targettime > at )

	movss	xmm0, DWORD PTR _targettime$[ebp]
	comiss	xmm0, DWORD PTR _at$[ebp]
	jbe	SHORT $LN6@CL_FindInt

; 336  : 		{
; 337  : 			// found it
; 338  : 			i0 = (( imod - i ) + 1 ) & HISTORY_MASK;

	mov	edx, DWORD PTR _imod$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _i0$[ebp], edx

; 339  : 			i1 = (( imod - i ) + 0 ) & HISTORY_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _i1$[ebp], eax

; 340  : 			extrapolate = false;

	mov	DWORD PTR _extrapolate$[ebp], 0

; 341  : 			break;

	jmp	SHORT $LN3@CL_FindInt
$LN6@CL_FindInt:

; 342  : 		}
; 343  : 	}

	jmp	SHORT $LN2@CL_FindInt
$LN3@CL_FindInt:

; 344  : 
; 345  : 	if( ph0 != NULL ) *ph0 = &ent->ph[i0];

	cmp	DWORD PTR _ph0$[ebp], 0
	je	SHORT $LN7@CL_FindInt
	imul	ecx, DWORD PTR _i0$[ebp], 28
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1032]
	mov	ecx, DWORD PTR _ph0$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@CL_FindInt:

; 346  : 	if( ph1 != NULL ) *ph1 = &ent->ph[i1];

	cmp	DWORD PTR _ph1$[ebp], 0
	je	SHORT $LN8@CL_FindInt
	imul	edx, DWORD PTR _i1$[ebp], 28
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1032]
	mov	edx, DWORD PTR _ph1$[ebp]
	mov	DWORD PTR [edx], ecx
$LN8@CL_FindInt:

; 347  : 
; 348  : 	return extrapolate;

	mov	eax, DWORD PTR _extrapolate$[ebp]

; 349  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindInterpolationUpdates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_parametric$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ProcessEntityUpdate PROC

; 275  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 276  : 	qboolean	parametric;
; 277  : 
; 278  : 	ent->model = CL_ModelHandle( ent->curstate.modelindex );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+2964], eax

; 279  : 	ent->index = ent->curstate.number;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	DWORD PTR [eax], edx

; 280  : 
; 281  : 	if( FBitSet( ent->curstate.entityType, ENTITY_NORMAL ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+688]
	and	ecx, 1
	je	SHORT $LN2@CL_Process

; 282  : 		COM_NormalizeAngles( ent->curstate.angles );

	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 716				; 000002ccH
	push	edx
	call	_COM_NormalizeAngles
	add	esp, 4
$LN2@CL_Process:

; 283  : 
; 284  : 	parametric = CL_ParametricMove( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ParametricMove
	add	esp, 4
	mov	DWORD PTR _parametric$[ebp], eax

; 285  : 
; 286  : 	// allow interpolation on bmodels too
; 287  : 	if( ent->model && ent->model->type == mod_brush )

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	je	SHORT $LN3@CL_Process
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN3@CL_Process

; 288  : 		ent->curstate.animtime = ent->curstate.msg_time;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+696]
	mov	DWORD PTR [ecx+780], eax
$LN3@CL_Process:

; 289  : 
; 290  : 	if( CL_EntityCustomLerp( ent ) && !parametric )

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_EntityCustomLerp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@CL_Process
	cmp	DWORD PTR _parametric$[ebp], 0
	jne	SHORT $LN4@CL_Process

; 291  : 		ent->curstate.animtime = ent->curstate.msg_time;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+696]
	mov	DWORD PTR [edx+780], ecx
$LN4@CL_Process:

; 292  : 
; 293  : 	if( !CL_CompareTimestamps( ent->curstate.animtime, ent->prevstate.animtime ) || CL_EntityIgnoreLerp( ent ))

	mov	edx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+440]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+780]
	movss	DWORD PTR [esp], xmm0
	call	_CL_CompareTimestamps
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@CL_Process
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_EntityIgnoreLerp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@CL_Process
$LN6@CL_Process:

; 294  : 	{
; 295  : 		CL_UpdateLatchedVars( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_UpdateLatchedVars
	add	esp, 4

; 296  : 		CL_UpdatePositions( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_UpdatePositions
	add	esp, 4
$LN5@CL_Process:

; 297  : 	}
; 298  : 
; 299  : 	// g-cont. it should be done for all the players?
; 300  : 	if( ent->player && !FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP )) 

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN7@CL_Process
	mov	edx, DWORD PTR _host+34748
	and	edx, 128				; 00000080H
	jne	SHORT $LN7@CL_Process

; 301  : 		ent->curstate.angles[PITCH] /= -3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+716]
	divss	xmm0, DWORD PTR __real@c0400000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+716], xmm0
$LN7@CL_Process:

; 302  : 
; 303  : 	VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [edx+eax+2888], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2888], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2888], eax

; 304  : 	VectorCopy( ent->curstate.angles, ent->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [eax+ecx+2900], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2900], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2900], ecx

; 305  : 
; 306  : 	// initialize attachments for now
; 307  : 	VectorCopy( ent->origin, ent->attachment[0] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+2912]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+2912]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+2912]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx

; 308  : 	VectorCopy( ent->origin, ent->attachment[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+2912]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2912]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax

; 309  : 	VectorCopy( ent->origin, ent->attachment[2] );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+2912]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2912]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [ecx+edx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+2912]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [edx+eax], ecx

; 310  : 	VectorCopy( ent->origin, ent->attachment[3] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+2912]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+2888]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+2912]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+2888]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+2912]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+2888]
	mov	DWORD PTR [ecx+eax], edx

; 311  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessEntityUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_CL_UpdateLatchedVars PROC

; 207  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 208  : 	if( !ent->model || ( ent->model->type != mod_alias && ent->model->type != mod_studio ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	je	SHORT $LN3@CL_UpdateL
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 2
	je	SHORT $LN2@CL_UpdateL
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $LN2@CL_UpdateL
$LN3@CL_UpdateL:

; 209  : 		return; // below fields used only for alias and studio interpolation

	jmp	$LN6@CL_UpdateL
$LN2@CL_UpdateL:

; 210  : 
; 211  : 	VectorCopy( ent->prevstate.origin, ent->latched.prevorigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+364]
	mov	DWORD PTR [ecx+edx+2844], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+364]
	mov	DWORD PTR [eax+edx+2844], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+364]
	mov	DWORD PTR [ecx+eax+2844], edx

; 212  : 	VectorCopy( ent->prevstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+376]
	mov	DWORD PTR [edx+eax+2856], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+376]
	mov	DWORD PTR [ecx+eax+2856], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+376]
	mov	DWORD PTR [edx+ecx+2856], eax

; 213  : 
; 214  : 	if( ent->model->type == mod_alias )

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 2
	jne	SHORT $LN4@CL_UpdateL

; 215  : 		ent->latched.prevframe = ent->prevstate.frame;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+396]
	mov	DWORD PTR [eax+2872], edx
$LN4@CL_UpdateL:

; 216  : 	ent->latched.prevanimtime = ent->prevstate.animtime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	mov	DWORD PTR [eax+2832], edx

; 217  : 
; 218  : 	if( ent->curstate.sequence != ent->prevstate.sequence )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+732]
	cmp	edx, DWORD PTR [ecx+392]
	je	SHORT $LN5@CL_UpdateL

; 219  : 	{
; 220  : 		memcpy( ent->prevstate.blending, ent->latched.prevseqblending, sizeof( ent->prevstate.blending ));

	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 2840				; 00000b18H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 456				; 000001c8H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 221  : 		ent->latched.prevsequence = ent->prevstate.sequence;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	mov	DWORD PTR [edx+2868], ecx

; 222  : 		ent->latched.sequencetime = ent->curstate.animtime;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+780]
	mov	DWORD PTR [edx+2836], ecx
$LN5@CL_UpdateL:

; 223  : 	}
; 224  : 
; 225  : 	memcpy( ent->latched.prevcontroller, ent->prevstate.controller, sizeof( ent->latched.prevcontroller ));

	push	4
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 452				; 000001c4H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 2876				; 00000b3cH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 226  : 	memcpy( ent->latched.prevblending, ent->prevstate.blending, sizeof( ent->latched.prevblending ));

	push	2
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 456				; 000001c8H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 2880				; 00000b40H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 227  : 
; 228  : 	// update custom latched vars
; 229  : 	if( clgame.drawFuncs.CL_UpdateLatchedVars != NULL )

	cmp	DWORD PTR _clgame+224, 0
	je	SHORT $LN6@CL_UpdateL

; 230  : 		clgame.drawFuncs.CL_UpdateLatchedVars( ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _clgame+224
	add	esp, 8
$LN6@CL_UpdateL:

; 231  : }

	pop	esi
	pop	ebp
	ret	0
_CL_UpdateLatchedVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv358 = -56						; size = 8
tv173 = -48						; size = 4
tv94 = -44						; size = 4
tv143 = -40						; size = 4
tv142 = -36						; size = 4
_dt$ = -32						; size = 4
_t$ = -28						; size = 4
_ilength$1 = -24					; size = 4
_frac$ = -20						; size = 4
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ParametricMove PROC

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 171  : 	float	frac, dt, t;
; 172  : 	vec3_t	delta;
; 173  : 
; 174  : 	if( ent->curstate.starttime == 0.0f || ent->curstate.impacttime == 0.0f )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+944]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_Paramet
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+940]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_Paramet
$LN3@CL_Paramet:

; 175  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Paramet
$LN2@CL_Paramet:

; 176  : 
; 177  : 	VectorSubtract( ent->curstate.endpos, ent->curstate.startpos, delta );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+928]
	subss	xmm0, DWORD PTR [esi+edx+916]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+928]
	subss	xmm0, DWORD PTR [esi+edx+916]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+928]
	subss	xmm0, DWORD PTR [esi+eax+916]
	movss	DWORD PTR tv94[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv94[ebp]
	movss	DWORD PTR _delta$[ebp+edx], xmm0

; 178  : 	dt = ent->curstate.impacttime - ent->curstate.starttime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+940]
	subss	xmm0, DWORD PTR [ecx+944]
	movss	DWORD PTR _dt$[ebp], xmm0

; 179  : 
; 180  : 	if( dt != 0.0f )

	movss	xmm0, DWORD PTR _dt$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@CL_Paramet

; 181  : 	{
; 182  : 		if( ent->lastmove > cl.time )

	mov	edx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+2884]
	comisd	xmm0, QWORD PTR _cl+1525848
	jbe	SHORT $LN5@CL_Paramet

; 183  : 			t = ent->lastmove;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+2884]
	movss	DWORD PTR _t$[ebp], xmm0
	jmp	SHORT $LN6@CL_Paramet
$LN5@CL_Paramet:

; 184  : 		else t = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	movss	DWORD PTR _t$[ebp], xmm0
$LN6@CL_Paramet:

; 185  : 
; 186  : 		frac = ( t - ent->curstate.starttime ) / dt;

	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR [ecx+944]
	divss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 187  : 		frac = bound( 0.0f, frac, 1.0f );

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@CL_Paramet
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN10@CL_Paramet
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN11@CL_Paramet
$LN10@CL_Paramet:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv142[ebp], xmm0
$LN11@CL_Paramet:
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN13@CL_Paramet
$LN12@CL_Paramet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv143[ebp], xmm0
$LN13@CL_Paramet:
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 188  : 		VectorMA( ent->curstate.startpos, frac, delta, ent->curstate.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+916]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+704], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx+916]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+704], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx+916]
	addss	xmm1, xmm0
	movss	DWORD PTR tv173[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR [edx+ecx+704], xmm0

; 189  : 
; 190  : 		ent->lastmove = t;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [eax+2884], xmm0
$LN4@CL_Paramet:

; 191  : 	}
; 192  : 
; 193  : 	VectorNormalize( delta );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+edx]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@CL_Paramet
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN7@CL_Paramet:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _delta$[ebp+ecx], xmm0

; 194  : 	if( VectorLength( delta ) > 0.0f )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _delta$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv358[ebp]
	movsd	xmm0, QWORD PTR tv358[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN8@CL_Paramet

; 195  : 		VectorAngles( delta, ent->curstate.angles ); // re-aim projectile

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 716				; 000002ccH
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp]
	push	edx
	call	_VectorAngles
	add	esp, 8
$LN8@CL_Paramet:

; 196  : 
; 197  : 	return true;

	mov	eax, 1
$LN1@CL_Paramet:

; 198  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParametricMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_e$ = 8							; size = 4
_CL_EntityCustomLerp PROC

; 148  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 149  : 	switch( e->curstate.movetype )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+776]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 14			; 0000000eH
	ja	SHORT $LN2@CL_EntityC
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN6@CL_EntityC[edx]
	jmp	DWORD PTR $LN7@CL_EntityC[eax*4]
$LN4@CL_EntityC:

; 150  : 	{
; 151  : 	case MOVETYPE_NONE:
; 152  : 	case MOVETYPE_STEP:
; 153  : 	case MOVETYPE_WALK:
; 154  : 	case MOVETYPE_FLY:
; 155  : 	case MOVETYPE_COMPOUND:
; 156  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_EntityC
$LN2@CL_EntityC:

; 157  : 	}
; 158  : 
; 159  : 	return true;

	mov	eax, 1
$LN1@CL_EntityC:

; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@CL_EntityC:
	DD	$LN4@CL_EntityC
	DD	$LN2@CL_EntityC
$LN6@CL_EntityC:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_CL_EntityCustomLerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv71 = -4						; size = 4
_e$ = 8							; size = 4
_CL_EntityIgnoreLerp PROC

; 134  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 135  : 	if( e->model && e->model->type == mod_alias )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	je	SHORT $LN2@CL_EntityI
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 2
	jne	SHORT $LN2@CL_EntityI

; 136  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_EntityI
$LN2@CL_EntityI:

; 137  : 
; 138  : 	return (e->curstate.movetype == MOVETYPE_NONE) ? true : false;

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+776], 0
	jne	SHORT $LN4@CL_EntityI
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@CL_EntityI
$LN4@CL_EntityI:
	mov	DWORD PTR tv71[ebp], 0
$LN5@CL_EntityI:
	mov	eax, DWORD PTR tv71[ebp]
$LN1@CL_EntityI:

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EntityIgnoreLerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_iTime2$ = -12						; size = 4
_iTime1$ = -8						; size = 4
tv70 = -4						; size = 4
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
_CL_CompareTimestamps PROC

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 120  : 	int	iTime1 = t1 * 1000;

	movss	xmm0, DWORD PTR _t1$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si eax, xmm0
	mov	DWORD PTR _iTime1$[ebp], eax

; 121  : 	int	iTime2 = t2 * 1000;

	movss	xmm0, DWORD PTR _t2$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _iTime2$[ebp], ecx

; 122  : 
; 123  : 	return (( iTime1 - iTime2 ) <= 1 );

	mov	edx, DWORD PTR _iTime1$[ebp]
	sub	edx, DWORD PTR _iTime2$[ebp]
	cmp	edx, 1
	jg	SHORT $LN3@CL_Compare
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_Compare
$LN3@CL_Compare:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_Compare:
	mov	eax, DWORD PTR tv70[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CompareTimestamps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_maxlen$ = -32						; size = 4
_len$ = -28						; size = 4
tv90 = -24						; size = 4
tv151 = -20						; size = 4
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_EntityTeleported PROC

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 99   : 	float	len, maxlen;
; 100  : 	vec3_t	delta;
; 101  : 
; 102  : 	VectorSubtract( ent->curstate.origin, ent->prevstate.origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+704]
	subss	xmm0, DWORD PTR [esi+eax+364]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+704]
	subss	xmm0, DWORD PTR [esi+eax+364]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+704]
	subss	xmm0, DWORD PTR [esi+ecx+364]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 103  : 
; 104  : 	// compute potential max movement in units per frame and compare with entity movement
; 105  : 	maxlen = ( clgame.movevars.maxvelocity * ( 1.0 / GAME_FPS ));

	cvtss2sd xmm0, DWORD PTR _clgame+1080
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxlen$[ebp], xmm0

; 106  : 	len = VectorLength( delta );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+edx]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _len$[ebp]

; 107  : 
; 108  : 	return (len > maxlen);

	movss	xmm0, DWORD PTR _len$[ebp]
	comiss	xmm0, DWORD PTR _maxlen$[ebp]
	jbe	SHORT $LN3@CL_EntityT
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN4@CL_EntityT
$LN3@CL_EntityT:
	mov	DWORD PTR tv151[ebp], 0
$LN4@CL_EntityT:
	mov	eax, DWORD PTR tv151[ebp]

; 109  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EntityTeleported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_store$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ResetPositions PROC

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 77   : 	position_history_t	store;
; 78   : 
; 79   : 	if( !ent ) return;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN2@CL_ResetPo
	jmp	$LN1@CL_ResetPo
$LN2@CL_ResetPo:

; 80   : 
; 81   : 	store = ent->ph[ent->current_position];

	mov	eax, DWORD PTR _ent$[ebp]
	imul	ecx, DWORD PTR [eax+1028], 28
	mov	edx, DWORD PTR _ent$[ebp]
	lea	esi, DWORD PTR [edx+ecx+1032]
	mov	ecx, 7
	lea	edi, DWORD PTR _store$[ebp]
	rep movsd

; 82   : 	ent->current_position = 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+1028], 1

; 83   : 
; 84   : 	memset( ent->ph, 0, sizeof( position_history_t ) * HISTORY_MAX );

	push	1792					; 00000700H
	push	0
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 1032				; 00000408H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 85   : 	memcpy( &ent->ph[1], &store, sizeof( position_history_t ));

	push	28					; 0000001cH
	lea	edx, DWORD PTR _store$[ebp]
	push	edx
	mov	eax, 28					; 0000001cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1032]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 86   : 	memcpy( &ent->ph[0], &store, sizeof( position_history_t ));

	push	28					; 0000001cH
	lea	eax, DWORD PTR _store$[ebp]
	push	eax
	mov	ecx, 28					; 0000001cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1032]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@CL_ResetPo:

; 87   : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetPositions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_ph$ = -4						; size = 4
_ent$ = 8						; size = 4
_CL_UpdatePositions PROC

; 57   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 58   : 	position_history_t	*ph;
; 59   : 
; 60   : 	ent->current_position = (ent->current_position + 1) & HISTORY_MASK;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+1028]
	add	ecx, 1
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+1028], ecx

; 61   : 	ph = &ent->ph[ent->current_position];

	mov	eax, DWORD PTR _ent$[ebp]
	imul	ecx, DWORD PTR [eax+1028], 28
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1032]
	mov	DWORD PTR _ph$[ebp], eax

; 62   : 
; 63   : 	VectorCopy( ent->curstate.origin, ph->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+4], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+4], ecx

; 64   : 	VectorCopy( ent->curstate.angles, ph->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [ecx+edx+16], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+16], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+16], edx

; 65   : 	ph->animtime = ent->curstate.animtime;	// !!!

	mov	eax, DWORD PTR _ph$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+780]
	mov	DWORD PTR [eax], edx

; 66   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdatePositions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_CL_EmitEntities PROC

; 1257 : {

	push	ebp
	mov	ebp, esp

; 1258 : 	if( cl.paused ) return; // don't waste time

	cmp	DWORD PTR _cl+24, 0
	je	SHORT $LN2@CL_EmitEnt
	jmp	$LN1@CL_EmitEnt
$LN2@CL_EmitEnt:

; 1259 : 
; 1260 : 	R_ClearScene ();

	call	_R_ClearScene

; 1261 : 
; 1262 : 	// not in server yet, no entities to redraw
; 1263 : 	if( cls.state != ca_active || !cl.validsequence )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN4@CL_EmitEnt
	cmp	DWORD PTR _cl+4, 0
	jne	SHORT $LN3@CL_EmitEnt
$LN4@CL_EmitEnt:

; 1264 : 		return;

	jmp	$LN1@CL_EmitEnt
$LN3@CL_EmitEnt:

; 1265 : 
; 1266 : 	// make sure we have at least one valid update
; 1267 : 	if( !cl.frames[cl.parsecountmod].valid )

	imul	eax, DWORD PTR _cl+12, 17304
	cmp	DWORD PTR _cl[eax+112], 0
	jne	SHORT $LN5@CL_EmitEnt

; 1268 : 		return;

	jmp	SHORT $LN1@CL_EmitEnt
$LN5@CL_EmitEnt:

; 1269 : 
; 1270 : 	// animate lightestyles
; 1271 : 	CL_RunLightStyles ();

	call	_CL_RunLightStyles

; 1272 : 
; 1273 : 	// decay dynamic lights
; 1274 : 	CL_DecayLights ();

	call	_CL_DecayLights

; 1275 : 
; 1276 : 	// compute last interpolation amount
; 1277 : 	CL_UpdateFrameLerp ();

	call	_CL_UpdateFrameLerp

; 1278 : 
; 1279 : 	// set client ideal pitch when mlook is disabled
; 1280 : 	CL_SetIdealPitch ();

	call	_CL_SetIdealPitch

; 1281 : 
; 1282 : 	// clear the scene befor start new frame
; 1283 : 	if( clgame.drawFuncs.R_ClearScene != NULL )

	cmp	DWORD PTR _clgame+220, 0
	je	SHORT $LN6@CL_EmitEnt

; 1284 : 		clgame.drawFuncs.R_ClearScene();

	call	DWORD PTR _clgame+220
$LN6@CL_EmitEnt:

; 1285 : 
; 1286 : 	// link all the visible clients first
; 1287 : 	CL_LinkPlayers ( &cl.frames[cl.parsecountmod] );

	imul	ecx, DWORD PTR _cl+12, 17304
	add	ecx, OFFSET _cl+88
	push	ecx
	call	_CL_LinkPlayers
	add	esp, 4

; 1288 : 
; 1289 : 	// link all the entities that actually have update
; 1290 : 	CL_LinkPacketEntities ( &cl.frames[cl.parsecountmod] );

	imul	edx, DWORD PTR _cl+12, 17304
	add	edx, OFFSET _cl+88
	push	edx
	call	_CL_LinkPacketEntities
	add	esp, 4

; 1291 : 
; 1292 : 	// link custom user temp entities
; 1293 : 	clgame.dllFuncs.pfnCreateEntities();

	call	DWORD PTR _clgame+88

; 1294 : 
; 1295 : 	// evaluate temp entities
; 1296 : 	CL_TempEntUpdate ();

	call	_CL_TempEntUpdate

; 1297 : 
; 1298 : 	// fire events (client and server)
; 1299 : 	CL_FireEvents ();

	call	_CL_FireEvents

; 1300 : 
; 1301 : 	// handle spectator camera movement
; 1302 : 	CL_MoveSpectatorCamera();

	call	_CL_MoveSpectatorCamera

; 1303 : 
; 1304 : 	// perfomance test
; 1305 : 	CL_TestLights();

	call	_CL_TestLights
$LN1@CL_EmitEnt:

; 1306 : }

	pop	ebp
	ret	0
_CL_EmitEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_idx$ = 8						; size = 4
_CL_IsPlayerIndex PROC

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 39   : 	return ( idx >= 1 && idx <= cl.maxclients );

	cmp	DWORD PTR _idx$[ebp], 1
	jl	SHORT $LN3@CL_IsPlaye
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _cl+1568832
	jg	SHORT $LN3@CL_IsPlaye
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@CL_IsPlaye
$LN3@CL_IsPlaye:
	mov	DWORD PTR tv66[ebp], 0
$LN4@CL_IsPlaye:
	mov	eax, DWORD PTR tv66[ebp]

; 40   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsPlayerIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_CL_MoveThirdpersonCamera PROC

; 1240 : {

	push	ebp
	mov	ebp, esp

; 1241 : 	if( cls.state == ca_disconnected || cls.state == ca_cinematic )

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN3@CL_MoveThi
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN2@CL_MoveThi
$LN3@CL_MoveThi:

; 1242 : 		return;

	jmp	SHORT $LN1@CL_MoveThi
$LN2@CL_MoveThi:

; 1243 : 
; 1244 : 	// think thirdperson camera
; 1245 : 	clgame.dllFuncs.CAM_Think ();

	call	DWORD PTR _clgame+76
$LN1@CL_MoveThi:

; 1246 : }

	pop	ebp
	ret	0
_CL_MoveThirdpersonCamera ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_pnum$ = -12						; size = 4
_ent$ = -8						; size = 4
_state$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_ProcessPacket PROC

; 575  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 576  : 	entity_state_t	*state;
; 577  : 	cl_entity_t	*ent;
; 578  : 	int		pnum;
; 579  : 
; 580  : 	for( pnum = 0; pnum < frame->num_entities; pnum++ )

	mov	DWORD PTR _pnum$[ebp], 0
	jmp	SHORT $LN4@CL_Process
$LN2@CL_Process:
	mov	eax, DWORD PTR _pnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _pnum$[ebp], eax
$LN4@CL_Process:
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR _pnum$[ebp]
	cmp	edx, DWORD PTR [ecx+17296]
	jge	$LN3@CL_Process

; 581  : 	{
; 582  : 		// request the entity state from circular buffer
; 583  : 		state = &cls.packet_entities[(frame->first_entity+pnum) % cls.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+17300]
	add	eax, DWORD PTR _pnum$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _cls+291764
	mov	DWORD PTR _state$[ebp], ecx

; 584  : 		state->messagenum = cl.parsecount;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _cl+8
	mov	DWORD PTR [edx+12], eax

; 585  : 		state->msg_time = cl.mtime[0];

	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[edx+32]
	mov	eax, DWORD PTR _state$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 586  : 
; 587  : 		// mark all the players
; 588  : 		ent = &clgame.entities[state->number];

	mov	ecx, DWORD PTR _state$[ebp]
	imul	edx, DWORD PTR [ecx+4], 3000
	add	edx, DWORD PTR _clgame+1000
	mov	DWORD PTR _ent$[ebp], edx

; 589  : 		ent->player = CL_IsPlayerIndex( state->number );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 590  : 
; 591  : 		if( state->number == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _cl+1568828
	add	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN5@CL_Process

; 592  : 			clgame.dllFuncs.pfnTxferLocalOverrides( state, &frame->clientdata );

	mov	edx, DWORD PTR _frame$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _clgame+112
	add	esp, 8
$LN5@CL_Process:

; 593  : 
; 594  : 		// shuffle states
; 595  : 		ent->prevstate = ent->curstate;

	mov	esi, DWORD PTR _ent$[ebp]
	add	esi, 688				; 000002b0H
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 348				; 0000015cH
	mov	ecx, 85					; 00000055H
	rep movsd

; 596  : 		ent->curstate = *state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 688				; 000002b0H
	mov	ecx, 85					; 00000055H
	mov	esi, DWORD PTR _state$[ebp]
	rep movsd

; 597  : 
; 598  : 		CL_ProcessEntityUpdate( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_ProcessEntityUpdate
	add	esp, 4

; 599  : 		CL_ResetLatchedState( pnum, frame, ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnum$[ebp]
	push	ecx
	call	_CL_ResetLatchedState
	add	esp, 12					; 0000000cH

; 600  : 		if( !ent->player ) continue;

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN6@CL_Process
	jmp	$LN2@CL_Process
$LN6@CL_Process:

; 601  : 
; 602  : 		CL_ProcessPlayerState(( state->number - 1 ), state );

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	push	edx
	call	_CL_ProcessPlayerState
	add	esp, 8

; 603  : 
; 604  : 		if( state->number == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _cl+1568828
	add	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN7@CL_Process

; 605  : 			CL_CheckPredictionError();

	call	_CL_CheckPredictionError
$LN7@CL_Process:

; 606  : 	}

	jmp	$LN2@CL_Process
$LN3@CL_Process:

; 607  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_targettime$ = -84					; size = 4
tv149 = -80						; size = 4
_q$ = -76						; size = 16
_q1$ = -60						; size = 16
_q2$ = -44						; size = 16
_origin$ = -28						; size = 12
_angles$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ComputePlayerOrigin PROC

; 497  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 498  : 	float	targettime;
; 499  : 	vec4_t	q, q1, q2;
; 500  : 	vec3_t	origin;
; 501  : 	vec3_t	angles;
; 502  : 
; 503  : 	if( !ent->player || ent->index == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@CL_Compute
	mov	ecx, DWORD PTR _cl+1568828
	add	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN2@CL_Compute
$LN3@CL_Compute:

; 504  : 		return;

	jmp	$LN1@CL_Compute
$LN2@CL_Compute:

; 505  : 
; 506  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+297580, 2
	jne	$LN4@CL_Compute

; 507  : 	{
; 508  : 		// quake lerping is easy
; 509  : 		VectorLerp( ent->prevstate.origin, cl.lerpFrac, ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+704]
	subss	xmm0, DWORD PTR [edi+edx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+364]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+2888], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+704]
	subss	xmm0, DWORD PTR [edi+eax+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+364]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+2888], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+704]
	subss	xmm0, DWORD PTR [edi+ecx+364]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+364]
	addss	xmm1, xmm0
	movss	DWORD PTR tv149[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR [edx+ecx+2888], xmm0

; 510  : 		AngleQuaternion( ent->prevstate.angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 376				; 00000178H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 511  : 		AngleQuaternion( ent->curstate.angles, q2, false );

	push	0
	lea	edx, DWORD PTR _q2$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 716				; 000002ccH
	push	eax
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 512  : 		QuaternionSlerp( q1, q2, cl.lerpFrac, q );

	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _q2$[ebp]
	push	edx
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 513  : 		QuaternionAngle( q, ent->angles );

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 2900				; 00000b54H
	push	ecx
	lea	edx, DWORD PTR _q$[ebp]
	push	edx
	call	_QuaternionAngle
	add	esp, 8

; 514  : 		return;

	jmp	$LN1@CL_Compute
$LN4@CL_Compute:

; 515  : 	}
; 516  : 
; 517  : 	targettime = cl.time - cl_interp->value;

	mov	eax, DWORD PTR _cl_interp
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _cl+1525848
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _targettime$[ebp], xmm0

; 518  : 	CL_PureOrigin( ent, targettime, origin, angles );

	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _targettime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_PureOrigin
	add	esp, 16					; 00000010H

; 519  : 
; 520  : 	VectorCopy( angles, ent->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [eax+ecx+2900], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+2900], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [eax+edx+2900], ecx

; 521  : 	VectorCopy( origin, ent->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+edx+2888], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [eax+edx+2888], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR [ecx+eax+2888], edx
$LN1@CL_Compute:

; 522  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ComputePlayerOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_ps$ = -4						; size = 4
_playerindex$ = 8					; size = 4
_state$ = 12						; size = 4
_CL_ProcessPlayerState PROC

; 532  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 533  : 	entity_state_t	*ps;
; 534  : 
; 535  : 	ps = &cl.frames[cl.parsecountmod].playerstate[playerindex];

	imul	eax, DWORD PTR _cl+12, 17304
	imul	ecx, DWORD PTR _playerindex$[ebp], 340
	lea	edx, DWORD PTR _cl[eax+ecx+596]
	mov	DWORD PTR _ps$[ebp], edx

; 536  : 	ps->number = state->number;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 537  : 	ps->messagenum = cl.parsecount;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _cl+8
	mov	DWORD PTR [eax+12], ecx

; 538  : 	ps->msg_time = cl.mtime[0];

	mov	edx, 8
	imul	eax, edx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[eax+32]
	mov	ecx, DWORD PTR _ps$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 539  : 
; 540  : 	clgame.dllFuncs.pfnProcessPlayerState( ps, state );

	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	DWORD PTR _clgame+116
	add	esp, 8

; 541  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessPlayerState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv188 = -20						; size = 4
tv158 = -16						; size = 4
_valid_origin$ = -12					; size = 4
tv76 = -8						; size = 4
_ent$ = -4						; size = 4
_ch$ = 8						; size = 4
_CL_GetMovieSpatialization PROC

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1363 : 	cl_entity_t	*ent;
; 1364 : 	qboolean		valid_origin;
; 1365 : 
; 1366 : 	valid_origin = VectorIsNull( ch->origin ) ? false : true;          

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_GetMovi
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_GetMovi
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_GetMovi
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN8@CL_GetMovi
$LN7@CL_GetMovi:
	mov	DWORD PTR tv76[ebp], 1
$LN8@CL_GetMovi:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _valid_origin$[ebp], ecx

; 1367 : 	ent = CL_GetEntityByIndex( ch->entnum );

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1368 : 
; 1369 : 	// entity is not present on the client but has valid origin
; 1370 : 	if( !ent || !ent->index || ent->curstate.messagenum == 0 )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN3@CL_GetMovi
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@CL_GetMovi
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+700], 0
	jne	SHORT $LN2@CL_GetMovi
$LN3@CL_GetMovi:

; 1371 : 		return valid_origin;

	mov	eax, DWORD PTR _valid_origin$[ebp]
	jmp	$LN1@CL_GetMovi
$LN2@CL_GetMovi:

; 1372 : 
; 1373 : 	// setup origin
; 1374 : 	VectorAverage( ent->curstate.mins, ent->curstate.maxs, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+812]
	addss	xmm0, DWORD PTR [esi+eax+824]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+812]
	addss	xmm0, DWORD PTR [esi+ecx+824]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+812]
	addss	xmm0, DWORD PTR [esi+eax+824]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv158[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0

; 1375 : 	VectorAdd( ch->origin, ent->curstate.origin, ch->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+20]
	addss	xmm0, DWORD PTR [esi+ecx+704]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+20]
	addss	xmm0, DWORD PTR [esi+edx+704]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+20]
	addss	xmm0, DWORD PTR [esi+ecx+704]
	movss	DWORD PTR tv188[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0

; 1376 : 
; 1377 : 	// setup radius
; 1378 : 	if( ent->model != NULL && ent->model->radius ) ch->radius = ent->model->radius;

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+2964], 0
	je	SHORT $LN4@CL_GetMovi
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	movss	xmm0, DWORD PTR [ecx+108]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@CL_GetMovi
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [eax+108]
	mov	DWORD PTR [ecx+32], edx
	jmp	SHORT $LN5@CL_GetMovi
$LN4@CL_GetMovi:

; 1379 : 	else ch->radius = RadiusFromBounds( ent->curstate.mins, ent->curstate.maxs );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 824				; 00000338H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	mov	edx, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [edx+32]
$LN5@CL_GetMovi:

; 1380 : 
; 1381 : 	return true;

	mov	eax, 1
$LN1@CL_GetMovi:

; 1382 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetMovieSpatialization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv271 = -28						; size = 4
tv241 = -24						; size = 4
tv211 = -20						; size = 4
tv181 = -16						; size = 4
_valid_origin$ = -12					; size = 4
tv129 = -8						; size = 4
_ent$ = -4						; size = 4
_ch$ = 8						; size = 4
_CL_GetEntitySpatialization PROC

; 1316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1317 : 	cl_entity_t	*ent;
; 1318 : 	qboolean		valid_origin;
; 1319 : 
; 1320 : 	if( ch->entnum == 0 )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN2@CL_GetEnti

; 1321 : 	{
; 1322 : 		ch->staticsound = true;

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+72], 1

; 1323 : 		return true; // static sound

	mov	eax, 1
	jmp	$LN1@CL_GetEnti
$LN2@CL_GetEnti:

; 1324 : 	}
; 1325 : 
; 1326 : 	if(( ch->entnum - 1 ) == cl.playernum )

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, 1
	cmp	eax, DWORD PTR _cl+1568828
	jne	SHORT $LN3@CL_GetEnti

; 1327 : 	{
; 1328 : 		VectorCopy( RI.vieworg, ch->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR [eax+ecx+36], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _RI[eax+200]
	mov	DWORD PTR [edx+ecx+36], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR [eax+edx+36], ecx

; 1329 : 		return true;

	mov	eax, 1
	jmp	$LN1@CL_GetEnti
$LN3@CL_GetEnti:

; 1330 : 	}
; 1331 : 
; 1332 : 	valid_origin = VectorIsNull( ch->origin ) ? false : true;          

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+36]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_GetEnti
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+36]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_GetEnti
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+36]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_GetEnti
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN10@CL_GetEnti
$LN9@CL_GetEnti:
	mov	DWORD PTR tv129[ebp], 1
$LN10@CL_GetEnti:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR _valid_origin$[ebp], eax

; 1333 : 	ent = CL_GetEntityByIndex( ch->entnum );

	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1334 : 
; 1335 : 	// entity is not present on the client but has valid origin
; 1336 : 	if( !ent || !ent->index || ent->curstate.messagenum == 0 )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@CL_GetEnti
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@CL_GetEnti
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+700], 0
	jne	SHORT $LN4@CL_GetEnti
$LN5@CL_GetEnti:

; 1337 : 		return valid_origin;

	mov	eax, DWORD PTR _valid_origin$[ebp]
	jmp	$LN1@CL_GetEnti
$LN4@CL_GetEnti:

; 1338 : 
; 1339 : #if 0
; 1340 : 	// uncomment this if you want enable additional check by PVS
; 1341 : 	if( ent->curstate.messagenum != cl.parsecount )
; 1342 : 		return valid_origin;
; 1343 : #endif
; 1344 : 	ch->movetype = ent->curstate.movetype;

	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+776]
	mov	DWORD PTR [edx+160], ecx

; 1345 : 
; 1346 : 	// setup origin
; 1347 : 	VectorAverage( ent->curstate.mins, ent->curstate.maxs, ch->origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+812]
	addss	xmm0, DWORD PTR [esi+edx+824]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+36], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+812]
	addss	xmm0, DWORD PTR [esi+eax+824]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+edx+36], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+812]
	addss	xmm0, DWORD PTR [esi+edx+824]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv181[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv181[ebp]
	movss	DWORD PTR [edx+ecx+36], xmm0

; 1348 : 	VectorAdd( ch->origin, ent->curstate.origin, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+36]
	addss	xmm0, DWORD PTR [esi+eax+704]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+36], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+36]
	addss	xmm0, DWORD PTR [esi+ecx+704]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+36], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+36]
	addss	xmm0, DWORD PTR [esi+eax+704]
	movss	DWORD PTR tv211[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR [eax+edx+36], xmm0

; 1349 : 
; 1350 : 	// setup mins\maxs
; 1351 : 	VectorAdd( ent->curstate.mins, ent->curstate.origin, ch->absmin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+812]
	addss	xmm0, DWORD PTR [esi+ecx+704]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+812]
	addss	xmm0, DWORD PTR [esi+edx+704]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+812]
	addss	xmm0, DWORD PTR [esi+ecx+704]
	movss	DWORD PTR tv241[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0

; 1352 : 	VectorAdd( ent->curstate.maxs, ent->curstate.origin, ch->absmax );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+824]
	addss	xmm0, DWORD PTR [esi+edx+704]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+148], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+824]
	addss	xmm0, DWORD PTR [esi+eax+704]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+edx+148], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+824]
	addss	xmm0, DWORD PTR [esi+edx+704]
	movss	DWORD PTR tv271[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv271[ebp]
	movss	DWORD PTR [edx+ecx+148], xmm0

; 1353 : 
; 1354 : 	// setup radius
; 1355 : 	if( ent->model != NULL && ent->model->radius ) ch->radius = ent->model->radius;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	je	SHORT $LN6@CL_GetEnti
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	movss	xmm0, DWORD PTR [edx+108]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_GetEnti
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	mov	DWORD PTR [edx+132], eax
	jmp	SHORT $LN7@CL_GetEnti
$LN6@CL_GetEnti:

; 1356 : 	else ch->radius = RadiusFromBounds( ent->curstate.mins, ent->curstate.maxs );

	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 824				; 00000338H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 812				; 0000032cH
	push	edx
	call	_RadiusFromBounds
	add	esp, 8
	mov	eax, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [eax+132]
$LN7@CL_GetEnti:

; 1357 : 
; 1358 : 	return true;

	mov	eax, 1
$LN1@CL_GetEnti:

; 1359 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetEntitySpatialization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv135 = -4						; size = 4
_ent$ = 8						; size = 4
_full_reset$ = 12					; size = 4
_CL_ResetLatchedVars PROC

; 240  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 241  : 	if( !ent->model || ( ent->model->type != mod_alias && ent->model->type != mod_studio ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	je	SHORT $LN3@CL_ResetLa
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 2
	je	SHORT $LN2@CL_ResetLa
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $LN2@CL_ResetLa
$LN3@CL_ResetLa:

; 242  : 		return; // below fields used only for alias and studio interpolation

	jmp	$LN8@CL_ResetLa
$LN2@CL_ResetLa:

; 243  : 
; 244  : 	if( full_reset )

	cmp	DWORD PTR _full_reset$[ebp], 0
	je	$LN4@CL_ResetLa

; 245  : 	{
; 246  : 		// don't modify for sprites to avoid broke sprite interp
; 247  : 		memcpy( ent->latched.prevblending, ent->curstate.blending, sizeof( ent->latched.prevblending ));

	push	2
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 796				; 0000031cH
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 2880				; 00000b40H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 248  : 		ent->latched.sequencetime = ent->curstate.animtime;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+780]
	mov	DWORD PTR [ecx+2836], eax

; 249  : 		memcpy( ent->latched.prevcontroller, ent->curstate.controller, sizeof( ent->latched.prevcontroller ));

	push	4
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 792				; 00000318H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 2876				; 00000b3cH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 250  : 		if( ent->model->type == mod_studio )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 3
	jne	SHORT $LN5@CL_ResetLa

; 251  : 			ent->latched.prevframe = CL_GetStudioEstimatedFrame( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_GetStudioEstimatedFrame
	add	esp, 4
	mov	eax, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [eax+2872]
	jmp	SHORT $LN7@CL_ResetLa
$LN5@CL_ResetLa:

; 252  : 		else if( ent->model->type == mod_alias )

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 2
	jne	SHORT $LN7@CL_ResetLa

; 253  : 			ent->latched.prevframe = ent->curstate.frame;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+736]
	mov	DWORD PTR [eax+2872], edx
$LN7@CL_ResetLa:

; 254  : 		ent->prevstate = ent->curstate;

	mov	esi, DWORD PTR _ent$[ebp]
	add	esi, 688				; 000002b0H
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 348				; 0000015cH
	mov	ecx, 85					; 00000055H
	rep movsd
$LN4@CL_ResetLa:

; 255  : 	}
; 256  : 
; 257  : 	ent->latched.prevanimtime = ent->curstate.animtime = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR tv135[ebp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR [edx+780], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR [eax+2832], xmm0

; 258  : 	VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [eax+ecx+2844], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2844], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [eax+edx+2844], ecx

; 259  : 	VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [ecx+edx+2856], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2856], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [ecx+eax+2856], edx

; 260  : 	ent->latched.prevsequence = ent->curstate.sequence;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR [eax+2868], edx

; 261  : 
; 262  : 	// update custom latched vars
; 263  : 	if( clgame.drawFuncs.CL_UpdateLatchedVars != NULL )

	cmp	DWORD PTR _clgame+224, 0
	je	SHORT $LN8@CL_ResetLa

; 264  : 		clgame.drawFuncs.CL_UpdateLatchedVars( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _clgame+224
	add	esp, 8
$LN8@CL_ResetLa:

; 265  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetLatchedVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_entityType$ = 12					; size = 4
_CL_AddVisibleEntity PROC

; 918  : {

	push	ebp
	mov	ebp, esp

; 919  : 	if( !ent || !ent->model )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN3@CL_AddVisi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+2964], 0
	jne	SHORT $LN2@CL_AddVisi
$LN3@CL_AddVisi:

; 920  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_AddVisi
$LN2@CL_AddVisi:

; 921  : 
; 922  : 	// check for adding this entity
; 923  : 	if( !clgame.dllFuncs.pfnAddEntity( entityType, ent, ent->model->name ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityType$[ebp]
	push	ecx
	call	DWORD PTR _clgame+84
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@CL_AddVisi

; 924  : 	{
; 925  : 		// local player was reject by game code, so ignore any effects
; 926  : 		if( RP_LOCALCLIENT( ent ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@CL_AddVisi
	mov	edx, DWORD PTR _cl+1568828
	add	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN5@CL_AddVisi
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@CL_AddVisi

; 927  : 			cl.local.apply_effects = false;

	mov	DWORD PTR _cl+1568544, 0
$LN5@CL_AddVisi:

; 928  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_AddVisi
$LN4@CL_AddVisi:

; 929  : 	}
; 930  : 
; 931  : 	// don't add the player in firstperson mode
; 932  : 	if( RP_LOCALCLIENT( ent ) && !CL_IsThirdPerson( ) && ( ent->index == cl.viewentity ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN6@CL_AddVisi
	mov	edx, DWORD PTR _cl+1568828
	add	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN6@CL_AddVisi
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN6@CL_AddVisi
	call	_CL_IsThirdPerson
	test	eax, eax
	jne	SHORT $LN6@CL_AddVisi
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _cl+1568608
	jne	SHORT $LN6@CL_AddVisi

; 933  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_AddVisi
$LN6@CL_AddVisi:

; 934  : 
; 935  : 	if( entityType == ET_BEAM )

	cmp	DWORD PTR _entityType$[ebp], 3
	jne	SHORT $LN7@CL_AddVisi

; 936  : 	{
; 937  : 		CL_AddCustomBeam( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_AddCustomBeam
	add	esp, 4

; 938  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_AddVisi

; 939  : 	}

	jmp	SHORT $LN8@CL_AddVisi
$LN7@CL_AddVisi:

; 940  : 	else if( !R_AddEntity( ent, entityType ))

	mov	edx, DWORD PTR _entityType$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_R_AddEntity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@CL_AddVisi

; 941  : 	{
; 942  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_AddVisi
$LN8@CL_AddVisi:

; 943  : 	}
; 944  : 
; 945  : 	// because pTemp->entity.curstate.effects
; 946  : 	// is already occupied by FTENT_FLICKER
; 947  : 	if( entityType != ET_TEMPENTITY )

	cmp	DWORD PTR _entityType$[ebp], 2
	je	SHORT $LN10@CL_AddVisi

; 948  : 	{
; 949  : 		// no reason to do it twice
; 950  : 		if( RP_LOCALCLIENT( ent ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN11@CL_AddVisi
	mov	ecx, DWORD PTR _cl+1568828
	add	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx], ecx
	jne	SHORT $LN11@CL_AddVisi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@CL_AddVisi

; 951  : 			cl.local.apply_effects = false;

	mov	DWORD PTR _cl+1568544, 0
$LN11@CL_AddVisi:

; 952  : 
; 953  : 		// apply client-side effects
; 954  : 		CL_AddEntityEffects( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_AddEntityEffects
	add	esp, 4

; 955  : 
; 956  : 		// alias & studiomodel efefcts
; 957  : 		CL_AddModelEffects( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_AddModelEffects
	add	esp, 4
$LN10@CL_AddVisi:

; 958  : 	}
; 959  : 
; 960  : 	return true;

	mov	eax, 1
$LN1@CL_AddVisi:

; 961  : }

	pop	ebp
	ret	0
_CL_AddVisibleEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
tv230 = -52						; size = 4
_count$ = -48						; size = 4
_player$ = -44						; size = 4
_subtracted$1 = -40					; size = 4
_bufStart$ = -36					; size = 4
_oldpacket$ = -32					; size = 4
_newnum$ = -28						; size = 4
_playerbytes$ = -24					; size = 4
_oldent$ = -20						; size = 4
_oldframe$ = -16					; size = 4
_newframe$ = -12					; size = 4
_oldnum$ = -8						; size = 4
_oldindex$ = -4						; size = 4
_msg$ = 8						; size = 4
_delta$ = 12						; size = 4
_CL_ParsePacketEntities PROC

; 717  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 718  : 	frame_t		*newframe, *oldframe;
; 719  : 	int		oldindex, newnum, oldnum;
; 720  : 	int		playerbytes = 0;

	mov	DWORD PTR _playerbytes$[ebp], 0

; 721  : 	int		oldpacket;
; 722  : 	int		bufStart;
; 723  : 	entity_state_t	*oldent;
; 724  : 	qboolean		player;
; 725  : 	int		count;
; 726  : 
; 727  : 	// save first uncompressed packet as timestamp
; 728  : 	if( cls.changelevel && !delta && cls.demorecording )

	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN8@CL_ParsePa
	cmp	DWORD PTR _delta$[ebp], 0
	jne	SHORT $LN8@CL_ParsePa
	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN8@CL_ParsePa

; 729  : 		CL_WriteDemoJumpTime();

	call	_CL_WriteDemoJumpTime
$LN8@CL_ParsePa:

; 730  : 
; 731  : 	// sentinel count. save it for debug checking
; 732  : 	count = ( MSG_ReadUBitLong( msg, MAX_VISIBLE_PACKET_BITS ) + 1 );

	push	11					; 0000000bH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 733  : 	newframe = &cl.frames[cl.parsecountmod];

	imul	ecx, DWORD PTR _cl+12, 17304
	add	ecx, OFFSET _cl+88
	mov	DWORD PTR _newframe$[ebp], ecx

; 734  : 
; 735  : 	// allocate parse entities
; 736  : 	memset( newframe->flags, 0, sizeof( newframe->flags ));

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _newframe$[ebp]
	add	edx, 17038				; 0000428eH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 737  : 	newframe->first_entity = cls.next_client_entities;

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	ecx, DWORD PTR _cls+291760
	mov	DWORD PTR [eax+17300], ecx

; 738  : 	newframe->num_entities = 0;

	mov	edx, DWORD PTR _newframe$[ebp]
	mov	DWORD PTR [edx+17296], 0

; 739  : 	newframe->valid = true; // assume valid

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	DWORD PTR [eax+24], 1

; 740  : 
; 741  : 	if( delta )

	cmp	DWORD PTR _delta$[ebp], 0
	je	$LN9@CL_ParsePa

; 742  : 	{
; 743  : 		int	subtracted;
; 744  : 
; 745  : 		oldpacket = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _oldpacket$[ebp], eax

; 746  : 		subtracted = ( cls.netchan.incoming_sequence - oldpacket ) & 0xFF;

	mov	edx, DWORD PTR _cls+23584
	sub	edx, DWORD PTR _oldpacket$[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _subtracted$1[ebp], edx

; 747  : 
; 748  : 		if( subtracted == 0 )

	jne	SHORT $LN11@CL_ParsePa

; 749  : 		{
; 750  : 			Con_NPrintf( 2, "^3Warning:^1 update too old\n^7\n" );

	push	OFFSET $SG145626
	push	2
	call	_Con_NPrintf
	add	esp, 8

; 751  : 			CL_FlushEntityPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_FlushEntityPacket
	add	esp, 4

; 752  : 			return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	$LN1@CL_ParsePa
$LN11@CL_ParsePa:

; 753  : 		}
; 754  : 
; 755  : 		if( subtracted >= CL_UPDATE_MASK )

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	cmp	DWORD PTR _subtracted$1[ebp], ecx
	jl	SHORT $LN12@CL_ParsePa

; 756  : 		{	
; 757  : 			// we can't use this, it is too old
; 758  : 			Con_NPrintf( 2, "^3Warning:^1 delta frame is too old^7\n" );

	push	OFFSET $SG145628
	push	2
	call	_Con_NPrintf
	add	esp, 8

; 759  : 			CL_FlushEntityPacket( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_FlushEntityPacket
	add	esp, 4

; 760  : 			return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	$LN1@CL_ParsePa
$LN12@CL_ParsePa:

; 761  : 		}
; 762  : 
; 763  : 		oldframe = &cl.frames[oldpacket & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _oldpacket$[ebp]
	imul	ecx, eax, 17304
	add	ecx, OFFSET _cl+88
	mov	DWORD PTR _oldframe$[ebp], ecx

; 764  : 
; 765  : 		if(( cls.next_client_entities - oldframe->first_entity ) > ( cls.num_client_entities - NUM_PACKET_ENTITIES ))

	mov	edx, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR _cls+291760
	sub	eax, DWORD PTR [edx+17300]
	mov	ecx, DWORD PTR _cls+291756
	sub	ecx, 256				; 00000100H
	cmp	eax, ecx
	jle	SHORT $LN13@CL_ParsePa

; 766  : 		{
; 767  : 			Con_NPrintf( 2, "^3Warning:^1 delta frame is too old^7\n" );

	push	OFFSET $SG145630
	push	2
	call	_Con_NPrintf
	add	esp, 8

; 768  : 			CL_FlushEntityPacket( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_FlushEntityPacket
	add	esp, 4

; 769  : 			return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	$LN1@CL_ParsePa
$LN13@CL_ParsePa:

; 770  : 		}
; 771  : 	}

	jmp	SHORT $LN10@CL_ParsePa
$LN9@CL_ParsePa:

; 772  : 	else
; 773  : 	{
; 774  : 		// this is a full update that we can start delta compressing from now
; 775  : 		oldframe = NULL;

	mov	DWORD PTR _oldframe$[ebp], 0

; 776  : 		oldpacket = -1;		// delta too old or is initial message

	mov	DWORD PTR _oldpacket$[ebp], -1

; 777  : 		cl.send_reply = true;	// send reply

	mov	DWORD PTR _cl+60, 1

; 778  : 		cls.demowaiting = false;	// we can start recording now

	mov	DWORD PTR _cls+297584, 0
$LN10@CL_ParsePa:

; 779  : 	}
; 780  : 
; 781  : 	// mark current delta state
; 782  : 	cl.validsequence = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+23584
	mov	DWORD PTR _cl+4, eax

; 783  : 
; 784  : 	oldent = NULL;

	mov	DWORD PTR _oldent$[ebp], 0

; 785  : 	oldindex = 0;

	mov	DWORD PTR _oldindex$[ebp], 0

; 786  : 
; 787  : 	if( !oldframe )

	cmp	DWORD PTR _oldframe$[ebp], 0
	jne	SHORT $LN14@CL_ParsePa

; 788  : 	{
; 789  : 		oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 790  : 	}

	jmp	SHORT $LN2@CL_ParsePa
$LN14@CL_ParsePa:

; 791  : 	else
; 792  : 	{
; 793  : 		if( oldindex >= oldframe->num_entities )

	mov	ecx, DWORD PTR _oldframe$[ebp]
	mov	edx, DWORD PTR _oldindex$[ebp]
	cmp	edx, DWORD PTR [ecx+17296]
	jl	SHORT $LN16@CL_ParsePa

; 794  : 		{
; 795  : 			oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 796  : 		}

	jmp	SHORT $LN2@CL_ParsePa
$LN16@CL_ParsePa:

; 797  : 		else
; 798  : 		{
; 799  : 			oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [eax+17300]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _cls+291764
	mov	DWORD PTR _oldent$[ebp], ecx

; 800  : 			oldnum = oldent->number;

	mov	edx, DWORD PTR _oldent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldnum$[ebp], eax
$LN2@CL_ParsePa:

; 801  : 		}
; 802  : 	}
; 803  : 
; 804  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN6@CL_ParsePa

; 805  : 	{
; 806  : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 807  : 		if( newnum == LAST_EDICT ) break; // end of packet entities

	cmp	DWORD PTR _newnum$[ebp], 8191		; 00001fffH
	jne	SHORT $LN18@CL_ParsePa
	jmp	$LN6@CL_ParsePa
$LN18@CL_ParsePa:

; 808  : 
; 809  : 		if( MSG_CheckOverflow( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@CL_ParsePa

; 810  : 			Host_Error( "CL_ParsePacketEntities: overflow\n" );

	push	OFFSET $SG145637
	call	_Host_Error
	add	esp, 4
$LN19@CL_ParsePa:

; 811  : 		player = CL_IsPlayerIndex( newnum );

	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax
$LN4@CL_ParsePa:

; 812  : 
; 813  : 		while( oldnum < newnum )

	mov	edx, DWORD PTR _oldnum$[ebp]
	cmp	edx, DWORD PTR _newnum$[ebp]
	jge	SHORT $LN5@CL_ParsePa

; 814  : 		{	
; 815  : 			// one or more entities from the old packet are unchanged
; 816  : 			CL_DeltaEntity( msg, newframe, oldnum, oldent, false );

	push	0
	mov	eax, DWORD PTR _oldent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newframe$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 817  : 			oldindex++;

	mov	ecx, DWORD PTR _oldindex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _oldindex$[ebp], ecx

; 818  : 
; 819  : 			if( oldindex >= oldframe->num_entities )

	mov	edx, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR _oldindex$[ebp]
	cmp	eax, DWORD PTR [edx+17296]
	jl	SHORT $LN20@CL_ParsePa

; 820  : 			{
; 821  : 				oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 822  : 			}

	jmp	SHORT $LN21@CL_ParsePa
$LN20@CL_ParsePa:

; 823  : 			else
; 824  : 			{
; 825  : 				oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	ecx, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [ecx+17300]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	edx, edx, 340
	add	edx, DWORD PTR _cls+291764
	mov	DWORD PTR _oldent$[ebp], edx

; 826  : 				oldnum = oldent->number;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx
$LN21@CL_ParsePa:

; 827  : 			}
; 828  : 		}

	jmp	SHORT $LN4@CL_ParsePa
$LN5@CL_ParsePa:

; 829  : 
; 830  : 		if( oldnum == newnum )

	mov	edx, DWORD PTR _oldnum$[ebp]
	cmp	edx, DWORD PTR _newnum$[ebp]
	jne	$LN22@CL_ParsePa

; 831  : 		{	
; 832  : 			// delta from previous state
; 833  : 			bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 834  : 			CL_DeltaEntity( msg, newframe, newnum, oldent, true );

	push	1
	mov	ecx, DWORD PTR _oldent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _newframe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 835  : 			if( player ) playerbytes += MSG_GetNumBytesRead( msg ) - bufStart;

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN23@CL_ParsePa
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	add	eax, DWORD PTR _playerbytes$[ebp]
	mov	DWORD PTR _playerbytes$[ebp], eax
$LN23@CL_ParsePa:

; 836  : 			oldindex++;

	mov	eax, DWORD PTR _oldindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _oldindex$[ebp], eax

; 837  : 
; 838  : 			if( oldindex >= oldframe->num_entities )

	mov	ecx, DWORD PTR _oldframe$[ebp]
	mov	edx, DWORD PTR _oldindex$[ebp]
	cmp	edx, DWORD PTR [ecx+17296]
	jl	SHORT $LN24@CL_ParsePa

; 839  : 			{
; 840  : 				oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 841  : 			}

	jmp	SHORT $LN25@CL_ParsePa
$LN24@CL_ParsePa:

; 842  : 			else
; 843  : 			{
; 844  : 				oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [eax+17300]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _cls+291764
	mov	DWORD PTR _oldent$[ebp], ecx

; 845  : 				oldnum = oldent->number;

	mov	edx, DWORD PTR _oldent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldnum$[ebp], eax
$LN25@CL_ParsePa:

; 846  : 			}
; 847  : 			continue;

	jmp	$LN2@CL_ParsePa
$LN22@CL_ParsePa:

; 848  : 		}
; 849  : 
; 850  : 		if( oldnum > newnum )

	mov	ecx, DWORD PTR _oldnum$[ebp]
	cmp	ecx, DWORD PTR _newnum$[ebp]
	jle	SHORT $LN26@CL_ParsePa

; 851  : 		{	
; 852  : 			// delta from baseline ?
; 853  : 			bufStart = MSG_GetNumBytesRead( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 854  : 			CL_DeltaEntity( msg, newframe, newnum, NULL, true );

	push	1
	push	0
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newframe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 855  : 			if( player ) playerbytes += MSG_GetNumBytesRead( msg ) - bufStart;

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN27@CL_ParsePa
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	add	eax, DWORD PTR _playerbytes$[ebp]
	mov	DWORD PTR _playerbytes$[ebp], eax
$LN27@CL_ParsePa:

; 856  : 			continue;

	jmp	$LN2@CL_ParsePa
$LN26@CL_ParsePa:

; 857  : 		}
; 858  : 	}

	jmp	$LN2@CL_ParsePa
$LN6@CL_ParsePa:

; 859  : 
; 860  : 	// any remaining entities in the old frame are copied over
; 861  : 	while( oldnum != MAX_ENTNUMBER )

	cmp	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH
	je	SHORT $LN7@CL_ParsePa

; 862  : 	{	
; 863  : 		// one or more entities from the old packet are unchanged
; 864  : 		CL_DeltaEntity( msg, newframe, oldnum, oldent, false );

	push	0
	mov	ecx, DWORD PTR _oldent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _newframe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 865  : 		oldindex++;

	mov	edx, DWORD PTR _oldindex$[ebp]
	add	edx, 1
	mov	DWORD PTR _oldindex$[ebp], edx

; 866  : 
; 867  : 		if( oldindex >= oldframe->num_entities )

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _oldindex$[ebp]
	cmp	ecx, DWORD PTR [eax+17296]
	jl	SHORT $LN28@CL_ParsePa

; 868  : 		{
; 869  : 			oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 870  : 		}

	jmp	SHORT $LN29@CL_ParsePa
$LN28@CL_ParsePa:

; 871  : 		else
; 872  : 		{
; 873  : 			oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	edx, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [edx+17300]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+291756
	imul	eax, edx, 340
	add	eax, DWORD PTR _cls+291764
	mov	DWORD PTR _oldent$[ebp], eax

; 874  : 			oldnum = oldent->number;

	mov	ecx, DWORD PTR _oldent$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _oldnum$[ebp], edx
$LN29@CL_ParsePa:

; 875  : 		}
; 876  : 	}

	jmp	SHORT $LN6@CL_ParsePa
$LN7@CL_ParsePa:

; 877  : 
; 878  : 	if( newframe->num_entities != count && newframe->num_entities != 0 )

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	ecx, DWORD PTR [eax+17296]
	cmp	ecx, DWORD PTR _count$[ebp]
	je	SHORT $LN30@CL_ParsePa
	mov	edx, DWORD PTR _newframe$[ebp]
	cmp	DWORD PTR [edx+17296], 0
	je	SHORT $LN30@CL_ParsePa

; 879  : 		Con_Reportf( S_WARN "CL_Parse%sPacketEntities: (%i should be %i)\n", delta ? "Delta" : "", newframe->num_entities, count );

	cmp	DWORD PTR _delta$[ebp], 0
	je	SHORT $LN34@CL_ParsePa
	mov	DWORD PTR tv230[ebp], OFFSET $SG145649
	jmp	SHORT $LN35@CL_ParsePa
$LN34@CL_ParsePa:
	mov	DWORD PTR tv230[ebp], OFFSET $SG145650
$LN35@CL_ParsePa:
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newframe$[ebp]
	mov	edx, DWORD PTR [ecx+17296]
	push	edx
	mov	eax, DWORD PTR tv230[ebp]
	push	eax
	push	OFFSET $SG145651
	call	_Con_Reportf
	add	esp, 16					; 00000010H
$LN30@CL_ParsePa:

; 880  : 
; 881  : 	if( !newframe->valid )

	mov	ecx, DWORD PTR _newframe$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN31@CL_ParsePa

; 882  : 		return playerbytes; // frame is not valid but message was parsed

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	SHORT $LN1@CL_ParsePa
$LN31@CL_ParsePa:

; 883  : 
; 884  : 	// now process packet.
; 885  : 	CL_ProcessPacket( newframe );

	mov	edx, DWORD PTR _newframe$[ebp]
	push	edx
	call	_CL_ProcessPacket
	add	esp, 4

; 886  : 
; 887  : 	// add new entities into physic lists
; 888  : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 889  : 
; 890  : 	// first update is the final signon stage where we actually receive an entity (i.e., the world at least)
; 891  : 	if( cls.signon == ( SIGNONS - 1 ))

	cmp	DWORD PTR _cls+64, 1
	jne	SHORT $LN32@CL_ParsePa

; 892  : 	{	
; 893  : 		// we are done with signon sequence.
; 894  : 		cls.signon = SIGNONS;

	mov	DWORD PTR _cls+64, 2

; 895  : 		
; 896  : 		// Clear loading plaque.
; 897  : 		CL_SignonReply ();

	call	_CL_SignonReply
$LN32@CL_ParsePa:

; 898  : 	}
; 899  : 
; 900  : 	return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
$LN1@CL_ParsePa:

; 901  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParsePacketEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 853  : {

	push	ebp
	mov	ebp, esp

; 854  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1012
	jge	SHORT $LN2@CL_EDICT_N

; 855  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3000
	add	eax, DWORD PTR _clgame+1000
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 856  : 
; 857  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 858  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 859  : }

	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_frame.c
_TEXT	SEGMENT
_CL_ExtraUpdate PROC

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 : 	clgame.dllFuncs.IN_Accumulate();

	call	DWORD PTR _clgame+56

; 1387 : 	S_ExtraUpdate();

	call	_S_ExtraUpdate

; 1388 : }

	pop	ebp
	ret	0
_CL_ExtraUpdate ENDP
_TEXT	ENDS
END
