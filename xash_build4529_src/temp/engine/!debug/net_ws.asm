; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\net_ws.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_winsock_dll
_BSS	SEGMENT
_pWSACleanup DD	01H DUP (?)
_pNtohs	DD	01H DUP (?)
_pWSAGetLastError DD 01H DUP (?)
_pCloseSocket DD 01H DUP (?)
_pHtons	DD	01H DUP (?)
_pInet_Addr DD	01H DUP (?)
_pInet_Ntoa DD	01H DUP (?)
_pSocket DD	01H DUP (?)
_pGetHostByName DD 01H DUP (?)
_pIoctlSocket DD 01H DUP (?)
_pWSAStartup DD	01H DUP (?)
_pBind	DD	01H DUP (?)
_pSetSockopt DD	01H DUP (?)
_pRecvFrom DD	01H DUP (?)
_pSendTo DD	01H DUP (?)
_pSelect DD	01H DUP (?)
_pConnect DD	01H DUP (?)
_pGetSockName DD 01H DUP (?)
_pSend	DD	01H DUP (?)
_pRecv	DD	01H DUP (?)
_pGetHostName DD 01H DUP (?)
_pNtohl	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_net_clockwindow:DWORD
COMM	_net_local:BYTE:014H
_DATA	ENDS
_DATA	SEGMENT
_winsock_funcs DD FLAT:$SG132114
	DD	FLAT:_pBind
	DD	FLAT:$SG132115
	DD	FLAT:_pSend
	DD	FLAT:$SG132116
	DD	FLAT:_pRecv
	DD	FLAT:$SG132117
	DD	FLAT:_pNtohs
	DD	FLAT:$SG132118
	DD	FLAT:_pHtons
	DD	FLAT:$SG132119
	DD	FLAT:_pNtohl
	DD	FLAT:$SG132120
	DD	FLAT:_pSocket
	DD	FLAT:$SG132121
	DD	FLAT:_pSelect
	DD	FLAT:$SG132122
	DD	FLAT:_pSendTo
	DD	FLAT:$SG132123
	DD	FLAT:_pConnect
	DD	FLAT:$SG132124
	DD	FLAT:_pRecvFrom
	DD	FLAT:$SG132125
	DD	FLAT:_pInet_Addr
	DD	FLAT:$SG132126
	DD	FLAT:_pInet_Ntoa
	DD	FLAT:$SG132127
	DD	FLAT:_pWSAStartup
	DD	FLAT:$SG132128
	DD	FLAT:_pWSACleanup
	DD	FLAT:$SG132129
	DD	FLAT:_pSetSockopt
	DD	FLAT:$SG132130
	DD	FLAT:_pIoctlSocket
	DD	FLAT:$SG132131
	DD	FLAT:_pCloseSocket
	DD	FLAT:$SG132132
	DD	FLAT:_pGetHostName
	DD	FLAT:$SG132133
	DD	FLAT:_pGetSockName
	DD	FLAT:$SG132134
	DD	FLAT:_pGetHostByName
	DD	FLAT:$SG132135
	DD	FLAT:_pWSAGetLastError
	DD	00H
	DD	00H
$SG132114 DB	'bind', 00H
	ORG $+3
$SG132115 DB	'send', 00H
	ORG $+3
$SG132116 DB	'recv', 00H
	ORG $+3
$SG132117 DB	'ntohs', 00H
	ORG $+2
$SG132118 DB	'htons', 00H
	ORG $+2
$SG132119 DB	'ntohl', 00H
	ORG $+2
$SG132120 DB	'socket', 00H
	ORG $+1
$SG132121 DB	'select', 00H
	ORG $+1
$SG132122 DB	'sendto', 00H
	ORG $+1
$SG132123 DB	'connect', 00H
$SG132124 DB	'recvfrom', 00H
	ORG $+3
$SG132125 DB	'inet_addr', 00H
	ORG $+2
$SG132126 DB	'inet_ntoa', 00H
	ORG $+2
$SG132127 DB	'WSAStartup', 00H
	ORG $+1
$SG132128 DB	'WSACleanup', 00H
	ORG $+1
$SG132129 DB	'setsockopt', 00H
	ORG $+1
$SG132130 DB	'ioctlsocket', 00H
$SG132131 DB	'closesocket', 00H
$SG132132 DB	'gethostname', 00H
$SG132133 DB	'getsockname', 00H
$SG132134 DB	'gethostbyname', 00H
	ORG $+2
$SG132135 DB	'WSAGetLastError', 00H
_winsock_dll DD	FLAT:$SG132137
	DD	FLAT:_winsock_funcs
	DD	00H
	ORG $+4
$SG132137 DB	'wsock32.dll', 00H
_DATA	ENDS
PUBLIC	_NET_Init
PUBLIC	_NET_Shutdown
PUBLIC	_NET_Sleep
PUBLIC	_NET_IsActive
PUBLIC	_NET_IsConfigured
PUBLIC	_NET_Config
PUBLIC	_NET_IsLocalAddress
PUBLIC	_NET_AdrToString
PUBLIC	_NET_BaseAdrToString
PUBLIC	_NET_IsReservedAdr
PUBLIC	_NET_CompareClassBAdr
PUBLIC	_NET_StringToAdr
PUBLIC	_NET_CompareAdr
PUBLIC	_NET_CompareBaseAdr
PUBLIC	_NET_GetPacket
PUBLIC	_NET_BufferToBufferCompress
PUBLIC	_NET_BufferToBufferDecompress
PUBLIC	_NET_SendPacket
PUBLIC	_NET_ClearLagData
PUBLIC	_NET_OpenWinSock
PUBLIC	_NET_FreeWinSock
PUBLIC	_NET_ErrorString
PUBLIC	_NET_GetLong
PUBLIC	_NET_QueuePacket
PUBLIC	_NET_SendLong
PUBLIC	_NET_GetLocalAddress
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@4069000000000000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_LoadLibrary:PROC
EXTRN	_Sys_FreeLibrary:PROC
EXTRN	__Sys_GetParmFromCmdLine:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_isdigit:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_LZSS_IsCompressed:PROC
EXTRN	_LZSS_GetActualSize:PROC
EXTRN	_LZSS_Compress:PROC
EXTRN	_LZSS_Decompress:PROC
EXTRN	_fabs:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host_developer:BYTE
EXTRN	_net_showpackets:DWORD
EXTRN	_host:BYTE
EXTRN	_net_from:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_net	DB	011047cH DUP (?)
_net_ipname DD	01H DUP (?)
_net_hostport DD 01H DUP (?)
_net_iphostport DD 01H DUP (?)
_net_clientport DD 01H DUP (?)
_net_ipclientport DD 01H DUP (?)
_net_fakelag DD	01H DUP (?)
_net_fakeloss DD 01H DUP (?)
_net_address DD	01H DUP (?)
	ALIGN	8

?lasttime@?1??NET_AdjustLag@@9@9 DQ 01H DUP (?)		; `NET_AdjustLag'::`2'::lasttime
?old_config@?1??NET_Config@@9@9 DD 01H DUP (?)		; `NET_Config'::`2'::old_config
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG132205 DB	'WSAEINTR', 00H
	ORG $+3
$SG132207 DB	'WSAEBADF', 00H
	ORG $+3
$SG132209 DB	'WSAEACCES', 00H
	ORG $+2
$SG132211 DB	'WSAEDISCON', 00H
	ORG $+1
$SG132213 DB	'WSAEFAULT', 00H
	ORG $+2
$SG132215 DB	'WSAEINVAL', 00H
	ORG $+2
$SG132217 DB	'WSAEMFILE', 00H
	ORG $+2
$SG132219 DB	'WSAEWOULDBLOCK', 00H
	ORG $+1
$SG132221 DB	'WSAEINPROGRESS', 00H
	ORG $+1
$SG132223 DB	'WSAEALREADY', 00H
$SG132225 DB	'WSAENOTSOCK', 00H
$SG132227 DB	'WSAEDESTADDRREQ', 00H
$SG132229 DB	'WSAEMSGSIZE', 00H
$SG132231 DB	'WSAEPROTOTYPE', 00H
	ORG $+2
$SG132233 DB	'WSAENOPROTOOPT', 00H
	ORG $+1
$SG132235 DB	'WSAEPROTONOSUPPORT', 00H
	ORG $+1
$SG132237 DB	'WSAESOCKTNOSUPPORT', 00H
	ORG $+1
$SG132239 DB	'WSAEOPNOTSUPP', 00H
	ORG $+2
$SG132241 DB	'WSAEPFNOSUPPORT', 00H
$SG132243 DB	'WSAEAFNOSUPPORT', 00H
$SG132245 DB	'WSAEADDRINUSE', 00H
	ORG $+2
$SG132247 DB	'WSAEADDRNOTAVAIL', 00H
	ORG $+3
$SG132249 DB	'WSAENETDOWN', 00H
$SG132251 DB	'WSAENETUNREACH', 00H
	ORG $+1
$SG132253 DB	'WSAENETRESET', 00H
	ORG $+3
$SG132255 DB	'WSWSAECONNABORTEDAEINTR', 00H
$SG132257 DB	'WSAECONNRESET', 00H
	ORG $+2
$SG132259 DB	'WSAENOBUFS', 00H
	ORG $+1
$SG132261 DB	'WSAEISCONN', 00H
	ORG $+1
$SG132263 DB	'WSAENOTCONN', 00H
$SG132265 DB	'WSAESHUTDOWN', 00H
	ORG $+3
$SG132267 DB	'WSAETOOMANYREFS', 00H
$SG132269 DB	'WSAETIMEDOUT', 00H
	ORG $+3
$SG132271 DB	'WSAECONNREFUSED', 00H
$SG132273 DB	'WSAELOOP', 00H
	ORG $+3
$SG132275 DB	'WSAENAMETOOLONG', 00H
$SG132277 DB	'WSAEHOSTDOWN', 00H
	ORG $+3
$SG132279 DB	'WSASYSNOTREADY', 00H
	ORG $+1
$SG132281 DB	'WSAVERNOTSUPPORTED', 00H
	ORG $+1
$SG132283 DB	'WSANOTINITIALISED', 00H
	ORG $+2
$SG132285 DB	'WSAHOST_NOT_FOUND', 00H
	ORG $+2
$SG132287 DB	'WSATRY_AGAIN', 00H
	ORG $+3
$SG132289 DB	'WSANO_RECOVERY', 00H
	ORG $+1
$SG132291 DB	'WSANO_DATA', 00H
	ORG $+1
$SG132293 DB	'NO ERROR', 00H
	ORG $+3
$SG132352 DB	'loopback', 00H
	ORG $+3
$SG132353 DB	'%i.%i.%i.%i:%i', 00H
	ORG $+1
$SG132358 DB	'loopback', 00H
	ORG $+3
$SG132359 DB	'%i.%i.%i.%i', 00H
$SG132397 DB	'^1Error:^7 NET_CompareAdr: bad address type', 0aH, 00H
	ORG $+3
$SG132409 DB	'localhost', 00H
	ORG $+2
$SG132458 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_ws.c', 00H
	ORG $+2
$SG132496 DB	'Server must enable dev-mode to activate fakelag', 0aH, 00H
	ORG $+3
$SG132459 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_ws.c', 00H
	ORG $+2
$SG132497 DB	'fakelag', 00H
$SG132529 DB	'fakeloss', 00H
	ORG $+3
$SG132481 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_ws.c', 00H
	ORG $+2
$SG132564 DB	'^1Error:^7 invalid split packet length %i', 0aH, 00H
	ORG $+1
$SG132530 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_ws.c', 00H
	ORG $+2
$SG132567 DB	'^1Error:^7 malformed packet number (%i/%i)', 0aH, 00H
$SG132534 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_ws.c', 00H
	ORG $+2
$SG132571 DB	'<-- Split packet restart %i count %i seq', 0aH, 00H
	ORG $+2
$SG132535 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\net_ws.c', 00H
	ORG $+2
$SG132576 DB	'<-- Split packet %i of %i, %i bytes %i seq', 0aH, 00H
$SG132577 DB	'NET_GetLong: Ignoring duplicated split packet %i of %i ('
	DB	' %i bytes )', 0aH, 00H
	ORG $+3
$SG132580 DB	'Split packet too large! %d bytes', 0aH, 00H
	ORG $+2
$SG132608 DB	'NET_QueuePacket: oversize packet from %s', 0aH, 00H
	ORG $+2
$SG132611 DB	'^1Error:^7 NET_QueuePacket: %s from %s', 0aH, 00H
$SG132665 DB	'NET_SendPacket: bad address type %i', 0aH, 00H
	ORG $+3
$SG132671 DB	'^1Error:^7 NET_SendPacket: %s to %s', 0aH, 00H
	ORG $+3
$SG132675 DB	'^1Error:^7 NET_SendPacket: %s to %s', 0aH, 00H
	ORG $+3
$SG132676 DB	'NET_SendPacket: %s to %s', 0aH, 00H
	ORG $+2
$SG132736 DB	'^3Warning:^7 NET_UDPSocket: port: %d socket: %s', 0aH, 00H
	ORG $+3
$SG132738 DB	'^3Warning:^7 NET_UDPSocket: port: %d ioctl FIONBIO: %s', 0aH
	DB	00H
$SG132740 DB	'^3Warning:^7 NET_UDPSocket: port: %d setsockopt SO_BROAD'
	DB	'CAST: %s', 0aH, 00H
	ORG $+2
$SG132743 DB	'-reuse', 00H
	ORG $+1
$SG132755 DB	'localhost', 00H
	ORG $+2
$SG132745 DB	'^3Warning:^7 NET_UDPSocket: port: %d setsockopt SO_REUSE'
	DB	'ADDR: %s', 0aH, 00H
	ORG $+2
$SG132747 DB	'-tos', 00H
	ORG $+3
$SG132748 DB	'Enabling LOWDELAY TOS option', 0aH, 00H
	ORG $+2
$SG132751 DB	'^3Warning:^7 NET_UDPSocket: port: %d  setsockopt IP_TOS:'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG132759 DB	'^3Warning:^7 NET_UDPSocket: port: %d bind: %s', 0aH, 00H
	ORG $+1
$SG132761 DB	'-loopback', 00H
	ORG $+2
$SG132763 DB	'^3Warning:^7 NET_UDPSocket: port %d setsockopt IP_MULTIC'
	DB	'AST_LOOP: %s', 0aH, 00H
	ORG $+2
$SG132778 DB	'Couldn''t allocate dedicated server IP port %d.', 0aH, 00H
$SG132798 DB	'localhost', 00H
	ORG $+2
$SG132803 DB	'^1Error:^7 Could not get TCP/IP address. Reason:  %s', 0aH
	DB	00H
	ORG $+2
$SG132804 DB	'Server IP address %s', 0aH, 00H
	ORG $+2
$SG132805 DB	'net_address', 00H
$SG132806 DB	'^1Error:^7 Could not get TCP/IP address, Invalid hostnam'
	DB	'e: ''%s''', 0aH, 00H
	ORG $+3
$SG132807 DB	'TCP/IP Disabled.', 0aH, 00H
	ORG $+2
?bFirst@?1??NET_Config@@9@9 DD 01H			; `NET_Config'::`2'::bFirst
$SG132874 DB	'timewindow to execute client moves', 00H
	ORG $+1
$SG132875 DB	'0.5', 00H
$SG132876 DB	'clockwindow', 00H
$SG132877 DB	'contain local address of current client', 00H
$SG132878 DB	'0', 00H
	ORG $+2
$SG132879 DB	'net_address', 00H
$SG132880 DB	'network ip address', 00H
	ORG $+1
$SG132881 DB	'localhost', 00H
	ORG $+2
$SG132882 DB	'ip', 00H
	ORG $+1
$SG132883 DB	'network ip host port', 00H
	ORG $+3
$SG132884 DB	'0', 00H
	ORG $+2
$SG132885 DB	'ip_hostport', 00H
$SG132886 DB	'network default host port', 00H
	ORG $+2
$SG132887 DB	'%i', 00H
	ORG $+1
$SG132888 DB	'hostport', 00H
	ORG $+3
$SG132889 DB	'network ip client port', 00H
	ORG $+1
$SG132890 DB	'0', 00H
	ORG $+2
$SG132891 DB	'ip_clientport', 00H
	ORG $+2
$SG132892 DB	'network default client port', 00H
$SG132893 DB	'%i', 00H
	ORG $+1
$SG132894 DB	'clientport', 00H
	ORG $+1
$SG132895 DB	'lag all incoming network data (including loopback) by xx'
	DB	'x ms.', 00H
	ORG $+2
$SG132896 DB	'0', 00H
	ORG $+2
$SG132897 DB	'fakelag', 00H
$SG132898 DB	'act like we dropped the packet this % of the time.', 00H
	ORG $+1
$SG132899 DB	'0', 00H
	ORG $+2
$SG132900 DB	'fakeloss', 00H
	ORG $+3
$SG132902 DB	'^1Error:^7 network failed to load wsock32.dll.', 0aH, 00H
$SG132904 DB	'^1Error:^7 network initialization failed.', 0aH, 00H
	ORG $+1
$SG132907 DB	'-noip', 00H
	ORG $+2
$SG132909 DB	'-port', 00H
	ORG $+2
$SG132910 DB	'hostport', 00H
	ORG $+3
$SG132912 DB	'-clockwindow', 00H
	ORG $+3
$SG132913 DB	'clockwindow', 00H
$SG132914 DB	'Base networking initialized.', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_namelen$ = -544					; size = 4
$T1 = -540						; size = 4
$T2 = -536						; size = 4
_address$ = -532					; size = 16
_buff$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_NET_GetLocalAddress PROC

; 1267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1268 : 	char		buff[512];
; 1269 : 	struct sockaddr_in	address;
; 1270 : 	int		namelen;
; 1271 : 
; 1272 : 	memset( &net_local, 0, sizeof( netadr_t ));

	push	20					; 00000014H
	push	0
	push	OFFSET _net_local
	call	_memset
	add	esp, 12					; 0000000cH

; 1273 : 	buff[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 512			; 00000200H
	jae	SHORT $LN11@NET_GetLoc
	jmp	SHORT $LN12@NET_GetLoc
$LN11@NET_GetLoc:
	call	___report_rangecheckfailure
$LN12@NET_GetLoc:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _buff$[ebp+edx], 0

; 1274 : 
; 1275 : 	if( net.allow_ip )

	cmp	DWORD PTR _net+1115256, 0
	je	$LN2@NET_GetLoc

; 1276 : 	{
; 1277 : 		// If we have changed the ip var from the command line, use that instead.
; 1278 : 		if( Q_strcmp( net_ipname->string, "localhost" ))

	push	99999					; 0001869fH
	push	OFFSET $SG132798
	mov	eax, DWORD PTR _net_ipname
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@NET_GetLoc

; 1279 : 		{
; 1280 : 			Q_strcpy( buff, net_ipname->string );

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _net_ipname
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1281 : 		}

	jmp	SHORT $LN5@NET_GetLoc
$LN4@NET_GetLoc:

; 1282 : 		else
; 1283 : 		{
; 1284 : 			pGetHostName( buff, 512 );

	push	512					; 00000200H
	lea	edx, DWORD PTR _buff$[ebp]
	push	edx
	call	DWORD PTR _pGetHostName
$LN5@NET_GetLoc:

; 1285 : 		}
; 1286 : 
; 1287 : 		// ensure that it doesn't overrun the buffer
; 1288 : 		buff[511] = 0;

	mov	eax, 1
	imul	ecx, eax, 511
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 512			; 00000200H
	jae	SHORT $LN13@NET_GetLoc
	jmp	SHORT $LN14@NET_GetLoc
$LN13@NET_GetLoc:
	call	___report_rangecheckfailure
$LN14@NET_GetLoc:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _buff$[ebp+edx], 0

; 1289 : 
; 1290 : 		if( NET_StringToAdr( buff, &net_local ))

	push	OFFSET _net_local
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	je	$LN6@NET_GetLoc

; 1291 : 		{
; 1292 : 			namelen = sizeof( address );

	mov	DWORD PTR _namelen$[ebp], 16		; 00000010H

; 1293 : 
; 1294 : 			if( pGetSockName( net.ip_sockets[NS_SERVER], (struct sockaddr *)&address, &namelen ) == SOCKET_ERROR )

	lea	ecx, DWORD PTR _namelen$[ebp]
	push	ecx
	lea	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _net[eax+1114840]
	push	ecx
	call	DWORD PTR _pGetSockName
	cmp	eax, -1
	jne	SHORT $LN8@NET_GetLoc

; 1295 : 			{
; 1296 : 				// this may happens if multiple clients running on single machine
; 1297 : 				Con_DPrintf( S_ERROR "Could not get TCP/IP address. Reason:  %s\n", NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	push	OFFSET $SG132803
	call	_Con_DPrintf
	add	esp, 8

; 1298 : //				net.allow_ip = false;
; 1299 : 			}

	jmp	$LN9@NET_GetLoc
$LN8@NET_GetLoc:

; 1300 : 			else
; 1301 : 			{
; 1302 : 				net_local.port = address.sin_port;

	mov	dx, WORD PTR _address$[ebp+2]
	mov	WORD PTR _net_local+18, dx

; 1303 : 				Con_Printf( "Server IP address %s\n", NET_AdrToString( net_local ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG132804
	call	_Con_Printf
	add	esp, 8

; 1304 : 				Cvar_FullSet( "net_address", va( NET_AdrToString( net_local )), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _net_local
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _net_local+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _net_local+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _net_local+12
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _net_local+16
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_va
	add	esp, 4
	push	eax
	push	OFFSET $SG132805
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN9@NET_GetLoc:

; 1305 : 			}
; 1306 : 		}

	jmp	SHORT $LN7@NET_GetLoc
$LN6@NET_GetLoc:

; 1307 : 		else
; 1308 : 		{
; 1309 : 			Con_DPrintf( S_ERROR "Could not get TCP/IP address, Invalid hostname: '%s'\n", buff );

	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	push	OFFSET $SG132806
	call	_Con_DPrintf
	add	esp, 8
$LN7@NET_GetLoc:

; 1310 : 		}
; 1311 : 	}

	jmp	SHORT $LN10@NET_GetLoc
$LN2@NET_GetLoc:

; 1312 : 	else
; 1313 : 	{
; 1314 : 		Con_Printf( "TCP/IP Disabled.\n" );

	push	OFFSET $SG132807
	call	_Con_Printf
	add	esp, 4
$LN10@NET_GetLoc:

; 1315 : 	}
; 1316 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetLocalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_cl_port$ = -12						; size = 4
_sv_port$ = -8						; size = 4
_port$ = -4						; size = 4
_NET_OpenIP PROC

; 1228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1229 : 	int	port, sv_port = 0, cl_port = 0;

	mov	DWORD PTR _sv_port$[ebp], 0
	mov	DWORD PTR _cl_port$[ebp], 0

; 1230 : 
; 1231 : 	if( net.ip_sockets[NS_SERVER] == INVALID_SOCKET )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _net[eax+1114840], -1
	jne	$LN2@NET_OpenIP

; 1232 : 	{
; 1233 : 		port = net_iphostport->value;

	mov	ecx, DWORD PTR _net_iphostport
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _port$[ebp], edx

; 1234 : 		if( !port ) port = net_hostport->value;

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN3@NET_OpenIP
	mov	eax, DWORD PTR _net_hostport
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _port$[ebp], ecx
$LN3@NET_OpenIP:

; 1235 : 		if( !port ) port = PORT_SERVER; // forcing to default

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN4@NET_OpenIP
	mov	DWORD PTR _port$[ebp], 27015		; 00006987H
$LN4@NET_OpenIP:

; 1236 : 		net.ip_sockets[NS_SERVER] = NET_IPSocket( net_ipname->string, port, false );

	push	0
	mov	edx, DWORD PTR _port$[ebp]
	push	edx
	mov	eax, DWORD PTR _net_ipname
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_NET_IPSocket
	add	esp, 12					; 0000000cH
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _net[edx+1114840], eax

; 1237 : 
; 1238 : 		if( net.ip_sockets[NS_SERVER] == INVALID_SOCKET && host.type == HOST_DEDICATED )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _net[eax+1114840], -1
	jne	SHORT $LN5@NET_OpenIP
	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@NET_OpenIP

; 1239 : 			Host_Error( "Couldn't allocate dedicated server IP port %d.\n", port );

	mov	ecx, DWORD PTR _port$[ebp]
	push	ecx
	push	OFFSET $SG132778
	call	_Host_Error
	add	esp, 8
$LN5@NET_OpenIP:

; 1240 : 		sv_port = port;

	mov	edx, DWORD PTR _port$[ebp]
	mov	DWORD PTR _sv_port$[ebp], edx
$LN2@NET_OpenIP:

; 1241 : 	}
; 1242 : 
; 1243 : 	// dedicated servers don't need client ports
; 1244 : 	if( host.type == HOST_DEDICATED ) return;

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN6@NET_OpenIP
	jmp	$LN7@NET_OpenIP
$LN6@NET_OpenIP:

; 1245 : 
; 1246 : 	if( net.ip_sockets[NS_CLIENT] == INVALID_SOCKET )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _net[ecx+1114840], -1
	jne	$LN7@NET_OpenIP

; 1247 : 	{
; 1248 : 		port = net_ipclientport->value;

	mov	edx, DWORD PTR _net_ipclientport
	cvttss2si eax, DWORD PTR [edx+12]
	mov	DWORD PTR _port$[ebp], eax

; 1249 : 		if( !port ) port = net_clientport->value;

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN8@NET_OpenIP
	mov	ecx, DWORD PTR _net_clientport
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _port$[ebp], edx
$LN8@NET_OpenIP:

; 1250 : 		if( !port ) port = PORT_ANY; // forcing to default

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN9@NET_OpenIP
	mov	DWORD PTR _port$[ebp], -1
$LN9@NET_OpenIP:

; 1251 : 		net.ip_sockets[NS_CLIENT] = NET_IPSocket( net_ipname->string, port, false );

	push	0
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_ipname
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_NET_IPSocket
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _net[edx+1114840], eax

; 1252 : 
; 1253 : 		if( net.ip_sockets[NS_CLIENT] == INVALID_SOCKET )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _net[ecx+1114840], -1
	jne	SHORT $LN10@NET_OpenIP

; 1254 : 			net.ip_sockets[NS_CLIENT] = NET_IPSocket( net_ipname->string, PORT_ANY, false );

	push	0
	push	-1
	mov	edx, DWORD PTR _net_ipname
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_NET_IPSocket
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _net[edx+1114840], eax
$LN10@NET_OpenIP:

; 1255 : 		cl_port = port;

	mov	eax, DWORD PTR _port$[ebp]
	mov	DWORD PTR _cl_port$[ebp], eax
$LN7@NET_OpenIP:

; 1256 : 	}
; 1257 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_OpenIP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_err$ = -32						; size = 4
_optval$ = -28						; size = 4
_net_socket$ = -24					; size = 4
_addr$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_net_interface$ = 8					; size = 4
_port$ = 12						; size = 4
_multicast$ = 16					; size = 4
_NET_IPSocket PROC

; 1143 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1144 : 	int		err, net_socket;
; 1145 : 	uint		optval = 1;

	mov	DWORD PTR _optval$[ebp], 1

; 1146 : 	struct sockaddr_in	addr;
; 1147 : 
; 1148 : 	if(( net_socket = pSocket( PF_INET, SOCK_DGRAM, IPPROTO_UDP )) == SOCKET_ERROR )

	push	17					; 00000011H
	push	2
	push	2
	call	DWORD PTR _pSocket
	mov	DWORD PTR _net_socket$[ebp], eax
	cmp	DWORD PTR _net_socket$[ebp], -1
	jne	SHORT $LN2@NET_IPSock

; 1149 : 	{
; 1150 : 		err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 1151 : 		if( err != WSAEAFNOSUPPORT )

	cmp	DWORD PTR _err$[ebp], 10047		; 0000273fH
	je	SHORT $LN3@NET_IPSock

; 1152 : 			Con_DPrintf( S_WARN "NET_UDPSocket: port: %d socket: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET $SG132736
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN3@NET_IPSock:

; 1153 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN2@NET_IPSock:

; 1154 : 	}
; 1155 : 
; 1156 : 	if( pIoctlSocket( net_socket, FIONBIO, &optval ) == SOCKET_ERROR )

	lea	ecx, DWORD PTR _optval$[ebp]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	DWORD PTR _pIoctlSocket
	cmp	eax, -1
	jne	SHORT $LN4@NET_IPSock

; 1157 : 	{
; 1158 : 		Con_DPrintf( S_WARN "NET_UDPSocket: port: %d ioctl FIONBIO: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET $SG132738
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1159 : 		pCloseSocket( net_socket );

	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pCloseSocket

; 1160 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN4@NET_IPSock:

; 1161 : 	}
; 1162 : 
; 1163 : 	// make it broadcast capable
; 1164 : 	if( pSetSockopt( net_socket, SOL_SOCKET, SO_BROADCAST, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	edx, DWORD PTR _optval$[ebp]
	push	edx
	push	32					; 00000020H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN5@NET_IPSock

; 1165 : 	{
; 1166 : 		Con_DPrintf( S_WARN "NET_UDPSocket: port: %d setsockopt SO_BROADCAST: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	ecx, DWORD PTR _port$[ebp]
	push	ecx
	push	OFFSET $SG132740
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1167 : 		pCloseSocket( net_socket );

	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	DWORD PTR _pCloseSocket

; 1168 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN5@NET_IPSock:

; 1169 : 	}
; 1170 : 
; 1171 : 	if( Sys_CheckParm( "-reuse" ) || multicast )

	push	OFFSET $SG132743
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@NET_IPSock
	cmp	DWORD PTR _multicast$[ebp], 0
	je	SHORT $LN6@NET_IPSock
$LN7@NET_IPSock:

; 1172 : 	{
; 1173 : 		if( pSetSockopt( net_socket, SOL_SOCKET, SO_REUSEADDR, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	eax, DWORD PTR _optval$[ebp]
	push	eax
	push	4
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN6@NET_IPSock

; 1174 : 		{
; 1175 : 			Con_DPrintf( S_WARN "NET_UDPSocket: port: %d setsockopt SO_REUSEADDR: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	edx, DWORD PTR _port$[ebp]
	push	edx
	push	OFFSET $SG132745
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1176 : 			pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1177 : 			return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN6@NET_IPSock:

; 1178 : 		}
; 1179 : 	}
; 1180 : 
; 1181 : 	if( Sys_CheckParm( "-tos" ))

	push	OFFSET $SG132747
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@NET_IPSock

; 1182 : 	{
; 1183 : 		optval = 16;

	mov	DWORD PTR _optval$[ebp], 16		; 00000010H

; 1184 : 		Con_Printf( "Enabling LOWDELAY TOS option\n" );

	push	OFFSET $SG132748
	call	_Con_Printf
	add	esp, 4

; 1185 : 
; 1186 : 		if( pSetSockopt( net_socket, IPPROTO_IP, IP_TOS, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	ecx, DWORD PTR _optval$[ebp]
	push	ecx
	push	8
	push	0
	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN9@NET_IPSock

; 1187 : 		{
; 1188 : 			err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 1189 : 			if( err != WSAENOPROTOOPT )

	cmp	DWORD PTR _err$[ebp], 10042		; 0000273aH
	je	SHORT $LN11@NET_IPSock

; 1190 : 				Con_Printf( S_WARN "NET_UDPSocket: port: %d  setsockopt IP_TOS: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET $SG132751
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN11@NET_IPSock:

; 1191 : 			pCloseSocket( net_socket );

	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pCloseSocket

; 1192 : 			return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN9@NET_IPSock:

; 1193 : 		}
; 1194 : 	}
; 1195 : 
; 1196 : 	if( !net_interface[0] || !Q_stricmp( net_interface, "localhost" ))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _net_interface$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN14@NET_IPSock
	push	99999					; 0001869fH
	push	OFFSET $SG132755
	mov	eax, DWORD PTR _net_interface$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@NET_IPSock
$LN14@NET_IPSock:

; 1197 : 		addr.sin_addr.s_addr = INADDR_ANY;

	mov	DWORD PTR _addr$[ebp+4], 0
	jmp	SHORT $LN13@NET_IPSock
$LN12@NET_IPSock:

; 1198 : 	else NET_StringToSockaddr( net_interface, (struct sockaddr *)&addr );

	lea	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _net_interface$[ebp]
	push	edx
	call	_NET_StringToSockaddr
	add	esp, 8
$LN13@NET_IPSock:

; 1199 : 
; 1200 : 	if( port == PORT_ANY ) addr.sin_port = 0;

	cmp	DWORD PTR _port$[ebp], -1
	jne	SHORT $LN15@NET_IPSock
	xor	eax, eax
	mov	WORD PTR _addr$[ebp+2], ax
	jmp	SHORT $LN16@NET_IPSock
$LN15@NET_IPSock:

; 1201 : 	else addr.sin_port = pHtons((short)port);

	movzx	ecx, WORD PTR _port$[ebp]
	push	ecx
	call	DWORD PTR _pHtons
	mov	WORD PTR _addr$[ebp+2], ax
$LN16@NET_IPSock:

; 1202 : 
; 1203 : 	addr.sin_family = AF_INET;

	mov	edx, 2
	mov	WORD PTR _addr$[ebp], dx

; 1204 : 
; 1205 : 	if( pBind( net_socket, (void *)&addr, sizeof( addr )) == SOCKET_ERROR )

	push	16					; 00000010H
	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pBind
	cmp	eax, -1
	jne	SHORT $LN17@NET_IPSock

; 1206 : 	{
; 1207 : 		Con_DPrintf( S_WARN "NET_UDPSocket: port: %d bind: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	edx, DWORD PTR _port$[ebp]
	push	edx
	push	OFFSET $SG132759
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1208 : 		pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1209 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN1@NET_IPSock
$LN17@NET_IPSock:

; 1210 : 	}
; 1211 : 
; 1212 : 	if( Sys_CheckParm( "-loopback" ))

	push	OFFSET $SG132761
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@NET_IPSock

; 1213 : 	{
; 1214 : 		optval = 1;

	mov	DWORD PTR _optval$[ebp], 1

; 1215 : 		if( pSetSockopt( net_socket, IPPROTO_IP, IP_MULTICAST_LOOP, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	ecx, DWORD PTR _optval$[ebp]
	push	ecx
	push	4
	push	0
	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN18@NET_IPSock

; 1216 : 			Con_DPrintf( S_WARN "NET_UDPSocket: port %d setsockopt IP_MULTICAST_LOOP: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET $SG132763
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN18@NET_IPSock:

; 1217 : 	}
; 1218 : 
; 1219 : 	return net_socket;

	mov	eax, DWORD PTR _net_socket$[ebp]
$LN1@NET_IPSock:

; 1220 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IPSocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_net_socket$ = 12					; size = 4
_buf$ = 16						; size = 4
_len$ = 20						; size = 4
_flags$ = 24						; size = 4
_to$ = 28						; size = 4
_tolen$ = 32						; size = 4
_NET_SendLong PROC

; 952  : {

	push	ebp
	mov	ebp, esp

; 953  : #ifdef NET_USE_FRAGMENTS
; 954  : 	// do we need to break this packet up?
; 955  : 	if( sock == NS_SERVER && len > MAX_ROUTEABLE_PACKET )
; 956  : 	{
; 957  : 		char		packet[MAX_ROUTEABLE_PACKET];
; 958  : 		int		total_sent, size, packet_count;
; 959  : 		int		ret, packet_number;
; 960  : 		SPLITPACKET	*pPacket;
; 961  : 
; 962  : 		net.sequence_number++;
; 963  : 		if( net.sequence_number <= 0 )
; 964  : 			net.sequence_number = 1;
; 965  : 
; 966  : 		pPacket = (SPLITPACKET *)packet;
; 967  : 		pPacket->sequence_number = net.sequence_number;
; 968  : 		pPacket->net_id = NET_HEADER_SPLITPACKET;
; 969  : 		packet_number = 0;
; 970  : 		total_sent = 0;
; 971  : 		packet_count = (len + SPLIT_SIZE - 1) / SPLIT_SIZE;
; 972  : 
; 973  : 		while( len > 0 )
; 974  : 		{
; 975  : 			size = Q_min( SPLIT_SIZE, len );
; 976  : 			pPacket->packet_id = (packet_number << 8) + packet_count;
; 977  : 			memcpy( packet + sizeof( SPLITPACKET ), buf + ( packet_number * SPLIT_SIZE ), size );
; 978  : 
; 979  : 			if( net_showpackets && net_showpackets->value == 3.0f )
; 980  : 			{
; 981  : 				netadr_t	adr;
; 982  : 
; 983  : 				memset( &adr, 0, sizeof( adr ));
; 984  : 				NET_SockadrToNetadr((struct sockaddr *)to, &adr );
; 985  : 
; 986  : 				Con_Printf( "Sending split %i of %i with %i bytes and seq %i to %s\n",
; 987  : 					packet_number + 1, packet_count, size, net.sequence_number, NET_AdrToString( adr ));
; 988  : 			}
; 989  : 
; 990  : 			ret = pSendTo( net_socket, packet, size + sizeof( SPLITPACKET ), flags, to, tolen );
; 991  : 			if( ret < 0 ) return ret; // error
; 992  : 
; 993  : 			if( ret >= size )
; 994  : 				total_sent += size;
; 995  : 			len -= size;
; 996  : 			packet_number++;
; 997  : 			Sleep( 1 );
; 998  : 		}
; 999  : 
; 1000 : 		return total_sent;
; 1001 : 	}
; 1002 : 	else
; 1003 : #endif
; 1004 : 	{
; 1005 : 		// no fragmenantion for client connection
; 1006 : 		return pSendTo( net_socket, buf, len, flags, to, tolen );

	mov	eax, DWORD PTR _tolen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	DWORD PTR _pSendTo

; 1007 : 	}
; 1008 : }

	pop	ebp
	ret	0
_NET_SendLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_err$1 = -65576						; size = 4
_addr_len$ = -65572					; size = 4
_net_socket$ = -65568					; size = 4
tv129 = -65564						; size = 4
_ret$ = -65560						; size = 4
_addr$ = -65556						; size = 16
_buf$ = -65540						; size = 65536
__$ArrayPad$ = -4					; size = 4
_sock$ = 8						; size = 4
_from$ = 12						; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_NET_QueuePacket PROC

; 859  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 65576				; 00010028H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 860  : 	byte		buf[NET_MAX_FRAGMENT];
; 861  : 	int		ret = SOCKET_ERROR;

	mov	DWORD PTR _ret$[ebp], -1

; 862  : 	int		net_socket;
; 863  : 	int		addr_len;
; 864  : 	struct sockaddr	addr;
; 865  : 
; 866  : 	*length = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0

; 867  : 
; 868  : 	net_socket = net.ip_sockets[sock];

	mov	ecx, DWORD PTR _sock$[ebp]
	mov	edx, DWORD PTR _net[ecx*4+1114840]
	mov	DWORD PTR _net_socket$[ebp], edx

; 869  : 
; 870  : 	if( net_socket != INVALID_SOCKET )

	cmp	DWORD PTR _net_socket$[ebp], -1
	je	$LN4@NET_QueueP

; 871  : 	{
; 872  : 		addr_len = sizeof( addr );

	mov	DWORD PTR _addr_len$[ebp], 16		; 00000010H

; 873  : 		ret = pRecvFrom( net_socket, buf, sizeof( buf ), 0, (struct sockaddr *)&addr, &addr_len );

	lea	eax, DWORD PTR _addr_len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	push	0
	push	65536					; 00010000H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pRecvFrom
	mov	DWORD PTR _ret$[ebp], eax

; 874  : 
; 875  : 		if( ret != SOCKET_ERROR )

	cmp	DWORD PTR _ret$[ebp], -1
	je	$LN5@NET_QueueP

; 876  : 		{
; 877  : 			NET_SockadrToNetadr( &addr, from );

	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	lea	edx, DWORD PTR _addr$[ebp]
	push	edx
	call	_NET_SockadrToNetadr
	add	esp, 8

; 878  : 
; 879  : 			if( ret < NET_MAX_FRAGMENT )

	cmp	DWORD PTR _ret$[ebp], 65536		; 00010000H
	jge	SHORT $LN7@NET_QueueP

; 880  : 			{
; 881  : 				// Transfer data
; 882  : 				memcpy( data, buf, ret );

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 883  : 				*length = ret;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx

; 884  : 
; 885  : 				// check for split message
; 886  : 				if( *(int *)data == NET_HEADER_SPLITPACKET )

	mov	edx, DWORD PTR _data$[ebp]
	cmp	DWORD PTR [edx], -2			; fffffffeH
	jne	SHORT $LN9@NET_QueueP

; 887  : 				{
; 888  : 					return NET_GetLong( data, ret, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_NET_GetLong
	add	esp, 12					; 0000000cH
	jmp	$LN1@NET_QueueP
$LN9@NET_QueueP:

; 889  : 				}
; 890  : 
; 891  : 				// lag the packet, if needed
; 892  : 				return NET_LagPacket( true, sock, from, length, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	push	1
	call	_NET_LagPacket
	add	esp, 20					; 00000014H
	jmp	$LN1@NET_QueueP

; 893  : 			}

	jmp	SHORT $LN8@NET_QueueP
$LN7@NET_QueueP:

; 894  : 			else
; 895  : 			{
; 896  : 				Con_Reportf( "NET_QueuePacket: oversize packet from %s\n", NET_AdrToString( *from ));

	mov	ecx, DWORD PTR _from$[ebp]
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG132608
	call	_Con_Reportf
	add	esp, 8
$LN8@NET_QueueP:

; 897  : 			}
; 898  : 		}

	jmp	$LN4@NET_QueueP
$LN5@NET_QueueP:

; 899  : 		else
; 900  : 		{
; 901  : 			int	err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$1[ebp], eax

; 902  : 
; 903  : 			switch( err )

	mov	edx, DWORD PTR _err$1[ebp]
	mov	DWORD PTR tv129[ebp], edx
	mov	eax, DWORD PTR tv129[ebp]
	sub	eax, 10035				; 00002733H
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], 26		; 0000001aH
	ja	SHORT $LN11@NET_QueueP
	mov	ecx, DWORD PTR tv129[ebp]
	movzx	edx, BYTE PTR $LN13@NET_QueueP[ecx]
	jmp	DWORD PTR $LN14@NET_QueueP[edx*4]
$LN10@NET_QueueP:

; 904  : 			{
; 905  : 			case WSAEWOULDBLOCK:
; 906  : 			case WSAECONNRESET:
; 907  : 			case WSAECONNREFUSED:
; 908  : 			case WSAEMSGSIZE:
; 909  : 				break;

	jmp	SHORT $LN4@NET_QueueP
$LN11@NET_QueueP:

; 910  : 			default:	// let's continue even after errors
; 911  : 				Con_DPrintf( S_ERROR "NET_QueuePacket: %s from %s\n", NET_ErrorString(), NET_AdrToString( *from ));

	mov	eax, DWORD PTR _from$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET $SG132611
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN4@NET_QueueP:

; 912  : 				break;
; 913  : 			}
; 914  : 		}
; 915  : 	}
; 916  : 
; 917  : 	return NET_LagPacket( false, sock, from, length, data );

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	push	0
	call	_NET_LagPacket
	add	esp, 20					; 00000014H
$LN1@NET_QueueP:

; 918  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN14@NET_QueueP:
	DD	$LN10@NET_QueueP
	DD	$LN11@NET_QueueP
$LN13@NET_QueueP:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_NET_QueuePacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_offset$ = -28						; size = 4
_pHeader$ = -24						; size = 4
_i$ = -20						; size = 4
_sequence_number$ = -16					; size = 4
_packet_count$ = -12					; size = 4
_packet_number$ = -8					; size = 4
_packet_id$ = -4					; size = 2
_pData$ = 8						; size = 4
_size$ = 12						; size = 4
_outSize$ = 16						; size = 4
_NET_GetLong PROC

; 772  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 773  : 	int		i, sequence_number, offset;
; 774  : 	SPLITPACKET	*pHeader = (SPLITPACKET *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pHeader$[ebp], eax

; 775  : 	int		packet_number;
; 776  : 	int		packet_count;
; 777  : 	short		packet_id;
; 778  : 
; 779  : 	if( size < sizeof( SPLITPACKET ))

	cmp	DWORD PTR _size$[ebp], 10		; 0000000aH
	jae	SHORT $LN5@NET_GetLon

; 780  : 	{
; 781  : 		Con_Printf( S_ERROR "invalid split packet length %i\n", size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET $SG132564
	call	_Con_Printf
	add	esp, 8

; 782  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLon
$LN5@NET_GetLon:

; 783  : 	}
; 784  : 
; 785  : 	sequence_number = pHeader->sequence_number;

	mov	edx, DWORD PTR _pHeader$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _sequence_number$[ebp], eax

; 786  : 	packet_id = pHeader->packet_id;

	mov	ecx, DWORD PTR _pHeader$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR _packet_id$[ebp], dx

; 787  : 	packet_count = ( packet_id & 0xFF );

	movsx	eax, WORD PTR _packet_id$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _packet_count$[ebp], eax

; 788  : 	packet_number = ( packet_id >> 8 );

	movsx	ecx, WORD PTR _packet_id$[ebp]
	sar	ecx, 8
	mov	DWORD PTR _packet_number$[ebp], ecx

; 789  : 
; 790  : 	if( packet_number >= NET_MAX_FRAGMENTS || packet_count > NET_MAX_FRAGMENTS )

	cmp	DWORD PTR _packet_number$[ebp], 47	; 0000002fH
	jae	SHORT $LN7@NET_GetLon
	cmp	DWORD PTR _packet_count$[ebp], 47	; 0000002fH
	jbe	SHORT $LN6@NET_GetLon
$LN7@NET_GetLon:

; 791  : 	{
; 792  : 		Con_Printf( S_ERROR "malformed packet number (%i/%i)\n", packet_number + 1, packet_count );

	mov	edx, DWORD PTR _packet_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _packet_number$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET $SG132567
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 793  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLon
$LN6@NET_GetLon:

; 794  : 	}
; 795  : 
; 796  : 	if( net.split.current_sequence == -1 || sequence_number != net.split.current_sequence )

	cmp	DWORD PTR _net+1049100, -1
	je	SHORT $LN9@NET_GetLon
	mov	ecx, DWORD PTR _sequence_number$[ebp]
	cmp	ecx, DWORD PTR _net+1049100
	je	SHORT $LN10@NET_GetLon
$LN9@NET_GetLon:

; 797  : 	{
; 798  : 		net.split.current_sequence = sequence_number;

	mov	edx, DWORD PTR _sequence_number$[ebp]
	mov	DWORD PTR _net+1049100, edx

; 799  : 		net.split.split_count = packet_count;

	mov	eax, DWORD PTR _packet_count$[ebp]
	mov	DWORD PTR _net+1049104, eax

; 800  : 		net.split.total_size = 0;

	mov	DWORD PTR _net+1049108, 0

; 801  : 
; 802  : 		// clear part's sequence
; 803  : 		for( i = 0; i < NET_MAX_FRAGMENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NET_GetLon
$LN2@NET_GetLon:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@NET_GetLon:
	cmp	DWORD PTR _i$[ebp], 47			; 0000002fH
	jae	SHORT $LN3@NET_GetLon

; 804  : 			net.split_flags[i] = -1;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _net[edx*4+1114648], -1
	jmp	SHORT $LN2@NET_GetLon
$LN3@NET_GetLon:

; 805  : 
; 806  : 		if( net_showpackets && net_showpackets->value == 4.0f )

	cmp	DWORD PTR _net_showpackets, 0
	je	SHORT $LN10@NET_GetLon
	mov	eax, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@NET_GetLon

; 807  : 			Con_Printf( "<-- Split packet restart %i count %i seq\n", net.split.split_count, sequence_number );

	mov	ecx, DWORD PTR _sequence_number$[ebp]
	push	ecx
	mov	edx, DWORD PTR _net+1049104
	push	edx
	push	OFFSET $SG132571
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN10@NET_GetLon:

; 808  : 	}
; 809  : 
; 810  : 	size -= sizeof( SPLITPACKET );

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR _size$[ebp], eax

; 811  : 
; 812  : 	if( net.split_flags[packet_number] != sequence_number )

	mov	ecx, DWORD PTR _packet_number$[ebp]
	mov	edx, DWORD PTR _net[ecx*4+1114648]
	cmp	edx, DWORD PTR _sequence_number$[ebp]
	je	SHORT $LN11@NET_GetLon

; 813  : 	{
; 814  : 		if( packet_number == ( packet_count - 1 ))

	mov	eax, DWORD PTR _packet_count$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _packet_number$[ebp], eax
	jne	SHORT $LN13@NET_GetLon

; 815  : 			net.split.total_size = size + SPLIT_SIZE * ( packet_count - 1 );

	mov	ecx, DWORD PTR _packet_count$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 1390
	add	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _net+1049108, edx
$LN13@NET_GetLon:

; 816  : 
; 817  : 		net.split.split_count--;

	mov	eax, DWORD PTR _net+1049104
	sub	eax, 1
	mov	DWORD PTR _net+1049104, eax

; 818  : 		net.split_flags[packet_number] = sequence_number;

	mov	ecx, DWORD PTR _packet_number$[ebp]
	mov	edx, DWORD PTR _sequence_number$[ebp]
	mov	DWORD PTR _net[ecx*4+1114648], edx

; 819  : 
; 820  : 		if( net_showpackets && net_showpackets->value == 4.0f )

	cmp	DWORD PTR _net_showpackets, 0
	je	SHORT $LN14@NET_GetLon
	mov	eax, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@NET_GetLon

; 821  : 			Con_Printf( "<-- Split packet %i of %i, %i bytes %i seq\n", packet_number + 1, packet_count, size, sequence_number );

	mov	ecx, DWORD PTR _sequence_number$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _packet_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet_number$[ebp]
	add	ecx, 1
	push	ecx
	push	OFFSET $SG132576
	call	_Con_Printf
	add	esp, 20					; 00000014H
$LN14@NET_GetLon:

; 822  : 	}

	jmp	SHORT $LN12@NET_GetLon
$LN11@NET_GetLon:

; 823  : 	else
; 824  : 	{
; 825  : 		Con_DPrintf( "NET_GetLong: Ignoring duplicated split packet %i of %i ( %i bytes )\n", packet_number + 1, packet_count, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _packet_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet_number$[ebp]
	add	ecx, 1
	push	ecx
	push	OFFSET $SG132577
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN12@NET_GetLon:

; 826  : 	}
; 827  : 
; 828  : 	offset = (packet_number * SPLIT_SIZE);

	imul	edx, DWORD PTR _packet_number$[ebp], 1390
	mov	DWORD PTR _offset$[ebp], edx

; 829  : 	memcpy( net.split.buffer + offset, pData + sizeof( SPLITPACKET ), size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, OFFSET _net+1049112
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 830  : 
; 831  : 	// have we received all of the pieces to the packet?
; 832  : 	if( net.split.split_count <= 0 )

	cmp	DWORD PTR _net+1049104, 0
	jg	SHORT $LN15@NET_GetLon

; 833  : 	{
; 834  : 		net.split.current_sequence = -1; // Clear packet

	mov	DWORD PTR _net+1049100, -1

; 835  : 
; 836  : 		if( net.split.total_size > sizeof( net.split.buffer ))

	cmp	DWORD PTR _net+1049108, 65536		; 00010000H
	jbe	SHORT $LN16@NET_GetLon

; 837  : 		{
; 838  : 			Con_Printf( "Split packet too large! %d bytes\n", net.split.total_size );

	mov	eax, DWORD PTR _net+1049108
	push	eax
	push	OFFSET $SG132580
	call	_Con_Printf
	add	esp, 8

; 839  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_GetLon
$LN16@NET_GetLon:

; 840  : 		}
; 841  : 
; 842  : 		memcpy( pData, net.split.buffer, net.split.total_size );

	mov	ecx, DWORD PTR _net+1049108
	push	ecx
	push	OFFSET _net+1049112
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 843  : 		*outSize = net.split.total_size;

	mov	eax, DWORD PTR _outSize$[ebp]
	mov	ecx, DWORD PTR _net+1049108
	mov	DWORD PTR [eax], ecx

; 844  : 
; 845  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_GetLon
$LN15@NET_GetLon:

; 846  : 	}
; 847  : 
; 848  : 	return false;

	xor	eax, eax
$LN1@NET_GetLon:

; 849  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_pNewPacketLag$ = -16					; size = 4
_curtime$ = -12						; size = 4
_ninterval$ = -8					; size = 4
_pPacket$ = -4						; size = 4
_newdata$ = 8						; size = 4
_sock$ = 12						; size = 4
_from$ = 16						; size = 4
_length$ = 20						; size = 4
_data$ = 24						; size = 4
_NET_LagPacket PROC

; 690  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 691  : 	packetlag_t	*pNewPacketLag;
; 692  : 	packetlag_t	*pPacket;
; 693  : 	int		ninterval;
; 694  : 	float		curtime;
; 695  : 
; 696  : 	if( net.fakelag <= 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _net+1049096
	jb	SHORT $LN4@NET_LagPac

; 697  : 	{
; 698  : 		NET_ClearLagData( true, true );

	push	1
	push	1
	call	_NET_ClearLagData
	add	esp, 8

; 699  : 		return newdata;

	mov	eax, DWORD PTR _newdata$[ebp]
	jmp	$LN1@NET_LagPac
$LN4@NET_LagPac:

; 700  : 	}
; 701  : 
; 702  : 	curtime = host.realtime;

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _curtime$[ebp], xmm0

; 703  : 
; 704  : 	if( newdata )

	cmp	DWORD PTR _newdata$[ebp], 0
	je	$LN5@NET_LagPac

; 705  : 	{
; 706  : 		if( net_fakeloss->value != 0.0f )

	mov	eax, DWORD PTR _net_fakeloss
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@NET_LagPac

; 707  : 		{
; 708  : 			if( host_developer.value )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN7@NET_LagPac

; 709  : 			{
; 710  : 				net.losscount[sock]++;

	mov	ecx, DWORD PTR _sock$[ebp]
	mov	edx, DWORD PTR _net[ecx*4+1049088]
	add	edx, 1
	mov	eax, DWORD PTR _sock$[ebp]
	mov	DWORD PTR _net[eax*4+1049088], edx

; 711  : 				if( net_fakeloss->value <= 0.0f )

	mov	ecx, DWORD PTR _net_fakeloss
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+12]
	jb	SHORT $LN9@NET_LagPac

; 712  : 				{
; 713  : 					ninterval = fabs( net_fakeloss->value );

	mov	edx, DWORD PTR _net_fakeloss
	cvtss2sd xmm0, DWORD PTR [edx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _ninterval$[ebp], eax

; 714  : 					if( ninterval < 2 ) ninterval = 2;

	cmp	DWORD PTR _ninterval$[ebp], 2
	jge	SHORT $LN11@NET_LagPac
	mov	DWORD PTR _ninterval$[ebp], 2
$LN11@NET_LagPac:

; 715  : 
; 716  : 					if(( net.losscount[sock] % ninterval ) == 0 )

	mov	eax, DWORD PTR _sock$[ebp]
	mov	eax, DWORD PTR _net[eax*4+1049088]
	cdq
	idiv	DWORD PTR _ninterval$[ebp]
	test	edx, edx
	jne	SHORT $LN12@NET_LagPac

; 717  : 						return false;

	xor	eax, eax
	jmp	$LN1@NET_LagPac
$LN12@NET_LagPac:

; 718  : 				}

	jmp	SHORT $LN13@NET_LagPac
$LN9@NET_LagPac:

; 719  : 				else
; 720  : 				{
; 721  : 					if( COM_RandomLong( 0, 100 ) <= net_fakeloss->value )

	push	100					; 00000064H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _net_fakeloss
	movss	xmm1, DWORD PTR [ecx+12]
	comiss	xmm1, xmm0
	jb	SHORT $LN13@NET_LagPac

; 722  : 						return false;

	xor	eax, eax
	jmp	$LN1@NET_LagPac
$LN13@NET_LagPac:

; 723  : 				}
; 724  : 			}

	jmp	SHORT $LN8@NET_LagPac
$LN7@NET_LagPac:

; 725  : 			else
; 726  : 			{
; 727  : 				Cvar_SetValue( "fakeloss", 0.0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG132529
	call	_Cvar_SetValue
	add	esp, 8
$LN8@NET_LagPac:

; 728  : 			}
; 729  : 		}
; 730  : 
; 731  : 		pNewPacketLag = (packetlag_t *)Z_Malloc( sizeof( packetlag_t ));

	push	731					; 000002dbH
	push	OFFSET $SG132530
	push	0
	push	40					; 00000028H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pNewPacketLag$[ebp], eax

; 732  : 		// queue packet to simulate fake lag
; 733  : 		NET_AddToLagged( sock, &net.lagdata[sock], pNewPacketLag, from, *length, data, curtime );

	push	ecx
	movss	xmm0, DWORD PTR _curtime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewPacketLag$[ebp]
	push	ecx
	imul	edx, DWORD PTR _sock$[ebp], 40
	add	edx, OFFSET _net+1049008
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_NET_AddToLagged
	add	esp, 28					; 0000001cH
$LN5@NET_LagPac:

; 734  : 	}
; 735  : 
; 736  : 	pPacket = net.lagdata[sock].next;

	imul	ecx, DWORD PTR _sock$[ebp], 40
	mov	edx, DWORD PTR _net[ecx+1049040]
	mov	DWORD PTR _pPacket$[ebp], edx
$LN2@NET_LagPac:

; 737  : 
; 738  : 	while( pPacket != &net.lagdata[sock] )

	imul	eax, DWORD PTR _sock$[ebp], 40
	add	eax, OFFSET _net+1049008
	cmp	DWORD PTR _pPacket$[ebp], eax
	je	SHORT $LN3@NET_LagPac

; 739  : 	{
; 740  : 		if( pPacket->receivedtime <= curtime - ( net.fakelag / 1000.0 ))

	mov	ecx, DWORD PTR _pPacket$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+28]
	cvtss2sd xmm1, DWORD PTR _curtime$[ebp]
	cvtss2sd xmm2, DWORD PTR _net+1049096
	divsd	xmm2, QWORD PTR __real@408f400000000000
	subsd	xmm1, xmm2
	comisd	xmm1, xmm0
	jb	SHORT $LN14@NET_LagPac

; 741  : 			break;

	jmp	SHORT $LN3@NET_LagPac
$LN14@NET_LagPac:

; 742  : 
; 743  : 		pPacket = pPacket->next;

	mov	edx, DWORD PTR _pPacket$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _pPacket$[ebp], eax

; 744  : 	}

	jmp	SHORT $LN2@NET_LagPac
$LN3@NET_LagPac:

; 745  : 
; 746  : 	if( pPacket == &net.lagdata[sock] )

	imul	ecx, DWORD PTR _sock$[ebp], 40
	add	ecx, OFFSET _net+1049008
	cmp	DWORD PTR _pPacket$[ebp], ecx
	jne	SHORT $LN15@NET_LagPac

; 747  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_LagPac
$LN15@NET_LagPac:

; 748  : 
; 749  : 	NET_RemoveFromPacketList( pPacket );

	mov	edx, DWORD PTR _pPacket$[ebp]
	push	edx
	call	_NET_RemoveFromPacketList
	add	esp, 4

; 750  : 
; 751  : 	// delivery packet from fake lag queue
; 752  : 	memcpy( data, pPacket->data, pPacket->size );

	mov	eax, DWORD PTR _pPacket$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pPacket$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 753  : 	memcpy( &net_from, &pPacket->from, sizeof( netadr_t ));

	push	20					; 00000014H
	mov	edx, DWORD PTR _pPacket$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET _net_from
	call	_memcpy
	add	esp, 12					; 0000000cH

; 754  : 	*length = pPacket->size;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _pPacket$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 755  : 
; 756  : 	if( pPacket->data )

	mov	eax, DWORD PTR _pPacket$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@NET_LagPac

; 757  : 		Mem_Free( pPacket->data );

	push	757					; 000002f5H
	push	OFFSET $SG132534
	mov	ecx, DWORD PTR _pPacket$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN16@NET_LagPac:

; 758  : 
; 759  : 	Mem_Free( pPacket );

	push	759					; 000002f7H
	push	OFFSET $SG132535
	mov	eax, DWORD PTR _pPacket$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 760  : 
; 761  : 	return TRUE;

	mov	eax, 1
$LN1@NET_LagPac:

; 762  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_LagPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
tv155 = -40						; size = 8
tv68 = -32						; size = 8
tv67 = -24						; size = 8
_dt$ = -16						; size = 8
_diff$ = -8						; size = 4
_converge$ = -4						; size = 4
_NET_AdjustLag PROC

; 652  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 653  : 	static double	lasttime = 0.0;
; 654  : 	float		diff, converge;
; 655  : 	double		dt;
; 656  : 
; 657  : 	dt = host.realtime - lasttime;

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR ?lasttime@?1??NET_AdjustLag@@9@9
	movsd	QWORD PTR _dt$[ebp], xmm0

; 658  : 	dt = bound( 0.0, dt, 0.1 );

	movsd	xmm0, QWORD PTR _dt$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN11@NET_Adjust
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	comisd	xmm0, QWORD PTR _dt$[ebp]
	jbe	SHORT $LN9@NET_Adjust
	movsd	xmm0, QWORD PTR _dt$[ebp]
	movsd	QWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN10@NET_Adjust
$LN9@NET_Adjust:
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	movsd	QWORD PTR tv67[ebp], xmm0
$LN10@NET_Adjust:
	movsd	xmm0, QWORD PTR tv67[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN12@NET_Adjust
$LN11@NET_Adjust:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv68[ebp], xmm0
$LN12@NET_Adjust:
	movsd	xmm0, QWORD PTR tv68[ebp]
	movsd	QWORD PTR _dt$[ebp], xmm0

; 659  : 	lasttime = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR ?lasttime@?1??NET_AdjustLag@@9@9, xmm0

; 660  : 
; 661  : 	if( host_developer.value || !net_fakelag->value )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@NET_Adjust
	mov	eax, DWORD PTR _net_fakelag
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN2@NET_Adjust
$LN4@NET_Adjust:

; 662  : 	{
; 663  : 		if( net_fakelag->value != net.fakelag )

	mov	ecx, DWORD PTR _net_fakelag
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR _net+1049096
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@NET_Adjust

; 664  : 		{
; 665  : 			diff = net_fakelag->value - net.fakelag;

	mov	edx, DWORD PTR _net_fakelag
	movss	xmm0, DWORD PTR [edx+12]
	subss	xmm0, DWORD PTR _net+1049096
	movss	DWORD PTR _diff$[ebp], xmm0

; 666  : 			converge = dt * 200.0f;

	movsd	xmm0, QWORD PTR _dt$[ebp]
	mulsd	xmm0, QWORD PTR __real@4069000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _converge$[ebp], xmm0

; 667  : 			if( fabs( diff ) < converge )

	cvtss2sd xmm0, DWORD PTR _diff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv155[ebp]
	cvtss2sd xmm0, DWORD PTR _converge$[ebp]
	comisd	xmm0, QWORD PTR tv155[ebp]
	jbe	SHORT $LN6@NET_Adjust

; 668  : 				converge = fabs( diff );

	cvtss2sd xmm0, DWORD PTR _diff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _converge$[ebp]
$LN6@NET_Adjust:

; 669  : 			if( diff < 0.0 )

	cvtss2sd xmm0, DWORD PTR _diff$[ebp]
	xorps	xmm1, xmm1
	comisd	xmm1, xmm0
	jbe	SHORT $LN7@NET_Adjust

; 670  : 				converge = -converge;

	movss	xmm0, DWORD PTR _converge$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _converge$[ebp], xmm0
$LN7@NET_Adjust:

; 671  : 			net.fakelag += converge;

	movss	xmm0, DWORD PTR _net+1049096
	addss	xmm0, DWORD PTR _converge$[ebp]
	movss	DWORD PTR _net+1049096, xmm0
$LN5@NET_Adjust:

; 672  : 		}
; 673  : 	}

	jmp	SHORT $LN3@NET_Adjust
$LN2@NET_Adjust:

; 674  : 	else
; 675  : 	{
; 676  : 		Con_Printf( "Server must enable dev-mode to activate fakelag\n" );

	push	OFFSET $SG132496
	call	_Con_Printf

; 677  : 		Cvar_SetValue( "fakelag", 0.0 );

	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG132497
	call	_Cvar_SetValue
	add	esp, 8

; 678  : 		net.fakelag = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _net+1049096, xmm0
$LN3@NET_Adjust:

; 679  : 	}
; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_AdjustLag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_pStart$ = -4						; size = 4
_sock$ = 8						; size = 4
_list$ = 12						; size = 4
_packet$ = 16						; size = 4
_from$ = 20						; size = 4
_length$ = 24						; size = 4
_data$ = 28						; size = 4
_timestamp$ = 32					; size = 4
_NET_AddToLagged PROC

; 625  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 626  : 	byte	*pStart;
; 627  : 
; 628  : 	if( packet->prev || packet->next )

	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN3@NET_AddToL
	mov	ecx, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN2@NET_AddToL
$LN3@NET_AddToL:

; 629  : 		return;

	jmp	$LN1@NET_AddToL
$LN2@NET_AddToL:

; 630  : 
; 631  : 	packet->prev = list->prev;

	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx

; 632  : 	list->prev->next = packet;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 633  : 	list->prev = packet;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx+36], eax

; 634  : 	packet->next = list;

	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 635  : 
; 636  : 	pStart = (byte *)Z_Malloc( length );

	push	636					; 0000027cH
	push	OFFSET $SG132481
	push	0
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pStart$[ebp], eax

; 637  : 	memcpy( pStart, data, length );

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStart$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 638  : 	packet->data = pStart;

	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR _pStart$[ebp]
	mov	DWORD PTR [edx], eax

; 639  : 	packet->size = length;

	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 640  : 	packet->receivedtime = timestamp;

	mov	eax, DWORD PTR _packet$[ebp]
	movss	xmm0, DWORD PTR _timestamp$[ebp]
	movss	DWORD PTR [eax+28], xmm0

; 641  : 	memcpy( &packet->from, from, sizeof( netadr_t ));

	push	20					; 00000014H
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$[ebp]
	add	edx, 8
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@NET_AddToL:

; 642  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_AddToLagged ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_n$ = -8						; size = 4
_p$ = -4						; size = 4
_list$ = 8						; size = 4
_NET_ClearLaggedList PROC

; 593  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 594  : 	packetlag_t	*p, *n;
; 595  : 
; 596  : 	p = list->next;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _p$[ebp], ecx
$LN2@NET_ClearL:

; 597  : 	while( p && p != list )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@NET_ClearL
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR _list$[ebp]
	je	SHORT $LN3@NET_ClearL

; 598  : 	{
; 599  : 		n = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _n$[ebp], ecx

; 600  : 
; 601  : 		NET_RemoveFromPacketList( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_NET_RemoveFromPacketList
	add	esp, 4

; 602  : 
; 603  : 		if( p->data )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@NET_ClearL

; 604  : 		{
; 605  : 			Mem_Free( p->data );

	push	605					; 0000025dH
	push	OFFSET $SG132458
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 606  : 			p->data = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@NET_ClearL:

; 607  : 		}
; 608  : 
; 609  : 		Mem_Free( p );

	push	609					; 00000261H
	push	OFFSET $SG132459
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 610  : 		p = n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 611  : 	}

	jmp	SHORT $LN2@NET_ClearL
$LN3@NET_ClearL:

; 612  : 
; 613  : 	list->prev = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 614  : 	list->next = list;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+32], eax

; 615  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_ClearLaggedList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_p$ = 8							; size = 4
_NET_RemoveFromPacketList PROC

; 578  : {

	push	ebp
	mov	ebp, esp

; 579  : 	p->prev->next = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax

; 580  : 	p->next->prev = p->prev;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx

; 581  : 	p->prev = NULL;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+36], 0

; 582  : 	p->next = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+32], 0

; 583  : }

	pop	ebp
	ret	0
_NET_RemoveFromPacketList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_NET_ClearLoopback PROC

; 558  : {

	push	ebp
	mov	ebp, esp

; 559  : 	net.loopbacks[0].send = net.loopbacks[0].get = 0;

	mov	eax, 524504				; 000800d8H
	imul	ecx, eax, 0
	mov	DWORD PTR _net[ecx+524496], 0
	mov	edx, 524504				; 000800d8H
	imul	eax, edx, 0
	mov	DWORD PTR _net[eax+524500], 0

; 560  : 	net.loopbacks[1].send = net.loopbacks[1].get = 0;

	mov	ecx, 524504				; 000800d8H
	shl	ecx, 0
	mov	DWORD PTR _net[ecx+524496], 0
	mov	edx, 524504				; 000800d8H
	shl	edx, 0
	mov	DWORD PTR _net[edx+524500], 0

; 561  : }

	pop	ebp
	ret	0
_NET_ClearLoopback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_loop$ = -4						; size = 4
_sock$ = 8						; size = 4
_length$ = 12						; size = 4
_data$ = 16						; size = 4
_to$ = 20						; size = 20
_NET_SendLoopPacket PROC

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 540  : 	net_loopback_t	*loop;
; 541  : 	int		i;
; 542  : 
; 543  : 	loop = &net.loopbacks[sock^1];

	mov	eax, DWORD PTR _sock$[ebp]
	xor	eax, 1
	imul	ecx, eax, 524504
	add	ecx, OFFSET _net
	mov	DWORD PTR _loop$[ebp], ecx

; 544  : 
; 545  : 	i = loop->send & MASK_LOOPBACK;

	mov	edx, DWORD PTR _loop$[ebp]
	mov	eax, DWORD PTR [edx+524500]
	and	eax, 3
	mov	DWORD PTR _i$[ebp], eax

; 546  : 	loop->send++;

	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [ecx+524500]
	add	edx, 1
	mov	eax, DWORD PTR _loop$[ebp]
	mov	DWORD PTR [eax+524500], edx

; 547  : 
; 548  : 	memcpy( loop->msgs[i].data, data, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 131124
	add	eax, DWORD PTR _loop$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 549  : 	loop->msgs[i].datalen = length;

	imul	ecx, DWORD PTR _i$[ebp], 131124
	mov	edx, DWORD PTR _loop$[ebp]
	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [edx+ecx+131120], eax

; 550  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_SendLoopPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_loop$ = -4						; size = 4
_sock$ = 8						; size = 4
_from$ = 12						; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_NET_GetLoopPacket PROC

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 508  : 	net_loopback_t	*loop;
; 509  : 	int		i;
; 510  : 
; 511  : 	if( !data || !length )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@NET_GetLoo
	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN2@NET_GetLoo
$LN3@NET_GetLoo:

; 512  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLoo
$LN2@NET_GetLoo:

; 513  : 
; 514  : 	loop = &net.loopbacks[sock];

	imul	eax, DWORD PTR _sock$[ebp], 524504
	add	eax, OFFSET _net
	mov	DWORD PTR _loop$[ebp], eax

; 515  : 
; 516  : 	if( loop->send - loop->get > MAX_LOOPBACK )

	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR _loop$[ebp]
	mov	eax, DWORD PTR [ecx+524500]
	sub	eax, DWORD PTR [edx+524496]
	cmp	eax, 4
	jle	SHORT $LN4@NET_GetLoo

; 517  : 		loop->get = loop->send - MAX_LOOPBACK;

	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [ecx+524500]
	sub	edx, 4
	mov	eax, DWORD PTR _loop$[ebp]
	mov	DWORD PTR [eax+524496], edx
$LN4@NET_GetLoo:

; 518  : 
; 519  : 	if( loop->get >= loop->send )

	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR _loop$[ebp]
	mov	eax, DWORD PTR [ecx+524496]
	cmp	eax, DWORD PTR [edx+524500]
	jl	SHORT $LN5@NET_GetLoo

; 520  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLoo
$LN5@NET_GetLoo:

; 521  : 	i = loop->get & MASK_LOOPBACK;

	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [ecx+524496]
	and	edx, 3
	mov	DWORD PTR _i$[ebp], edx

; 522  : 	loop->get++;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR [eax+524496]
	add	ecx, 1
	mov	edx, DWORD PTR _loop$[ebp]
	mov	DWORD PTR [edx+524496], ecx

; 523  : 
; 524  : 	memcpy( data, loop->msgs[i].data, loop->msgs[i].datalen );

	imul	eax, DWORD PTR _i$[ebp], 131124
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [ecx+eax+131120]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 131124
	add	eax, DWORD PTR _loop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 525  : 	*length = loop->msgs[i].datalen;

	imul	edx, DWORD PTR _i$[ebp], 131124
	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [ecx+edx+131120]
	mov	DWORD PTR [eax], edx

; 526  : 
; 527  : 	memset( from, 0, sizeof( *from ));

	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 528  : 	from->type = NA_LOOPBACK;

	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], 1

; 529  : 
; 530  : 	return true;

	mov	eax, 1
$LN1@NET_GetLoo:

; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetLoopPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_h$1 = -140						; size = 4
_colon$ = -136						; size = 4
_copy$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_sadr$ = 12						; size = 4
_NET_StringToSockaddr PROC

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 294  : 	char	*colon;
; 295  : 	char	copy[128];
; 296  : 
; 297  : 	if( !net.initialized ) return false;

	cmp	DWORD PTR _net+1115248, 0
	jne	SHORT $LN5@NET_String
	xor	eax, eax
	jmp	$LN1@NET_String
$LN5@NET_String:

; 298  : 	
; 299  : 	memset( sadr, 0, sizeof( *sadr ));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _sadr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 300  : 
; 301  : 	((struct sockaddr_in *)sadr)->sin_family = AF_INET;

	mov	ecx, 2
	mov	edx, DWORD PTR _sadr$[ebp]
	mov	WORD PTR [edx], cx

; 302  : 	((struct sockaddr_in *)sadr)->sin_port = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	WORD PTR [ecx+2], ax

; 303  : 
; 304  : 	Q_strncpy( copy, s, sizeof( copy ));

	push	128					; 00000080H
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	lea	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 305  : 
; 306  : 	// strip off a trailing :port if present
; 307  : 	for( colon = copy; *colon; colon++ )

	lea	ecx, DWORD PTR _copy$[ebp]
	mov	DWORD PTR _colon$[ebp], ecx
	jmp	SHORT $LN4@NET_String
$LN2@NET_String:
	mov	edx, DWORD PTR _colon$[ebp]
	add	edx, 1
	mov	DWORD PTR _colon$[ebp], edx
$LN4@NET_String:
	mov	eax, DWORD PTR _colon$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@NET_String

; 308  : 	{
; 309  : 		if( *colon == ':' )

	mov	edx, DWORD PTR _colon$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN6@NET_String

; 310  : 		{
; 311  : 			*colon = 0;

	mov	ecx, DWORD PTR _colon$[ebp]
	mov	BYTE PTR [ecx], 0

; 312  : 			((struct sockaddr_in *)sadr)->sin_port = pHtons((short)Q_atoi( colon + 1 ));	

	mov	edx, DWORD PTR _colon$[ebp]
	add	edx, 1
	push	edx
	call	_Q_atoi
	add	esp, 4
	push	eax
	call	DWORD PTR _pHtons
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	WORD PTR [ecx+2], ax
$LN6@NET_String:

; 313  : 		}
; 314  : 	}

	jmp	SHORT $LN2@NET_String
$LN3@NET_String:

; 315  : 
; 316  : 	((struct sockaddr_in *)sadr)->sin_addr.s_addr = pInet_Addr( copy );

	lea	edx, DWORD PTR _copy$[ebp]
	push	edx
	call	DWORD PTR _pInet_Addr
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 317  : 
; 318  : 	if(((struct sockaddr_in *)sadr)->sin_addr.s_addr == INADDR_NONE )

	mov	edx, DWORD PTR _sadr$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN7@NET_String

; 319  : 	{
; 320  : 		struct hostent	*h = pGetHostByName( copy );

	lea	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	DWORD PTR _pGetHostByName
	mov	DWORD PTR _h$1[ebp], eax

; 321  : 
; 322  : 		if( h == NULL || h->h_addr == NULL )

	cmp	DWORD PTR _h$1[ebp], 0
	je	SHORT $LN9@NET_String
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _h$1[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [edx+ecx], 0
	jne	SHORT $LN8@NET_String
$LN9@NET_String:

; 323  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_String
$LN8@NET_String:

; 324  : 
; 325  : 		((struct sockaddr_in *)sadr)->sin_addr.s_addr = *(uint *)h->h_addr;	

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _h$1[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx
$LN7@NET_String:

; 326  : 	}
; 327  : 	return true;

	mov	eax, 1
$LN1@NET_String:

; 328  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_StringToSockaddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_a$ = 12						; size = 4
_NET_SockadrToNetadr PROC

; 272  : {

	push	ebp
	mov	ebp, esp

; 273  : 	if( s->sa_family == AF_INET )

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 2
	jne	SHORT $LN1@NET_Sockad

; 274  : 	{
; 275  : 		a->type = NA_IP;

	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx], 3

; 276  : 		*(int *)&a->ip = ((struct sockaddr_in *)s)->sin_addr.s_addr;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 277  : 		a->port = ((struct sockaddr_in *)s)->sin_port;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+18], dx
$LN1@NET_Sockad:

; 278  : 	}
; 279  : }

	pop	ebp
	ret	0
_NET_SockadrToNetadr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
_s$ = 12						; size = 4
_NET_NetadrToSockadr PROC

; 249  : {

	push	ebp
	mov	ebp, esp

; 250  : 	memset( s, 0, sizeof( *s ));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 251  : 
; 252  : 	if( a->type == NA_BROADCAST )

	mov	ecx, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [ecx], 2
	jne	SHORT $LN2@NET_Netadr

; 253  : 	{
; 254  : 		((struct sockaddr_in *)s)->sin_family = AF_INET;

	mov	edx, 2
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax], dx

; 255  : 		((struct sockaddr_in *)s)->sin_port = a->port;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	ax, WORD PTR [edx+18]
	mov	WORD PTR [ecx+2], ax

; 256  : 		((struct sockaddr_in *)s)->sin_addr.s_addr = INADDR_BROADCAST;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+4], -1

; 257  : 	}

	jmp	SHORT $LN1@NET_Netadr
$LN2@NET_Netadr:

; 258  : 	else if( a->type == NA_IP )

	mov	edx, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN1@NET_Netadr

; 259  : 	{
; 260  : 		((struct sockaddr_in *)s)->sin_family = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax

; 261  : 		((struct sockaddr_in *)s)->sin_addr.s_addr = *(int *)&a->ip;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 262  : 		((struct sockaddr_in *)s)->sin_port = a->port;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	cx, WORD PTR [eax+18]
	mov	WORD PTR [edx+2], cx
$LN1@NET_Netadr:

; 263  : 	}
; 264  : }

	pop	ebp
	ret	0
_NET_NetadrToSockadr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_err$ = -8						; size = 4
tv66 = -4						; size = 4
_NET_ErrorString PROC

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 188  : 	int	err = WSANOTINITIALISED;

	mov	DWORD PTR _err$[ebp], 10093		; 0000276dH

; 189  : 
; 190  : 	if( net.initialized )

	cmp	DWORD PTR _net+1115248, 0
	je	SHORT $LN4@NET_ErrorS

; 191  : 		err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
$LN4@NET_ErrorS:

; 192  : 
; 193  : 	switch( err )

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 11001		; 00002af9H
	jg	SHORT $LN51@NET_ErrorS
	cmp	DWORD PTR tv66[ebp], 11001		; 00002af9H
	je	$LN45@NET_ErrorS
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 10004				; 00002714H
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 97			; 00000061H
	ja	$LN49@NET_ErrorS
	mov	edx, DWORD PTR tv66[ebp]
	movzx	eax, BYTE PTR $LN52@NET_ErrorS[edx]
	jmp	DWORD PTR $LN53@NET_ErrorS[eax*4]
$LN51@NET_ErrorS:
	cmp	DWORD PTR tv66[ebp], 11002		; 00002afaH
	je	$LN46@NET_ErrorS
	cmp	DWORD PTR tv66[ebp], 11003		; 00002afbH
	je	$LN47@NET_ErrorS
	cmp	DWORD PTR tv66[ebp], 11004		; 00002afcH
	je	$LN48@NET_ErrorS
	jmp	$LN49@NET_ErrorS
$LN5@NET_ErrorS:

; 194  : 	{
; 195  : 	case WSAEINTR: return "WSAEINTR";

	mov	eax, OFFSET $SG132205
	jmp	$LN1@NET_ErrorS
$LN6@NET_ErrorS:

; 196  : 	case WSAEBADF: return "WSAEBADF";

	mov	eax, OFFSET $SG132207
	jmp	$LN1@NET_ErrorS
$LN7@NET_ErrorS:

; 197  : 	case WSAEACCES: return "WSAEACCES";

	mov	eax, OFFSET $SG132209
	jmp	$LN1@NET_ErrorS
$LN8@NET_ErrorS:

; 198  : 	case WSAEDISCON: return "WSAEDISCON";

	mov	eax, OFFSET $SG132211
	jmp	$LN1@NET_ErrorS
$LN9@NET_ErrorS:

; 199  : 	case WSAEFAULT: return "WSAEFAULT";

	mov	eax, OFFSET $SG132213
	jmp	$LN1@NET_ErrorS
$LN10@NET_ErrorS:

; 200  : 	case WSAEINVAL: return "WSAEINVAL";

	mov	eax, OFFSET $SG132215
	jmp	$LN1@NET_ErrorS
$LN11@NET_ErrorS:

; 201  : 	case WSAEMFILE: return "WSAEMFILE";

	mov	eax, OFFSET $SG132217
	jmp	$LN1@NET_ErrorS
$LN12@NET_ErrorS:

; 202  : 	case WSAEWOULDBLOCK: return "WSAEWOULDBLOCK";

	mov	eax, OFFSET $SG132219
	jmp	$LN1@NET_ErrorS
$LN13@NET_ErrorS:

; 203  : 	case WSAEINPROGRESS: return "WSAEINPROGRESS";

	mov	eax, OFFSET $SG132221
	jmp	$LN1@NET_ErrorS
$LN14@NET_ErrorS:

; 204  : 	case WSAEALREADY: return "WSAEALREADY";

	mov	eax, OFFSET $SG132223
	jmp	$LN1@NET_ErrorS
$LN15@NET_ErrorS:

; 205  : 	case WSAENOTSOCK: return "WSAENOTSOCK";

	mov	eax, OFFSET $SG132225
	jmp	$LN1@NET_ErrorS
$LN16@NET_ErrorS:

; 206  : 	case WSAEDESTADDRREQ: return "WSAEDESTADDRREQ";

	mov	eax, OFFSET $SG132227
	jmp	$LN1@NET_ErrorS
$LN17@NET_ErrorS:

; 207  : 	case WSAEMSGSIZE: return "WSAEMSGSIZE";

	mov	eax, OFFSET $SG132229
	jmp	$LN1@NET_ErrorS
$LN18@NET_ErrorS:

; 208  : 	case WSAEPROTOTYPE: return "WSAEPROTOTYPE";

	mov	eax, OFFSET $SG132231
	jmp	$LN1@NET_ErrorS
$LN19@NET_ErrorS:

; 209  : 	case WSAENOPROTOOPT: return "WSAENOPROTOOPT";

	mov	eax, OFFSET $SG132233
	jmp	$LN1@NET_ErrorS
$LN20@NET_ErrorS:

; 210  : 	case WSAEPROTONOSUPPORT: return "WSAEPROTONOSUPPORT";

	mov	eax, OFFSET $SG132235
	jmp	$LN1@NET_ErrorS
$LN21@NET_ErrorS:

; 211  : 	case WSAESOCKTNOSUPPORT: return "WSAESOCKTNOSUPPORT";

	mov	eax, OFFSET $SG132237
	jmp	$LN1@NET_ErrorS
$LN22@NET_ErrorS:

; 212  : 	case WSAEOPNOTSUPP: return "WSAEOPNOTSUPP";

	mov	eax, OFFSET $SG132239
	jmp	$LN1@NET_ErrorS
$LN23@NET_ErrorS:

; 213  : 	case WSAEPFNOSUPPORT: return "WSAEPFNOSUPPORT";

	mov	eax, OFFSET $SG132241
	jmp	$LN1@NET_ErrorS
$LN24@NET_ErrorS:

; 214  : 	case WSAEAFNOSUPPORT: return "WSAEAFNOSUPPORT";

	mov	eax, OFFSET $SG132243
	jmp	$LN1@NET_ErrorS
$LN25@NET_ErrorS:

; 215  : 	case WSAEADDRINUSE: return "WSAEADDRINUSE";

	mov	eax, OFFSET $SG132245
	jmp	$LN1@NET_ErrorS
$LN26@NET_ErrorS:

; 216  : 	case WSAEADDRNOTAVAIL: return "WSAEADDRNOTAVAIL";

	mov	eax, OFFSET $SG132247
	jmp	$LN1@NET_ErrorS
$LN27@NET_ErrorS:

; 217  : 	case WSAENETDOWN: return "WSAENETDOWN";

	mov	eax, OFFSET $SG132249
	jmp	$LN1@NET_ErrorS
$LN28@NET_ErrorS:

; 218  : 	case WSAENETUNREACH: return "WSAENETUNREACH";

	mov	eax, OFFSET $SG132251
	jmp	$LN1@NET_ErrorS
$LN29@NET_ErrorS:

; 219  : 	case WSAENETRESET: return "WSAENETRESET";

	mov	eax, OFFSET $SG132253
	jmp	$LN1@NET_ErrorS
$LN30@NET_ErrorS:

; 220  : 	case WSAECONNABORTED: return "WSWSAECONNABORTEDAEINTR";

	mov	eax, OFFSET $SG132255
	jmp	$LN1@NET_ErrorS
$LN31@NET_ErrorS:

; 221  : 	case WSAECONNRESET: return "WSAECONNRESET";

	mov	eax, OFFSET $SG132257
	jmp	SHORT $LN1@NET_ErrorS
$LN32@NET_ErrorS:

; 222  : 	case WSAENOBUFS: return "WSAENOBUFS";

	mov	eax, OFFSET $SG132259
	jmp	SHORT $LN1@NET_ErrorS
$LN33@NET_ErrorS:

; 223  : 	case WSAEISCONN: return "WSAEISCONN";

	mov	eax, OFFSET $SG132261
	jmp	SHORT $LN1@NET_ErrorS
$LN34@NET_ErrorS:

; 224  : 	case WSAENOTCONN: return "WSAENOTCONN";

	mov	eax, OFFSET $SG132263
	jmp	SHORT $LN1@NET_ErrorS
$LN35@NET_ErrorS:

; 225  : 	case WSAESHUTDOWN: return "WSAESHUTDOWN";

	mov	eax, OFFSET $SG132265
	jmp	SHORT $LN1@NET_ErrorS
$LN36@NET_ErrorS:

; 226  : 	case WSAETOOMANYREFS: return "WSAETOOMANYREFS";

	mov	eax, OFFSET $SG132267
	jmp	SHORT $LN1@NET_ErrorS
$LN37@NET_ErrorS:

; 227  : 	case WSAETIMEDOUT: return "WSAETIMEDOUT";

	mov	eax, OFFSET $SG132269
	jmp	SHORT $LN1@NET_ErrorS
$LN38@NET_ErrorS:

; 228  : 	case WSAECONNREFUSED: return "WSAECONNREFUSED";

	mov	eax, OFFSET $SG132271
	jmp	SHORT $LN1@NET_ErrorS
$LN39@NET_ErrorS:

; 229  : 	case WSAELOOP: return "WSAELOOP";

	mov	eax, OFFSET $SG132273
	jmp	SHORT $LN1@NET_ErrorS
$LN40@NET_ErrorS:

; 230  : 	case WSAENAMETOOLONG: return "WSAENAMETOOLONG";

	mov	eax, OFFSET $SG132275
	jmp	SHORT $LN1@NET_ErrorS
$LN41@NET_ErrorS:

; 231  : 	case WSAEHOSTDOWN: return "WSAEHOSTDOWN";

	mov	eax, OFFSET $SG132277
	jmp	SHORT $LN1@NET_ErrorS
$LN42@NET_ErrorS:

; 232  : 	case WSASYSNOTREADY: return "WSASYSNOTREADY";

	mov	eax, OFFSET $SG132279
	jmp	SHORT $LN1@NET_ErrorS
$LN43@NET_ErrorS:

; 233  : 	case WSAVERNOTSUPPORTED: return "WSAVERNOTSUPPORTED";

	mov	eax, OFFSET $SG132281
	jmp	SHORT $LN1@NET_ErrorS
$LN44@NET_ErrorS:

; 234  : 	case WSANOTINITIALISED: return "WSANOTINITIALISED";

	mov	eax, OFFSET $SG132283
	jmp	SHORT $LN1@NET_ErrorS
$LN45@NET_ErrorS:

; 235  : 	case WSAHOST_NOT_FOUND: return "WSAHOST_NOT_FOUND";

	mov	eax, OFFSET $SG132285
	jmp	SHORT $LN1@NET_ErrorS
$LN46@NET_ErrorS:

; 236  : 	case WSATRY_AGAIN: return "WSATRY_AGAIN";

	mov	eax, OFFSET $SG132287
	jmp	SHORT $LN1@NET_ErrorS
$LN47@NET_ErrorS:

; 237  : 	case WSANO_RECOVERY: return "WSANO_RECOVERY";

	mov	eax, OFFSET $SG132289
	jmp	SHORT $LN1@NET_ErrorS
$LN48@NET_ErrorS:

; 238  : 	case WSANO_DATA: return "WSANO_DATA";

	mov	eax, OFFSET $SG132291
	jmp	SHORT $LN1@NET_ErrorS
$LN49@NET_ErrorS:

; 239  : 	default: return "NO ERROR";

	mov	eax, OFFSET $SG132293
$LN1@NET_ErrorS:

; 240  : 	}
; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN53@NET_ErrorS:
	DD	$LN5@NET_ErrorS
	DD	$LN6@NET_ErrorS
	DD	$LN7@NET_ErrorS
	DD	$LN9@NET_ErrorS
	DD	$LN10@NET_ErrorS
	DD	$LN11@NET_ErrorS
	DD	$LN12@NET_ErrorS
	DD	$LN13@NET_ErrorS
	DD	$LN14@NET_ErrorS
	DD	$LN15@NET_ErrorS
	DD	$LN16@NET_ErrorS
	DD	$LN17@NET_ErrorS
	DD	$LN18@NET_ErrorS
	DD	$LN19@NET_ErrorS
	DD	$LN20@NET_ErrorS
	DD	$LN21@NET_ErrorS
	DD	$LN22@NET_ErrorS
	DD	$LN23@NET_ErrorS
	DD	$LN24@NET_ErrorS
	DD	$LN25@NET_ErrorS
	DD	$LN26@NET_ErrorS
	DD	$LN27@NET_ErrorS
	DD	$LN28@NET_ErrorS
	DD	$LN29@NET_ErrorS
	DD	$LN30@NET_ErrorS
	DD	$LN31@NET_ErrorS
	DD	$LN32@NET_ErrorS
	DD	$LN33@NET_ErrorS
	DD	$LN34@NET_ErrorS
	DD	$LN35@NET_ErrorS
	DD	$LN36@NET_ErrorS
	DD	$LN37@NET_ErrorS
	DD	$LN38@NET_ErrorS
	DD	$LN39@NET_ErrorS
	DD	$LN40@NET_ErrorS
	DD	$LN41@NET_ErrorS
	DD	$LN42@NET_ErrorS
	DD	$LN43@NET_ErrorS
	DD	$LN44@NET_ErrorS
	DD	$LN8@NET_ErrorS
	DD	$LN49@NET_ErrorS
$LN52@NET_ErrorS:
	DB	0
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	1
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	2
	DB	3
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	4
	DB	40					; 00000028H
	DB	5
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	39					; 00000027H
_NET_ErrorString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_NET_FreeWinSock PROC

; 177  : {

	push	ebp
	mov	ebp, esp

; 178  : 	Sys_FreeLibrary( &winsock_dll );

	push	OFFSET _winsock_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 179  : }

	pop	ebp
	ret	0
_NET_FreeWinSock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_NET_OpenWinSock PROC

; 161  : {

	push	ebp
	mov	ebp, esp

; 162  : 	// initialize the Winsock function vectors (we do this instead of statically linking
; 163  : 	// so we can run on Win 3.1, where there isn't necessarily Winsock)
; 164  : 	if( Sys_LoadLibrary( &winsock_dll ))

	push	OFFSET _winsock_dll
	call	_Sys_LoadLibrary
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@NET_OpenWi

; 165  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_OpenWi
$LN2@NET_OpenWi:

; 166  : 	return false;

	xor	eax, eax
$LN1@NET_OpenWi:

; 167  : }

	pop	ebp
	ret	0
_NET_OpenWinSock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_bClient$ = 8						; size = 4
_bServer$ = 12						; size = 4
_NET_ClearLagData PROC

; 1429 : {

	push	ebp
	mov	ebp, esp

; 1430 : 	if( bClient ) NET_ClearLaggedList( &net.lagdata[NS_CLIENT] );

	cmp	DWORD PTR _bClient$[ebp], 0
	je	SHORT $LN2@NET_ClearL
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	add	ecx, OFFSET _net+1049008
	push	ecx
	call	_NET_ClearLaggedList
	add	esp, 4
$LN2@NET_ClearL:

; 1431 : 	if( bServer ) NET_ClearLaggedList( &net.lagdata[NS_SERVER] );

	cmp	DWORD PTR _bServer$[ebp], 0
	je	SHORT $LN1@NET_ClearL
	mov	edx, 40					; 00000028H
	shl	edx, 0
	add	edx, OFFSET _net+1049008
	push	edx
	call	_NET_ClearLaggedList
	add	esp, 4
$LN1@NET_ClearL:

; 1432 : }

	pop	ebp
	ret	0
_NET_ClearLagData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_ret$ = -32						; size = 4
_err$ = -28						; size = 4
_net_socket$ = -24					; size = 4
_addr$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_sock$ = 8						; size = 4
_length$ = 12						; size = 4
_data$ = 16						; size = 4
_to$ = 20						; size = 20
_NET_SendPacket PROC

; 1016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1017 : 	int		ret, err;
; 1018 : 	struct sockaddr	addr;
; 1019 : 	SOCKET		net_socket;
; 1020 : 
; 1021 : 	if( !net.initialized || to.type == NA_LOOPBACK )

	cmp	DWORD PTR _net+1115248, 0
	je	SHORT $LN4@NET_SendPa
	cmp	DWORD PTR _to$[ebp], 1
	jne	SHORT $LN2@NET_SendPa
$LN4@NET_SendPa:

; 1022 : 	{
; 1023 : 		NET_SendLoopPacket( sock, length, data, to );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	_NET_SendLoopPacket
	add	esp, 32					; 00000020H

; 1024 : 		return;

	jmp	$LN1@NET_SendPa

; 1025 : 	}

	jmp	SHORT $LN3@NET_SendPa
$LN2@NET_SendPa:

; 1026 : 	else if( to.type == NA_BROADCAST )

	cmp	DWORD PTR _to$[ebp], 2
	jne	SHORT $LN5@NET_SendPa

; 1027 : 	{
; 1028 : 		net_socket = net.ip_sockets[sock];

	mov	edx, DWORD PTR _sock$[ebp]
	mov	eax, DWORD PTR _net[edx*4+1114840]
	mov	DWORD PTR _net_socket$[ebp], eax

; 1029 : 		if( net_socket == INVALID_SOCKET )

	cmp	DWORD PTR _net_socket$[ebp], -1
	jne	SHORT $LN7@NET_SendPa

; 1030 : 			return;

	jmp	$LN1@NET_SendPa
$LN7@NET_SendPa:

; 1031 : 	}

	jmp	SHORT $LN3@NET_SendPa
$LN5@NET_SendPa:

; 1032 : 	else if( to.type == NA_IP )

	cmp	DWORD PTR _to$[ebp], 3
	jne	SHORT $LN8@NET_SendPa

; 1033 : 	{
; 1034 : 		net_socket = net.ip_sockets[sock];

	mov	ecx, DWORD PTR _sock$[ebp]
	mov	edx, DWORD PTR _net[ecx*4+1114840]
	mov	DWORD PTR _net_socket$[ebp], edx

; 1035 : 		if( net_socket == INVALID_SOCKET )

	cmp	DWORD PTR _net_socket$[ebp], -1
	jne	SHORT $LN10@NET_SendPa

; 1036 : 			return;

	jmp	$LN1@NET_SendPa
$LN10@NET_SendPa:

; 1037 : 	}

	jmp	SHORT $LN3@NET_SendPa
$LN8@NET_SendPa:

; 1038 : 	else
; 1039 : 	{
; 1040 : 		Host_Error( "NET_SendPacket: bad address type %i\n", to.type );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	push	OFFSET $SG132665
	call	_Host_Error
	add	esp, 8
$LN3@NET_SendPa:

; 1041 : 	}
; 1042 : 
; 1043 : 	NET_NetadrToSockadr( &to, &addr );

	lea	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _to$[ebp]
	push	edx
	call	_NET_NetadrToSockadr
	add	esp, 8

; 1044 : 
; 1045 : 	ret = NET_SendLong( sock, net_socket, data, length, 0, &addr, sizeof( addr ));

	push	16					; 00000010H
	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	_NET_SendLong
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 1046 : 
; 1047 : 	if( ret == SOCKET_ERROR )

	cmp	DWORD PTR _ret$[ebp], -1
	jne	$LN1@NET_SendPa

; 1048 : 	{
; 1049 : 		err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 1050 : 
; 1051 : 		// WSAEWOULDBLOCK is silent
; 1052 : 		if( err == WSAEWOULDBLOCK )

	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	jne	SHORT $LN12@NET_SendPa

; 1053 : 			return;

	jmp	$LN1@NET_SendPa
$LN12@NET_SendPa:

; 1054 : 
; 1055 : 		// some PPP links don't allow broadcasts
; 1056 : 		if( err == WSAEADDRNOTAVAIL && to.type == NA_BROADCAST )

	cmp	DWORD PTR _err$[ebp], 10049		; 00002741H
	jne	SHORT $LN13@NET_SendPa
	cmp	DWORD PTR _to$[ebp], 2
	jne	SHORT $LN13@NET_SendPa

; 1057 : 			return;

	jmp	$LN1@NET_SendPa
$LN13@NET_SendPa:

; 1058 : 
; 1059 : 		// let dedicated servers continue after errors
; 1060 : 		if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN14@NET_SendPa

; 1061 : 		{
; 1062 : 			Con_DPrintf( S_ERROR "NET_SendPacket: %s to %s\n", NET_ErrorString(), NET_AdrToString( to ));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET $SG132671
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1063 : 		}

	jmp	$LN1@NET_SendPa
$LN14@NET_SendPa:

; 1064 : 		else if( err == WSAEADDRNOTAVAIL || err == WSAENOBUFS )

	cmp	DWORD PTR _err$[ebp], 10049		; 00002741H
	je	SHORT $LN18@NET_SendPa
	cmp	DWORD PTR _err$[ebp], 10055		; 00002747H
	jne	SHORT $LN16@NET_SendPa
$LN18@NET_SendPa:

; 1065 : 		{
; 1066 : 			Con_DPrintf( S_ERROR "NET_SendPacket: %s to %s\n", NET_ErrorString(), NET_AdrToString( to ));

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET $SG132675
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1067 : 		}

	jmp	SHORT $LN1@NET_SendPa
$LN16@NET_SendPa:

; 1068 : 		else
; 1069 : 		{
; 1070 : 			Host_Error( "NET_SendPacket: %s to %s\n", NET_ErrorString(), NET_AdrToString( to ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET $SG132676
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN1@NET_SendPa:

; 1071 : 		}
; 1072 : 	}
; 1073 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_SendPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_uDecompressedLen$1 = -4				; size = 4
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_NET_BufferToBufferDecompress PROC

; 1114 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1115 : 	if( LZSS_IsCompressed( source ))

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_LZSS_IsCompressed
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@NET_Buffer

; 1116 : 	{
; 1117 : 		uint	uDecompressedLen = LZSS_GetActualSize( source );

	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_LZSS_GetActualSize
	add	esp, 4
	mov	DWORD PTR _uDecompressedLen$1[ebp], eax

; 1118 : 
; 1119 : 		if( uDecompressedLen <= *destLen )

	mov	edx, DWORD PTR _destLen$[ebp]
	mov	eax, DWORD PTR _uDecompressedLen$1[ebp]
	cmp	eax, DWORD PTR [edx]
	ja	SHORT $LN4@NET_Buffer

; 1120 : 		{
; 1121 : 			*destLen = LZSS_Decompress( source, dest );

	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	_LZSS_Decompress
	add	esp, 8
	mov	ecx, DWORD PTR _destLen$[ebp]
	mov	DWORD PTR [ecx], eax

; 1122 : 		}

	jmp	SHORT $LN5@NET_Buffer
$LN4@NET_Buffer:

; 1123 : 		else
; 1124 : 		{
; 1125 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Buffer
$LN5@NET_Buffer:

; 1126 : 		}
; 1127 : 	}

	jmp	SHORT $LN3@NET_Buffer
$LN2@NET_Buffer:

; 1128 : 	else
; 1129 : 	{
; 1130 : 		memcpy( dest, source, sourceLen );

	mov	edx, DWORD PTR _sourceLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1131 : 		*destLen = sourceLen;

	mov	edx, DWORD PTR _destLen$[ebp]
	mov	eax, DWORD PTR _sourceLen$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@NET_Buffer:

; 1132 : 	}
; 1133 : 
; 1134 : 	return true;

	mov	eax, 1
$LN1@NET_Buffer:

; 1135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_BufferToBufferDecompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_uCompressedLen$ = -8					; size = 4
_pbOut$ = -4						; size = 4
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_NET_BufferToBufferCompress PROC

; 1083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1084 : 	uint	uCompressedLen = 0;

	mov	DWORD PTR _uCompressedLen$[ebp], 0

; 1085 : 	byte	*pbOut = NULL;

	mov	DWORD PTR _pbOut$[ebp], 0

; 1086 : 
; 1087 : 	memcpy( dest, source, sourceLen );

	mov	eax, DWORD PTR _sourceLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1088 : 	pbOut = LZSS_Compress( source, sourceLen, &uCompressedLen );

	lea	eax, DWORD PTR _uCompressedLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sourceLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	_LZSS_Compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pbOut$[ebp], eax

; 1089 : 
; 1090 : 	if( pbOut && uCompressedLen > 0 && uCompressedLen <= *destLen )

	cmp	DWORD PTR _pbOut$[ebp], 0
	je	SHORT $LN2@NET_Buffer
	cmp	DWORD PTR _uCompressedLen$[ebp], 0
	jbe	SHORT $LN2@NET_Buffer
	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _uCompressedLen$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	SHORT $LN2@NET_Buffer

; 1091 : 	{
; 1092 : 		memcpy( dest, pbOut, uCompressedLen );

	mov	edx, DWORD PTR _uCompressedLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1093 : 		*destLen = uCompressedLen;

	mov	edx, DWORD PTR _destLen$[ebp]
	mov	eax, DWORD PTR _uCompressedLen$[ebp]
	mov	DWORD PTR [edx], eax

; 1094 : 		free( pbOut );

	mov	ecx, DWORD PTR _pbOut$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 1095 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Buffer

; 1096 : 	}

	jmp	SHORT $LN1@NET_Buffer
$LN2@NET_Buffer:

; 1097 : 	else
; 1098 : 	{
; 1099 : 		if( pbOut ) free( pbOut );

	cmp	DWORD PTR _pbOut$[ebp], 0
	je	SHORT $LN4@NET_Buffer
	mov	edx, DWORD PTR _pbOut$[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN4@NET_Buffer:

; 1100 : 		memcpy( dest, source, sourceLen );

	mov	eax, DWORD PTR _sourceLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1101 : 		*destLen = sourceLen;

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _sourceLen$[ebp]
	mov	DWORD PTR [eax], ecx

; 1102 : 		return false;

	xor	eax, eax
$LN1@NET_Buffer:

; 1103 : 	}
; 1104 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_BufferToBufferCompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_from$ = 12						; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_NET_GetPacket PROC

; 928  : {

	push	ebp
	mov	ebp, esp

; 929  : 	if( !data || !length )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@NET_GetPac
	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN2@NET_GetPac
$LN3@NET_GetPac:

; 930  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_GetPac
$LN2@NET_GetPac:

; 931  : 
; 932  : 	NET_AdjustLag();

	call	_NET_AdjustLag

; 933  : 
; 934  : 	if( NET_GetLoopPacket( sock, from, data, length ))

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_NET_GetLoopPacket
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@NET_GetPac

; 935  : 	{
; 936  : 		return NET_LagPacket( true, sock, from, length, data );

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	push	1
	call	_NET_LagPacket
	add	esp, 20					; 00000014H
	jmp	SHORT $LN1@NET_GetPac

; 937  : 	}

	jmp	SHORT $LN1@NET_GetPac
$LN4@NET_GetPac:

; 938  : 	else
; 939  : 	{
; 940  : 		return NET_QueuePacket( sock, from, data, length );

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	call	_NET_QueuePacket
	add	esp, 16					; 00000010H
$LN1@NET_GetPac:

; 941  : 	}
; 942  : }

	pop	ebp
	ret	0
_NET_GetPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 20
_b$ = 28						; size = 20
_NET_CompareBaseAdr PROC

; 362  : {

	push	ebp
	mov	ebp, esp

; 363  : 	if( a.type != b.type )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _b$[ebp]
	je	SHORT $LN2@NET_Compar

; 364  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN2@NET_Compar:

; 365  : 
; 366  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN3@NET_Compar

; 367  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN3@NET_Compar:

; 368  : 
; 369  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	SHORT $LN4@NET_Compar

; 370  : 	{
; 371  : 		if( !memcmp( a.ip, b.ip, 4 ))

	push	4
	lea	ecx, DWORD PTR _b$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp+4]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@NET_Compar

; 372  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN4@NET_Compar:

; 373  : 	}
; 374  : 
; 375  : 	return false;

	xor	eax, eax
$LN1@NET_Compar:

; 376  : }

	pop	ebp
	ret	0
_NET_CompareBaseAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 20
_b$ = 28						; size = 20
_NET_CompareAdr PROC

; 440  : {

	push	ebp
	mov	ebp, esp

; 441  : 	if( a.type != b.type )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _b$[ebp]
	je	SHORT $LN2@NET_Compar

; 442  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN2@NET_Compar:

; 443  : 
; 444  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN3@NET_Compar

; 445  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN3@NET_Compar:

; 446  : 
; 447  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	SHORT $LN4@NET_Compar

; 448  : 	{
; 449  : 		if(!memcmp( a.ip, b.ip, 4 ) && a.port == b.port )

	push	4
	lea	ecx, DWORD PTR _b$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp+4]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@NET_Compar
	movzx	eax, WORD PTR _a$[ebp+18]
	movzx	ecx, WORD PTR _b$[ebp+18]
	cmp	eax, ecx
	jne	SHORT $LN5@NET_Compar

; 450  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN5@NET_Compar:

; 451  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN4@NET_Compar:

; 452  : 	}
; 453  : 
; 454  : 	Con_DPrintf( S_ERROR "NET_CompareAdr: bad address type\n" );

	push	OFFSET $SG132397
	call	_Con_DPrintf
	add	esp, 4

; 455  : 	return false;

	xor	eax, eax
$LN1@NET_Compar:

; 456  : }

	pop	ebp
	ret	0
_NET_CompareAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_s$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_string$ = 8						; size = 4
_adr$ = 12						; size = 4
_NET_StringToAdr PROC

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 478  : 	struct sockaddr s;
; 479  : 
; 480  : 	if( !Q_stricmp( string, "localhost" ))

	push	99999					; 0001869fH
	push	OFFSET $SG132409
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@NET_String

; 481  : 	{
; 482  : 		memset( adr, 0, sizeof( netadr_t ));

	push	20					; 00000014H
	push	0
	mov	ecx, DWORD PTR _adr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 483  : 		adr->type = NA_LOOPBACK;

	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [edx], 1

; 484  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_String
$LN2@NET_String:

; 485  : 	}
; 486  : 
; 487  : 	if( !NET_StringToSockaddr( string, &s ))

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_NET_StringToSockaddr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@NET_String

; 488  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_String
$LN3@NET_String:

; 489  : 	NET_SockadrToNetadr( &s, adr );

	mov	edx, DWORD PTR _adr$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_NET_SockadrToNetadr
	add	esp, 8

; 490  : 
; 491  : 	return true;

	mov	eax, 1
$LN1@NET_String:

; 492  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_StringToAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 20
_b$ = 28						; size = 20
_NET_CompareClassBAdr PROC

; 386  : {

	push	ebp
	mov	ebp, esp

; 387  : 	if( a.type != b.type )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _b$[ebp]
	je	SHORT $LN2@NET_Compar

; 388  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN2@NET_Compar:

; 389  : 
; 390  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN3@NET_Compar

; 391  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN3@NET_Compar:

; 392  : 
; 393  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	SHORT $LN4@NET_Compar

; 394  : 	{
; 395  : 		if( a.ip[0] == b.ip[0] && a.ip[1] == b.ip[1] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	ecx, BYTE PTR _b$[ebp+edx+4]
	cmp	eax, ecx
	jne	SHORT $LN4@NET_Compar
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR _b$[ebp+ecx+4]
	cmp	eax, edx
	jne	SHORT $LN4@NET_Compar

; 396  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN4@NET_Compar:

; 397  : 	}
; 398  : 	return false;

	xor	eax, eax
$LN1@NET_Compar:

; 399  : }

	pop	ebp
	ret	0
_NET_CompareClassBAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 20
_NET_IsReservedAdr PROC

; 409  : {

	push	ebp
	mov	ebp, esp

; 410  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN2@NET_IsRese

; 411  : 		return true;

	mov	eax, 1
	jmp	$LN1@NET_IsRese
$LN2@NET_IsRese:

; 412  : 
; 413  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	$LN3@NET_IsRese

; 414  : 	{
; 415  : 		if( a.ip[0] == 10 || a.ip[0] == 127 )

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN5@NET_IsRese
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 127				; 0000007fH
	jne	SHORT $LN4@NET_IsRese
$LN5@NET_IsRese:

; 416  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_IsRese
$LN4@NET_IsRese:

; 417  : 
; 418  : 		if( a.ip[0] == 172 && a.ip[1] >= 16 )

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 172				; 000000acH
	jne	SHORT $LN6@NET_IsRese
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	cmp	ecx, 16					; 00000010H
	jl	SHORT $LN6@NET_IsRese

; 419  : 		{
; 420  : 			if( a.ip[1] >= 32 )

	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN7@NET_IsRese

; 421  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_IsRese
$LN7@NET_IsRese:

; 422  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_IsRese
$LN6@NET_IsRese:

; 423  : 		}
; 424  : 
; 425  : 		if( a.ip[0] == 192 && a.ip[1] >= 168 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN3@NET_IsRese
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 168				; 000000a8H
	jl	SHORT $LN3@NET_IsRese

; 426  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_IsRese
$LN3@NET_IsRese:

; 427  : 	}
; 428  : 
; 429  : 	return false;

	xor	eax, eax
$LN1@NET_IsRese:

; 430  : }

	pop	ebp
	ret	0
_NET_IsReservedAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 20
_NET_BaseAdrToString PROC

; 348  : {

	push	ebp
	mov	ebp, esp

; 349  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN2@NET_BaseAd

; 350  : 		return "loopback";

	mov	eax, OFFSET $SG132358
	jmp	SHORT $LN1@NET_BaseAd
$LN2@NET_BaseAd:

; 351  : 	return va( "%i.%i.%i.%i", a.ip[0], a.ip[1], a.ip[2], a.ip[3] );

	mov	eax, 1
	imul	ecx, eax, 3
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	push	edx
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	push	ecx
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	push	eax
	push	OFFSET $SG132359
	call	_va
	add	esp, 20					; 00000014H
$LN1@NET_BaseAd:

; 352  : }

	pop	ebp
	ret	0
_NET_BaseAdrToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_a$ = 8							; size = 20
_NET_AdrToString PROC

; 336  : {

	push	ebp
	mov	ebp, esp

; 337  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN2@NET_AdrToS

; 338  : 		return "loopback";

	mov	eax, OFFSET $SG132352
	jmp	SHORT $LN1@NET_AdrToS
$LN2@NET_AdrToS:

; 339  : 	return va( "%i.%i.%i.%i:%i", a.ip[0], a.ip[1], a.ip[2], a.ip[3], pNtohs( a.port ));

	movzx	eax, WORD PTR _a$[ebp+18]
	push	eax
	call	DWORD PTR _pNtohs
	movzx	ecx, ax
	push	ecx
	mov	edx, 1
	imul	eax, edx, 3
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	push	ecx
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	push	edx
	push	OFFSET $SG132353
	call	_va
	add	esp, 24					; 00000018H
$LN1@NET_AdrToS:

; 340  : }

	pop	ebp
	ret	0
_NET_AdrToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_adr$ = 8						; size = 20
_NET_IsLocalAddress PROC

; 464  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 465  : 	return (adr.type == NA_LOOPBACK) ? true : false;

	cmp	DWORD PTR _adr$[ebp], 1
	jne	SHORT $LN3@NET_IsLoca
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@NET_IsLoca
$LN3@NET_IsLoca:
	mov	DWORD PTR tv65[ebp], 0
$LN4@NET_IsLoca:
	mov	eax, DWORD PTR tv65[ebp]

; 466  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IsLocalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
tv80 = -8						; size = 4
_i$1 = -4						; size = 4
_multiplayer$ = 8					; size = 4
_NET_Config PROC

; 1326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1327 : 	static qboolean	bFirst = true;
; 1328 : 	static qboolean	old_config;
; 1329 : 
; 1330 : 	if( !net.initialized )

	cmp	DWORD PTR _net+1115248, 0
	jne	SHORT $LN5@NET_Config

; 1331 : 		return;

	jmp	$LN1@NET_Config
$LN5@NET_Config:

; 1332 : 
; 1333 : 	if( old_config == multiplayer )

	mov	eax, DWORD PTR ?old_config@?1??NET_Config@@9@9
	cmp	eax, DWORD PTR _multiplayer$[ebp]
	jne	SHORT $LN6@NET_Config

; 1334 : 		return;

	jmp	$LN1@NET_Config
$LN6@NET_Config:

; 1335 : 
; 1336 : 	old_config = multiplayer;

	mov	ecx, DWORD PTR _multiplayer$[ebp]
	mov	DWORD PTR ?old_config@?1??NET_Config@@9@9, ecx

; 1337 : 
; 1338 : 	if( multiplayer )

	cmp	DWORD PTR _multiplayer$[ebp], 0
	je	SHORT $LN7@NET_Config

; 1339 : 	{	
; 1340 : 		// open sockets
; 1341 : 		if( net.allow_ip ) NET_OpenIP();

	cmp	DWORD PTR _net+1115256, 0
	je	SHORT $LN9@NET_Config
	call	_NET_OpenIP
$LN9@NET_Config:

; 1342 : 
; 1343 : 		// get our local address, if possible
; 1344 : 		if( bFirst )

	cmp	DWORD PTR ?bFirst@?1??NET_Config@@9@9, 0
	je	SHORT $LN10@NET_Config

; 1345 : 		{
; 1346 : 			NET_GetLocalAddress();

	call	_NET_GetLocalAddress

; 1347 : 			bFirst = false;

	mov	DWORD PTR ?bFirst@?1??NET_Config@@9@9, 0
$LN10@NET_Config:

; 1348 : 		}
; 1349 : 	}

	jmp	SHORT $LN8@NET_Config
$LN7@NET_Config:

; 1350 : 	else
; 1351 : 	{	
; 1352 : 		int	i;
; 1353 : 
; 1354 : 		// shut down any existing sockets
; 1355 : 		for( i = 0; i < NS_COUNT; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@NET_Config
$LN2@NET_Config:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@NET_Config:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN8@NET_Config

; 1356 : 		{
; 1357 : 			if( net.ip_sockets[i] != INVALID_SOCKET )

	mov	eax, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR _net[eax*4+1114840], -1
	je	SHORT $LN11@NET_Config

; 1358 : 			{
; 1359 : 				pCloseSocket( net.ip_sockets[i] );

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _net[ecx*4+1114840]
	push	edx
	call	DWORD PTR _pCloseSocket

; 1360 : 				net.ip_sockets[i] = INVALID_SOCKET;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _net[eax*4+1114840], -1
$LN11@NET_Config:

; 1361 : 			}
; 1362 : 		}

	jmp	SHORT $LN2@NET_Config
$LN8@NET_Config:

; 1363 : 	}
; 1364 : 
; 1365 : 	NET_ClearLoopback ();

	call	_NET_ClearLoopback

; 1366 : 
; 1367 : 	net.configured = multiplayer ? true : false;

	cmp	DWORD PTR _multiplayer$[ebp], 0
	je	SHORT $LN13@NET_Config
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN14@NET_Config
$LN13@NET_Config:
	mov	DWORD PTR tv80[ebp], 0
$LN14@NET_Config:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _net+1115252, ecx
$LN1@NET_Config:

; 1368 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Config ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_NET_IsConfigured PROC

; 1378 : {

	push	ebp
	mov	ebp, esp

; 1379 : 	return net.configured;

	mov	eax, DWORD PTR _net+1115252

; 1380 : }

	pop	ebp
	ret	0
_NET_IsConfigured ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_NET_IsActive PROC

; 1388 : {

	push	ebp
	mov	ebp, esp

; 1389 : 	return net.initialized;

	mov	eax, DWORD PTR _net+1115248

; 1390 : }

	pop	ebp
	ret	0
_NET_IsActive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_timeout$ = -276					; size = 8
_i$ = -268						; size = 4
_fdset$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_msec$ = 8						; size = 4
_NET_Sleep PROC

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1401 : 	struct timeval	timeout;
; 1402 : 	fd_set		fdset;
; 1403 : 	int		i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1404 : 
; 1405 : 	if( !net.initialized || host.type == HOST_NORMAL )

	cmp	DWORD PTR _net+1115248, 0
	je	SHORT $LN6@NET_Sleep
	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN5@NET_Sleep
$LN6@NET_Sleep:

; 1406 : 		return; // we're not a dedicated server, just run full speed

	jmp	$LN1@NET_Sleep
$LN5@NET_Sleep:

; 1407 : 
; 1408 : 	FD_ZERO( &fdset );

	mov	DWORD PTR _fdset$[ebp], 0

; 1409 : 
; 1410 : 	if( net.ip_sockets[NS_SERVER] != INVALID_SOCKET )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _net[eax+1114840], -1
	je	SHORT $LN7@NET_Sleep
$LN4@NET_Sleep:

; 1411 : 	{
; 1412 : 		FD_SET( net.ip_sockets[NS_SERVER], &fdset ); // network socket

	cmp	DWORD PTR _fdset$[ebp], 64		; 00000040H
	jae	SHORT $LN2@NET_Sleep
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fdset$[ebp]
	mov	eax, DWORD PTR _net[ecx+1114840]
	mov	DWORD PTR _fdset$[ebp+edx*4+4], eax
	mov	ecx, DWORD PTR _fdset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _fdset$[ebp], ecx
$LN2@NET_Sleep:
	xor	edx, edx
	jne	SHORT $LN4@NET_Sleep

; 1413 : 		i = net.ip_sockets[NS_SERVER];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _net[eax+1114840]
	mov	DWORD PTR _i$[ebp], ecx
$LN7@NET_Sleep:

; 1414 : 	}
; 1415 : 
; 1416 : 	timeout.tv_sec = msec / 1000;

	mov	eax, DWORD PTR _msec$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _timeout$[ebp], eax

; 1417 : 	timeout.tv_usec = (msec % 1000) * 1000;

	mov	eax, DWORD PTR _msec$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	imul	edx, edx, 1000
	mov	DWORD PTR _timeout$[ebp+4], edx

; 1418 : 	pSelect( i+1, &fdset, NULL, NULL, &timeout );

	lea	eax, DWORD PTR _timeout$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _fdset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR _pSelect
$LN1@NET_Sleep:

; 1419 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Sleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_NET_Shutdown PROC

; 1501 : {

	push	ebp
	mov	ebp, esp

; 1502 : 	if( !net.initialized )

	cmp	DWORD PTR _net+1115248, 0
	jne	SHORT $LN2@NET_Shutdo

; 1503 : 		return;

	jmp	SHORT $LN1@NET_Shutdo
$LN2@NET_Shutdo:

; 1504 : 
; 1505 : 	NET_ClearLagData( true, true );

	push	1
	push	1
	call	_NET_ClearLagData
	add	esp, 8

; 1506 : 
; 1507 : 	NET_Config( false );

	push	0
	call	_NET_Config
	add	esp, 4

; 1508 : 	pWSACleanup();

	call	DWORD PTR _pWSACleanup

; 1509 : 	NET_FreeWinSock();

	call	_NET_FreeWinSock

; 1510 : 	net.initialized = false;

	mov	DWORD PTR _net+1115248, 0
$LN1@NET_Shutdo:

; 1511 : }

	pop	ebp
	ret	0
_NET_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\net_ws.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_cmd$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_NET_Init PROC

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1441 : 	char	cmd[64];
; 1442 : 	int	i = 1;

	mov	DWORD PTR _i$[ebp], 1

; 1443 : 
; 1444 : 	if( net.initialized ) return;

	cmp	DWORD PTR _net+1115248, 0
	je	SHORT $LN5@NET_Init
	jmp	$LN1@NET_Init
$LN5@NET_Init:

; 1445 : 
; 1446 : 	net_clockwindow = Cvar_Get( "clockwindow", "0.5", 0, "timewindow to execute client moves" );

	push	OFFSET $SG132874
	push	0
	push	OFFSET $SG132875
	push	OFFSET $SG132876
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_clockwindow, eax

; 1447 : 	net_address = Cvar_Get( "net_address", "0", FCVAR_READ_ONLY, "contain local address of current client" );

	push	OFFSET $SG132877
	push	131072					; 00020000H
	push	OFFSET $SG132878
	push	OFFSET $SG132879
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_address, eax

; 1448 : 	net_ipname = Cvar_Get( "ip", "localhost", FCVAR_READ_ONLY, "network ip address" );

	push	OFFSET $SG132880
	push	131072					; 00020000H
	push	OFFSET $SG132881
	push	OFFSET $SG132882
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_ipname, eax

; 1449 : 	net_iphostport = Cvar_Get( "ip_hostport", "0", FCVAR_READ_ONLY, "network ip host port" );

	push	OFFSET $SG132883
	push	131072					; 00020000H
	push	OFFSET $SG132884
	push	OFFSET $SG132885
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_iphostport, eax

; 1450 : 	net_hostport = Cvar_Get( "hostport", va( "%i", PORT_SERVER ), FCVAR_READ_ONLY, "network default host port" );

	push	OFFSET $SG132886
	push	131072					; 00020000H
	push	27015					; 00006987H
	push	OFFSET $SG132887
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG132888
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_hostport, eax

; 1451 : 	net_ipclientport = Cvar_Get( "ip_clientport", "0", FCVAR_READ_ONLY, "network ip client port" );

	push	OFFSET $SG132889
	push	131072					; 00020000H
	push	OFFSET $SG132890
	push	OFFSET $SG132891
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_ipclientport, eax

; 1452 : 	net_clientport = Cvar_Get( "clientport", va( "%i", PORT_CLIENT ), FCVAR_READ_ONLY, "network default client port" );

	push	OFFSET $SG132892
	push	131072					; 00020000H
	push	27005					; 0000697dH
	push	OFFSET $SG132893
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG132894
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_clientport, eax

; 1453 : 	net_fakelag = Cvar_Get( "fakelag", "0", 0, "lag all incoming network data (including loopback) by xxx ms." );

	push	OFFSET $SG132895
	push	0
	push	OFFSET $SG132896
	push	OFFSET $SG132897
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_fakelag, eax

; 1454 : 	net_fakeloss = Cvar_Get( "fakeloss", "0", 0, "act like we dropped the packet this % of the time." );

	push	OFFSET $SG132898
	push	0
	push	OFFSET $SG132899
	push	OFFSET $SG132900
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_fakeloss, eax

; 1455 : 
; 1456 : 	// prepare some network data
; 1457 : 	for( i = 0; i < NS_COUNT; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NET_Init
$LN2@NET_Init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NET_Init:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@NET_Init

; 1458 : 	{
; 1459 : 		net.lagdata[i].prev = &net.lagdata[i];

	imul	ecx, DWORD PTR _i$[ebp], 40
	add	ecx, OFFSET _net+1049008
	imul	edx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _net[edx+1049044], ecx

; 1460 : 		net.lagdata[i].next = &net.lagdata[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _net+1049008
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _net[ecx+1049040], eax

; 1461 : 		net.ip_sockets[i] = INVALID_SOCKET;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _net[edx*4+1114840], -1

; 1462 : 	}

	jmp	SHORT $LN2@NET_Init
$LN3@NET_Init:

; 1463 : 
; 1464 : 	if( !NET_OpenWinSock( ))	// loading wsock32.dll

	call	_NET_OpenWinSock
	test	eax, eax
	jne	SHORT $LN6@NET_Init

; 1465 : 	{
; 1466 : 		Con_DPrintf( S_ERROR "network failed to load wsock32.dll.\n" );

	push	OFFSET $SG132902
	call	_Con_DPrintf
	add	esp, 4

; 1467 : 		return;

	jmp	$LN1@NET_Init
$LN6@NET_Init:

; 1468 : 	}
; 1469 : 
; 1470 : 	if( pWSAStartup( MAKEWORD( 1, 1 ), &net.winsockdata ))

	push	OFFSET _net+1114848
	push	257					; 00000101H
	call	DWORD PTR _pWSAStartup
	test	eax, eax
	je	SHORT $LN7@NET_Init

; 1471 : 	{
; 1472 : 		Con_DPrintf( S_ERROR "network initialization failed.\n" );

	push	OFFSET $SG132904
	call	_Con_DPrintf
	add	esp, 4

; 1473 : 		NET_FreeWinSock();

	call	_NET_FreeWinSock

; 1474 : 		return;

	jmp	$LN1@NET_Init
$LN7@NET_Init:

; 1475 : 	}
; 1476 : 
; 1477 : 	if( Sys_CheckParm( "-noip" ))

	push	OFFSET $SG132907
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@NET_Init

; 1478 : 		net.allow_ip = false;

	mov	DWORD PTR _net+1115256, 0
	jmp	SHORT $LN9@NET_Init
$LN8@NET_Init:

; 1479 : 	else net.allow_ip = true;

	mov	DWORD PTR _net+1115256, 1
$LN9@NET_Init:

; 1480 : 
; 1481 : 	// specify custom host port
; 1482 : 	if( Sys_GetParmFromCmdLine( "-port", cmd ) && Q_isdigit( cmd ))

	push	64					; 00000040H
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	push	OFFSET $SG132909
	call	__Sys_GetParmFromCmdLine
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@NET_Init
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@NET_Init

; 1483 : 		Cvar_FullSet( "hostport", cmd, FCVAR_READ_ONLY );

	push	131072					; 00020000H
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	push	OFFSET $SG132910
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN10@NET_Init:

; 1484 : 
; 1485 : 	// adjust clockwindow
; 1486 : 	if( Sys_GetParmFromCmdLine( "-clockwindow", cmd ))

	push	64					; 00000040H
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	push	OFFSET $SG132912
	call	__Sys_GetParmFromCmdLine
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@NET_Init

; 1487 : 		Cvar_SetValue( "clockwindow", Q_atof( cmd ));

	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Q_atof
	fstp	DWORD PTR [esp]
	push	OFFSET $SG132913
	call	_Cvar_SetValue
	add	esp, 8
$LN11@NET_Init:

; 1488 : 
; 1489 : 	net.sequence_number = 1;

	mov	DWORD PTR _net+1114836, 1

; 1490 : 	net.initialized = true;

	mov	DWORD PTR _net+1115248, 1

; 1491 : 	Con_Reportf( "Base networking initialized.\n" );

	push	OFFSET $SG132914
	call	_Con_Reportf
	add	esp, 4
$LN1@NET_Init:

; 1492 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Init ENDP
_TEXT	ENDS
END
