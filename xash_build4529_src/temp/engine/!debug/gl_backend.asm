; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\gl_backend.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_r_skyBoxInfo
PUBLIC	_r_envMapInfo
_DATA	SEGMENT
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_r_stats:BYTE:040H
COMM	_r_speeds_msg:BYTE:0400H
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
_DATA	ENDS
CONST	SEGMENT
_r_skyBoxInfo DD 000000000r			; 0
	DD	043870000r			; 270
	DD	043340000r			; 180
	DD	010000H
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	043340000r			; 180
	DD	010000H
	DD	0c2b40000r			; -90
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	010000H
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	010000H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	010000H
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	043340000r			; 180
	DD	010000H
_r_envMapInfo DD 000000000r			; 0
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	00H
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	0c2b40000r			; -90
	DD	00H
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	00H
	DD	000000000r			; 0
	DD	043870000r			; 270
	DD	043340000r			; 180
	DD	00H
	DD	0c2b40000r			; -90
	DD	043340000r			; 180
	DD	0c2b40000r			; -90
	DD	00H
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	00H
CONST	ENDS
PUBLIC	_GL_BackendStartFrame
PUBLIC	_GL_BackendEndFrame
PUBLIC	_GL_CleanUpTextureUnits
PUBLIC	_GL_MultiTexCoord2f
PUBLIC	_GL_SetTexCoordArrayMode
PUBLIC	_GL_LoadTexMatrix
PUBLIC	_GL_LoadTexMatrixExt
PUBLIC	_GL_LoadMatrix
PUBLIC	_GL_TexGen
PUBLIC	_GL_SelectTexture
PUBLIC	_GL_CleanupAllTextureUnits
PUBLIC	_GL_LoadIdentityTexMatrix
PUBLIC	_GL_DisableAllTexGens
PUBLIC	_GL_SetRenderMode
PUBLIC	_GL_TextureTarget
PUBLIC	_GL_Cull
PUBLIC	_R_ShowTextures
PUBLIC	_R_ShowTree
PUBLIC	_VID_ScreenShot
PUBLIC	_VID_CubemapShot
PUBLIC	_R_SpeedsMessage
PUBLIC	_R_Speeds_Printf
PUBLIC	_VID_WriteOverviewScript
PUBLIC	_R_DrawLeafNode
PUBLIC	_R_DrawNodeConnection
PUBLIC	_R_ShowTree_r
PUBLIC	__real@00000000
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40600000
PUBLIC	__real@41800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_AllowDirectPaths:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_DefaultExtension:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_FS_Print:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_SaveImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Image_Process:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_pfnNumberOfEntities:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_CL_DrawCenterPrint:PROC
EXTRN	_CL_CenterPrint:PROC
EXTRN	_Con_DrawStringLen:PROC
EXTRN	_Con_DrawString:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_R_Set2DMode:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_R_DrawCubemapView:PROC
EXTRN	_R_CheckGamma:PROC
EXTRN	_Matrix4x4_ToArrayFloatGL:PROC
EXTRN	_GL_Support:PROC
EXTRN	_GL_MaxTextureUnits:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_cl:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gl_showtextures:DWORD
EXTRN	_r_temppool:DWORD
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_glConfig:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	_r_speeds:DWORD
EXTRN	_r_showtree:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@40600000
CONST	SEGMENT
__real@40600000 DD 040600000r			; 3.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG143341 DB	'Renderer: ^1Engine^7', 0aH, 0aH, 00H
	ORG $+1
$SG143343 DB	'%3i wpoly, %3i apoly', 0aH, '%3i epoly, %3i spoly', 00H
	ORG $+2
$SG143345 DB	'visible leafs:', 0aH, '%3i leafs', 0aH, 'current leaf %3'
	DB	'i', 0aH, 00H
	ORG $+1
$SG143346 DB	'ReciusiveWorldNode: %3lf secs', 0aH, 'DrawTextureChains '
	DB	'%lf', 0aH, 00H
	ORG $+3
$SG143348 DB	'%3i alias models drawn', 0aH, '%3i studio models drawn', 0aH
	DB	'%3i sprites drawn', 00H
	ORG $+3
$SG143350 DB	'%3i static entities', 0aH, '%3i normal entities', 0aH, '%'
	DB	'3i server entities', 00H
$SG143352 DB	'%3i tempents', 0aH, '%3i viewbeams', 0aH, '%3i particles'
	DB	00H
	ORG $+3
$SG143362 DB	'glmatrix != NULL', 00H
	ORG $+3
$SG143361 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143376 DB	'^1Error:^7 GL_SelectTexture: bad tmu state %i', 0aH, 00H
	ORG $+1
$SG143408 DB	'^1Error:^7 GL_TextureTarget: bad tmu state %i', 0aH, 00H
	ORG $+1
$SG143473 DB	'overviews/%s.txt', 00H
	ORG $+3
$SG143474 DB	'w', 00H
	ORG $+2
$SG143476 DB	'// overview description file for %s.bsp', 0aH, 0aH, 00H
	ORG $+2
$SG143477 DB	'global', 0aH, '{', 0aH, 00H
	ORG $+2
$SG143478 DB	09H, 'ZOOM', 09H, '%.2f', 0aH, 00H
$SG143479 DB	09H, 'ORIGIN', 09H, '%.2f', 09H, '%.2f', 09H, '%.2f', 0aH
	DB	00H
$SG143480 DB	09H, 'ROTATED', 09H, '%i', 0aH, 00H
	ORG $+3
$SG143481 DB	'}', 0aH, 0aH, 'layer', 0aH, '{', 0aH, 00H
$SG143482 DB	09H, 'IMAGE', 09H, '"overviews/%s.bmp"', 0aH, 00H
	ORG $+1
$SG143483 DB	09H, 'HEIGHT', 09H, '%.2f', 0aH, 00H
	ORG $+2
$SG143484 DB	'}', 0aH, 00H
	ORG $+1
$SG143499 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143500 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143540 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143541 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143542 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143543 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\gl_backend.c', 00H
	ORG $+2
$SG143548 DB	'.tga', 00H
	ORG $+3
?showHelp@?1??R_ShowTextures@@9@9 DD 01H		; `R_ShowTextures'::`2'::showHelp
$SG143582 DB	'use ''<-'' and ''->'' keys to change atlas page, ESC to '
	DB	'quit', 00H
	ORG $+3
$SG143587 DB	'r_showtextures', 00H
	ORG $+1
$SG143656 DB	'max recursion %d', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_leaf$1 = -12						; size = 4
tv66 = -8						; size = 4
_downScale$ = -4					; size = 4
_node$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_scale$ = 20						; size = 4
_shownodes$ = 24					; size = 4
_R_ShowTree_r PROC

; 768  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 769  : 	float	downScale = scale * 0.8f;

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _downScale$[ebp], xmm0

; 770  : 
; 771  : 	downScale = Q_max( downScale, 1.0f );

	movss	xmm0, DWORD PTR _downScale$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@R_ShowTree
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN15@R_ShowTree
$LN14@R_ShowTree:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv66[ebp], xmm0
$LN15@R_ShowTree:
	movss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR _downScale$[ebp], xmm0

; 772  : 
; 773  : 	if( !node ) return;

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@R_ShowTree
	jmp	$LN1@R_ShowTree
$LN2@R_ShowTree:

; 774  : 
; 775  : 	tr.recursion_level++;

	mov	eax, DWORD PTR _tr+66700
	add	eax, 1
	mov	DWORD PTR _tr+66700, eax

; 776  : 
; 777  : 	if( node->contents < 0 )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN3@R_ShowTree

; 778  : 	{
; 779  : 		mleaf_t	*leaf = (mleaf_t *)node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$1[ebp], edx

; 780  : 
; 781  : 		if( tr.recursion_level > tr.max_recursion )

	mov	eax, DWORD PTR _tr+66700
	cmp	eax, DWORD PTR _tr+66704
	jle	SHORT $LN4@R_ShowTree

; 782  : 			tr.max_recursion = tr.recursion_level;

	mov	ecx, DWORD PTR _tr+66700
	mov	DWORD PTR _tr+66704, ecx
$LN4@R_ShowTree:

; 783  : 
; 784  : 		if( shownodes == 1 )

	cmp	DWORD PTR _shownodes$[ebp], 1
	jne	$LN5@R_ShowTree

; 785  : 		{
; 786  : 			if( cl.worldmodel->leafs == leaf )

	mov	edx, DWORD PTR _cl+2686576
	mov	eax, DWORD PTR [edx+140]
	cmp	eax, DWORD PTR _leaf$1[ebp]
	jne	SHORT $LN6@R_ShowTree

; 787  : 				pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
	jmp	SHORT $LN9@R_ShowTree
$LN6@R_ShowTree:

; 788  : 			else if( RI.viewleaf && RI.viewleaf == leaf )

	cmp	DWORD PTR _RI+180, 0
	je	SHORT $LN8@R_ShowTree
	mov	ecx, DWORD PTR _RI+180
	cmp	ecx, DWORD PTR _leaf$1[ebp]
	jne	SHORT $LN8@R_ShowTree

; 789  : 				pglColor4f( 1.0f, 0.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
	jmp	SHORT $LN9@R_ShowTree
$LN8@R_ShowTree:

; 790  : 			else pglColor4f( 0.0f, 1.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN9@R_ShowTree:

; 791  : 			R_DrawLeafNode( x, y, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawLeafNode
	add	esp, 12					; 0000000cH
$LN5@R_ShowTree:

; 792  : 		}
; 793  : 		tr.recursion_level--;

	mov	edx, DWORD PTR _tr+66700
	sub	edx, 1
	mov	DWORD PTR _tr+66700, edx

; 794  : 		return;

	jmp	$LN1@R_ShowTree
$LN3@R_ShowTree:

; 795  : 	}
; 796  : 
; 797  : 	if( shownodes == 1 )

	cmp	DWORD PTR _shownodes$[ebp], 1
	jne	SHORT $LN10@R_ShowTree

; 798  : 	{
; 799  : 		pglColor4f( 0.0f, 0.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 800  : 		R_DrawLeafNode( x, y, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawLeafNode
	add	esp, 12					; 0000000cH

; 801  : 	}

	jmp	$LN12@R_ShowTree
$LN10@R_ShowTree:

; 802  : 	else if( shownodes == 2 )

	cmp	DWORD PTR _shownodes$[ebp], 2
	jne	SHORT $LN12@R_ShowTree

; 803  : 	{
; 804  : 		R_DrawNodeConnection( x, y, x - scale, y + scale );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawNodeConnection
	add	esp, 16					; 00000010H

; 805  : 		R_DrawNodeConnection( x, y, x + scale, y + scale );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawNodeConnection
	add	esp, 16					; 00000010H
$LN12@R_ShowTree:

; 806  : 	}
; 807  : 
; 808  : 	R_ShowTree_r( node->children[1], x - scale, y + scale, downScale, shownodes );

	mov	eax, DWORD PTR _shownodes$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 809  : 	R_ShowTree_r( node->children[0], x + scale, y + scale, downScale, shownodes );

	mov	ecx, DWORD PTR _shownodes$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 810  : 
; 811  : 	tr.recursion_level--;

	mov	eax, DWORD PTR _tr+66700
	sub	eax, 1
	mov	DWORD PTR _tr+66700, eax
$LN1@R_ShowTree:

; 812  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShowTree_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_R_DrawNodeConnection PROC

; 760  : {

	push	ebp
	mov	ebp, esp

; 761  : 	pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 762  : 		pglVertex2f( x, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 763  : 		pglVertex2f( x2, y2 );

	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 764  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 765  : }

	pop	ebp
	ret	0
_R_DrawNodeConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_downScale$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scale$ = 16						; size = 4
_R_DrawLeafNode PROC

; 753  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 754  : 	float downScale = scale * 0.25f;// * POINT_SIZE;

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _downScale$[ebp], xmm0

; 755  : 
; 756  : 	R_DrawStretchPic( x - downScale * 0.5f, y - downScale * 0.5f, downScale, downScale, 0, 0, 1, 1, tr.particleTexture );

	mov	eax, DWORD PTR _tr+4
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _downScale$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _downScale$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 757  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawLeafNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
tv135 = -272						; size = 4
_ov$ = -268						; size = 4
_f$ = -264						; size = 4
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_VID_WriteOverviewScript PROC

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 465  : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+125416

; 466  : 	string		filename;
; 467  : 	file_t		*f;
; 468  : 
; 469  : 	Q_snprintf( filename, sizeof( filename ), "overviews/%s.txt", clgame.mapname );

	push	OFFSET _clgame+232
	push	OFFSET $SG143473
	push	256					; 00000100H
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 470  : 
; 471  : 	f = FS_Open( filename, "w", false );

	push	0
	push	OFFSET $SG143474
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 472  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@VID_WriteO
	jmp	$LN1@VID_WriteO
$LN2@VID_WriteO:

; 473  : 
; 474  : 	FS_Printf( f, "// overview description file for %s.bsp\n\n", clgame.mapname );

	push	OFFSET _clgame+232
	push	OFFSET $SG143476
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 475  : 	FS_Print( f, "global\n{\n" );

	push	OFFSET $SG143477
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 476  : 	FS_Printf( f, "\tZOOM\t%.2f\n", ov->flZoom );

	mov	ecx, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+40]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG143478
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 16					; 00000010H

; 477  : 	FS_Printf( f, "\tORIGIN\t%.2f\t%.2f\t%.2f\n", ov->origin[0], ov->origin[1], ov->origin[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG143479
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 32					; 00000020H

; 478  : 	FS_Printf( f, "\tROTATED\t%i\n", ov->rotated ? 1 : 0 );

	mov	edx, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN4@VID_WriteO
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN5@VID_WriteO
$LN4@VID_WriteO:
	mov	DWORD PTR tv135[ebp], 0
$LN5@VID_WriteO:
	mov	eax, DWORD PTR tv135[ebp]
	push	eax
	push	OFFSET $SG143480
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 479  : 	FS_Print( f, "}\n\nlayer\n{\n" );

	push	OFFSET $SG143481
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 480  : 	FS_Printf( f, "\tIMAGE\t\"overviews/%s.bmp\"\n", clgame.mapname );

	push	OFFSET _clgame+232
	push	OFFSET $SG143482
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 481  : 	FS_Printf( f, "\tHEIGHT\t%.2f\n", ov->zFar );	// ???

	mov	ecx, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+32]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG143483
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 16					; 00000010H

; 482  : 	FS_Print( f, "}\n" );

	push	OFFSET $SG143484
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 483  : 
; 484  : 	FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4
$LN1@VID_WriteO:

; 485  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_WriteOverviewScript ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_argptr$ = -2056					; size = 4
_text$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_R_Speeds_Printf PROC

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2056				; 00000808H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 55   : 	va_list	argptr;
; 56   : 	char	text[2048];
; 57   : 
; 58   : 	va_start( argptr, msg );

	lea	eax, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 59   : 	Q_vsprintf( text, msg, argptr );

	mov	ecx, DWORD PTR _argptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	99999					; 0001869fH
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 60   : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 61   : 
; 62   : 	Q_strncat( r_speeds_msg, text, sizeof( r_speeds_msg ));

	push	1024					; 00000400H
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	push	OFFSET _r_speeds_msg
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 63   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Speeds_Printf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_out$ = 8						; size = 4
_size$ = 12						; size = 4
_R_SpeedsMessage PROC

; 30   : {

	push	ebp
	mov	ebp, esp

; 31   : 	if( clgame.drawFuncs.R_SpeedsMessage != NULL )

	cmp	DWORD PTR _clgame+200, 0
	je	SHORT $LN3@R_SpeedsMe

; 32   : 	{
; 33   : 		if( clgame.drawFuncs.R_SpeedsMessage( out, size ))

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	DWORD PTR _clgame+200
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@R_SpeedsMe

; 34   : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_SpeedsMe
$LN3@R_SpeedsMe:

; 35   : 		// otherwise pass to default handler
; 36   : 	}
; 37   : 
; 38   : 	if( r_speeds->value <= 0 ) return false;

	mov	edx, DWORD PTR _r_speeds
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+12]
	jb	SHORT $LN4@R_SpeedsMe
	xor	eax, eax
	jmp	SHORT $LN1@R_SpeedsMe
$LN4@R_SpeedsMe:

; 39   : 	if( !out || !size ) return false;

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN6@R_SpeedsMe
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN5@R_SpeedsMe
$LN6@R_SpeedsMe:
	xor	eax, eax
	jmp	SHORT $LN1@R_SpeedsMe
$LN5@R_SpeedsMe:

; 40   : 
; 41   : 	Q_strncpy( out, r_speeds_msg, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET _r_speeds_msg
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 42   : 
; 43   : 	return true;

	mov	eax, 1
$LN1@R_SpeedsMe:

; 44   : }

	pop	ebp
	ret	0
_R_SpeedsMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_result$ = -292						; size = 4
tv193 = -288						; size = 4
_buffer$ = -284						; size = 4
_flags$ = -280						; size = 4
_temp$ = -276						; size = 4
_r_side$ = -272						; size = 4
_r_shot$ = -268						; size = 4
_i$ = -264						; size = 4
_basename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_vieworg$ = 16						; size = 4
_skyshot$ = 20						; size = 4
_VID_CubemapShot PROC

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 557  : 	rgbdata_t		*r_shot, *r_side;
; 558  : 	byte		*temp = NULL;

	mov	DWORD PTR _temp$[ebp], 0

; 559  : 	byte		*buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 560  : 	string		basename;
; 561  : 	int		i = 1, flags, result;

	mov	DWORD PTR _i$[ebp], 1

; 562  : 
; 563  : 	if( !RI.drawWorld || !cl.worldmodel )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN8@VID_Cubema
	cmp	DWORD PTR _cl+2686576, 0
	jne	SHORT $LN7@VID_Cubema
$LN8@VID_Cubema:

; 564  : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Cubema
$LN7@VID_Cubema:

; 565  : 
; 566  : 	// make sure the specified size is valid
; 567  : 	while( i < size ) i<<=1;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN3@VID_Cubema
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN7@VID_Cubema
$LN3@VID_Cubema:

; 568  : 
; 569  : 	if( i != size ) return false;

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	je	SHORT $LN9@VID_Cubema
	xor	eax, eax
	jmp	$LN1@VID_Cubema
$LN9@VID_Cubema:

; 570  : 	if( size > glState.width || size > glState.height )

	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _glState
	ja	SHORT $LN11@VID_Cubema
	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ecx, DWORD PTR _glState+4
	jbe	SHORT $LN10@VID_Cubema
$LN11@VID_Cubema:

; 571  : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Cubema
$LN10@VID_Cubema:

; 572  : 
; 573  : 	// alloc space
; 574  : 	temp = Mem_Malloc( r_temppool, size * size * 3 );

	push	574					; 0000023eH
	push	OFFSET $SG143540
	push	0
	mov	edx, DWORD PTR _size$[ebp]
	imul	edx, DWORD PTR _size$[ebp]
	imul	eax, edx, 3
	push	eax
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp], eax

; 575  : 	buffer = Mem_Malloc( r_temppool, size * size * 3 * 6 );

	push	575					; 0000023fH
	push	OFFSET $SG143541
	push	0
	mov	edx, DWORD PTR _size$[ebp]
	imul	edx, DWORD PTR _size$[ebp]
	imul	eax, edx, 3
	imul	ecx, eax, 6
	push	ecx
	mov	edx, DWORD PTR _r_temppool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buffer$[ebp], eax

; 576  : 	r_shot = Mem_Calloc( r_temppool, sizeof( rgbdata_t ));

	push	576					; 00000240H
	push	OFFSET $SG143542
	push	1
	push	36					; 00000024H
	mov	eax, DWORD PTR _r_temppool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _r_shot$[ebp], eax

; 577  : 	r_side = Mem_Calloc( r_temppool, sizeof( rgbdata_t ));

	push	577					; 00000241H
	push	OFFSET $SG143543
	push	1
	push	36					; 00000024H
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _r_side$[ebp], eax

; 578  : 
; 579  : 	// use client vieworg
; 580  : 	if( !vieworg ) vieworg = RI.vieworg;

	cmp	DWORD PTR _vieworg$[ebp], 0
	jne	SHORT $LN12@VID_Cubema
	mov	DWORD PTR _vieworg$[ebp], OFFSET _RI+200
$LN12@VID_Cubema:

; 581  : 
; 582  : 	R_CheckGamma();

	call	_R_CheckGamma

; 583  : 
; 584  : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@VID_Cubema
$LN4@VID_Cubema:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@VID_Cubema:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN5@VID_Cubema

; 585  : 	{
; 586  : 		// go into 3d mode
; 587  : 		R_Set2DMode( false );

	push	0
	call	_R_Set2DMode
	add	esp, 4

; 588  : 
; 589  : 		if( skyshot )

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN13@VID_Cubema

; 590  : 		{
; 591  : 			R_DrawCubemapView( vieworg, r_skyBoxInfo[i].angles, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _r_skyBoxInfo
	push	ecx
	mov	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_R_DrawCubemapView
	add	esp, 12					; 0000000cH

; 592  : 			flags = r_skyBoxInfo[i].flags;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _r_skyBoxInfo[eax+12]
	mov	DWORD PTR _flags$[ebp], ecx

; 593  : 		}

	jmp	SHORT $LN14@VID_Cubema
$LN13@VID_Cubema:

; 594  : 		else
; 595  : 		{
; 596  : 			R_DrawCubemapView( vieworg, r_envMapInfo[i].angles, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _r_envMapInfo
	push	eax
	mov	ecx, DWORD PTR _vieworg$[ebp]
	push	ecx
	call	_R_DrawCubemapView
	add	esp, 12					; 0000000cH

; 597  : 			flags = r_envMapInfo[i].flags;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _r_envMapInfo[edx+12]
	mov	DWORD PTR _flags$[ebp], eax
$LN14@VID_Cubema:

; 598  : 		}
; 599  : 
; 600  : 		pglReadPixels( 0, 0, size, size, GL_RGB, GL_UNSIGNED_BYTE, temp );

	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	push	5121					; 00001401H
	push	6407					; 00001907H
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	push	0
	call	DWORD PTR _pglReadPixels

; 601  : 		r_side->flags = IMAGE_HAS_COLOR;

	mov	ecx, DWORD PTR _r_side$[ebp]
	mov	DWORD PTR [ecx+12], 4

; 602  : 		r_side->width = r_side->height = size;

	mov	edx, DWORD PTR _r_side$[ebp]
	mov	ax, WORD PTR _size$[ebp]
	mov	WORD PTR [edx+2], ax
	mov	ecx, DWORD PTR _r_side$[ebp]
	mov	dx, WORD PTR _size$[ebp]
	mov	WORD PTR [ecx], dx

; 603  : 		r_side->type = PF_RGB_24;

	mov	eax, DWORD PTR _r_side$[ebp]
	mov	DWORD PTR [eax+8], 5

; 604  : 		r_side->size = r_side->width * r_side->height * 3;

	mov	ecx, DWORD PTR _r_side$[ebp]
	movzx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _r_side$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	imul	edx, ecx
	imul	edx, edx, 3
	mov	eax, DWORD PTR _r_side$[ebp]
	mov	DWORD PTR [eax+32], edx

; 605  : 		r_side->buffer = temp;

	mov	ecx, DWORD PTR _r_side$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 606  : 
; 607  : 		if( flags ) Image_Process( &r_side, 0, 0, flags, 0.0f );

	cmp	DWORD PTR _flags$[ebp], 0
	je	SHORT $LN15@VID_Cubema
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _r_side$[ebp]
	push	ecx
	call	_Image_Process
	add	esp, 20					; 00000014H
$LN15@VID_Cubema:

; 608  : 		memcpy( buffer + (size * size * 3 * i), r_side->buffer, size * size * 3 );

	mov	edx, DWORD PTR _size$[ebp]
	imul	edx, DWORD PTR _size$[ebp]
	imul	eax, edx, 3
	push	eax
	mov	ecx, DWORD PTR _r_side$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, DWORD PTR _size$[ebp]
	imul	ecx, eax, 3
	imul	ecx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 609  : 	}

	jmp	$LN4@VID_Cubema
$LN5@VID_Cubema:

; 610  : 
; 611  : 	r_shot->flags = IMAGE_HAS_COLOR;

	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+12], 4

; 612  : 	r_shot->flags |= (skyshot) ? IMAGE_SKYBOX : IMAGE_CUBEMAP;

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN17@VID_Cubema
	mov	DWORD PTR tv193[ebp], 32		; 00000020H
	jmp	SHORT $LN18@VID_Cubema
$LN17@VID_Cubema:
	mov	DWORD PTR tv193[ebp], 1
$LN18@VID_Cubema:
	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, DWORD PTR tv193[ebp]
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 613  : 	r_shot->width = size;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	cx, WORD PTR _size$[ebp]
	mov	WORD PTR [eax], cx

; 614  : 	r_shot->height = size;

	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	ax, WORD PTR _size$[ebp]
	mov	WORD PTR [edx+2], ax

; 615  : 	r_shot->type = PF_RGB_24;

	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [ecx+8], 5

; 616  : 	r_shot->size = r_shot->width * r_shot->height * 3 * 6;

	mov	edx, DWORD PTR _r_shot$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _r_shot$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	imul	eax, eax, 3
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 617  : 	r_shot->palette = NULL;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+20], 0

; 618  : 	r_shot->buffer = buffer;

	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 619  : 
; 620  : 	// make sure what we have right extension
; 621  : 	Q_strncpy( basename, base, MAX_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	lea	ecx, DWORD PTR _basename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 622  : 	COM_StripExtension( basename );

	lea	edx, DWORD PTR _basename$[ebp]
	push	edx
	call	_COM_StripExtension
	add	esp, 4

; 623  : 	COM_DefaultExtension( basename, ".tga" );

	push	OFFSET $SG143548
	lea	eax, DWORD PTR _basename$[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 624  : 
; 625  : 	// write image as 6 sides
; 626  : 	result = FS_SaveImage( basename, r_shot );

	mov	ecx, DWORD PTR _r_shot$[ebp]
	push	ecx
	lea	edx, DWORD PTR _basename$[ebp]
	push	edx
	call	_FS_SaveImage
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 627  : 	FS_FreeImage( r_shot );

	mov	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 628  : 	FS_FreeImage( r_side );

	mov	ecx, DWORD PTR _r_side$[ebp]
	push	ecx
	call	_FS_FreeImage
	add	esp, 4

; 629  : 
; 630  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@VID_Cubema:

; 631  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CubemapShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_result$ = -24						; size = 4
tv144 = -20						; size = 4
_width$ = -16						; size = 4
_height$ = -12						; size = 4
_flags$ = -8						; size = 4
_r_shot$ = -4						; size = 4
_filename$ = 8						; size = 4
_shot_type$ = 12					; size = 4
_VID_ScreenShot PROC

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 489  : 	rgbdata_t *r_shot;
; 490  : 	uint	flags = IMAGE_FLIP_Y;

	mov	DWORD PTR _flags$[ebp], 131072		; 00020000H

; 491  : 	int	width = 0, height = 0;

	mov	DWORD PTR _width$[ebp], 0
	mov	DWORD PTR _height$[ebp], 0

; 492  : 	qboolean	result;
; 493  : 
; 494  : 	r_shot = Mem_Calloc( r_temppool, sizeof( rgbdata_t ));

	push	494					; 000001eeH
	push	OFFSET $SG143499
	push	1
	push	36					; 00000024H
	mov	eax, DWORD PTR _r_temppool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _r_shot$[ebp], eax

; 495  : 	r_shot->width = (glState.width + 3) & ~3;

	mov	ecx, DWORD PTR _glState
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	WORD PTR [edx], cx

; 496  : 	r_shot->height = (glState.height + 3) & ~3;

	mov	eax, DWORD PTR _glState+4
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	WORD PTR [ecx+2], ax

; 497  : 	r_shot->flags = IMAGE_HAS_COLOR;

	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+12], 4

; 498  : 	r_shot->type = PF_RGB_24;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+8], 5

; 499  : 	r_shot->size = r_shot->width * r_shot->height * PFDesc[r_shot->type].bpp;

	mov	ecx, DWORD PTR _r_shot$[ebp]
	movzx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _r_shot$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	imul	edx, ecx
	mov	eax, DWORD PTR _r_shot$[ebp]
	imul	ecx, DWORD PTR [eax+8], 28
	imul	edx, DWORD PTR _PFDesc[ecx+24]
	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+32], edx

; 500  : 	r_shot->palette = NULL;

	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 501  : 	r_shot->buffer = Mem_Malloc( r_temppool, r_shot->size );

	push	501					; 000001f5H
	push	OFFSET $SG143500
	push	0
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+24], eax

; 502  : 
; 503  : 	// get screen frame
; 504  : 	pglReadPixels( 0, 0, r_shot->width, r_shot->height, GL_RGB, GL_UNSIGNED_BYTE, r_shot->buffer );

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	5121					; 00001401H
	push	6407					; 00001907H
	mov	edx, DWORD PTR _r_shot$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _r_shot$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	push	0
	push	0
	call	DWORD PTR _pglReadPixels

; 505  : 
; 506  : 	switch( shot_type )

	mov	eax, DWORD PTR _shot_type$[ebp]
	mov	DWORD PTR tv144[ebp], eax
	mov	ecx, DWORD PTR tv144[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv144[ebp], ecx
	cmp	DWORD PTR tv144[ebp], 3
	ja	$LN2@VID_Screen
	mov	edx, DWORD PTR tv144[ebp]
	jmp	DWORD PTR $LN12@VID_Screen[edx*4]

; 507  : 	{
; 508  : 	case VID_SCREENSHOT:
; 509  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN5@VID_Screen:

; 510  : 	case VID_SNAPSHOT:
; 511  : 		FS_AllowDirectPaths( true );

	push	1
	call	_FS_AllowDirectPaths
	add	esp, 4

; 512  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN6@VID_Screen:

; 513  : 	case VID_LEVELSHOT:
; 514  : 		flags |= IMAGE_RESAMPLE;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1048576				; 00100000H
	mov	DWORD PTR _flags$[ebp], eax

; 515  : 		if( glState.wideScreen )

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN7@VID_Screen

; 516  : 		{
; 517  : 			height = 480;

	mov	DWORD PTR _height$[ebp], 480		; 000001e0H

; 518  : 			width = 800;

	mov	DWORD PTR _width$[ebp], 800		; 00000320H

; 519  : 		}

	jmp	SHORT $LN8@VID_Screen
$LN7@VID_Screen:

; 520  : 		else
; 521  : 		{
; 522  : 			height = 480;

	mov	DWORD PTR _height$[ebp], 480		; 000001e0H

; 523  : 			width = 640;

	mov	DWORD PTR _width$[ebp], 640		; 00000280H
$LN8@VID_Screen:

; 524  : 		}
; 525  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN9@VID_Screen:

; 526  : 	case VID_MINISHOT:
; 527  : 		flags |= IMAGE_RESAMPLE;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 1048576				; 00100000H
	mov	DWORD PTR _flags$[ebp], ecx

; 528  : 		height = 200;

	mov	DWORD PTR _height$[ebp], 200		; 000000c8H

; 529  : 		width = 320;

	mov	DWORD PTR _width$[ebp], 320		; 00000140H

; 530  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN10@VID_Screen:

; 531  : 	case VID_MAPSHOT:
; 532  : 		VID_WriteOverviewScript();		// store overview script too

	call	_VID_WriteOverviewScript

; 533  : 		flags |= IMAGE_RESAMPLE|IMAGE_QUANTIZE;	// GoldSrc request overviews in 8-bit format

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 34603008				; 02100000H
	mov	DWORD PTR _flags$[ebp], edx

; 534  : 		height = 768;

	mov	DWORD PTR _height$[ebp], 768		; 00000300H

; 535  : 		width = 1024;

	mov	DWORD PTR _width$[ebp], 1024		; 00000400H
$LN2@VID_Screen:

; 536  : 		break;
; 537  : 	}
; 538  : 
; 539  : 	Image_Process( &r_shot, width, height, flags, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	call	_Image_Process
	add	esp, 20					; 00000014H

; 540  : 
; 541  : 	// write image
; 542  : 	result = FS_SaveImage( filename, r_shot );

	mov	ecx, DWORD PTR _r_shot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_SaveImage
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 543  : 	host.write_to_clipboard = false;		// disable write to clipboard

	mov	DWORD PTR _host+34384, 0

; 544  : 	FS_AllowDirectPaths( false );			// always reset after store screenshot

	push	0
	call	_FS_AllowDirectPaths
	add	esp, 4

; 545  : 	FS_FreeImage( r_shot );

	mov	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 546  : 
; 547  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 548  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@VID_Screen:
	DD	$LN6@VID_Screen
	DD	$LN9@VID_Screen
	DD	$LN10@VID_Screen
	DD	$LN5@VID_Screen
_VID_ScreenShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_x$ = -12						; size = 4
_y$ = -8						; size = 4
tv71 = -4						; size = 4
_R_ShowTree PROC

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 816  : 	float	x = (float)((glState.width - (int)POINT_SIZE) >> 1);

	mov	eax, DWORD PTR _glState
	sub	eax, 16					; 00000010H
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 817  : 	float	y = NODE_INTERVAL_Y(1.0);

	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR _y$[ebp], xmm0

; 818  : 
; 819  : 	if( !cl.worldmodel || !CVAR_TO_BOOL( r_showtree ))

	cmp	DWORD PTR _cl+2686576, 0
	je	SHORT $LN3@R_ShowTree
	cmp	DWORD PTR _r_showtree, 0
	je	SHORT $LN5@R_ShowTree
	mov	ecx, DWORD PTR _r_showtree
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_ShowTree
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@R_ShowTree
$LN5@R_ShowTree:
	mov	DWORD PTR tv71[ebp], 0
$LN6@R_ShowTree:
	cmp	DWORD PTR tv71[ebp], 0
	jne	SHORT $LN2@R_ShowTree
$LN3@R_ShowTree:

; 820  : 		return;

	jmp	$LN1@R_ShowTree
$LN2@R_ShowTree:

; 821  : 
; 822  : 	tr.recursion_level = 0;

	mov	DWORD PTR _tr+66700, 0

; 823  : 
; 824  : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 825  : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 826  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 827  : 
; 828  : 	pglLineWidth( 2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 829  : 	pglColor3f( 1, 0.7f, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 830  : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 831  : 	R_ShowTree_r( cl.worldmodel->nodes, x, y, tr.max_recursion * 3.5f, 2 );

	push	2
	cvtsi2ss xmm0, DWORD PTR _tr+66704
	mulss	xmm0, DWORD PTR __real@40600000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _cl+2686576
	mov	eax, DWORD PTR [edx+164]
	push	eax
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 832  : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 833  : 	pglLineWidth( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 834  : 
; 835  : 	R_ShowTree_r( cl.worldmodel->nodes, x, y, tr.max_recursion * 3.5f, 1 );

	push	1
	cvtsi2ss xmm0, DWORD PTR _tr+66704
	mulss	xmm0, DWORD PTR __real@40600000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cl+2686576
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 836  : 
; 837  : 	Con_NPrintf( 0, "max recursion %d\n", tr.max_recursion );

	mov	eax, DWORD PTR _tr+66704
	push	eax
	push	OFFSET $SG143656
	push	0
	call	_Con_NPrintf
	add	esp, 12					; 0000000cH
$LN1@R_ShowTree:

; 838  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShowTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_charHeight$ = -336					; size = 4
_start$ = -332						; size = 4
$T1 = -328						; size = 4
tv146 = -324						; size = 4
_base_h$ = -320						; size = 4
_total$ = -316						; size = 4
tv67 = -312						; size = 4
_w$ = -308						; size = 4
_end$ = -304						; size = 4
_numTries$ = -300					; size = 4
_k$ = -296						; size = 4
_h$ = -292						; size = 4
_color$ = -288						; size = 4
_base_w$ = -284						; size = 4
_x$ = -280						; size = 4
_y$ = -276						; size = 4
_j$ = -272						; size = 4
_i$ = -268						; size = 4
_image$ = -264						; size = 4
_shortname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_R_ShowTextures PROC

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 645  : 	gl_texture_t	*image;
; 646  : 	float		x, y, w, h;
; 647  : 	int		total, start, end;
; 648  : 	int		i, j, k, base_w, base_h;
; 649  : 	rgba_t		color = { 192, 192, 192, 255 };

	mov	BYTE PTR _color$[ebp], 192		; 000000c0H
	mov	BYTE PTR _color$[ebp+1], 192		; 000000c0H
	mov	BYTE PTR _color$[ebp+2], 192		; 000000c0H
	mov	BYTE PTR _color$[ebp+3], 255		; 000000ffH

; 650  : 	int		charHeight, numTries = 0;

	mov	DWORD PTR _numTries$[ebp], 0

; 651  : 	static qboolean	showHelp = true;
; 652  : 	string		shortname;
; 653  : 
; 654  : 	if( !CVAR_TO_BOOL( gl_showtextures ))

	cmp	DWORD PTR _gl_showtextures, 0
	je	SHORT $LN27@R_ShowText
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN27@R_ShowText
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN28@R_ShowText
$LN27@R_ShowText:
	mov	DWORD PTR tv67[ebp], 0
$LN28@R_ShowText:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN8@R_ShowText

; 655  : 		return;

	jmp	$LN1@R_ShowText
$LN8@R_ShowText:

; 656  : 
; 657  : 	if( showHelp )

	cmp	DWORD PTR ?showHelp@?1??R_ShowTextures@@9@9, 0
	je	SHORT $LN9@R_ShowText

; 658  : 	{
; 659  : 		CL_CenterPrint( "use '<-' and '->' keys to change atlas page, ESC to quit", 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG143582
	call	_CL_CenterPrint
	add	esp, 8

; 660  : 		showHelp = false;

	mov	DWORD PTR ?showHelp@?1??R_ShowTextures@@9@9, 0
$LN9@R_ShowText:

; 661  : 	}
; 662  : 
; 663  : 	GL_SetRenderMode( kRenderNormal );

	push	0
	call	_GL_SetRenderMode
	add	esp, 4

; 664  : 	pglClear( GL_COLOR_BUFFER_BIT );

	push	16384					; 00004000H
	call	DWORD PTR _pglClear

; 665  : 	pglFinish();

	call	DWORD PTR _pglFinish

; 666  : 
; 667  : 	base_w = 8;	// textures view by horizontal

	mov	DWORD PTR _base_w$[ebp], 8

; 668  : 	base_h = 6;	// textures view by vertical

	mov	DWORD PTR _base_h$[ebp], 6
$rebuild_page$33:

; 669  : 
; 670  : rebuild_page:
; 671  : 	total = base_w * base_h;

	mov	ecx, DWORD PTR _base_w$[ebp]
	imul	ecx, DWORD PTR _base_h$[ebp]
	mov	DWORD PTR _total$[ebp], ecx

; 672  : 	start = total * (gl_showtextures->value - 1);

	cvtsi2ss xmm0, DWORD PTR _total$[ebp]
	mov	edx, DWORD PTR _gl_showtextures
	movss	xmm1, DWORD PTR [edx+12]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _start$[ebp], eax

; 673  : 	end = total * gl_showtextures->value;

	cvtsi2ss xmm0, DWORD PTR _total$[ebp]
	mov	ecx, DWORD PTR _gl_showtextures
	mulss	xmm0, DWORD PTR [ecx+12]
	cvttss2si edx, xmm0
	mov	DWORD PTR _end$[ebp], edx

; 674  : 	if( end > MAX_TEXTURES ) end = MAX_TEXTURES;

	cmp	DWORD PTR _end$[ebp], 4096		; 00001000H
	jle	SHORT $LN10@R_ShowText
	mov	DWORD PTR _end$[ebp], 4096		; 00001000H
$LN10@R_ShowText:

; 675  : 
; 676  : 	w = glState.width / base_w;

	mov	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _base_w$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _w$[ebp], xmm0

; 677  : 	h = glState.height / base_h;

	mov	eax, DWORD PTR _glState+4
	cdq
	idiv	DWORD PTR _base_h$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _h$[ebp], xmm0

; 678  : 
; 679  : 	Con_DrawStringLen( NULL, NULL, &charHeight );

	lea	eax, DWORD PTR _charHeight$[ebp]
	push	eax
	push	0
	push	0
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 680  : 
; 681  : 	for( i = j = 0; i < MAX_TEXTURES; i++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@R_ShowText
$LN2@R_ShowText:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@R_ShowText:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	SHORT $LN3@R_ShowText

; 682  : 	{
; 683  : 		image = R_GetTexture( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _image$[ebp], eax

; 684  : 		if( j == start ) break; // found start

	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jne	SHORT $LN11@R_ShowText
	jmp	SHORT $LN3@R_ShowText
$LN11@R_ShowText:

; 685  : 		if( pglIsTexture( image->texnum )) j++;

	mov	edx, DWORD PTR _image$[ebp]
	mov	eax, DWORD PTR [edx+272]
	push	eax
	call	DWORD PTR _pglIsTexture
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@R_ShowText
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN12@R_ShowText:

; 686  : 	}

	jmp	SHORT $LN2@R_ShowText
$LN3@R_ShowText:

; 687  : 
; 688  : 	if( i == MAX_TEXTURES && gl_showtextures->value != 1 )

	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jne	$LN14@R_ShowText
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN14@R_ShowText

; 689  : 	{
; 690  : 		// bad case, rewind to one and try again
; 691  : 		Cvar_SetValue( "r_showtextures", max( 1, gl_showtextures->value - 1 ));

	mov	ecx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN29@R_ShowText
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[ebp], xmm0
	jmp	SHORT $LN30@R_ShowText
$LN29@R_ShowText:
	mov	edx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [edx+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[ebp], xmm0
$LN30@R_ShowText:
	push	ecx
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG143587
	call	_Cvar_SetValue
	add	esp, 8

; 692  : 		if( ++numTries < 2 ) goto rebuild_page;	// to prevent infinite loop

	mov	eax, DWORD PTR _numTries$[ebp]
	add	eax, 1
	mov	DWORD PTR _numTries$[ebp], eax
	cmp	DWORD PTR _numTries$[ebp], 2
	jge	SHORT $LN14@R_ShowText
	jmp	$rebuild_page$33
$LN14@R_ShowText:

; 693  : 	}
; 694  : 
; 695  : 	for( k = 0; i < MAX_TEXTURES; i++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@R_ShowText
$LN5@R_ShowText:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@R_ShowText:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	$LN6@R_ShowText

; 696  : 	{
; 697  : 		if( j == end ) break; // page is full

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	jne	SHORT $LN15@R_ShowText
	jmp	$LN6@R_ShowText
$LN15@R_ShowText:

; 698  : 
; 699  : 		image = R_GetTexture( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _image$[ebp], eax

; 700  : 		if( !pglIsTexture( image->texnum ))

	mov	ecx, DWORD PTR _image$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	push	edx
	call	DWORD PTR _pglIsTexture
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@R_ShowText

; 701  : 			continue;

	jmp	SHORT $LN5@R_ShowText
$LN16@R_ShowText:

; 702  : 
; 703  : 		x = k % base_w * w;

	mov	eax, DWORD PTR _k$[ebp]
	cdq
	idiv	DWORD PTR _base_w$[ebp]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 704  : 		y = k / base_w * h;

	mov	eax, DWORD PTR _k$[ebp]
	cdq
	idiv	DWORD PTR _base_w$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 705  : 
; 706  : 		pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 707  : 		GL_Bind( GL_TEXTURE0, i ); // NOTE: don't use image->texnum here, because skybox has a 'wrong' indexes

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 708  : 
; 709  : 		if( FBitSet( image->flags, TF_DEPTHMAP ) && !FBitSet( image->flags, TF_NOCOMPARE ))

	mov	edx, DWORD PTR _image$[ebp]
	mov	eax, DWORD PTR [edx+284]
	and	eax, 128				; 00000080H
	je	SHORT $LN17@R_ShowText
	mov	ecx, DWORD PTR _image$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	and	edx, 134217728				; 08000000H
	jne	SHORT $LN17@R_ShowText

; 710  : 			pglTexParameteri( image->target, GL_TEXTURE_COMPARE_MODE_ARB, GL_NONE );

	push	0
	push	34892					; 0000884cH
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN17@R_ShowText:

; 711  : 
; 712  : 		pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 713  : 		pglTexCoord2f( 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 714  : 		pglVertex2f( x, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 715  : 		if( image->target == GL_TEXTURE_RECTANGLE_EXT )

	mov	edx, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [edx+268], 34037		; 000084f5H
	jne	SHORT $LN18@R_ShowText

; 716  : 			pglTexCoord2f( image->width, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+260]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN19@R_ShowText
$LN18@R_ShowText:

; 717  : 		else pglTexCoord2f( 1, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN19@R_ShowText:

; 718  : 		pglVertex2f( x + w, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 719  : 		if( image->target == GL_TEXTURE_RECTANGLE_EXT )

	mov	edx, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [edx+268], 34037		; 000084f5H
	jne	SHORT $LN20@R_ShowText

; 720  : 			pglTexCoord2f( image->width, image->height );

	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+262]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _image$[ebp]
	movzx	eax, WORD PTR [edx+260]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN21@R_ShowText
$LN20@R_ShowText:

; 721  : 		else pglTexCoord2f( 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN21@R_ShowText:

; 722  : 		pglVertex2f( x + w, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 723  : 		if( image->target == GL_TEXTURE_RECTANGLE_EXT )

	mov	ecx, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [ecx+268], 34037		; 000084f5H
	jne	SHORT $LN22@R_ShowText

; 724  : 			pglTexCoord2f( 0, image->height );

	mov	edx, DWORD PTR _image$[ebp]
	movzx	eax, WORD PTR [edx+262]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN23@R_ShowText
$LN22@R_ShowText:

; 725  : 		else pglTexCoord2f( 0, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN23@R_ShowText:

; 726  : 		pglVertex2f( x, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 727  : 		pglEnd();

	call	DWORD PTR _pglEnd

; 728  : 
; 729  : 		if( FBitSet( image->flags, TF_DEPTHMAP ) && !FBitSet( image->flags, TF_NOCOMPARE ))

	mov	ecx, DWORD PTR _image$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	and	edx, 128				; 00000080H
	je	SHORT $LN24@R_ShowText
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 134217728				; 08000000H
	jne	SHORT $LN24@R_ShowText

; 730  : 			pglTexParameteri( image->target, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB );

	push	34894					; 0000884eH
	push	34892					; 0000884cH
	mov	edx, DWORD PTR _image$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglTexParameteri
$LN24@R_ShowText:

; 731  : 
; 732  : 		COM_FileBase( image->name, shortname );

	lea	ecx, DWORD PTR _shortname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image$[ebp]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 733  : 		if( Q_strlen( shortname ) > 18 )

	lea	eax, DWORD PTR _shortname$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 18					; 00000012H
	jle	SHORT $LN25@R_ShowText

; 734  : 		{
; 735  : 			// cutoff too long names, it looks ugly
; 736  : 			shortname[16] = '.';

	mov	ecx, 1
	shl	ecx, 4
	mov	BYTE PTR _shortname$[ebp+ecx], 46	; 0000002eH

; 737  : 			shortname[17] = '.';

	mov	edx, 1
	imul	eax, edx, 17
	mov	BYTE PTR _shortname$[ebp+eax], 46	; 0000002eH

; 738  : 			shortname[18] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 18
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN31@R_ShowText
	jmp	SHORT $LN32@R_ShowText
$LN31@R_ShowText:
	call	___report_rangecheckfailure
$LN32@R_ShowText:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _shortname$[ebp+eax], 0
$LN25@R_ShowText:

; 739  : 		}
; 740  : 		Con_DrawString( x + 1, y + h - charHeight, shortname, color );

	lea	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _shortname$[ebp]
	push	edx
	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	cvtsi2ss xmm1, DWORD PTR _charHeight$[ebp]
	subss	xmm0, xmm1
	cvttss2si eax, xmm0
	push	eax
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	cvttss2si ecx, xmm0
	push	ecx
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 741  : 		j++, k++;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 742  : 	}

	jmp	$LN5@R_ShowText
$LN6@R_ShowText:

; 743  : 
; 744  : 	CL_DrawCenterPrint ();

	call	_CL_DrawCenterPrint

; 745  : 	pglFinish();

	call	DWORD PTR _pglFinish
$LN1@R_ShowText:

; 746  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShowTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_cull$ = 8						; size = 4
_GL_Cull PROC

; 379  : {

	push	ebp
	mov	ebp, esp

; 380  : 	if( !cull )

	cmp	DWORD PTR _cull$[ebp], 0
	jne	SHORT $LN2@GL_Cull

; 381  : 	{
; 382  : 		pglDisable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR _pglDisable

; 383  : 		glState.faceCull = 0;

	mov	DWORD PTR _glState+568, 0

; 384  : 		return;

	jmp	SHORT $LN1@GL_Cull
$LN2@GL_Cull:

; 385  : 	}
; 386  : 
; 387  : 	pglEnable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR _pglEnable

; 388  : 	pglCullFace( cull );

	mov	eax, DWORD PTR _cull$[ebp]
	push	eax
	call	DWORD PTR _pglCullFace

; 389  : 	glState.faceCull = cull;

	mov	ecx, DWORD PTR _cull$[ebp]
	mov	DWORD PTR _glState+568, ecx
$LN1@GL_Cull:

; 390  : }

	pop	ebp
	ret	0
_GL_Cull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_target$ = 8						; size = 4
_GL_TextureTarget PROC

; 278  : {

	push	ebp
	mov	ebp, esp

; 279  : 	if( glState.activeTMU < 0 || glState.activeTMU >= GL_MaxTextureUnits( ))

	cmp	DWORD PTR _glState+16, 0
	jl	SHORT $LN3@GL_Texture
	call	_GL_MaxTextureUnits
	cmp	DWORD PTR _glState+16, eax
	jl	SHORT $LN2@GL_Texture
$LN3@GL_Texture:

; 280  : 	{
; 281  : 		Con_Reportf( S_ERROR "GL_TextureTarget: bad tmu state %i\n", glState.activeTMU );

	mov	eax, DWORD PTR _glState+16
	push	eax
	push	OFFSET $SG143408
	call	_Con_Reportf
	add	esp, 8

; 282  : 		return; 

	jmp	SHORT $LN1@GL_Texture
$LN2@GL_Texture:

; 283  : 	}
; 284  : 
; 285  : 	if( glState.currentTextureTargets[glState.activeTMU] != target )

	mov	ecx, DWORD PTR _glState+16
	mov	edx, DWORD PTR _glState[ecx*4+148]
	cmp	edx, DWORD PTR _target$[ebp]
	je	SHORT $LN1@GL_Texture

; 286  : 	{
; 287  : 		if( glState.currentTextureTargets[glState.activeTMU] != GL_NONE )

	mov	eax, DWORD PTR _glState+16
	cmp	DWORD PTR _glState[eax*4+148], 0
	je	SHORT $LN5@GL_Texture

; 288  : 			pglDisable( glState.currentTextureTargets[glState.activeTMU] );

	mov	ecx, DWORD PTR _glState+16
	mov	edx, DWORD PTR _glState[ecx*4+148]
	push	edx
	call	DWORD PTR _pglDisable
$LN5@GL_Texture:

; 289  : 		glState.currentTextureTargets[glState.activeTMU] = target;

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR _glState[eax*4+148], ecx

; 290  : 		if( target != GL_NONE )

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN1@GL_Texture

; 291  : 			pglEnable( glState.currentTextureTargets[glState.activeTMU] );

	mov	edx, DWORD PTR _glState+16
	mov	eax, DWORD PTR _glState[edx*4+148]
	push	eax
	call	DWORD PTR _pglEnable
$LN1@GL_Texture:

; 292  : 	}
; 293  : }

	pop	ebp
	ret	0
_GL_TextureTarget ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
tv67 = -4						; size = 4
_mode$ = 8						; size = 4
_GL_SetRenderMode PROC

; 393  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 394  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 395  : 
; 396  : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 4
	ja	SHORT $LN4@GL_SetRend
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN9@GL_SetRend[edx*4]
$LN4@GL_SetRend:

; 397  : 	{
; 398  : 	case kRenderNormal:
; 399  : 	default:
; 400  : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 401  : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 402  : 		break;

	jmp	SHORT $LN1@GL_SetRend
$LN5@GL_SetRend:

; 403  : 	case kRenderTransColor:
; 404  : 	case kRenderTransTexture:
; 405  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 406  : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 407  : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 408  : 		break;

	jmp	SHORT $LN1@GL_SetRend
$LN6@GL_SetRend:

; 409  : 	case kRenderTransAlpha:
; 410  : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 411  : 		pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 412  : 		break;

	jmp	SHORT $LN1@GL_SetRend
$LN7@GL_SetRend:

; 413  : 	case kRenderGlow:
; 414  : 	case kRenderTransAdd:
; 415  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 416  : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 417  : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc
$LN1@GL_SetRend:

; 418  : 		break;
; 419  : 	}
; 420  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@GL_SetRend:
	DD	$LN5@GL_SetRend
	DD	$LN5@GL_SetRend
	DD	$LN7@GL_SetRend
	DD	$LN6@GL_SetRend
	DD	$LN7@GL_SetRend
_GL_SetRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_GL_DisableAllTexGens PROC

; 212  : {

	push	ebp
	mov	ebp, esp

; 213  : 	GL_TexGen( GL_S, 0 );

	push	0
	push	8192					; 00002000H
	call	_GL_TexGen
	add	esp, 8

; 214  : 	GL_TexGen( GL_T, 0 );

	push	0
	push	8193					; 00002001H
	call	_GL_TexGen
	add	esp, 8

; 215  : 	GL_TexGen( GL_R, 0 );

	push	0
	push	8194					; 00002002H
	call	_GL_TexGen
	add	esp, 8

; 216  : 	GL_TexGen( GL_Q, 0 );

	push	0
	push	8195					; 00002003H
	call	_GL_TexGen
	add	esp, 8

; 217  : }

	pop	ebp
	ret	0
_GL_DisableAllTexGens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_GL_LoadIdentityTexMatrix PROC

; 164  : {

	push	ebp
	mov	ebp, esp

; 165  : 	if( glState.texIdentityMatrix[glState.activeTMU] )

	mov	eax, DWORD PTR _glState+16
	movzx	ecx, BYTE PTR _glState[eax+276]
	test	ecx, ecx
	je	SHORT $LN2@GL_LoadIde

; 166  : 		return;

	jmp	SHORT $LN1@GL_LoadIde
$LN2@GL_LoadIde:

; 167  : 
; 168  : 	pglMatrixMode( GL_TEXTURE );

	push	5890					; 00001702H
	call	DWORD PTR _pglMatrixMode

; 169  : 	pglLoadIdentity();

	call	DWORD PTR _pglLoadIdentity

; 170  : 	glState.texIdentityMatrix[glState.activeTMU] = true;

	mov	edx, DWORD PTR _glState+16
	mov	BYTE PTR _glState[edx+276], 1
$LN1@GL_LoadIde:

; 171  : }

	pop	ebp
	ret	0
_GL_LoadIdentityTexMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_GL_CleanupAllTextureUnits PROC

; 251  : {

	push	ebp
	mov	ebp, esp

; 252  : 	if( !glw_state.initialized ) return;

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN2@GL_Cleanup
	jmp	SHORT $LN1@GL_Cleanup
$LN2@GL_Cleanup:

; 253  : 	// force to cleanup all the units
; 254  : 	GL_SelectTexture( GL_MaxTextureUnits() - 1 );

	call	_GL_MaxTextureUnits
	sub	eax, 1
	push	eax
	call	_GL_SelectTexture
	add	esp, 4

; 255  : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	_GL_CleanUpTextureUnits
	add	esp, 4
$LN1@GL_Cleanup:

; 256  : }

	pop	ebp
	ret	0
_GL_CleanupAllTextureUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_tmu$ = 8						; size = 4
_GL_SelectTexture PROC

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : 	if( !GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_SelectT

; 181  : 		return;

	jmp	SHORT $LN1@GL_SelectT
$LN2@GL_SelectT:

; 182  : 
; 183  : 	// don't allow negative texture units
; 184  : 	if( tmu < 0 ) return;

	cmp	DWORD PTR _tmu$[ebp], 0
	jge	SHORT $LN3@GL_SelectT
	jmp	SHORT $LN1@GL_SelectT
$LN3@GL_SelectT:

; 185  : 
; 186  : 	if( tmu >= GL_MaxTextureUnits( ))

	call	_GL_MaxTextureUnits
	cmp	DWORD PTR _tmu$[ebp], eax
	jl	SHORT $LN4@GL_SelectT

; 187  : 	{
; 188  : 		Con_Reportf( S_ERROR "GL_SelectTexture: bad tmu state %i\n", tmu );

	mov	eax, DWORD PTR _tmu$[ebp]
	push	eax
	push	OFFSET $SG143376
	call	_Con_Reportf
	add	esp, 8

; 189  : 		return; 

	jmp	SHORT $LN1@GL_SelectT
$LN4@GL_SelectT:

; 190  : 	}
; 191  : 
; 192  : 	if( glState.activeTMU == tmu )

	mov	ecx, DWORD PTR _glState+16
	cmp	ecx, DWORD PTR _tmu$[ebp]
	jne	SHORT $LN5@GL_SelectT

; 193  : 		return;

	jmp	SHORT $LN1@GL_SelectT
$LN5@GL_SelectT:

; 194  : 
; 195  : 	glState.activeTMU = tmu;

	mov	edx, DWORD PTR _tmu$[ebp]
	mov	DWORD PTR _glState+16, edx

; 196  : 
; 197  : 	if( pglActiveTextureARB )

	cmp	DWORD PTR _pglActiveTextureARB, 0
	je	SHORT $LN1@GL_SelectT

; 198  : 	{
; 199  : 		pglActiveTextureARB( tmu + GL_TEXTURE0_ARB );

	mov	eax, DWORD PTR _tmu$[ebp]
	add	eax, 33984				; 000084c0H
	push	eax
	call	DWORD PTR _pglActiveTextureARB

; 200  : 
; 201  : 		if( tmu < glConfig.max_texture_coords )

	mov	ecx, DWORD PTR _tmu$[ebp]
	cmp	ecx, DWORD PTR _glConfig+52
	jge	SHORT $LN1@GL_SelectT

; 202  : 			pglClientActiveTextureARB( tmu + GL_TEXTURE0_ARB );

	mov	edx, DWORD PTR _tmu$[ebp]
	add	edx, 33984				; 000084c0H
	push	edx
	call	DWORD PTR _pglClientActiveTextureARB
$LN1@GL_SelectT:

; 203  : 	}
; 204  : }

	pop	ebp
	ret	0
_GL_SelectTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
tv65 = -20						; size = 4
tv66 = -16						; size = 4
_gen$ = -12						; size = 4
_tmu$ = -8						; size = 4
_bit$ = -4						; size = 4
_coord$ = 8						; size = 4
_mode$ = 12						; size = 4
_GL_TexGen PROC

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 302  : 	int	tmu = min( glConfig.max_texture_coords, glState.activeTMU );

	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glState+16
	jge	SHORT $LN14@GL_TexGen
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv65[ebp], ecx
	jmp	SHORT $LN15@GL_TexGen
$LN14@GL_TexGen:
	mov	edx, DWORD PTR _glState+16
	mov	DWORD PTR tv65[ebp], edx
$LN15@GL_TexGen:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _tmu$[ebp], eax

; 303  : 	int	bit, gen;
; 304  : 
; 305  : 	switch( coord )

	mov	ecx, DWORD PTR _coord$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 8192				; 00002000H
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 3
	ja	SHORT $LN8@GL_TexGen
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN16@GL_TexGen[eax*4]
$LN4@GL_TexGen:

; 306  : 	{
; 307  : 	case GL_S:
; 308  : 		bit = 1;

	mov	DWORD PTR _bit$[ebp], 1

; 309  : 		gen = GL_TEXTURE_GEN_S;

	mov	DWORD PTR _gen$[ebp], 3168		; 00000c60H

; 310  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN5@GL_TexGen:

; 311  : 	case GL_T:
; 312  : 		bit = 2;

	mov	DWORD PTR _bit$[ebp], 2

; 313  : 		gen = GL_TEXTURE_GEN_T;

	mov	DWORD PTR _gen$[ebp], 3169		; 00000c61H

; 314  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN6@GL_TexGen:

; 315  : 	case GL_R:
; 316  : 		bit = 4;

	mov	DWORD PTR _bit$[ebp], 4

; 317  : 		gen = GL_TEXTURE_GEN_R;

	mov	DWORD PTR _gen$[ebp], 3170		; 00000c62H

; 318  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN7@GL_TexGen:

; 319  : 	case GL_Q:
; 320  : 		bit = 8;

	mov	DWORD PTR _bit$[ebp], 8

; 321  : 		gen = GL_TEXTURE_GEN_Q;

	mov	DWORD PTR _gen$[ebp], 3171		; 00000c63H

; 322  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN8@GL_TexGen:

; 323  : 	default: return;

	jmp	SHORT $LN1@GL_TexGen
$LN2@GL_TexGen:

; 324  : 	}
; 325  : 
; 326  : 	if( mode )

	cmp	DWORD PTR _mode$[ebp], 0
	je	SHORT $LN9@GL_TexGen

; 327  : 	{
; 328  : 		if( !( glState.genSTEnabled[tmu] & bit ))

	mov	ecx, DWORD PTR _tmu$[ebp]
	mov	edx, DWORD PTR _glState[ecx*4+308]
	and	edx, DWORD PTR _bit$[ebp]
	jne	SHORT $LN11@GL_TexGen

; 329  : 		{
; 330  : 			pglEnable( gen );

	mov	eax, DWORD PTR _gen$[ebp]
	push	eax
	call	DWORD PTR _pglEnable

; 331  : 			glState.genSTEnabled[tmu] |= bit;

	mov	ecx, DWORD PTR _tmu$[ebp]
	mov	edx, DWORD PTR _glState[ecx*4+308]
	or	edx, DWORD PTR _bit$[ebp]
	mov	eax, DWORD PTR _tmu$[ebp]
	mov	DWORD PTR _glState[eax*4+308], edx
$LN11@GL_TexGen:

; 332  : 		}
; 333  : 		pglTexGeni( coord, GL_TEXTURE_GEN_MODE, mode );

	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	push	9472					; 00002500H
	mov	edx, DWORD PTR _coord$[ebp]
	push	edx
	call	DWORD PTR _pglTexGeni

; 334  : 	}

	jmp	SHORT $LN1@GL_TexGen
$LN9@GL_TexGen:

; 335  : 	else
; 336  : 	{
; 337  : 		if( glState.genSTEnabled[tmu] & bit )

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+308]
	and	ecx, DWORD PTR _bit$[ebp]
	je	SHORT $LN1@GL_TexGen

; 338  : 		{
; 339  : 			pglDisable( gen );

	mov	edx, DWORD PTR _gen$[ebp]
	push	edx
	call	DWORD PTR _pglDisable

; 340  : 			glState.genSTEnabled[tmu] &= ~bit;

	mov	eax, DWORD PTR _bit$[ebp]
	not	eax
	mov	ecx, DWORD PTR _tmu$[ebp]
	and	eax, DWORD PTR _glState[ecx*4+308]
	mov	edx, DWORD PTR _tmu$[ebp]
	mov	DWORD PTR _glState[edx*4+308], eax
$LN1@GL_TexGen:

; 341  : 		}
; 342  : 	}
; 343  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN16@GL_TexGen:
	DD	$LN4@GL_TexGen
	DD	$LN5@GL_TexGen
	DD	$LN6@GL_TexGen
	DD	$LN7@GL_TexGen
_GL_TexGen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_dest$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 4
_GL_LoadMatrix PROC

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 152  : 	GLfloat	dest[16];
; 153  : 
; 154  : 	Matrix4x4_ToArrayFloatGL( source, dest );

	lea	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_Matrix4x4_ToArrayFloatGL
	add	esp, 8

; 155  : 	pglLoadMatrixf( dest );

	lea	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	DWORD PTR _pglLoadMatrixf

; 156  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_glmatrix$ = 8						; size = 4
_GL_LoadTexMatrixExt PROC

; 138  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 139  : 	Assert( glmatrix != NULL );

	cmp	DWORD PTR _glmatrix$[ebp], 0
	je	SHORT $LN3@GL_LoadTex
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@GL_LoadTex
$LN3@GL_LoadTex:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GL_LoadTex:
	push	0
	push	139					; 0000008bH
	push	OFFSET $SG143361
	push	OFFSET $SG143362
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 140  : 	pglMatrixMode( GL_TEXTURE );

	push	5890					; 00001702H
	call	DWORD PTR _pglMatrixMode

; 141  : 	pglLoadMatrixf( glmatrix );

	mov	ecx, DWORD PTR _glmatrix$[ebp]
	push	ecx
	call	DWORD PTR _pglLoadMatrixf

; 142  : 	glState.texIdentityMatrix[glState.activeTMU] = false;

	mov	edx, DWORD PTR _glState+16
	mov	BYTE PTR _glState[edx+276], 0

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadTexMatrixExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_m$ = 8							; size = 4
_GL_LoadTexMatrix PROC

; 126  : {

	push	ebp
	mov	ebp, esp

; 127  : 	pglMatrixMode( GL_TEXTURE );

	push	5890					; 00001702H
	call	DWORD PTR _pglMatrixMode

; 128  : 	GL_LoadMatrix( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_GL_LoadMatrix
	add	esp, 4

; 129  : 	glState.texIdentityMatrix[glState.activeTMU] = false;

	mov	ecx, DWORD PTR _glState+16
	mov	BYTE PTR _glState[ecx+276], 0

; 130  : }

	pop	ebp
	ret	0
_GL_LoadTexMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_tmu$ = -16						; size = 4
tv65 = -12						; size = 4
_cmode$ = -8						; size = 4
_bit$ = -4						; size = 4
_mode$ = 8						; size = 4
_GL_SetTexCoordArrayMode PROC

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 352  : 	int	tmu = min( glConfig.max_texture_coords, glState.activeTMU );

	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glState+16
	jge	SHORT $LN14@GL_SetTexC
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv65[ebp], ecx
	jmp	SHORT $LN15@GL_SetTexC
$LN14@GL_SetTexC:
	mov	edx, DWORD PTR _glState+16
	mov	DWORD PTR tv65[ebp], edx
$LN15@GL_SetTexC:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _tmu$[ebp], eax

; 353  : 	int	bit, cmode = glState.texCoordArrayMode[tmu];

	mov	ecx, DWORD PTR _tmu$[ebp]
	mov	edx, DWORD PTR _glState[ecx*4+436]
	mov	DWORD PTR _cmode$[ebp], edx

; 354  : 
; 355  : 	if( mode == GL_TEXTURE_COORD_ARRAY )

	cmp	DWORD PTR _mode$[ebp], 32888		; 00008078H
	jne	SHORT $LN2@GL_SetTexC

; 356  : 		bit = 1;

	mov	DWORD PTR _bit$[ebp], 1
	jmp	SHORT $LN3@GL_SetTexC
$LN2@GL_SetTexC:

; 357  : 	else if( mode == GL_TEXTURE_CUBE_MAP_ARB )

	cmp	DWORD PTR _mode$[ebp], 34067		; 00008513H
	jne	SHORT $LN4@GL_SetTexC

; 358  : 		bit = 2;

	mov	DWORD PTR _bit$[ebp], 2
	jmp	SHORT $LN3@GL_SetTexC
$LN4@GL_SetTexC:

; 359  : 	else bit = 0;

	mov	DWORD PTR _bit$[ebp], 0
$LN3@GL_SetTexC:

; 360  : 
; 361  : 	if( cmode != bit )

	mov	eax, DWORD PTR _cmode$[ebp]
	cmp	eax, DWORD PTR _bit$[ebp]
	je	SHORT $LN1@GL_SetTexC

; 362  : 	{
; 363  : 		if( cmode == 1 ) pglDisableClientState( GL_TEXTURE_COORD_ARRAY );

	cmp	DWORD PTR _cmode$[ebp], 1
	jne	SHORT $LN7@GL_SetTexC
	push	32888					; 00008078H
	call	DWORD PTR _pglDisableClientState
	jmp	SHORT $LN8@GL_SetTexC
$LN7@GL_SetTexC:

; 364  : 		else if( cmode == 2 ) pglDisable( GL_TEXTURE_CUBE_MAP_ARB );

	cmp	DWORD PTR _cmode$[ebp], 2
	jne	SHORT $LN8@GL_SetTexC
	push	34067					; 00008513H
	call	DWORD PTR _pglDisable
$LN8@GL_SetTexC:

; 365  : 
; 366  : 		if( bit == 1 ) pglEnableClientState( GL_TEXTURE_COORD_ARRAY );

	cmp	DWORD PTR _bit$[ebp], 1
	jne	SHORT $LN10@GL_SetTexC
	push	32888					; 00008078H
	call	DWORD PTR _pglEnableClientState
	jmp	SHORT $LN11@GL_SetTexC
$LN10@GL_SetTexC:

; 367  : 		else if( bit == 2 ) pglEnable( GL_TEXTURE_CUBE_MAP_ARB );

	cmp	DWORD PTR _bit$[ebp], 2
	jne	SHORT $LN11@GL_SetTexC
	push	34067					; 00008513H
	call	DWORD PTR _pglEnable
$LN11@GL_SetTexC:

; 368  : 
; 369  : 		glState.texCoordArrayMode[tmu] = bit;

	mov	ecx, DWORD PTR _tmu$[ebp]
	mov	edx, DWORD PTR _bit$[ebp]
	mov	DWORD PTR _glState[ecx*4+436], edx
$LN1@GL_SetTexC:

; 370  : 	}
; 371  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetTexCoordArrayMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_texture$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_GL_MultiTexCoord2f PROC

; 264  : {

	push	ebp
	mov	ebp, esp

; 265  : 	if( !GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_MultiTe

; 266  : 		return;

	jmp	SHORT $LN3@GL_MultiTe
$LN2@GL_MultiTe:

; 267  : 
; 268  : 	if( pglMultiTexCoord2f != NULL )

	cmp	DWORD PTR _pglMultiTexCoord2f, 0
	je	SHORT $LN3@GL_MultiTe

; 269  : 		pglMultiTexCoord2f( texture + GL_TEXTURE0_ARB, s, t );

	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _texture$[ebp]
	add	eax, 33984				; 000084c0H
	push	eax
	call	DWORD PTR _pglMultiTexCoord2f
$LN3@GL_MultiTe:

; 270  : }

	pop	ebp
	ret	0
_GL_MultiTexCoord2f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_last$ = 8						; size = 4
_GL_CleanUpTextureUnits PROC

; 225  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 226  : 	int	i;
; 227  : 
; 228  : 	for( i = glState.activeTMU; i > (last - 1); i-- )

	mov	eax, DWORD PTR _glState+16
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@GL_CleanUp
$LN2@GL_CleanUp:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@GL_CleanUp:
	mov	edx, DWORD PTR _last$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jle	SHORT $LN1@GL_CleanUp

; 229  : 	{
; 230  : 		// disable upper units
; 231  : 		if( glState.currentTextureTargets[i] != GL_NONE )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _glState[eax*4+148], 0
	je	SHORT $LN5@GL_CleanUp

; 232  : 		{
; 233  : 			pglDisable( glState.currentTextureTargets[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _glState[ecx*4+148]
	push	edx
	call	DWORD PTR _pglDisable

; 234  : 			glState.currentTextureTargets[i] = GL_NONE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _glState[eax*4+148], 0

; 235  : 			glState.currentTextures[i] = -1; // unbind texture

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _glState[ecx*4+20], -1
$LN5@GL_CleanUp:

; 236  : 		}
; 237  : 
; 238  : 		GL_SetTexCoordArrayMode( GL_NONE );

	push	0
	call	_GL_SetTexCoordArrayMode
	add	esp, 4

; 239  : 		GL_LoadIdentityTexMatrix();

	call	_GL_LoadIdentityTexMatrix

; 240  : 		GL_DisableAllTexGens();

	call	_GL_DisableAllTexGens

; 241  : 		GL_SelectTexture( i - 1 );

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	push	edx
	call	_GL_SelectTexture
	add	esp, 4

; 242  : 	}

	jmp	SHORT $LN2@GL_CleanUp
$LN1@GL_CleanUp:

; 243  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CleanUpTextureUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
_curleaf$ = -8						; size = 4
tv72 = -4						; size = 4
_GL_BackendEndFrame PROC

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 82   : 	mleaf_t	*curleaf;
; 83   : 
; 84   : 	if( r_speeds->value <= 0 || !RI.drawWorld )

	mov	eax, DWORD PTR _r_speeds
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jae	SHORT $LN5@GL_Backend
	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN4@GL_Backend
$LN5@GL_Backend:

; 85   : 		return;

	jmp	$LN1@GL_Backend
$LN4@GL_Backend:

; 86   : 
; 87   : 	if( !RI.viewleaf )

	cmp	DWORD PTR _RI+180, 0
	jne	SHORT $LN6@GL_Backend

; 88   : 		curleaf = cl.worldmodel->leafs;

	mov	ecx, DWORD PTR _cl+2686576
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR _curleaf$[ebp], edx
	jmp	SHORT $LN7@GL_Backend
$LN6@GL_Backend:

; 89   : 	else curleaf = RI.viewleaf;

	mov	eax, DWORD PTR _RI+180
	mov	DWORD PTR _curleaf$[ebp], eax
$LN7@GL_Backend:

; 90   : 
; 91   : 	R_Speeds_Printf( "Renderer: ^1Engine^7\n\n" );

	push	OFFSET $SG143341
	call	_R_Speeds_Printf
	add	esp, 4

; 92   : 
; 93   : 	switch( (int)r_speeds->value )

	mov	ecx, DWORD PTR _r_speeds
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	sub	eax, 1
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 4
	ja	$LN2@GL_Backend
	mov	ecx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN14@GL_Backend[ecx*4]
$LN8@GL_Backend:

; 94   : 	{
; 95   : 	case 1:
; 96   : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i wpoly, %3i apoly\n%3i epoly, %3i spoly",

	mov	edx, DWORD PTR _r_stats+8
	push	edx
	mov	eax, DWORD PTR _r_stats+4
	push	eax
	mov	ecx, DWORD PTR _r_stats+12
	push	ecx
	mov	edx, DWORD PTR _r_stats
	push	edx
	push	OFFSET $SG143343
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 97   : 		r_stats.c_world_polys, r_stats.c_alias_polys, r_stats.c_studio_polys, r_stats.c_sprite_polys );
; 98   : 		break;		

	jmp	$LN2@GL_Backend
$LN9@GL_Backend:

; 99   : 	case 2:
; 100  : 		R_Speeds_Printf( "visible leafs:\n%3i leafs\ncurrent leaf %3i\n", r_stats.c_world_leafs, curleaf - cl.worldmodel->leafs );

	mov	eax, DWORD PTR _cl+2686576
	mov	ecx, DWORD PTR _curleaf$[ebp]
	sub	ecx, DWORD PTR [eax+140]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _r_stats+16
	push	edx
	push	OFFSET $SG143345
	call	_R_Speeds_Printf

; 101  : 		R_Speeds_Printf( "ReciusiveWorldNode: %3lf secs\nDrawTextureChains %lf\n", r_stats.t_world_node, r_stats.t_world_draw );

	add	esp, 4
	movsd	xmm0, QWORD PTR _r_stats+56
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _r_stats+48
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG143346
	call	_R_Speeds_Printf
	add	esp, 20					; 00000014H

; 102  : 		break;

	jmp	$LN2@GL_Backend
$LN10@GL_Backend:

; 103  : 	case 3:
; 104  : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i alias models drawn\n%3i studio models drawn\n%3i sprites drawn",

	mov	eax, DWORD PTR _r_stats+36
	push	eax
	mov	ecx, DWORD PTR _r_stats+32
	push	ecx
	mov	edx, DWORD PTR _r_stats+28
	push	edx
	push	OFFSET $SG143348
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 105  : 		r_stats.c_alias_models_drawn, r_stats.c_studio_models_drawn, r_stats.c_sprite_models_drawn );
; 106  : 		break;

	jmp	SHORT $LN2@GL_Backend
$LN11@GL_Backend:

; 107  : 	case 4:
; 108  : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i static entities\n%3i normal entities\n%3i server entities",

	call	_pfnNumberOfEntities
	push	eax
	mov	eax, DWORD PTR _tr+50272
	mov	ecx, DWORD PTR [eax+24576]
	mov	edx, DWORD PTR _tr+50272
	add	ecx, DWORD PTR [edx+24580]
	sub	ecx, DWORD PTR _r_stats+44
	push	ecx
	mov	eax, DWORD PTR _r_stats+44
	push	eax
	push	OFFSET $SG143350
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 109  : 		r_numStatics, r_numEntities - r_numStatics, pfnNumberOfEntities( ));
; 110  : 		break;

	jmp	SHORT $LN2@GL_Backend
$LN12@GL_Backend:

; 111  : 	case 5:
; 112  : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i tempents\n%3i viewbeams\n%3i particles",

	mov	ecx, DWORD PTR _r_stats+40
	push	ecx
	mov	edx, DWORD PTR _r_stats+20
	push	edx
	mov	eax, DWORD PTR _r_stats+24
	push	eax
	push	OFFSET $SG143352
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN2@GL_Backend:

; 113  : 		r_stats.c_active_tents_count, r_stats.c_view_beams_count, r_stats.c_particle_count );
; 114  : 		break;
; 115  : 	}
; 116  : 
; 117  : 	memset( &r_stats, 0, sizeof( r_stats ));

	push	64					; 00000040H
	push	0
	push	OFFSET _r_stats
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@GL_Backend:

; 118  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN14@GL_Backend:
	DD	$LN8@GL_Backend
	DD	$LN9@GL_Backend
	DD	$LN10@GL_Backend
	DD	$LN11@GL_Backend
	DD	$LN12@GL_Backend
_GL_BackendEndFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\gl_backend.c
_TEXT	SEGMENT
$T1 = -4						; size = 4
_GL_BackendStartFrame PROC

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 72   : 	r_speeds_msg[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN3@GL_Backend
	jmp	SHORT $LN4@GL_Backend
$LN3@GL_Backend:
	call	___report_rangecheckfailure
$LN4@GL_Backend:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _r_speeds_msg[edx], 0
$LN2@GL_Backend:

; 73   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_BackendStartFrame ENDP
_TEXT	ENDS
END
