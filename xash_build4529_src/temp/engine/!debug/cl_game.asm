; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\cl_game.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnLoadMapSprite
PUBLIC	_PlayerInfo_ValueForKey
PUBLIC	_PlayerInfo_SetValueForKey
PUBLIC	_pfnGetPlayerUniqueID
PUBLIC	_pfnGetTrackerIDForPlayer
PUBLIC	_pfnGetPlayerForTrackerID
PUBLIC	_pfnServerCmdUnreliable
PUBLIC	_pfnGetMousePos
PUBLIC	_pfnSetMousePos
PUBLIC	_pfnSetMouseEnable
PUBLIC	_pfnParseFile
PUBLIC	_pfnGetClientOldTime
PUBLIC	_pfnGetGravity
PUBLIC	_LocalPlayerInfo_ValueForKey
PUBLIC	_CL_FillRGBABlend
PUBLIC	_pfnGetAppID
PUBLIC	_TriFog
PUBLIC	_TriGetMatrix
PUBLIC	_TriLightAtPoint
PUBLIC	_TriFogParams
PUBLIC	_NetAPI_InitNetworking
PUBLIC	_NetAPI_Status
PUBLIC	_NetAPI_SendRequest
PUBLIC	_NetAPI_CancelRequest
PUBLIC	_NetAPI_AdrToString
PUBLIC	_NetAPI_CompareAdr
PUBLIC	_NetAPI_StringToAdr
PUBLIC	_NetAPI_ValueForKey
PUBLIC	_NetAPI_RemoveKey
PUBLIC	_NetAPI_SetValueForKey
PUBLIC	_Voice_StartVoiceTweakMode
PUBLIC	_Voice_EndVoiceTweakMode
PUBLIC	_Voice_SetControlFloat
PUBLIC	_Voice_GetControlFloat
PUBLIC	_gTriApi
PUBLIC	_TriBegin
PUBLIC	_TriTexCoord2f
PUBLIC	_TriVertex3fv
PUBLIC	_TriVertex3f
PUBLIC	_TriBoxInPVS
PUBLIC	_TriColor4f
PUBLIC	_TriSpriteTexture
PUBLIC	_TriColor4fRendermode
PUBLIC	_TriColor4ub
PUBLIC	_TriBrightness
PUBLIC	_TriRenderMode
PUBLIC	_TriCullFace
PUBLIC	_TriEnd
PUBLIC	_pfnDrawConsoleString
PUBLIC	_pfnDrawSetTextColor
PUBLIC	_pfnDrawConsoleStringLen
PUBLIC	_CL_TextMessageGet
PUBLIC	_pfnIndexFromTrace
PUBLIC	_CL_ModelHandle
PUBLIC	_NetAPI_CancelAllRequests
PUBLIC	_CL_FindModelIndex
PUBLIC	_CL_GetLocalPlayer
PUBLIC	_CL_LoadModel
PUBLIC	_pfnSPR_Load
PUBLIC	_CL_FillRGBA
PUBLIC	_CL_PlayerTrace
PUBLIC	_CL_PlayerTraceExt
PUBLIC	_CL_SetTraceHull
PUBLIC	_CL_GetEntityByIndex
PUBLIC	_CL_GetMaxClients
PUBLIC	_CL_AddEntity
PUBLIC	_CL_SoundFromIndex
PUBLIC	_CL_GetSpritePointer
PUBLIC	_pfnIsNoClipping
PUBLIC	_pfnCalcShake
PUBLIC	_pfnApplyShake
PUBLIC	_pfnPlaySound
PUBLIC	_pfnIsLocal
PUBLIC	_pfnLocalPlayerDucking
PUBLIC	_pfnLocalPlayerViewheight
PUBLIC	_pfnLocalPlayerBounds
PUBLIC	_pfnGetPhysent
PUBLIC	_pfnGetVisent
PUBLIC	_pfnStopAllSounds
PUBLIC	_pfnGetGameDirectory
PUBLIC	_Key_LookupBinding
EXTRN	_R_AllocParticle:PROC
EXTRN	_R_Explosion:PROC
EXTRN	_R_ParticleExplosion:PROC
EXTRN	_R_ParticleExplosion2:PROC
EXTRN	_R_Implosion:PROC
EXTRN	_R_Blood:PROC
EXTRN	_R_BloodStream:PROC
EXTRN	_R_BlobExplosion:PROC
EXTRN	_R_EntityParticles:PROC
EXTRN	_R_FlickerParticles:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_R_ParticleBurst:PROC
EXTRN	_R_LavaSplash:PROC
EXTRN	_R_TeleportSplash:PROC
EXTRN	_R_RocketTrail:PROC
EXTRN	_R_LookupColor:PROC
EXTRN	_R_GetPackedColor:PROC
EXTRN	_R_TracerEffect:PROC
EXTRN	_R_UserTracerParticle:PROC
EXTRN	_R_TracerParticles:PROC
EXTRN	_R_ParticleLine:PROC
EXTRN	_R_ParticleBox:PROC
EXTRN	_R_ShowLine:PROC
EXTRN	_R_BulletImpactParticles:PROC
EXTRN	_R_SparkShower:PROC
EXTRN	_CL_TempEntAlloc:PROC
EXTRN	_CL_TempEntAllocHigh:PROC
EXTRN	_CL_TempEntAllocNoModel:PROC
EXTRN	_CL_TempEntAllocCustom:PROC
EXTRN	_R_FizzEffect:PROC
EXTRN	_R_Bubbles:PROC
EXTRN	_R_BubbleTrail:PROC
EXTRN	_R_AttachTentToPlayer:PROC
EXTRN	_R_KillAttachedTents:PROC
EXTRN	_R_RicochetSprite:PROC
EXTRN	_R_RocketFlare:PROC
EXTRN	_R_MuzzleFlash:PROC
EXTRN	_R_BloodSprite:PROC
EXTRN	_R_BreakModel:PROC
EXTRN	_R_TempModel:PROC
EXTRN	_R_TempSprite:PROC
EXTRN	_R_DefaultSprite:PROC
EXTRN	_R_Sprite_Explode:PROC
EXTRN	_R_Sprite_Smoke:PROC
EXTRN	_R_Spray:PROC
EXTRN	_R_Sprite_Spray:PROC
EXTRN	_R_Sprite_Trail:PROC
EXTRN	_R_FunnelSprite:PROC
EXTRN	_R_LargeFunnel:PROC
EXTRN	_R_SparkEffect:PROC
EXTRN	_R_StreakSplash:PROC
EXTRN	_R_SparkStreaks:PROC
EXTRN	_R_Projectile:PROC
EXTRN	_R_TempSphereModel:PROC
EXTRN	_R_MultiGunshot:PROC
EXTRN	_R_FireField:PROC
EXTRN	_R_PlayerSprites:PROC
EXTRN	_R_Sprite_WallPuff:PROC
EXTRN	_R_RicochetSound:PROC
EXTRN	_CL_AllocDlight:PROC
EXTRN	_CL_AllocElight:PROC
EXTRN	_CL_DecalRemoveAll:PROC
EXTRN	_CL_DecalIndexFromName:PROC
EXTRN	_CL_DecalIndex:PROC
EXTRN	_R_BeamLightning:PROC
EXTRN	_R_BeamEnts:PROC
EXTRN	_R_BeamPoints:PROC
EXTRN	_R_BeamCirclePoints:PROC
EXTRN	_R_BeamEntPoint:PROC
EXTRN	_R_BeamRing:PROC
EXTRN	_R_BeamFollow:PROC
EXTRN	_R_BeamKill:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddClientCommand:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableValue:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_R_WorldToScreen:PROC
EXTRN	_R_ScreenToWorld:PROC
EXTRN	_pfnCvar_RegisterClientVariable:PROC
EXTRN	_pfnCVarGetPointer:PROC
EXTRN	_COM_CheckParm:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_clgame:BYTE
EXTRN	_Key_Event:PROC
EXTRN	_CL_PlaybackEvent:PROC
EXTRN	_VGui_GetPanel:PROC
EXTRN	_VGui_ViewportPaintBackground:PROC
EXTRN	_COM_LoadFile:PROC
EXTRN	_COM_AddAppDirectoryToSearchPath:PROC
EXTRN	_COM_ExpandFilename:PROC
EXTRN	_CL_SetSolidPlayers:PROC
EXTRN	_CL_WaterEntity:PROC
EXTRN	_CL_TestLine:PROC
EXTRN	_CL_VisTraceLine:PROC
EXTRN	_CL_PushTraceBounds:PROC
EXTRN	_CL_PopTraceBounds:PROC
EXTRN	_CL_PushPMStates:PROC
EXTRN	_CL_PopPMStates:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_CL_SetUpPlayerPrediction:PROC
EXTRN	_Con_NXPrintf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_CL_WeaponAnim:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_CL_FireCustomDecal:PROC
EXTRN	_CL_DecalShoot:PROC
EXTRN	_S_StopSound:PROC
EXTRN	_Con_Visible:PROC
EXTRN	_AngleVectors:PROC
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_cl_textbuffer:BYTE:04000H
COMM	_cl_textmessage:BYTE:0160H
_DATA	ENDS
_DATA	SEGMENT
_gTriApi DD	01H
	DD	FLAT:_TriRenderMode
	DD	FLAT:_TriBegin
	DD	FLAT:_TriEnd
	DD	FLAT:_TriColor4f
	DD	FLAT:_TriColor4ub
	DD	FLAT:_TriTexCoord2f
	DD	FLAT:_TriVertex3fv
	DD	FLAT:_TriVertex3f
	DD	FLAT:_TriBrightness
	DD	FLAT:_TriCullFace
	DD	FLAT:_TriSpriteTexture
	DD	FLAT:_R_WorldToScreen
	DD	FLAT:_TriFog
	DD	FLAT:_R_ScreenToWorld
	DD	FLAT:_TriGetMatrix
	DD	FLAT:_TriBoxInPVS
	DD	FLAT:_TriLightAtPoint
	DD	FLAT:_TriColor4fRendermode
	DD	FLAT:_TriFogParams
_gEfxApi DD	FLAT:_R_AllocParticle
	DD	FLAT:_R_BlobExplosion
	DD	FLAT:_R_Blood
	DD	FLAT:_R_BloodSprite
	DD	FLAT:_R_BloodStream
	DD	FLAT:_R_BreakModel
	DD	FLAT:_R_Bubbles
	DD	FLAT:_R_BubbleTrail
	DD	FLAT:_R_BulletImpactParticles
	DD	FLAT:_R_EntityParticles
	DD	FLAT:_R_Explosion
	DD	FLAT:_R_FizzEffect
	DD	FLAT:_R_FireField
	DD	FLAT:_R_FlickerParticles
	DD	FLAT:_R_FunnelSprite
	DD	FLAT:_R_Implosion
	DD	FLAT:_R_LargeFunnel
	DD	FLAT:_R_LavaSplash
	DD	FLAT:_R_MultiGunshot
	DD	FLAT:_R_MuzzleFlash
	DD	FLAT:_R_ParticleBox
	DD	FLAT:_R_ParticleBurst
	DD	FLAT:_R_ParticleExplosion
	DD	FLAT:_R_ParticleExplosion2
	DD	FLAT:_R_ParticleLine
	DD	FLAT:_R_PlayerSprites
	DD	FLAT:_R_Projectile
	DD	FLAT:_R_RicochetSound
	DD	FLAT:_R_RicochetSprite
	DD	FLAT:_R_RocketFlare
	DD	FLAT:_R_RocketTrail
	DD	FLAT:_R_RunParticleEffect
	DD	FLAT:_R_ShowLine
	DD	FLAT:_R_SparkEffect
	DD	FLAT:_R_SparkShower
	DD	FLAT:_R_SparkStreaks
	DD	FLAT:_R_Spray
	DD	FLAT:_R_Sprite_Explode
	DD	FLAT:_R_Sprite_Smoke
	DD	FLAT:_R_Sprite_Spray
	DD	FLAT:_R_Sprite_Trail
	DD	FLAT:_R_Sprite_WallPuff
	DD	FLAT:_R_StreakSplash
	DD	FLAT:_R_TracerEffect
	DD	FLAT:_R_UserTracerParticle
	DD	FLAT:_R_TracerParticles
	DD	FLAT:_R_TeleportSplash
	DD	FLAT:_R_TempSphereModel
	DD	FLAT:_R_TempModel
	DD	FLAT:_R_DefaultSprite
	DD	FLAT:_R_TempSprite
	DD	FLAT:_CL_DecalIndex
	DD	FLAT:_CL_DecalIndexFromName
	DD	FLAT:_CL_DecalShoot
	DD	FLAT:_R_AttachTentToPlayer
	DD	FLAT:_R_KillAttachedTents
	DD	FLAT:_R_BeamCirclePoints
	DD	FLAT:_R_BeamEntPoint
	DD	FLAT:_R_BeamEnts
	DD	FLAT:_R_BeamFollow
	DD	FLAT:_R_BeamKill
	DD	FLAT:_R_BeamLightning
	DD	FLAT:_R_BeamPoints
	DD	FLAT:_R_BeamRing
	DD	FLAT:_CL_AllocDlight
	DD	FLAT:_CL_AllocElight
	DD	FLAT:_CL_TempEntAlloc
	DD	FLAT:_CL_TempEntAllocNoModel
	DD	FLAT:_CL_TempEntAllocHigh
	DD	FLAT:_CL_TempEntAllocCustom
	DD	FLAT:_R_GetPackedColor
	DD	FLAT:_R_LookupColor
	DD	FLAT:_CL_DecalRemoveAll
	DD	FLAT:_CL_FireCustomDecal
_gEventApi DD	01H
	DD	FLAT:_pfnPlaySound
	DD	FLAT:_S_StopSound
	DD	FLAT:_CL_FindModelIndex
	DD	FLAT:_pfnIsLocal
	DD	FLAT:_pfnLocalPlayerDucking
	DD	FLAT:_pfnLocalPlayerViewheight
	DD	FLAT:_pfnLocalPlayerBounds
	DD	FLAT:_pfnIndexFromTrace
	DD	FLAT:_pfnGetPhysent
	DD	FLAT:_CL_SetUpPlayerPrediction
	DD	FLAT:_CL_PushPMStates
	DD	FLAT:_CL_PopPMStates
	DD	FLAT:_CL_SetSolidPlayers
	DD	FLAT:_CL_SetTraceHull
	DD	FLAT:_CL_PlayerTrace
	DD	FLAT:_CL_WeaponAnim
	DD	FLAT:_pfnPrecacheEvent
	DD	FLAT:_CL_PlaybackEvent
	DD	FLAT:_pfnTraceTexture
	DD	FLAT:_pfnStopAllSounds
	DD	FLAT:_pfnKillEvents
	DD	FLAT:_CL_PlayerTraceExt
	DD	FLAT:_CL_SoundFromIndex
	DD	FLAT:_pfnTraceSurface
	DD	FLAT:_pfnGetMoveVars
	DD	FLAT:_CL_VisTraceLine
	DD	FLAT:_pfnGetVisent
	DD	FLAT:_CL_TestLine
	DD	FLAT:_CL_PushTraceBounds
	DD	FLAT:_CL_PopTraceBounds
_gDemoApi DD	FLAT:_Demo_IsRecording
	DD	FLAT:_Demo_IsPlayingback
	DD	FLAT:_Demo_IsTimeDemo
	DD	FLAT:_Demo_WriteBuffer
_gNetApi DD	FLAT:_NetAPI_InitNetworking
	DD	FLAT:_NetAPI_Status
	DD	FLAT:_NetAPI_SendRequest
	DD	FLAT:_NetAPI_CancelRequest
	DD	FLAT:_NetAPI_CancelAllRequests
	DD	FLAT:_NetAPI_AdrToString
	DD	FLAT:_NetAPI_CompareAdr
	DD	FLAT:_NetAPI_StringToAdr
	DD	FLAT:_NetAPI_ValueForKey
	DD	FLAT:_NetAPI_RemoveKey
	DD	FLAT:_NetAPI_SetValueForKey
_gVoiceApi DD	FLAT:_Voice_StartVoiceTweakMode
	DD	FLAT:_Voice_EndVoiceTweakMode
	DD	FLAT:_Voice_SetControlFloat
	DD	FLAT:_Voice_GetControlFloat
$SG146190 DB	'Initialize', 00H
	ORG $+1
$SG146191 DB	'HUD_VidInit', 00H
$SG146192 DB	'HUD_Init', 00H
	ORG $+3
$SG146193 DB	'HUD_Shutdown', 00H
	ORG $+3
$SG146194 DB	'HUD_Redraw', 00H
	ORG $+1
$SG146195 DB	'HUD_UpdateClientData', 00H
	ORG $+3
$SG146196 DB	'HUD_Reset', 00H
	ORG $+2
$SG146197 DB	'HUD_PlayerMove', 00H
	ORG $+1
$SG146198 DB	'HUD_PlayerMoveInit', 00H
	ORG $+1
$SG146199 DB	'HUD_PlayerMoveTexture', 00H
	ORG $+2
$SG146200 DB	'HUD_ConnectionlessPacket', 00H
	ORG $+3
$SG146201 DB	'HUD_GetHullBounds', 00H
	ORG $+2
$SG146202 DB	'HUD_Frame', 00H
	ORG $+2
$SG146203 DB	'HUD_PostRunCmd', 00H
	ORG $+1
$SG146204 DB	'HUD_Key_Event', 00H
	ORG $+2
$SG146205 DB	'HUD_AddEntity', 00H
	ORG $+2
$SG146206 DB	'HUD_CreateEntities', 00H
	ORG $+1
$SG146207 DB	'HUD_StudioEvent', 00H
$SG146208 DB	'HUD_TxferLocalOverrides', 00H
$SG146209 DB	'HUD_ProcessPlayerState', 00H
	ORG $+1
$SG146210 DB	'HUD_TxferPredictionData', 00H
$SG146211 DB	'HUD_TempEntUpdate', 00H
	ORG $+2
$SG146212 DB	'HUD_DrawNormalTriangles', 00H
$SG146213 DB	'HUD_DrawTransparentTriangles', 00H
	ORG $+3
$SG146214 DB	'HUD_GetUserEntity', 00H
	ORG $+2
$SG146215 DB	'Demo_ReadBuffer', 00H
$SG146216 DB	'CAM_Think', 00H
	ORG $+2
$SG146217 DB	'CL_IsThirdPerson', 00H
	ORG $+3
$SG146218 DB	'CL_CameraOffset', 00H
$SG146219 DB	'CL_CreateMove', 00H
	ORG $+2
$SG146220 DB	'IN_ActivateMouse', 00H
	ORG $+3
$SG146221 DB	'IN_DeactivateMouse', 00H
	ORG $+1
$SG146222 DB	'IN_MouseEvent', 00H
	ORG $+2
$SG146223 DB	'IN_Accumulate', 00H
	ORG $+2
$SG146224 DB	'IN_ClearStates', 00H
	ORG $+1
$SG146225 DB	'V_CalcRefdef', 00H
	ORG $+3
$SG146226 DB	'KB_Find', 00H
$SG146236 DB	'HUD_GetStudioModelInterface', 00H
$SG146237 DB	'HUD_DirectorMessage', 00H
$SG146238 DB	'HUD_VoiceStatus', 00H
$SG146239 DB	'HUD_ChatInputPosition', 00H
	ORG $+2
$SG146240 DB	'HUD_GetRenderInterface', 00H
	ORG $+1
$SG146241 DB	'HUD_ClipMoveToEntity', 00H
_DATA	ENDS
PUBLIC	_CL_IsThirdPerson
PUBLIC	_CL_PointContents
PUBLIC	_CL_GetPlayerInfo
PUBLIC	_CL_HudMessage
PUBLIC	_CL_LoadProgs
PUBLIC	_CL_ClearEdicts
PUBLIC	_CL_UnloadProgs
PUBLIC	_CL_LinkUserMessage
PUBLIC	_CL_ParseFinaleCutscene
PUBLIC	_CL_ParseTextMessage
PUBLIC	_CL_DrawHUD
PUBLIC	_CL_InitEdicts
PUBLIC	_CL_FreeEdicts
PUBLIC	_CL_ClearWorld
PUBLIC	_CL_DrawCenterPrint
PUBLIC	_CL_ClearSpriteTextures
PUBLIC	_CL_FreeEntity
PUBLIC	_CL_CenterPrint
PUBLIC	_CL_LoadClientSprite
PUBLIC	_pfnSPR_LoadExt
PUBLIC	_PicAdjustSize
PUBLIC	_CL_EDICT_NUM
PUBLIC	_TriWorldToScreen
PUBLIC	_CL_CreatePlaylist
PUBLIC	_CL_InitCDAudio
PUBLIC	_CL_DrawScreenFade
PUBLIC	_CL_DrawCrosshair
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3e19999a
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@437fe666
PUBLIC	__real@43800000
PUBLIC	__real@46000000
PUBLIC	__real@47c34f80
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__SetCursorPos@8:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cmd_Unlink:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_Cvar_Unlink:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_NET_Config:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_ExtractFilePath:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_Print:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Key_KeynumToString:PROC
EXTRN	_Key_GetKey:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_ServerCommand:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_RemoveKey:PROC
EXTRN	_Info_SetValueForStarKey:PROC
EXTRN	_sin:PROC
EXTRN	__imp__ceil:PROC
EXTRN	_Mod_ClearUserData:PROC
EXTRN	_Mod_BoxVisible:PROC
EXTRN	_MSG_BigShort:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_OutOfBandPrint:PROC
EXTRN	_CL_WriteDemoUserMessage:PROC
EXTRN	_CL_RegisterEvent:PROC
EXTRN	_CL_ResetEvent:PROC
EXTRN	_CL_EventIndex:PROC
EXTRN	_CL_TextMessageParse:PROC
EXTRN	_CL_DispatchUserMessage:PROC
EXTRN	_CL_InitClientMove:PROC
EXTRN	_CL_InitStudioAPI:PROC
EXTRN	_CL_AddVisibleEntity:PROC
EXTRN	_CL_ClearAllRemaps:PROC
EXTRN	_CL_AddClientResource:PROC
EXTRN	_CL_InitParticles:PROC
EXTRN	_CL_FreeParticles:PROC
EXTRN	_CL_InitTempEnts:PROC
EXTRN	_CL_FreeTempEnts:PROC
EXTRN	_CL_InitViewBeams:PROC
EXTRN	_CL_FreeViewBeams:PROC
EXTRN	_CL_KillDeadBeams:PROC
EXTRN	_Con_DrawStringLen:PROC
EXTRN	_Con_DrawString:PROC
EXTRN	_Con_DrawCharacter:PROC
EXTRN	_Con_DrawCharacterLen:PROC
EXTRN	_Con_SetFont:PROC
EXTRN	_Con_RestoreFont:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_pfnPIC_Set:PROC
EXTRN	_pfnPIC_DrawAdditive:PROC
EXTRN	_PM_PlayerTraceExt:PROC
EXTRN	_PM_PointContents:PROC
EXTRN	_PM_TraceTexture:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_LightPoint:PROC
EXTRN	_R_InitRenderAPI:PROC
EXTRN	_Mod_LoadSpriteModel:PROC
EXTRN	_R_GetTextureParms:PROC
EXTRN	_R_GetSpriteParms:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	_Mod_LoadMapSprite:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_R_GetSpriteTexture:PROC
EXTRN	_R_RemoveEfrags:PROC
EXTRN	_Mod_GetCurrentVis:PROC
EXTRN	_COM_LoadLibrary:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_COM_FreeLibrary:PROC
EXTRN	_VGui_Startup:PROC
EXTRN	_VGui_Shutdown:PROC
EXTRN	_S_GetSfxByHandle:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memset:PROC
EXTRN	_scr_loading:DWORD
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_svc_strings:BYTE
EXTRN	_net_local:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_cl_crosshair:DWORD
EXTRN	_cl_righthand:DWORD
EXTRN	_scr_centertime:DWORD
EXTRN	_rate:DWORD
EXTRN	_con_fontsize:DWORD
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_glState:BYTE
EXTRN	_g_color_table:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?msgindex@?1??CL_ParseTextMessage@@9@9 DD 01H DUP (?)	; `CL_ParseTextMessage'::`2'::msgindex
?msgindex@?1??CL_ParseFinaleCutscene@@9@9 DD 01H DUP (?) ; `CL_ParseFinaleCutscene'::`2'::msgindex
?tr@?1??pfnTraceLine@@9@9 DB 044H DUP (?)		; `pfnTraceLine'::`2'::tr
?lasttimewarn@?1??CL_FindModelIndex@@9@9 DD 01H DUP (?)	; `CL_FindModelIndex'::`2'::lasttimewarn
?szGetGameDir@?1??pfnGetGameDirectory@@9@9 DB 0400H DUP (?) ; `pfnGetGameDirectory'::`2'::szGetGameDir
?mapname@?1??pfnGetLevelName@@9@9 DB 040H DUP (?)	; `pfnGetLevelName'::`2'::mapname
?gpMove@?1??CL_LoadProgs@@9@9 DB 04f5d0H DUP (?)	; `CL_LoadProgs'::`2'::gpMove
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@47c34f80
CONST	SEGMENT
__real@47c34f80 DD 047c34f80r			; 99999
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437fe666
CONST	SEGMENT
__real@437fe666 DD 0437fe666r			; 255.9
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
_cdll_exports DD FLAT:$SG146190
	DD	FLAT:_clgame+4
	DD	FLAT:$SG146191
	DD	FLAT:_clgame+12
	DD	FLAT:$SG146192
	DD	FLAT:_clgame+8
	DD	FLAT:$SG146193
	DD	FLAT:_clgame+108
	DD	FLAT:$SG146194
	DD	FLAT:_clgame+16
	DD	FLAT:$SG146195
	DD	FLAT:_clgame+20
	DD	FLAT:$SG146196
	DD	FLAT:_clgame+24
	DD	FLAT:$SG146197
	DD	FLAT:_clgame+28
	DD	FLAT:$SG146198
	DD	FLAT:_clgame+32
	DD	FLAT:$SG146199
	DD	FLAT:_clgame+36
	DD	FLAT:$SG146200
	DD	FLAT:_clgame+128
	DD	FLAT:$SG146201
	DD	FLAT:_clgame+132
	DD	FLAT:$SG146202
	DD	FLAT:_clgame+136
	DD	FLAT:$SG146203
	DD	FLAT:_clgame+104
	DD	FLAT:$SG146204
	DD	FLAT:_clgame+140
	DD	FLAT:$SG146205
	DD	FLAT:_clgame+84
	DD	FLAT:$SG146206
	DD	FLAT:_clgame+88
	DD	FLAT:$SG146207
	DD	FLAT:_clgame+100
	DD	FLAT:$SG146208
	DD	FLAT:_clgame+112
	DD	FLAT:$SG146209
	DD	FLAT:_clgame+116
	DD	FLAT:$SG146210
	DD	FLAT:_clgame+120
	DD	FLAT:$SG146211
	DD	FLAT:_clgame+144
	DD	FLAT:$SG146212
	DD	FLAT:_clgame+92
	DD	FLAT:$SG146213
	DD	FLAT:_clgame+96
	DD	FLAT:$SG146214
	DD	FLAT:_clgame+148
	DD	FLAT:$SG146215
	DD	FLAT:_clgame+124
	DD	FLAT:$SG146216
	DD	FLAT:_clgame+76
	DD	FLAT:$SG146217
	DD	FLAT:_clgame+64
	DD	FLAT:$SG146218
	DD	FLAT:_clgame+68
	DD	FLAT:$SG146219
	DD	FLAT:_clgame+60
	DD	FLAT:$SG146220
	DD	FLAT:_clgame+40
	DD	FLAT:$SG146221
	DD	FLAT:_clgame+44
	DD	FLAT:$SG146222
	DD	FLAT:_clgame+48
	DD	FLAT:$SG146223
	DD	FLAT:_clgame+56
	DD	FLAT:$SG146224
	DD	FLAT:_clgame+52
	DD	FLAT:$SG146225
	DD	FLAT:_clgame+80
	DD	FLAT:$SG146226
	DD	FLAT:_clgame+72
	DD	00H
	DD	00H
_cdll_new_exports DD FLAT:$SG146236
	DD	FLAT:_clgame+160
	DD	FLAT:$SG146237
	DD	FLAT:_clgame+156
	DD	FLAT:$SG146238
	DD	FLAT:_clgame+152
	DD	FLAT:$SG146239
	DD	FLAT:_clgame+164
	DD	FLAT:$SG146240
	DD	FLAT:_clgame+168
	DD	FLAT:$SG146241
	DD	FLAT:_clgame+172
	DD	00H
	DD	00H
$SG146280 DB	'w', 00H
	ORG $+2
$SG146282 DB	'blank', 0aH, 00H
	ORG $+1
$SG146283 DB	'Half-Life01.mp3', 0aH, 00H
	ORG $+3
$SG146284 DB	'Prospero01.mp3', 0aH, 00H
$SG146285 DB	'Half-Life12.mp3', 0aH, 00H
	ORG $+3
$SG146286 DB	'Half-Life07.mp3', 0aH, 00H
	ORG $+3
$SG146287 DB	'Half-Life10.mp3', 0aH, 00H
	ORG $+3
$SG146288 DB	'Suspense01.mp3', 0aH, 00H
$SG146289 DB	'Suspense03.mp3', 0aH, 00H
$SG146290 DB	'Half-Life09.mp3', 0aH, 00H
	ORG $+3
$SG146291 DB	'Half-Life02.mp3', 0aH, 00H
	ORG $+3
$SG146292 DB	'Half-Life13.mp3', 0aH, 00H
	ORG $+3
$SG146293 DB	'Half-Life04.mp3', 0aH, 00H
	ORG $+3
$SG146294 DB	'Half-Life15.mp3', 0aH, 00H
	ORG $+3
$SG146295 DB	'Half-Life14.mp3', 0aH, 00H
	ORG $+3
$SG146296 DB	'Half-Life16.mp3', 0aH, 00H
	ORG $+3
$SG146297 DB	'Suspense02.mp3', 0aH, 00H
$SG146298 DB	'Half-Life03.mp3', 0aH, 00H
	ORG $+3
$SG146299 DB	'Half-Life08.mp3', 0aH, 00H
	ORG $+3
$SG146300 DB	'Prospero02.mp3', 0aH, 00H
$SG146301 DB	'Half-Life05.mp3', 0aH, 00H
	ORG $+3
$SG146302 DB	'Prospero04.mp3', 0aH, 00H
$SG146303 DB	'Half-Life11.mp3', 0aH, 00H
	ORG $+3
$SG146304 DB	'Half-Life06.mp3', 0aH, 00H
	ORG $+3
$SG146305 DB	'Prospero03.mp3', 0aH, 00H
$SG146306 DB	'Half-Life17.mp3', 0aH, 00H
	ORG $+3
$SG146307 DB	'Prospero05.mp3', 0aH, 00H
$SG146308 DB	'Suspense05.mp3', 0aH, 00H
$SG146309 DB	'Suspense07.mp3', 0aH, 00H
$SG146326 DB	'blank', 00H
	ORG $+2
$SG146328 DB	'^3Warning:^7 CD_Init: too many tracks %i in %s', 0aH, 00H
$SG146329 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146551 DB	'HudText', 00H
$SG146602 DB	'^1Error:^7 CL_SoundFromIndex: bad sfx for index %i', 0aH
	DB	00H
$SG146540 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146541 DB	'TextMessage%i', 00H
	ORG $+2
$SG146587 DB	'player != NULL', 00H
	ORG $+1
$SG146697 DB	'CL_LinkUserMessage: tried to hook a system message "%s"', 0aH
	DB	00H
	ORG $+3
$SG146543 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146700 DB	'CL_LinkUserMessage: MAX_USER_MESSAGES hit!', 0aH, 00H
$SG146545 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146722 DB	'clgame.entities == NULL', 00H
$SG146772 DB	'm_pSprite != NULL', 00H
	ORG $+2
$SG146586 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146600 DB	'^1Error:^7 CL_SoundFromIndex: invalid sound index %i', 0aH
	DB	00H
	ORG $+2
$SG146695 DB	'CL_LinkUserMessage: bad message name', 0aH, 00H
	ORG $+2
$SG146707 DB	'pEdict != NULL', 00H
	ORG $+1
$SG146781 DB	'assert failed at %s:%i', 0aH, 00H
$SG146807 DB	'^1Error:^7 CL_LoadSpriteModel: bad name!', 0aH, 00H
	ORG $+2
$SG146706 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146813 DB	'^1Error:^7 MAX_CLIENT_SPRITES limit exceeded (%d)', 0aH, 00H
	ORG $+1
$SG146721 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146937 DB	'^1Error:^7 SPR_GetList: overflow cache!', 0aH, 00H
	ORG $+3
$SG146724 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146973 DB	'hud_scale', 00H
	ORG $+2
$SG146725 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147015 DB	'cmd %s', 0aH, 00H
$SG147023 DB	0aH, 00H
	ORG $+2
$SG146726 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147024 DB	'%s', 0aH, 00H
$SG146728 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147116 DB	'%s', 00H
	ORG $+1
$SG146739 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147450 DB	'maps/%s.bsp', 00H
$SG146741 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147487 DB	'setinfo "%s" "%s"', 0aH, 00H
	ORG $+1
$SG146744 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147781 DB	'nr != NULL', 00H
	ORG $+1
$SG146771 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146778 DB	'^1Error:^7 %s couldn''t load', 0aH, 00H
	ORG $+3
$SG147066 DB	'TextMessage%i', 00H
	ORG $+2
$SG147259 DB	'^3Warning:^7 CL_HookEvent: %s already hooked!', 0aH, 00H
	ORG $+1
$SG147786 DB	'netinfo %i %i %i', 00H
	ORG $+3
$SG146780 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147882 DB	'0', 00H
	ORG $+2
$SG146784 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147884 DB	'0', 00H
	ORG $+2
$SG146940 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG146943 DB	'^3Warning:^7 unexpected end of %s (%i should be %i)', 0aH
	DB	00H
	ORG $+3
$SG147437 DB	'%s/%s', 00H
	ORG $+2
$SG147742 DB	'status != NULL', 00H
	ORG $+1
$SG147885 DB	'host_clientloaded', 00H
	ORG $+2
$SG146945 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147008 DB	'HookUserMsg: MAX_USER_MESSAGES hit!', 0aH, 00H
	ORG $+3
$SG147310 DB	'^1Error:^7 %s not precached', 0aH, 00H
	ORG $+3
$SG147784 DB	'1', 0ffH, '0.0.0.0:0', 00H, '\gamedir\', 00H
	ORG $+2
$SG147930 DB	'Client Static Pool', 00H
	ORG $+1
$SG147741 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147932 DB	'Client Edicts Zone', 00H
	ORG $+1
$SG147775 DB	'^1Error:^7 Net_SendRequest: no callbcak specified for re'
	DB	'quest with context %i!', 0aH, 00H
$SG147780 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147936 DB	'CL_LoadProgs: found single callback export', 0aH, 00H
_gEngfuncs DD	FLAT:_pfnSPR_Load
	DD	FLAT:_pfnSPR_Frames
	DD	FLAT:_pfnSPR_Height
	DD	FLAT:_pfnSPR_Width
	DD	FLAT:_pfnSPR_Set
	DD	FLAT:_pfnSPR_Draw
	DD	FLAT:_pfnSPR_DrawHoles
	DD	FLAT:_pfnSPR_DrawAdditive
	DD	FLAT:_SPR_EnableScissor
	DD	FLAT:_SPR_DisableScissor
	DD	FLAT:_pfnSPR_GetList
	DD	FLAT:_CL_FillRGBA
	DD	FLAT:_pfnGetScreenInfo
	DD	FLAT:_pfnSetCrosshair
	DD	FLAT:_pfnCvar_RegisterClientVariable
	DD	FLAT:_Cvar_VariableValue
	DD	FLAT:_Cvar_VariableString
	DD	FLAT:_Cmd_AddClientCommand
	DD	FLAT:_pfnHookUserMsg
	DD	FLAT:_pfnServerCmd
	DD	FLAT:_pfnClientCmd
	DD	FLAT:_pfnGetPlayerInfo
	DD	FLAT:_pfnPlaySoundByName
	DD	FLAT:_pfnPlaySoundByIndex
	DD	FLAT:_AngleVectors
	DD	FLAT:_CL_TextMessageGet
	DD	FLAT:_pfnDrawCharacter
	DD	FLAT:_pfnDrawConsoleString
	DD	FLAT:_pfnDrawSetTextColor
	DD	FLAT:_pfnDrawConsoleStringLen
	DD	FLAT:_pfnConsolePrint
	DD	FLAT:_pfnCenterPrint
	DD	FLAT:_pfnGetWindowCenterX
	DD	FLAT:_pfnGetWindowCenterY
	DD	FLAT:_pfnGetViewAngles
	DD	FLAT:_pfnSetViewAngles
	DD	FLAT:_CL_GetMaxClients
	DD	FLAT:_Cvar_SetValue
	DD	FLAT:_Cmd_Argc
	DD	FLAT:_Cmd_Argv
	DD	FLAT:_Con_Printf
	DD	FLAT:_Con_DPrintf
	DD	FLAT:_Con_NPrintf
	DD	FLAT:_Con_NXPrintf
	DD	FLAT:_pfnPhysInfo_ValueForKey
	DD	FLAT:_pfnServerInfo_ValueForKey
	DD	FLAT:_pfnGetClientMaxspeed
	DD	FLAT:_COM_CheckParm
	DD	FLAT:_Key_Event
	DD	FLAT:_pfnGetMousePosition
	DD	FLAT:_pfnIsNoClipping
	DD	FLAT:_CL_GetLocalPlayer
	DD	FLAT:_pfnGetViewModel
	DD	FLAT:_CL_GetEntityByIndex
	DD	FLAT:_pfnGetClientTime
	DD	FLAT:_pfnCalcShake
	DD	FLAT:_pfnApplyShake
	DD	FLAT:_pfnPointContents
	DD	FLAT:_CL_WaterEntity
	DD	FLAT:_pfnTraceLine
	DD	FLAT:_CL_LoadModel
	DD	FLAT:_CL_AddEntity
	DD	FLAT:_CL_GetSpritePointer
	DD	FLAT:_pfnPlaySoundByNameAtLocation
	DD	FLAT:_pfnPrecacheEvent
	DD	FLAT:_CL_PlaybackEvent
	DD	FLAT:_CL_WeaponAnim
	DD	FLAT:_COM_RandomFloat
	DD	FLAT:_COM_RandomLong
	DD	FLAT:_pfnHookEvent
	DD	FLAT:_Con_Visible
	DD	FLAT:_pfnGetGameDirectory
	DD	FLAT:_pfnCVarGetPointer
	DD	FLAT:_Key_LookupBinding
	DD	FLAT:_pfnGetLevelName
	DD	FLAT:_pfnGetScreenFade
	DD	FLAT:_pfnSetScreenFade
	DD	FLAT:_VGui_GetPanel
	DD	FLAT:_VGui_ViewportPaintBackground
	DD	FLAT:_COM_LoadFile
	DD	FLAT:_pfnParseFile
	DD	FLAT:_COM_FreeFile
	DD	FLAT:_gTriApi
	DD	FLAT:_gEfxApi
	DD	FLAT:_gEventApi
	DD	FLAT:_gDemoApi
	DD	FLAT:_gNetApi
	DD	FLAT:_gVoiceApi
	DD	FLAT:_pfnIsSpectateOnly
	DD	FLAT:_pfnLoadMapSprite
	DD	FLAT:_COM_AddAppDirectoryToSearchPath
	DD	FLAT:_COM_ExpandFilename
	DD	FLAT:_PlayerInfo_ValueForKey
	DD	FLAT:_PlayerInfo_SetValueForKey
	DD	FLAT:_pfnGetPlayerUniqueID
	DD	FLAT:_pfnGetTrackerIDForPlayer
	DD	FLAT:_pfnGetPlayerForTrackerID
	DD	FLAT:_pfnServerCmdUnreliable
	DD	FLAT:_pfnGetMousePos
	DD	FLAT:_pfnSetMousePos
	DD	FLAT:_pfnSetMouseEnable
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnGetClientOldTime
	DD	FLAT:_pfnGetGravity
	DD	FLAT:_CL_ModelHandle
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_LocalPlayerInfo_ValueForKey
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_Cvar_Set
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_Sys_DoubleTime
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_CL_FillRGBABlend
	DD	FLAT:_pfnGetAppID
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
$SG147881 DB	'hlfx', 00H
	ORG $+3
$SG147883 DB	'cl_background', 00H
	ORG $+2
$SG147886 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147942 DB	'CL_LoadProgs: failed to get address of %s proc', 0aH, 00H
$SG147950 DB	'1', 00H
	ORG $+2
$SG147887 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147947 DB	'CL_LoadProgs: failed to get address of %s proc', 0aH, 00H
$SG147951 DB	'host_clientloaded', 00H
	ORG $+2
$SG147929 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147952 DB	'media/cdaudio.txt', 00H
	ORG $+2
$SG147931 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\cl_game.c', 00H
	ORG $+1
$SG147935 DB	'GetClientAPI', 00H
	ORG $+3
$SG147949 DB	'CL_LoadProgs: can''t init client API', 0aH, 00H
	ORG $+3
$SG147953 DB	'titles.txt', 00H
	ORG $+1
$SG147955 DB	'^3Warning:^7 CL_LoadProgs: couldn''t get render API', 0aH
	DB	00H
$SG147956 DB	'cl_righthand', 00H
	ORG $+3
$SG147958 DB	'flip viewmodel (left to right)', 00H
	ORG $+1
$SG147959 DB	'0', 00H
	ORG $+2
$SG147960 DB	'cl_righthand', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
_DATA	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnEngineStub PROC

; 3589 : {

	push	ebp
	mov	ebp, esp

; 3590 : }

	pop	ebp
	ret	0
_pfnEngineStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_iControl$ = 8						; size = 4
_Voice_GetControlFloat PROC

; 3577 : {

	push	ebp
	mov	ebp, esp

; 3578 : 	return 1.0f;

	fld1

; 3579 : }

	pop	ebp
	ret	0
_Voice_GetControlFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_iControl$ = 8						; size = 4
_value$ = 12						; size = 4
_Voice_SetControlFloat PROC

; 3567 : {

	push	ebp
	mov	ebp, esp

; 3568 : }

	pop	ebp
	ret	0
_Voice_SetControlFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_Voice_EndVoiceTweakMode PROC

; 3557 : {

	push	ebp
	mov	ebp, esp

; 3558 : }

	pop	ebp
	ret	0
_Voice_EndVoiceTweakMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_Voice_StartVoiceTweakMode PROC

; 3546 : {

	push	ebp
	mov	ebp, esp

; 3547 : 	return 0;

	xor	eax, eax

; 3548 : }

	pop	ebp
	ret	0
_Voice_StartVoiceTweakMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_maxsize$ = 20						; size = 4
_NetAPI_SetValueForKey PROC

; 3526 : {

	push	ebp
	mov	ebp, esp

; 3527 : 	if( key[0] == '*' ) return;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _key$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN2@NetAPI_Set
	jmp	SHORT $LN1@NetAPI_Set
$LN2@NetAPI_Set:

; 3528 : 	Info_SetValueForStarKey( s, key, value, maxsize );

	mov	ecx, DWORD PTR _maxsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
$LN1@NetAPI_Set:

; 3529 : }

	pop	ebp
	ret	0
_NetAPI_SetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_NetAPI_RemoveKey PROC

; 3515 : {

	push	ebp
	mov	ebp, esp

; 3516 : 	Info_RemoveKey( s, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_RemoveKey
	add	esp, 8

; 3517 : }

	pop	ebp
	ret	0
_NetAPI_RemoveKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_NetAPI_ValueForKey PROC

; 3504 : {

	push	ebp
	mov	ebp, esp

; 3505 : 	return Info_ValueForKey( s, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8

; 3506 : }

	pop	ebp
	ret	0
_NetAPI_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_a$ = 12						; size = 4
_NetAPI_StringToAdr PROC

; 3493 : {

	push	ebp
	mov	ebp, esp

; 3494 : 	return NET_StringToAdr( s, a );

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_NET_StringToAdr
	add	esp, 8

; 3495 : }

	pop	ebp
	ret	0
_NetAPI_StringToAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_NetAPI_CompareAdr PROC

; 3482 : {

	push	ebp
	mov	ebp, esp

; 3483 : 	return NET_CompareAdr( *a, *b );

	mov	eax, DWORD PTR _b$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _a$[ebp]
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H

; 3484 : }

	pop	ebp
	ret	0
_NetAPI_CompareAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
_NetAPI_AdrToString PROC

; 3471 : {

	push	ebp
	mov	ebp, esp

; 3472 : 	return NET_AdrToString( *a );

	mov	eax, DWORD PTR _a$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H

; 3473 : }

	pop	ebp
	ret	0
_NetAPI_AdrToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_nr$ = -8						; size = 4
_i$ = -4						; size = 4
_context$ = 8						; size = 4
_NetAPI_CancelRequest PROC

; 3407 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3408 : 	net_request_t	*nr;
; 3409 : 	int		i;
; 3410 : 
; 3411 : 	// find a specified request
; 3412 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NetAPI_Can
$LN2@NetAPI_Can:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NetAPI_Can:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN3@NetAPI_Can

; 3413 : 	{
; 3414 : 		nr = &clgame.net_requests[i];

	imul	ecx, DWORD PTR _i$[ebp], 80
	add	ecx, OFFSET _clgame+144672
	mov	DWORD PTR _nr$[ebp], ecx

; 3415 : 
; 3416 : 		if( clgame.net_requests[i].resp.context == context )

	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _clgame[edx+144676]
	cmp	eax, DWORD PTR _context$[ebp]
	jne	$LN5@NetAPI_Can

; 3417 : 		{
; 3418 : 			if( nr->pfnFunc )

	mov	ecx, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN6@NetAPI_Can

; 3419 : 			{
; 3420 : 				SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	edx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [ecx], eax

; 3421 : 				nr->resp.ping = host.realtime - nr->timesend;

	mov	edx, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [edx+64]
	mov	eax, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [eax+32], xmm0

; 3422 : 				nr->pfnFunc( &nr->resp );

	mov	ecx, DWORD PTR _nr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	add	esp, 4
$LN6@NetAPI_Can:

; 3423 :                               }
; 3424 : 
; 3425 : 			if( clgame.net_requests[i].resp.type == NETAPI_REQUEST_SERVERLIST && &clgame.net_requests[i] == clgame.master_request )

	imul	ecx, DWORD PTR _i$[ebp], 80
	cmp	DWORD PTR _clgame[ecx+144680], 0
	jne	SHORT $LN7@NetAPI_Can
	imul	edx, DWORD PTR _i$[ebp], 80
	add	edx, OFFSET _clgame+144672
	cmp	edx, DWORD PTR _clgame+149792
	jne	SHORT $LN7@NetAPI_Can

; 3426 : 			{
; 3427 : 				if( clgame.request_type == NET_REQUEST_CLIENT )

	cmp	DWORD PTR _clgame+144668, 2
	jne	SHORT $LN8@NetAPI_Can

; 3428 : 					clgame.request_type = NET_REQUEST_CANCEL;

	mov	DWORD PTR _clgame+144668, 0
$LN8@NetAPI_Can:

; 3429 : 				clgame.master_request = NULL;

	mov	DWORD PTR _clgame+149792, 0
$LN7@NetAPI_Can:

; 3430 : 			}
; 3431 : 
; 3432 : 			memset( &clgame.net_requests[i], 0, sizeof( net_request_t ));

	push	80					; 00000050H
	push	0
	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+144672
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3433 : 			break;

	jmp	SHORT $LN3@NetAPI_Can
$LN5@NetAPI_Can:

; 3434 : 		}
; 3435 : 	}

	jmp	$LN2@NetAPI_Can
$LN3@NetAPI_Can:

; 3436 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_CancelRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_max_timeout$1 = -792					; size = 8
tv95 = -784						; size = 4
_i$ = -780						; size = 4
_nr$ = -776						; size = 4
_req$ = -772						; size = 256
_fullquery$2 = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_context$ = 8						; size = 4
_request$ = 12						; size = 4
_flags$ = 16						; size = 4
_timeout$ = 20						; size = 8
_remote_address$ = 28					; size = 4
_response$ = 32						; size = 4
_NetAPI_SendRequest PROC

; 3329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 792				; 00000318H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3330 : 	net_request_t	*nr = NULL;

	mov	DWORD PTR _nr$[ebp], 0

; 3331 : 	string		req;
; 3332 : 	int		i;
; 3333 : 
; 3334 : 	if( !response )

	cmp	DWORD PTR _response$[ebp], 0
	jne	SHORT $LN8@NetAPI_Sen

; 3335 : 	{
; 3336 : 		Con_DPrintf( S_ERROR "Net_SendRequest: no callbcak specified for request with context %i!\n", context );

	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET $SG147775
	call	_Con_DPrintf
	add	esp, 8

; 3337 : 		return;

	jmp	$LN14@NetAPI_Sen
$LN8@NetAPI_Sen:

; 3338 : 	}
; 3339 : 
; 3340 : 	if( remote_address->type >= NA_IPX )

	mov	ecx, DWORD PTR _remote_address$[ebp]
	cmp	DWORD PTR [ecx], 4
	jl	SHORT $LN9@NetAPI_Sen

; 3341 : 		return; // IPX no longer support

	jmp	$LN14@NetAPI_Sen
$LN9@NetAPI_Sen:

; 3342 : 
; 3343 : 	// find a free request
; 3344 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NetAPI_Sen
$LN2@NetAPI_Sen:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@NetAPI_Sen:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@NetAPI_Sen

; 3345 : 	{
; 3346 : 		nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+144672
	mov	DWORD PTR _nr$[ebp], eax

; 3347 : 		if( !nr->pfnFunc ) break;

	mov	ecx, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN10@NetAPI_Sen
	jmp	SHORT $LN3@NetAPI_Sen
$LN10@NetAPI_Sen:

; 3348 : 	}

	jmp	SHORT $LN2@NetAPI_Sen
$LN3@NetAPI_Sen:

; 3349 : 
; 3350 : 	if( i == MAX_REQUESTS )

	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jne	$LN6@NetAPI_Sen

; 3351 : 	{
; 3352 : 		double	max_timeout = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _max_timeout$1[ebp], xmm0

; 3353 : 
; 3354 : 		// no free requests? use oldest
; 3355 : 		for( i = 0, nr = NULL; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _nr$[ebp], 0
	jmp	SHORT $LN7@NetAPI_Sen
$LN5@NetAPI_Sen:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@NetAPI_Sen:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@NetAPI_Sen

; 3356 : 		{
; 3357 : 			if(( host.realtime - clgame.net_requests[i].timesend ) > max_timeout )

	imul	eax, DWORD PTR _i$[ebp], 80
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _clgame[eax+144736]
	comisd	xmm0, QWORD PTR _max_timeout$1[ebp]
	jbe	SHORT $LN12@NetAPI_Sen

; 3358 : 			{
; 3359 : 				max_timeout = host.realtime - clgame.net_requests[i].timesend;

	imul	ecx, DWORD PTR _i$[ebp], 80
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _clgame[ecx+144736]
	movsd	QWORD PTR _max_timeout$1[ebp], xmm0

; 3360 : 				nr = &clgame.net_requests[i];

	imul	edx, DWORD PTR _i$[ebp], 80
	add	edx, OFFSET _clgame+144672
	mov	DWORD PTR _nr$[ebp], edx
$LN12@NetAPI_Sen:

; 3361 : 			}
; 3362 : 		}

	jmp	SHORT $LN5@NetAPI_Sen
$LN6@NetAPI_Sen:

; 3363 : 	}
; 3364 : 
; 3365 : 	Assert( nr != NULL );

	cmp	DWORD PTR _nr$[ebp], 0
	je	SHORT $LN17@NetAPI_Sen
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN18@NetAPI_Sen
$LN17@NetAPI_Sen:
	mov	DWORD PTR tv95[ebp], 0
$LN18@NetAPI_Sen:
	push	0
	push	3365					; 00000d25H
	push	OFFSET $SG147780
	push	OFFSET $SG147781
	mov	eax, DWORD PTR tv95[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 3366 : 
; 3367 : 	// clear slot
; 3368 : 	memset( nr, 0, sizeof( *nr ));

	push	80					; 00000050H
	push	0
	mov	ecx, DWORD PTR _nr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3369 : 
; 3370 : 	// create a new request
; 3371 : 	nr->timesend = host.realtime;

	mov	edx, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx+64], xmm0

; 3372 : 	nr->timeout = nr->timesend + timeout;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR [eax+64]
	addsd	xmm0, QWORD PTR _timeout$[ebp]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+56], xmm0

; 3373 : 	nr->pfnFunc = response;

	mov	edx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR [edx+48], eax

; 3374 : 	nr->resp.context = context;

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR _context$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 3375 : 	nr->resp.type = request;	

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _request$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3376 : 	nr->resp.remote_address = *remote_address; 

	mov	edx, DWORD PTR _nr$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _remote_address$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], eax

; 3377 : 	nr->flags = flags;

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 3378 : 
; 3379 : 	if( request == NETAPI_REQUEST_SERVERLIST )

	cmp	DWORD PTR _request$[ebp], 0
	jne	$LN13@NetAPI_Sen

; 3380 : 	{
; 3381 : 		char	fullquery[512] = "1\xFF" "0.0.0.0:0\0" "\\gamedir\\";

	mov	eax, DWORD PTR $SG147784
	mov	DWORD PTR _fullquery$2[ebp], eax
	mov	ecx, DWORD PTR $SG147784+4
	mov	DWORD PTR _fullquery$2[ebp+4], ecx
	mov	edx, DWORD PTR $SG147784+8
	mov	DWORD PTR _fullquery$2[ebp+8], edx
	mov	eax, DWORD PTR $SG147784+12
	mov	DWORD PTR _fullquery$2[ebp+12], eax
	mov	ecx, DWORD PTR $SG147784+16
	mov	DWORD PTR _fullquery$2[ebp+16], ecx
	mov	dx, WORD PTR $SG147784+20
	mov	WORD PTR _fullquery$2[ebp+20], dx
	push	490					; 000001eaH
	push	0
	lea	eax, DWORD PTR _fullquery$2[ebp+22]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3382 : 
; 3383 : 		// make sure what port is specified
; 3384 : 		if( !nr->resp.remote_address.port ) nr->resp.remote_address.port = MSG_BigShort( PORT_MASTER );

	mov	ecx, DWORD PTR _nr$[ebp]
	movzx	edx, WORD PTR [ecx+30]
	test	edx, edx
	jne	SHORT $LN15@NetAPI_Sen
	push	27010					; 00006982H
	call	_MSG_BigShort
	add	esp, 4
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	WORD PTR [ecx+30], ax
$LN15@NetAPI_Sen:

; 3385 : 
; 3386 : 		// grab the list from the master server
; 3387 : 		Q_strcpy( &fullquery[22], GI->gamedir );

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _SI+768
	add	edx, 128				; 00000080H
	push	edx
	mov	eax, 1
	imul	ecx, eax, 22
	lea	edx, DWORD PTR _fullquery$2[ebp+ecx]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3388 : 		NET_SendPacket( NS_CLIENT, Q_strlen( GI->gamedir ) + 23, fullquery, nr->resp.remote_address );

	mov	eax, DWORD PTR _nr$[ebp]
	add	eax, 12					; 0000000cH
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	lea	ecx, DWORD PTR _fullquery$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _SI+768
	add	edx, 128				; 00000080H
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, 23					; 00000017H
	push	eax
	push	0
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 3389 : 		clgame.request_type = NET_REQUEST_CLIENT;

	mov	DWORD PTR _clgame+144668, 2

; 3390 : 		clgame.master_request = nr; // holds the master request unitl the master acking

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR _clgame+149792, eax

; 3391 : 	}

	jmp	SHORT $LN14@NetAPI_Sen
$LN13@NetAPI_Sen:

; 3392 : 	else
; 3393 : 	{
; 3394 : 		// local servers request
; 3395 : 		Q_snprintf( req, sizeof( req ), "netinfo %i %i %i", PROTOCOL_VERSION, context, request );

	mov	ecx, DWORD PTR _request$[ebp]
	push	ecx
	mov	edx, DWORD PTR _context$[ebp]
	push	edx
	push	49					; 00000031H
	push	OFFSET $SG147786
	push	256					; 00000100H
	lea	eax, DWORD PTR _req$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 3396 : 		Netchan_OutOfBandPrint( NS_CLIENT, nr->resp.remote_address, req );

	lea	ecx, DWORD PTR _req$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nr$[ebp]
	add	edx, 12					; 0000000cH
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH
$LN14@NetAPI_Sen:

; 3397 : 	}
; 3398 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_SendRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv92 = -36						; size = 8
tv86 = -28						; size = 8
_packet_loss$ = -20					; size = 4
tv80 = -16						; size = 4
tv79 = -12						; size = 4
tv69 = -8						; size = 4
_connected$ = -4					; size = 4
_status$ = 8						; size = 4
_NetAPI_Status PROC

; 3301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3302 : 	qboolean	connected = false;

	mov	DWORD PTR _connected$[ebp], 0

; 3303 : 	int	packet_loss = 0;

	mov	DWORD PTR _packet_loss$[ebp], 0

; 3304 : 
; 3305 : 	Assert( status != NULL );

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN5@NetAPI_Sta
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN6@NetAPI_Sta
$LN5@NetAPI_Sta:
	mov	DWORD PTR tv69[ebp], 0
$LN6@NetAPI_Sta:
	push	0
	push	3305					; 00000ce9H
	push	OFFSET $SG147741
	push	OFFSET $SG147742
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 3306 : 
; 3307 : 	if( cls.state > ca_disconnected && cls.state != ca_cinematic )

	cmp	DWORD PTR _cls, 0
	jle	SHORT $LN2@NetAPI_Sta
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN2@NetAPI_Sta

; 3308 : 		connected = true;

	mov	DWORD PTR _connected$[ebp], 1
$LN2@NetAPI_Sta:

; 3309 : 
; 3310 : 	if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN3@NetAPI_Sta

; 3311 : 		packet_loss = bound( 0, (int)cls.packet_loss, 100 );

	cvttss2si ecx, DWORD PTR _cls+287324
	test	ecx, ecx
	jl	SHORT $LN9@NetAPI_Sta
	cvttss2si edx, DWORD PTR _cls+287324
	cmp	edx, 100				; 00000064H
	jge	SHORT $LN7@NetAPI_Sta
	cvttss2si eax, DWORD PTR _cls+287324
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@NetAPI_Sta
$LN7@NetAPI_Sta:
	mov	DWORD PTR tv79[ebp], 100		; 00000064H
$LN8@NetAPI_Sta:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], ecx
	jmp	SHORT $LN10@NetAPI_Sta
$LN9@NetAPI_Sta:
	mov	DWORD PTR tv80[ebp], 0
$LN10@NetAPI_Sta:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _packet_loss$[ebp], edx
$LN3@NetAPI_Sta:

; 3312 : 
; 3313 : 	status->connected = connected;

	mov	eax, DWORD PTR _status$[ebp]
	mov	ecx, DWORD PTR _connected$[ebp]
	mov	DWORD PTR [eax], ecx

; 3314 : 	status->connection_time = (connected) ? (host.realtime - cls.netchan.connect_time) : 0.0;

	cmp	DWORD PTR _connected$[ebp], 0
	je	SHORT $LN11@NetAPI_Sta
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+23560
	movsd	QWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN12@NetAPI_Sta
$LN11@NetAPI_Sta:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv86[ebp], xmm0
$LN12@NetAPI_Sta:
	mov	edx, DWORD PTR _status$[ebp]
	movsd	xmm0, QWORD PTR tv86[ebp]
	movsd	QWORD PTR [edx+56], xmm0

; 3315 : 	status->latency = (connected) ? cl.frames[cl.parsecountmod].latency : 0.0;

	cmp	DWORD PTR _connected$[ebp], 0
	je	SHORT $LN13@NetAPI_Sta
	imul	eax, DWORD PTR _cl+12, 17304
	movsd	xmm0, QWORD PTR _cl[eax+96]
	movsd	QWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN14@NetAPI_Sta
$LN13@NetAPI_Sta:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv92[ebp], xmm0
$LN14@NetAPI_Sta:
	mov	ecx, DWORD PTR _status$[ebp]
	movsd	xmm0, QWORD PTR tv92[ebp]
	movsd	QWORD PTR [ecx+48], xmm0

; 3316 : 	status->remote_address = cls.netchan.remote_address;

	mov	edx, DWORD PTR _status$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _cls+23524
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _cls+23528
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _cls+23532
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _cls+23536
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _cls+23540
	mov	DWORD PTR [edx+16], eax

; 3317 : 	status->packet_loss = packet_loss;

	mov	ecx, DWORD PTR _status$[ebp]
	mov	edx, DWORD PTR _packet_loss$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 3318 : 	status->local_address = net_local;

	mov	eax, DWORD PTR _status$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx

; 3319 : 	status->rate = rate->value;

	mov	edx, DWORD PTR _rate
	cvtss2sd xmm0, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _status$[ebp]
	movsd	QWORD PTR [eax+64], xmm0

; 3320 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_Status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_NetAPI_InitNetworking PROC

; 3290 : {

	push	ebp
	mov	ebp, esp

; 3291 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 3292 : }

	pop	ebp
	ret	0
_NetAPI_InitNetworking ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_size$ = 8						; size = 4
_buffer$ = 12						; size = 4
_Demo_WriteBuffer PROC

; 3273 : {

	push	ebp
	mov	ebp, esp

; 3274 : 	CL_WriteDemoUserMessage( buffer, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_CL_WriteDemoUserMessage
	add	esp, 8

; 3275 : }

	pop	ebp
	ret	0
_Demo_WriteBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_Demo_IsTimeDemo PROC

; 3262 : {

	push	ebp
	mov	ebp, esp

; 3263 : 	return cls.timedemo;

	mov	eax, DWORD PTR _cls+297588

; 3264 : }

	pop	ebp
	ret	0
_Demo_IsTimeDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_Demo_IsPlayingback PROC

; 3251 : {

	push	ebp
	mov	ebp, esp

; 3252 : 	return cls.demoplayback;

	mov	eax, DWORD PTR _cls+297580

; 3253 : }

	pop	ebp
	ret	0
_Demo_IsPlayingback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_Demo_IsRecording PROC

; 3240 : {

	push	ebp
	mov	ebp, esp

; 3241 : 	return cls.demorecording;

	mov	eax, DWORD PTR _cls+297576

; 3242 : }

	pop	ebp
	ret	0
_Demo_IsRecording ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_flDensity$ = 8						; size = 4
_iFogSkybox$ = 12					; size = 4
_TriFogParams PROC

; 3222 : {

	push	ebp
	mov	ebp, esp

; 3223 : 	RI.fogDensity = flDensity;

	movss	xmm0, DWORD PTR _flDensity$[ebp]
	movss	DWORD PTR _RI+340, xmm0

; 3224 : 	RI.fogSkybox = iFogSkybox;

	mov	eax, DWORD PTR _iFogSkybox$[ebp]
	mov	DWORD PTR _RI+320, eax

; 3225 : }

	pop	ebp
	ret	0
_TriFogParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
$T1 = -72						; size = 16
tv151 = -56						; size = 8
tv140 = -48						; size = 8
tv129 = -40						; size = 8
tv147 = -32						; size = 4
tv136 = -28						; size = 4
tv93 = -24						; size = 4
_vLightColor$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_value$ = 12						; size = 4
_TriLightAtPoint PROC

; 3186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3187 : 	colorVec	vLightColor;
; 3188 : 
; 3189 : 	if( !pos || !value ) return;

	cmp	DWORD PTR _pos$[ebp], 0
	je	SHORT $LN3@TriLightAt
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@TriLightAt
$LN3@TriLightAt:
	jmp	$LN1@TriLightAt
$LN2@TriLightAt:

; 3190 : 
; 3191 : 	vLightColor = R_LightPoint( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_R_LightPoint
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vLightColor$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vLightColor$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vLightColor$[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _vLightColor$[ebp+12], eax

; 3192 : 
; 3193 : 	value[0] = vLightColor.r;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _vLightColor$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv93[ebp]
	mov	ecx, DWORD PTR tv93[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv129[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv129[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3194 : 	value[1] = vLightColor.g;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _vLightColor$[ebp+4]
	mov	DWORD PTR tv136[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv136[ebp]
	mov	eax, DWORD PTR tv136[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv140[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv140[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 3195 : 	value[2] = vLightColor.b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _vLightColor$[ebp+8]
	mov	DWORD PTR tv147[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR tv147[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv151[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv151[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN1@TriLightAt:

; 3196 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TriLightAtPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pname$ = 8						; size = 4
_matrix$ = 12						; size = 4
_TriGetMatrix PROC

; 3162 : {

	push	ebp
	mov	ebp, esp

; 3163 : 	pglGetFloatv( pname, matrix );

	mov	eax, DWORD PTR _matrix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	call	DWORD PTR _pglGetFloatv

; 3164 : }

	pop	ebp
	ret	0
_TriGetMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_flFogColor$ = 8					; size = 4
_flStart$ = 12						; size = 4
_flEnd$ = 16						; size = 4
_bOn$ = 20						; size = 4
_TriFog	PROC

; 3119 : {

	push	ebp
	mov	ebp, esp

; 3120 : 	// overrided by internal fog
; 3121 : 	if( RI.fogEnabled ) return;

	cmp	DWORD PTR _RI+316, 0
	je	SHORT $LN2@TriFog
	jmp	$LN1@TriFog
$LN2@TriFog:

; 3122 : 	RI.fogCustom = bOn;

	mov	eax, DWORD PTR _bOn$[ebp]
	mov	DWORD PTR _RI+312, eax

; 3123 : 
; 3124 : 	// check for invalid parms
; 3125 : 	if( flEnd <= flStart )

	movss	xmm0, DWORD PTR _flStart$[ebp]
	comiss	xmm0, DWORD PTR _flEnd$[ebp]
	jb	SHORT $LN3@TriFog

; 3126 : 	{
; 3127 : 		glState.isFogEnabled = false;

	mov	DWORD PTR _glState+564, 0

; 3128 : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 3129 : 		pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable

; 3130 : 		return;

	jmp	$LN1@TriFog
$LN3@TriFog:

; 3131 : 	}
; 3132 : 
; 3133 : 	if( RI.fogCustom )

	cmp	DWORD PTR _RI+312, 0
	je	SHORT $LN4@TriFog

; 3134 : 		pglEnable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglEnable
	jmp	SHORT $LN5@TriFog
$LN4@TriFog:

; 3135 : 	else pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN5@TriFog:

; 3136 : 
; 3137 : 	// copy fog params
; 3138 : 	RI.fogColor[0] = flFogColor[0] / 255.0f;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _flFogColor$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _RI[edx+324], xmm0

; 3139 : 	RI.fogColor[1] = flFogColor[1] / 255.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _flFogColor$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _RI[edx+324], xmm0

; 3140 : 	RI.fogColor[2] = flFogColor[2] / 255.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _flFogColor$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _RI[edx+324], xmm0

; 3141 : 	RI.fogStart = flStart;

	movss	xmm0, DWORD PTR _flStart$[ebp]
	movss	DWORD PTR _RI+344, xmm0

; 3142 : 	RI.fogColor[3] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RI[ecx+324], xmm0

; 3143 : 	RI.fogDensity = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+340, xmm0

; 3144 : 	RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1

; 3145 : 	RI.fogEnd = flEnd;

	movss	xmm0, DWORD PTR _flEnd$[ebp]
	movss	DWORD PTR _RI+348, xmm0

; 3146 : 
; 3147 : 	pglFogi( GL_FOG_MODE, GL_LINEAR );

	push	9729					; 00002601H
	push	2917					; 00000b65H
	call	DWORD PTR _pglFogi

; 3148 : 	pglFogfv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv

; 3149 : 	pglFogf( GL_FOG_START, RI.fogStart );

	push	ecx
	movss	xmm0, DWORD PTR _RI+344
	movss	DWORD PTR [esp], xmm0
	push	2915					; 00000b63H
	call	DWORD PTR _pglFogf

; 3150 : 	pglFogf( GL_FOG_END, RI.fogEnd );

	push	ecx
	movss	xmm0, DWORD PTR _RI+348
	movss	DWORD PTR [esp], xmm0
	push	2916					; 00000b64H
	call	DWORD PTR _pglFogf

; 3151 : 	pglHint( GL_FOG_HINT, GL_NICEST );

	push	4354					; 00001102H
	push	3156					; 00000c54H
	call	DWORD PTR _pglHint
$LN1@TriFog:

; 3152 : }

	pop	ebp
	ret	0
_TriFog	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetAppID PROC

; 2863 : {

	push	ebp
	mov	ebp, esp

; 2864 : 	return 70;

	mov	eax, 70					; 00000046H

; 2865 : }

	pop	ebp
	ret	0
_pfnGetAppID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv79 = -32						; size = 4
tv78 = -28						; size = 4
tv75 = -24						; size = 4
tv74 = -20						; size = 4
tv71 = -16						; size = 4
tv70 = -12						; size = 4
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_r$ = 24						; size = 4
_g$ = 28						; size = 4
_b$ = 32						; size = 4
_a$ = 36						; size = 4
_CL_FillRGBABlend PROC

; 2830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2831 : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@CL_FillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@CL_FillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_FillRGB
$LN3@CL_FillRGB:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@CL_FillRGB:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_FillRGB
$LN5@CL_FillRGB:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_FillRGB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 2832 : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@CL_FillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@CL_FillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@CL_FillRGB
$LN7@CL_FillRGB:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@CL_FillRGB:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@CL_FillRGB
$LN9@CL_FillRGB:
	mov	DWORD PTR tv71[ebp], 0
$LN10@CL_FillRGB:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 2833 : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@CL_FillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@CL_FillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@CL_FillRGB
$LN11@CL_FillRGB:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@CL_FillRGB:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@CL_FillRGB
$LN13@CL_FillRGB:
	mov	DWORD PTR tv75[ebp], 0
$LN14@CL_FillRGB:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 2834 : 	a = bound( 0, a, 255 );

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN17@CL_FillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN15@CL_FillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN16@CL_FillRGB
$LN15@CL_FillRGB:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN16@CL_FillRGB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN18@CL_FillRGB
$LN17@CL_FillRGB:
	mov	DWORD PTR tv79[ebp], 0
$LN18@CL_FillRGB:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 2835 : 
; 2836 : 	SPR_AdjustSize( (float *)&x, (float *)&y, (float *)&w, (float *)&h );

	lea	eax, DWORD PTR _h$[ebp]
	push	eax
	lea	ecx, DWORD PTR _w$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_AdjustSize
	add	esp, 16					; 00000010H

; 2837 : 
; 2838 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 2839 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 2840 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 2841 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 2842 : 	pglColor4f( r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f );

	cvtsi2ss xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _b$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _g$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _r$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 2843 : 
; 2844 : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 2845 : 		pglVertex2f( x, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 2846 : 		pglVertex2f( x + w, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 2847 : 		pglVertex2f( x + w, y + h );

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 2848 : 		pglVertex2f( x, y + h );

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 2849 : 	pglEnd ();

	call	DWORD PTR _pglEnd

; 2850 : 
; 2851 : 	pglColor3f( 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2852 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 2853 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 2854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FillRGBABlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_key$ = 8						; size = 4
_LocalPlayerInfo_ValueForKey PROC

; 2819 : {

	push	ebp
	mov	ebp, esp

; 2820 : 	return Info_ValueForKey( cls.userinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _cls+6604
	call	_Info_ValueForKey
	add	esp, 8

; 2821 : }

	pop	ebp
	ret	0
_LocalPlayerInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetGravity PROC

; 2808 : {

	push	ebp
	mov	ebp, esp

; 2809 : 	return clgame.movevars.gravity;

	fld	DWORD PTR _clgame+1028

; 2810 : }

	pop	ebp
	ret	0
_pfnGetGravity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_pfnGetClientOldTime PROC

; 2797 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2798 : 	return cl.oldtime;

	cvtsd2ss xmm0, QWORD PTR _cl+1525856
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]

; 2799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetClientOldTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_out$ = -4						; size = 4
_data$ = 8						; size = 4
_token$ = 12						; size = 4
_pfnParseFile PROC

; 2780 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2781 : 	char	*out;
; 2782 : 
; 2783 : 	host.com_handlecolon = true;

	mov	DWORD PTR _host+34360, 1

; 2784 : 	out = COM_ParseFile( data, token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _out$[ebp], eax

; 2785 : 	host.com_handlecolon = false;

	mov	DWORD PTR _host+34360, 0

; 2786 : 
; 2787 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]

; 2788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_fEnable$ = 8						; size = 4
_pfnSetMouseEnable PROC

; 2769 : {

	push	ebp
	mov	ebp, esp

; 2770 : }

	pop	ebp
	ret	0
_pfnSetMouseEnable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_mx$ = 8						; size = 4
_my$ = 12						; size = 4
_pfnSetMousePos PROC

; 2757 : {

	push	ebp
	mov	ebp, esp

; 2758 : 	SetCursorPos( mx, my );

	mov	eax, DWORD PTR _my$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mx$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetCursorPos@8

; 2759 : }

	pop	ebp
	ret	0
_pfnSetMousePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_ppt$ = 8						; size = 4
_pfnGetMousePos PROC

; 2746 : {

	push	ebp
	mov	ebp, esp

; 2747 : 	GetCursorPos( ppt );

	mov	eax, DWORD PTR _ppt$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 2748 : }

	pop	ebp
	ret	0
_pfnGetMousePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_szCmdString$ = 8					; size = 4
_pfnServerCmdUnreliable PROC

; 2729 : {

	push	ebp
	mov	ebp, esp

; 2730 : 	if( !COM_CheckString( szCmdString ))

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnServerC

; 2731 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnServerC
$LN2@pfnServerC:

; 2732 : 
; 2733 : 	MSG_BeginClientCmd( &cls.datagram, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+7116
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2734 : 	MSG_WriteString( &cls.datagram, szCmdString );

	mov	ecx, DWORD PTR _szCmdString$[ebp]
	push	ecx
	push	OFFSET _cls+7116
	call	_MSG_WriteString
	add	esp, 8

; 2735 : 
; 2736 : 	return 1;

	mov	eax, 1
$LN1@pfnServerC:

; 2737 : }

	pop	ebp
	ret	0
_pfnServerCmdUnreliable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_trackerID$ = 8						; size = 4
_pfnGetPlayerForTrackerID PROC

; 2718 : {

	push	ebp
	mov	ebp, esp

; 2719 : 	return 0;

	xor	eax, eax

; 2720 : }

	pop	ebp
	ret	0
_pfnGetPlayerForTrackerID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_playerSlot$ = 8					; size = 4
_pfnGetTrackerIDForPlayer PROC

; 2706 : {

	push	ebp
	mov	ebp, esp

; 2707 : 	return 0;

	xor	eax, eax

; 2708 : }

	pop	ebp
	ret	0
_pfnGetTrackerIDForPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
_playerID$ = 12						; size = 4
_pfnGetPlayerUniqueID PROC

; 2686 : {

	push	ebp
	mov	ebp, esp

; 2687 : 	if( iPlayer < 1 || iPlayer > cl.maxclients )

	cmp	DWORD PTR _iPlayer$[ebp], 1
	jl	SHORT $LN3@pfnGetPlay
	mov	eax, DWORD PTR _iPlayer$[ebp]
	cmp	eax, DWORD PTR _cl+1568832
	jle	SHORT $LN2@pfnGetPlay
$LN3@pfnGetPlay:

; 2688 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetPlay
$LN2@pfnGetPlay:

; 2689 : 
; 2690 : 	// make sure there is a player here..
; 2691 : 	if( !cl.players[iPlayer-1].userinfo[0] || !cl.players[iPlayer-1].name[0] )

	mov	ecx, DWORD PTR _iPlayer$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 584
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _cl[edx+ecx+1543152]
	test	edx, edx
	je	SHORT $LN5@pfnGetPlay
	mov	eax, DWORD PTR _iPlayer$[ebp]
	sub	eax, 1
	imul	ecx, eax, 584
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _cl[ecx+eax+1543408]
	test	ecx, ecx
	jne	SHORT $LN4@pfnGetPlay
$LN5@pfnGetPlay:

; 2692 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetPlay
$LN4@pfnGetPlay:

; 2693 : 
; 2694 : 	memcpy( playerID, cl.players[iPlayer-1].hashedcdkey, 16 );

	push	16					; 00000010H
	mov	edx, DWORD PTR _iPlayer$[ebp]
	sub	edx, 1
	imul	eax, edx, 584
	add	eax, OFFSET _cl+1543716
	push	eax
	mov	ecx, DWORD PTR _playerID$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2695 : 	return true;

	mov	eax, 1
$LN1@pfnGetPlay:

; 2696 : }

	pop	ebp
	ret	0
_pfnGetPlayerUniqueID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_var$ = -4						; size = 4
_key$ = 8						; size = 4
_value$ = 12						; size = 4
_PlayerInfo_SetValueForKey PROC

; 2660 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2661 : 	convar_t	*var;
; 2662 : 
; 2663 : 	if( !Q_strcmp( Info_ValueForKey( cls.userinfo, key ), value ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET _cls+6604
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@PlayerInfo

; 2664 : 		return; // no changes ?

	jmp	SHORT $LN1@PlayerInfo
$LN2@PlayerInfo:

; 2665 : 
; 2666 : 	var = Cvar_FindVar( key );

	push	0
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _var$[ebp], eax

; 2667 : 
; 2668 : 	if( var && FBitSet( var->flags, FCVAR_USERINFO ))

	cmp	DWORD PTR _var$[ebp], 0
	je	SHORT $LN3@PlayerInfo
	mov	eax, DWORD PTR _var$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	SHORT $LN3@PlayerInfo

; 2669 : 	{
; 2670 : 		Cvar_DirectSet( var, value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	call	_Cvar_DirectSet
	add	esp, 8

; 2671 : 	}

	jmp	SHORT $LN1@PlayerInfo
$LN3@PlayerInfo:

; 2672 : 	else if( Info_SetValueForStarKey( cls.userinfo, key, value, MAX_INFO_STRING ))

	push	256					; 00000100H
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	push	OFFSET _cls+6604
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@PlayerInfo

; 2673 : 	{
; 2674 : 		// time to update server copy of userinfo
; 2675 : 		CL_ServerCommand( true, "setinfo \"%s\" \"%s\"\n", key, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET $SG147487
	push	1
	call	_CL_ServerCommand
	add	esp, 16					; 00000010H
$LN1@PlayerInfo:

; 2676 : 	}
; 2677 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PlayerInfo_SetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_playerNum$ = 8						; size = 4
_key$ = 12						; size = 4
_PlayerInfo_ValueForKey PROC

; 2642 : {

	push	ebp
	mov	ebp, esp

; 2643 : 	// find the player
; 2644 : 	if(( playerNum > cl.maxclients ) || ( playerNum < 1 ))

	mov	eax, DWORD PTR _playerNum$[ebp]
	cmp	eax, DWORD PTR _cl+1568832
	jg	SHORT $LN3@PlayerInfo
	cmp	DWORD PTR _playerNum$[ebp], 1
	jge	SHORT $LN2@PlayerInfo
$LN3@PlayerInfo:

; 2645 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@PlayerInfo
$LN2@PlayerInfo:

; 2646 : 
; 2647 : 	if( !cl.players[playerNum-1].name[0] )

	mov	ecx, DWORD PTR _playerNum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 584
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _cl[edx+ecx+1543408]
	test	edx, edx
	jne	SHORT $LN4@PlayerInfo

; 2648 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@PlayerInfo
$LN4@PlayerInfo:

; 2649 : 
; 2650 : 	return Info_ValueForKey( cl.players[playerNum-1].userinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerNum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 584
	add	edx, OFFSET _cl+1543152
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
$LN1@PlayerInfo:

; 2651 : }

	pop	ebp
	ret	0
_PlayerInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_pfnLoadMapSprite PROC

; 2631 : {

	push	ebp
	mov	ebp, esp

; 2632 : 	return CL_LoadSpriteModel( filename, SPR_MAPSPRITE, 0 );

	push	0
	push	2
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH

; 2633 : }

	pop	ebp
	ret	0
_pfnLoadMapSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_fade$ = 8						; size = 4
_pfnSetScreenFade PROC

; 2620 : {

	push	ebp
	mov	ebp, esp

; 2621 : 	if( fade ) clgame.fade = *fade;

	cmp	DWORD PTR _fade$[ebp], 0
	je	SHORT $LN1@pfnSetScre
	mov	eax, DWORD PTR _fade$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _clgame+122740, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _clgame+122744, edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _clgame+122748, ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _clgame+122752, edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _clgame+122756, ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _clgame+122760, edx
$LN1@pfnSetScre:

; 2622 : }

	pop	ebp
	ret	0
_pfnSetScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_fade$ = 8						; size = 4
_pfnGetScreenFade PROC

; 2609 : {

	push	ebp
	mov	ebp, esp

; 2610 : 	if( fade ) *fade = clgame.fade;

	cmp	DWORD PTR _fade$[ebp], 0
	je	SHORT $LN1@pfnGetScre
	mov	eax, DWORD PTR _fade$[ebp]
	mov	ecx, DWORD PTR _clgame+122740
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _clgame+122744
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _clgame+122748
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _clgame+122752
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _clgame+122756
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _clgame+122760
	mov	DWORD PTR [eax+20], edx
$LN1@pfnGetScre:

; 2611 : }

	pop	ebp
	ret	0
_pfnGetScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pfnGetLevelName PROC

; 2592 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2593 : 	static char	mapname[64];
; 2594 : 
; 2595 : 	if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN2@pfnGetLeve

; 2596 : 		Q_snprintf( mapname, sizeof( mapname ), "maps/%s.bsp", clgame.mapname );

	push	OFFSET _clgame+232
	push	OFFSET $SG147450
	push	64					; 00000040H
	push	OFFSET ?mapname@?1??pfnGetLevelName@@9@9
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@pfnGetLeve
$LN2@pfnGetLeve:

; 2597 : 	else mapname[0] = '\0'; // not in game

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 64			; 00000040H
	jae	SHORT $LN5@pfnGetLeve
	jmp	SHORT $LN6@pfnGetLeve
$LN5@pfnGetLeve:
	call	___report_rangecheckfailure
$LN6@pfnGetLeve:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?mapname@?1??pfnGetLevelName@@9@9[edx], 0
$LN3@pfnGetLeve:

; 2598 : 
; 2599 : 	return mapname;

	mov	eax, OFFSET ?mapname@?1??pfnGetLevelName@@9@9
$LN4@pfnGetLeve:

; 2600 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetLevelName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pBinding$ = 8						; size = 4
_Key_LookupBinding PROC

; 2581 : {

	push	ebp
	mov	ebp, esp

; 2582 : 	return Key_KeynumToString( Key_GetKey( pBinding ));

	mov	eax, DWORD PTR _pBinding$[ebp]
	push	eax
	call	_Key_GetKey
	add	esp, 4
	push	eax
	call	_Key_KeynumToString
	add	esp, 4

; 2583 : }

	pop	ebp
	ret	0
_Key_LookupBinding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetGameDirectory PROC

; 2567 : {

	push	ebp
	mov	ebp, esp

; 2568 : 	static char	szGetGameDir[MAX_SYSPATH];
; 2569 : 
; 2570 : 	Q_sprintf( szGetGameDir, "%s/%s", host.rootdir, GI->gamedir );

	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET _host+34420
	push	OFFSET $SG147437
	push	OFFSET ?szGetGameDir@?1??pfnGetGameDirectory@@9@9
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 2571 : 	return szGetGameDir;

	mov	eax, OFFSET ?szGetGameDir@?1??pfnGetGameDirectory@@9@9

; 2572 : }

	pop	ebp
	ret	0
_pfnGetGameDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_entchannel$ = 12					; size = 4
_pfnStopAllSounds PROC

; 2525 : {

	push	ebp
	mov	ebp, esp

; 2526 : 	S_StopSound( ent, entchannel, NULL );

	push	0
	mov	eax, DWORD PTR _entchannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_S_StopSound
	add	esp, 12					; 0000000cH

; 2527 : }

	pop	ebp
	ret	0
_pfnStopAllSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetMoveVars PROC

; 2514 : {

	push	ebp
	mov	ebp, esp

; 2515 : 	return &clgame.movevars;

	mov	eax, OFFSET _clgame+1028

; 2516 : }

	pop	ebp
	ret	0
_pfnGetMoveVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceSurface PROC

; 2497 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2498 : 	physent_t *pe;
; 2499 : 
; 2500 : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceSu
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceSu
$LN3@pfnTraceSu:

; 2501 : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceSu
$LN2@pfnTraceSu:

; 2502 : 
; 2503 : 	pe = &clgame.pmove->physents[ground];

	imul	edx, DWORD PTR _ground$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 2504 : 	return PM_TraceSurface( pe, vstart, vend );

	mov	edx, DWORD PTR _vend$[ebp]
	push	edx
	mov	eax, DWORD PTR _vstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
$LN1@pfnTraceSu:

; 2505 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceTexture PROC

; 2480 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2481 : 	physent_t *pe;
; 2482 : 
; 2483 : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceTe
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceTe
$LN3@pfnTraceTe:

; 2484 : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 2485 : 
; 2486 : 	pe = &clgame.pmove->physents[ground];

	imul	edx, DWORD PTR _ground$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 2487 : 	return PM_TraceTexture( pe, vstart, vend );

	mov	edx, DWORD PTR _vend$[ebp]
	push	edx
	mov	eax, DWORD PTR _vstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 2488 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_pfnGetVisent PROC

; 2428 : {

	push	ebp
	mov	ebp, esp

; 2429 : 	if( idx >= 0 && idx < clgame.pmove->numvisent )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN2@pfnGetVise
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _idx$[ebp]
	cmp	ecx, DWORD PTR [eax+149332]
	jge	SHORT $LN2@pfnGetVise

; 2430 : 	{
; 2431 : 		// return physent
; 2432 : 		return &clgame.pmove->visents[idx];

	imul	edx, DWORD PTR _idx$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [eax+edx+149336]
	jmp	SHORT $LN1@pfnGetVise
$LN2@pfnGetVise:

; 2433 : 	}
; 2434 : 	return NULL;

	xor	eax, eax
$LN1@pfnGetVise:

; 2435 : }

	pop	ebp
	ret	0
_pfnGetVisent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_pfnGetPhysent PROC

; 2412 : {

	push	ebp
	mov	ebp, esp

; 2413 : 	if( idx >= 0 && idx < clgame.pmove->numphysent )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN2@pfnGetPhys
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _idx$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	SHORT $LN2@pfnGetPhys

; 2414 : 	{
; 2415 : 		// return physent
; 2416 : 		return &clgame.pmove->physents[idx];

	imul	edx, DWORD PTR _idx$[ebp], 224
	mov	eax, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [eax+edx+592]
	jmp	SHORT $LN1@pfnGetPhys
$LN2@pfnGetPhys:

; 2417 : 	}
; 2418 : 	return NULL;

	xor	eax, eax
$LN1@pfnGetPhys:

; 2419 : }

	pop	ebp
	ret	0
_pfnGetPhysent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_hull$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_pfnLocalPlayerBounds PROC

; 2381 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 2382 : 	if( hull >= 0 && hull < 4 )

	cmp	DWORD PTR _hull$[ebp], 0
	jl	$LN4@pfnLocalPl
	cmp	DWORD PTR _hull$[ebp], 4
	jge	$LN4@pfnLocalPl

; 2383 : 	{
; 2384 : 		if( mins ) VectorCopy( clgame.pmove->player_mins[hull], mins );

	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN3@pfnLocalPl
	imul	eax, DWORD PTR _hull$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1316
	lea	edx, DWORD PTR [ecx+eax+324852]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+324852]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
$LN3@pfnLocalPl:

; 2385 : 		if( maxs ) VectorCopy( clgame.pmove->player_maxs[hull], maxs );

	cmp	DWORD PTR _maxs$[ebp], 0
	je	SHORT $LN4@pfnLocalPl
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1316
	lea	ecx, DWORD PTR [eax+edx+324900]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [esi+edx], eax
	imul	ecx, DWORD PTR _hull$[ebp], 12
	mov	edx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [esi+edx], eax
	imul	ecx, DWORD PTR _hull$[ebp], 12
	mov	edx, DWORD PTR _clgame+1316
	lea	eax, DWORD PTR [edx+ecx+324900]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [esi+edx], eax
$LN4@pfnLocalPl:

; 2386 : 	}
; 2387 : }

	pop	esi
	pop	ebp
	ret	0
_pfnLocalPlayerBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_view_ofs$ = 8						; size = 4
_pfnLocalPlayerViewheight PROC

; 2370 : {

	push	ebp
	mov	ebp, esp

; 2371 : 	if( view_ofs ) VectorCopy( cl.viewheight, view_ofs );		

	cmp	DWORD PTR _view_ofs$[ebp], 0
	je	SHORT $LN2@pfnLocalPl
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _view_ofs$[ebp]
	mov	ecx, DWORD PTR _cl[ecx+1568624]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _view_ofs$[ebp]
	mov	edx, DWORD PTR _cl[edx+1568624]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _view_ofs$[ebp]
	mov	eax, DWORD PTR _cl[eax+1568624]
	mov	DWORD PTR [edx+ecx], eax
$LN2@pfnLocalPl:

; 2372 : }

	pop	ebp
	ret	0
_pfnLocalPlayerViewheight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_pfnLocalPlayerDucking PROC

; 2359 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2360 : 	return (cl.local.usehull == 1) ? true : false;

	cmp	DWORD PTR _cl+1568572, 1
	jne	SHORT $LN3@pfnLocalPl
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@pfnLocalPl
$LN3@pfnLocalPl:
	mov	DWORD PTR tv65[ebp], 0
$LN4@pfnLocalPl:
	mov	eax, DWORD PTR tv65[ebp]

; 2361 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLocalPlayerDucking ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_playernum$ = 8						; size = 4
_pfnIsLocal PROC

; 2346 : {

	push	ebp
	mov	ebp, esp

; 2347 : 	if( playernum == cl.playernum )

	mov	eax, DWORD PTR _playernum$[ebp]
	cmp	eax, DWORD PTR _cl+1568828
	jne	SHORT $LN2@pfnIsLocal

; 2348 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnIsLocal
$LN2@pfnIsLocal:

; 2349 : 	return false;

	xor	eax, eax
$LN1@pfnIsLocal:

; 2350 : }

	pop	ebp
	ret	0
_pfnIsLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_org$ = 12						; size = 4
_chan$ = 16						; size = 4
_samp$ = 20						; size = 4
_vol$ = 24						; size = 4
_attn$ = 28						; size = 4
_flags$ = 32						; size = 4
_pitch$ = 36						; size = 4
_pfnPlaySound PROC

; 2298 : {

	push	ebp
	mov	ebp, esp

; 2299 : 	S_StartSound( org, ent, chan, S_RegisterSound( samp ), vol, attn, pitch, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _samp$[ebp]
	push	edx
	call	_S_RegisterSound
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 2300 : }

	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_es$ = -16						; size = 4
_ei$ = -12						; size = 4
_eventIndex$ = -8					; size = 4
_i$ = -4						; size = 4
_entnum$ = 8						; size = 4
_eventname$ = 12					; size = 4
_pfnKillEvents PROC

; 2264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2265 : 	int		i;
; 2266 : 	event_state_t	*es;
; 2267 : 	event_info_t	*ei;
; 2268 : 	int		eventIndex = CL_EventIndex( eventname );

	mov	eax, DWORD PTR _eventname$[ebp]
	push	eax
	call	_CL_EventIndex
	add	esp, 4
	movzx	ecx, ax
	mov	DWORD PTR _eventIndex$[ebp], ecx

; 2269 : 
; 2270 : 	if( eventIndex < 0 || eventIndex >= MAX_EVENTS )

	cmp	DWORD PTR _eventIndex$[ebp], 0
	jl	SHORT $LN6@pfnKillEve
	cmp	DWORD PTR _eventIndex$[ebp], 1024	; 00000400H
	jl	SHORT $LN5@pfnKillEve
$LN6@pfnKillEve:

; 2271 : 		return;

	jmp	SHORT $LN1@pfnKillEve
$LN5@pfnKillEve:

; 2272 : 
; 2273 : 	if( entnum < 0 || entnum > clgame.maxEntities )

	cmp	DWORD PTR _entnum$[ebp], 0
	jl	SHORT $LN8@pfnKillEve
	mov	edx, DWORD PTR _entnum$[ebp]
	cmp	edx, DWORD PTR _clgame+1012
	jle	SHORT $LN7@pfnKillEve
$LN8@pfnKillEve:

; 2274 : 		return;

	jmp	SHORT $LN1@pfnKillEve
$LN7@pfnKillEve:

; 2275 : 
; 2276 : 	es = &cl.events;

	mov	DWORD PTR _es$[ebp], OFFSET _cl+1562104

; 2277 : 
; 2278 : 	// find all events with specified index and kill it
; 2279 : 	for( i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnKillEve
$LN2@pfnKillEve:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnKillEve:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN1@pfnKillEve

; 2280 : 	{
; 2281 : 		ei = &es->ei[i];

	imul	ecx, DWORD PTR _i$[ebp], 88
	add	ecx, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], ecx

; 2282 : 
; 2283 : 		if( ei->index == eventIndex && ei->entity_index == entnum )

	mov	edx, DWORD PTR _ei$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, DWORD PTR _eventIndex$[ebp]
	jne	SHORT $LN9@pfnKillEve
	mov	ecx, DWORD PTR _ei$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	cmp	edx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@pfnKillEve

; 2284 : 		{
; 2285 : 			CL_ResetEvent( ei );

	mov	eax, DWORD PTR _ei$[ebp]
	push	eax
	call	_CL_ResetEvent
	add	esp, 4

; 2286 : 			break;

	jmp	SHORT $LN1@pfnKillEve
$LN9@pfnKillEve:

; 2287 : 		}
; 2288 : 	}

	jmp	SHORT $LN2@pfnKillEve
$LN1@pfnKillEve:

; 2289 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnKillEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_ev$ = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pfn$ = 12						; size = 4
_pfnHookEvent PROC

; 2229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2230 : 	char		name[64];
; 2231 : 	cl_user_event_t	*ev;
; 2232 : 	int		i;
; 2233 : 
; 2234 : 	// ignore blank names
; 2235 : 	if( !filename || !*filename )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN6@pfnHookEve
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@pfnHookEve
$LN6@pfnHookEve:

; 2236 : 		return;	

	jmp	$LN1@pfnHookEve
$LN5@pfnHookEve:

; 2237 : 
; 2238 : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2239 : 	COM_FixSlashes( name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_FixSlashes
	add	esp, 4

; 2240 : 
; 2241 : 	// find an empty slot
; 2242 : 	for( i = 0; i < MAX_EVENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnHookEve
$LN2@pfnHookEve:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@pfnHookEve:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@pfnHookEve

; 2243 : 	{
; 2244 : 		ev = clgame.events[i];		

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame[eax*4+10000]
	mov	DWORD PTR _ev$[ebp], ecx

; 2245 : 		if( !ev ) break;

	cmp	DWORD PTR _ev$[ebp], 0
	jne	SHORT $LN7@pfnHookEve
	jmp	SHORT $LN3@pfnHookEve
$LN7@pfnHookEve:

; 2246 : 
; 2247 : 		if( !Q_stricmp( name, ev->name ) && ev->func != NULL )

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _ev$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnHookEve
	mov	ecx, DWORD PTR _ev$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN8@pfnHookEve

; 2248 : 		{
; 2249 : 			Con_Reportf( S_WARN "CL_HookEvent: %s already hooked!\n", name );

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG147259
	call	_Con_Reportf
	add	esp, 8

; 2250 : 			return;

	jmp	SHORT $LN1@pfnHookEve
$LN8@pfnHookEve:

; 2251 : 		}
; 2252 : 	}

	jmp	SHORT $LN2@pfnHookEve
$LN3@pfnHookEve:

; 2253 : 
; 2254 : 	CL_RegisterEvent( i, name, pfn );

	mov	eax, DWORD PTR _pfn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_CL_RegisterEvent
	add	esp, 12					; 0000000cH
$LN1@pfnHookEve:

; 2255 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHookEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_type$ = 8						; size = 4
_psz$ = 12						; size = 4
_pfnPrecacheEvent PROC

; 2218 : {

	push	ebp
	mov	ebp, esp

; 2219 : 	return CL_EventIndex( psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_CL_EventIndex
	add	esp, 4

; 2220 : }

	pop	ebp
	ret	0
_pfnPrecacheEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_hSound$ = -4						; size = 4
_szSound$ = 8						; size = 4
_volume$ = 12						; size = 4
_origin$ = 16						; size = 4
_pfnPlaySoundByNameAtLocation PROC

; 2206 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2207 : 	int hSound = S_RegisterSound( szSound );

	mov	eax, DWORD PTR _szSound$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _hSound$[ebp], eax

; 2208 : 	S_StartSound( origin, 0, CHAN_AUTO, hSound, volume, ATTN_NORM, PITCH_NORM, 0 );

	push	0
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _hSound$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 2209 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySoundByNameAtLocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
$T1 = -144						; size = 68
$T2 = -76						; size = 68
_old_usehull$ = -8					; size = 4
tv66 = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_ignore_pe$ = 24					; size = 4
_pfnTraceLine PROC

; 2183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	push	edi

; 2184 : 	static pmtrace_t	tr;
; 2185 : 	int		old_usehull;
; 2186 : 
; 2187 : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 2188 : 	clgame.pmove->usehull = usehull;	

	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 2189 : 
; 2190 : 	switch( flags )

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 2191 : 	{
; 2192 : 	case PM_TRACELINE_PHYSENTSONLY:
; 2193 : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	edx, DWORD PTR _ignore_pe$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	push	0
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd

; 2194 : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 2195 : 	case PM_TRACELINE_ANYVISIBLE:
; 2196 : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numvisent, clgame.pmove->visents, ignore_pe, NULL );

	push	0
	mov	ecx, DWORD PTR _ignore_pe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	add	edx, 149336				; 00024758H
	push	edx
	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR [eax+149332]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 2197 : 		break;
; 2198 : 	}
; 2199 : 
; 2200 : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1316
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 2201 : 
; 2202 : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLine@@9@9

; 2203 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_truecont$ = -8						; size = 4
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_truecontents$ = 12					; size = 4
_pfnPointContents PROC

; 2165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2166 : 	int	cont, truecont;
; 2167 : 
; 2168 : 	truecont = cont = PM_PointContents( clgame.pmove, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	call	_PM_PointContents
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax
	mov	edx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR _truecont$[ebp], edx

; 2169 : 	if( truecontents ) *truecontents = truecont;

	cmp	DWORD PTR _truecontents$[ebp], 0
	je	SHORT $LN2@pfnPointCo
	mov	eax, DWORD PTR _truecontents$[ebp]
	mov	ecx, DWORD PTR _truecont$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnPointCo:

; 2170 : 
; 2171 : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN3@pfnPointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN3@pfnPointCo

; 2172 : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN3@pfnPointCo:

; 2173 : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 2174 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_pfnIsSpectateOnly PROC

; 2154 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2155 : 	return (cls.spectator != 0);

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN3@pfnIsSpect
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@pfnIsSpect
$LN3@pfnIsSpect:
	mov	DWORD PTR tv65[ebp], 0
$LN4@pfnIsSpect:
	mov	eax, DWORD PTR tv65[ebp]

; 2156 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsSpectateOnly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv88 = -4						; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
_factor$ = 16						; size = 4
_pfnApplyShake PROC

; 2142 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2143 : 	if( origin ) VectorMA( origin, factor, clgame.shake.applied_offset, origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	$LN2@pfnApplySh
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _factor$[ebp]
	mulss	xmm0, DWORD PTR _clgame[eax+122800]
	mov	edx, DWORD PTR _origin$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _factor$[ebp]
	mulss	xmm0, DWORD PTR _clgame[ecx+122800]
	mov	edx, DWORD PTR _origin$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _factor$[ebp]
	mulss	xmm0, DWORD PTR _clgame[eax+122800]
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv88[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN2@pfnApplySh:

; 2144 : 	if( angles ) angles[ROLL] += clgame.shake.applied_angle * factor;

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN3@pfnApplySh
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _clgame+122812
	mulss	xmm0, DWORD PTR _factor$[ebp]
	mov	edx, DWORD PTR _angles$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN3@pfnApplySh:

; 2145 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnApplyShake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv234 = -36						; size = 8
tv252 = -28						; size = 8
_localAmp$ = -20					; size = 4
tv156 = -16						; size = 4
_freq$ = -12						; size = 4
_i$ = -8						; size = 4
_fraction$ = -4						; size = 4
_pfnCalcShake PROC

; 2080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2081 : 	int	i;
; 2082 : 	float	fraction, freq;
; 2083 : 	float	localAmp;
; 2084 : 
; 2085 : 	if( clgame.shake.time == 0 )

	movss	xmm0, DWORD PTR _clgame+122764
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@pfnCalcSha

; 2086 : 		return;

	jmp	$LN1@pfnCalcSha
$LN5@pfnCalcSha:

; 2087 : 
; 2088 : 	if(( cl.time > clgame.shake.time ) || clgame.shake.amplitude <= 0 || clgame.shake.frequency <= 0 )

	cvtss2sd xmm0, DWORD PTR _clgame+122764
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	ja	SHORT $LN7@pfnCalcSha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _clgame+122772
	jae	SHORT $LN7@pfnCalcSha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _clgame+122776
	jb	SHORT $LN6@pfnCalcSha
$LN7@pfnCalcSha:

; 2089 : 	{
; 2090 : 		memset( &clgame.shake, 0, sizeof( clgame.shake ));

	push	52					; 00000034H
	push	0
	push	OFFSET _clgame+122764
	call	_memset
	add	esp, 12					; 0000000cH

; 2091 : 		return;

	jmp	$LN1@pfnCalcSha
$LN6@pfnCalcSha:

; 2092 : 	}
; 2093 : 
; 2094 : 	if( cl.time > clgame.shake.next_shake )

	cvtss2sd xmm0, DWORD PTR _clgame+122780
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	jbe	$LN8@pfnCalcSha

; 2095 : 	{
; 2096 : 		// higher frequency means we recalc the extents more often and perturb the display again
; 2097 : 		clgame.shake.next_shake = cl.time + ( 1.0f / clgame.shake.frequency );

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _clgame+122776
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+1525848
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _clgame+122780, xmm0

; 2098 : 
; 2099 : 		// compute random shake extents (the shake will settle down from this)
; 2100 : 		for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnCalcSha
$LN2@pfnCalcSha:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnCalcSha:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@pfnCalcSha

; 2101 : 			clgame.shake.offset[i] = COM_RandomFloat( -clgame.shake.amplitude, clgame.shake.amplitude );

	push	ecx
	movss	xmm0, DWORD PTR _clgame+122772
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _clgame+122772
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _clgame[ecx*4+122784]
	jmp	SHORT $LN2@pfnCalcSha
$LN3@pfnCalcSha:

; 2102 : 		clgame.shake.angle = COM_RandomFloat( -clgame.shake.amplitude * 0.25f, clgame.shake.amplitude * 0.25f );

	movss	xmm0, DWORD PTR _clgame+122772
	mulss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _clgame+122772
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _clgame+122796
$LN8@pfnCalcSha:

; 2103 : 	}
; 2104 : 
; 2105 : 	// ramp down amplitude over duration (fraction goes from 1 to 0 linearly with slope 1/duration)
; 2106 : 	fraction = ( clgame.shake.time - cl.time ) / clgame.shake.duration;

	cvtss2sd xmm0, DWORD PTR _clgame+122764
	subsd	xmm0, QWORD PTR _cl+1525848
	cvtss2sd xmm1, DWORD PTR _clgame+122768
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2107 : 
; 2108 : 	// ramp up frequency over duration
; 2109 : 	if( fraction )

	movss	xmm0, DWORD PTR _fraction$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@pfnCalcSha

; 2110 : 	{
; 2111 : 		freq = ( clgame.shake.frequency / fraction );

	movss	xmm0, DWORD PTR _clgame+122776
	divss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR _freq$[ebp], xmm0

; 2112 : 	}

	jmp	SHORT $LN10@pfnCalcSha
$LN9@pfnCalcSha:

; 2113 : 	else
; 2114 : 	{
; 2115 : 		freq = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _freq$[ebp], xmm0
$LN10@pfnCalcSha:

; 2116 : 	}
; 2117 : 
; 2118 : 	// square fraction to approach zero more quickly
; 2119 : 	fraction *= fraction;

	movss	xmm0, DWORD PTR _fraction$[ebp]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2120 : 
; 2121 : 	// Sine wave that slowly settles to zero
; 2122 : 	fraction = fraction * sin( cl.time * freq );

	cvtss2sd xmm0, DWORD PTR _fraction$[ebp]
	cvtss2sd xmm1, DWORD PTR _freq$[ebp]
	mulsd	xmm1, QWORD PTR _cl+1525848
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv252[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv234[ebp]
	movsd	xmm0, QWORD PTR tv252[ebp]
	mulsd	xmm0, QWORD PTR tv234[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2123 : 	
; 2124 : 	// add to view origin
; 2125 : 	VectorScale( clgame.shake.offset, fraction, clgame.shake.applied_offset );

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _clgame[eax+122784]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _clgame[edx+122800], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _clgame[eax+122784]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _clgame[ecx+122800], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _clgame[edx+122784]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR tv156[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv156[ebp]
	movss	DWORD PTR _clgame[eax+122800], xmm0

; 2126 : 
; 2127 : 	// add to roll
; 2128 : 	clgame.shake.applied_angle = clgame.shake.angle * fraction;

	movss	xmm0, DWORD PTR _clgame+122796
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR _clgame+122812, xmm0

; 2129 : 
; 2130 : 	// drop amplitude a bit, less for higher frequency shakes
; 2131 : 	localAmp = clgame.shake.amplitude * ( host.frametime / ( clgame.shake.duration * clgame.shake.frequency ));

	cvtss2sd xmm0, DWORD PTR _clgame+122772
	movss	xmm1, DWORD PTR _clgame+122768
	mulss	xmm1, DWORD PTR _clgame+122776
	cvtss2sd xmm1, xmm1
	movsd	xmm2, QWORD PTR _host+1448
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _localAmp$[ebp], xmm0

; 2132 : 	clgame.shake.amplitude -= localAmp;

	movss	xmm0, DWORD PTR _clgame+122772
	subss	xmm0, DWORD PTR _localAmp$[ebp]
	movss	DWORD PTR _clgame+122772, xmm0
$LN1@pfnCalcSha:

; 2133 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCalcShake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_pfnGetClientTime PROC

; 2069 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2070 : 	return cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]

; 2071 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetClientTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetViewModel PROC

; 2058 : {

	push	ebp
	mov	ebp, esp

; 2059 : 	return &clgame.viewent;

	mov	eax, OFFSET _clgame+149800

; 2060 : }

	pop	ebp
	ret	0
_pfnGetViewModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv71 = -4						; size = 4
_pfnIsNoClipping PROC

; 2047 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2048 : 	return ( cl.frames[cl.parsecountmod].playerstate[cl.playernum].movetype == MOVETYPE_NOCLIP );

	imul	eax, DWORD PTR _cl+12, 17304
	imul	ecx, DWORD PTR _cl+1568828, 340
	cmp	DWORD PTR _cl[eax+ecx+684], 8
	jne	SHORT $LN3@pfnIsNoCli
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@pfnIsNoCli
$LN3@pfnIsNoCli:
	mov	DWORD PTR tv71[ebp], 0
$LN4@pfnIsNoCli:
	mov	eax, DWORD PTR tv71[ebp]

; 2049 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsNoClipping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_curpos$ = -8						; size = 8
_mx$ = 8						; size = 4
_my$ = 12						; size = 4
_pfnGetMousePosition PROC

; 2030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2031 : 	POINT	curpos;
; 2032 : 
; 2033 : 	GetCursorPos( &curpos );

	lea	eax, DWORD PTR _curpos$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 2034 : 	ScreenToClient( host.hWnd, &curpos );

	lea	ecx, DWORD PTR _curpos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+34332
	push	edx
	call	DWORD PTR __imp__ScreenToClient@8

; 2035 : 
; 2036 : 	if( mx ) *mx = curpos.x;

	cmp	DWORD PTR _mx$[ebp], 0
	je	SHORT $LN2@pfnGetMous
	mov	eax, DWORD PTR _mx$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnGetMous:

; 2037 : 	if( my ) *my = curpos.y;

	cmp	DWORD PTR _my$[ebp], 0
	je	SHORT $LN1@pfnGetMous
	mov	edx, DWORD PTR _my$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp+4]
	mov	DWORD PTR [edx], eax
$LN1@pfnGetMous:

; 2038 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetMousePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetClientMaxspeed PROC

; 2019 : {

	push	ebp
	mov	ebp, esp

; 2020 : 	return cl.local.maxspeed;

	fld	DWORD PTR _cl+1568588

; 2021 : }

	pop	ebp
	ret	0
_pfnGetClientMaxspeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_key$ = 8						; size = 4
_pfnServerInfo_ValueForKey PROC

; 2007 : {

	push	ebp
	mov	ebp, esp

; 2008 : 	return Info_ValueForKey( cl.serverinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _cl+1525868
	call	_Info_ValueForKey
	add	esp, 8

; 2009 : }

	pop	ebp
	ret	0
_pfnServerInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_key$ = 8						; size = 4
_pfnPhysInfo_ValueForKey PROC

; 1996 : {

	push	ebp
	mov	ebp, esp

; 1997 : 	return Info_ValueForKey( cls.physinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _cls+6860
	call	_Info_ValueForKey
	add	esp, 8

; 1998 : }

	pop	ebp
	ret	0
_pfnPhysInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_angles$ = 8						; size = 4
_pfnSetViewAngles PROC

; 1985 : {

	push	ebp
	mov	ebp, esp

; 1986 : 	if( angles ) VectorCopy( angles, cl.viewangles );

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN2@pfnSetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _cl[eax+1568612], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _cl[eax+1568612], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _cl[ecx+1568612], eax
$LN2@pfnSetView:

; 1987 : }

	pop	ebp
	ret	0
_pfnSetViewAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_angles$ = 8						; size = 4
_pfnGetViewAngles PROC

; 1973 : {

	push	ebp
	mov	ebp, esp

; 1974 : 	if( angles ) VectorCopy( cl.viewangles, angles );

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN2@pfnGetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR _cl[ecx+1568612]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR _cl[edx+1568612]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR _cl[eax+1568612]
	mov	DWORD PTR [edx+ecx], eax
$LN2@pfnGetView:

; 1975 : }

	pop	ebp
	ret	0
_pfnGetViewAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetWindowCenterY PROC

; 1961 : {

	push	ebp
	mov	ebp, esp

; 1962 : 	return host.window_center_y;

	mov	eax, DWORD PTR _host+34756

; 1963 : }

	pop	ebp
	ret	0
_pfnGetWindowCenterY ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pfnGetWindowCenterX PROC

; 1950 : {

	push	ebp
	mov	ebp, esp

; 1951 : 	return host.window_center_x;

	mov	eax, DWORD PTR _host+34752

; 1952 : }

	pop	ebp
	ret	0
_pfnGetWindowCenterX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_string$ = 8						; size = 4
_pfnCenterPrint PROC

; 1939 : {

	push	ebp
	mov	ebp, esp

; 1940 : 	CL_CenterPrint( string, 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_CL_CenterPrint
	add	esp, 8

; 1941 : }

	pop	ebp
	ret	0
_pfnCenterPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_string$ = 8						; size = 4
_pfnConsolePrint PROC

; 1926 : {

	push	ebp
	mov	ebp, esp

; 1927 : 	Con_Printf( "%s", string );

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	push	OFFSET $SG147116
	call	_Con_Printf
	add	esp, 8

; 1928 : }

	pop	ebp
	ret	0
_pfnConsolePrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_r$ = 20						; size = 4
_g$ = 24						; size = 4
_b$ = 28						; size = 4
_pfnDrawCharacter PROC

; 1845 : {

	push	ebp
	mov	ebp, esp

; 1846 : 	if( !cls.creditsFont.valid )

	cmp	DWORD PTR _cls+291748, 0
	jne	SHORT $LN2@pfnDrawCha

; 1847 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDrawCha
$LN2@pfnDrawCha:

; 1848 : 
; 1849 : 	number &= 255;

	mov	eax, DWORD PTR _number$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _number$[ebp], eax

; 1850 : 
; 1851 : 	if( number < 32 ) return 0;

	cmp	DWORD PTR _number$[ebp], 32		; 00000020H
	jge	SHORT $LN3@pfnDrawCha
	xor	eax, eax
	jmp	SHORT $LN1@pfnDrawCha
$LN3@pfnDrawCha:

; 1852 : 	if( y < -clgame.scrInfo.iCharHeight )

	mov	ecx, DWORD PTR _clgame+124900
	neg	ecx
	cmp	DWORD PTR _y$[ebp], ecx
	jge	SHORT $LN4@pfnDrawCha

; 1853 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnDrawCha
$LN4@pfnDrawCha:

; 1854 : 
; 1855 : 	clgame.ds.adjust_size = true;

	mov	DWORD PTR _clgame+122680, 1

; 1856 : 	pfnPIC_Set( cls.creditsFont.hFontTexture, r, g, b, 255 );

	push	255					; 000000ffH
	mov	edx, DWORD PTR _b$[ebp]
	push	edx
	mov	eax, DWORD PTR _g$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+287384
	push	edx
	call	_pfnPIC_Set
	add	esp, 20					; 00000014H

; 1857 : 	pfnPIC_DrawAdditive( x, y, -1, -1, &cls.creditsFont.fontRc[number] );

	mov	eax, DWORD PTR _number$[ebp]
	shl	eax, 4
	add	eax, OFFSET _cls+287388
	push	eax
	push	-1
	push	-1
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_pfnPIC_DrawAdditive
	add	esp, 20					; 00000014H

; 1858 : 	clgame.ds.adjust_size = false;

	mov	DWORD PTR _clgame+122680, 0

; 1859 : 
; 1860 : 	return clgame.scrInfo.charWidths[number];

	mov	eax, DWORD PTR _number$[ebp]
	movsx	eax, WORD PTR _clgame[eax*2+124904]
$LN1@pfnDrawCha:

; 1861 : }

	pop	ebp
	ret	0
_pfnDrawCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_hSound$ = -12						; size = 4
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_iSound$ = 8						; size = 4
_volume$ = 12						; size = 4
_pfnPlaySoundByIndex PROC

; 1799 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1800 : 	int hSound;
; 1801 : 
; 1802 : 	// make sure what we in-bounds
; 1803 : 	iSound = bound( 0, iSound, MAX_SOUNDS );

	cmp	DWORD PTR _iSound$[ebp], 0
	jl	SHORT $LN6@pfnPlaySou
	cmp	DWORD PTR _iSound$[ebp], 2048		; 00000800H
	jge	SHORT $LN4@pfnPlaySou
	mov	eax, DWORD PTR _iSound$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN5@pfnPlaySou
$LN4@pfnPlaySou:
	mov	DWORD PTR tv66[ebp], 2048		; 00000800H
$LN5@pfnPlaySou:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN7@pfnPlaySou
$LN6@pfnPlaySou:
	mov	DWORD PTR tv67[ebp], 0
$LN7@pfnPlaySou:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _iSound$[ebp], edx

; 1804 : 	hSound = cl.sound_index[iSound];

	mov	eax, DWORD PTR _iSound$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+2681456]
	mov	DWORD PTR _hSound$[ebp], ecx

; 1805 : 	if( !hSound ) return;

	cmp	DWORD PTR _hSound$[ebp], 0
	jne	SHORT $LN2@pfnPlaySou
	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 1806 : 
; 1807 : 	S_StartSound( NULL, cl.viewentity, CHAN_ITEM, hSound, volume, ATTN_NORM, PITCH_NORM, SND_STOP_LOOPING );

	push	1024					; 00000400H
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _hSound$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _cl+1568608
	push	eax
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@pfnPlaySou:

; 1808 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySoundByIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_hSound$ = -4						; size = 4
_szSound$ = 8						; size = 4
_volume$ = 12						; size = 4
_pfnPlaySoundByName PROC

; 1787 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1788 : 	int hSound = S_RegisterSound( szSound );

	mov	eax, DWORD PTR _szSound$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _hSound$[ebp], eax

; 1789 : 	S_StartSound( NULL, cl.viewentity, CHAN_ITEM, hSound, volume, ATTN_NORM, PITCH_NORM, SND_STOP_LOOPING );

	push	1024					; 00000400H
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _hSound$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _cl+1568608
	push	edx
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 1790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySoundByName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv80 = -8						; size = 4
_player$ = -4						; size = 4
_ent_num$ = 8						; size = 4
_pinfo$ = 12						; size = 4
_pfnGetPlayerInfo PROC

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1758 : 	player_info_t	*player;
; 1759 : 
; 1760 : 	ent_num -= 1; // player list if offset by 1 from ents

	mov	eax, DWORD PTR _ent_num$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ent_num$[ebp], eax

; 1761 : 
; 1762 : 	if( ent_num >= cl.maxclients || ent_num < 0 || !cl.players[ent_num].name[0] )

	mov	ecx, DWORD PTR _ent_num$[ebp]
	cmp	ecx, DWORD PTR _cl+1568832
	jge	SHORT $LN3@pfnGetPlay
	cmp	DWORD PTR _ent_num$[ebp], 0
	jl	SHORT $LN3@pfnGetPlay
	imul	edx, DWORD PTR _ent_num$[ebp], 584
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _cl[edx+ecx+1543408]
	test	edx, edx
	jne	SHORT $LN2@pfnGetPlay
$LN3@pfnGetPlay:

; 1763 : 	{
; 1764 : 		pinfo->name = NULL;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	DWORD PTR [eax], 0

; 1765 : 		pinfo->thisplayer = false;

	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	BYTE PTR [ecx+6], 0

; 1766 : 		return;

	jmp	$LN1@pfnGetPlay
$LN2@pfnGetPlay:

; 1767 : 	}
; 1768 : 
; 1769 : 	player = &cl.players[ent_num];

	imul	edx, DWORD PTR _ent_num$[ebp], 584
	add	edx, OFFSET _cl+1543148
	mov	DWORD PTR _player$[ebp], edx

; 1770 : 	pinfo->thisplayer = ( ent_num == cl.playernum ) ? true : false;

	mov	eax, DWORD PTR _ent_num$[ebp]
	cmp	eax, DWORD PTR _cl+1568828
	jne	SHORT $LN5@pfnGetPlay
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@pfnGetPlay
$LN5@pfnGetPlay:
	mov	DWORD PTR tv80[ebp], 0
$LN6@pfnGetPlay:
	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	dl, BYTE PTR tv80[ebp]
	mov	BYTE PTR [ecx+6], dl

; 1771 : 	pinfo->name = player->name;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 260				; 00000104H
	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	DWORD PTR [ecx], eax

; 1772 : 	pinfo->model = player->model;

	mov	edx, DWORD PTR _player$[ebp]
	add	edx, 304				; 00000130H
	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1773 : 	pinfo->spectator = player->spectator;		

	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	edx, DWORD PTR _player$[ebp]
	mov	al, BYTE PTR [edx+292]
	mov	BYTE PTR [ecx+7], al

; 1774 : 	pinfo->ping = player->ping;

	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	edx, DWORD PTR _player$[ebp]
	mov	ax, WORD PTR [edx+296]
	mov	WORD PTR [ecx+4], ax

; 1775 : 	pinfo->packetloss = player->packet_loss;

	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	edx, DWORD PTR _player$[ebp]
	mov	al, BYTE PTR [edx+300]
	mov	BYTE PTR [ecx+8], al

; 1776 : 	pinfo->topcolor = player->topcolor;

	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	edx, DWORD PTR _player$[ebp]
	mov	ax, WORD PTR [edx+368]
	mov	WORD PTR [ecx+16], ax

; 1777 : 	pinfo->bottomcolor = player->bottomcolor;

	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	edx, DWORD PTR _player$[ebp]
	mov	ax, WORD PTR [edx+372]
	mov	WORD PTR [ecx+18], ax
$LN1@pfnGetPlay:

; 1778 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_szCmdString$ = 8					; size = 4
_pfnClientCmd PROC

; 1732 : {

	push	ebp
	mov	ebp, esp

; 1733 : 	if( !COM_CheckString( szCmdString ))

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnClientC

; 1734 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnClientC
$LN2@pfnClientC:

; 1735 : 
; 1736 : 	if( cls.initialized )

	cmp	DWORD PTR _cls+4, 0
	je	SHORT $LN3@pfnClientC

; 1737 : 	{
; 1738 : 		Cbuf_AddText( szCmdString );

	mov	ecx, DWORD PTR _szCmdString$[ebp]
	push	ecx
	call	_Cbuf_AddText
	add	esp, 4

; 1739 : 		Cbuf_AddText( "\n" );

	push	OFFSET $SG147023
	call	_Cbuf_AddText
	add	esp, 4

; 1740 : 	}

	jmp	SHORT $LN4@pfnClientC
$LN3@pfnClientC:

; 1741 : 	else
; 1742 : 	{
; 1743 : 		// will exec later
; 1744 : 		Q_strncat( host.deferred_cmd, va( "%s\n", szCmdString ), sizeof( host.deferred_cmd )); 

	push	128					; 00000080H
	mov	edx, DWORD PTR _szCmdString$[ebp]
	push	edx
	push	OFFSET $SG147024
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET _host+756
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN4@pfnClientC:

; 1745 : 	}
; 1746 : 
; 1747 : 	return 1;

	mov	eax, 1
$LN1@pfnClientC:

; 1748 : }

	pop	ebp
	ret	0
_pfnClientCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_buf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_szCmdString$ = 8					; size = 4
_pfnServerCmd PROC

; 1712 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1713 : 	string	buf;
; 1714 : 
; 1715 : 	if( !COM_CheckString( szCmdString ))

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnServerC

; 1716 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnServerC
$LN2@pfnServerC:

; 1717 : 
; 1718 : 	// just like the client typed "cmd xxxxx" at the console
; 1719 : 	Q_snprintf( buf, sizeof( buf ) - 1, "cmd %s\n", szCmdString );

	mov	ecx, DWORD PTR _szCmdString$[ebp]
	push	ecx
	push	OFFSET $SG147015
	push	255					; 000000ffH
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1720 : 	Cbuf_AddText( buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 1721 : 
; 1722 : 	return 1;

	mov	eax, 1
$LN1@pfnServerC:

; 1723 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_pfn$ = 12						; size = 4
_pfnHookUserMsg PROC

; 1678 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1679 : 	int	i;
; 1680 : 
; 1681 : 	// ignore blank names or invalid callbacks
; 1682 : 	if( !pszName || !*pszName || !pfn )

	cmp	DWORD PTR _pszName$[ebp], 0
	je	SHORT $LN6@pfnHookUse
	mov	eax, DWORD PTR _pszName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@pfnHookUse
	cmp	DWORD PTR _pfn$[ebp], 0
	jne	SHORT $LN5@pfnHookUse
$LN6@pfnHookUse:

; 1683 : 		return 0;	

	xor	eax, eax
	jmp	$LN1@pfnHookUse
$LN5@pfnHookUse:

; 1684 : 
; 1685 : 	for( i = 0; i < MAX_USER_MESSAGES && clgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnHookUse
$LN2@pfnHookUse:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@pfnHookUse:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@pfnHookUse
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _clgame[eax+edx+1332]
	test	eax, eax
	je	SHORT $LN3@pfnHookUse

; 1686 : 	{
; 1687 : 		// see if already hooked
; 1688 : 		if( !Q_stricmp( clgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _pszName$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _clgame+1332
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@pfnHookUse

; 1689 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@pfnHookUse
$LN7@pfnHookUse:

; 1690 : 	}

	jmp	SHORT $LN2@pfnHookUse
$LN3@pfnHookUse:

; 1691 : 
; 1692 : 	if( i == MAX_USER_MESSAGES ) 

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN8@pfnHookUse

; 1693 : 	{
; 1694 : 		Host_Error( "HookUserMsg: MAX_USER_MESSAGES hit!\n" );

	push	OFFSET $SG147008
	call	_Host_Error
	add	esp, 4

; 1695 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnHookUse
$LN8@pfnHookUse:

; 1696 : 	}
; 1697 : 
; 1698 : 	// hook new message
; 1699 : 	Q_strncpy( clgame.msg[i].name, pszName, sizeof( clgame.msg[i].name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1332
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1700 : 	clgame.msg[i].func = pfn;

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _pfn$[ebp]
	mov	DWORD PTR _clgame[edx+1372], eax

; 1701 : 
; 1702 : 	return 1;

	mov	eax, 1
$LN1@pfnHookUse:

; 1703 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHookUserMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_hspr$ = 8						; size = 4
_rc$ = 12						; size = 16
_r$ = 28						; size = 4
_g$ = 32						; size = 4
_b$ = 36						; size = 4
_pfnSetCrosshair PROC

; 1662 : {

	push	ebp
	mov	ebp, esp

; 1663 : 	clgame.ds.rgbaCrosshair[0] = (byte)r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _clgame[ecx+122736], dl

; 1664 : 	clgame.ds.rgbaCrosshair[1] = (byte)g;

	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _clgame[eax+122736], cl

; 1665 : 	clgame.ds.rgbaCrosshair[2] = (byte)b;

	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR _clgame[edx+122736], al

; 1666 : 	clgame.ds.rgbaCrosshair[3] = (byte)0xFF;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _clgame[edx+122736], 255	; 000000ffH

; 1667 : 	clgame.ds.pCrosshair = CL_GetSpritePointer( hspr );

	mov	eax, DWORD PTR _hspr$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	mov	DWORD PTR _clgame+122716, eax

; 1668 : 	clgame.ds.rcCrosshair = rc;

	mov	ecx, DWORD PTR _rc$[ebp]
	mov	DWORD PTR _clgame+122720, ecx
	mov	edx, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR _clgame+122724, edx
	mov	eax, DWORD PTR _rc$[ebp+8]
	mov	DWORD PTR _clgame+122728, eax
	mov	ecx, DWORD PTR _rc$[ebp+12]
	mov	DWORD PTR _clgame+122732, ecx

; 1669 : }

	pop	ebp
	ret	0
_pfnSetCrosshair ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pscrinfo$ = 8						; size = 4
_pfnGetScreenInfo PROC

; 1615 : {

	push	ebp
	mov	ebp, esp

; 1616 : 	// setup screen info
; 1617 : 	clgame.scrInfo.iSize = sizeof( clgame.scrInfo );

	mov	DWORD PTR _clgame+124884, 532		; 00000214H

; 1618 : 	clgame.scrInfo.iFlags = SCRINFO_SCREENFLASH;

	mov	DWORD PTR _clgame+124896, 1

; 1619 : 
; 1620 : 	if( Cvar_VariableInteger( "hud_scale" ))

	push	OFFSET $SG146973
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@pfnGetScre

; 1621 : 	{
; 1622 : 		if( glState.width < 640 )

	cmp	DWORD PTR _glState, 640			; 00000280H
	jge	SHORT $LN4@pfnGetScre

; 1623 : 		{
; 1624 : 			// virtual screen space 320x200
; 1625 : 			clgame.scrInfo.iWidth = 320;

	mov	DWORD PTR _clgame+124888, 320		; 00000140H

; 1626 : 			clgame.scrInfo.iHeight = 200;

	mov	DWORD PTR _clgame+124892, 200		; 000000c8H

; 1627 : 		}

	jmp	SHORT $LN5@pfnGetScre
$LN4@pfnGetScre:

; 1628 : 		else
; 1629 : 		{
; 1630 : 			// virtual screen space 640x480
; 1631 : 			clgame.scrInfo.iWidth = 640;

	mov	DWORD PTR _clgame+124888, 640		; 00000280H

; 1632 : 			clgame.scrInfo.iHeight = 480;

	mov	DWORD PTR _clgame+124892, 480		; 000001e0H
$LN5@pfnGetScre:

; 1633 : 		}
; 1634 : 		clgame.scrInfo.iFlags |= SCRINFO_STRETCHED;

	mov	eax, DWORD PTR _clgame+124896
	or	eax, 2
	mov	DWORD PTR _clgame+124896, eax

; 1635 : 	}

	jmp	SHORT $LN3@pfnGetScre
$LN2@pfnGetScre:

; 1636 : 	else
; 1637 : 	{
; 1638 : 		clgame.scrInfo.iWidth = glState.width;

	mov	ecx, DWORD PTR _glState
	mov	DWORD PTR _clgame+124888, ecx

; 1639 : 		clgame.scrInfo.iHeight = glState.height;

	mov	edx, DWORD PTR _glState+4
	mov	DWORD PTR _clgame+124892, edx

; 1640 : 		clgame.scrInfo.iFlags &= ~SCRINFO_STRETCHED;

	mov	eax, DWORD PTR _clgame+124896
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _clgame+124896, eax
$LN3@pfnGetScre:

; 1641 : 	}
; 1642 : 
; 1643 : 	if( !pscrinfo ) return 0;

	cmp	DWORD PTR _pscrinfo$[ebp], 0
	jne	SHORT $LN6@pfnGetScre
	xor	eax, eax
	jmp	SHORT $LN1@pfnGetScre
$LN6@pfnGetScre:

; 1644 : 
; 1645 : 	if( pscrinfo->iSize != clgame.scrInfo.iSize )

	mov	ecx, DWORD PTR _pscrinfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _clgame+124884
	je	SHORT $LN7@pfnGetScre

; 1646 : 		clgame.scrInfo.iSize = pscrinfo->iSize;

	mov	eax, DWORD PTR _pscrinfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _clgame+124884, ecx
$LN7@pfnGetScre:

; 1647 : 
; 1648 : 	// copy screeninfo out
; 1649 : 	memcpy( pscrinfo, &clgame.scrInfo, clgame.scrInfo.iSize );

	mov	edx, DWORD PTR _clgame+124884
	push	edx
	push	OFFSET _clgame+124884
	mov	eax, DWORD PTR _pscrinfo$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1650 : 
; 1651 : 	return 1;

	mov	eax, 1
$LN1@pfnGetScre:

; 1652 : }

	pop	ebp
	ret	0
_pfnGetScreenInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_afile$ = -284						; size = 4
_numSprites$ = -280					; size = 4
_slot$ = -276						; size = 4
_index$ = -272						; size = 4
_pfile$ = -268						; size = 4
_pEntry$ = -264						; size = 4
_token$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_psz$ = 8						; size = 4
_piCount$ = 12						; size = 4
_pfnSPR_GetList PROC

; 1492 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1493 : 	cached_spritelist_t	*pEntry = &clgame.sprlist[0];

	mov	eax, 72					; 00000048H
	imul	ecx, eax, 0
	add	ecx, OFFSET _clgame+126228
	mov	DWORD PTR _pEntry$[ebp], ecx

; 1494 : 	int		slot, index, numSprites = 0;

	mov	DWORD PTR _numSprites$[ebp], 0

; 1495 : 	char		*afile, *pfile;
; 1496 : 	string		token;
; 1497 : 
; 1498 : 	if( piCount ) *piCount = 0;

	cmp	DWORD PTR _piCount$[ebp], 0
	je	SHORT $LN8@pfnSPR_Get
	mov	edx, DWORD PTR _piCount$[ebp]
	mov	DWORD PTR [edx], 0
$LN8@pfnSPR_Get:

; 1499 : 
; 1500 : 	// see if already in list
; 1501 : 	// NOTE: client.dll is cache hud.txt but reparse weapon lists again and again
; 1502 : 	// obviously there a memory leak by-design. Cache the sprite lists to prevent it
; 1503 : 	for( slot = 0; slot < MAX_CLIENT_SPRITES && pEntry->szListName[0]; slot++ )

	mov	DWORD PTR _slot$[ebp], 0
	jmp	SHORT $LN4@pfnSPR_Get
$LN2@pfnSPR_Get:
	mov	eax, DWORD PTR _slot$[ebp]
	add	eax, 1
	mov	DWORD PTR _slot$[ebp], eax
$LN4@pfnSPR_Get:
	cmp	DWORD PTR _slot$[ebp], 256		; 00000100H
	jge	SHORT $LN3@pfnSPR_Get
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pEntry$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN3@pfnSPR_Get

; 1504 : 	{
; 1505 : 		pEntry = &clgame.sprlist[slot];

	imul	edx, DWORD PTR _slot$[ebp], 72
	add	edx, OFFSET _clgame+126228
	mov	DWORD PTR _pEntry$[ebp], edx

; 1506 : 
; 1507 : 		if( !Q_stricmp( pEntry->szListName, psz ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntry$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@pfnSPR_Get

; 1508 : 		{
; 1509 : 			if( piCount ) *piCount = pEntry->count;

	cmp	DWORD PTR _piCount$[ebp], 0
	je	SHORT $LN10@pfnSPR_Get
	mov	edx, DWORD PTR _piCount$[ebp]
	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx], ecx
$LN10@pfnSPR_Get:

; 1510 : 			return pEntry->pList;

	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	jmp	$LN1@pfnSPR_Get
$LN9@pfnSPR_Get:

; 1511 : 		}
; 1512 : 	}

	jmp	$LN2@pfnSPR_Get
$LN3@pfnSPR_Get:

; 1513 : 
; 1514 : 	if( slot == MAX_CLIENT_SPRITES )

	cmp	DWORD PTR _slot$[ebp], 256		; 00000100H
	jne	SHORT $LN11@pfnSPR_Get

; 1515 : 	{
; 1516 : 		Con_Printf( S_ERROR "SPR_GetList: overflow cache!\n" );

	push	OFFSET $SG146937
	call	_Con_Printf
	add	esp, 4

; 1517 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@pfnSPR_Get
$LN11@pfnSPR_Get:

; 1518 :           }
; 1519 : 
; 1520 : 	if( !clgame.itemspath[0] )	// typically it's sprites\*.txt

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _clgame[ecx+744]
	test	edx, edx
	jne	SHORT $LN12@pfnSPR_Get

; 1521 : 		COM_ExtractFilePath( psz, clgame.itemspath );

	push	OFFSET _clgame+744
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_COM_ExtractFilePath
	add	esp, 8
$LN12@pfnSPR_Get:

; 1522 : 
; 1523 : 	afile = FS_LoadFile( psz, NULL, false );

	push	0
	push	0
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _afile$[ebp], eax

; 1524 : 	if( !afile ) return NULL;

	cmp	DWORD PTR _afile$[ebp], 0
	jne	SHORT $LN13@pfnSPR_Get
	xor	eax, eax
	jmp	$LN1@pfnSPR_Get
$LN13@pfnSPR_Get:

; 1525 : 
; 1526 : 	pfile = afile;

	mov	edx, DWORD PTR _afile$[ebp]
	mov	DWORD PTR _pfile$[ebp], edx

; 1527 : 	pfile = COM_ParseFile( pfile, token );          

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1528 : 	numSprites = Q_atoi( token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _numSprites$[ebp], eax

; 1529 : 
; 1530 : 	Q_strncpy( pEntry->szListName, psz, sizeof( pEntry->szListName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntry$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1531 : 
; 1532 : 	// name, res, pic, x, y, w, h
; 1533 : 	pEntry->pList = Mem_Calloc( cls.mempool, sizeof( client_sprite_t ) * numSprites );

	push	1533					; 000005fdH
	push	OFFSET $SG146940
	push	1
	imul	edx, DWORD PTR _numSprites$[ebp], 152
	push	edx
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1534 : 
; 1535 : 	for( index = 0; index < numSprites; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN7@pfnSPR_Get
$LN5@pfnSPR_Get:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN7@pfnSPR_Get:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _numSprites$[ebp]
	jge	$LN6@pfnSPR_Get

; 1536 : 	{
; 1537 : 		if(( pfile = COM_ParseFile( pfile, token )) == NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN14@pfnSPR_Get

; 1538 : 			break;

	jmp	$LN6@pfnSPR_Get
$LN14@pfnSPR_Get:

; 1539 : 
; 1540 : 		Q_strncpy( pEntry->pList[index].szName, token, sizeof( pEntry->pList[0].szName ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	add	eax, ecx
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1541 : 
; 1542 : 		// read resolution
; 1543 : 		pfile = COM_ParseFile( pfile, token );

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1544 : 		pEntry->pList[index].iRes = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+132], eax

; 1545 : 
; 1546 : 		// read spritename
; 1547 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1548 : 		Q_strncpy( pEntry->pList[index].szSprite, token, sizeof( pEntry->pList[0].szSprite ));

	push	64					; 00000040H
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	imul	eax, DWORD PTR _index$[ebp], 152
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	lea	eax, DWORD PTR [edx+eax+64]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1549 : 
; 1550 : 		// parse rectangle
; 1551 : 		pfile = COM_ParseFile( pfile, token );

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1552 : 		pEntry->pList[index].rc.left = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+136], eax

; 1553 : 
; 1554 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1555 : 		pEntry->pList[index].rc.top = Q_atoi( token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+144], eax

; 1556 : 
; 1557 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1558 : 		pEntry->pList[index].rc.right = pEntry->pList[index].rc.left + Q_atoi( token );

	imul	esi, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edi, DWORD PTR [edx+64]
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	add	eax, DWORD PTR [edi+esi+136]
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+140], eax

; 1559 : 
; 1560 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1561 : 		pEntry->pList[index].rc.bottom = pEntry->pList[index].rc.top + Q_atoi( token );

	imul	esi, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edi, DWORD PTR [edx+64]
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	add	eax, DWORD PTR [edi+esi+144]
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+148], eax

; 1562 : 
; 1563 : 		pEntry->count++;

	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1564 : 	}

	jmp	$LN5@pfnSPR_Get
$LN6@pfnSPR_Get:

; 1565 : 
; 1566 : 	if( index < numSprites )

	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _numSprites$[ebp]
	jge	SHORT $LN15@pfnSPR_Get

; 1567 : 		Con_DPrintf( S_WARN "unexpected end of %s (%i should be %i)\n", psz, numSprites, index );

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _numSprites$[ebp]
	push	edx
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	push	OFFSET $SG146943
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN15@pfnSPR_Get:

; 1568 : 	if( piCount ) *piCount = pEntry->count;

	cmp	DWORD PTR _piCount$[ebp], 0
	je	SHORT $LN16@pfnSPR_Get
	mov	ecx, DWORD PTR _piCount$[ebp]
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx], eax
$LN16@pfnSPR_Get:

; 1569 : 	Mem_Free( afile );

	push	1569					; 00000621H
	push	OFFSET $SG146945
	mov	ecx, DWORD PTR _afile$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1570 : 
; 1571 : 	return pEntry->pList;

	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+64]
$LN1@pfnSPR_Get:

; 1572 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_GetList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_pfnSPR_DrawAdditive PROC

; 1475 : {

	push	ebp
	mov	ebp, esp

; 1476 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1477 : 	pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 1478 : 
; 1479 : 	SPR_DrawGeneric( frame, x, y, -1, -1, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGeneric
	add	esp, 24					; 00000018H

; 1480 : 
; 1481 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1482 : }

	pop	ebp
	ret	0
_pfnSPR_DrawAdditive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_pfnSPR_Draw PROC

; 1444 : {

	push	ebp
	mov	ebp, esp

; 1445 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1446 : 
; 1447 : 	SPR_DrawGeneric( frame, x, y, -1, -1, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGeneric
	add	esp, 24					; 00000018H

; 1448 : }

	pop	ebp
	ret	0
_pfnSPR_Draw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv85 = -24						; size = 4
tv84 = -20						; size = 4
tv78 = -16						; size = 4
tv77 = -12						; size = 4
tv71 = -8						; size = 4
tv70 = -4						; size = 4
_hPic$ = 8						; size = 4
_r$ = 12						; size = 4
_g$ = 16						; size = 4
_b$ = 20						; size = 4
_pfnSPR_Set PROC

; 1429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1430 : 	clgame.ds.pSprite = CL_GetSpritePointer( hPic );

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	mov	DWORD PTR _clgame+122656, eax

; 1431 : 	clgame.ds.spriteColor[0] = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@pfnSPR_Set
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@pfnSPR_Set
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@pfnSPR_Set
$LN3@pfnSPR_Set:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN4@pfnSPR_Set:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN6@pfnSPR_Set
$LN5@pfnSPR_Set:
	mov	DWORD PTR tv71[ebp], 0
$LN6@pfnSPR_Set:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR tv71[ebp]
	mov	BYTE PTR _clgame[ecx+122696], dl

; 1432 : 	clgame.ds.spriteColor[1] = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@pfnSPR_Set
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@pfnSPR_Set
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN8@pfnSPR_Set
$LN7@pfnSPR_Set:
	mov	DWORD PTR tv77[ebp], 255		; 000000ffH
$LN8@pfnSPR_Set:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN10@pfnSPR_Set
$LN9@pfnSPR_Set:
	mov	DWORD PTR tv78[ebp], 0
$LN10@pfnSPR_Set:
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR tv78[ebp]
	mov	BYTE PTR _clgame[edx+122696], al

; 1433 : 	clgame.ds.spriteColor[2] = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@pfnSPR_Set
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@pfnSPR_Set
	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN12@pfnSPR_Set
$LN11@pfnSPR_Set:
	mov	DWORD PTR tv84[ebp], 255		; 000000ffH
$LN12@pfnSPR_Set:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv85[ebp], edx
	jmp	SHORT $LN14@pfnSPR_Set
$LN13@pfnSPR_Set:
	mov	DWORD PTR tv85[ebp], 0
$LN14@pfnSPR_Set:
	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR tv85[ebp]
	mov	BYTE PTR _clgame[eax+122696], cl

; 1434 : 	clgame.ds.spriteColor[3] = 255;

	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _clgame[eax+122696], 255	; 000000ffH

; 1435 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Set ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_sprWidth$ = -4						; size = 4
_hPic$ = 8						; size = 4
_frame$ = 12						; size = 4
_pfnSPR_Width PROC

; 1414 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1415 : 	int	sprWidth;
; 1416 : 
; 1417 : 	R_GetSpriteParms( &sprWidth, NULL, NULL, frame, CL_GetSpritePointer( hPic ));

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _sprWidth$[ebp]
	push	edx
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 1418 : 
; 1419 : 	return sprWidth;

	mov	eax, DWORD PTR _sprWidth$[ebp]

; 1420 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Width ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_sprHeight$ = -4					; size = 4
_hPic$ = 8						; size = 4
_frame$ = 12						; size = 4
_pfnSPR_Height PROC

; 1399 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1400 : 	int	sprHeight;
; 1401 : 
; 1402 : 	R_GetSpriteParms( NULL, &sprHeight, NULL, frame, CL_GetSpritePointer( hPic ));

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _sprHeight$[ebp]
	push	edx
	push	0
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 1403 : 
; 1404 : 	return sprHeight;

	mov	eax, DWORD PTR _sprHeight$[ebp]

; 1405 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Height ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_numFrames$ = -4					; size = 4
_hPic$ = 8						; size = 4
_pfnSPR_Frames PROC

; 1384 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1385 : 	int	numFrames;
; 1386 : 
; 1387 : 	R_GetSpriteParms( NULL, NULL, &numFrames, 0, CL_GetSpritePointer( hPic ));

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	push	eax
	push	0
	lea	ecx, DWORD PTR _numFrames$[ebp]
	push	ecx
	push	0
	push	0
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 1388 : 
; 1389 : 	return numFrames;

	mov	eax, DWORD PTR _numFrames$[ebp]

; 1390 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Frames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_type$1 = -12						; size = 4
tv73 = -8						; size = 4
_mod$ = -4						; size = 4
_hSprite$ = 8						; size = 4
_CL_GetSpritePointer PROC

; 1353 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1354 : 	model_t	*mod;
; 1355 : 
; 1356 : 	if( hSprite <= 0 || hSprite >= MAX_CLIENT_SPRITES )

	cmp	DWORD PTR _hSprite$[ebp], 0
	jle	SHORT $LN3@CL_GetSpri
	cmp	DWORD PTR _hSprite$[ebp], 256		; 00000100H
	jl	SHORT $LN2@CL_GetSpri
$LN3@CL_GetSpri:

; 1357 : 		return NULL; // bad image

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetSpri
$LN2@CL_GetSpri:

; 1358 : 	mod = &clgame.sprites[hSprite];

	imul	eax, DWORD PTR _hSprite$[ebp], 392
	add	eax, OFFSET _clgame+22288
	mov	DWORD PTR _mod$[ebp], eax

; 1359 : 
; 1360 : 	if( mod->needload == NL_NEEDS_LOADED )

	mov	ecx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [ecx+64], 1
	jne	SHORT $LN4@CL_GetSpri

; 1361 : 	{
; 1362 : 		int	type = FBitSet( mod->flags, MODEL_CLIENT ) ? SPR_HUDSPRITE : SPR_MAPSPRITE;

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN8@CL_GetSpri
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN9@CL_GetSpri
$LN8@CL_GetSpri:
	mov	DWORD PTR tv73[ebp], 2
$LN9@CL_GetSpri:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _type$1[ebp], ecx

; 1363 : 
; 1364 : 		if( CL_LoadHudSprite( mod->name, mod, type, mod->numtexinfo ))

	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+168]
	push	eax
	mov	ecx, DWORD PTR _type$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_CL_LoadHudSprite
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@CL_GetSpri

; 1365 : 			return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	SHORT $LN1@CL_GetSpri
$LN4@CL_GetSpri:

; 1366 : 	}
; 1367 : 
; 1368 : 	if( mod->mempool )

	mov	ecx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN6@CL_GetSpri

; 1369 : 	{
; 1370 : 		mod->needload = NL_PRESENT;

	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+64], 2

; 1371 : 		return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	SHORT $LN1@CL_GetSpri
$LN6@CL_GetSpri:

; 1372 : 	}
; 1373 : 
; 1374 : 	return NULL;

	xor	eax, eax
$LN1@CL_GetSpri:

; 1375 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetSpritePointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -76						; size = 4
_mod$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_type$ = 12						; size = 4
_texFlags$ = 16						; size = 4
_CL_LoadSpriteModel PROC

; 1249 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1250 : 	char	name[MAX_QPATH];
; 1251 : 	model_t	*mod;
; 1252 : 	int	i;
; 1253 : 
; 1254 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@CL_LoadSpr

; 1255 : 	{
; 1256 : 		Con_Reportf( S_ERROR "CL_LoadSpriteModel: bad name!\n" );

	push	OFFSET $SG146807
	call	_Con_Reportf
	add	esp, 4

; 1257 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@CL_LoadSpr
$LN8@CL_LoadSpr:

; 1258 : 	}
; 1259 : 
; 1260 : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1261 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1262 : 
; 1263 : 	// slot 0 isn't used
; 1264 : 	for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+22288
	jmp	SHORT $LN4@CL_LoadSpr
$LN2@CL_LoadSpr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _mod$[ebp]
	add	edx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], edx
$LN4@CL_LoadSpr:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@CL_LoadSpr

; 1265 : 	{
; 1266 : 		if( !Q_stricmp( mod->name, name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_LoadSpr

; 1267 : 		{
; 1268 : 			if( mod->needload == NL_NEEDS_LOADED )

	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+64], 1
	jne	SHORT $LN10@CL_LoadSpr

; 1269 : 			{
; 1270 : 				if( CL_LoadHudSprite( name, mod, type, texFlags ))

	mov	eax, DWORD PTR _texFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_CL_LoadHudSprite
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@CL_LoadSpr

; 1271 : 					return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	$LN1@CL_LoadSpr
$LN10@CL_LoadSpr:

; 1272 : 			}
; 1273 : 
; 1274 : 			// prolonge registration
; 1275 : 			mod->needload = NL_PRESENT;

	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [ecx+64], 2

; 1276 : 			return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	$LN1@CL_LoadSpr
$LN9@CL_LoadSpr:

; 1277 : 		}
; 1278 : 	}

	jmp	SHORT $LN2@CL_LoadSpr
$LN3@CL_LoadSpr:

; 1279 : 
; 1280 : 	// find a free model slot spot
; 1281 : 	for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+22288
	jmp	SHORT $LN7@CL_LoadSpr
$LN5@CL_LoadSpr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], eax
$LN7@CL_LoadSpr:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN6@CL_LoadSpr

; 1282 : 		if( !mod->name[0] ) break; // this is a valid spot

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mod$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN12@CL_LoadSpr
	jmp	SHORT $LN6@CL_LoadSpr
$LN12@CL_LoadSpr:
	jmp	SHORT $LN5@CL_LoadSpr
$LN6@CL_LoadSpr:

; 1283 : 
; 1284 : 	if( i == MAX_CLIENT_SPRITES ) 

	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jne	SHORT $LN13@CL_LoadSpr

; 1285 : 	{
; 1286 : 		Con_Printf( S_ERROR "MAX_CLIENT_SPRITES limit exceeded (%d)\n", MAX_CLIENT_SPRITES );

	push	256					; 00000100H
	push	OFFSET $SG146813
	call	_Con_Printf
	add	esp, 8

; 1287 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_LoadSpr
$LN13@CL_LoadSpr:

; 1288 : 	}
; 1289 : 
; 1290 : 	// load new map sprite
; 1291 : 	if( CL_LoadHudSprite( name, mod, type, texFlags ))

	mov	edx, DWORD PTR _texFlags$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_CL_LoadHudSprite
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN14@CL_LoadSpr

; 1292 : 		return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	SHORT $LN1@CL_LoadSpr
$LN14@CL_LoadSpr:

; 1293 : 	return NULL;

	xor	eax, eax
$LN1@CL_LoadSpr:

; 1294 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadSpriteModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_size$ = -16						; size = 4
_loaded$ = -12						; size = 4
tv69 = -8						; size = 4
_buf$ = -4						; size = 4
_szSpriteName$ = 8					; size = 4
_m_pSprite$ = 12					; size = 4
_type$ = 16						; size = 4
_texFlags$ = 20						; size = 4
_CL_LoadHudSprite PROC

; 1189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1190 : 	byte	*buf;
; 1191 : 	size_t	size;
; 1192 : 	qboolean	loaded;
; 1193 : 
; 1194 : 	Assert( m_pSprite != NULL );

	cmp	DWORD PTR _m_pSprite$[ebp], 0
	je	SHORT $LN12@CL_LoadHud
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN13@CL_LoadHud
$LN12@CL_LoadHud:
	mov	DWORD PTR tv69[ebp], 0
$LN13@CL_LoadHud:
	push	0
	push	1194					; 000004aaH
	push	OFFSET $SG146771
	push	OFFSET $SG146772
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1195 : 
; 1196 : 	Q_strncpy( m_pSprite->name, szSpriteName, sizeof( m_pSprite->name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _szSpriteName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m_pSprite$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1197 : 
; 1198 : 	// it's hud sprite, make difference names to prevent free shared textures
; 1199 : 	if( type == SPR_CLIENT || type == SPR_HUDSPRITE )

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN3@CL_LoadHud
	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN2@CL_LoadHud
$LN3@CL_LoadHud:

; 1200 : 		SetBits( m_pSprite->flags, MODEL_CLIENT );

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _m_pSprite$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN2@CL_LoadHud:

; 1201 : 	m_pSprite->numtexinfo = texFlags; // store texFlags into numtexinfo

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	mov	ecx, DWORD PTR _texFlags$[ebp]
	mov	DWORD PTR [eax+168], ecx

; 1202 : 
; 1203 : 	if( FS_FileSize( szSpriteName, false ) == -1 )

	push	0
	mov	edx, DWORD PTR _szSpriteName$[ebp]
	push	edx
	call	_FS_FileSize
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN4@CL_LoadHud

; 1204 : 	{
; 1205 : 		if( cls.state != ca_active && cl.maxclients > 1 )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN5@CL_LoadHud
	cmp	DWORD PTR _cl+1568832, 1
	jle	SHORT $LN5@CL_LoadHud

; 1206 : 		{
; 1207 : 			// trying to download sprite from server
; 1208 : 			CL_AddClientResource( szSpriteName, t_model );

	push	2
	mov	eax, DWORD PTR _szSpriteName$[ebp]
	push	eax
	call	_CL_AddClientResource
	add	esp, 8

; 1209 : 			m_pSprite->needload = NL_NEEDS_LOADED;

	mov	ecx, DWORD PTR _m_pSprite$[ebp]
	mov	DWORD PTR [ecx+64], 1

; 1210 : 			return true;

	mov	eax, 1
	jmp	$LN1@CL_LoadHud

; 1211 : 		}

	jmp	SHORT $LN4@CL_LoadHud
$LN5@CL_LoadHud:

; 1212 : 		else
; 1213 : 		{
; 1214 : 			Con_Reportf( S_ERROR "%s couldn't load\n", szSpriteName );

	mov	edx, DWORD PTR _szSpriteName$[ebp]
	push	edx
	push	OFFSET $SG146778
	call	_Con_Reportf
	add	esp, 8

; 1215 : 			Mod_UnloadSpriteModel( m_pSprite );

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 1216 : 			return false;

	xor	eax, eax
	jmp	$LN1@CL_LoadHud
$LN4@CL_LoadHud:

; 1217 : 		}
; 1218 : 	}
; 1219 : 
; 1220 : 	buf = FS_LoadFile( szSpriteName, &size, false );

	push	0
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szSpriteName$[ebp]
	push	edx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 1221 : 	ASSERT( buf != NULL );

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN7@CL_LoadHud
	push	1221					; 000004c5H
	push	OFFSET $SG146780
	push	OFFSET $SG146781
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN7@CL_LoadHud:

; 1222 : 
; 1223 : 	if( type == SPR_MAPSPRITE )

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN8@CL_LoadHud

; 1224 : 		Mod_LoadMapSprite( m_pSprite, buf, size, &loaded );

	lea	eax, DWORD PTR _loaded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_LoadMapSprite
	add	esp, 16					; 00000010H
	jmp	SHORT $LN9@CL_LoadHud
$LN8@CL_LoadHud:

; 1225 : 	else Mod_LoadSpriteModel( m_pSprite, buf, &loaded, texFlags );		

	mov	ecx, DWORD PTR _texFlags$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loaded$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSprite$[ebp]
	push	ecx
	call	_Mod_LoadSpriteModel
	add	esp, 16					; 00000010H
$LN9@CL_LoadHud:

; 1226 : 
; 1227 : 	Mem_Free( buf );

	push	1227					; 000004cbH
	push	OFFSET $SG146784
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1228 : 
; 1229 : 	if( !loaded )

	cmp	DWORD PTR _loaded$[ebp], 0
	jne	SHORT $LN10@CL_LoadHud

; 1230 : 	{
; 1231 : 		Mod_UnloadSpriteModel( m_pSprite );

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 1232 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_LoadHud
$LN10@CL_LoadHud:

; 1233 : 	}
; 1234 : 
; 1235 : 	m_pSprite->needload = NL_PRESENT;

	mov	ecx, DWORD PTR _m_pSprite$[ebp]
	mov	DWORD PTR [ecx+64], 2

; 1236 : 
; 1237 : 	return true;

	mov	eax, 1
$LN1@CL_LoadHud:

; 1238 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadHudSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_yscale$ = -24						; size = 4
_xscale$ = -20						; size = 4
_x$ = -16						; size = 4
_y$ = -12						; size = 4
_width$ = -8						; size = 4
_height$ = -4						; size = 4
_CL_DrawPause PROC

; 989  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 990  : 	int	x, y, width, height;
; 991  : 	float	xscale, yscale;
; 992  : 
; 993  : 	R_GetTextureParms( &width, &height, cls.pauseIcon );

	mov	eax, DWORD PTR _cls+287372
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 994  : 	x = ( clgame.scrInfo.iWidth - width ) >> 1;

	mov	eax, DWORD PTR _clgame+124888
	sub	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 995  : 	y = ( clgame.scrInfo.iHeight - height) >> 1;

	mov	ecx, DWORD PTR _clgame+124892
	sub	ecx, DWORD PTR _height$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx

; 996  : 
; 997  : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+124888
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 998  : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+124892
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 999  : 
; 1000 : 	x *= xscale;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si edx, xmm0
	mov	DWORD PTR _x$[ebp], edx

; 1001 : 	y *= yscale;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 1002 : 	width *= xscale;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _width$[ebp], ecx

; 1003 : 	height *= yscale;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si edx, xmm0
	mov	DWORD PTR _height$[ebp], edx

; 1004 : 
; 1005 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 1006 : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 1007 : 	R_DrawStretchPic( x, y, width, height, 0, 0, 1, 1, cls.pauseIcon );

	mov	eax, DWORD PTR _cls+287372
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawPause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_s2$ = -36						; size = 4
_step$ = -32						; size = 4
_right$ = -28						; size = 4
_yscale$ = -24						; size = 4
_xscale$ = -20						; size = 4
_x$ = -16						; size = 4
_y$ = -12						; size = 4
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_percent$ = 8						; size = 4
_CL_DrawLoading PROC

; 941  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 942  : 	int	x, y, width, height, right;
; 943  : 	float	xscale, yscale, step, s2;
; 944  : 
; 945  : 	R_GetTextureParms( &width, &height, cls.loadingBar );

	mov	eax, DWORD PTR _cls+287380
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 946  : 	x = ( clgame.scrInfo.iWidth - width ) >> 1;

	mov	eax, DWORD PTR _clgame+124888
	sub	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 947  : 	y = ( clgame.scrInfo.iHeight - height) >> 1;

	mov	ecx, DWORD PTR _clgame+124892
	sub	ecx, DWORD PTR _height$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx

; 948  : 
; 949  : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+124888
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 950  : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+124892
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 951  : 
; 952  : 	x *= xscale;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si edx, xmm0
	mov	DWORD PTR _x$[ebp], edx

; 953  : 	y *= yscale;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 954  : 	width *= xscale;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _width$[ebp], ecx

; 955  : 	height *= yscale;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si edx, xmm0
	mov	DWORD PTR _height$[ebp], edx

; 956  : 
; 957  : 	if( cl_allow_levelshots->value )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@CL_DrawLoa

; 958  :           {
; 959  : 		pglColor4ub( 128, 128, 128, 255 );

	push	255					; 000000ffH
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	call	DWORD PTR _pglColor4ub

; 960  : 		GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 961  : 		R_DrawStretchPic( x, y, width, height, 0, 0, 1, 1, cls.loadingBar );

	mov	ecx, DWORD PTR _cls+287380
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 962  : 
; 963  : 		step = (float)width / 100.0f;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _step$[ebp], xmm0

; 964  : 		right = (int)ceil( percent * step );

	movss	xmm0, DWORD PTR _percent$[ebp]
	mulss	xmm0, DWORD PTR _step$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _right$[ebp], eax

; 965  : 		s2 = (float)right / width;

	cvtsi2ss xmm0, DWORD PTR _right$[ebp]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s2$[ebp], xmm0

; 966  : 		width = right;

	mov	edx, DWORD PTR _right$[ebp]
	mov	DWORD PTR _width$[ebp], edx

; 967  : 	
; 968  : 		pglColor4ub( 208, 152, 0, 255 );

	push	255					; 000000ffH
	push	0
	push	152					; 00000098H
	push	208					; 000000d0H
	call	DWORD PTR _pglColor4ub

; 969  : 		GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 970  : 		R_DrawStretchPic( x, y, width, height, 0, 0, s2, 1, cls.loadingBar );

	mov	eax, DWORD PTR _cls+287380
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 971  : 		pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 972  : 	}

	jmp	$LN3@CL_DrawLoa
$LN2@CL_DrawLoa:

; 973  : 	else
; 974  : 	{
; 975  : 		pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 976  : 		GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 977  : 		R_DrawStretchPic( x, y, width, height, 0, 0, 1, 1, cls.loadingBar );

	mov	ecx, DWORD PTR _cls+287380
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H
$LN3@CL_DrawLoa:

; 978  : 	}
; 979  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawLoading ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv170 = -76						; size = 4
tv145 = -72						; size = 4
_width$ = -68						; size = 4
_height$ = -64						; size = 4
_x$ = -60						; size = 4
_y$ = -56						; size = 4
_screen$1 = -52						; size = 12
_point$2 = -40						; size = 12
_forward$3 = -28					; size = 12
_angles$4 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_CL_DrawCrosshair PROC

; 887  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 888  : 	int	x, y, width, height;
; 889  : 
; 890  : 	if( !clgame.ds.pCrosshair || !cl_crosshair->value )

	cmp	DWORD PTR _clgame+122716, 0
	je	SHORT $LN3@CL_DrawCro
	mov	eax, DWORD PTR _cl_crosshair
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_DrawCro
$LN3@CL_DrawCro:

; 891  : 		return;

	jmp	$LN1@CL_DrawCro
$LN2@CL_DrawCro:

; 892  : 
; 893  : 	// any camera on or client is died
; 894  : 	if( cl.local.health <= 0 || cl.viewentity != ( cl.playernum + 1 ))

	cmp	DWORD PTR _cl+1568556, 0
	jle	SHORT $LN5@CL_DrawCro
	mov	ecx, DWORD PTR _cl+1568828
	add	ecx, 1
	cmp	DWORD PTR _cl+1568608, ecx
	je	SHORT $LN4@CL_DrawCro
$LN5@CL_DrawCro:

; 895  : 		return;

	jmp	$LN1@CL_DrawCro
$LN4@CL_DrawCro:

; 896  : 
; 897  : 	// get crosshair dimension
; 898  : 	width = clgame.ds.rcCrosshair.right - clgame.ds.rcCrosshair.left;

	mov	edx, DWORD PTR _clgame+122724
	sub	edx, DWORD PTR _clgame+122720
	mov	DWORD PTR _width$[ebp], edx

; 899  : 	height = clgame.ds.rcCrosshair.bottom - clgame.ds.rcCrosshair.top;

	mov	eax, DWORD PTR _clgame+122732
	sub	eax, DWORD PTR _clgame+122728
	mov	DWORD PTR _height$[ebp], eax

; 900  : 
; 901  : 	x = clgame.viewport[0] + ( clgame.viewport[2] >> 1 ); 

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clgame[eax+122640]
	sar	ecx, 1
	add	ecx, DWORD PTR _clgame[edx+122640]
	mov	DWORD PTR _x$[ebp], ecx

; 902  : 	y = clgame.viewport[1] + ( clgame.viewport[3] >> 1 );

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _clgame[ecx+122640]
	sar	eax, 1
	add	eax, DWORD PTR _clgame[edx+122640]
	mov	DWORD PTR _y$[ebp], eax

; 903  : 
; 904  : 	// g-cont - cl.crosshairangle is the autoaim angle.
; 905  : 	// if we're not using autoaim, just draw in the middle of the screen
; 906  : 	if( !VectorIsNull( cl.crosshairangle ))

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _cl[edx+1568652]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_DrawCro
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+1568652]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_DrawCro
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _cl[ecx+1568652]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@CL_DrawCro
$LN7@CL_DrawCro:

; 907  : 	{
; 908  : 		vec3_t	angles;
; 909  : 		vec3_t	forward;
; 910  : 		vec3_t	point, screen;
; 911  : 
; 912  : 		VectorAdd( RI.viewangles, cl.crosshairangle, angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[edx+1568652]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _angles$4[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[edx+212]
	addss	xmm0, DWORD PTR _cl[eax+1568652]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _angles$4[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[edx+212]
	addss	xmm0, DWORD PTR _cl[eax+1568652]
	movss	DWORD PTR tv145[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR _angles$4[ebp+ecx], xmm0

; 913  : 		AngleVectors( angles, forward, NULL, NULL );

	push	0
	push	0
	lea	edx, DWORD PTR _forward$3[ebp]
	push	edx
	lea	eax, DWORD PTR _angles$4[ebp]
	push	eax
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 914  : 		VectorAdd( RI.vieworg, forward, point );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[edx+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _point$2[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _point$2[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _RI[ecx+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+edx]
	movss	DWORD PTR tv170[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _point$2[ebp+eax], xmm0

; 915  : 		R_WorldToScreen( point, screen );

	lea	ecx, DWORD PTR _screen$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _point$2[ebp]
	push	edx
	call	_R_WorldToScreen
	add	esp, 8

; 916  : 
; 917  : 		x += ( clgame.viewport[2] >> 1 ) * screen[0] + 0.5f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clgame[eax+122640]
	sar	ecx, 1
	cvtsi2ss xmm0, ecx
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm0, DWORD PTR _screen$1[ebp+eax]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	addss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _x$[ebp], ecx

; 918  : 		y += ( clgame.viewport[3] >> 1 ) * screen[1] + 0.5f;

	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _clgame[eax+122640]
	sar	ecx, 1
	cvtsi2ss xmm0, ecx
	mov	edx, 4
	shl	edx, 0
	mulss	xmm0, DWORD PTR _screen$1[ebp+edx]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _y$[ebp], eax
$LN6@CL_DrawCro:

; 919  : 	}
; 920  : 
; 921  : 	// move at center the screen
; 922  : 	x -= 0.5f * width;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _x$[ebp], ecx

; 923  : 	y -= 0.5f * height;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	DWORD PTR _y$[ebp], edx

; 924  : 
; 925  : 	clgame.ds.pSprite = clgame.ds.pCrosshair;

	mov	eax, DWORD PTR _clgame+122716
	mov	DWORD PTR _clgame+122656, eax

; 926  : 	*(int *)clgame.ds.spriteColor = *(int *)clgame.ds.rgbaCrosshair;

	mov	ecx, DWORD PTR _clgame+122736
	mov	DWORD PTR _clgame+122696, ecx

; 927  : 
; 928  : 	SPR_EnableScissor( x, y, width, height );

	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_SPR_EnableScissor
	add	esp, 16					; 00000010H

; 929  : 	pfnSPR_DrawHoles( 0, x, y, &clgame.ds.rcCrosshair );

	push	OFFSET _clgame+122720
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	_pfnSPR_DrawHoles
	add	esp, 16					; 00000010H

; 930  : 	SPR_DisableScissor();

	call	_SPR_DisableScissor
$LN1@CL_DrawCro:

; 931  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawCrosshair ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_SPR_DisableScissor PROC

; 871  : {

	push	ebp
	mov	ebp, esp

; 872  : 	clgame.ds.scissor_x = 0;

	mov	DWORD PTR _clgame+122660, 0

; 873  : 	clgame.ds.scissor_width = 0;

	mov	DWORD PTR _clgame+122668, 0

; 874  : 	clgame.ds.scissor_y = 0;

	mov	DWORD PTR _clgame+122664, 0

; 875  : 	clgame.ds.scissor_height = 0;

	mov	DWORD PTR _clgame+122672, 0

; 876  : 	clgame.ds.scissor_test = false;

	mov	DWORD PTR _clgame+122676, 0

; 877  : }

	pop	ebp
	ret	0
_SPR_DisableScissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv83 = -32						; size = 4
tv82 = -28						; size = 4
tv77 = -24						; size = 4
tv76 = -20						; size = 4
tv71 = -16						; size = 4
tv70 = -12						; size = 4
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_SPR_EnableScissor PROC

; 850  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 851  : 	// check bounds
; 852  : 	x = bound( 0, x, clgame.scrInfo.iWidth );

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN5@SPR_Enable
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _clgame+124888
	jge	SHORT $LN3@SPR_Enable
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	jmp	SHORT $LN4@SPR_Enable
$LN3@SPR_Enable:
	mov	edx, DWORD PTR _clgame+124888
	mov	DWORD PTR tv66[ebp], edx
$LN4@SPR_Enable:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN6@SPR_Enable
$LN5@SPR_Enable:
	mov	DWORD PTR tv67[ebp], 0
$LN6@SPR_Enable:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _x$[ebp], ecx

; 853  : 	y = bound( 0, y, clgame.scrInfo.iHeight );

	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN9@SPR_Enable
	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR _clgame+124892
	jge	SHORT $LN7@SPR_Enable
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@SPR_Enable
$LN7@SPR_Enable:
	mov	ecx, DWORD PTR _clgame+124892
	mov	DWORD PTR tv70[ebp], ecx
$LN8@SPR_Enable:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN10@SPR_Enable
$LN9@SPR_Enable:
	mov	DWORD PTR tv71[ebp], 0
$LN10@SPR_Enable:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 854  : 	width = bound( 0, width, clgame.scrInfo.iWidth - x );

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN13@SPR_Enable
	mov	ecx, DWORD PTR _clgame+124888
	sub	ecx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR _width$[ebp], ecx
	jge	SHORT $LN11@SPR_Enable
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN12@SPR_Enable
$LN11@SPR_Enable:
	mov	eax, DWORD PTR _clgame+124888
	sub	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv76[ebp], eax
$LN12@SPR_Enable:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN14@SPR_Enable
$LN13@SPR_Enable:
	mov	DWORD PTR tv77[ebp], 0
$LN14@SPR_Enable:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _width$[ebp], edx

; 855  : 	height = bound( 0, height, clgame.scrInfo.iHeight - y );

	cmp	DWORD PTR _height$[ebp], 0
	jl	SHORT $LN17@SPR_Enable
	mov	eax, DWORD PTR _clgame+124892
	sub	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _height$[ebp], eax
	jge	SHORT $LN15@SPR_Enable
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN16@SPR_Enable
$LN15@SPR_Enable:
	mov	edx, DWORD PTR _clgame+124892
	sub	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN16@SPR_Enable:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN18@SPR_Enable
$LN17@SPR_Enable:
	mov	DWORD PTR tv83[ebp], 0
$LN18@SPR_Enable:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _height$[ebp], ecx

; 856  : 
; 857  : 	clgame.ds.scissor_x = x;

	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _clgame+122660, edx

; 858  : 	clgame.ds.scissor_width = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _clgame+122668, eax

; 859  : 	clgame.ds.scissor_y = y;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _clgame+122664, ecx

; 860  : 	clgame.ds.scissor_height = height;

	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _clgame+122672, edx

; 861  : 	clgame.ds.scissor_test = true;

	mov	DWORD PTR _clgame+122676, 1

; 862  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_EnableScissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_hSound$ = -16						; size = 4
tv67 = -12						; size = 4
tv66 = -8						; size = 4
_sfx$ = -4						; size = 4
_index$ = 8						; size = 4
_CL_SoundFromIndex PROC

; 819  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 820  : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 821  : 	int	hSound;
; 822  : 
; 823  : 	// make sure what we in-bounds
; 824  : 	index = bound( 0, index, MAX_SOUNDS );

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN7@CL_SoundFr
	cmp	DWORD PTR _index$[ebp], 2048		; 00000800H
	jge	SHORT $LN5@CL_SoundFr
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN6@CL_SoundFr
$LN5@CL_SoundFr:
	mov	DWORD PTR tv66[ebp], 2048		; 00000800H
$LN6@CL_SoundFr:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN8@CL_SoundFr
$LN7@CL_SoundFr:
	mov	DWORD PTR tv67[ebp], 0
$LN8@CL_SoundFr:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _index$[ebp], edx

; 825  : 	hSound = cl.sound_index[index];

	mov	eax, DWORD PTR _index$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+2681456]
	mov	DWORD PTR _hSound$[ebp], ecx

; 826  : 
; 827  : 	if( !hSound )

	cmp	DWORD PTR _hSound$[ebp], 0
	jne	SHORT $LN2@CL_SoundFr

; 828  : 	{
; 829  : 		Con_DPrintf( S_ERROR "CL_SoundFromIndex: invalid sound index %i\n", index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET $SG146600
	call	_Con_DPrintf
	add	esp, 8

; 830  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_SoundFr
$LN2@CL_SoundFr:

; 831  : 	}
; 832  : 
; 833  : 	sfx = S_GetSfxByHandle( hSound );

	mov	eax, DWORD PTR _hSound$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 834  : 	if( !sfx )

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN3@CL_SoundFr

; 835  : 	{
; 836  : 		Con_DPrintf( S_ERROR "CL_SoundFromIndex: bad sfx for index %i\n", index );

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	push	OFFSET $SG146602
	call	_Con_DPrintf
	add	esp, 8

; 837  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_SoundFr
$LN3@CL_SoundFr:

; 838  : 	}
; 839  : 
; 840  : 	return sfx->name;

	mov	eax, DWORD PTR _sfx$[ebp]
$LN1@CL_SoundFr:

; 841  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SoundFromIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_fileSize$ = -12					; size = 4
_pMemFile$ = -8						; size = 4
_i$ = -4						; size = 4
_filename$ = 8						; size = 4
_CL_InitTitles PROC

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 647  : 	size_t	fileSize;
; 648  : 	byte	*pMemFile;
; 649  : 	int	i;
; 650  : 
; 651  : 	// initialize text messages (game_text)
; 652  : 	for( i = 0; i < MAX_TEXTCHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_InitTit
$LN2@CL_InitTit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_InitTit:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN3@CL_InitTit

; 653  : 	{
; 654  : 		cl_textmessage[i].pName = _copystring( clgame.mempool, va( TEXT_MSGNAME, i ), __FILE__, __LINE__ );

	push	654					; 0000028eH
	push	OFFSET $SG146540
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET $SG146541
	call	_va
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _clgame+228
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _cl_textmessage[ecx+36], eax

; 655  : 		cl_textmessage[i].pMessage = cl_textbuffer[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, OFFSET _cl_textbuffer
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _cl_textmessage[eax+40], edx

; 656  : 	}

	jmp	SHORT $LN2@CL_InitTit
$LN3@CL_InitTit:

; 657  : 
; 658  : 	// clear out any old data that's sitting around.
; 659  : 	if( clgame.titles ) Mem_Free( clgame.titles );

	cmp	DWORD PTR _clgame+144660, 0
	je	SHORT $LN5@CL_InitTit
	push	659					; 00000293H
	push	OFFSET $SG146543
	mov	ecx, DWORD PTR _clgame+144660
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@CL_InitTit:

; 660  : 
; 661  : 	clgame.titles = NULL;

	mov	DWORD PTR _clgame+144660, 0

; 662  : 	clgame.numTitles = 0;

	mov	DWORD PTR _clgame+144664, 0

; 663  : 
; 664  : 	pMemFile = FS_LoadFile( filename, &fileSize, false );

	push	0
	lea	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pMemFile$[ebp], eax

; 665  : 	if( !pMemFile ) return;

	cmp	DWORD PTR _pMemFile$[ebp], 0
	jne	SHORT $LN6@CL_InitTit
	jmp	SHORT $LN1@CL_InitTit
$LN6@CL_InitTit:

; 666  : 
; 667  : 	CL_TextMessageParse( pMemFile, fileSize );

	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMemFile$[ebp]
	push	edx
	call	_CL_TextMessageParse
	add	esp, 8

; 668  : 	Mem_Free( pMemFile );

	push	668					; 0000029cH
	push	OFFSET $SG146545
	mov	eax, DWORD PTR _pMemFile$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@CL_InitTit:

; 669  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitTitles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_testFlags$ = -20					; size = 4
tv141 = -16						; size = 4
tv140 = -12						; size = 4
_iFadeAlpha$ = -8					; size = 4
_sf$ = -4						; size = 4
_CL_DrawScreenFade PROC

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 597  : 	screenfade_t	*sf = &clgame.fade;

	mov	DWORD PTR _sf$[ebp], OFFSET _clgame+122740

; 598  : 	int		iFadeAlpha, testFlags;
; 599  : 
; 600  : 	// keep pushing reset time out indefinitely
; 601  : 	if( sf->fadeFlags & FFADE_STAYOUT )

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 4
	je	SHORT $LN2@CL_DrawScr

; 602  : 		sf->fadeReset = cl.time + 0.1f;

	movsd	xmm0, QWORD PTR _cl+1525848
	addsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [edx+12], xmm0
$LN2@CL_DrawScr:

; 603  : 		
; 604  : 	if( sf->fadeReset == 0.0f && sf->fadeEnd == 0.0f )

	mov	eax, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_DrawScr
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_DrawScr

; 605  : 		return;	// inactive

	jmp	$LN1@CL_DrawScr
$LN3@CL_DrawScr:

; 606  : 
; 607  : 	// all done?
; 608  : 	if(( cl.time > sf->fadeReset ) && ( cl.time > sf->fadeEnd ))

	mov	edx, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+12]
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	jbe	SHORT $LN4@CL_DrawScr
	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4]
	movsd	xmm1, QWORD PTR _cl+1525848
	comisd	xmm1, xmm0
	jbe	SHORT $LN4@CL_DrawScr

; 609  : 	{
; 610  : 		memset( &clgame.fade, 0, sizeof( clgame.fade ));

	push	24					; 00000018H
	push	0
	push	OFFSET _clgame+122740
	call	_memset
	add	esp, 12					; 0000000cH

; 611  : 		return;

	jmp	$LN1@CL_DrawScr
$LN4@CL_DrawScr:

; 612  : 	}
; 613  : 
; 614  : 	testFlags = (sf->fadeFlags & ~FFADE_MODULATE);

	mov	ecx, DWORD PTR _sf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	and	edx, -3					; fffffffdH
	mov	DWORD PTR _testFlags$[ebp], edx

; 615  : 
; 616  : 	// fading...
; 617  : 	if( testFlags == FFADE_STAYOUT )

	cmp	DWORD PTR _testFlags$[ebp], 4
	jne	SHORT $LN5@CL_DrawScr

; 618  : 	{
; 619  : 		iFadeAlpha = sf->fadealpha;

	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR _iFadeAlpha$[ebp], ecx

; 620  : 	}

	jmp	SHORT $LN6@CL_DrawScr
$LN5@CL_DrawScr:

; 621  : 	else
; 622  : 	{
; 623  : 		iFadeAlpha = sf->fadeSpeed * ( sf->fadeEnd - cl.time );

	mov	edx, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+4]
	subsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _iFadeAlpha$[ebp], ecx

; 624  : 		if( sf->fadeFlags & FFADE_OUT ) iFadeAlpha += sf->fadealpha;

	mov	edx, DWORD PTR _sf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, 1
	je	SHORT $LN7@CL_DrawScr
	mov	ecx, DWORD PTR _sf$[ebp]
	movzx	edx, BYTE PTR [ecx+19]
	add	edx, DWORD PTR _iFadeAlpha$[ebp]
	mov	DWORD PTR _iFadeAlpha$[ebp], edx
$LN7@CL_DrawScr:

; 625  : 		iFadeAlpha = bound( 0, iFadeAlpha, sf->fadealpha );

	cmp	DWORD PTR _iFadeAlpha$[ebp], 0
	jl	SHORT $LN13@CL_DrawScr
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	cmp	DWORD PTR _iFadeAlpha$[ebp], ecx
	jge	SHORT $LN11@CL_DrawScr
	mov	edx, DWORD PTR _iFadeAlpha$[ebp]
	mov	DWORD PTR tv140[ebp], edx
	jmp	SHORT $LN12@CL_DrawScr
$LN11@CL_DrawScr:
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR tv140[ebp], ecx
$LN12@CL_DrawScr:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], edx
	jmp	SHORT $LN14@CL_DrawScr
$LN13@CL_DrawScr:
	mov	DWORD PTR tv141[ebp], 0
$LN14@CL_DrawScr:
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR _iFadeAlpha$[ebp], eax
$LN6@CL_DrawScr:

; 626  : 	}
; 627  : 
; 628  : 	pglColor4ub( sf->fader, sf->fadeg, sf->fadeb, iFadeAlpha );

	movzx	ecx, BYTE PTR _iFadeAlpha$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sf$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	push	eax
	mov	ecx, DWORD PTR _sf$[ebp]
	movzx	edx, BYTE PTR [ecx+17]
	push	edx
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	push	ecx
	call	DWORD PTR _pglColor4ub

; 629  : 
; 630  : 	if( sf->fadeFlags & FFADE_MODULATE )

	mov	edx, DWORD PTR _sf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, 2
	je	SHORT $LN8@CL_DrawScr

; 631  : 		GL_SetRenderMode( kRenderTransAdd );

	push	5
	call	_GL_SetRenderMode
	add	esp, 4
	jmp	SHORT $LN9@CL_DrawScr
$LN8@CL_DrawScr:

; 632  : 	else GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4
$LN9@CL_DrawScr:

; 633  : 	R_DrawStretchPic( 0, 0, glState.width, glState.height, 0, 0, 1, 1, tr.whiteTexture );

	mov	ecx, DWORD PTR _tr+8
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState+4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 634  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@CL_DrawScr:

; 635  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_texnum$ = -48						; size = 4
_h$1 = -44						; size = 4
_w$2 = -40						; size = 4
_s1$ = -36						; size = 4
_s2$ = -32						; size = 4
_t1$ = -28						; size = 4
_t2$ = -24						; size = 4
_rc$3 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_prc$ = 28						; size = 4
_SPR_DrawGeneric PROC

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 473  : 	float	s1, s2, t1, t2;
; 474  : 	int	texnum;
; 475  : 
; 476  : 	if( width == -1 && height == -1 )

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_DrawGe

; 477  : 	{
; 478  : 		int	w, h;
; 479  : 
; 480  : 		// assume we get sizes from image
; 481  : 		R_GetSpriteParms( &w, &h, NULL, frame, clgame.ds.pSprite );

	mov	eax, DWORD PTR _clgame+122656
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _h$1[ebp]
	push	edx
	lea	eax, DWORD PTR _w$2[ebp]
	push	eax
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 482  : 
; 483  : 		width = w;

	cvtsi2ss xmm0, DWORD PTR _w$2[ebp]
	movss	DWORD PTR _width$[ebp], xmm0

; 484  : 		height = h;

	cvtsi2ss xmm0, DWORD PTR _h$1[ebp]
	movss	DWORD PTR _height$[ebp], xmm0
$LN2@SPR_DrawGe:

; 485  : 	}
; 486  : 
; 487  : 	if( prc )

	cmp	DWORD PTR _prc$[ebp], 0
	je	$LN3@SPR_DrawGe

; 488  : 	{
; 489  : 		wrect_t	rc;
; 490  : 
; 491  : 		rc = *prc;

	mov	ecx, DWORD PTR _prc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _rc$3[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _rc$3[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _rc$3[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _rc$3[ebp+12], eax

; 492  : 
; 493  : 		// Sigh! some stupid modmakers set wrong rectangles in hud.txt 
; 494  : 		if( rc.left <= 0 || rc.left >= width ) rc.left = 0;

	cmp	DWORD PTR _rc$3[ebp], 0
	jle	SHORT $LN6@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp]
	comiss	xmm0, DWORD PTR _width$[ebp]
	jb	SHORT $LN5@SPR_DrawGe
$LN6@SPR_DrawGe:
	mov	DWORD PTR _rc$3[ebp], 0
$LN5@SPR_DrawGe:

; 495  : 		if( rc.top <= 0 || rc.top >= height ) rc.top = 0;

	cmp	DWORD PTR _rc$3[ebp+8], 0
	jle	SHORT $LN8@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp+8]
	comiss	xmm0, DWORD PTR _height$[ebp]
	jb	SHORT $LN7@SPR_DrawGe
$LN8@SPR_DrawGe:
	mov	DWORD PTR _rc$3[ebp+8], 0
$LN7@SPR_DrawGe:

; 496  : 		if( rc.right <= 0 || rc.right > width ) rc.right = width;

	cmp	DWORD PTR _rc$3[ebp+4], 0
	jle	SHORT $LN10@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp+4]
	comiss	xmm0, DWORD PTR _width$[ebp]
	jbe	SHORT $LN9@SPR_DrawGe
$LN10@SPR_DrawGe:
	cvttss2si ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _rc$3[ebp+4], ecx
$LN9@SPR_DrawGe:

; 497  : 		if( rc.bottom <= 0 || rc.bottom > height ) rc.bottom = height;

	cmp	DWORD PTR _rc$3[ebp+12], 0
	jle	SHORT $LN12@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp+12]
	comiss	xmm0, DWORD PTR _height$[ebp]
	jbe	SHORT $LN11@SPR_DrawGe
$LN12@SPR_DrawGe:
	cvttss2si edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _rc$3[ebp+12], edx
$LN11@SPR_DrawGe:

; 498  : 
; 499  : 		// calc user-defined rectangle
; 500  : 		s1 = (float)rc.left / width;

	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp]
	divss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 501  : 		t1 = (float)rc.top / height;

	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp+8]
	divss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR _t1$[ebp], xmm0

; 502  : 		s2 = (float)rc.right / width;

	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp+4]
	divss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0

; 503  : 		t2 = (float)rc.bottom / height;

	cvtsi2ss xmm0, DWORD PTR _rc$3[ebp+12]
	divss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR _t2$[ebp], xmm0

; 504  : 		width = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$3[ebp+4]
	sub	eax, DWORD PTR _rc$3[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _width$[ebp], xmm0

; 505  : 		height = rc.bottom - rc.top;

	mov	ecx, DWORD PTR _rc$3[ebp+12]
	sub	ecx, DWORD PTR _rc$3[ebp+8]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _height$[ebp], xmm0

; 506  : 	}

	jmp	SHORT $LN4@SPR_DrawGe
$LN3@SPR_DrawGe:

; 507  : 	else
; 508  : 	{
; 509  : 		s1 = t1 = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _t1$[ebp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 510  : 		s2 = t2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t2$[ebp], xmm0
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0
$LN4@SPR_DrawGe:

; 511  : 	}
; 512  : 
; 513  : 	// pass scissor test if supposed
; 514  : 	if( clgame.ds.scissor_test && !SPR_Scissor( &x, &y, &width, &height, &s1, &t1, &s2, &t2 ))

	cmp	DWORD PTR _clgame+122676, 0
	je	SHORT $LN13@SPR_DrawGe
	lea	edx, DWORD PTR _t2$[ebp]
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s1$[ebp]
	push	edx
	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_Scissor
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN13@SPR_DrawGe

; 515  : 		return;

	jmp	$LN1@SPR_DrawGe
$LN13@SPR_DrawGe:

; 516  : 
; 517  : 	// scale for screen sizes
; 518  : 	SPR_AdjustSize( &x, &y, &width, &height );

	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_SPR_AdjustSize
	add	esp, 16					; 00000010H

; 519  : 	texnum = R_GetSpriteTexture( clgame.ds.pSprite, frame );

	mov	edx, DWORD PTR _frame$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+122656
	push	eax
	call	_R_GetSpriteTexture
	add	esp, 8
	mov	DWORD PTR _texnum$[ebp], eax

; 520  : 	pglColor4ubv( clgame.ds.spriteColor );

	push	OFFSET _clgame+122696
	call	DWORD PTR _pglColor4ubv

; 521  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 522  : 	R_DrawStretchPic( x, y, width, height, s1, t1, s2, t2, texnum );

	mov	ecx, DWORD PTR _texnum$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H
$LN1@SPR_DrawGe:

; 523  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_DrawGeneric ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_dvdy$ = -8						; size = 4
_dudx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_u0$ = 24						; size = 4
_v0$ = 28						; size = 4
_u1$ = 32						; size = 4
_v1$ = 36						; size = 4
_SPR_Scissor PROC

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 417  : 	float	dudx, dvdy;
; 418  : 
; 419  : 	// clip sub rect to sprite
; 420  : 	if(( width == 0 ) || ( height == 0 ))

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN3@SPR_Scisso
	cmp	DWORD PTR _height$[ebp], 0
	jne	SHORT $LN2@SPR_Scisso
$LN3@SPR_Scisso:

; 421  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN2@SPR_Scisso:

; 422  : 
; 423  : 	if( *x + *width <= clgame.ds.scissor_x )

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	cvtsi2ss xmm1, DWORD PTR _clgame+122660
	comiss	xmm1, xmm0
	jb	SHORT $LN4@SPR_Scisso

; 424  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN4@SPR_Scisso:

; 425  : 	if( *x >= clgame.ds.scissor_x + clgame.ds.scissor_width )

	mov	edx, DWORD PTR _clgame+122660
	add	edx, DWORD PTR _clgame+122668
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm1, xmm0
	jb	SHORT $LN5@SPR_Scisso

; 426  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN5@SPR_Scisso:

; 427  : 	if( *y + *height <= clgame.ds.scissor_y )

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	cvtsi2ss xmm1, DWORD PTR _clgame+122664
	comiss	xmm1, xmm0
	jb	SHORT $LN6@SPR_Scisso

; 428  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN6@SPR_Scisso:

; 429  : 	if( *y >= clgame.ds.scissor_y + clgame.ds.scissor_height )

	mov	eax, DWORD PTR _clgame+122664
	add	eax, DWORD PTR _clgame+122672
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jb	SHORT $LN7@SPR_Scisso

; 430  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN7@SPR_Scisso:

; 431  : 
; 432  : 	dudx = (*u1 - *u0) / *width;

	mov	edx, DWORD PTR _u1$[ebp]
	mov	eax, DWORD PTR _u0$[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _dudx$[ebp], xmm0

; 433  : 	dvdy = (*v1 - *v0) / *height;

	mov	edx, DWORD PTR _v1$[ebp]
	mov	eax, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _height$[ebp]
	divss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _dvdy$[ebp], xmm0

; 434  : 
; 435  : 	if( *x < clgame.ds.scissor_x )

	cvtsi2ss xmm0, DWORD PTR _clgame+122660
	mov	edx, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN8@SPR_Scisso

; 436  : 	{
; 437  : 		*u0 += (clgame.ds.scissor_x - *x) * dudx;

	cvtsi2ss xmm0, DWORD PTR _clgame+122660
	mov	eax, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _dudx$[ebp]
	mov	ecx, DWORD PTR _u0$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _u0$[ebp]
	movss	DWORD PTR [edx], xmm0

; 438  : 		*width -= clgame.ds.scissor_x - *x;

	cvtsi2ss xmm0, DWORD PTR _clgame+122660
	mov	eax, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _width$[ebp]
	movss	DWORD PTR [edx], xmm1

; 439  : 		*x = clgame.ds.scissor_x;

	cvtsi2ss xmm0, DWORD PTR _clgame+122660
	mov	eax, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN8@SPR_Scisso:

; 440  : 	}
; 441  : 
; 442  : 	if( *x + *width > clgame.ds.scissor_x + clgame.ds.scissor_width )

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _clgame+122660
	add	eax, DWORD PTR _clgame+122668
	cvtsi2ss xmm1, eax
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@SPR_Scisso

; 443  : 	{
; 444  : 		*u1 -= (*x + *width - (clgame.ds.scissor_x + clgame.ds.scissor_width)) * dudx;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _clgame+122660
	add	eax, DWORD PTR _clgame+122668
	cvtsi2ss xmm1, eax
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _dudx$[ebp]
	mov	ecx, DWORD PTR _u1$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _u1$[ebp]
	movss	DWORD PTR [edx], xmm1

; 445  : 		*width = clgame.ds.scissor_x + clgame.ds.scissor_width - *x;

	mov	eax, DWORD PTR _clgame+122660
	add	eax, DWORD PTR _clgame+122668
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _width$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN9@SPR_Scisso:

; 446  : 	}
; 447  : 
; 448  : 	if( *y < clgame.ds.scissor_y )

	cvtsi2ss xmm0, DWORD PTR _clgame+122664
	mov	eax, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN10@SPR_Scisso

; 449  : 	{
; 450  : 		*v0 += (clgame.ds.scissor_y - *y) * dvdy;

	cvtsi2ss xmm0, DWORD PTR _clgame+122664
	mov	ecx, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _dvdy$[ebp]
	mov	edx, DWORD PTR _v0$[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _v0$[ebp]
	movss	DWORD PTR [eax], xmm0

; 451  : 		*height -= clgame.ds.scissor_y - *y;

	cvtsi2ss xmm0, DWORD PTR _clgame+122664
	mov	ecx, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _height$[ebp]
	movss	xmm1, DWORD PTR [edx]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _height$[ebp]
	movss	DWORD PTR [eax], xmm1

; 452  : 		*y = clgame.ds.scissor_y;

	cvtsi2ss xmm0, DWORD PTR _clgame+122664
	mov	ecx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN10@SPR_Scisso:

; 453  : 	}
; 454  : 
; 455  : 	if( *y + *height > clgame.ds.scissor_y + clgame.ds.scissor_height )

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _clgame+122664
	add	ecx, DWORD PTR _clgame+122672
	cvtsi2ss xmm1, ecx
	comiss	xmm0, xmm1
	jbe	SHORT $LN11@SPR_Scisso

; 456  : 	{
; 457  : 		*v1 -= (*y + *height - (clgame.ds.scissor_y + clgame.ds.scissor_height)) * dvdy;

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _clgame+122664
	add	ecx, DWORD PTR _clgame+122672
	cvtsi2ss xmm1, ecx
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _dvdy$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	movss	xmm1, DWORD PTR [edx]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _v1$[ebp]
	movss	DWORD PTR [eax], xmm1

; 458  : 		*height = clgame.ds.scissor_y + clgame.ds.scissor_height - *y;

	mov	ecx, DWORD PTR _clgame+122664
	add	ecx, DWORD PTR _clgame+122672
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _height$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN11@SPR_Scisso:

; 459  : 	}
; 460  : 
; 461  : 	return true;

	mov	eax, 1
$LN1@SPR_Scisso:

; 462  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_Scissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_yscale$ = -8						; size = 4
_xscale$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_SPR_AdjustSize PROC

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 377  : 	float	xscale, yscale;
; 378  : 
; 379  : 	if( !x && !y && !w && !h ) return;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	jmp	$LN6@SPR_Adjust
$LN2@SPR_Adjust:

; 380  : 
; 381  : 	// scale for screen sizes
; 382  : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+124888
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 383  : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+124892
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 384  : 
; 385  : 	if( x ) *x *= xscale;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@SPR_Adjust
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN3@SPR_Adjust:

; 386  : 	if( y ) *y *= yscale;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@SPR_Adjust
	mov	edx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN4@SPR_Adjust:

; 387  : 	if( w ) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN5@SPR_Adjust
	mov	ecx, DWORD PTR _w$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN5@SPR_Adjust:

; 388  : 	if( h ) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN6@SPR_Adjust
	mov	eax, DWORD PTR _h$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN6@SPR_Adjust:

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_AdjustSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_yPos$ = -4						; size = 4
_y$ = 8							; size = 4
_height$ = 12						; size = 4
_CL_AdjustYPos PROC

; 303  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 304  : 	int	yPos;
; 305  : 
; 306  : 	if( y == -1 ) // centered?

	movss	xmm0, DWORD PTR _y$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_AdjustY

; 307  : 	{
; 308  : 		yPos = ( glState.height - height ) * 0.5f;

	mov	eax, DWORD PTR _glState+4
	sub	eax, DWORD PTR _height$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _yPos$[ebp], ecx

; 309  : 	}

	jmp	SHORT $LN5@CL_AdjustY
$LN2@CL_AdjustY:

; 310  : 	else
; 311  : 	{
; 312  : 		// Alight bottom?
; 313  : 		if( y < 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _y$[ebp]
	jbe	SHORT $LN4@CL_AdjustY

; 314  : 			yPos = (1.0f + y) * glState.height - height; // Alight bottom

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, DWORD PTR _glState+4
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	subss	xmm0, xmm1
	cvttss2si edx, xmm0
	mov	DWORD PTR _yPos$[ebp], edx
	jmp	SHORT $LN5@CL_AdjustY
$LN4@CL_AdjustY:

; 315  : 		else // align top
; 316  : 			yPos = y * glState.height;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	mulss	xmm0, DWORD PTR _y$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _yPos$[ebp], eax
$LN5@CL_AdjustY:

; 317  : 	}
; 318  : 
; 319  : 	if( yPos + height > glState.height )

	mov	ecx, DWORD PTR _yPos$[ebp]
	add	ecx, DWORD PTR _height$[ebp]
	cmp	ecx, DWORD PTR _glState+4
	jle	SHORT $LN6@CL_AdjustY

; 320  : 		yPos = glState.height - height;

	mov	edx, DWORD PTR _glState+4
	sub	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _yPos$[ebp], edx
	jmp	SHORT $LN8@CL_AdjustY
$LN6@CL_AdjustY:

; 321  : 	else if( yPos < 0 )

	cmp	DWORD PTR _yPos$[ebp], 0
	jge	SHORT $LN8@CL_AdjustY

; 322  : 		yPos = 0;

	mov	DWORD PTR _yPos$[ebp], 0
$LN8@CL_AdjustY:

; 323  : 
; 324  : 	return yPos;

	mov	eax, DWORD PTR _yPos$[ebp]

; 325  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AdjustYPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_xPos$ = -4						; size = 4
_x$ = 8							; size = 4
_width$ = 12						; size = 4
_totalWidth$ = 16					; size = 4
_CL_AdjustXPos PROC

; 272  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 273  : 	int	xPos;
; 274  : 
; 275  : 	if( x == -1 )

	movss	xmm0, DWORD PTR _x$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_AdjustX

; 276  : 	{
; 277  : 		xPos = ( glState.width - width ) * 0.5f;

	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR _width$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _xPos$[ebp], ecx

; 278  : 	}

	jmp	SHORT $LN5@CL_AdjustX
$LN2@CL_AdjustX:

; 279  : 	else
; 280  : 	{
; 281  : 		if ( x < 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _x$[ebp]
	jbe	SHORT $LN4@CL_AdjustX

; 282  : 			xPos = (1.0f + x) * glState.width - totalWidth;	// Alight right

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, DWORD PTR _glState
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _totalWidth$[ebp]
	subss	xmm0, xmm1
	cvttss2si edx, xmm0
	mov	DWORD PTR _xPos$[ebp], edx
	jmp	SHORT $LN5@CL_AdjustX
$LN4@CL_AdjustX:

; 283  : 		else // align left
; 284  : 			xPos = x * glState.width;

	cvtsi2ss xmm0, DWORD PTR _glState
	mulss	xmm0, DWORD PTR _x$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _xPos$[ebp], eax
$LN5@CL_AdjustX:

; 285  : 	}
; 286  : 
; 287  : 	if( xPos + width > glState.width )

	mov	ecx, DWORD PTR _xPos$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	cmp	ecx, DWORD PTR _glState
	jle	SHORT $LN6@CL_AdjustX

; 288  : 		xPos = glState.width - width;

	mov	edx, DWORD PTR _glState
	sub	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _xPos$[ebp], edx
	jmp	SHORT $LN8@CL_AdjustX
$LN6@CL_AdjustX:

; 289  : 	else if( xPos < 0 )

	cmp	DWORD PTR _xPos$[ebp], 0
	jge	SHORT $LN8@CL_AdjustX

; 290  : 		xPos = 0;

	mov	DWORD PTR _xPos$[ebp], 0
$LN8@CL_AdjustX:

; 291  : 
; 292  : 	return xPos;

	mov	eax, DWORD PTR _xPos$[ebp]

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AdjustXPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
$T1 = -276						; size = 4
_afile$ = -272						; size = 4
_pfile$ = -268						; size = 4
_c$ = -264						; size = 4
_token$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_CL_InitCDAudio PROC

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 217  : 	char	*afile, *pfile;
; 218  : 	string	token;
; 219  : 	int	c = 0;

	mov	DWORD PTR _c$[ebp], 0

; 220  : 
; 221  : 	if( !FS_FileExists( filename, false ))

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@CL_InitCDA

; 222  : 	{
; 223  : 		// create a default playlist
; 224  : 		CL_CreatePlaylist( filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_CL_CreatePlaylist
	add	esp, 4
$LN4@CL_InitCDA:

; 225  : 	}
; 226  : 
; 227  : 	afile = FS_LoadFile( filename, NULL, false );

	push	0
	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _afile$[ebp], eax

; 228  : 	if( !afile ) return;

	cmp	DWORD PTR _afile$[ebp], 0
	jne	SHORT $LN5@CL_InitCDA
	jmp	$LN8@CL_InitCDA
$LN5@CL_InitCDA:

; 229  : 
; 230  : 	pfile = afile;

	mov	eax, DWORD PTR _afile$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN2@CL_InitCDA:

; 231  : 
; 232  : 	// format: trackname\n [num]
; 233  : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@CL_InitCDA

; 234  : 	{
; 235  : 		if( !Q_stricmp( token, "blank" )) token[0] = '\0';

	push	99999					; 0001869fH
	push	OFFSET $SG146326
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_InitCDA
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN9@CL_InitCDA
	jmp	SHORT $LN10@CL_InitCDA
$LN9@CL_InitCDA:
	call	___report_rangecheckfailure
$LN10@CL_InitCDA:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _token$[ebp+eax], 0
$LN6@CL_InitCDA:

; 236  : 		Q_strncpy( clgame.cdtracks[c], token, sizeof( clgame.cdtracks[0] ));

	push	256					; 00000100H
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 8
	add	edx, OFFSET _clgame+14096
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 237  : 
; 238  : 		if( ++c > MAX_CDTRACKS - 1 )

	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 31			; 0000001fH
	jle	SHORT $LN7@CL_InitCDA

; 239  : 		{
; 240  : 			Con_Reportf( S_WARN "CD_Init: too many tracks %i in %s\n", MAX_CDTRACKS, filename );

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	32					; 00000020H
	push	OFFSET $SG146328
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 241  : 			break;

	jmp	SHORT $LN3@CL_InitCDA
$LN7@CL_InitCDA:

; 242  : 		}
; 243  : 	}

	jmp	$LN2@CL_InitCDA
$LN3@CL_InitCDA:

; 244  : 
; 245  : 	Mem_Free( afile );

	push	245					; 000000f5H
	push	OFFSET $SG146329
	mov	edx, DWORD PTR _afile$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@CL_InitCDA:

; 246  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitCDAudio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_f$ = -4						; size = 4
_filename$ = 8						; size = 4
_CL_CreatePlaylist PROC

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 171  : 	file_t	*f;
; 172  : 
; 173  : 	f = FS_Open( filename, "w", false );

	push	0
	push	OFFSET $SG146280
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 174  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@CL_CreateP
	jmp	$LN1@CL_CreateP
$LN2@CL_CreateP:

; 175  : 
; 176  : 	// make standard cdaudio playlist
; 177  : 	FS_Print( f, "blank\n" );		// #1

	push	OFFSET $SG146282
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 178  : 	FS_Print( f, "Half-Life01.mp3\n" );	// #2

	push	OFFSET $SG146283
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 179  : 	FS_Print( f, "Prospero01.mp3\n" );	// #3

	push	OFFSET $SG146284
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 180  : 	FS_Print( f, "Half-Life12.mp3\n" );	// #4

	push	OFFSET $SG146285
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 181  : 	FS_Print( f, "Half-Life07.mp3\n" );	// #5

	push	OFFSET $SG146286
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 182  : 	FS_Print( f, "Half-Life10.mp3\n" );	// #6

	push	OFFSET $SG146287
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 183  : 	FS_Print( f, "Suspense01.mp3\n" );	// #7

	push	OFFSET $SG146288
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 184  : 	FS_Print( f, "Suspense03.mp3\n" );	// #8

	push	OFFSET $SG146289
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 185  : 	FS_Print( f, "Half-Life09.mp3\n" );	// #9

	push	OFFSET $SG146290
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 186  : 	FS_Print( f, "Half-Life02.mp3\n" );	// #10

	push	OFFSET $SG146291
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 187  : 	FS_Print( f, "Half-Life13.mp3\n" );	// #11

	push	OFFSET $SG146292
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 188  : 	FS_Print( f, "Half-Life04.mp3\n" );	// #12

	push	OFFSET $SG146293
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 189  : 	FS_Print( f, "Half-Life15.mp3\n" );	// #13

	push	OFFSET $SG146294
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 190  : 	FS_Print( f, "Half-Life14.mp3\n" );	// #14

	push	OFFSET $SG146295
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 191  : 	FS_Print( f, "Half-Life16.mp3\n" );	// #15

	push	OFFSET $SG146296
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 192  : 	FS_Print( f, "Suspense02.mp3\n" );	// #16

	push	OFFSET $SG146297
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 193  : 	FS_Print( f, "Half-Life03.mp3\n" );	// #17

	push	OFFSET $SG146298
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 194  : 	FS_Print( f, "Half-Life08.mp3\n" );	// #18

	push	OFFSET $SG146299
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 195  : 	FS_Print( f, "Prospero02.mp3\n" );	// #19

	push	OFFSET $SG146300
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 196  : 	FS_Print( f, "Half-Life05.mp3\n" );	// #20

	push	OFFSET $SG146301
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 197  : 	FS_Print( f, "Prospero04.mp3\n" );	// #21

	push	OFFSET $SG146302
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 198  : 	FS_Print( f, "Half-Life11.mp3\n" );	// #22

	push	OFFSET $SG146303
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 199  : 	FS_Print( f, "Half-Life06.mp3\n" );	// #23

	push	OFFSET $SG146304
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 200  : 	FS_Print( f, "Prospero03.mp3\n" );	// #24

	push	OFFSET $SG146305
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 201  : 	FS_Print( f, "Half-Life17.mp3\n" );	// #25

	push	OFFSET $SG146306
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 202  : 	FS_Print( f, "Prospero05.mp3\n" );	// #26

	push	OFFSET $SG146307
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Print
	add	esp, 8

; 203  : 	FS_Print( f, "Suspense05.mp3\n" );	// #27

	push	OFFSET $SG146308
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 204  : 	FS_Print( f, "Suspense07.mp3\n" );	// #28

	push	OFFSET $SG146309
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Print
	add	esp, 8

; 205  : 	FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4
$LN1@CL_CreateP:

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreatePlaylist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_pfnSPR_DrawHoles PROC

; 1457 : {

	push	ebp
	mov	ebp, esp

; 1458 : 	pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 1459 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1460 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1461 : 
; 1462 : 	SPR_DrawGeneric( frame, x, y, -1, -1, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGeneric
	add	esp, 24					; 00000018H

; 1463 : 
; 1464 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1465 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1466 : }

	pop	ebp
	ret	0
_pfnSPR_DrawHoles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_TriEnd	PROC

; 2959 : {

	push	ebp
	mov	ebp, esp

; 2960 : 	pglEnd();

	call	DWORD PTR _pglEnd

; 2961 : }

	pop	ebp
	ret	0
_TriEnd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_mode$ = 8						; size = 4
_TriCullFace PROC

; 3054 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3055 : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN4@TriCullFac
	jmp	SHORT $LN5@TriCullFac
$LN4@TriCullFac:

; 3056 : 	{
; 3057 : 	case TRI_FRONT:
; 3058 : 		clgame.ds.cullMode = GL_FRONT;

	mov	DWORD PTR _clgame+122688, 1028		; 00000404H

; 3059 : 		break;

	jmp	SHORT $LN2@TriCullFac
$LN5@TriCullFac:

; 3060 : 	default:
; 3061 : 		clgame.ds.cullMode = GL_NONE;

	mov	DWORD PTR _clgame+122688, 0
$LN2@TriCullFac:

; 3062 : 		break;
; 3063 : 	}
; 3064 : 
; 3065 : 	GL_Cull( clgame.ds.cullMode );

	mov	ecx, DWORD PTR _clgame+122688
	push	ecx
	call	_GL_Cull
	add	esp, 4

; 3066 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_TriCullFace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_mode$ = 8						; size = 4
_TriRenderMode PROC

; 2881 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2882 : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	$LN2@TriRenderM
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN9@TriRenderM[ecx*4]
$LN4@TriRenderM:

; 2883 : 	{
; 2884 : 	case kRenderNormal:
; 2885 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 2886 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 2887 : 		pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 2888 : 		break;

	jmp	SHORT $LN2@TriRenderM
$LN5@TriRenderM:

; 2889 : 	case kRenderTransAlpha:
; 2890 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 2891 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 2892 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 2893 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 2894 : 		break;

	jmp	SHORT $LN2@TriRenderM
$LN6@TriRenderM:

; 2895 : 	case kRenderTransColor:
; 2896 : 	case kRenderTransTexture:
; 2897 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 2898 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 2899 : 		break;

	jmp	SHORT $LN2@TriRenderM
$LN7@TriRenderM:

; 2900 : 	case kRenderGlow:
; 2901 : 	case kRenderTransAdd:
; 2902 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 2903 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 2904 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask
$LN2@TriRenderM:

; 2905 : 		break;
; 2906 : 	}
; 2907 : 
; 2908 : 	clgame.ds.renderMode = mode;

	mov	edx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR _clgame+122684, edx

; 2909 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@TriRenderM:
	DD	$LN4@TriRenderM
	DD	$LN6@TriRenderM
	DD	$LN6@TriRenderM
	DD	$LN7@TriRenderM
	DD	$LN5@TriRenderM
	DD	$LN7@TriRenderM
_TriRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_r$ = -12						; size = 4
_g$ = -8						; size = 4
_b$ = -4						; size = 4
_brightness$ = 8					; size = 4
_TriBrightness PROC

; 3037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3038 : 	float	r, g, b;
; 3039 : 
; 3040 : 	r = clgame.ds.triRGBA[0] * clgame.ds.triRGBA[3] * brightness;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _clgame[ecx+122700]
	mulss	xmm0, DWORD PTR _clgame[eax+122700]
	mulss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 3041 : 	g = clgame.ds.triRGBA[1] * clgame.ds.triRGBA[3] * brightness;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _clgame[ecx+122700]
	mulss	xmm0, DWORD PTR _clgame[eax+122700]
	mulss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 3042 : 	b = clgame.ds.triRGBA[2] * clgame.ds.triRGBA[3] * brightness;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _clgame[ecx+122700]
	mulss	xmm0, DWORD PTR _clgame[eax+122700]
	mulss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 3043 : 
; 3044 : 	pglColor4f( r, g, b, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3045 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_TriBrightness ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_r$ = 8							; size = 1
_g$ = 12						; size = 1
_b$ = 16						; size = 1
_a$ = 20						; size = 1
_TriColor4ub PROC

; 2988 : {

	push	ebp
	mov	ebp, esp

; 2989 : 	clgame.ds.triRGBA[0] = r * (1.0f / 255.0f);

	movzx	eax, BYTE PTR _r$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _clgame[edx+122700], xmm0

; 2990 : 	clgame.ds.triRGBA[1] = g * (1.0f / 255.0f);

	movzx	eax, BYTE PTR _g$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _clgame[ecx+122700], xmm0

; 2991 : 	clgame.ds.triRGBA[2] = b * (1.0f / 255.0f);

	movzx	edx, BYTE PTR _b$[ebp]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _clgame[eax+122700], xmm0

; 2992 : 	clgame.ds.triRGBA[3] = a * (1.0f / 255.0f);

	movzx	ecx, BYTE PTR _a$[ebp]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	imul	eax, edx, 3
	movss	DWORD PTR _clgame[eax+122700], xmm0

; 2993 : 
; 2994 : 	pglColor4f( clgame.ds.triRGBA[0], clgame.ds.triRGBA[1], clgame.ds.triRGBA[2], 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR _clgame[ecx+122700]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _clgame[edx+122700]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _clgame[ecx+122700]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 2995 : }

	pop	ebp
	ret	0
_TriColor4ub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_retval$ = -4						; size = 4
_world$ = 8						; size = 4
_screen$ = 12						; size = 4
_TriWorldToScreen PROC

; 3098 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3099 : 	int	retval;
; 3100 : 
; 3101 : 	retval = R_WorldToScreen( world, screen );

	mov	eax, DWORD PTR _screen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _world$[ebp]
	push	ecx
	call	_R_WorldToScreen
	add	esp, 8
	mov	DWORD PTR _retval$[ebp], eax

; 3102 : 
; 3103 : 	screen[0] =  0.5f * screen[0] * (float)clgame.viewport[2];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm1, DWORD PTR _clgame[edx+122640]
	mulss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 3104 : 	screen[1] = -0.5f * screen[1] * (float)clgame.viewport[3];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR __real@bf000000
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	imul	eax, edx, 3
	cvtsi2ss xmm1, DWORD PTR _clgame[eax+122640]
	mulss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 3105 : 	screen[0] += 0.5f * (float)clgame.viewport[2];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm0, DWORD PTR _clgame[edx+122640]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _screen$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3106 : 	screen[1] += 0.5f * (float)clgame.viewport[3];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 3
	cvtsi2ss xmm0, DWORD PTR _clgame[eax+122640]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _screen$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 3107 : 
; 3108 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 3109 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_TriWorldToScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_rendermode$ = 24					; size = 4
_TriColor4fRendermode PROC

; 3206 : {

	push	ebp
	mov	ebp, esp

; 3207 : 	if( clgame.ds.renderMode == kRenderTransAlpha )

	cmp	DWORD PTR _clgame+122684, 4
	jne	SHORT $LN2@TriColor4f

; 3208 : 	{
; 3209 : 		clgame.ds.triRGBA[3] = a / 255.0f;

	movss	xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR _clgame[ecx+122700], xmm0

; 3210 : 		pglColor4f( r, g, b, a );

	push	ecx
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3211 : 	}

	jmp	SHORT $LN3@TriColor4f
$LN2@TriColor4f:

; 3212 : 	else pglColor4f( r * a, g * a, b * a, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN3@TriColor4f:

; 3213 : }

	pop	ebp
	ret	0
_TriColor4fRendermode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_gl_texturenum$ = -4					; size = 4
_pSpriteModel$ = 8					; size = 4
_frame$ = 12						; size = 4
_TriSpriteTexture PROC

; 3076 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3077 : 	int	gl_texturenum;
; 3078 : 
; 3079 : 	if(( gl_texturenum = R_GetSpriteTexture( pSpriteModel, frame )) == 0 )

	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSpriteModel$[ebp]
	push	ecx
	call	_R_GetSpriteTexture
	add	esp, 8
	mov	DWORD PTR _gl_texturenum$[ebp], eax
	cmp	DWORD PTR _gl_texturenum$[ebp], 0
	jne	SHORT $LN2@TriSpriteT

; 3080 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@TriSpriteT
$LN2@TriSpriteT:

; 3081 : 
; 3082 : 	if( gl_texturenum <= 0 || gl_texturenum > MAX_TEXTURES )

	cmp	DWORD PTR _gl_texturenum$[ebp], 0
	jle	SHORT $LN4@TriSpriteT
	cmp	DWORD PTR _gl_texturenum$[ebp], 4096	; 00001000H
	jle	SHORT $LN3@TriSpriteT
$LN4@TriSpriteT:

; 3083 : 		gl_texturenum = tr.defaultTexture;

	mov	edx, DWORD PTR _tr
	mov	DWORD PTR _gl_texturenum$[ebp], edx
$LN3@TriSpriteT:

; 3084 : 
; 3085 : 	GL_Bind( GL_TEXTURE0, gl_texturenum );

	mov	eax, DWORD PTR _gl_texturenum$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 3086 : 
; 3087 : 	return 1;

	mov	eax, 1
$LN1@TriSpriteT:

; 3088 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_TriSpriteTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_TriColor4f PROC

; 2970 : {

	push	ebp
	mov	ebp, esp

; 2971 : 	if( clgame.ds.renderMode == kRenderTransAlpha )

	cmp	DWORD PTR _clgame+122684, 4
	jne	SHORT $LN2@TriColor4f

; 2972 : 		pglColor4ub( r * 255.9f, g * 255.9f, b * 255.9f, a * 255.0f );

	movss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	movzx	ecx, al
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	cvttss2si edx, xmm0
	movzx	eax, dl
	push	eax
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	cvttss2si ecx, xmm0
	movzx	edx, cl
	push	edx
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	cvttss2si eax, xmm0
	movzx	ecx, al
	push	ecx
	call	DWORD PTR _pglColor4ub
	jmp	SHORT $LN3@TriColor4f
$LN2@TriColor4f:

; 2973 : 	else pglColor4f( r * a, g * a, b * a, 1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN3@TriColor4f:

; 2974 : 
; 2975 : 	clgame.ds.triRGBA[0] = r;

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _clgame[eax+122700], xmm0

; 2976 : 	clgame.ds.triRGBA[1] = g;

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR _clgame[ecx+122700], xmm0

; 2977 : 	clgame.ds.triRGBA[2] = b;

	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR _clgame[edx+122700], xmm0

; 2978 : 	clgame.ds.triRGBA[3] = a;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR _clgame[ecx+122700], xmm0

; 2979 : }

	pop	ebp
	ret	0
_TriColor4f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_TriBoxInPVS PROC

; 3174 : {

	push	ebp
	mov	ebp, esp

; 3175 : 	return Mod_BoxVisible( mins, maxs, Mod_GetCurrentVis( ));

	call	_Mod_GetCurrentVis
	push	eax
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_Mod_BoxVisible
	add	esp, 12					; 0000000cH

; 3176 : }

	pop	ebp
	ret	0
_TriBoxInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_TriVertex3f PROC

; 3026 : {

	push	ebp
	mov	ebp, esp

; 3027 : 	pglVertex3f( x, y, z );

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex3f

; 3028 : }

	pop	ebp
	ret	0
_TriVertex3f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_v$ = 8							; size = 4
_TriVertex3fv PROC

; 3015 : {

	push	ebp
	mov	ebp, esp

; 3016 : 	pglVertex3fv( v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 3017 : }

	pop	ebp
	ret	0
_TriVertex3fv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_TriTexCoord2f PROC

; 3004 : {

	push	ebp
	mov	ebp, esp

; 3005 : 	pglTexCoord2f( u, v );

	push	ecx
	movss	xmm0, DWORD PTR _v$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 3006 : }

	pop	ebp
	ret	0
_TriTexCoord2f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_mode$ = 8						; size = 4
_TriBegin PROC

; 2919 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2920 : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 7
	ja	SHORT $LN11@TriBegin
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN13@TriBegin[ecx*4]
$LN4@TriBegin:

; 2921 : 	{
; 2922 : 	case TRI_POINTS:
; 2923 : 		mode = GL_POINTS;

	mov	DWORD PTR _mode$[ebp], 0

; 2924 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN5@TriBegin:

; 2925 : 	case TRI_TRIANGLES:
; 2926 : 		mode = GL_TRIANGLES;

	mov	DWORD PTR _mode$[ebp], 4

; 2927 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN6@TriBegin:

; 2928 : 	case TRI_TRIANGLE_FAN:
; 2929 : 		mode = GL_TRIANGLE_FAN;

	mov	DWORD PTR _mode$[ebp], 6

; 2930 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN7@TriBegin:

; 2931 : 	case TRI_QUADS:
; 2932 : 		mode = GL_QUADS;

	mov	DWORD PTR _mode$[ebp], 7

; 2933 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN8@TriBegin:

; 2934 : 	case TRI_LINES:
; 2935 : 		mode = GL_LINES;

	mov	DWORD PTR _mode$[ebp], 1

; 2936 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN9@TriBegin:

; 2937 : 	case TRI_TRIANGLE_STRIP:
; 2938 : 		mode = GL_TRIANGLE_STRIP;

	mov	DWORD PTR _mode$[ebp], 5

; 2939 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN10@TriBegin:

; 2940 : 	case TRI_QUAD_STRIP:
; 2941 : 		mode = GL_QUAD_STRIP;

	mov	DWORD PTR _mode$[ebp], 8

; 2942 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN11@TriBegin:

; 2943 : 	case TRI_POLYGON:
; 2944 : 	default:	mode = GL_POLYGON;

	mov	DWORD PTR _mode$[ebp], 9
$LN2@TriBegin:

; 2945 : 		break;
; 2946 : 	}
; 2947 : 
; 2948 : 	pglBegin( mode );

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	call	DWORD PTR _pglBegin

; 2949 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@TriBegin:
	DD	$LN5@TriBegin
	DD	$LN6@TriBegin
	DD	$LN7@TriBegin
	DD	$LN11@TriBegin
	DD	$LN8@TriBegin
	DD	$LN9@TriBegin
	DD	$LN10@TriBegin
	DD	$LN4@TriBegin
_TriBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_entityType$ = 8					; size = 4
_pEnt$ = 12						; size = 4
_CL_AddEntity PROC

; 2550 : {

	push	ebp
	mov	ebp, esp

; 2551 : 	if( !pEnt ) return false;

	cmp	DWORD PTR _pEnt$[ebp], 0
	jne	SHORT $LN2@CL_AddEnti
	xor	eax, eax
	jmp	SHORT $LN1@CL_AddEnti
$LN2@CL_AddEnti:

; 2552 : 
; 2553 : 	// clear effects for all temp entities
; 2554 : 	if( !pEnt->index ) pEnt->curstate.effects = 0;

	mov	eax, DWORD PTR _pEnt$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@CL_AddEnti
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	DWORD PTR [ecx+748], 0
$LN3@CL_AddEnti:

; 2555 : 
; 2556 : 	// let the render reject entity without model
; 2557 : 	return CL_AddVisibleEntity( pEnt, entityType );

	mov	edx, DWORD PTR _entityType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEnt$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8
$LN1@CL_AddEnti:

; 2558 : }

	pop	ebp
	ret	0
_CL_AddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 853  : {

	push	ebp
	mov	ebp, esp

; 854  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1012
	jge	SHORT $LN2@CL_EDICT_N

; 855  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3000
	add	eax, DWORD PTR _clgame+1000
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 856  : 
; 857  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 858  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 859  : }

	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv68 = -8						; size = 4
tv67 = -4						; size = 4
_hull$ = 8						; size = 4
_CL_SetTraceHull PROC

; 2444 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2445 : 	clgame.pmove->usehull = bound( 0, hull, 3 );

	cmp	DWORD PTR _hull$[ebp], 0
	jl	SHORT $LN5@CL_SetTrac
	cmp	DWORD PTR _hull$[ebp], 3
	jge	SHORT $LN3@CL_SetTrac
	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@CL_SetTrac
$LN3@CL_SetTrac:
	mov	DWORD PTR tv67[ebp], 3
$LN4@CL_SetTrac:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN6@CL_SetTrac
$LN5@CL_SetTrac:
	mov	DWORD PTR tv68[ebp], 0
$LN6@CL_SetTrac:
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR [edx+188], eax

; 2446 : 
; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetTraceHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
$T1 = -68						; size = 68
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_traceFlags$ = 16					; size = 4
_pfnIgnore$ = 20					; size = 4
_tr$ = 24						; size = 4
_CL_PlayerTraceExt PROC

; 2468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi

; 2469 : 	if( !tr ) return;

	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN2@CL_PlayerT
	jmp	SHORT $LN1@CL_PlayerT
$LN2@CL_PlayerT:

; 2470 : 	*tr = PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, -1, pfnIgnore );

	mov	eax, DWORD PTR _pfnIgnore$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR _tr$[ebp]
	rep movsd
$LN1@CL_PlayerT:

; 2471 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerTraceExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
$T1 = -68						; size = 68
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_traceFlags$ = 16					; size = 4
_ignore_pe$ = 20					; size = 4
_tr$ = 24						; size = 4
_CL_PlayerTrace PROC

; 2456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi

; 2457 : 	if( !tr ) return;

	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN2@CL_PlayerT
	jmp	SHORT $LN1@CL_PlayerT
$LN2@CL_PlayerT:

; 2458 : 	*tr = PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR _tr$[ebp]
	rep movsd
$LN1@CL_PlayerT:

; 2459 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv79 = -32						; size = 4
tv78 = -28						; size = 4
tv75 = -24						; size = 4
tv74 = -20						; size = 4
tv71 = -16						; size = 4
tv70 = -12						; size = 4
tv67 = -8						; size = 4
tv66 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_r$ = 24						; size = 4
_g$ = 28						; size = 4
_b$ = 32						; size = 4
_a$ = 36						; size = 4
_CL_FillRGBA PROC

; 1581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1582 : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@CL_FillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@CL_FillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_FillRGB
$LN3@CL_FillRGB:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@CL_FillRGB:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_FillRGB
$LN5@CL_FillRGB:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_FillRGB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 1583 : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@CL_FillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@CL_FillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@CL_FillRGB
$LN7@CL_FillRGB:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@CL_FillRGB:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@CL_FillRGB
$LN9@CL_FillRGB:
	mov	DWORD PTR tv71[ebp], 0
$LN10@CL_FillRGB:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 1584 : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@CL_FillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@CL_FillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@CL_FillRGB
$LN11@CL_FillRGB:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@CL_FillRGB:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@CL_FillRGB
$LN13@CL_FillRGB:
	mov	DWORD PTR tv75[ebp], 0
$LN14@CL_FillRGB:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 1585 : 	a = bound( 0, a, 255 );

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN17@CL_FillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN15@CL_FillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN16@CL_FillRGB
$LN15@CL_FillRGB:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN16@CL_FillRGB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN18@CL_FillRGB
$LN17@CL_FillRGB:
	mov	DWORD PTR tv79[ebp], 0
$LN18@CL_FillRGB:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 1586 : 
; 1587 : 	SPR_AdjustSize( (float *)&x, (float *)&y, (float *)&w, (float *)&h );

	lea	eax, DWORD PTR _h$[ebp]
	push	eax
	lea	ecx, DWORD PTR _w$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_AdjustSize
	add	esp, 16					; 00000010H

; 1588 : 
; 1589 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1590 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1591 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1592 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1593 : 	pglColor4f( r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f );

	cvtsi2ss xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _b$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _g$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _r$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1594 : 
; 1595 : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 1596 : 		pglVertex2f( x, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1597 : 		pglVertex2f( x + w, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1598 : 		pglVertex2f( x + w, y + h );

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1599 : 		pglVertex2f( x, y + h );

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1600 : 	pglEnd ();

	call	DWORD PTR _pglEnd

; 1601 : 
; 1602 : 	pglColor3f( 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 1603 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1604 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1605 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FillRGBA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_yscale$ = -8						; size = 4
_xscale$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_PicAdjustSize PROC

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 400  : 	float	xscale, yscale;
; 401  : 
; 402  : 	if( !clgame.ds.adjust_size ) return;

	cmp	DWORD PTR _clgame+122680, 0
	jne	SHORT $LN2@PicAdjustS
	jmp	$LN7@PicAdjustS
$LN2@PicAdjustS:

; 403  : 	if( !x && !y && !w && !h ) return;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	jmp	$LN7@PicAdjustS
$LN3@PicAdjustS:

; 404  : 
; 405  : 	// scale for screen sizes
; 406  : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+124888
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 407  : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+124892
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 408  : 
; 409  : 	if( x ) *x *= xscale;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN4@PicAdjustS
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN4@PicAdjustS:

; 410  : 	if( y ) *y *= yscale;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN5@PicAdjustS
	mov	edx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN5@PicAdjustS:

; 411  : 	if( w ) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN6@PicAdjustS
	mov	ecx, DWORD PTR _w$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN6@PicAdjustS:

; 412  : 	if( h ) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN7@PicAdjustS
	mov	eax, DWORD PTR _h$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN7@PicAdjustS:

; 413  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PicAdjustSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_spr$ = -4						; size = 4
_szPicName$ = 8						; size = 4
_texFlags$ = 12						; size = 4
_pfnSPR_LoadExt PROC

; 1321 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1322 : 	model_t	*spr;
; 1323 : 
; 1324 : 	if(( spr = CL_LoadSpriteModel( szPicName, SPR_CLIENT, texFlags )) == NULL )

	mov	eax, DWORD PTR _texFlags$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _szPicName$[ebp]
	push	ecx
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _spr$[ebp], eax
	cmp	DWORD PTR _spr$[ebp], 0
	jne	SHORT $LN2@pfnSPR_Loa

; 1325 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnSPR_Loa
$LN2@pfnSPR_Loa:

; 1326 : 
; 1327 : 	return (spr - clgame.sprites); // return index

	mov	eax, DWORD PTR _spr$[ebp]
	sub	eax, OFFSET _clgame+22288
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
$LN1@pfnSPR_Loa:

; 1328 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_LoadExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_spr$ = -4						; size = 4
_szPicName$ = 8						; size = 4
_pfnSPR_Load PROC

; 1337 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1338 : 	model_t	*spr;
; 1339 : 
; 1340 : 	if(( spr = CL_LoadSpriteModel( szPicName, SPR_HUDSPRITE, 0 )) == NULL )

	push	0
	push	1
	mov	eax, DWORD PTR _szPicName$[ebp]
	push	eax
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _spr$[ebp], eax
	cmp	DWORD PTR _spr$[ebp], 0
	jne	SHORT $LN2@pfnSPR_Loa

; 1341 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnSPR_Loa
$LN2@pfnSPR_Loa:

; 1342 : 
; 1343 : 	return (spr - clgame.sprites); // return index

	mov	eax, DWORD PTR _spr$[ebp]
	sub	eax, OFFSET _clgame+22288
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
$LN1@pfnSPR_Loa:

; 1344 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_modelname$ = 8						; size = 4
_index$ = 12						; size = 4
_CL_LoadModel PROC

; 2536 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2537 : 	int	i;
; 2538 : 
; 2539 : 	if( index ) *index = -1;

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN2@CL_LoadMod
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], -1
$LN2@CL_LoadMod:

; 2540 : 
; 2541 : 	if(( i = CL_FindModelIndex( modelname )) == 0 )

	mov	ecx, DWORD PTR _modelname$[ebp]
	push	ecx
	call	_CL_FindModelIndex
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@CL_LoadMod

; 2542 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_LoadMod
$LN3@CL_LoadMod:

; 2543 : 
; 2544 : 	if( index ) *index = i;

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN4@CL_LoadMod
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@CL_LoadMod:

; 2545 : 
; 2546 : 	return CL_ModelHandle( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
$LN1@CL_LoadMod:

; 2547 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_CL_LoadClientSprite PROC

; 1304 : {

	push	ebp
	mov	ebp, esp

; 1305 : 	return CL_LoadSpriteModel( filename, SPR_CLIENT, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH

; 1306 : }

	pop	ebp
	ret	0
_CL_LoadClientSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_player$ = -8						; size = 4
tv72 = -4						; size = 4
_CL_GetLocalPlayer PROC

; 790  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 791  : 	cl_entity_t	*player;
; 792  : 
; 793  : 	player = CL_EDICT_NUM( cl.playernum + 1 );

	mov	eax, DWORD PTR _cl+1568828
	add	eax, 1
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax

; 794  : 	Assert( player != NULL );

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN3@CL_GetLoca
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@CL_GetLoca
$LN3@CL_GetLoca:
	mov	DWORD PTR tv72[ebp], 0
$LN4@CL_GetLoca:
	push	0
	push	794					; 0000031aH
	push	OFFSET $SG146586
	push	OFFSET $SG146587
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 795  : 
; 796  : 	return player;

	mov	eax, DWORD PTR _player$[ebp]

; 797  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetLocalPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_filepath$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_CL_FindModelIndex PROC

; 2309 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2310 : 	char		filepath[MAX_QPATH];
; 2311 : 	static float	lasttimewarn;
; 2312 : 	int		i;
; 2313 : 
; 2314 : 	if( !COM_CheckString( m ))

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_FindMod

; 2315 : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_FindMod
$LN5@CL_FindMod:

; 2316 : 
; 2317 : 	Q_strncpy( filepath, m, sizeof( filepath ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2318 : 	COM_FixSlashes( filepath );

	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 2319 : 
; 2320 : 	for( i = 0; i < cl.nummodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FindMod
$LN2@CL_FindMod:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_FindMod:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cl+1939788
	jge	SHORT $LN3@CL_FindMod

; 2321 : 	{
; 2322 : 		if( !cl.models[i+1] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _cl[eax*4+1935692], 0
	jne	SHORT $LN6@CL_FindMod

; 2323 : 			continue;

	jmp	SHORT $LN2@CL_FindMod
$LN6@CL_FindMod:

; 2324 : 
; 2325 : 		if( !Q_stricmp( cl.models[i+1]->name, filepath ))

	push	99999					; 0001869fH
	lea	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cl[edx*4+1935692]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@CL_FindMod

; 2326 : 			return i+1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	jmp	SHORT $LN1@CL_FindMod
$LN7@CL_FindMod:

; 2327 : 	}

	jmp	SHORT $LN2@CL_FindMod
$LN3@CL_FindMod:

; 2328 : 
; 2329 : 	if( lasttimewarn < host.realtime )

	cvtss2sd xmm0, DWORD PTR ?lasttimewarn@?1??CL_FindModelIndex@@9@9
	movsd	xmm1, QWORD PTR _host+1440
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@CL_FindMod

; 2330 : 	{
; 2331 : 		// tell user about problem (but don't spam console)
; 2332 : 		Con_Printf( S_ERROR "%s not precached\n", filepath );

	lea	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	push	OFFSET $SG147310
	call	_Con_Printf
	add	esp, 8

; 2333 : 		lasttimewarn = host.realtime + 1.0f;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR ?lasttimewarn@?1??CL_FindModelIndex@@9@9, xmm0
$LN8@CL_FindMod:

; 2334 : 	}
; 2335 : 
; 2336 : 	return 0;

	xor	eax, eax
$LN1@CL_FindMod:

; 2337 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindModelIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_nr$ = -4						; size = 4
_NetAPI_CancelAllRequests PROC

; 3445 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3446 : 	net_request_t	*nr;
; 3447 : 	int		i;
; 3448 : 
; 3449 : 	// tell the user about cancel
; 3450 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NetAPI_Can
$LN2@NetAPI_Can:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NetAPI_Can:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@NetAPI_Can

; 3451 : 	{
; 3452 : 		nr = &clgame.net_requests[i];

	imul	ecx, DWORD PTR _i$[ebp], 80
	add	ecx, OFFSET _clgame+144672
	mov	DWORD PTR _nr$[ebp], ecx

; 3453 : 		if( !nr->pfnFunc ) continue;	// not used

	mov	edx, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN5@NetAPI_Can
	jmp	SHORT $LN2@NetAPI_Can
$LN5@NetAPI_Can:

; 3454 : 		SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [edx], ecx

; 3455 : 		nr->resp.ping = host.realtime - nr->timesend;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+64]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+32], xmm0

; 3456 : 		nr->pfnFunc( &nr->resp );

	mov	edx, DWORD PTR _nr$[ebp]
	push	edx
	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	add	esp, 4

; 3457 : 	}

	jmp	SHORT $LN2@NetAPI_Can
$LN3@NetAPI_Can:

; 3458 : 
; 3459 : 	memset( clgame.net_requests, 0, sizeof( clgame.net_requests ));

	push	5120					; 00001400H
	push	0
	push	OFFSET _clgame+144672
	call	_memset
	add	esp, 12					; 0000000cH

; 3460 : 	clgame.request_type = NET_REQUEST_CANCEL;

	mov	DWORD PTR _clgame+144668, 0

; 3461 : 	clgame.master_request = NULL;

	mov	DWORD PTR _clgame+149792, 0

; 3462 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_CancelAllRequests ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_modelindex$ = 8					; size = 4
_CL_ModelHandle PROC

; 125  : {

	push	ebp
	mov	ebp, esp

; 126  : 	if( modelindex < 0 || modelindex >= MAX_MODELS )

	cmp	DWORD PTR _modelindex$[ebp], 0
	jl	SHORT $LN3@CL_ModelHa
	cmp	DWORD PTR _modelindex$[ebp], 1024	; 00000400H
	jl	SHORT $LN2@CL_ModelHa
$LN3@CL_ModelHa:

; 127  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_ModelHa
$LN2@CL_ModelHa:

; 128  : 	return cl.models[modelindex];

	mov	eax, DWORD PTR _modelindex$[ebp]
	mov	eax, DWORD PTR _cl[eax*4+1935688]
$LN1@CL_ModelHa:

; 129  : }

	pop	ebp
	ret	0
_CL_ModelHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pTrace$ = 8						; size = 4
_pfnIndexFromTrace PROC

; 2396 : {

	push	ebp
	mov	ebp, esp

; 2397 : 	if( pTrace->ent >= 0 && pTrace->ent < clgame.pmove->numphysent )

	mov	eax, DWORD PTR _pTrace$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jl	SHORT $LN2@pfnIndexFr
	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, DWORD PTR [edx+588]
	jge	SHORT $LN2@pfnIndexFr

; 2398 : 	{
; 2399 : 		// return cl.entities number
; 2400 : 		return clgame.pmove->physents[pTrace->ent].info;

	mov	ecx, DWORD PTR _pTrace$[ebp]
	imul	edx, DWORD PTR [ecx+48], 224
	mov	eax, DWORD PTR _clgame+1316
	mov	eax, DWORD PTR [eax+edx+672]
	jmp	SHORT $LN1@pfnIndexFr
$LN2@pfnIndexFr:

; 2401 : 	}
; 2402 : 	return -1;

	or	eax, -1
$LN1@pfnIndexFr:

; 2403 : }

	pop	ebp
	ret	0
_pfnIndexFromTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pName$ = 8						; size = 4
_CL_TextMessageGet PROC

; 1818 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1819 : 	int	i;
; 1820 : 
; 1821 : 	// first check internal messages
; 1822 : 	for( i = 0; i < MAX_TEXTCHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_TextMes
$LN2@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_TextMes:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN3@CL_TextMes

; 1823 : 	{
; 1824 : 		if( !Q_strcmp( pName, va( TEXT_MSGNAME, i )))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET $SG147066
	call	_va
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@CL_TextMes

; 1825 : 			return cl_textmessage + i;

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _cl_textmessage
	jmp	SHORT $LN1@CL_TextMes
$LN8@CL_TextMes:

; 1826 : 	}

	jmp	SHORT $LN2@CL_TextMes
$LN3@CL_TextMes:

; 1827 : 
; 1828 : 	// find desired message
; 1829 : 	for( i = 0; i < clgame.numTitles; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_TextMes
$LN5@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_TextMes:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _clgame+144664
	jge	SHORT $LN6@CL_TextMes

; 1830 : 	{
; 1831 : 		if( !Q_stricmp( pName, clgame.titles[i].pName ))

	push	99999					; 0001869fH
	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _clgame+144660
	mov	ecx, DWORD PTR [eax+edx+36]
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_TextMes

; 1832 : 			return clgame.titles + i;

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, DWORD PTR _clgame+144660
	jmp	SHORT $LN1@CL_TextMes
$LN9@CL_TextMes:

; 1833 : 	}

	jmp	SHORT $LN5@CL_TextMes
$LN6@CL_TextMes:

; 1834 : 	return NULL; // found nothing

	xor	eax, eax
$LN1@CL_TextMes:

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TextMessageGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_length$ = -12						; size = 4
_s$ = -8						; size = 4
_width$ = -4						; size = 4
_text$ = 8						; size = 4
_y$ = 12						; size = 4
_CL_CenterPrint PROC

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 336  : 	int	length = 0;

	mov	DWORD PTR _length$[ebp], 0

; 337  : 	int	width = 0;

	mov	DWORD PTR _width$[ebp], 0

; 338  : 	char	*s;
; 339  : 
; 340  : 	if( !COM_CheckString( text ))

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@CL_CenterP

; 341  : 		return;

	jmp	$LN1@CL_CenterP
$LN4@CL_CenterP:

; 342  : 
; 343  : 	clgame.centerPrint.lines = 1;

	mov	DWORD PTR _clgame+122824, 1

; 344  : 	clgame.centerPrint.totalWidth = 0;

	mov	DWORD PTR _clgame+124876, 0

; 345  : 	clgame.centerPrint.time = cl.mtime[0]; // allow pause for centerprint

	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[edx+32]
	movss	DWORD PTR _clgame+122816, xmm0

; 346  : 	Q_strncpy( clgame.centerPrint.message, text, sizeof( clgame.centerPrint.message ));

	push	2048					; 00000800H
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _clgame+122828
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 347  : 	s = clgame.centerPrint.message;

	mov	DWORD PTR _s$[ebp], OFFSET _clgame+122828
$LN2@CL_CenterP:

; 348  : 
; 349  : 	// count the number of lines for centering
; 350  : 	while( *s )

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@CL_CenterP

; 351  : 	{
; 352  : 		if( *s == '\n' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN5@CL_CenterP

; 353  : 		{
; 354  : 			clgame.centerPrint.lines++;

	mov	edx, DWORD PTR _clgame+122824
	add	edx, 1
	mov	DWORD PTR _clgame+122824, edx

; 355  : 			if( width > clgame.centerPrint.totalWidth )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _clgame+124876
	jle	SHORT $LN7@CL_CenterP

; 356  : 				clgame.centerPrint.totalWidth = width;

	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _clgame+124876, ecx
$LN7@CL_CenterP:

; 357  : 			width = 0;

	mov	DWORD PTR _width$[ebp], 0

; 358  : 		}

	jmp	SHORT $LN6@CL_CenterP
$LN5@CL_CenterP:

; 359  : 		else width += clgame.scrInfo.charWidths[*s];

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, WORD PTR _clgame[eax*2+124904]
	add	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], ecx
$LN6@CL_CenterP:

; 360  : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 361  : 		length++;

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 362  : 	}

	jmp	SHORT $LN2@CL_CenterP
$LN3@CL_CenterP:

; 363  : 
; 364  : 	clgame.centerPrint.totalHeight = ( clgame.centerPrint.lines * clgame.scrInfo.iCharHeight ); 

	mov	ecx, DWORD PTR _clgame+122824
	imul	ecx, DWORD PTR _clgame+124900
	mov	DWORD PTR _clgame+124880, ecx

; 365  : 	clgame.centerPrint.y = CL_AdjustYPos( y, clgame.centerPrint.totalHeight );

	mov	edx, DWORD PTR _clgame+124880
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_CL_AdjustYPos
	add	esp, 8
	mov	DWORD PTR _clgame+122820, eax
$LN1@CL_CenterP:

; 366  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CenterPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_pEdict$ = 8						; size = 4
_CL_FreeEntity PROC

; 1083 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1084 : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN3@CL_FreeEnt
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@CL_FreeEnt
$LN3@CL_FreeEnt:
	mov	DWORD PTR tv69[ebp], 0
$LN4@CL_FreeEnt:
	push	0
	push	1084					; 0000043cH
	push	OFFSET $SG146706
	push	OFFSET $SG146707
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1085 : 	R_RemoveEfrags( pEdict );

	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_R_RemoveEfrags
	add	esp, 4

; 1086 : 	CL_KillDeadBeams( pEdict );

	mov	edx, DWORD PTR _pEdict$[ebp]
	push	edx
	call	_CL_KillDeadBeams
	add	esp, 4

; 1087 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearSpriteTextures PROC

; 1174 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1175 : 	int	i;
; 1176 : 
; 1177 : 	for( i = 1; i < MAX_CLIENT_SPRITES; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_ClearSp
$LN2@CL_ClearSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearSp:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@CL_ClearSp

; 1178 : 		clgame.sprites[i].needload = NL_UNREFERENCED;

	imul	ecx, DWORD PTR _i$[ebp], 392
	mov	DWORD PTR _clgame[ecx+22352], 0
	jmp	SHORT $LN2@CL_ClearSp
$LN1@CL_ClearSp:

; 1179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearSpriteTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_charHeight$ = -132					; size = 4
_colorDefault$ = -128					; size = 4
_charWidth$ = -124					; size = 4
$T1 = -120						; size = 4
_width$ = -116						; size = 4
_i$ = -112						; size = 4
_y$ = -108						; size = 4
_j$ = -104						; size = 4
_x$ = -100						; size = 4
_pText$ = -96						; size = 4
_lineLength$ = -92					; size = 4
_c$2 = -85						; size = 1
_line$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_CL_DrawCenterPrint PROC

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 534  : 	char	*pText;
; 535  : 	int	i, j, x, y;
; 536  : 	int	width, lineLength;
; 537  : 	byte	*colorDefault, line[MAX_LINELENGTH];
; 538  : 	int	charWidth, charHeight;
; 539  : 
; 540  : 	if( !clgame.centerPrint.time )

	movss	xmm0, DWORD PTR _clgame+122816
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_DrawCen

; 541  : 		return;

	jmp	$LN3@CL_DrawCen
$LN10@CL_DrawCen:

; 542  : 
; 543  : 	if(( cl.time - clgame.centerPrint.time ) >= scr_centertime->value )

	cvtss2sd xmm0, DWORD PTR _clgame+122816
	movsd	xmm1, QWORD PTR _cl+1525848
	subsd	xmm1, xmm0
	mov	eax, DWORD PTR _scr_centertime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	comisd	xmm1, xmm0
	jb	SHORT $LN11@CL_DrawCen

; 544  : 	{
; 545  : 		// time expired
; 546  : 		clgame.centerPrint.time = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _clgame+122816, xmm0

; 547  : 		return;

	jmp	$LN3@CL_DrawCen
$LN11@CL_DrawCen:

; 548  : 	}
; 549  : 
; 550  : 	y = clgame.centerPrint.y; // start y

	mov	ecx, DWORD PTR _clgame+122820
	mov	DWORD PTR _y$[ebp], ecx

; 551  : 	colorDefault = g_color_table[7];

	mov	edx, 4
	imul	eax, edx, 7
	add	eax, OFFSET _g_color_table
	mov	DWORD PTR _colorDefault$[ebp], eax

; 552  : 	pText = clgame.centerPrint.message;

	mov	DWORD PTR _pText$[ebp], OFFSET _clgame+122828

; 553  : 	Con_DrawCharacterLen( 0, NULL, &charHeight );

	lea	ecx, DWORD PTR _charHeight$[ebp]
	push	ecx
	push	0
	push	0
	call	_Con_DrawCharacterLen
	add	esp, 12					; 0000000cH

; 554  : 	
; 555  : 	for( i = 0; i < clgame.centerPrint.lines; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_DrawCen
$LN2@CL_DrawCen:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_DrawCen:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _clgame+122824
	jge	$LN3@CL_DrawCen

; 556  : 	{
; 557  : 		lineLength = 0;

	mov	DWORD PTR _lineLength$[ebp], 0

; 558  : 		width = 0;

	mov	DWORD PTR _width$[ebp], 0
$LN5@CL_DrawCen:

; 559  : 
; 560  : 		while( *pText && *pText != '\n' && lineLength < MAX_LINELENGTH )

	mov	ecx, DWORD PTR _pText$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN6@CL_DrawCen
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN6@CL_DrawCen
	cmp	DWORD PTR _lineLength$[ebp], 80		; 00000050H
	jge	SHORT $LN6@CL_DrawCen

; 561  : 		{
; 562  : 			byte c = *pText;

	mov	edx, DWORD PTR _pText$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _c$2[ebp], al

; 563  : 			line[lineLength] = c;

	mov	ecx, DWORD PTR _lineLength$[ebp]
	mov	dl, BYTE PTR _c$2[ebp]
	mov	BYTE PTR _line$[ebp+ecx], dl

; 564  : 			Con_DrawCharacterLen( c, &charWidth, NULL );

	push	0
	lea	eax, DWORD PTR _charWidth$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _c$2[ebp]
	push	ecx
	call	_Con_DrawCharacterLen
	add	esp, 12					; 0000000cH

; 565  : 			width += charWidth;

	mov	edx, DWORD PTR _width$[ebp]
	add	edx, DWORD PTR _charWidth$[ebp]
	mov	DWORD PTR _width$[ebp], edx

; 566  : 			lineLength++;

	mov	eax, DWORD PTR _lineLength$[ebp]
	add	eax, 1
	mov	DWORD PTR _lineLength$[ebp], eax

; 567  : 			pText++;

	mov	ecx, DWORD PTR _pText$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pText$[ebp], ecx

; 568  : 		}

	jmp	SHORT $LN5@CL_DrawCen
$LN6@CL_DrawCen:

; 569  : 
; 570  : 		if( lineLength == MAX_LINELENGTH )

	cmp	DWORD PTR _lineLength$[ebp], 80		; 00000050H
	jne	SHORT $LN12@CL_DrawCen

; 571  : 			lineLength--;

	mov	edx, DWORD PTR _lineLength$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lineLength$[ebp], edx
$LN12@CL_DrawCen:

; 572  : 
; 573  : 		pText++; // Skip LineFeed

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, 1
	mov	DWORD PTR _pText$[ebp], eax

; 574  : 		line[lineLength] = 0;

	mov	ecx, DWORD PTR _lineLength$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 80			; 00000050H
	jae	SHORT $LN15@CL_DrawCen
	jmp	SHORT $LN16@CL_DrawCen
$LN15@CL_DrawCen:
	call	___report_rangecheckfailure
$LN16@CL_DrawCen:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _line$[ebp+edx], 0

; 575  : 
; 576  : 		x = CL_AdjustXPos( -1, width, clgame.centerPrint.totalWidth );

	mov	eax, DWORD PTR _clgame+124876
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_CL_AdjustXPos
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$[ebp], eax

; 577  : 
; 578  : 		for( j = 0; j < lineLength; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@CL_DrawCen
$LN7@CL_DrawCen:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN9@CL_DrawCen:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _lineLength$[ebp]
	jge	SHORT $LN8@CL_DrawCen

; 579  : 		{
; 580  : 			if( x >= 0 && y >= 0 && x <= glState.width )

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN13@CL_DrawCen
	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN13@CL_DrawCen
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR _glState
	jg	SHORT $LN13@CL_DrawCen

; 581  : 				x += Con_DrawCharacter( x, y, line[j], colorDefault );

	mov	edx, DWORD PTR _colorDefault$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR _line$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN13@CL_DrawCen:

; 582  : 		}

	jmp	SHORT $LN7@CL_DrawCen
$LN8@CL_DrawCen:

; 583  : 		y += charHeight;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _charHeight$[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 584  : 	}

	jmp	$LN2@CL_DrawCen
$LN3@CL_DrawCen:

; 585  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawCenterPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_world$ = -4						; size = 4
_CL_ClearWorld PROC

; 1090 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1091 : 	cl_entity_t	*world;
; 1092 : 
; 1093 : 	world = clgame.entities;

	mov	eax, DWORD PTR _clgame+1000
	mov	DWORD PTR _world$[ebp], eax

; 1094 : 	world->curstate.modelindex = 1;	// world model

	mov	ecx, DWORD PTR _world$[ebp]
	mov	DWORD PTR [ecx+728], 1

; 1095 : 	world->curstate.solid = SOLID_BSP;

	mov	edx, 4
	mov	eax, DWORD PTR _world$[ebp]
	mov	WORD PTR [eax+746], dx

; 1096 : 	world->curstate.movetype = MOVETYPE_PUSH;

	mov	ecx, DWORD PTR _world$[ebp]
	mov	DWORD PTR [ecx+776], 7

; 1097 : 	world->model = cl.worldmodel;

	mov	edx, DWORD PTR _world$[ebp]
	mov	eax, DWORD PTR _cl+2686576
	mov	DWORD PTR [edx+2964], eax

; 1098 : 	world->index = 0;

	mov	ecx, DWORD PTR _world$[ebp]
	mov	DWORD PTR [ecx], 0

; 1099 : 
; 1100 : 	clgame.ds.cullMode = GL_FRONT;

	mov	DWORD PTR _clgame+122688, 1028		; 00000404H

; 1101 : 	clgame.numStatics = 0;

	mov	DWORD PTR _clgame+1020, 0

; 1102 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_CL_FreeEdicts PROC

; 1132 : {

	push	ebp
	mov	ebp, esp

; 1133 : 	if( clgame.drawFuncs.R_ProcessEntData != NULL )

	cmp	DWORD PTR _clgame+208, 0
	je	SHORT $LN2@CL_FreeEdi

; 1134 : 	{
; 1135 : 		// let the client.dll free custom data
; 1136 : 		clgame.drawFuncs.R_ProcessEntData( false );

	push	0
	call	DWORD PTR _clgame+208
	add	esp, 4
$LN2@CL_FreeEdi:

; 1137 : 	}
; 1138 : 
; 1139 : 	if( clgame.entities )

	cmp	DWORD PTR _clgame+1000, 0
	je	SHORT $LN3@CL_FreeEdi

; 1140 : 		Mem_Free( clgame.entities );

	push	1140					; 00000474H
	push	OFFSET $SG146739
	mov	eax, DWORD PTR _clgame+1000
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@CL_FreeEdi:

; 1141 : 	clgame.entities = NULL;

	mov	DWORD PTR _clgame+1000, 0

; 1142 : 
; 1143 : 	if( clgame.static_entities )

	cmp	DWORD PTR _clgame+1004, 0
	je	SHORT $LN4@CL_FreeEdi

; 1144 : 		Mem_Free( clgame.static_entities );

	push	1144					; 00000478H
	push	OFFSET $SG146741
	mov	ecx, DWORD PTR _clgame+1004
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@CL_FreeEdi:

; 1145 : 	clgame.static_entities = NULL;

	mov	DWORD PTR _clgame+1004, 0

; 1146 : 
; 1147 : 	if( cls.packet_entities )

	cmp	DWORD PTR _cls+291764, 0
	je	SHORT $LN5@CL_FreeEdi

; 1148 : 		Z_Free( cls.packet_entities );

	cmp	DWORD PTR _cls+291764, 0
	je	SHORT $LN5@CL_FreeEdi
	push	1148					; 0000047cH
	push	OFFSET $SG146744
	mov	edx, DWORD PTR _cls+291764
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@CL_FreeEdi:

; 1149 : 
; 1150 : 	cls.packet_entities = NULL;

	mov	DWORD PTR _cls+291764, 0

; 1151 : 	cls.num_client_entities = 0;

	mov	DWORD PTR _cls+291756, 0

; 1152 : 	cls.next_client_entities = 0;

	mov	DWORD PTR _cls+291760, 0

; 1153 : 	clgame.numStatics = 0;

	mov	DWORD PTR _clgame+1020, 0

; 1154 : }

	pop	ebp
	ret	0
_CL_FreeEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv69 = -4						; size = 4
_CL_InitEdicts PROC

; 1105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1106 : 	Assert( clgame.entities == NULL );

	cmp	DWORD PTR _clgame+1000, 0
	jne	SHORT $LN6@CL_InitEdi
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@CL_InitEdi
$LN6@CL_InitEdi:
	mov	DWORD PTR tv69[ebp], 0
$LN7@CL_InitEdi:
	push	0
	push	1106					; 00000452H
	push	OFFSET $SG146721
	push	OFFSET $SG146722
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1107 : 
; 1108 : 	if( !clgame.mempool ) return; // Host_Error without client

	cmp	DWORD PTR _clgame+228, 0
	jne	SHORT $LN2@CL_InitEdi
	jmp	$LN1@CL_InitEdi
$LN2@CL_InitEdi:

; 1109 : 
; 1110 : 	CL_UPDATE_BACKUP = ( cl.maxclients == 1 ) ? SINGLEPLAYER_BACKUP : MULTIPLAYER_BACKUP;

	cmp	DWORD PTR _cl+1568832, 1
	jne	SHORT $LN8@CL_InitEdi
	mov	DWORD PTR tv73[ebp], 16			; 00000010H
	jmp	SHORT $LN9@CL_InitEdi
$LN8@CL_InitEdi:
	mov	DWORD PTR tv73[ebp], 64			; 00000040H
$LN9@CL_InitEdi:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _CL_UPDATE_BACKUP, ecx

; 1111 : 	cls.num_client_entities = CL_UPDATE_BACKUP * NUM_PACKET_ENTITIES;

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	shl	edx, 8
	mov	DWORD PTR _cls+291756, edx

; 1112 : 	cls.packet_entities = Mem_Realloc( clgame.mempool, cls.packet_entities, sizeof( entity_state_t ) * cls.num_client_entities );

	push	1112					; 00000458H
	push	OFFSET $SG146724
	push	1
	imul	eax, DWORD PTR _cls+291756, 340
	push	eax
	mov	ecx, DWORD PTR _cls+291764
	push	ecx
	mov	edx, DWORD PTR _clgame+228
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _cls+291764, eax

; 1113 : 	clgame.entities = Mem_Calloc( clgame.mempool, sizeof( cl_entity_t ) * clgame.maxEntities );

	push	1113					; 00000459H
	push	OFFSET $SG146725
	push	1
	imul	eax, DWORD PTR _clgame+1012, 3000
	push	eax
	mov	ecx, DWORD PTR _clgame+228
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+1000, eax

; 1114 : 	clgame.static_entities = Mem_Calloc( clgame.mempool, sizeof( cl_entity_t ) * MAX_STATIC_ENTITIES );

	push	1114					; 0000045aH
	push	OFFSET $SG146726
	push	1
	push	9288000					; 008db940H
	mov	edx, DWORD PTR _clgame+228
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+1004, eax

; 1115 : 	clgame.numStatics = 0;

	mov	DWORD PTR _clgame+1020, 0

; 1116 : 
; 1117 : 	if(( clgame.maxRemapInfos - 1 ) != clgame.maxEntities )

	mov	eax, DWORD PTR _clgame+1016
	sub	eax, 1
	cmp	eax, DWORD PTR _clgame+1012
	je	SHORT $LN3@CL_InitEdi

; 1118 : 	{
; 1119 : 		CL_ClearAllRemaps (); // purge old remap info

	call	_CL_ClearAllRemaps

; 1120 : 		clgame.maxRemapInfos = clgame.maxEntities + 1; 

	mov	ecx, DWORD PTR _clgame+1012
	add	ecx, 1
	mov	DWORD PTR _clgame+1016, ecx

; 1121 : 		clgame.remap_info = (remap_info_t **)Mem_Calloc( clgame.mempool, sizeof( remap_info_t* ) * clgame.maxRemapInfos );

	push	1121					; 00000461H
	push	OFFSET $SG146728
	push	1
	mov	edx, DWORD PTR _clgame+1016
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _clgame+228
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+1008, eax
$LN3@CL_InitEdi:

; 1122 : 	}
; 1123 : 
; 1124 : 	if( clgame.drawFuncs.R_ProcessEntData != NULL )

	cmp	DWORD PTR _clgame+208, 0
	je	SHORT $LN1@CL_InitEdi

; 1125 : 	{
; 1126 : 		// let the client.dll free custom data
; 1127 : 		clgame.drawFuncs.R_ProcessEntData( true );

	push	1
	call	DWORD PTR _clgame+208
	add	esp, 4
$LN1@CL_InitEdi:

; 1128 : 	}
; 1129 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv68 = -4						; size = 4
_state$ = 8						; size = 4
_CL_DrawHUD PROC

; 1011 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1012 : 	if( state == CL_ACTIVE && !cl.video_prepped )

	cmp	DWORD PTR _state$[ebp], 2
	jne	SHORT $LN4@CL_DrawHUD
	cmp	DWORD PTR _cl+16, 0
	jne	SHORT $LN4@CL_DrawHUD

; 1013 : 		state = CL_LOADING;

	mov	DWORD PTR _state$[ebp], 1
$LN4@CL_DrawHUD:

; 1014 : 
; 1015 : 	if( state == CL_ACTIVE && cl.paused )

	cmp	DWORD PTR _state$[ebp], 2
	jne	SHORT $LN5@CL_DrawHUD
	cmp	DWORD PTR _cl+24, 0
	je	SHORT $LN5@CL_DrawHUD

; 1016 : 		state = CL_PAUSED;

	mov	DWORD PTR _state$[ebp], 3
$LN5@CL_DrawHUD:

; 1017 : 
; 1018 : 	switch( state )

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN2@CL_DrawHUD
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN14@CL_DrawHUD[edx*4]
$LN6@CL_DrawHUD:

; 1019 : 	{
; 1020 : 	case CL_ACTIVE:
; 1021 : 		if( !cl.intermission )

	cmp	DWORD PTR _cl+1568648, 0
	jne	SHORT $LN7@CL_DrawHUD

; 1022 : 			CL_DrawScreenFade ();

	call	_CL_DrawScreenFade
$LN7@CL_DrawHUD:

; 1023 : 		CL_DrawCrosshair ();

	call	_CL_DrawCrosshair

; 1024 : 		CL_DrawCenterPrint ();

	call	_CL_DrawCenterPrint

; 1025 : 		clgame.dllFuncs.pfnRedraw( cl.time, cl.intermission );

	mov	eax, DWORD PTR _cl+1568648
	push	eax
	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+16
	add	esp, 8

; 1026 : 		if( cl.intermission ) CL_DrawScreenFade ();

	cmp	DWORD PTR _cl+1568648, 0
	je	SHORT $LN8@CL_DrawHUD
	call	_CL_DrawScreenFade
$LN8@CL_DrawHUD:

; 1027 : 		break;

	jmp	SHORT $LN2@CL_DrawHUD
$LN9@CL_DrawHUD:

; 1028 : 	case CL_PAUSED:
; 1029 : 		CL_DrawScreenFade ();

	call	_CL_DrawScreenFade

; 1030 : 		CL_DrawCrosshair ();

	call	_CL_DrawCrosshair

; 1031 : 		CL_DrawCenterPrint ();

	call	_CL_DrawCenterPrint

; 1032 : 		clgame.dllFuncs.pfnRedraw( cl.time, cl.intermission );

	mov	ecx, DWORD PTR _cl+1568648
	push	ecx
	cvtsd2ss xmm0, QWORD PTR _cl+1525848
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+16
	add	esp, 8

; 1033 : 		CL_DrawPause();

	call	_CL_DrawPause

; 1034 : 		break;

	jmp	SHORT $LN2@CL_DrawHUD
$LN10@CL_DrawHUD:

; 1035 : 	case CL_LOADING:
; 1036 : 		CL_DrawLoading( scr_loading->value );

	mov	edx, DWORD PTR _scr_loading
	push	ecx
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR [esp], xmm0
	call	_CL_DrawLoading
	add	esp, 4

; 1037 : 		break;

	jmp	SHORT $LN2@CL_DrawHUD
$LN11@CL_DrawHUD:

; 1038 : 	case CL_CHANGELEVEL:
; 1039 : 		if( cls.draw_changelevel )

	cmp	DWORD PTR _cls+32, 0
	je	SHORT $LN12@CL_DrawHUD

; 1040 : 		{
; 1041 : 			CL_DrawLoading( 100.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	call	_CL_DrawLoading
	add	esp, 4

; 1042 : 			cls.draw_changelevel = false;

	mov	DWORD PTR _cls+32, 0
$LN12@CL_DrawHUD:
$LN2@CL_DrawHUD:

; 1043 : 		}
; 1044 : 		break;
; 1045 : 	}
; 1046 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@CL_DrawHUD:
	DD	$LN10@CL_DrawHUD
	DD	$LN6@CL_DrawHUD
	DD	$LN9@CL_DrawHUD
	DD	$LN11@CL_DrawHUD
_CL_DrawHUD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_channel$ = -8						; size = 4
_text$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseTextMessage PROC

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 693  : 	static int		msgindex = 0;
; 694  : 	client_textmessage_t	*text;
; 695  : 	int			channel;
; 696  : 
; 697  : 	// read channel ( 0 - auto)
; 698  : 	channel = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _channel$[ebp], eax

; 699  : 
; 700  : 	if( channel <= 0 || channel > ( MAX_TEXTCHANNELS - 1 ))

	cmp	DWORD PTR _channel$[ebp], 0
	jle	SHORT $LN3@CL_ParseTe
	cmp	DWORD PTR _channel$[ebp], 7
	jle	SHORT $LN2@CL_ParseTe
$LN3@CL_ParseTe:

; 701  : 	{
; 702  : 		channel = msgindex;

	mov	ecx, DWORD PTR ?msgindex@?1??CL_ParseTextMessage@@9@9
	mov	DWORD PTR _channel$[ebp], ecx

; 703  : 		msgindex = (msgindex + 1) & (MAX_TEXTCHANNELS - 1);

	mov	edx, DWORD PTR ?msgindex@?1??CL_ParseTextMessage@@9@9
	add	edx, 1
	and	edx, 7
	mov	DWORD PTR ?msgindex@?1??CL_ParseTextMessage@@9@9, edx
$LN2@CL_ParseTe:

; 704  : 	}	
; 705  : 
; 706  : 	// grab message channel
; 707  : 	text = &cl_textmessage[channel];

	imul	eax, DWORD PTR _channel$[ebp], 44
	add	eax, OFFSET _cl_textmessage
	mov	DWORD PTR _text$[ebp], eax

; 708  : 
; 709  : 	text->x = (float)(MSG_ReadShort( msg ) / 8192.0f);

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46000000
	mov	edx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [edx+12], xmm0

; 710  : 	text->y = (float)(MSG_ReadShort( msg ) / 8192.0f);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46000000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 711  : 	text->effect = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	DWORD PTR [ecx], eax

; 712  : 	text->r1 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+4], al

; 713  : 	text->g1 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+5], al

; 714  : 	text->b1 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+6], al

; 715  : 	text->a1 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+7], al

; 716  : 	text->r2 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+8], al

; 717  : 	text->g2 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+9], al

; 718  : 	text->b2 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+10], al

; 719  : 	text->a2 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+11], al

; 720  : 	text->fadein = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	eax, DWORD PTR _text$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 721  : 	text->fadeout = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	edx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [edx+24], xmm0

; 722  : 	text->holdtime = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+28], xmm0

; 723  : 
; 724  : 	if( text->effect == 2 )

	mov	edx, DWORD PTR _text$[ebp]
	cmp	DWORD PTR [edx], 2
	jne	SHORT $LN4@CL_ParseTe

; 725  : 		text->fxtime = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
	jmp	SHORT $LN5@CL_ParseTe
$LN4@CL_ParseTe:

; 726  : 	else text->fxtime = 0.0f;

	mov	edx, DWORD PTR _text$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+32], xmm0
$LN5@CL_ParseTe:

; 727  : 
; 728  : 	// to prevent grab too long messages
; 729  : 	Q_strncpy( (char *)text->pMessage, MSG_ReadString( msg ), 2048 ); 		

	push	2048					; 00000800H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 730  : 
; 731  : 	CL_HudMessage( text->pName );

	mov	eax, DWORD PTR _text$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_CL_HudMessage
	add	esp, 4

; 732  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseTextMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_channel$ = -8						; size = 4
_text$ = -4						; size = 4
_msg$ = 8						; size = 4
_level$ = 12						; size = 4
_CL_ParseFinaleCutscene PROC

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 743  : 	static int		msgindex = 0;
; 744  : 	client_textmessage_t	*text;
; 745  : 	int			channel;
; 746  : 
; 747  : 	cl.intermission = level;

	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR _cl+1568648, eax

; 748  : 
; 749  : 	channel = msgindex;

	mov	ecx, DWORD PTR ?msgindex@?1??CL_ParseFinaleCutscene@@9@9
	mov	DWORD PTR _channel$[ebp], ecx

; 750  : 	msgindex = (msgindex + 1) & (MAX_TEXTCHANNELS - 1);

	mov	edx, DWORD PTR ?msgindex@?1??CL_ParseFinaleCutscene@@9@9
	add	edx, 1
	and	edx, 7
	mov	DWORD PTR ?msgindex@?1??CL_ParseFinaleCutscene@@9@9, edx

; 751  : 
; 752  : 	// grab message channel
; 753  : 	text = &cl_textmessage[channel];

	imul	eax, DWORD PTR _channel$[ebp], 44
	add	eax, OFFSET _cl_textmessage
	mov	DWORD PTR _text$[ebp], eax

; 754  : 
; 755  : 	// NOTE: svc_finale and svc_cutscene has a
; 756  : 	// predefined settings like Quake-style
; 757  : 	text->x = -1.0f;

	mov	ecx, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+12], xmm0

; 758  : 	text->y = 0.15f;

	mov	edx, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [edx+16], xmm0

; 759  : 	text->effect = 2;	// scan out effect

	mov	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR [eax], 2

; 760  : 	text->r1 = 245;

	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+4], 245			; 000000f5H

; 761  : 	text->g1 = 245;

	mov	edx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [edx+5], 245			; 000000f5H

; 762  : 	text->b1 = 245;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+6], 245			; 000000f5H

; 763  : 	text->a1 = 0;	// unused

	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+7], 0

; 764  : 	text->r2 = 0;

	mov	edx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [edx+8], 0

; 765  : 	text->g2 = 0;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+9], 0

; 766  : 	text->b2 = 0;

	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+10], 0

; 767  : 	text->a2 = 0;

	mov	edx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [edx+11], 0

; 768  : 	text->fadein = 0.15f;

	mov	eax, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [eax+20], xmm0

; 769  : 	text->fadeout = 0.0f;

	mov	ecx, DWORD PTR _text$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+24], xmm0

; 770  : 	text->holdtime = 99999.0f;

	mov	edx, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@47c34f80
	movss	DWORD PTR [edx+28], xmm0

; 771  : 	text->fxtime = 0.0f;

	mov	eax, DWORD PTR _text$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+32], xmm0

; 772  : 
; 773  : 	// to prevent grab too long messages
; 774  : 	Q_strncpy( (char *)text->pMessage, MSG_ReadString( msg ), 2048 ); 		

	push	2048					; 00000800H
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _text$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 775  : 
; 776  : 	if( *text->pMessage == '\0' )

	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@CL_ParseFi

; 777  : 		return; // no real text

	jmp	SHORT $LN1@CL_ParseFi
$LN2@CL_ParseFi:

; 778  : 
; 779  : 	CL_HudMessage( text->pName );

	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_CL_HudMessage
	add	esp, 4
$LN1@CL_ParseFi:

; 780  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseFinaleCutscene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_svc_num$ = 12						; size = 4
_iSize$ = 16						; size = 4
_CL_LinkUserMessage PROC

; 1049 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1050 : 	int	i;
; 1051 : 
; 1052 : 	if( !pszName || !*pszName )

	cmp	DWORD PTR _pszName$[ebp], 0
	je	SHORT $LN6@CL_LinkUse
	mov	eax, DWORD PTR _pszName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@CL_LinkUse
$LN6@CL_LinkUse:

; 1053 : 		Host_Error( "CL_LinkUserMessage: bad message name\n" );

	push	OFFSET $SG146695
	call	_Host_Error
	add	esp, 4
$LN5@CL_LinkUse:

; 1054 : 
; 1055 : 	if( svc_num <= svc_lastmsg )

	cmp	DWORD PTR _svc_num$[ebp], 58		; 0000003aH
	jg	SHORT $LN7@CL_LinkUse

; 1056 : 		Host_Error( "CL_LinkUserMessage: tried to hook a system message \"%s\"\n", svc_strings[svc_num] );	

	mov	edx, DWORD PTR _svc_num$[ebp]
	mov	eax, DWORD PTR _svc_strings[edx*4]
	push	eax
	push	OFFSET $SG146697
	call	_Host_Error
	add	esp, 8
$LN7@CL_LinkUse:

; 1057 : 
; 1058 : 	// see if already hooked
; 1059 : 	for( i = 0; i < MAX_USER_MESSAGES && clgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_LinkUse
$LN2@CL_LinkUse:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@CL_LinkUse:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@CL_LinkUse
	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _clgame[edx+ecx+1332]
	test	edx, edx
	je	SHORT $LN3@CL_LinkUse

; 1060 : 	{
; 1061 : 		// NOTE: no check for DispatchFunc, check only name
; 1062 : 		if( !Q_stricmp( clgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1332
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@CL_LinkUse

; 1063 : 		{
; 1064 : 			clgame.msg[i].number = svc_num;

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _svc_num$[ebp]
	mov	DWORD PTR _clgame[edx+1364], eax

; 1065 : 			clgame.msg[i].size = iSize;

	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	edx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _clgame[ecx+1368], edx

; 1066 : 			return;

	jmp	SHORT $LN1@CL_LinkUse
$LN8@CL_LinkUse:

; 1067 : 		}
; 1068 : 	}

	jmp	SHORT $LN2@CL_LinkUse
$LN3@CL_LinkUse:

; 1069 : 
; 1070 : 	if( i == MAX_USER_MESSAGES ) 

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN9@CL_LinkUse

; 1071 : 	{
; 1072 : 		Host_Error( "CL_LinkUserMessage: MAX_USER_MESSAGES hit!\n" );

	push	OFFSET $SG146700
	call	_Host_Error
	add	esp, 4

; 1073 : 		return;

	jmp	SHORT $LN1@CL_LinkUse
$LN9@CL_LinkUse:

; 1074 : 	}
; 1075 : 
; 1076 : 	// register new message without DispatchFunc, so we should parse it properly
; 1077 : 	Q_strncpy( clgame.msg[i].name, pszName, sizeof( clgame.msg[i].name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1332
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1078 : 	clgame.msg[i].number = svc_num;

	imul	edx, DWORD PTR _i$[ebp], 44
	mov	eax, DWORD PTR _svc_num$[ebp]
	mov	DWORD PTR _clgame[edx+1364], eax

; 1079 : 	clgame.msg[i].size = iSize;

	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	edx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _clgame[ecx+1368], edx
$LN1@CL_LinkUse:

; 1080 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_CL_UnloadProgs PROC

; 3901 : {

	push	ebp
	mov	ebp, esp

; 3902 : 	if( !clgame.hInstance ) return;

	cmp	DWORD PTR _clgame, 0
	jne	SHORT $LN2@CL_UnloadP
	jmp	$LN1@CL_UnloadP
$LN2@CL_UnloadP:

; 3903 : 
; 3904 : 	CL_FreeEdicts();

	call	_CL_FreeEdicts

; 3905 : 	CL_FreeTempEnts();

	call	_CL_FreeTempEnts

; 3906 : 	CL_FreeViewBeams();

	call	_CL_FreeViewBeams

; 3907 : 	CL_FreeParticles();

	call	_CL_FreeParticles

; 3908 : 	CL_ClearAllRemaps();

	call	_CL_ClearAllRemaps

; 3909 : 	Mod_ClearUserData();

	call	_Mod_ClearUserData

; 3910 : 	VGui_Shutdown();

	call	_VGui_Shutdown

; 3911 : 
; 3912 : 	// NOTE: HLFX 0.5 has strange bug: hanging on exit if no map was loaded
; 3913 : 	if( Q_stricmp( GI->gamedir, "hlfx" ) || GI->version != 0.5f )

	push	99999					; 0001869fH
	push	OFFSET $SG147881
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@CL_UnloadP
	mov	ecx, DWORD PTR _SI+768
	movss	xmm0, DWORD PTR [ecx+448]
	ucomiss	xmm0, DWORD PTR __real@3f000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_UnloadP
$LN4@CL_UnloadP:

; 3914 : 		clgame.dllFuncs.pfnShutdown();

	call	DWORD PTR _clgame+108
$LN3@CL_UnloadP:

; 3915 : 
; 3916 : 	Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG147882
	push	OFFSET $SG147883
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 3917 : 	Cvar_FullSet( "host_clientloaded", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG147884
	push	OFFSET $SG147885
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 3918 : 
; 3919 : 	COM_FreeLibrary( clgame.hInstance );

	mov	edx, DWORD PTR _clgame
	push	edx
	call	_COM_FreeLibrary
	add	esp, 4

; 3920 : 	Mem_FreePool( &cls.mempool );

	push	3920					; 00000f50H
	push	OFFSET $SG147886
	push	OFFSET _cls+40
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 3921 : 	Mem_FreePool( &clgame.mempool );

	push	3921					; 00000f51H
	push	OFFSET $SG147887
	push	OFFSET _clgame+228
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 3922 : 	memset( &clgame, 0, sizeof( clgame ));

	push	152800					; 000254e0H
	push	0
	push	OFFSET _clgame
	call	_memset
	add	esp, 12					; 0000000cH

; 3923 : 
; 3924 : 	Cvar_Unlink( FCVAR_CLIENTDLL );

	push	16					; 00000010H
	call	_Cvar_Unlink
	add	esp, 4

; 3925 : 	Cmd_Unlink( CMD_CLIENTDLL );

	push	2
	call	_Cmd_Unlink
	add	esp, 4
$LN1@CL_UnloadP:

; 3926 : }

	pop	ebp
	ret	0
_CL_UnloadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_CL_ClearEdicts PROC

; 1157 : {

	push	ebp
	mov	ebp, esp

; 1158 : 	if( clgame.entities != NULL )

	cmp	DWORD PTR _clgame+1000, 0
	je	SHORT $LN2@CL_ClearEd

; 1159 : 		return;

	jmp	SHORT $LN1@CL_ClearEd
$LN2@CL_ClearEd:

; 1160 : 
; 1161 : 	// in case we stopped with error
; 1162 : 	clgame.maxEntities = 2;

	mov	DWORD PTR _clgame+1012, 2

; 1163 : 	CL_InitEdicts();

	call	_CL_InitEdicts
$LN1@CL_ClearEd:

; 1164 : }

	pop	ebp
	ret	0
_CL_ClearEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv165 = -20						; size = 4
tv139 = -16						; size = 4
_GetClientAPI$ = -12					; size = 4
_critical_exports$ = -8					; size = 4
_func$ = -4						; size = 4
_name$ = 8						; size = 4
_CL_LoadProgs PROC

; 3929 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3930 : 	static playermove_t		gpMove;
; 3931 : 	const dllfunc_t		*func;
; 3932 : 	CL_EXPORT_FUNCS		GetClientAPI; // single export
; 3933 : 	qboolean			critical_exports = true;

	mov	DWORD PTR _critical_exports$[ebp], 1

; 3934 : 
; 3935 : 	if( clgame.hInstance ) CL_UnloadProgs();

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN17@CL_LoadPro
	call	_CL_UnloadProgs
$LN17@CL_LoadPro:

; 3936 : 
; 3937 : 	// initialize PlayerMove
; 3938 : 	clgame.pmove = &gpMove;

	mov	DWORD PTR _clgame+1316, OFFSET ?gpMove@?1??CL_LoadProgs@@9@9

; 3939 : 
; 3940 : 	cls.mempool = Mem_AllocPool( "Client Static Pool" );

	push	3940					; 00000f64H
	push	OFFSET $SG147929
	push	OFFSET $SG147930
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cls+40, eax

; 3941 : 	clgame.mempool = Mem_AllocPool( "Client Edicts Zone" );

	push	3941					; 00000f65H
	push	OFFSET $SG147931
	push	OFFSET $SG147932
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clgame+228, eax

; 3942 : 	clgame.entities = NULL;

	mov	DWORD PTR _clgame+1000, 0

; 3943 : 
; 3944 : 	clgame.hInstance = COM_LoadLibrary( name, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clgame, eax

; 3945 : 	if( !clgame.hInstance ) return false;

	cmp	DWORD PTR _clgame, 0
	jne	SHORT $LN18@CL_LoadPro
	xor	eax, eax
	jmp	$LN1@CL_LoadPro
$LN18@CL_LoadPro:

; 3946 : 
; 3947 : 	// clear exports
; 3948 : 	for( func = cdll_exports; func && func->name; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_exports
	jmp	SHORT $LN4@CL_LoadPro
$LN2@CL_LoadPro:
	mov	ecx, DWORD PTR _func$[ebp]
	add	ecx, 8
	mov	DWORD PTR _func$[ebp], ecx
$LN4@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN3@CL_LoadPro
	mov	edx, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@CL_LoadPro

; 3949 : 		*func->func = NULL;

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@CL_LoadPro
$LN3@CL_LoadPro:

; 3950 : 
; 3951 : 	// trying to get single export
; 3952 : 	if(( GetClientAPI = (void *)COM_GetProcAddress( clgame.hInstance, "GetClientAPI" )) != NULL )

	push	OFFSET $SG147935
	mov	edx, DWORD PTR _clgame
	push	edx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _GetClientAPI$[ebp], eax
	cmp	DWORD PTR _GetClientAPI$[ebp], 0
	je	SHORT $LN19@CL_LoadPro

; 3953 : 	{
; 3954 : 		Con_Reportf( "CL_LoadProgs: found single callback export\n" );		

	push	OFFSET $SG147936
	call	_Con_Reportf
	add	esp, 4

; 3955 : 
; 3956 : 		// trying to fill interface now
; 3957 : 		GetClientAPI( &clgame.dllFuncs );

	push	OFFSET _clgame+4
	call	DWORD PTR _GetClientAPI$[ebp]
	add	esp, 4

; 3958 : 
; 3959 : 		// check critical functions again
; 3960 : 		for( func = cdll_exports; func && func->name; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_exports
	jmp	SHORT $LN7@CL_LoadPro
$LN5@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN7@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN6@CL_LoadPro
	mov	ecx, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@CL_LoadPro

; 3961 : 		{
; 3962 : 			if( func->func == NULL )

	mov	edx, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN20@CL_LoadPro

; 3963 : 				break; // BAH critical function was missed

	jmp	SHORT $LN6@CL_LoadPro
$LN20@CL_LoadPro:

; 3964 : 		}

	jmp	SHORT $LN5@CL_LoadPro
$LN6@CL_LoadPro:

; 3965 : 
; 3966 : 		// because all the exports are loaded through function 'F"
; 3967 : 		if( !func || !func->name )

	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN22@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN19@CL_LoadPro
$LN22@CL_LoadPro:

; 3968 : 			critical_exports = false;

	mov	DWORD PTR _critical_exports$[ebp], 0
$LN19@CL_LoadPro:

; 3969 : 	}
; 3970 : 
; 3971 : 	for( func = cdll_exports; func && func->name != NULL; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_exports
	jmp	SHORT $LN10@CL_LoadPro
$LN8@CL_LoadPro:
	mov	ecx, DWORD PTR _func$[ebp]
	add	ecx, 8
	mov	DWORD PTR _func$[ebp], ecx
$LN10@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN9@CL_LoadPro
	mov	edx, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN9@CL_LoadPro

; 3972 : 	{
; 3973 : 		if( *func->func != NULL )

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN23@CL_LoadPro

; 3974 : 			continue;	// already get through 'F'

	jmp	SHORT $LN8@CL_LoadPro
$LN23@CL_LoadPro:

; 3975 : 
; 3976 : 		// functions are cleared before all the extensions are evaluated
; 3977 : 		if(( *func->func = (void *)COM_GetProcAddress( clgame.hInstance, func->name )) == NULL )

	mov	edx, DWORD PTR _func$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _clgame
	push	ecx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR tv139[ebp], eax
	mov	edx, DWORD PTR _func$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR tv139[ebp], 0
	jne	SHORT $LN24@CL_LoadPro

; 3978 : 		{
; 3979 :           		Con_Reportf( "CL_LoadProgs: failed to get address of %s proc\n", func->name );

	mov	edx, DWORD PTR _func$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET $SG147942
	call	_Con_Reportf
	add	esp, 8

; 3980 : 
; 3981 : 			if( critical_exports )

	cmp	DWORD PTR _critical_exports$[ebp], 0
	je	SHORT $LN24@CL_LoadPro

; 3982 : 			{
; 3983 : 				COM_FreeLibrary( clgame.hInstance );

	mov	ecx, DWORD PTR _clgame
	push	ecx
	call	_COM_FreeLibrary
	add	esp, 4

; 3984 : 				clgame.hInstance = NULL;

	mov	DWORD PTR _clgame, 0

; 3985 : 				return false;

	xor	eax, eax
	jmp	$LN1@CL_LoadPro
$LN24@CL_LoadPro:

; 3986 : 			}
; 3987 : 		}
; 3988 : 	}

	jmp	$LN8@CL_LoadPro
$LN9@CL_LoadPro:

; 3989 : 
; 3990 : 	// it may be loaded through 'GetClientAPI' so we don't need to clear them
; 3991 : 	if( critical_exports )

	cmp	DWORD PTR _critical_exports$[ebp], 0
	je	SHORT $LN26@CL_LoadPro

; 3992 : 	{
; 3993 : 		// clear new exports
; 3994 : 		for( func = cdll_new_exports; func && func->name; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_new_exports
	jmp	SHORT $LN13@CL_LoadPro
$LN11@CL_LoadPro:
	mov	edx, DWORD PTR _func$[ebp]
	add	edx, 8
	mov	DWORD PTR _func$[ebp], edx
$LN13@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN26@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN26@CL_LoadPro

; 3995 : 			*func->func = NULL;

	mov	ecx, DWORD PTR _func$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN11@CL_LoadPro
$LN26@CL_LoadPro:

; 3996 : 	}
; 3997 : 
; 3998 : 	for( func = cdll_new_exports; func && func->name != NULL; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_new_exports
	jmp	SHORT $LN16@CL_LoadPro
$LN14@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN16@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN15@CL_LoadPro
	mov	ecx, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN15@CL_LoadPro

; 3999 : 	{
; 4000 : 		if( *func->func != NULL )

	mov	edx, DWORD PTR _func$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN27@CL_LoadPro

; 4001 : 			continue;	// already get through 'F'

	jmp	SHORT $LN14@CL_LoadPro
$LN27@CL_LoadPro:

; 4002 : 
; 4003 : 		// functions are cleared before all the extensions are evaluated
; 4004 : 		// NOTE: new exports can be missed without stop the engine
; 4005 : 		if(( *func->func = (void *)COM_GetProcAddress( clgame.hInstance, func->name )) == NULL )

	mov	ecx, DWORD PTR _func$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _clgame
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR _func$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv165[ebp]
	mov	DWORD PTR [edx], eax
	cmp	DWORD PTR tv165[ebp], 0
	jne	SHORT $LN28@CL_LoadPro

; 4006 : 			Con_Reportf( "CL_LoadProgs: failed to get address of %s proc\n", func->name );

	mov	ecx, DWORD PTR _func$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG147947
	call	_Con_Reportf
	add	esp, 8
$LN28@CL_LoadPro:

; 4007 : 	}

	jmp	SHORT $LN14@CL_LoadPro
$LN15@CL_LoadPro:

; 4008 : 
; 4009 : 	if( !clgame.dllFuncs.pfnInitialize( &gEngfuncs, CLDLL_INTERFACE_VERSION ))

	push	7
	push	OFFSET _gEngfuncs
	call	DWORD PTR _clgame+4
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@CL_LoadPro

; 4010 : 	{
; 4011 : 		COM_FreeLibrary( clgame.hInstance );

	mov	eax, DWORD PTR _clgame
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4012 : 		Con_Reportf( "CL_LoadProgs: can't init client API\n" );

	push	OFFSET $SG147949
	call	_Con_Reportf
	add	esp, 4

; 4013 : 		clgame.hInstance = NULL;

	mov	DWORD PTR _clgame, 0

; 4014 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_LoadPro
$LN29@CL_LoadPro:

; 4015 : 	}
; 4016 : 
; 4017 : 	Cvar_FullSet( "host_clientloaded", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG147950
	push	OFFSET $SG147951
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4018 : 
; 4019 : 	clgame.maxRemapInfos = 0; // will be alloc on first call CL_InitEdicts();

	mov	DWORD PTR _clgame+1016, 0

; 4020 : 	clgame.maxEntities = 2; // world + localclient (have valid entities not in game)

	mov	DWORD PTR _clgame+1012, 2

; 4021 : 
; 4022 : 	CL_InitCDAudio( "media/cdaudio.txt" );

	push	OFFSET $SG147952
	call	_CL_InitCDAudio
	add	esp, 4

; 4023 : 	CL_InitTitles( "titles.txt" );

	push	OFFSET $SG147953
	call	_CL_InitTitles
	add	esp, 4

; 4024 : 	CL_InitParticles ();

	call	_CL_InitParticles

; 4025 : 	CL_InitViewBeams ();

	call	_CL_InitViewBeams

; 4026 : 	CL_InitTempEnts ();

	call	_CL_InitTempEnts

; 4027 : 
; 4028 : 	if( !R_InitRenderAPI())	// Xash3D extension

	call	_R_InitRenderAPI
	test	eax, eax
	jne	SHORT $LN30@CL_LoadPro

; 4029 : 		Con_Reportf( S_WARN "CL_LoadProgs: couldn't get render API\n" );

	push	OFFSET $SG147955
	call	_Con_Reportf
	add	esp, 4
$LN30@CL_LoadPro:

; 4030 : 
; 4031 : 	CL_InitEdicts ();		// initailize local player and world

	call	_CL_InitEdicts

; 4032 : 	CL_InitClientMove();	// initialize pm_shared

	call	_CL_InitClientMove

; 4033 : 
; 4034 : 	// initialize game
; 4035 : 	clgame.dllFuncs.pfnInit();

	call	DWORD PTR _clgame+8

; 4036 : 
; 4037 : 	CL_InitStudioAPI( );

	call	_CL_InitStudioAPI

; 4038 : 
; 4039 : 	// initialize VGui
; 4040 : 	VGui_Startup ();

	call	_VGui_Startup

; 4041 : 
; 4042 : 	// trying to grab them from client.dll
; 4043 : 	cl_righthand = Cvar_FindVar( "cl_righthand" );

	push	0
	push	OFFSET $SG147956
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cl_righthand, eax

; 4044 : 
; 4045 : 	if( cl_righthand == NULL )

	cmp	DWORD PTR _cl_righthand, 0
	jne	SHORT $LN31@CL_LoadPro

; 4046 : 		cl_righthand = Cvar_Get( "cl_righthand", "0", FCVAR_ARCHIVE, "flip viewmodel (left to right)" );

	push	OFFSET $SG147958
	push	1
	push	OFFSET $SG147959
	push	OFFSET $SG147960
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_righthand, eax
$LN31@CL_LoadPro:

; 4047 : 
; 4048 : 	return true;

	mov	eax, 1
$LN1@CL_LoadPro:

; 4049 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_CL_GetMaxClients PROC

; 807  : {

	push	ebp
	mov	ebp, esp

; 808  : 	return cl.maxclients;

	mov	eax, DWORD PTR _cl+1568832

; 809  : }

	pop	ebp
	ret	0
_CL_GetMaxClients ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pMessage$ = 8						; size = 4
_CL_HudMessage PROC

; 679  : {

	push	ebp
	mov	ebp, esp

; 680  : 	if( !COM_CheckString( pMessage )) return;

	mov	eax, DWORD PTR _pMessage$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_HudMess
	jmp	SHORT $LN1@CL_HudMess
$LN2@CL_HudMess:

; 681  : 	CL_DispatchUserMessage( "HudText", Q_strlen( pMessage ), (void *)pMessage );

	mov	ecx, DWORD PTR _pMessage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMessage$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET $SG146551
	call	_CL_DispatchUserMessage
	add	esp, 12					; 0000000cH
$LN1@CL_HudMess:

; 682  : }

	pop	ebp
	ret	0
_CL_HudMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_playerIndex$ = 8					; size = 4
_CL_GetPlayerInfo PROC

; 155  : {

	push	ebp
	mov	ebp, esp

; 156  : 	if( playerIndex < 0 || playerIndex >= cl.maxclients )

	cmp	DWORD PTR _playerIndex$[ebp], 0
	jl	SHORT $LN3@CL_GetPlay
	mov	eax, DWORD PTR _playerIndex$[ebp]
	cmp	eax, DWORD PTR _cl+1568832
	jl	SHORT $LN2@CL_GetPlay
$LN3@CL_GetPlay:

; 157  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetPlay
$LN2@CL_GetPlay:

; 158  : 
; 159  : 	return &cl.players[playerIndex];

	imul	eax, DWORD PTR _playerIndex$[ebp], 584
	add	eax, OFFSET _cl+1543148
$LN1@CL_GetPlay:

; 160  : }

	pop	ebp
	ret	0
_CL_GetPlayerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_index$ = 8						; size = 4
_CL_GetEntityByIndex PROC

; 104  : {

	push	ebp
	mov	ebp, esp

; 105  : 	if( !clgame.entities ) // not in game yet

	cmp	DWORD PTR _clgame+1000, 0
	jne	SHORT $LN2@CL_GetEnti

; 106  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetEnti
$LN2@CL_GetEnti:

; 107  : 
; 108  : 	if( index < 0 || index >= clgame.maxEntities )

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN4@CL_GetEnti
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _clgame+1012
	jl	SHORT $LN3@CL_GetEnti
$LN4@CL_GetEnti:

; 109  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetEnti
$LN3@CL_GetEnti:

; 110  : 
; 111  : 	if( index == 0 )

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN5@CL_GetEnti

; 112  : 		return clgame.entities;

	mov	eax, DWORD PTR _clgame+1000
	jmp	SHORT $LN1@CL_GetEnti
$LN5@CL_GetEnti:

; 113  : 
; 114  : 	return CL_EDICT_NUM( index );

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	call	_CL_EDICT_NUM
	add	esp, 4
$LN1@CL_GetEnti:

; 115  : }

	pop	ebp
	ret	0
_CL_GetEntityByIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_CL_PointContents PROC

; 256  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 257  : 	int cont = PM_PointContents( clgame.pmove, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1316
	push	ecx
	call	_PM_PointContents
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax

; 258  : 
; 259  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN2@CL_PointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN2@CL_PointCo

; 260  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN2@CL_PointCo:

; 261  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_CL_IsThirdPerson PROC

; 139  : {

	push	ebp
	mov	ebp, esp

; 140  : 	cl.local.thirdperson = clgame.dllFuncs.CL_IsThirdPerson();

	call	DWORD PTR _clgame+64
	mov	DWORD PTR _cl+1568540, eax

; 141  : 
; 142  : 	if( cl.local.thirdperson )

	cmp	DWORD PTR _cl+1568540, 0
	je	SHORT $LN2@CL_IsThird

; 143  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsThird
$LN2@CL_IsThird:

; 144  : 	return false;

	xor	eax, eax
$LN1@CL_IsThird:

; 145  : }

	pop	ebp
	ret	0
_CL_IsThirdPerson ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_length$ = 12						; size = 4
_height$ = 16						; size = 4
_pfnDrawConsoleStringLen PROC

; 1912 : {

	push	ebp
	mov	ebp, esp

; 1913 : 	Con_SetFont( con_fontsize->value );

	mov	eax, DWORD PTR _con_fontsize
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	call	_Con_SetFont
	add	esp, 4

; 1914 : 	Con_DrawStringLen( pText, length, height );

	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 1915 : 	Con_RestoreFont();

	call	_Con_RestoreFont

; 1916 : }

	pop	ebp
	ret	0
_pfnDrawConsoleStringLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
tv133 = -24						; size = 4
tv132 = -20						; size = 4
tv88 = -16						; size = 4
tv87 = -12						; size = 4
tv75 = -8						; size = 4
tv74 = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_pfnDrawSetTextColor PROC

; 1896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1897 : 	// bound color and convert to byte
; 1898 : 	clgame.ds.textColor[0] = (byte)bound( 0, r * 255, 255 );

	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN5@pfnDrawSet
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@pfnDrawSet
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN4@pfnDrawSet
$LN3@pfnDrawSet:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv74[ebp], xmm0
$LN4@pfnDrawSet:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN6@pfnDrawSet
$LN5@pfnDrawSet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
$LN6@pfnDrawSet:
	cvttss2si eax, DWORD PTR tv75[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _clgame[edx+122692], al

; 1899 : 	clgame.ds.textColor[1] = (byte)bound( 0, g * 255, 255 );

	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN9@pfnDrawSet
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@pfnDrawSet
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN8@pfnDrawSet
$LN7@pfnDrawSet:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv87[ebp], xmm0
$LN8@pfnDrawSet:
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN10@pfnDrawSet
$LN9@pfnDrawSet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv88[ebp], xmm0
$LN10@pfnDrawSet:
	cvttss2si eax, DWORD PTR tv88[ebp]
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _clgame[ecx+122692], al

; 1900 : 	clgame.ds.textColor[2] = (byte)bound( 0, b * 255, 255 );

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN13@pfnDrawSet
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@pfnDrawSet
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv132[ebp], xmm0
	jmp	SHORT $LN12@pfnDrawSet
$LN11@pfnDrawSet:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv132[ebp], xmm0
$LN12@pfnDrawSet:
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN14@pfnDrawSet
$LN13@pfnDrawSet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv133[ebp], xmm0
$LN14@pfnDrawSet:
	cvttss2si edx, DWORD PTR tv133[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _clgame[eax+122692], dl

; 1901 : 	clgame.ds.textColor[3] = (byte)0xFF;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _clgame[edx+122692], 255	; 000000ffH

; 1902 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawSetTextColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\cl_game.c
_TEXT	SEGMENT
_drawLen$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_pfnDrawConsoleString PROC

; 1871 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1872 : 	int	drawLen;
; 1873 : 
; 1874 : 	if( !COM_CheckString( string ))

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnDrawCon

; 1875 : 		return 0; // silent ignore

	xor	eax, eax
	jmp	$LN1@pfnDrawCon
$LN2@pfnDrawCon:

; 1876 : 	Con_SetFont( con_fontsize->value );

	mov	ecx, DWORD PTR _con_fontsize
	cvttss2si edx, DWORD PTR [ecx+12]
	push	edx
	call	_Con_SetFont
	add	esp, 4

; 1877 : 
; 1878 : 	clgame.ds.adjust_size = true;

	mov	DWORD PTR _clgame+122680, 1

; 1879 : 	drawLen = Con_DrawString( x, y, string, clgame.ds.textColor );

	push	OFFSET _clgame+122692
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_Con_DrawString
	add	esp, 16					; 00000010H
	mov	DWORD PTR _drawLen$[ebp], eax

; 1880 : 	MakeRGBA( clgame.ds.textColor, 255, 255, 255, 255 );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _clgame[ecx+122692], 255	; 000000ffH
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _clgame[edx+122692], 255	; 000000ffH
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _clgame[eax+122692], 255	; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _clgame[edx+122692], 255	; 000000ffH

; 1881 : 	clgame.ds.adjust_size = false;

	mov	DWORD PTR _clgame+122680, 0

; 1882 : 
; 1883 : 	Con_RestoreFont();

	call	_Con_RestoreFont

; 1884 : 
; 1885 : 	return (x + drawLen); // exclude color prexfixes

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _drawLen$[ebp]
$LN1@pfnDrawCon:

; 1886 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawConsoleString ENDP
_TEXT	ENDS
END
