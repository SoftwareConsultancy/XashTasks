; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\client\s_load.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_s_registering
PUBLIC	_s_registration_sequence
_BSS	SEGMENT
_s_registering DD 01H DUP (?)
_s_registration_sequence DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_S_LoadSound
PUBLIC	_S_TestSoundChar
PUBLIC	_S_SkipSoundChar
PUBLIC	_S_FindName
PUBLIC	_S_RegisterSound
PUBLIC	_S_FreeSound
PUBLIC	_S_InitSounds
PUBLIC	_S_SoundList_f
PUBLIC	_S_GetSfxByHandle
PUBLIC	_S_FreeSounds
PUBLIC	_S_BeginRegistration
PUBLIC	_S_EndRegistration
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_LoadSound:PROC
EXTRN	_FS_FreeSound:PROC
EXTRN	_Sound_Process:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_HashKey:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_SI:BYTE
EXTRN	_sndpool:DWORD
EXTRN	_ambient_sfx:BYTE
EXTRN	_snd_ambient:DWORD
EXTRN	_dma:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_s_numSfx DD	01H DUP (?)
_s_knownSfx DB	0a0000H DUP (?)
_s_sfxHashList DD 0808H DUP (?)
_s_sentenceImmediateName DB 0100H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
_DATA	SEGMENT
$SG131891 DB	'L', 00H
	ORG $+2
$SG131892 DB	' ', 00H
	ORG $+2
$SG131895 DB	' (%2db) %s : %s', 0aH, 00H
	ORG $+3
$SG131896 DB	'sound/', 00H
	ORG $+1
$SG131897 DB	' (%2db) %s : %s%s', 0aH, 00H
	ORG $+1
$SG131898 DB	'-------------------------------------------', 0aH, 00H
	ORG $+3
$SG131899 DB	'%i total sounds', 0aH, 00H
	ORG $+3
$SG131900 DB	'%s total memory', 0aH, 00H
	ORG $+3
$SG131901 DB	0aH, 00H
	ORG $+2
$SG131942 DB	'*default', 00H
	ORG $+3
$SG131927 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_load.c', 00H
	ORG $+2
$SG132015 DB	'*default', 00H
	ORG $+3
$SG131928 DB	'c:\users\user\downloads\xash_build4529_src\engine\client'
	DB	'\s_load.c', 00H
	ORG $+2
$SG132044 DB	'*default', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_sfx$ = -4						; size = 4
_S_EndRegistration PROC

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 297  : 	sfx_t	*sfx;
; 298  : 	int	i;
; 299  : 
; 300  : 	if( !s_registering || !dma.initialized )

	cmp	DWORD PTR _s_registering, 0
	je	SHORT $LN9@S_EndRegis
	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN8@S_EndRegis
$LN9@S_EndRegis:

; 301  : 		return;

	jmp	$LN1@S_EndRegis
$LN8@S_EndRegis:

; 302  : 	
; 303  : 	// free any sounds not from this registration sequence
; 304  : 	for( i = 0, sfx = s_knownSfx; i < s_numSfx; i++, sfx++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _sfx$[ebp], OFFSET _s_knownSfx
	jmp	SHORT $LN4@S_EndRegis
$LN2@S_EndRegis:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _sfx$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _sfx$[ebp], ecx
$LN4@S_EndRegis:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _s_numSfx
	jge	SHORT $LN3@S_EndRegis

; 305  : 	{
; 306  : 		if( !sfx->name[0] || !Q_stricmp( sfx->name, "*default" ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sfx$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN11@S_EndRegis
	push	99999					; 0001869fH
	push	OFFSET $SG132015
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@S_EndRegis
$LN11@S_EndRegis:

; 307  : 			continue; // don't release default sound

	jmp	SHORT $LN2@S_EndRegis
$LN10@S_EndRegis:

; 308  : 
; 309  : 		if( sfx->servercount != s_registration_sequence )

	mov	edx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR [edx+68]
	cmp	eax, DWORD PTR _s_registration_sequence
	je	SHORT $LN12@S_EndRegis

; 310  : 			S_FreeSound( sfx ); // don't need this sound

	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	call	_S_FreeSound
	add	esp, 4
$LN12@S_EndRegis:

; 311  : 	}

	jmp	SHORT $LN2@S_EndRegis
$LN3@S_EndRegis:

; 312  : 
; 313  : 	// load everything in
; 314  : 	for( i = 0, sfx = s_knownSfx; i < s_numSfx; i++, sfx++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _sfx$[ebp], OFFSET _s_knownSfx
	jmp	SHORT $LN7@S_EndRegis
$LN5@S_EndRegis:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _sfx$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _sfx$[ebp], eax
$LN7@S_EndRegis:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _s_numSfx
	jge	SHORT $LN6@S_EndRegis

; 315  : 	{
; 316  : 		if( !sfx->name[0] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _sfx$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN13@S_EndRegis

; 317  : 			continue;

	jmp	SHORT $LN5@S_EndRegis
$LN13@S_EndRegis:

; 318  : 		S_LoadSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4

; 319  : 	}

	jmp	SHORT $LN5@S_EndRegis
$LN6@S_EndRegis:

; 320  : 	s_registering = false;

	mov	DWORD PTR _s_registering, 0
$LN1@S_EndRegis:

; 321  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_EndRegistration ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_S_BeginRegistration PROC

; 270  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 271  : 	int	i;
; 272  : 
; 273  : 	s_registration_sequence++;

	mov	eax, DWORD PTR _s_registration_sequence
	add	eax, 1
	mov	DWORD PTR _s_registration_sequence, eax

; 274  : 	snd_ambient = false;

	mov	DWORD PTR _snd_ambient, 0

; 275  : 
; 276  : 	// check for automatic ambient sounds
; 277  : 	for( i = 0; i < NUM_AMBIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_BeginReg
$LN2@S_BeginReg:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@S_BeginReg:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@S_BeginReg

; 278  : 	{
; 279  : 		if( !GI->ambientsound[i][0] )

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _SI+768
	lea	ecx, DWORD PTR [eax+edx+1400]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax]
	test	ecx, ecx
	jne	SHORT $LN5@S_BeginReg

; 280  : 			continue;	// empty slot

	jmp	SHORT $LN2@S_BeginReg
$LN5@S_BeginReg:

; 281  : 
; 282  : 		ambient_sfx[i] = S_RegisterSound( GI->ambientsound[i] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _SI+768
	lea	ecx, DWORD PTR [eax+edx+1400]
	push	ecx
	call	_S_RegisterSound
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _ambient_sfx[edx*4], eax

; 283  : 		if( ambient_sfx[i] ) snd_ambient = true; // allow auto-ambients

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _ambient_sfx[eax*4], 0
	je	SHORT $LN6@S_BeginReg
	mov	DWORD PTR _snd_ambient, 1
$LN6@S_BeginReg:

; 284  : 	}

	jmp	SHORT $LN2@S_BeginReg
$LN3@S_BeginReg:

; 285  : 
; 286  : 	s_registering = true;

	mov	DWORD PTR _s_registering, 1

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_BeginRegistration ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_sc$ = -4						; size = 4
_S_CreateDefaultSound PROC

; 106  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 107  : 	wavdata_t	*sc;
; 108  : 
; 109  : 	sc = Mem_Calloc( sndpool, sizeof( wavdata_t ));

	push	109					; 0000006dH
	push	OFFSET $SG131927
	push	1
	push	28					; 0000001cH
	mov	eax, DWORD PTR _sndpool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _sc$[ebp], eax

; 110  : 
; 111  : 	sc->width = 2;

	mov	ecx, DWORD PTR _sc$[ebp]
	mov	BYTE PTR [ecx+2], 2

; 112  : 	sc->channels = 1;

	mov	edx, DWORD PTR _sc$[ebp]
	mov	BYTE PTR [edx+3], 1

; 113  : 	sc->loopStart = -1;

	mov	eax, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [eax+4], -1

; 114  : 	sc->rate = SOUND_DMA_SPEED;

	mov	ecx, 44100				; 0000ac44H
	mov	edx, DWORD PTR _sc$[ebp]
	mov	WORD PTR [edx], cx

; 115  : 	sc->samples = SOUND_DMA_SPEED;

	mov	eax, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [eax+8], 44100		; 0000ac44H

; 116  : 	sc->size = sc->samples * sc->width * sc->channels;

	mov	ecx, DWORD PTR _sc$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	eax, DWORD PTR _sc$[ebp]
	imul	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _sc$[ebp]
	movzx	eax, BYTE PTR [ecx+3]
	imul	edx, eax
	mov	ecx, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 117  : 	sc->buffer = Mem_Calloc( sndpool, sc->size );

	push	117					; 00000075H
	push	OFFSET $SG131928
	push	1
	mov	edx, DWORD PTR _sc$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _sndpool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [edx+20], eax

; 118  : 
; 119  : 	return sc;

	mov	eax, DWORD PTR _sc$[ebp]

; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_CreateDefaultSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_sfx$ = -8						; size = 4
_i$ = -4						; size = 4
_S_FreeSounds PROC

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 393  : 	sfx_t	*sfx;
; 394  : 	int	i;
; 395  : 
; 396  : 	if( !dma.initialized )

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_FreeSoun

; 397  : 		return;

	jmp	SHORT $LN1@S_FreeSoun
$LN5@S_FreeSoun:

; 398  : 
; 399  : 	// stop all sounds
; 400  : 	S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 401  : 
; 402  : 	// free all sounds
; 403  : 	for( i = 0, sfx = s_knownSfx; i < s_numSfx; i++, sfx++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _sfx$[ebp], OFFSET _s_knownSfx
	jmp	SHORT $LN4@S_FreeSoun
$LN2@S_FreeSoun:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _sfx$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _sfx$[ebp], ecx
$LN4@S_FreeSoun:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _s_numSfx
	jge	SHORT $LN3@S_FreeSoun

; 404  : 		S_FreeSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_FreeSound
	add	esp, 4
	jmp	SHORT $LN2@S_FreeSoun
$LN3@S_FreeSoun:

; 405  : 
; 406  : 	memset( s_knownSfx, 0, sizeof( s_knownSfx ));

	push	655360					; 000a0000H
	push	0
	push	OFFSET _s_knownSfx
	call	_memset
	add	esp, 12					; 0000000cH

; 407  : 	memset( s_sfxHashList, 0, sizeof( s_sfxHashList ));

	push	8192					; 00002000H
	push	0
	push	OFFSET _s_sfxHashList
	call	_memset
	add	esp, 12					; 0000000cH

; 408  : 
; 409  : 	s_numSfx = 0;

	mov	DWORD PTR _s_numSfx, 0
$LN1@S_FreeSoun:

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_S_GetSfxByHandle PROC

; 356  : {

	push	ebp
	mov	ebp, esp

; 357  : 	if( !dma.initialized )

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_GetSfxBy

; 358  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@S_GetSfxBy
$LN2@S_GetSfxBy:

; 359  : 
; 360  : 	// create new sfx
; 361  : 	if( handle == SENTENCE_INDEX )

	cmp	DWORD PTR _handle$[ebp], -99999		; fffe7961H
	jne	SHORT $LN3@S_GetSfxBy

; 362  : 		return S_FindName( s_sentenceImmediateName, NULL );

	push	0
	push	OFFSET _s_sentenceImmediateName
	call	_S_FindName
	add	esp, 8
	jmp	SHORT $LN1@S_GetSfxBy
$LN3@S_GetSfxBy:

; 363  : 
; 364  : 	if( handle < 0 || handle >= s_numSfx )

	cmp	DWORD PTR _handle$[ebp], 0
	jl	SHORT $LN5@S_GetSfxBy
	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _s_numSfx
	jl	SHORT $LN4@S_GetSfxBy
$LN5@S_GetSfxBy:

; 365  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@S_GetSfxBy
$LN4@S_GetSfxBy:

; 366  : 
; 367  : 	return &s_knownSfx[handle];

	imul	eax, DWORD PTR _handle$[ebp], 80
	add	eax, OFFSET _s_knownSfx
$LN1@S_GetSfxBy:

; 368  : }

	pop	ebp
	ret	0
_S_GetSfxByHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
tv186 = -44						; size = 8
tv173 = -36						; size = 8
tv182 = -28						; size = 4
tv169 = -24						; size = 4
_totalSize$ = -20					; size = 4
_totalSfx$ = -16					; size = 4
_i$ = -12						; size = 4
_sc$ = -8						; size = 4
_sfx$ = -4						; size = 4
_S_SoundList_f PROC

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 40   : 	sfx_t		*sfx;
; 41   : 	wavdata_t		*sc;
; 42   : 	int		i, totalSfx = 0;

	mov	DWORD PTR _totalSfx$[ebp], 0

; 43   : 	int		totalSize = 0;

	mov	DWORD PTR _totalSize$[ebp], 0

; 44   : 
; 45   : 	for( i = 0, sfx = s_knownSfx; i < s_numSfx; i++, sfx++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _sfx$[ebp], OFFSET _s_knownSfx
	jmp	SHORT $LN4@S_SoundLis
$LN2@S_SoundLis:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _sfx$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _sfx$[ebp], ecx
$LN4@S_SoundLis:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _s_numSfx
	jge	$LN3@S_SoundLis

; 46   : 	{
; 47   : 		if( !sfx->name[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sfx$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@S_SoundLis

; 48   : 			continue;

	jmp	SHORT $LN2@S_SoundLis
$LN5@S_SoundLis:

; 49   : 
; 50   : 		sc = sfx->cache;

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _sc$[ebp], edx

; 51   : 		if( sc )

	cmp	DWORD PTR _sc$[ebp], 0
	je	$LN6@S_SoundLis

; 52   : 		{
; 53   : 			totalSize += sc->size;

	mov	eax, DWORD PTR _sc$[ebp]
	mov	ecx, DWORD PTR _totalSize$[ebp]
	add	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _totalSize$[ebp], ecx

; 54   : 
; 55   : 			if( sc->loopStart >= 0 ) Con_Printf( "L" );

	mov	edx, DWORD PTR _sc$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jl	SHORT $LN7@S_SoundLis
	push	OFFSET $SG131891
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN8@S_SoundLis
$LN7@S_SoundLis:

; 56   : 			else Con_Printf( " " );

	push	OFFSET $SG131892
	call	_Con_Printf
	add	esp, 4
$LN8@S_SoundLis:

; 57   : 			if( sfx->name[0] == '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sfx$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN9@S_SoundLis

; 58   : 				Con_Printf( " (%2db) %s : %s\n", sc->width * 8, Q_memprint( sc->size ), sfx->name );

	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _sc$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv169[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv169[ebp]
	mov	ecx, DWORD PTR tv169[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv173[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv173[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _sc$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	shl	eax, 3
	push	eax
	push	OFFSET $SG131895
	call	_Con_Printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@S_SoundLis
$LN9@S_SoundLis:

; 59   : 			else Con_Printf( " (%2db) %s : %s%s\n", sc->width * 8, Q_memprint( sc->size ), DEFAULT_SOUNDPATH, sfx->name );

	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	push	OFFSET $SG131896
	push	2
	mov	edx, DWORD PTR _sc$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv182[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv182[ebp]
	mov	ecx, DWORD PTR tv182[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv186[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv186[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _sc$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	shl	eax, 3
	push	eax
	push	OFFSET $SG131897
	call	_Con_Printf
	add	esp, 20					; 00000014H
$LN10@S_SoundLis:

; 60   : 			totalSfx++;

	mov	ecx, DWORD PTR _totalSfx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _totalSfx$[ebp], ecx
$LN6@S_SoundLis:

; 61   : 		}
; 62   : 	}

	jmp	$LN2@S_SoundLis
$LN3@S_SoundLis:

; 63   : 
; 64   : 	Con_Printf( "-------------------------------------------\n" );

	push	OFFSET $SG131898
	call	_Con_Printf
	add	esp, 4

; 65   : 	Con_Printf( "%i total sounds\n", totalSfx );

	mov	edx, DWORD PTR _totalSfx$[ebp]
	push	edx
	push	OFFSET $SG131899
	call	_Con_Printf
	add	esp, 8

; 66   : 	Con_Printf( "%s total memory\n", Q_memprint( totalSize ));

	push	2
	cvtsi2ss xmm0, DWORD PTR _totalSize$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG131900
	call	_Con_Printf
	add	esp, 8

; 67   : 	Con_Printf( "\n" );

	push	OFFSET $SG131901
	call	_Con_Printf
	add	esp, 4

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_SoundList_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_S_InitSounds PROC

; 376  : {

	push	ebp
	mov	ebp, esp

; 377  : 	// create unused 0-entry
; 378  : 	Q_strncpy( s_knownSfx->name, "*default", MAX_QPATH );

	push	64					; 00000040H
	push	OFFSET $SG132044
	push	OFFSET _s_knownSfx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 379  : 	s_knownSfx->hashValue = COM_HashKey( s_knownSfx->name, MAX_SFX_HASH );

	push	2048					; 00000800H
	push	OFFSET _s_knownSfx
	call	_COM_HashKey
	add	esp, 8
	mov	DWORD PTR _s_knownSfx+72, eax

; 380  : 	s_knownSfx->hashNext = s_sfxHashList[s_knownSfx->hashValue];

	mov	eax, DWORD PTR _s_knownSfx+72
	mov	ecx, DWORD PTR _s_sfxHashList[eax*4]
	mov	DWORD PTR _s_knownSfx+76, ecx

; 381  : 	s_sfxHashList[s_knownSfx->hashValue] = s_knownSfx;

	mov	edx, DWORD PTR _s_knownSfx+72
	mov	DWORD PTR _s_sfxHashList[edx*4], OFFSET _s_knownSfx

; 382  : 	s_knownSfx->cache = S_CreateDefaultSound();

	call	_S_CreateDefaultSound
	mov	DWORD PTR _s_knownSfx+64, eax

; 383  : 	s_numSfx = 1;

	mov	DWORD PTR _s_numSfx, 1

; 384  : }

	pop	ebp
	ret	0
_S_InitSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_prev$ = -8						; size = 4
_hashSfx$ = -4						; size = 4
_sfx$ = 8						; size = 4
_S_FreeSound PROC

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 236  : 	sfx_t	*hashSfx;
; 237  : 	sfx_t	**prev;
; 238  : 
; 239  : 	if( !sfx || !sfx->name[0] )

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN5@S_FreeSoun
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sfx$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@S_FreeSoun
$LN5@S_FreeSoun:

; 240  : 		return;

	jmp	SHORT $LN1@S_FreeSoun
$LN4@S_FreeSoun:

; 241  : 
; 242  : 	// de-link it from the hash tree
; 243  : 	prev = &s_sfxHashList[sfx->hashValue];

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	lea	eax, DWORD PTR _s_sfxHashList[edx*4]
	mov	DWORD PTR _prev$[ebp], eax
$LN2@S_FreeSoun:

; 244  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@S_FreeSoun

; 245  : 	{
; 246  : 		hashSfx = *prev;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _hashSfx$[ebp], eax

; 247  : 		if( !hashSfx )

	cmp	DWORD PTR _hashSfx$[ebp], 0
	jne	SHORT $LN6@S_FreeSoun

; 248  : 			break;

	jmp	SHORT $LN3@S_FreeSoun
$LN6@S_FreeSoun:

; 249  : 
; 250  : 		if( hashSfx == sfx )

	mov	ecx, DWORD PTR _hashSfx$[ebp]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN7@S_FreeSoun

; 251  : 		{
; 252  : 			*prev = hashSfx->hashNext;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR _hashSfx$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [edx], ecx

; 253  : 			break;

	jmp	SHORT $LN3@S_FreeSoun
$LN7@S_FreeSoun:

; 254  : 		}
; 255  : 		prev = &hashSfx->hashNext;

	mov	edx, DWORD PTR _hashSfx$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR _prev$[ebp], edx

; 256  : 	}

	jmp	SHORT $LN2@S_FreeSoun
$LN3@S_FreeSoun:

; 257  : 
; 258  : 	if( sfx->cache )

	mov	eax, DWORD PTR _sfx$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN8@S_FreeSoun

; 259  : 		FS_FreeSound( sfx->cache );

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_FS_FreeSound
	add	esp, 4
$LN8@S_FreeSoun:

; 260  : 	memset( sfx, 0, sizeof( *sfx ));

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@S_FreeSoun:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_sfx$ = -4						; size = 4
_name$ = 8						; size = 4
_S_RegisterSound PROC

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 331  : 	sfx_t	*sfx;
; 332  : 
; 333  : 	if( !COM_CheckString( name ) || !dma.initialized )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@S_Register
	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_Register
$LN3@S_Register:

; 334  : 		return -1;

	or	eax, -1
	jmp	$LN1@S_Register
$LN2@S_Register:

; 335  : 
; 336  : 	if( S_TestSoundChar( name, '!' ))

	push	33					; 00000021H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@S_Register

; 337  : 	{
; 338  : 		Q_strncpy( s_sentenceImmediateName, name, sizeof( s_sentenceImmediateName ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET _s_sentenceImmediateName
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 339  : 		return SENTENCE_INDEX;

	mov	eax, -99999				; fffe7961H
	jmp	$LN1@S_Register
$LN4@S_Register:

; 340  : 	}
; 341  : 
; 342  : 	// some stupid mappers used leading '/' or '\' in path to models or sounds
; 343  : 	if( name[0] == '/' || name[0] == '\\' ) name++;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@S_Register
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN5@S_Register
$LN6@S_Register:
	mov	edx, DWORD PTR _name$[ebp]
	add	edx, 1
	mov	DWORD PTR _name$[ebp], edx
$LN5@S_Register:

; 344  : 	if( name[0] == '/' || name[0] == '\\' ) name++;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN8@S_Register
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN7@S_Register
$LN8@S_Register:
	mov	edx, DWORD PTR _name$[ebp]
	add	edx, 1
	mov	DWORD PTR _name$[ebp], edx
$LN7@S_Register:

; 345  : 
; 346  : 	sfx = S_FindName( name, NULL );

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_S_FindName
	add	esp, 8
	mov	DWORD PTR _sfx$[ebp], eax

; 347  : 	if( !sfx ) return -1;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN9@S_Register
	or	eax, -1
	jmp	SHORT $LN1@S_Register
$LN9@S_Register:

; 348  : 
; 349  : 	sfx->servercount = s_registration_sequence;

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR _s_registration_sequence
	mov	DWORD PTR [ecx+68], edx

; 350  : 	if( !s_registering ) S_LoadSound( sfx );

	cmp	DWORD PTR _s_registering, 0
	jne	SHORT $LN10@S_Register
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4
$LN10@S_Register:

; 351  : 
; 352  : 	return sfx - s_knownSfx;

	mov	eax, DWORD PTR _sfx$[ebp]
	sub	eax, OFFSET _s_knownSfx
	cdq
	mov	ecx, 80					; 00000050H
	idiv	ecx
$LN1@S_Register:

; 353  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_RegisterSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_hash$ = -276						; size = 4
tv91 = -272						; size = 4
_i$ = -268						; size = 4
_sfx$ = -264						; size = 4
_name$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pname$ = 8						; size = 4
_pfInCache$ = 12					; size = 4
_S_FindName PROC

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 174  : 	sfx_t	*sfx;
; 175  : 	uint	i, hash;
; 176  : 	string	name;
; 177  : 
; 178  : 	if( !COM_CheckString( pname ) || !dma.initialized )

	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@S_FindName
	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN8@S_FindName
$LN9@S_FindName:

; 179  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@S_FindName
$LN8@S_FindName:

; 180  : 
; 181  : 	if( Q_strlen( pname ) >= sizeof( sfx->name ))

	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jb	SHORT $LN10@S_FindName

; 182  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@S_FindName
$LN10@S_FindName:

; 183  : 
; 184  : 	Q_strncpy( name, pname, sizeof( name ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 185  : 	COM_FixSlashes( name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_FixSlashes
	add	esp, 4

; 186  : 
; 187  : 	// see if already loaded
; 188  : 	hash = COM_HashKey( name, MAX_SFX_HASH );

	push	2048					; 00000800H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_COM_HashKey
	add	esp, 8
	mov	DWORD PTR _hash$[ebp], eax

; 189  : 	for( sfx = s_sfxHashList[hash]; sfx; sfx = sfx->hashNext )

	mov	eax, DWORD PTR _hash$[ebp]
	mov	ecx, DWORD PTR _s_sfxHashList[eax*4]
	mov	DWORD PTR _sfx$[ebp], ecx
	jmp	SHORT $LN4@S_FindName
$LN2@S_FindName:
	mov	edx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _sfx$[ebp], eax
$LN4@S_FindName:
	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN3@S_FindName

; 190  : 	{
; 191  : 		if( !Q_strcmp( sfx->name, name ))

	push	99999					; 0001869fH
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@S_FindName

; 192  : 		{
; 193  : 			if( pfInCache )

	cmp	DWORD PTR _pfInCache$[ebp], 0
	je	SHORT $LN12@S_FindName

; 194  : 			{
; 195  : 				// indicate whether or not sound is currently in the cache.
; 196  : 				*pfInCache = ( sfx->cache != NULL ) ? true : false;

	mov	eax, DWORD PTR _sfx$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN18@S_FindName
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN19@S_FindName
$LN18@S_FindName:
	mov	DWORD PTR tv91[ebp], 0
$LN19@S_FindName:
	mov	ecx, DWORD PTR _pfInCache$[ebp]
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR [ecx], edx
$LN12@S_FindName:

; 197  : 			}
; 198  : 			// prolonge registration
; 199  : 			sfx->servercount = s_registration_sequence;

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR _s_registration_sequence
	mov	DWORD PTR [eax+68], ecx

; 200  : 			return sfx;

	mov	eax, DWORD PTR _sfx$[ebp]
	jmp	$LN1@S_FindName
$LN11@S_FindName:

; 201  : 		}
; 202  : 	}

	jmp	$LN2@S_FindName
$LN3@S_FindName:

; 203  : 
; 204  : 	// find a free sfx slot spot
; 205  : 	for( i = 0, sfx = s_knownSfx; i < s_numSfx; i++, sfx++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _sfx$[ebp], OFFSET _s_knownSfx
	jmp	SHORT $LN7@S_FindName
$LN5@S_FindName:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _sfx$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _sfx$[ebp], eax
$LN7@S_FindName:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _s_numSfx
	jae	SHORT $LN6@S_FindName

; 206  : 		if( !sfx->name[0] ) break; // free spot

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _sfx$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN13@S_FindName
	jmp	SHORT $LN6@S_FindName
$LN13@S_FindName:
	jmp	SHORT $LN5@S_FindName
$LN6@S_FindName:

; 207  : 
; 208  : 	if( i == s_numSfx )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _s_numSfx
	jne	SHORT $LN14@S_FindName

; 209  : 	{
; 210  : 		if( s_numSfx == MAX_SFX )

	cmp	DWORD PTR _s_numSfx, 8192		; 00002000H
	jne	SHORT $LN15@S_FindName

; 211  : 			return NULL;

	xor	eax, eax
	jmp	$LN1@S_FindName
$LN15@S_FindName:

; 212  : 		s_numSfx++;

	mov	ecx, DWORD PTR _s_numSfx
	add	ecx, 1
	mov	DWORD PTR _s_numSfx, ecx
$LN14@S_FindName:

; 213  : 	}
; 214  : 	
; 215  : 	sfx = &s_knownSfx[i];

	imul	edx, DWORD PTR _i$[ebp], 80
	add	edx, OFFSET _s_knownSfx
	mov	DWORD PTR _sfx$[ebp], edx

; 216  : 	memset( sfx, 0, sizeof( *sfx ));

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 217  : 	if( pfInCache ) *pfInCache = false;

	cmp	DWORD PTR _pfInCache$[ebp], 0
	je	SHORT $LN16@S_FindName
	mov	ecx, DWORD PTR _pfInCache$[ebp]
	mov	DWORD PTR [ecx], 0
$LN16@S_FindName:

; 218  : 	Q_strncpy( sfx->name, name, MAX_STRING );

	push	256					; 00000100H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 219  : 	sfx->servercount = s_registration_sequence;

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR _s_registration_sequence
	mov	DWORD PTR [ecx+68], edx

; 220  : 	sfx->hashValue = COM_HashKey( sfx->name, MAX_SFX_HASH );

	push	2048					; 00000800H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_COM_HashKey
	add	esp, 8
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 221  : 
; 222  : 	// link it in
; 223  : 	sfx->hashNext = s_sfxHashList[sfx->hashValue];

	mov	edx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR _s_sfxHashList[eax*4]
	mov	DWORD PTR [ecx+76], edx

; 224  : 	s_sfxHashList[sfx->hashValue] = sfx;

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR _s_sfxHashList[ecx*4], edx

; 225  : 		
; 226  : 	return sfx;

	mov	eax, DWORD PTR _sfx$[ebp]
$LN1@S_FindName:

; 227  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FindName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_pcht$ = -4						; size = 4
_pch$ = 8						; size = 4
_S_SkipSoundChar PROC

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 92   : 	char *pcht = (char *)pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _pcht$[ebp], eax

; 93   : 
; 94   : 	// check first character
; 95   : 	if( *pcht == '!' )

	mov	ecx, DWORD PTR _pcht$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN2@S_SkipSoun

; 96   : 		pcht++;

	mov	eax, DWORD PTR _pcht$[ebp]
	add	eax, 1
	mov	DWORD PTR _pcht$[ebp], eax
$LN2@S_SkipSoun:

; 97   : 	return pcht;

	mov	eax, DWORD PTR _pcht$[ebp]

; 98   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_SkipSoundChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_pcht$ = -8						; size = 4
_i$ = -4						; size = 4
_pch$ = 8						; size = 4
_c$ = 12						; size = 1
_S_TestSoundChar PROC

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 73   : 	char	*pcht = (char *)pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _pcht$[ebp], eax

; 74   : 	int	i;
; 75   : 
; 76   : 	if( !pch || !*pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN6@S_TestSoun
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@S_TestSoun
$LN6@S_TestSoun:

; 77   : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@S_TestSoun
$LN5@S_TestSoun:

; 78   : 
; 79   : 	// check first 2 characters
; 80   : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_TestSoun
$LN2@S_TestSoun:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_TestSoun:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@S_TestSoun

; 81   : 	{
; 82   : 		if( *pcht == c )

	mov	ecx, DWORD PTR _pcht$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	edx, eax
	jne	SHORT $LN7@S_TestSoun

; 83   : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@S_TestSoun
$LN7@S_TestSoun:

; 84   : 		pcht++;

	mov	ecx, DWORD PTR _pcht$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pcht$[ebp], ecx

; 85   : 	}

	jmp	SHORT $LN2@S_TestSoun
$LN3@S_TestSoun:

; 86   : 	return false;

	xor	eax, eax
$LN1@S_TestSoun:

; 87   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_TestSoundChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\client\s_load.c
_TEXT	SEGMENT
_sc$ = -4						; size = 4
_sfx$ = 8						; size = 4
_S_LoadSound PROC

; 128  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 129  : 	wavdata_t	*sc = NULL;

	mov	DWORD PTR _sc$[ebp], 0

; 130  : 
; 131  : 	if( !sfx ) return NULL;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN2@S_LoadSoun
	xor	eax, eax
	jmp	$LN1@S_LoadSoun
$LN2@S_LoadSoun:

; 132  : 
; 133  : 	// see if still in memory
; 134  : 	if( sfx->cache )

	mov	eax, DWORD PTR _sfx$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN3@S_LoadSoun

; 135  : 		return sfx->cache;

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	jmp	$LN1@S_LoadSoun
$LN3@S_LoadSoun:

; 136  : 
; 137  : 	if( !COM_CheckString( sfx->name ))

	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@S_LoadSoun

; 138  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@S_LoadSoun
$LN4@S_LoadSoun:

; 139  : 
; 140  : 	// load it from disk
; 141  : 	if( Q_stricmp( sfx->name, "*default" ))

	push	99999					; 0001869fH
	push	OFFSET $SG131942
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@S_LoadSoun

; 142  : 	{
; 143  : 		// load it from disk
; 144  : 		if( sfx->name[0] == '*' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _sfx$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN6@S_LoadSoun

; 145  : 			sc = FS_LoadSound( sfx->name + 1, NULL, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _sfx$[ebp]
	add	edx, 1
	push	edx
	call	_FS_LoadSound
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sc$[ebp], eax
	jmp	SHORT $LN5@S_LoadSoun
$LN6@S_LoadSoun:

; 146  : 		else sc = FS_LoadSound( sfx->name, NULL, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_FS_LoadSound
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sc$[ebp], eax
$LN5@S_LoadSoun:

; 147  : 	}
; 148  : 
; 149  : 	if( !sc ) sc = S_CreateDefaultSound();

	cmp	DWORD PTR _sc$[ebp], 0
	jne	SHORT $LN8@S_LoadSoun
	call	_S_CreateDefaultSound
	mov	DWORD PTR _sc$[ebp], eax
$LN8@S_LoadSoun:

; 150  : 
; 151  : 	if( sc->rate < SOUND_11k ) // some bad sounds

	mov	ecx, DWORD PTR _sc$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 11025				; 00002b11H
	jge	SHORT $LN9@S_LoadSoun

; 152  : 		Sound_Process( &sc, SOUND_11k, sc->width, SOUND_RESAMPLE );

	push	4096					; 00001000H
	mov	eax, DWORD PTR _sc$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	push	11025					; 00002b11H
	lea	edx, DWORD PTR _sc$[ebp]
	push	edx
	call	_Sound_Process
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@S_LoadSoun
$LN9@S_LoadSoun:

; 153  : 	else if( sc->rate > SOUND_11k && sc->rate < SOUND_22k ) // some bad sounds

	mov	eax, DWORD PTR _sc$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 11025				; 00002b11H
	jle	SHORT $LN11@S_LoadSoun
	mov	edx, DWORD PTR _sc$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 22050				; 00005622H
	jge	SHORT $LN11@S_LoadSoun

; 154  : 		Sound_Process( &sc, SOUND_22k, sc->width, SOUND_RESAMPLE );

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _sc$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	push	22050					; 00005622H
	lea	eax, DWORD PTR _sc$[ebp]
	push	eax
	call	_Sound_Process
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@S_LoadSoun
$LN11@S_LoadSoun:

; 155  : 	else if( sc->rate > SOUND_22k && sc->rate <= SOUND_32k ) // some bad sounds

	mov	ecx, DWORD PTR _sc$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 22050				; 00005622H
	jle	SHORT $LN10@S_LoadSoun
	mov	eax, DWORD PTR _sc$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 32000				; 00007d00H
	jg	SHORT $LN10@S_LoadSoun

; 156  : 		Sound_Process( &sc, SOUND_44k, sc->width, SOUND_RESAMPLE );

	push	4096					; 00001000H
	mov	edx, DWORD PTR _sc$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	push	44100					; 0000ac44H
	lea	ecx, DWORD PTR _sc$[ebp]
	push	ecx
	call	_Sound_Process
	add	esp, 16					; 00000010H
$LN10@S_LoadSoun:

; 157  : 
; 158  : 	sfx->cache = sc;

	mov	edx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR _sc$[ebp]
	mov	DWORD PTR [edx+64], eax

; 159  : 
; 160  : 	return sfx->cache;

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	eax, DWORD PTR [ecx+64]
$LN1@S_LoadSoun:

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_S_LoadSound ENDP
_TEXT	ENDS
END
