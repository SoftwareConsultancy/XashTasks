; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\client\cl_qparse.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_CL_EDICT_NUM
PUBLIC	_CL_ParseQuakeMessage
PUBLIC	_CL_ParseQuakeEntityData
PUBLIC	_CL_ParseQuakeParticle
PUBLIC	_CL_ParseQuakeStaticSound
PUBLIC	_CL_QuakeStuffText
PUBLIC	_CL_QuakeExecStuff
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3d800000
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb40000
PUBLIC	__real@41800000
PUBLIC	__real@41b00000
PUBLIC	__real@42800000
PUBLIC	__real@437f0000
PUBLIC	__real@44480000
PUBLIC	__real@44fa0000
PUBLIC	__real@465d7000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Exists:PROC
EXTRN	_Cmd_ExecuteString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_Exists:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Host_AbortCurrentFrame:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CSCR_LoadDefaultCVars:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_StopPlayback:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Con_Print:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_StopSound:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_sqrt:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteCoord:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadCmd:PROC
EXTRN	_MSG_ReadChar:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadCoord:PROC
EXTRN	_MSG_ReadFloat:PROC
EXTRN	_MSG_ReadVec3Coord:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_CL_SetLightstyle:PROC
EXTRN	_CL_AddToResourceList:PROC
EXTRN	_CL_Parse_Debug:PROC
EXTRN	_CL_Parse_RecordCommand:PROC
EXTRN	_CL_ResetFrame:PROC
EXTRN	_CL_SignonReply:PROC
EXTRN	_CL_ClearState:PROC
EXTRN	_CL_DemoCompleted:PROC
EXTRN	_CL_BatchResourceRequest:PROC
EXTRN	_CL_ParseFinaleCutscene:PROC
EXTRN	_CL_InitEdicts:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_DispatchUserMessage:PROC
EXTRN	_CL_ParseViewEntity:PROC
EXTRN	_CL_ParseServerTime:PROC
EXTRN	_CL_SetSolidEntities:PROC
EXTRN	_CL_ResetLatchedVars:PROC
EXTRN	_CL_ProcessPacket:PROC
EXTRN	_CL_IsPlayerIndex:PROC
EXTRN	_CL_KillDeadBeams:PROC
EXTRN	_Con_FixedFont:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_R_AddEfrags:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_IN_MouseRestorePos:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gameui:BYTE
EXTRN	_mp_decals:BYTE
EXTRN	_cl_levelshot_name:DWORD
EXTRN	_glState:BYTE
EXTRN	_r_decals:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_cmd_buf DB	02000H DUP (?)
_msg_buf DB	02020H DUP (?)
_msg_demo DB	014H DUP (?)
$SG144930 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@465d7000
CONST	SEGMENT
__real@465d7000 DD 0465d7000r			; 14172
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG144575 DB	'Stats', 00H
	ORG $+2
$SG144597 DB	'Stats', 00H
	ORG $+2
$SG144602 DB	'GameMode', 00H
	ORG $+3
$SG144639 DB	'Serverdata packet received.', 0aH, 00H
	ORG $+3
$SG144642 DB	0aH, '^1Error:^7 Server use invalid protocol (%i should b'
	DB	'e %i)', 0aH, 00H
	ORG $+1
$SG144644 DB	0aH, 01dH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01fH, 0aH, 00H
$SG144645 DB	'%c%s', 0aH, 0aH, 00H
	ORG $+1
$SG144648 DB	'user.scr', 00H
	ORG $+3
$SG144650 DB	'r_decals', 00H
	ORG $+3
$SG144651 DB	'r_decals', 00H
	ORG $+3
$SG144655 DB	'1', 00H
	ORG $+2
$SG144656 DB	'cl_background', 00H
	ORG $+2
$SG144657 DB	'0', 00H
	ORG $+2
$SG144658 DB	'cl_background', 00H
	ORG $+2
$SG144672 DB	'4x3', 00H
$SG144665 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_qparse.c', 00H
	ORG $+2
$SG144668 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\cl_qparse.c', 00H
	ORG $+2
$SG144671 DB	'16x9', 00H
	ORG $+3
$SG144673 DB	'levelshots/%s_%s', 00H
	ORG $+3
$SG144674 DB	'cl_levelshot_name', 00H
	ORG $+2
$SG144675 DB	'16x9', 00H
	ORG $+3
$SG144676 DB	'4x3', 00H
$SG144677 DB	'levelshots/%s_%s', 00H
	ORG $+3
$SG144678 DB	'cl_levelshot_name', 00H
	ORG $+2
$SG144679 DB	'scr_loading', 00H
$SG144684 DB	'%s.bmp', 00H
	ORG $+1
$SG144685 DB	'*black', 00H
	ORG $+1
$SG144686 DB	'cl_levelshot_name', 00H
	ORG $+2
$SG144709 DB	'Items', 00H
	ORG $+2
$SG144800 DB	'Damage', 00H
	ORG $+1
$SG144844 DB	'TempEntity', 00H
	ORG $+1
$SG144813 DB	'^1Error:^7 CL_ParseStaticEntity: static entities limit e'
	DB	'xceeded!', 0aH, 00H
	ORG $+2
$SG144831 DB	'CL_AllocEdict: no free edicts', 0aH, 00H
	ORG $+1
$SG144851 DB	'CL_Signon: %d', 0aH, 00H
	ORG $+1
$SG144856 DB	'Stats', 00H
	ORG $+2
$SG144861 DB	'Stats', 00H
	ORG $+2
$SG144886 DB	'^3Warning:^7 ''%s'' is not exist', 0aH, 00H
$SG144888 DB	'playdemo', 00H
	ORG $+3
$SG144910 DB	'UserMsg', 00H
$SG144915 DB	'CL_ParseServerMessage: overflow!', 0aH, 00H
	ORG $+2
$SG144923 DB	'Server is protocol %i instead of %i', 0aH, 00H
	ORG $+3
$SG144927 DB	0aH, 00H
	ORG $+2
$SG144929 DB	0aH, 00H
	ORG $+2
$SG144931 DB	'%s%s', 00H
	ORG $+3
$SG144937 DB	'player', 00H
	ORG $+1
$SG144951 DB	'HudText', 00H
$SG144953 DB	'KillMonster', 00H
$SG144955 DB	'FoundSecret', 00H
$SG144964 DB	'help', 00H
	ORG $+3
$SG144974 DB	'CL_ParseServerMessage: Illegible server message', 0aH, 00H
_DATA	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
_DATA	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
$T1 = -272						; size = 4
_argc$ = -268						; size = 4
_text$ = -264						; size = 4
_token$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_CL_QuakeExecStuff PROC

; 839  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 840  : 	char	*text = cmd_buf;

	mov	DWORD PTR _text$[ebp], OFFSET _cmd_buf

; 841  : 	char	token[256];
; 842  : 	int	argc = 0;

	mov	DWORD PTR _argc$[ebp], 0

; 843  : 
; 844  : 	// check if no commands this frame
; 845  : 	if( !COM_CheckString( text ))

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_QuakeEx

; 846  : 		return;

	jmp	$LN15@CL_QuakeEx
$LN2@CL_QuakeEx:

; 847  : 
; 848  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@CL_QuakeEx
$LN4@CL_QuakeEx:

; 849  : 	{
; 850  : 		// skip whitespace up to a /n
; 851  : 		while( *text && ((byte)*text) <= ' ' && *text != '\r' && *text != '\n' )

	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@CL_QuakeEx
	mov	ecx, DWORD PTR _text$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jg	SHORT $LN5@CL_QuakeEx
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN5@CL_QuakeEx
	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN5@CL_QuakeEx

; 852  : 			text++;

	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx
	jmp	SHORT $LN4@CL_QuakeEx
$LN5@CL_QuakeEx:

; 853  : 
; 854  : 		if( *text == '\n' || *text == '\r' )

	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN8@CL_QuakeEx
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@CL_QuakeEx
$LN8@CL_QuakeEx:

; 855  : 		{
; 856  : 			// a newline seperates commands in the buffer
; 857  : 			if( *text == '\r' && text[1] == '\n' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@CL_QuakeEx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN9@CL_QuakeEx

; 858  : 				text++;

	mov	edx, DWORD PTR _text$[ebp]
	add	edx, 1
	mov	DWORD PTR _text$[ebp], edx
$LN9@CL_QuakeEx:

; 859  : 			argc = 0;

	mov	DWORD PTR _argc$[ebp], 0

; 860  : 			text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
$LN7@CL_QuakeEx:

; 861  : 		}
; 862  : 
; 863  : 		if( !*text ) break;

	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN10@CL_QuakeEx
	jmp	$LN3@CL_QuakeEx
$LN10@CL_QuakeEx:

; 864  : 
; 865  : 		host.com_ignorebracket = true;

	mov	DWORD PTR _host+34364, 1

; 866  : 		text = COM_ParseFile( text, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _text$[ebp], eax

; 867  : 		host.com_ignorebracket = false;

	mov	DWORD PTR _host+34364, 0

; 868  : 
; 869  : 		if( !text ) break;

	cmp	DWORD PTR _text$[ebp], 0
	jne	SHORT $LN11@CL_QuakeEx
	jmp	SHORT $LN3@CL_QuakeEx
$LN11@CL_QuakeEx:

; 870  : 
; 871  : 		if( argc == 0 )

	cmp	DWORD PTR _argc$[ebp], 0
	jne	SHORT $LN12@CL_QuakeEx

; 872  : 		{
; 873  : 			// debug: find all missed commands and cvars to add them into QWrap
; 874  : 			if( !Cvar_Exists( token ) && !Cmd_Exists( token ))

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Cvar_Exists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@CL_QuakeEx
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@CL_QuakeEx

; 875  : 				Con_Printf( S_WARN "'%s' is not exist\n", token );

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	OFFSET $SG144886
	call	_Con_Printf
	add	esp, 8
$LN13@CL_QuakeEx:

; 876  : //			else Msg( "cmd: %s\n", token );
; 877  : 
; 878  : 			// process some special commands
; 879  : 			if( !Q_stricmp( token, "playdemo" ))

	push	99999					; 0001869fH
	push	OFFSET $SG144888
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@CL_QuakeEx

; 880  : 				cls.changedemo = true;

	mov	DWORD PTR _cls+12, 1
$LN14@CL_QuakeEx:

; 881  : 			argc++;

	mov	eax, DWORD PTR _argc$[ebp]
	add	eax, 1
	mov	DWORD PTR _argc$[ebp], eax
$LN12@CL_QuakeEx:

; 882  : 		}
; 883  : 	}

	jmp	$LN2@CL_QuakeEx
$LN3@CL_QuakeEx:

; 884  : 
; 885  : 	// reset the buffer
; 886  : 	cmd_buf[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 8192		; 00002000H
	jae	SHORT $LN16@CL_QuakeEx
	jmp	SHORT $LN17@CL_QuakeEx
$LN16@CL_QuakeEx:
	call	___report_rangecheckfailure
$LN17@CL_QuakeEx:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cmd_buf[eax], 0
$LN15@CL_QuakeEx:

; 887  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_QuakeExecStuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_text$ = 8						; size = 4
_CL_QuakeStuffText PROC

; 827  : {

	push	ebp
	mov	ebp, esp

; 828  : 	Q_strncat( cmd_buf, text, sizeof( cmd_buf ));

	push	8192					; 00002000H
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _cmd_buf
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 829  : 	Cbuf_AddText( text );

	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_Cbuf_AddText
	add	esp, 4

; 830  : }

	pop	ebp
	ret	0
_CL_QuakeStuffText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseNehahraHideLMP PROC

; 815  : {

	push	ebp
	mov	ebp, esp

; 816  : 	MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8

; 817  : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET $SG144861
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 818  : }

	pop	ebp
	ret	0
_CL_ParseNehahraHideLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseNehahraShowLMP PROC

; 799  : {

	push	ebp
	mov	ebp, esp

; 800  : 	MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8

; 801  : 	MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8

; 802  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 803  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 804  : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET $SG144856
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 805  : }

	pop	ebp
	ret	0
_CL_ParseNehahraShowLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeSignon PROC

; 784  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 785  : 	int	i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 786  : 
; 787  : 	if( i == 3 ) cls.signon = SIGNONS - 1;

	cmp	DWORD PTR _i$[ebp], 3
	jne	SHORT $LN2@CL_ParseQu
	mov	DWORD PTR _cls+64, 1
$LN2@CL_ParseQu:

; 788  : 	Con_Reportf( "CL_Signon: %d\n", i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET $SG144851
	call	_Con_Reportf
	add	esp, 8

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeSignon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_type$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeTempEntity PROC

; 736  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 737  : 	int	type = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 738  : 
; 739  : 	MSG_WriteByte( &msg_demo, type );

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 740  : 
; 741  : 	if( type == 17 )

	cmp	DWORD PTR _type$[ebp], 17		; 00000011H
	jne	SHORT $LN2@CL_ParseQu

; 742  : 		MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8
$LN2@CL_ParseQu:

; 743  : 
; 744  : 	// TE_LIGHTNING1, TE_LIGHTNING2, TE_LIGHTNING3, TE_BEAM, TE_LIGHTNING4
; 745  : 	if( type == 5 || type == 6 || type == 9 || type == 13 || type == 17 )

	cmp	DWORD PTR _type$[ebp], 5
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 6
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 9
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 13		; 0000000dH
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 17		; 00000011H
	jne	SHORT $LN3@CL_ParseQu
$LN4@CL_ParseQu:

; 746  : 		MSG_WriteWord( &msg_demo, MSG_ReadWord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteWord
	add	esp, 8
$LN3@CL_ParseQu:

; 747  : 
; 748  : 	// all temp ents have position at beginning
; 749  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 750  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 751  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 752  : 
; 753  : 	// TE_LIGHTNING1, TE_LIGHTNING2, TE_LIGHTNING3, TE_BEAM, TE_EXPLOSION3, TE_LIGHTNING4
; 754  : 	if( type == 5 || type == 6 || type == 9 || type == 13 || type == 16 || type == 17 )

	cmp	DWORD PTR _type$[ebp], 5
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 6
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 9
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 13		; 0000000dH
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 16		; 00000010H
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 17		; 00000011H
	jne	SHORT $LN5@CL_ParseQu
$LN6@CL_ParseQu:

; 755  : 	{
; 756  : 		// write endpos for beams
; 757  : 		MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 758  : 		MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 759  : 		MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8
$LN5@CL_ParseQu:

; 760  : 	}
; 761  : 
; 762  : 	// TE_EXPLOSION2
; 763  : 	if( type == 12 )

	cmp	DWORD PTR _type$[ebp], 12		; 0000000cH
	jne	SHORT $LN7@CL_ParseQu

; 764  : 	{
; 765  : 		MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 766  : 		MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8
$LN7@CL_ParseQu:

; 767  : 	}
; 768  : 
; 769  : 	// TE_SMOKE (nehahra)
; 770  : 	if( type == 18 )

	cmp	DWORD PTR _type$[ebp], 18		; 00000012H
	jne	SHORT $LN8@CL_ParseQu

; 771  : 		MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8
$LN8@CL_ParseQu:

; 772  : 
; 773  : 	CL_DispatchQuakeMessage( "TempEntity" );

	push	OFFSET $SG144844
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 774  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeTempEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_newnum$ = -352						; size = 4
_ent$ = -348						; size = 4
_state$ = -344						; size = 340
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeBaseline PROC

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 698  : 	entity_state_t	state;
; 699  : 	cl_entity_t	*ent;
; 700  : 	int		newnum;
; 701  : 
; 702  : 	memset( &state, 0, sizeof( state ));

	push	340					; 00000154H
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 703  : 	newnum = MSG_ReadWord( msg ); // entnum

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _newnum$[ebp], eax

; 704  : 
; 705  : 	if( newnum >= clgame.maxEntities )

	mov	edx, DWORD PTR _newnum$[ebp]
	cmp	edx, DWORD PTR _clgame+1012
	jl	SHORT $LN2@CL_ParseQu

; 706  : 		Host_Error( "CL_AllocEdict: no free edicts\n" );

	push	OFFSET $SG144831
	call	_Host_Error
	add	esp, 4
$LN2@CL_ParseQu:

; 707  : 
; 708  : 	ent = CL_EDICT_NUM( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 709  : 	memset( &ent->prevstate, 0, sizeof( ent->prevstate ));

	push	340					; 00000154H
	push	0
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 348				; 0000015cH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 710  : 	ent->index = newnum;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [edx], eax

; 711  : 
; 712  : 	// parse baseline
; 713  : 	state.modelindex = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+40], eax

; 714  : 	state.frame = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _state$[ebp+48], xmm0

; 715  : 	state.colormap = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+52], eax

; 716  : 	state.skin = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	WORD PTR _state$[ebp+56], ax

; 717  : 	state.origin[0] = MSG_ReadCoord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 718  : 	state.angles[0] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _state$[ebp+ecx+28], xmm0

; 719  : 	state.origin[1] = MSG_ReadCoord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _state$[ebp+eax+16]

; 720  : 	state.angles[1] = MSG_ReadAngle( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _state$[ebp+edx+28], xmm0

; 721  : 	state.origin[2] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 722  : 	state.angles[2] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _state$[ebp+eax+28], xmm0

; 723  : 	ent->player = CL_IsPlayerIndex( newnum );

	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 724  : 
; 725  : 	memcpy( &ent->baseline, &state, sizeof( entity_state_t ));

	push	340					; 00000154H
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 8
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 726  : 	memcpy( &ent->prevstate, &state, sizeof( entity_state_t ));

	push	340					; 00000154H
	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 727  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_i$ = -352						; size = 4
_ent$ = -348						; size = 4
_state$ = -344						; size = 340
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeStaticEntity PROC

; 633  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 634  : 	entity_state_t	state;
; 635  : 	cl_entity_t	*ent;
; 636  : 	int		i;
; 637  : 
; 638  : 	memset( &state, 0, sizeof( state ));

	push	340					; 00000154H
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 639  : 
; 640  : 	state.modelindex = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+40], eax

; 641  : 	state.frame = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _state$[ebp+48], xmm0

; 642  : 	state.colormap = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+52], eax

; 643  : 	state.skin = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	WORD PTR _state$[ebp+56], ax

; 644  : 	state.origin[0] = MSG_ReadCoord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	imul	ecx, eax, 0
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 645  : 	state.angles[0] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _state$[ebp+ecx+28], xmm0

; 646  : 	state.origin[1] = MSG_ReadCoord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	fstp	DWORD PTR _state$[ebp+eax+16]

; 647  : 	state.angles[1] = MSG_ReadAngle( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _state$[ebp+edx+28], xmm0

; 648  : 	state.origin[2] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 649  : 	state.angles[2] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _state$[ebp+eax+28], xmm0

; 650  : 
; 651  : 	i = clgame.numStatics;

	mov	ecx, DWORD PTR _clgame+1020
	mov	DWORD PTR _i$[ebp], ecx

; 652  : 	if( i >= MAX_STATIC_ENTITIES )

	cmp	DWORD PTR _i$[ebp], 3096		; 00000c18H
	jl	SHORT $LN2@CL_ParseQu

; 653  : 	{
; 654  : 		Con_Printf( S_ERROR "CL_ParseStaticEntity: static entities limit exceeded!\n" );

	push	OFFSET $SG144813
	call	_Con_Printf
	add	esp, 4

; 655  : 		return;

	jmp	$LN1@CL_ParseQu
$LN2@CL_ParseQu:

; 656  : 	}
; 657  : 
; 658  : 	ent = &clgame.static_entities[i];

	imul	edx, DWORD PTR _i$[ebp], 3000
	add	edx, DWORD PTR _clgame+1004
	mov	DWORD PTR _ent$[ebp], edx

; 659  : 	clgame.numStatics++;

	mov	eax, DWORD PTR _clgame+1020
	add	eax, 1
	mov	DWORD PTR _clgame+1020, eax

; 660  : 
; 661  : 	ent->index = 0; // ???

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx], 0

; 662  : 	ent->baseline = state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 8
	mov	ecx, 85					; 00000055H
	lea	esi, DWORD PTR _state$[ebp]
	rep movsd

; 663  : 	ent->curstate = state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 688				; 000002b0H
	mov	ecx, 85					; 00000055H
	lea	esi, DWORD PTR _state$[ebp]
	rep movsd

; 664  : 	ent->prevstate = state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 348				; 0000015cH
	mov	ecx, 85					; 00000055H
	lea	esi, DWORD PTR _state$[ebp]
	rep movsd

; 665  : 
; 666  : 	// statics may be respawned in game e.g. for demo recording
; 667  : 	if( cls.state == ca_connected || cls.state == ca_validate )

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _cls, 3
	jne	SHORT $LN3@CL_ParseQu
$LN4@CL_ParseQu:

; 668  : 		ent->trivial_accept = INVALID_HANDLE;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+2960], 65535		; 0000ffffH
$LN3@CL_ParseQu:

; 669  : 
; 670  : 	// setup the new static entity
; 671  : 	VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+704]
	mov	DWORD PTR [edx+eax+2888], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+704]
	mov	DWORD PTR [ecx+eax+2888], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+704]
	mov	DWORD PTR [edx+ecx+2888], eax

; 672  : 	VectorCopy( ent->curstate.angles, ent->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+716]
	mov	DWORD PTR [eax+ecx+2900], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+716]
	mov	DWORD PTR [edx+ecx+2900], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+716]
	mov	DWORD PTR [eax+edx+2900], ecx

; 673  : 	ent->model = CL_ModelHandle( state.modelindex );

	mov	edx, DWORD PTR _state$[ebp+40]
	push	edx
	call	_CL_ModelHandle
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+2964], eax

; 674  : 	ent->curstate.framerate = 1.0f;

	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+784], xmm0

; 675  : 	CL_ResetLatchedVars( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8

; 676  : 
; 677  : 	if( ent->model != NULL )

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	je	SHORT $LN6@CL_ParseQu

; 678  : 	{
; 679  : 		// auto 'solid' faces
; 680  : 		if( FBitSet( ent->model->flags, MODEL_TRANSPARENT ) && CL_IsQuakeCompatible( ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 8
	je	SHORT $LN6@CL_ParseQu
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN6@CL_ParseQu

; 681  : 		{
; 682  : 			ent->curstate.rendermode = kRenderTransAlpha;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+760], 4

; 683  : 			ent->curstate.renderamt = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+764], 255		; 000000ffH
$LN6@CL_ParseQu:

; 684  : 		}
; 685  : 	}
; 686  : 
; 687  : 	R_AddEfrags( ent );	// add link

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_R_AddEfrags
	add	esp, 4
$LN1@CL_ParseQu:

; 688  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeStaticEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseQuakeDamage PROC

; 617  : {

	push	ebp
	mov	ebp, esp

; 618  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));	// armor

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 619  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));	// blood

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 620  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));	// direction

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 621  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));	// direction

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 622  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));	// direction

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 623  : 	CL_DispatchQuakeMessage( "Damage" );

	push	OFFSET $SG144800
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 624  : }

	pop	ebp
	ret	0
_CL_ParseQuakeDamage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_sound_num$ = -28					; size = 4
_vol$ = -24						; size = 4
_attn$ = -20						; size = 4
_org$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeStaticSound PROC

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 597  : 	int	sound_num;
; 598  : 	float 	vol, attn;
; 599  : 	vec3_t	org;
; 600  : 
; 601  : 	MSG_ReadVec3Coord( msg, org );	

	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 602  : 	sound_num = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _sound_num$[ebp], eax

; 603  : 	vol = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _vol$[ebp], xmm0

; 604  : 	attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0

; 605  : 
; 606  : 	S_StartSound( org, 0, CHAN_STATIC, cl.sound_index[sound_num], vol, attn, PITCH_NORM, 0 );	

	push	0
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sound_num$[ebp]
	movsx	eax, WORD PTR _cl[edx*2+2681456]
	push	eax
	push	6
	push	0
	lea	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 607  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeStaticSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_color$ = -36						; size = 4
_count$ = -32						; size = 4
_org$ = -28						; size = 12
_dir$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeParticle PROC

; 574  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 575  : 	int	count, color;
; 576  : 	vec3_t	org, dir;
; 577  : 	
; 578  : 	MSG_ReadVec3Coord( msg, org );	

	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 579  : 	dir[0] = MSG_ReadChar( msg ) * 0.0625f;

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 580  : 	dir[1] = MSG_ReadChar( msg ) * 0.0625f;

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0

; 581  : 	dir[2] = MSG_ReadChar( msg ) * 0.0625f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 582  : 	count = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 583  : 	color = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 584  : 	if( count == 255 ) count = 1024;

	cmp	DWORD PTR _count$[ebp], 255		; 000000ffH
	jne	SHORT $LN2@CL_ParseQu
	mov	DWORD PTR _count$[ebp], 1024		; 00000400H
$LN2@CL_ParseQu:

; 585  : 
; 586  : 	R_RunParticleEffect( org, dir, color, count );

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	lea	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_R_RunParticleEffect
	add	esp, 16					; 00000010H

; 587  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeParticle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
tv355 = -48						; size = 4
tv520 = -44						; size = 4
_temp$1 = -40						; size = 4
_i$ = -36						; size = 4
tv352 = -32						; size = 4
_forcelink$ = -28					; size = 4
_pack$ = -24						; size = 4
_alpha$2 = -20						; size = 4
_newnum$ = -16						; size = 4
_frame$ = -12						; size = 4
_ent$ = -8						; size = 4
_state$ = -4						; size = 4
_msg$ = 8						; size = 4
_bits$ = 12						; size = 4
_CL_ParseQuakeEntityData PROC

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi

; 424  : 	int		i, newnum, pack;
; 425  : 	qboolean		forcelink;
; 426  : 	entity_state_t	*state;
; 427  : 	frame_t		*frame;
; 428  : 	cl_entity_t	*ent;
; 429  : 
; 430  : 	// first update is the final signon stage where we actually receive an entity (i.e., the world at least)
; 431  : 	if( cls.signon == ( SIGNONS - 1 ))

	cmp	DWORD PTR _cls+64, 1
	jne	SHORT $LN2@CL_ParseQu

; 432  : 	{
; 433  : 		// we are done with signon sequence.
; 434  : 		cls.signon = SIGNONS;

	mov	DWORD PTR _cls+64, 2

; 435  : 
; 436  : 		// Clear loading plaque.
; 437  : 		CL_SignonReply ();

	call	_CL_SignonReply
$LN2@CL_ParseQu:

; 438  : 	}
; 439  : 
; 440  : 	// alloc next slot to store update
; 441  : 	state = &cls.packet_entities[cls.next_client_entities % cls.num_client_entities];

	mov	eax, DWORD PTR _cls+291760
	cdq
	idiv	DWORD PTR _cls+291756
	imul	eax, edx, 340
	add	eax, DWORD PTR _cls+291764
	mov	DWORD PTR _state$[ebp], eax

; 442  : 	cl.validsequence = cls.netchan.incoming_sequence;

	mov	ecx, DWORD PTR _cls+23584
	mov	DWORD PTR _cl+4, ecx

; 443  : 	frame = &cl.frames[cl.parsecountmod];

	imul	edx, DWORD PTR _cl+12, 17304
	add	edx, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], edx

; 444  : 	pack = frame->num_entities;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+17296]
	mov	DWORD PTR _pack$[ebp], ecx

; 445  : 
; 446  : 	if( FBitSet( bits, U_MOREBITS ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 1
	je	SHORT $LN3@CL_ParseQu

; 447  : 	{
; 448  : 		i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 449  : 		SetBits( bits, i << 8 );

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	or	ecx, DWORD PTR _bits$[ebp]
	mov	DWORD PTR _bits$[ebp], ecx
$LN3@CL_ParseQu:

; 450  : 	}
; 451  : 
; 452  : 	if( FBitSet( bits, U_LONGENTITY ))	

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 16384				; 00004000H
	je	SHORT $LN4@CL_ParseQu

; 453  : 		newnum = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _newnum$[ebp], eax
	jmp	SHORT $LN5@CL_ParseQu
$LN4@CL_ParseQu:

; 454  : 	else newnum = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _newnum$[ebp], eax
$LN5@CL_ParseQu:

; 455  : 
; 456  : 	memset( state, 0, sizeof( *state ));

	push	340					; 00000154H
	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 457  : 	SetBits( state->entityType, ENTITY_NORMAL );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], ecx

; 458  : 	state->number = newnum;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 459  : 
; 460  : 	// mark all the players
; 461  : 	ent = CL_EDICT_NUM( newnum );

	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 462  : 	ent->index = newnum; // enumerate entity index

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 463  : 	ent->player = CL_IsPlayerIndex( newnum );

	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 464  : 	state->animtime = cl.mtime[0];

	mov	edx, 8
	imul	eax, edx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[eax+32]
	mov	ecx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [ecx+92], xmm0

; 465  : 
; 466  : 	if( ent->curstate.msg_time != cl.mtime[1] )

	mov	edx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+696]
	mov	eax, 8
	shl	eax, 0
	ucomisd	xmm0, QWORD PTR _cl[eax+32]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_ParseQu

; 467  : 		forcelink = true;	// no previous frame to lerp from

	mov	DWORD PTR _forcelink$[ebp], 1
	jmp	SHORT $LN7@CL_ParseQu
$LN6@CL_ParseQu:

; 468  : 	else forcelink = false;

	mov	DWORD PTR _forcelink$[ebp], 0
$LN7@CL_ParseQu:

; 469  : 	
; 470  : 	if( FBitSet( bits, U_MODEL ))

	mov	ecx, DWORD PTR _bits$[ebp]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN8@CL_ParseQu

; 471  : 		state->modelindex = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN9@CL_ParseQu
$LN8@CL_ParseQu:

; 472  : 	else state->modelindex = ent->baseline.modelindex;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+40], ecx
$LN9@CL_ParseQu:

; 473  : 
; 474  : 	if( FBitSet( bits, U_FRAME ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN10@CL_ParseQu

; 475  : 		state->frame = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [ecx+48], xmm0
	jmp	SHORT $LN11@CL_ParseQu
$LN10@CL_ParseQu:

; 476  : 	else state->frame = ent->baseline.frame;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+48], ecx
$LN11@CL_ParseQu:

; 477  : 
; 478  : 	if( FBitSet( bits, U_COLORMAP ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN12@CL_ParseQu

; 479  : 		state->colormap = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+52], eax
	jmp	SHORT $LN13@CL_ParseQu
$LN12@CL_ParseQu:

; 480  : 	else state->colormap = ent->baseline.colormap;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+52], ecx
$LN13@CL_ParseQu:

; 481  : 
; 482  : 	if( FBitSet( bits, U_SKIN ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 4096				; 00001000H
	je	SHORT $LN14@CL_ParseQu

; 483  : 		state->skin = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	WORD PTR [ecx+56], ax
	jmp	SHORT $LN15@CL_ParseQu
$LN14@CL_ParseQu:

; 484  : 	else state->skin = ent->baseline.skin;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	cx, WORD PTR [eax+64]
	mov	WORD PTR [edx+56], cx
$LN15@CL_ParseQu:

; 485  : 
; 486  : 	if( FBitSet( bits, U_EFFECTS ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 8192				; 00002000H
	je	SHORT $LN16@CL_ParseQu

; 487  : 		state->effects = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+60], eax
	jmp	SHORT $LN17@CL_ParseQu
$LN16@CL_ParseQu:

; 488  : 	else state->effects = ent->baseline.effects;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+60], ecx
$LN17@CL_ParseQu:

; 489  : 
; 490  : 	if( FBitSet( bits, U_ORIGIN1 ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 2
	je	SHORT $LN18@CL_ParseQu

; 491  : 		state->origin[0] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _state$[ebp]
	fstp	DWORD PTR [eax+edx+16]
	jmp	SHORT $LN19@CL_ParseQu
$LN18@CL_ParseQu:

; 492  : 	else state->origin[0] = ent->baseline.origin[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+24]
	mov	DWORD PTR [eax+ecx+16], edx
$LN19@CL_ParseQu:

; 493  : 
; 494  : 	if( FBitSet( bits, U_ANGLE1 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN20@CL_ParseQu

; 495  : 		state->angles[0] = MSG_ReadAngle( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [ecx+eax+28], xmm0
	jmp	SHORT $LN21@CL_ParseQu
$LN20@CL_ParseQu:

; 496  : 	else state->angles[0] = ent->baseline.angles[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [ecx+edx+28], eax
$LN21@CL_ParseQu:

; 497  : 
; 498  : 	if( FBitSet( bits, U_ORIGIN2 ))

	mov	ecx, DWORD PTR _bits$[ebp]
	and	ecx, 4
	je	SHORT $LN22@CL_ParseQu

; 499  : 		state->origin[1] = MSG_ReadCoord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	fstp	DWORD PTR [ecx+eax+16]
	jmp	SHORT $LN23@CL_ParseQu
$LN22@CL_ParseQu:

; 500  : 	else state->origin[1] = ent->baseline.origin[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+24]
	mov	DWORD PTR [ecx+eax+16], edx
$LN23@CL_ParseQu:

; 501  : 
; 502  : 	if( FBitSet( bits, U_ANGLE2 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN24@CL_ParseQu

; 503  : 		state->angles[1] = MSG_ReadAngle( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _state$[ebp]
	movss	DWORD PTR [eax+edx+28], xmm0
	jmp	SHORT $LN25@CL_ParseQu
$LN24@CL_ParseQu:

; 504  : 	else state->angles[1] = ent->baseline.angles[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+36]
	mov	DWORD PTR [eax+edx+28], ecx
$LN25@CL_ParseQu:

; 505  : 
; 506  : 	if( FBitSet( bits, U_ORIGIN3 ))

	mov	edx, DWORD PTR _bits$[ebp]
	and	edx, 8
	je	SHORT $LN26@CL_ParseQu

; 507  : 		state->origin[2] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	fstp	DWORD PTR [edx+ecx+16]
	jmp	SHORT $LN27@CL_ParseQu
$LN26@CL_ParseQu:

; 508  : 	else state->origin[2] = ent->baseline.origin[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+24]
	mov	DWORD PTR [edx+ecx+16], eax
$LN27@CL_ParseQu:

; 509  : 
; 510  : 	if( FBitSet( bits, U_ANGLE3 ))

	mov	ecx, DWORD PTR _bits$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN28@CL_ParseQu

; 511  : 		state->angles[2] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [ecx+eax+28], xmm0
	jmp	SHORT $LN29@CL_ParseQu
$LN28@CL_ParseQu:

; 512  : 	else state->angles[2] = ent->baseline.angles[2];

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+36]
	mov	DWORD PTR [ecx+eax+28], edx
$LN29@CL_ParseQu:

; 513  : 
; 514  : 	if( FBitSet( bits, U_TRANS ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 32768				; 00008000H
	je	$LN33@CL_ParseQu

; 515  : 	{
; 516  : 		int	temp = MSG_ReadFloat( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadFloat
	add	esp, 4
	call	__ftol2_sse
	mov	DWORD PTR _temp$1[ebp], eax

; 517  : 		float	alpha = MSG_ReadFloat( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR _alpha$2[ebp]

; 518  : 
; 519  : 		if( alpha == 0.0f ) alpha = 1.0f;

	movss	xmm0, DWORD PTR _alpha$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@CL_ParseQu
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$2[ebp], xmm0
$LN31@CL_ParseQu:

; 520  : 
; 521  : 		if( alpha < 1.0f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _alpha$2[ebp]
	jbe	SHORT $LN32@CL_ParseQu

; 522  : 		{
; 523  : 			state->rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+72], 2

; 524  : 			state->renderamt = (int)(alpha * 255.0f);

	movss	xmm0, DWORD PTR _alpha$2[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN32@CL_ParseQu:

; 525  : 		}
; 526  : 
; 527  : 		if( temp == 2 && MSG_ReadFloat( msg ))

	cmp	DWORD PTR _temp$1[ebp], 2
	jne	SHORT $LN33@CL_ParseQu
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR tv520[ebp]
	movss	xmm0, DWORD PTR tv520[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN33@CL_ParseQu

; 528  : 			SetBits( state->effects, EF_FULLBRIGHT );

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	or	edx, 134217728				; 08000000H
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+60], edx
$LN33@CL_ParseQu:

; 529  : 	}
; 530  : 
; 531  : 	if( FBitSet( bits, U_NOLERP ))

	mov	ecx, DWORD PTR _bits$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN34@CL_ParseQu

; 532  : 		state->movetype = MOVETYPE_STEP;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+88], 4
	jmp	SHORT $LN35@CL_ParseQu
$LN34@CL_ParseQu:

; 533  : 	else state->movetype = MOVETYPE_NOCLIP;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+88], 8
$LN35@CL_ParseQu:

; 534  : 
; 535  : 	if( CL_QuakeEntityTeleported( ent, state ))

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_QuakeEntityTeleported
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@CL_ParseQu

; 536  : 	{
; 537  : 		// remove smooth stepping
; 538  : 		if( cl.viewentity == ent->index )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cl+1568608
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN37@CL_ParseQu

; 539  : 			cl.skip_interp = true;

	mov	DWORD PTR _cl+76, 1
$LN37@CL_ParseQu:

; 540  : 		forcelink = true;

	mov	DWORD PTR _forcelink$[ebp], 1
$LN36@CL_ParseQu:

; 541  : 	}
; 542  : 
; 543  : 	if( FBitSet( state->effects, 16 ))

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+60]
	and	eax, 16					; 00000010H
	je	SHORT $LN38@CL_ParseQu

; 544  : 		SetBits( state->effects, EF_NODRAW );

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+60], edx
$LN38@CL_ParseQu:

; 545  : 
; 546  : 	if(( newnum - 1 ) == cl.playernum )

	mov	ecx, DWORD PTR _newnum$[ebp]
	sub	ecx, 1
	cmp	ecx, DWORD PTR _cl+1568828
	jne	SHORT $LN39@CL_ParseQu

; 547  : 		VectorCopy( state->origin, frame->clientdata.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [ecx+edx+32], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _frame$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+32], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+32], edx
$LN39@CL_ParseQu:

; 548  : 
; 549  : 	if( forcelink )

	cmp	DWORD PTR _forcelink$[ebp], 0
	je	$LN40@CL_ParseQu

; 550  : 	{
; 551  : 		VectorCopy( state->origin, ent->baseline.vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+300], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+300], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+300], eax

; 552  : 
; 553  : 		SetBits( state->effects, EF_NOINTERP );

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+60], edx

; 554  : 
; 555  : 		// interpolation must be reset
; 556  : 		SETVISBIT( frame->flags, pack );

	cmp	DWORD PTR _pack$[ebp], 0
	jl	SHORT $LN42@CL_ParseQu
	mov	edx, DWORD PTR _pack$[ebp]
	sar	edx, 3
	mov	ecx, DWORD PTR _pack$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _frame$[ebp]
	movzx	edx, BYTE PTR [ecx+edx+17038]
	or	edx, eax
	mov	DWORD PTR tv352[ebp], edx
	mov	eax, DWORD PTR _pack$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	dl, BYTE PTR tv352[ebp]
	mov	BYTE PTR [ecx+eax+17038], dl
	movzx	eax, BYTE PTR tv352[ebp]
	mov	DWORD PTR tv355[ebp], eax
	jmp	SHORT $LN43@CL_ParseQu
$LN42@CL_ParseQu:
	mov	DWORD PTR tv355[ebp], 0
$LN43@CL_ParseQu:

; 557  : 
; 558  : 		// release beams from previous entity
; 559  : 		CL_KillDeadBeams( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_KillDeadBeams
	add	esp, 4
$LN40@CL_ParseQu:

; 560  : 	}
; 561  : 
; 562  : 	// add entity to packet
; 563  : 	cls.next_client_entities++;

	mov	edx, DWORD PTR _cls+291760
	add	edx, 1
	mov	DWORD PTR _cls+291760, edx

; 564  : 	frame->num_entities++;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+17296]
	add	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+17296], ecx

; 565  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeEntityData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_bits$ = -12						; size = 4
_i$ = -8						; size = 4
_frame$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeClientData PROC

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 347  : 	int	i, bits = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _bits$[ebp], eax

; 348  : 	frame_t	*frame;
; 349  : 
; 350  : 	// this is the frame update that this message corresponds to
; 351  : 	i = cls.netchan.incoming_sequence;

	mov	ecx, DWORD PTR _cls+23584
	mov	DWORD PTR _i$[ebp], ecx

; 352  : 
; 353  : 	cl.parsecount = i;					// ack'd incoming messages.  

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cl+8, edx

; 354  : 	cl.parsecountmod = cl.parsecount & CL_UPDATE_MASK;	// index into window.     

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cl+8
	mov	DWORD PTR _cl+12, eax

; 355  : 	frame = &cl.frames[cl.parsecountmod];			// frame at index.

	imul	ecx, DWORD PTR _cl+12, 17304
	add	ecx, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], ecx

; 356  : 	frame->time = cl.mtime[0];				// mark network received time

	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _cl[eax+32]
	movsd	QWORD PTR [ecx+16], xmm0

; 357  : 	frame->receivedtime = host.realtime;			// time now that we are parsing.  

	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx], xmm0

; 358  : 	memset( &frame->graphdata, 0, sizeof( netbandwidthgraph_t ));

	push	18					; 00000012H
	push	0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 17020				; 0000427cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 359  : 	memset( frame->flags, 0, sizeof( frame->flags ));

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _frame$[ebp]
	add	ecx, 17038				; 0000428eH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 360  : 	frame->first_entity = cls.next_client_entities;

	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR _cls+291760
	mov	DWORD PTR [edx+17300], eax

; 361  : 	frame->num_entities = 0;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+17296], 0

; 362  : 	frame->valid = true; // assume valid

	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+24], 1

; 363  : 
; 364  : 	if( FBitSet( bits, SU_VIEWHEIGHT ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 1
	je	SHORT $LN5@CL_ParseQu

; 365  : 		frame->clientdata.view_ofs[2] = MSG_ReadChar( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [eax+edx+84], xmm0
	jmp	SHORT $LN6@CL_ParseQu
$LN5@CL_ParseQu:

; 366  : 	else frame->clientdata.view_ofs[2] = 22.0f;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR __real@41b00000
	movss	DWORD PTR [edx+ecx+84], xmm0
$LN6@CL_ParseQu:

; 367  : 
; 368  : 	if( FBitSet( bits, SU_IDEALPITCH ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 2
	je	SHORT $LN7@CL_ParseQu

; 369  : 		cl.local.idealpitch = MSG_ReadChar( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _cl+1568548, xmm0
	jmp	SHORT $LN8@CL_ParseQu
$LN7@CL_ParseQu:

; 370  : 	else cl.local.idealpitch = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+1568548, xmm0
$LN8@CL_ParseQu:

; 371  : 
; 372  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseQu
$LN2@CL_ParseQu:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_ParseQu:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@CL_ParseQu

; 373  : 	{
; 374  : 		if( FBitSet( bits, SU_PUNCH1 << i ))

	mov	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _bits$[ebp]
	je	SHORT $LN9@CL_ParseQu

; 375  : 			frame->clientdata.punchangle[i] = (float)MSG_ReadChar( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [eax+edx*4+60], xmm0
	jmp	SHORT $LN10@CL_ParseQu
$LN9@CL_ParseQu:

; 376  : 		else frame->clientdata.punchangle[i] = 0.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx*4+60], xmm0
$LN10@CL_ParseQu:

; 377  : 
; 378  : 		if( FBitSet( bits, ( SU_VELOCITY1 << i )))

	mov	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _bits$[ebp]
	je	SHORT $LN11@CL_ParseQu

; 379  : 			frame->clientdata.velocity[i] = MSG_ReadChar( msg ) * 16.0f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41800000
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [eax+edx*4+44], xmm0
	jmp	SHORT $LN12@CL_ParseQu
$LN11@CL_ParseQu:

; 380  : 		else frame->clientdata.velocity[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx*4+44], xmm0
$LN12@CL_ParseQu:

; 381  : 	}

	jmp	$LN2@CL_ParseQu
$LN3@CL_ParseQu:

; 382  : 
; 383  : 	if( FBitSet( bits, SU_ONGROUND ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN13@CL_ParseQu

; 384  : 		SetBits( frame->clientdata.flags, FL_ONGROUND );

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [eax+72], edx
$LN13@CL_ParseQu:

; 385  : 	if( FBitSet( bits, SU_INWATER ))

	mov	ecx, DWORD PTR _bits$[ebp]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN14@CL_ParseQu

; 386  : 		SetBits( frame->clientdata.flags, FL_INWATER );

	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+72]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+72], eax
$LN14@CL_ParseQu:

; 387  : 
; 388  : 	// [always sent]
; 389  : 	MSG_WriteLong( &msg_demo, MSG_ReadLong( msg ));

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteLong
	add	esp, 8

; 390  : 	CL_DispatchQuakeMessage( "Items" );

	push	OFFSET $SG144709
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 391  : 
; 392  : 	if( FBitSet( bits, SU_WEAPONFRAME ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN15@CL_ParseQu

; 393  : 		CL_UpdateQuakeStats( msg, STAT_WEAPONFRAME, true );

	push	1
	push	5
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@CL_ParseQu
$LN15@CL_ParseQu:

; 394  : 	else CL_UpdateQuakeStats( msg, STAT_WEAPONFRAME, false );

	push	0
	push	5
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
$LN16@CL_ParseQu:

; 395  : 
; 396  : 	if( FBitSet( bits, SU_ARMOR ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 8192				; 00002000H
	je	SHORT $LN17@CL_ParseQu

; 397  : 		CL_UpdateQuakeStats( msg, STAT_ARMOR, true );

	push	1
	push	4
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@CL_ParseQu
$LN17@CL_ParseQu:

; 398  : 	else CL_UpdateQuakeStats( msg, STAT_ARMOR, false );

	push	0
	push	4
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
$LN18@CL_ParseQu:

; 399  : 
; 400  : 	if( FBitSet( bits, SU_WEAPON ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 16384				; 00004000H
	je	SHORT $LN19@CL_ParseQu

; 401  : 		frame->clientdata.viewmodel = CL_UpdateQuakeStats( msg, STAT_WEAPON, true );

	push	1
	push	2
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+56], eax
	jmp	SHORT $LN20@CL_ParseQu
$LN19@CL_ParseQu:

; 402  : 	else frame->clientdata.viewmodel = CL_UpdateQuakeStats( msg, STAT_WEAPON, false );

	push	0
	push	2
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+56], eax
$LN20@CL_ParseQu:

; 403  : 
; 404  : 	cl.local.health = CL_UpdateQuakeStats( msg, STAT_HEALTH, true );

	push	1
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cl+1568556, eax

; 405  : 	CL_UpdateQuakeStats( msg, STAT_AMMO, true );

	push	1
	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 406  : 	CL_UpdateQuakeStats( msg, STAT_SHELLS, true );

	push	1
	push	6
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 407  : 	CL_UpdateQuakeStats( msg, STAT_NAILS, true );

	push	1
	push	7
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 408  : 	CL_UpdateQuakeStats( msg, STAT_ROCKETS, true );

	push	1
	push	8
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 409  : 	CL_UpdateQuakeStats( msg, STAT_CELLS, true );

	push	1
	push	9
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 410  : 	CL_UpdateQuakeStats( msg, STAT_ACTIVEWEAPON, true );

	push	1
	push	10					; 0000000aH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 411  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeClientData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_gametype$ = -36					; size = 4
tv253 = -32						; size = 4
tv245 = -28						; size = 4
tv84 = -24						; size = 4
tv83 = -20						; size = 4
tv69 = -16						; size = 4
_pResName$ = -12					; size = 4
_pResource$ = -8					; size = 4
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeServerInfo PROC

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 184  : 	resource_t	*pResource;
; 185  : 	const char	*pResName;
; 186  : 	int		gametype;
; 187  : 	int		i;
; 188  : 
; 189  : 	Con_Reportf( "Serverdata packet received.\n" );

	push	OFFSET $SG144639
	call	_Con_Reportf
	add	esp, 4

; 190  : 	cls.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+16

; 191  : 
; 192  : 	cls.demowaiting = false;	// server is changed

	mov	DWORD PTR _cls+297584, 0

; 193  : 
; 194  : 	// wipe the client_t struct
; 195  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN8@CL_ParseQu
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN8@CL_ParseQu

; 196  : 		CL_ClearState ();

	call	_CL_ClearState
$LN8@CL_ParseQu:

; 197  : 	cl.background = (cls.demonum != -1) ? true : false;

	cmp	DWORD PTR _cls+293464, -1
	je	SHORT $LN32@CL_ParseQu
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN33@CL_ParseQu
$LN32@CL_ParseQu:
	mov	DWORD PTR tv69[ebp], 0
$LN33@CL_ParseQu:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _cl+64, eax

; 198  : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 199  : 
; 200  : 	// parse protocol version number
; 201  : 	i = MSG_ReadLong( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 202  : 
; 203  : 	if( i != PROTOCOL_VERSION_QUAKE )

	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	je	SHORT $LN9@CL_ParseQu

; 204  : 	{
; 205  : 		Con_Printf( "\n" S_ERROR "Server use invalid protocol (%i should be %i)\n", i, PROTOCOL_VERSION_QUAKE );

	push	15					; 0000000fH
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG144642
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 206  : 		CL_StopPlayback();

	call	_CL_StopPlayback

; 207  : 		Host_AbortCurrentFrame();

	call	_Host_AbortCurrentFrame
$LN9@CL_ParseQu:

; 208  : 	}
; 209  : 
; 210  : 	cl.maxclients = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+1568832, eax

; 211  : 	gametype = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _gametype$[ebp], eax

; 212  : 	clgame.maxEntities = GI->max_edicts;

	mov	edx, DWORD PTR _SI+768
	mov	eax, DWORD PTR [edx+1656]
	mov	DWORD PTR _clgame+1012, eax

; 213  : 	clgame.maxEntities = bound( 600, clgame.maxEntities, MAX_EDICTS );

	cmp	DWORD PTR _clgame+1012, 600		; 00000258H
	jl	SHORT $LN36@CL_ParseQu
	cmp	DWORD PTR _clgame+1012, 8192		; 00002000H
	jge	SHORT $LN34@CL_ParseQu
	mov	ecx, DWORD PTR _clgame+1012
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN35@CL_ParseQu
$LN34@CL_ParseQu:
	mov	DWORD PTR tv83[ebp], 8192		; 00002000H
$LN35@CL_ParseQu:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN37@CL_ParseQu
$LN36@CL_ParseQu:
	mov	DWORD PTR tv84[ebp], 600		; 00000258H
$LN37@CL_ParseQu:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _clgame+1012, eax

; 214  : 	clgame.maxModels = MAX_MODELS;

	mov	DWORD PTR _clgame+1024, 1024		; 00000400H

; 215  : 	Q_strncpy( clgame.maptitle, MSG_ReadString( msg ), MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+488
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 216  : 
; 217  : 	// Re-init hud video, especially if we changed game directories
; 218  : 	clgame.dllFuncs.pfnVidInit();

	call	DWORD PTR _clgame+12

; 219  : 
; 220  : 	if( Con_FixedFont( ))

	call	_Con_FixedFont
	test	eax, eax
	je	SHORT $LN10@CL_ParseQu

; 221  : 	{
; 222  : 		// seperate the printfs so the server message can have a color
; 223  : 		Con_Print( "\n\35\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\37\n" );

	push	OFFSET $SG144644
	call	_Con_Print
	add	esp, 4

; 224  : 		Con_Print( va( "%c%s\n\n", 2, clgame.maptitle ));

	push	OFFSET _clgame+488
	push	2
	push	OFFSET $SG144645
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_Con_Print
	add	esp, 4
$LN10@CL_ParseQu:

; 225  : 	}
; 226  : 
; 227  : 	// multiplayer game?
; 228  : 	if( cl.maxclients > 1 )	

	cmp	DWORD PTR _cl+1568832, 1
	jle	SHORT $LN11@CL_ParseQu

; 229  : 	{
; 230  : 		// allow console in multiplayer games
; 231  : 		host.allow_console = true;

	mov	DWORD PTR _host+34336, 1

; 232  : 
; 233  : 		// loading user settings
; 234  : 		CSCR_LoadDefaultCVars( "user.scr" );

	push	OFFSET $SG144648
	call	_CSCR_LoadDefaultCVars
	add	esp, 4

; 235  : 
; 236  : 		if( r_decals->value > mp_decals.value )

	mov	edx, DWORD PTR _r_decals
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR _mp_decals+12
	jbe	SHORT $LN13@CL_ParseQu

; 237  : 			Cvar_SetValue( "r_decals", mp_decals.value );

	push	ecx
	movss	xmm0, DWORD PTR _mp_decals+12
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144650
	call	_Cvar_SetValue
	add	esp, 8
$LN13@CL_ParseQu:

; 238  : 	}

	jmp	SHORT $LN12@CL_ParseQu
$LN11@CL_ParseQu:

; 239  : 	else Cvar_Reset( "r_decals" );

	push	OFFSET $SG144651
	call	_Cvar_Reset
	add	esp, 4
$LN12@CL_ParseQu:

; 240  : 
; 241  : 	// re-init mouse
; 242  : 	if( cl.background )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN14@CL_ParseQu

; 243  : 		host.mouse_visible = false;

	mov	DWORD PTR _host+34372, 0
$LN14@CL_ParseQu:

; 244  : 
; 245  : 	if( cl.background )	// tell the game parts about background state

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN15@CL_ParseQu

; 246  : 		Cvar_FullSet( "cl_background", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG144655
	push	OFFSET $SG144656
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@CL_ParseQu
$LN15@CL_ParseQu:

; 247  : 	else Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG144657
	push	OFFSET $SG144658
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN16@CL_ParseQu:

; 248  : 
; 249  : 	S_StopBackgroundTrack ();

	call	_S_StopBackgroundTrack

; 250  : 
; 251  : 	if( !cls.changedemo )

	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN17@CL_ParseQu

; 252  : 		UI_SetActiveMenu( cl.background );

	mov	eax, DWORD PTR _cl+64
	push	eax
	call	_UI_SetActiveMenu
	add	esp, 4
	jmp	SHORT $LN19@CL_ParseQu
$LN17@CL_ParseQu:

; 253  : 	else if( !cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN19@CL_ParseQu

; 254  : 		Key_SetKeyDest( key_menu );

	push	2
	call	_Key_SetKeyDest
	add	esp, 4
$LN19@CL_ParseQu:

; 255  : 
; 256  : 	// don't reset cursor in background mode
; 257  : 	if( cl.background )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN20@CL_ParseQu

; 258  : 		IN_MouseRestorePos();

	call	_IN_MouseRestorePos
$LN20@CL_ParseQu:

; 259  : 
; 260  : 	// will be changed later
; 261  : 	cl.viewentity = cl.playernum + 1;

	mov	ecx, DWORD PTR _cl+1568828
	add	ecx, 1
	mov	DWORD PTR _cl+1568608, ecx

; 262  : 	gameui.globals->maxClients = cl.maxclients;

	mov	edx, DWORD PTR _gameui+6712
	mov	eax, DWORD PTR _cl+1568832
	mov	DWORD PTR [edx+16], eax

; 263  : 	Q_strncpy( gameui.globals->maptitle, clgame.maptitle, sizeof( gameui.globals->maptitle ));

	push	64					; 00000040H
	push	OFFSET _clgame+488
	mov	ecx, DWORD PTR _gameui+6712
	add	ecx, 96					; 00000060H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 264  : 
; 265  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN21@CL_ParseQu
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN21@CL_ParseQu

; 266  : 		CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts
$LN21@CL_ParseQu:

; 267  : 
; 268  : 	// Quake just have a large packet of initialization data
; 269  : 	for( i = 1; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_ParseQu
$LN2@CL_ParseQu:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CL_ParseQu:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@CL_ParseQu

; 270  : 	{
; 271  : 		pResName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pResName$[ebp], eax

; 272  : 
; 273  : 		if( !COM_CheckString( pResName ))

	mov	ecx, DWORD PTR _pResName$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@CL_ParseQu

; 274  : 			break; // end of list

	jmp	$LN3@CL_ParseQu
$LN22@CL_ParseQu:

; 275  : 
; 276  : 		pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	push	276					; 00000114H
	push	OFFSET $SG144665
	push	1
	push	136					; 00000088H
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 277  : 		pResource->type = t_model;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+64], 2

; 278  : 
; 279  : 		Q_strncpy( pResource->szFileName, pResName, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pResName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 280  : 		if( i == 1 ) Q_strncpy( clgame.mapname, pResName, sizeof( clgame.mapname ));

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN23@CL_ParseQu
	push	256					; 00000100H
	mov	eax, DWORD PTR _pResName$[ebp]
	push	eax
	push	OFFSET _clgame+232
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN23@CL_ParseQu:

; 281  : 		pResource->nDownloadSize = -1;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+72], -1

; 282  : 		pResource->nIndex = i;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+68], eax

; 283  : 
; 284  : 		CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+1984996
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_CL_AddToResourceList
	add	esp, 8

; 285  : 	}

	jmp	$LN2@CL_ParseQu
$LN3@CL_ParseQu:

; 286  : 
; 287  : 	for( i = 1; i < MAX_SOUNDS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@CL_ParseQu
$LN5@CL_ParseQu:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@CL_ParseQu:
	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jge	$LN6@CL_ParseQu

; 288  : 	{
; 289  : 		pResName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pResName$[ebp], eax

; 290  : 
; 291  : 		if( !COM_CheckString( pResName ))

	mov	ecx, DWORD PTR _pResName$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@CL_ParseQu

; 292  : 			break; // end of list

	jmp	SHORT $LN6@CL_ParseQu
$LN24@CL_ParseQu:

; 293  : 
; 294  : 		pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	push	294					; 00000126H
	push	OFFSET $SG144668
	push	1
	push	136					; 00000088H
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 295  : 		pResource->type = t_sound;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+64], 0

; 296  : 
; 297  : 		Q_strncpy( pResource->szFileName, pResName, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pResName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 298  : 		pResource->nDownloadSize = -1;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+72], -1

; 299  : 		pResource->nIndex = i;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+68], edx

; 300  : 
; 301  : 		CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+1984996
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 302  : 	}

	jmp	$LN5@CL_ParseQu
$LN6@CL_ParseQu:

; 303  : 
; 304  : 	// get splash name
; 305  : 	if( cls.demoplayback && ( cls.demonum != -1 ))

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN25@CL_ParseQu
	cmp	DWORD PTR _cls+293464, -1
	je	SHORT $LN25@CL_ParseQu

; 306  : 		Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", cls.demoname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN38@CL_ParseQu
	mov	DWORD PTR tv245[ebp], OFFSET $SG144671
	jmp	SHORT $LN39@CL_ParseQu
$LN38@CL_ParseQu:
	mov	DWORD PTR tv245[ebp], OFFSET $SG144672
$LN39@CL_ParseQu:
	mov	ecx, DWORD PTR tv245[ebp]
	push	ecx
	push	OFFSET _cls+297592
	push	OFFSET $SG144673
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG144674
	call	_Cvar_Set
	add	esp, 8
	jmp	SHORT $LN26@CL_ParseQu
$LN25@CL_ParseQu:

; 307  : 	else Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", clgame.mapname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN40@CL_ParseQu
	mov	DWORD PTR tv253[ebp], OFFSET $SG144675
	jmp	SHORT $LN41@CL_ParseQu
$LN40@CL_ParseQu:
	mov	DWORD PTR tv253[ebp], OFFSET $SG144676
$LN41@CL_ParseQu:
	mov	edx, DWORD PTR tv253[ebp]
	push	edx
	push	OFFSET _clgame+232
	push	OFFSET $SG144677
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG144678
	call	_Cvar_Set
	add	esp, 8
$LN26@CL_ParseQu:

; 308  : 	Cvar_SetValue( "scr_loading", 0.0f ); // reset progress bar

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144679
	call	_Cvar_SetValue
	add	esp, 8

; 309  : 
; 310  : 	if(( cl_allow_levelshots->value && !cls.changelevel ) || cl.background )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@CL_ParseQu
	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN28@CL_ParseQu
$LN29@CL_ParseQu:
	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN27@CL_ParseQu
$LN28@CL_ParseQu:

; 311  : 	{
; 312  : 		if( !FS_FileExists( va( "%s.bmp", cl_levelshot_name->string ), true )) 

	push	1
	mov	ecx, DWORD PTR _cl_levelshot_name
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET $SG144684
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@CL_ParseQu

; 313  : 			Cvar_Set( "cl_levelshot_name", "*black" ); // render a black screen

	push	OFFSET $SG144685
	push	OFFSET $SG144686
	call	_Cvar_Set
	add	esp, 8
$LN30@CL_ParseQu:

; 314  : 		cls.scrshot_request = scrshot_plaque; // request levelshot even if exist (check filetime)

	mov	DWORD PTR _cls+293056, 3
$LN27@CL_ParseQu:

; 315  : 	}
; 316  : 
; 317  : 	memset( &clgame.movevars, 0, sizeof( clgame.movevars ));

	push	144					; 00000090H
	push	0
	push	OFFSET _clgame+1028
	call	_memset
	add	esp, 12					; 0000000cH

; 318  : 	memset( &clgame.oldmovevars, 0, sizeof( clgame.oldmovevars ));

	push	144					; 00000090H
	push	0
	push	OFFSET _clgame+1172
	call	_memset
	add	esp, 12					; 0000000cH

; 319  : 	memset( &clgame.centerPrint, 0, sizeof( clgame.centerPrint ));

	push	2068					; 00000814H
	push	0
	push	OFFSET _clgame+122816
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 	cl.video_prepped = false;

	mov	DWORD PTR _cl+16, 0

; 321  : 	cl.audio_prepped = false;

	mov	DWORD PTR _cl+20, 0

; 322  : 
; 323  : 	// GAME_COOP or GAME_DEATHMATCH
; 324  : 	CL_UpdateQuakeGameMode( gametype );

	mov	eax, DWORD PTR _gametype$[ebp]
	push	eax
	call	_CL_UpdateQuakeGameMode
	add	esp, 4

; 325  : 
; 326  : 	// now we can start to precache
; 327  : 	CL_BatchResourceRequest( true );

	push	1
	call	_CL_BatchResourceRequest
	add	esp, 4

; 328  : 
; 329  : 	clgame.movevars.wateralpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _clgame+1168, xmm0

; 330  : 	clgame.entities->curstate.scale = 0.0f;

	mov	ecx, DWORD PTR _clgame+1000
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+752], xmm0

; 331  : 	clgame.movevars.waveHeight = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _clgame+1088, xmm0

; 332  : 	clgame.movevars.zmax = 14172.0f;	// 8192 * 1.74

	movss	xmm0, DWORD PTR __real@465d7000
	movss	DWORD PTR _clgame+1084, xmm0

; 333  : 	clgame.movevars.gravity = 800.0f;	// quake doesn't write gravity in demos

	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR _clgame+1028, xmm0

; 334  : 	clgame.movevars.maxvelocity = 2000.0f;

	movss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR _clgame+1080, xmm0

; 335  : 
; 336  : 	memcpy( &clgame.oldmovevars, &clgame.movevars, sizeof( movevars_t ));

	push	144					; 00000090H
	push	OFFSET _clgame+1028
	push	OFFSET _clgame+1172
	call	_memcpy
	add	esp, 12					; 0000000cH

; 337  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeServerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_entnum$ = -44						; size = 4
_handle$ = -40						; size = 4
_sound$ = -36						; size = 4
_volume$ = -32						; size = 4
_attn$ = -28						; size = 4
_flags$ = -24						; size = 4
_channel$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeSound PROC

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 142  : 	int 	channel, sound;
; 143  : 	int	flags, entnum;
; 144  : 	float 	volume, attn;
; 145  : 	sound_t	handle;
; 146  : 	vec3_t	pos;
; 147  : 
; 148  : 	flags = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 149  : 
; 150  : 	if( FBitSet( flags, SND_VOLUME ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@CL_ParseQu

; 151  : 		volume = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _volume$[ebp], xmm0
	jmp	SHORT $LN3@CL_ParseQu
$LN2@CL_ParseQu:

; 152  : 	else volume = VOL_NORM;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _volume$[ebp], xmm0
$LN3@CL_ParseQu:

; 153  : 
; 154  : 	if( FBitSet( flags, SND_ATTENUATION ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN4@CL_ParseQu

; 155  : 		attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0
	jmp	SHORT $LN5@CL_ParseQu
$LN4@CL_ParseQu:

; 156  : 	else attn = ATTN_NONE;

	xorps	xmm0, xmm0
	movss	DWORD PTR _attn$[ebp], xmm0
$LN5@CL_ParseQu:

; 157  : 
; 158  : 	channel = MSG_ReadWord( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _channel$[ebp], eax

; 159  : 	sound = MSG_ReadByte( msg );	// Quake1 have max 255 precached sounds. erm

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _sound$[ebp], eax

; 160  : 
; 161  : 	// positioned in space
; 162  : 	MSG_ReadVec3Coord( msg, pos );

	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 163  : 
; 164  : 	entnum = channel >> 3;	// entity reletive

	mov	eax, DWORD PTR _channel$[ebp]
	sar	eax, 3
	mov	DWORD PTR _entnum$[ebp], eax

; 165  : 	channel &= 7;

	mov	ecx, DWORD PTR _channel$[ebp]
	and	ecx, 7
	mov	DWORD PTR _channel$[ebp], ecx

; 166  : 
; 167  : 	// see precached sound
; 168  : 	handle = cl.sound_index[sound];

	mov	edx, DWORD PTR _sound$[ebp]
	movsx	eax, WORD PTR _cl[edx*2+2681456]
	mov	DWORD PTR _handle$[ebp], eax

; 169  : 
; 170  : 	if( !cl.audio_prepped )

	cmp	DWORD PTR _cl+20, 0
	jne	SHORT $LN6@CL_ParseQu

; 171  : 		return; // too early

	jmp	SHORT $LN1@CL_ParseQu
$LN6@CL_ParseQu:

; 172  : 
; 173  : 	S_StartSound( pos, entnum, channel, handle, volume, attn, PITCH_NORM, flags );

	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entnum$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@CL_ParseQu:

; 174  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_gamemode$ = 8						; size = 4
_CL_UpdateQuakeGameMode PROC

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  : 	MSG_WriteByte( &msg_demo, gamemode );

	mov	eax, DWORD PTR _gamemode$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 131  : 	CL_DispatchQuakeMessage( "GameMode" );

	push	OFFSET $SG144602
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 132  : }

	pop	ebp
	ret	0
_CL_UpdateQuakeGameMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_value$ = -4						; size = 4
_msg$ = 8						; size = 4
_statnum$ = 12						; size = 4
_has_update$ = 16					; size = 4
_CL_UpdateQuakeStats PROC

; 103  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 104  : 	int 	value = 0;

	mov	DWORD PTR _value$[ebp], 0

; 105  : 
; 106  : 	MSG_WriteByte( &msg_demo, statnum );	// stat num

	mov	eax, DWORD PTR _statnum$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 107  : 
; 108  : 	if( has_update )

	cmp	DWORD PTR _has_update$[ebp], 0
	je	SHORT $LN2@CL_UpdateQ

; 109  : 	{
; 110  : 		if( statnum == STAT_HEALTH )

	cmp	DWORD PTR _statnum$[ebp], 0
	jne	SHORT $LN3@CL_UpdateQ

; 111  : 			value = MSG_ReadShort( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _value$[ebp], eax
	jmp	SHORT $LN2@CL_UpdateQ
$LN3@CL_UpdateQ:

; 112  : 		else value = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _value$[ebp], eax
$LN2@CL_UpdateQ:

; 113  : 	}
; 114  : 
; 115  : 	MSG_WriteLong( &msg_demo, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteLong
	add	esp, 8

; 116  : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET $SG144597
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 117  : 
; 118  : 	return value;

	mov	eax, DWORD PTR _value$[ebp]

; 119  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateQuakeStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_maxlen$ = -32						; size = 4
_len$ = -28						; size = 4
tv90 = -24						; size = 4
tv151 = -20						; size = 4
_delta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_newstate$ = 12						; size = 4
_CL_QuakeEntityTeleported PROC

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 83   : 	float	len, maxlen;
; 84   : 	vec3_t	delta;
; 85   : 
; 86   : 	VectorSubtract( newstate->origin, ent->prevstate.origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _newstate$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax+364]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _newstate$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax+364]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _newstate$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx+364]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 87   : 
; 88   : 	// compute potential max movement in units per frame and compare with entity movement
; 89   : 	maxlen = ( clgame.movevars.maxvelocity * ( 1.0 / GAME_FPS ));

	cvtss2sd xmm0, DWORD PTR _clgame+1080
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxlen$[ebp], xmm0

; 90   : 	len = VectorLength( delta );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+edx]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _delta$[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _len$[ebp]

; 91   : 
; 92   : 	return (len > maxlen);

	movss	xmm0, DWORD PTR _len$[ebp]
	comiss	xmm0, DWORD PTR _maxlen$[ebp]
	jbe	SHORT $LN3@CL_QuakeEn
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN4@CL_QuakeEn
$LN3@CL_QuakeEn:
	mov	DWORD PTR tv151[ebp], 0
$LN4@CL_QuakeEn:
	mov	eax, DWORD PTR tv151[ebp]

; 93   : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_QuakeEntityTeleported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseQuakeStats PROC

; 67   : {

	push	ebp
	mov	ebp, esp

; 68   : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));	// stat num

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 69   : 	MSG_WriteLong( &msg_demo, MSG_ReadLong( msg ));	// stat value

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteLong
	add	esp, 8

; 70   : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET $SG144575
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 71   : }

	pop	ebp
	ret	0
_CL_ParseQuakeStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_CL_DispatchQuakeMessage PROC

; 54   : {

	push	ebp
	mov	ebp, esp

; 55   : 	CL_DispatchUserMessage( name, msg_demo.iCurBit >> 3, msg_demo.pData );

	mov	eax, DWORD PTR _msg_demo+8
	push	eax
	mov	ecx, DWORD PTR _msg_demo+12
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_CL_DispatchUserMessage
	add	esp, 12					; 0000000cH

; 56   : 	MSG_Clear( &msg_demo ); // don't forget to clear buffer

	push	OFFSET _msg_demo
	call	_MSG_Clear
	add	esp, 4

; 57   : }

	pop	ebp
	ret	0
_CL_DispatchQuakeMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\cl_qparse.c
_TEXT	SEGMENT
tv324 = -80						; size = 4
tv323 = -76						; size = 4
tv318 = -72						; size = 4
tv317 = -68						; size = 4
tv170 = -64						; size = 4
tv141 = -60						; size = 4
_cmd$ = -56						; size = 4
_bufStart$ = -52					; size = 4
_str$ = -48						; size = 4
_param2$ = -44						; size = 4
_param1$ = -40						; size = 4
_packed_fog$1 = -36					; size = 16
_fog_settings$2 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_normal_message$ = 12					; size = 4
_CL_ParseQuakeMessage PROC

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 897  : 	int		cmd, param1, param2;
; 898  : 	size_t		bufStart;
; 899  : 	const char	*str;
; 900  : 
; 901  : 	cls.starting_count = MSG_GetNumBytesRead( msg );	// updates each frame

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _cls+287336, eax

; 902  : 	CL_Parse_Debug( true );			// begin parsing

	push	1
	call	_CL_Parse_Debug
	add	esp, 4

; 903  : 
; 904  : 	// init excise buffer
; 905  : 	MSG_Init( &msg_demo, "UserMsg", msg_buf, sizeof( msg_buf ));

	push	-1
	push	8192					; 00002000H
	push	OFFSET _msg_buf
	push	OFFSET $SG144910
	push	OFFSET _msg_demo
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 906  : 
; 907  : 	if( normal_message )

	cmp	DWORD PTR _normal_message$[ebp], 0
	je	SHORT $LN8@CL_ParseQu

; 908  : 	{
; 909  : 		// assume no entity/player update this packet
; 910  : 		if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN7@CL_ParseQu

; 911  : 		{
; 912  : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].valid = false;   

	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _cls+23584
	imul	edx, ecx, 17304
	mov	DWORD PTR _cl[edx+112], 0

; 913  : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].choked = false;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+23584
	imul	ecx, eax, 17304
	mov	DWORD PTR _cl[ecx+116], 0

; 914  : 		}

	jmp	SHORT $LN8@CL_ParseQu
$LN7@CL_ParseQu:

; 915  : 		else
; 916  : 		{
; 917  : 			CL_ResetFrame( &cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK] );

	mov	edx, DWORD PTR _CL_UPDATE_BACKUP
	sub	edx, 1
	and	edx, DWORD PTR _cls+23584
	imul	eax, edx, 17304
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_ResetFrame
	add	esp, 4
$LN8@CL_ParseQu:

; 918  : 		}
; 919  : 	}
; 920  : 
; 921  : 	// parse the message
; 922  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@CL_ParseQu

; 923  : 	{
; 924  : 		if( MSG_CheckOverflow( msg ))

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@CL_ParseQu

; 925  : 		{
; 926  : 			Host_Error( "CL_ParseServerMessage: overflow!\n" );

	push	OFFSET $SG144915
	call	_Host_Error
	add	esp, 4

; 927  : 			return;

	jmp	$LN1@CL_ParseQu
$LN9@CL_ParseQu:

; 928  : 		}
; 929  : 
; 930  : 		// mark start position
; 931  : 		bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 932  : 
; 933  : 		// end of message (align bits)
; 934  : 		if( MSG_GetNumBitsLeft( msg ) < 8 )

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN10@CL_ParseQu

; 935  : 			break;		

	jmp	$LN3@CL_ParseQu
$LN10@CL_ParseQu:

; 936  : 
; 937  : 		cmd = MSG_ReadServerCmd( msg );

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCmd
	add	esp, 8
	mov	DWORD PTR _cmd$[ebp], eax

; 938  : 
; 939  : 		// if the high bit of the command byte is set, it is a fast update
; 940  : 		if( FBitSet( cmd, 128 ))

	mov	eax, DWORD PTR _cmd$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN11@CL_ParseQu

; 941  : 		{
; 942  : 			CL_ParseQuakeEntityData( msg, cmd & 127 );

	mov	ecx, DWORD PTR _cmd$[ebp]
	and	ecx, 127				; 0000007fH
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseQuakeEntityData
	add	esp, 8

; 943  : 			continue;

	jmp	$LN8@CL_ParseQu
$LN11@CL_ParseQu:

; 944  : 		}
; 945  : 
; 946  : 		// record command for debugging spew on parse problem
; 947  : 		CL_Parse_RecordCommand( cmd, bufStart );

	mov	eax, DWORD PTR _bufStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_CL_Parse_RecordCommand
	add	esp, 8

; 948  : 
; 949  : 		// other commands
; 950  : 		switch( cmd )

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR tv141[ebp]
	sub	eax, 1
	mov	DWORD PTR tv141[ebp], eax
	cmp	DWORD PTR tv141[ebp], 50		; 00000032H
	ja	$LN57@CL_ParseQu
	mov	ecx, DWORD PTR tv141[ebp]
	jmp	DWORD PTR $LN70@CL_ParseQu[ecx*4]
$LN12@CL_ParseQu:

; 951  : 		{
; 952  : 		case svc_nop:
; 953  : 			// this does nothing
; 954  : 			break;

	jmp	$LN4@CL_ParseQu
$LN13@CL_ParseQu:

; 955  : 		case svc_disconnect:
; 956  : 			CL_DemoCompleted ();

	call	_CL_DemoCompleted

; 957  : 			break;

	jmp	$LN4@CL_ParseQu
$LN14@CL_ParseQu:

; 958  : 		case svc_updatestat:
; 959  : 			CL_ParseQuakeStats( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseQuakeStats
	add	esp, 4

; 960  : 			break;

	jmp	$LN4@CL_ParseQu
$LN15@CL_ParseQu:

; 961  : 		case svc_version:
; 962  : 			param1 = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 963  : 			if( param1 != PROTOCOL_VERSION_QUAKE )

	cmp	DWORD PTR _param1$[ebp], 15		; 0000000fH
	je	SHORT $LN16@CL_ParseQu

; 964  : 				Host_Error( "Server is protocol %i instead of %i\n", param1, PROTOCOL_VERSION_QUAKE );

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _param1$[ebp]
	push	ecx
	push	OFFSET $SG144923
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN16@CL_ParseQu:

; 965  : 			break;

	jmp	$LN4@CL_ParseQu
$LN17@CL_ParseQu:

; 966  : 		case svc_setview:
; 967  : 			CL_ParseViewEntity( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseViewEntity
	add	esp, 4

; 968  : 			break;

	jmp	$LN4@CL_ParseQu
$LN18@CL_ParseQu:

; 969  : 		case svc_sound:
; 970  : 			CL_ParseQuakeSound( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeSound
	add	esp, 4

; 971  : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	edx, WORD PTR _cl[esi+17116]
	add	edx, eax
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17116], dx

; 972  : 			break;

	jmp	$LN4@CL_ParseQu
$LN19@CL_ParseQu:

; 973  : 		case svc_time:
; 974  : 			Cbuf_AddText( "\n" ); // new frame was started

	push	OFFSET $SG144927
	call	_Cbuf_AddText
	add	esp, 4

; 975  : 			CL_ParseServerTime( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseServerTime
	add	esp, 4

; 976  : 			break;

	jmp	$LN4@CL_ParseQu
$LN20@CL_ParseQu:

; 977  : 		case svc_print:
; 978  : 			str = MSG_ReadString( msg );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 979  : 			Con_Printf( "%s%s", str, *str == 2 ? "\n" : "" );

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 2
	jne	SHORT $LN59@CL_ParseQu
	mov	DWORD PTR tv170[ebp], OFFSET $SG144929
	jmp	SHORT $LN60@CL_ParseQu
$LN59@CL_ParseQu:
	mov	DWORD PTR tv170[ebp], OFFSET $SG144930
$LN60@CL_ParseQu:
	mov	edx, DWORD PTR tv170[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET $SG144931
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 980  : 			break;

	jmp	$LN4@CL_ParseQu
$LN21@CL_ParseQu:

; 981  : 		case svc_stufftext:
; 982  : 			CL_QuakeStuffText( MSG_ReadString( msg ));

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_CL_QuakeStuffText
	add	esp, 4

; 983  : 			break;

	jmp	$LN4@CL_ParseQu
$LN22@CL_ParseQu:

; 984  : 		case svc_setangle:
; 985  : 			cl.viewangles[0] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _cl[ecx+1568612], xmm0

; 986  : 			cl.viewangles[1] = MSG_ReadAngle( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _cl[eax+1568612], xmm0

; 987  : 			cl.viewangles[2] = MSG_ReadAngle( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _cl[edx+1568612], xmm0

; 988  : 			break;

	jmp	$LN4@CL_ParseQu
$LN23@CL_ParseQu:

; 989  : 		case svc_serverdata:
; 990  : 			Cbuf_Execute(); // make sure any stuffed commands are done

	call	_Cbuf_Execute

; 991  : 			CL_ParseQuakeServerInfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeServerInfo
	add	esp, 4

; 992  : 			break;

	jmp	$LN4@CL_ParseQu
$LN24@CL_ParseQu:

; 993  : 		case svc_lightstyle:
; 994  : 			param1 = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 995  : 			str = MSG_ReadString( msg );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 996  : 			CL_SetLightstyle( param1, str, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _param1$[ebp]
	push	eax
	call	_CL_SetLightstyle
	add	esp, 12					; 0000000cH

; 997  : 			break;

	jmp	$LN4@CL_ParseQu
$LN25@CL_ParseQu:

; 998  : 		case svc_updatename:
; 999  : 			param1 = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1000 : 			Q_strncpy( cl.players[param1].name, MSG_ReadString( msg ), sizeof( cl.players[0].name ));

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	imul	eax, DWORD PTR _param1$[ebp], 584
	add	eax, OFFSET _cl+1543408
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1001 : 			Q_strncpy( cl.players[param1].model, "player", sizeof( cl.players[0].name ));

	push	32					; 00000020H
	push	OFFSET $SG144937
	imul	ecx, DWORD PTR _param1$[ebp], 584
	add	ecx, OFFSET _cl+1543452
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1002 : 			break;

	jmp	$LN4@CL_ParseQu
$LN26@CL_ParseQu:

; 1003 : 		case svc_updatefrags:
; 1004 : 			param1 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1005 : 			param2 = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 1006 : 			// HACKHACK: store frags into spectator
; 1007 : 			cl.players[param1].spectator = param2;

	imul	ecx, DWORD PTR _param1$[ebp], 584
	mov	edx, DWORD PTR _param2$[ebp]
	mov	DWORD PTR _cl[ecx+1543440], edx

; 1008 : 			break;

	jmp	$LN4@CL_ParseQu
$LN27@CL_ParseQu:

; 1009 : 		case svc_clientdata:
; 1010 : 			CL_ParseQuakeClientData( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeClientData
	add	esp, 4

; 1011 : 			cl.frames[cl.parsecountmod].graphdata.client += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	edx, WORD PTR _cl[esi+17108]
	add	edx, eax
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17108], dx

; 1012 : 			break;

	jmp	$LN4@CL_ParseQu
$LN28@CL_ParseQu:

; 1013 : 		case svc_stopsound:
; 1014 : 			param1 = MSG_ReadWord( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1015 : 			S_StopSound( param1 >> 3, param1 & 7, NULL );

	push	0
	mov	edx, DWORD PTR _param1$[ebp]
	and	edx, 7
	push	edx
	mov	eax, DWORD PTR _param1$[ebp]
	sar	eax, 3
	push	eax
	call	_S_StopSound
	add	esp, 12					; 0000000cH

; 1016 : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	edx, WORD PTR _cl[esi+17116]
	add	edx, eax
	imul	eax, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[eax+17116], dx

; 1017 : 			break;

	jmp	$LN4@CL_ParseQu
$LN29@CL_ParseQu:

; 1018 : 		case svc_updatecolors:
; 1019 : 			param1 = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1020 : 			param2 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 1021 : 			cl.players[param1].topcolor = param2 & 0xF;

	mov	eax, DWORD PTR _param2$[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, DWORD PTR _param1$[ebp], 584
	mov	DWORD PTR _cl[ecx+1543516], eax

; 1022 : 			cl.players[param1].bottomcolor = (param2 & 0xF0) >> 4;

	mov	edx, DWORD PTR _param2$[ebp]
	and	edx, 240				; 000000f0H
	sar	edx, 4
	imul	eax, DWORD PTR _param1$[ebp], 584
	mov	DWORD PTR _cl[eax+1543520], edx

; 1023 : 			break;

	jmp	$LN4@CL_ParseQu
$LN30@CL_ParseQu:

; 1024 : 		case svc_particle:
; 1025 : 			CL_ParseQuakeParticle( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseQuakeParticle
	add	esp, 4

; 1026 : 			break;

	jmp	$LN4@CL_ParseQu
$LN31@CL_ParseQu:

; 1027 : 		case svc_damage:
; 1028 : 			CL_ParseQuakeDamage( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseQuakeDamage
	add	esp, 4

; 1029 : 			break;

	jmp	$LN4@CL_ParseQu
$LN32@CL_ParseQu:

; 1030 : 		case svc_spawnstatic:
; 1031 : 			CL_ParseQuakeStaticEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeStaticEntity
	add	esp, 4

; 1032 : 			break;

	jmp	$LN4@CL_ParseQu
$LN33@CL_ParseQu:

; 1033 : 		case svc_spawnbinary:
; 1034 : 			// never used in Quake
; 1035 : 			break;

	jmp	$LN4@CL_ParseQu
$LN34@CL_ParseQu:

; 1036 : 		case svc_spawnbaseline:
; 1037 : 			CL_ParseQuakeBaseline( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseQuakeBaseline
	add	esp, 4

; 1038 : 			break;

	jmp	$LN4@CL_ParseQu
$LN35@CL_ParseQu:

; 1039 : 		case svc_temp_entity:
; 1040 : 			CL_ParseQuakeTempEntity( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseQuakeTempEntity
	add	esp, 4

; 1041 : 			cl.frames[cl.parsecountmod].graphdata.tentities += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+17114]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17114], cx

; 1042 : 			break;

	jmp	$LN4@CL_ParseQu
$LN36@CL_ParseQu:

; 1043 : 		case svc_setpause:
; 1044 : 			cl.paused = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+24, eax

; 1045 : 			break;

	jmp	$LN4@CL_ParseQu
$LN37@CL_ParseQu:

; 1046 : 		case svc_signonnum:
; 1047 : 			CL_ParseQuakeSignon( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseQuakeSignon
	add	esp, 4

; 1048 : 			break;

	jmp	$LN4@CL_ParseQu
$LN38@CL_ParseQu:

; 1049 : 		case svc_centerprint:
; 1050 : 			str = MSG_ReadString( msg );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 1051 : 			CL_DispatchUserMessage( "HudText", Q_strlen( str ), (void *)str );

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET $SG144951
	call	_CL_DispatchUserMessage
	add	esp, 12					; 0000000cH

; 1052 : 			break;

	jmp	$LN4@CL_ParseQu
$LN39@CL_ParseQu:

; 1053 : 		case svc_killedmonster:
; 1054 : 			CL_DispatchQuakeMessage( "KillMonster" ); // just an event

	push	OFFSET $SG144953
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 1055 : 			break;

	jmp	$LN4@CL_ParseQu
$LN40@CL_ParseQu:

; 1056 : 		case svc_foundsecret:
; 1057 : 			CL_DispatchQuakeMessage( "FoundSecret" ); // just an event

	push	OFFSET $SG144955
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 1058 : 			break;

	jmp	$LN4@CL_ParseQu
$LN41@CL_ParseQu:

; 1059 : 		case svc_spawnstaticsound:
; 1060 : 			CL_ParseQuakeStaticSound( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseQuakeStaticSound
	add	esp, 4

; 1061 : 			break;

	jmp	$LN4@CL_ParseQu
$LN42@CL_ParseQu:

; 1062 : 		case svc_intermission:
; 1063 : 			cl.intermission = 1;

	mov	DWORD PTR _cl+1568648, 1

; 1064 : 			break;

	jmp	$LN4@CL_ParseQu
$LN43@CL_ParseQu:

; 1065 : 		case svc_finale:
; 1066 : 			CL_ParseFinaleCutscene( msg, 2 );

	push	2
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 1067 : 			break;

	jmp	$LN4@CL_ParseQu
$LN44@CL_ParseQu:

; 1068 : 		case svc_cdtrack:
; 1069 : 			param1 = MSG_ReadByte( msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1070 : 			param1 = bound( 0, param1, MAX_CDTRACKS - 1 ); // tracknum

	cmp	DWORD PTR _param1$[ebp], 0
	jl	SHORT $LN63@CL_ParseQu
	cmp	DWORD PTR _param1$[ebp], 31		; 0000001fH
	jge	SHORT $LN61@CL_ParseQu
	mov	edx, DWORD PTR _param1$[ebp]
	mov	DWORD PTR tv317[ebp], edx
	jmp	SHORT $LN62@CL_ParseQu
$LN61@CL_ParseQu:
	mov	DWORD PTR tv317[ebp], 31		; 0000001fH
$LN62@CL_ParseQu:
	mov	eax, DWORD PTR tv317[ebp]
	mov	DWORD PTR tv318[ebp], eax
	jmp	SHORT $LN64@CL_ParseQu
$LN63@CL_ParseQu:
	mov	DWORD PTR tv318[ebp], 0
$LN64@CL_ParseQu:
	mov	ecx, DWORD PTR tv318[ebp]
	mov	DWORD PTR _param1$[ebp], ecx

; 1071 : 			param2 = MSG_ReadByte( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 1072 : 			param2 = bound( 0, param2, MAX_CDTRACKS - 1 ); // loopnum

	cmp	DWORD PTR _param2$[ebp], 0
	jl	SHORT $LN67@CL_ParseQu
	cmp	DWORD PTR _param2$[ebp], 31		; 0000001fH
	jge	SHORT $LN65@CL_ParseQu
	mov	eax, DWORD PTR _param2$[ebp]
	mov	DWORD PTR tv323[ebp], eax
	jmp	SHORT $LN66@CL_ParseQu
$LN65@CL_ParseQu:
	mov	DWORD PTR tv323[ebp], 31		; 0000001fH
$LN66@CL_ParseQu:
	mov	ecx, DWORD PTR tv323[ebp]
	mov	DWORD PTR tv324[ebp], ecx
	jmp	SHORT $LN68@CL_ParseQu
$LN67@CL_ParseQu:
	mov	DWORD PTR tv324[ebp], 0
$LN68@CL_ParseQu:
	mov	edx, DWORD PTR tv324[ebp]
	mov	DWORD PTR _param2$[ebp], edx

; 1073 : 			if(( cls.demoplayback || cls.demorecording ) && ( cls.forcetrack != -1 ))

	cmp	DWORD PTR _cls+297580, 0
	jne	SHORT $LN47@CL_ParseQu
	cmp	DWORD PTR _cls+297576, 0
	je	SHORT $LN45@CL_ParseQu
$LN47@CL_ParseQu:
	cmp	DWORD PTR _cls+287368, -1
	je	SHORT $LN45@CL_ParseQu

; 1074 : 				S_StartBackgroundTrack( clgame.cdtracks[cls.forcetrack], clgame.cdtracks[cls.forcetrack], 0, false );

	push	0
	push	0
	mov	eax, DWORD PTR _cls+287368
	shl	eax, 8
	add	eax, OFFSET _clgame+14096
	push	eax
	mov	ecx, DWORD PTR _cls+287368
	shl	ecx, 8
	add	ecx, OFFSET _clgame+14096
	push	ecx
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H
	jmp	SHORT $LN46@CL_ParseQu
$LN45@CL_ParseQu:

; 1075 : 			else S_StartBackgroundTrack( clgame.cdtracks[param1], clgame.cdtracks[param2], 0, false );

	push	0
	push	0
	mov	edx, DWORD PTR _param2$[ebp]
	shl	edx, 8
	add	edx, OFFSET _clgame+14096
	push	edx
	mov	eax, DWORD PTR _param1$[ebp]
	shl	eax, 8
	add	eax, OFFSET _clgame+14096
	push	eax
	call	_S_StartBackgroundTrack
	add	esp, 16					; 00000010H
$LN46@CL_ParseQu:

; 1076 : 			break;

	jmp	$LN4@CL_ParseQu
$LN48@CL_ParseQu:

; 1077 : 		case svc_sellscreen:
; 1078 : 			Cmd_ExecuteString( "help" );	// open quake menu

	push	OFFSET $SG144964
	call	_Cmd_ExecuteString
	add	esp, 4

; 1079 : 			break;

	jmp	$LN4@CL_ParseQu
$LN49@CL_ParseQu:

; 1080 : 		case svc_cutscene:
; 1081 : 			CL_ParseFinaleCutscene( msg, 3 );

	push	3
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 1082 : 			break;

	jmp	$LN4@CL_ParseQu
$LN50@CL_ParseQu:

; 1083 : 		case svc_hidelmp:
; 1084 : 			CL_ParseNehahraHideLMP( msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_ParseNehahraHideLMP
	add	esp, 4

; 1085 : 			break;

	jmp	$LN4@CL_ParseQu
$LN51@CL_ParseQu:

; 1086 : 		case svc_showlmp:
; 1087 : 			CL_ParseNehahraShowLMP( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseNehahraShowLMP
	add	esp, 4

; 1088 : 			break;

	jmp	$LN4@CL_ParseQu
$LN52@CL_ParseQu:

; 1089 : 		case svc_skybox:
; 1090 : 			Q_strncpy( clgame.movevars.skyName, MSG_ReadString( msg ), sizeof( clgame.movevars.skyName ));

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+1096
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1091 : 			break;

	jmp	$LN4@CL_ParseQu
$LN53@CL_ParseQu:

; 1092 : 		case svc_skyboxsize:
; 1093 : 			MSG_ReadCoord( msg ); // obsolete

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadCoord
	fstp	ST(0)
	add	esp, 4

; 1094 : 			break;

	jmp	$LN4@CL_ParseQu
$LN54@CL_ParseQu:

; 1095 : 		case svc_fog:
; 1096 : 			if( MSG_ReadByte( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	test	eax, eax
	je	$LN55@CL_ParseQu

; 1097 : 			{
; 1098 : 				float	fog_settings[4];
; 1099 : 				int	packed_fog[4];
; 1100 : 
; 1101 : 				fog_settings[3] = MSG_ReadFloat( msg );	// density

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadFloat
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 3
	fstp	DWORD PTR _fog_settings$2[ebp+eax]

; 1102 : 				fog_settings[0] = MSG_ReadByte( msg );	// red

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadByte
	add	esp, 4
	mov	edx, 4
	imul	ecx, edx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fog_settings$2[ebp+ecx], xmm0

; 1103 : 				fog_settings[1] = MSG_ReadByte( msg );	// green

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fog_settings$2[ebp+ecx], xmm0

; 1104 : 				fog_settings[2] = MSG_ReadByte( msg );	// blue

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fog_settings$2[ebp+ecx], xmm0

; 1105 : 				packed_fog[0] = fog_settings[0] * 255;

	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+eax]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	imul	edx, ecx, 0
	cvttss2si eax, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+edx], eax

; 1106 : 				packed_fog[1] = fog_settings[1] * 255;

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 0
	cvttss2si eax, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+edx], eax

; 1107 : 				packed_fog[2] = fog_settings[2] * 255;

	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 1
	cvttss2si eax, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+edx], eax

; 1108 : 				packed_fog[3] = fog_settings[3] * 255;

	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+edx]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 3
	cvttss2si edx, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+ecx], edx

; 1109 : 				clgame.movevars.fog_settings = (packed_fog[1]<<24)|(packed_fog[2]<<16)|(packed_fog[3]<<8)|packed_fog[0];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _packed_fog$1[ebp+eax]
	shl	ecx, 24					; 00000018H
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _packed_fog$1[ebp+edx]
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _packed_fog$1[ebp+eax]
	shl	edx, 8
	or	ecx, edx
	mov	eax, 4
	imul	edx, eax, 0
	or	ecx, DWORD PTR _packed_fog$1[ebp+edx]
	mov	DWORD PTR _clgame+1164, ecx

; 1110 : 			}

	jmp	SHORT $LN56@CL_ParseQu
$LN55@CL_ParseQu:

; 1111 : 			else
; 1112 : 			{
; 1113 : 				clgame.movevars.fog_settings = 0;

	mov	DWORD PTR _clgame+1164, 0
$LN56@CL_ParseQu:

; 1114 : 			}
; 1115 : 			break;

	jmp	SHORT $LN4@CL_ParseQu
$LN57@CL_ParseQu:

; 1116 : 		default:
; 1117 : 			Host_Error( "CL_ParseServerMessage: Illegible server message\n" );

	push	OFFSET $SG144974
	call	_Host_Error
	add	esp, 4
$LN4@CL_ParseQu:

; 1118 : 			break;
; 1119 : 		}
; 1120 : 	}

	jmp	$LN8@CL_ParseQu
$LN3@CL_ParseQu:

; 1121 : 
; 1122 : 	cl.frames[cl.parsecountmod].graphdata.msgbytes += MSG_GetNumBytesRead( msg ) - cls.starting_count;

	imul	esi, DWORD PTR _cl+12, 17304
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _cls+287336
	movzx	ecx, WORD PTR _cl[esi+17122]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 17304
	mov	WORD PTR _cl[edx+17122], cx

; 1123 : 	CL_Parse_Debug( false ); // done

	push	0
	call	_CL_Parse_Debug
	add	esp, 4

; 1124 : 
; 1125 : 	// now process packet.
; 1126 : 	CL_ProcessPacket( &cl.frames[cl.parsecountmod] );

	imul	eax, DWORD PTR _cl+12, 17304
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_ProcessPacket
	add	esp, 4

; 1127 : 
; 1128 : 	// add new entities into physic lists
; 1129 : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 1130 : 
; 1131 : 	// check deferred cmds
; 1132 : 	CL_QuakeExecStuff();

	call	_CL_QuakeExecStuff
$LN1@CL_ParseQu:

; 1133 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN70@CL_ParseQu:
	DD	$LN12@CL_ParseQu
	DD	$LN13@CL_ParseQu
	DD	$LN14@CL_ParseQu
	DD	$LN15@CL_ParseQu
	DD	$LN17@CL_ParseQu
	DD	$LN18@CL_ParseQu
	DD	$LN19@CL_ParseQu
	DD	$LN20@CL_ParseQu
	DD	$LN21@CL_ParseQu
	DD	$LN22@CL_ParseQu
	DD	$LN23@CL_ParseQu
	DD	$LN24@CL_ParseQu
	DD	$LN25@CL_ParseQu
	DD	$LN26@CL_ParseQu
	DD	$LN27@CL_ParseQu
	DD	$LN28@CL_ParseQu
	DD	$LN29@CL_ParseQu
	DD	$LN30@CL_ParseQu
	DD	$LN31@CL_ParseQu
	DD	$LN32@CL_ParseQu
	DD	$LN33@CL_ParseQu
	DD	$LN34@CL_ParseQu
	DD	$LN35@CL_ParseQu
	DD	$LN36@CL_ParseQu
	DD	$LN37@CL_ParseQu
	DD	$LN38@CL_ParseQu
	DD	$LN39@CL_ParseQu
	DD	$LN40@CL_ParseQu
	DD	$LN41@CL_ParseQu
	DD	$LN42@CL_ParseQu
	DD	$LN43@CL_ParseQu
	DD	$LN44@CL_ParseQu
	DD	$LN48@CL_ParseQu
	DD	$LN49@CL_ParseQu
	DD	$LN51@CL_ParseQu
	DD	$LN50@CL_ParseQu
	DD	$LN52@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN57@CL_ParseQu
	DD	$LN53@CL_ParseQu
	DD	$LN54@CL_ParseQu
_CL_ParseQuakeMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 853  : {

	push	ebp
	mov	ebp, esp

; 854  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1012
	jge	SHORT $LN2@CL_EDICT_N

; 855  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3000
	add	eax, DWORD PTR _clgame+1000
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 856  : 
; 857  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 858  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 859  : }

	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
