; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\con_utils.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Cmd_GetMapList
PUBLIC	_Cmd_GetDemoList
PUBLIC	_Cmd_GetMovieList
PUBLIC	_Cmd_GetMusicList
PUBLIC	_Cmd_GetSavesList
PUBLIC	_Cmd_GetConfigList
PUBLIC	_Cmd_GetSoundList
PUBLIC	_Cmd_GetItemsList
PUBLIC	_Cmd_GetCustomList
PUBLIC	_Cmd_GetGamesList
PUBLIC	_Cmd_GetCDList
PUBLIC	_cmd_list
_DATA	SEGMENT
_cmd_list DD	FLAT:$SG138819
	DD	FLAT:_Cmd_GetMapList
	DD	FLAT:$SG138820
	DD	FLAT:_Cmd_GetMapList
	DD	FLAT:$SG138821
	DD	FLAT:_Cmd_GetMapList
	DD	FLAT:$SG138822
	DD	FLAT:_Cmd_GetDemoList
	DD	FLAT:$SG138823
	DD	FLAT:_Cmd_GetDemoList
	DD	FLAT:$SG138824
	DD	FLAT:_Cmd_GetSoundList
	DD	FLAT:$SG138825
	DD	FLAT:_Cmd_GetCustomList
	DD	FLAT:$SG138826
	DD	FLAT:_Cmd_GetMapList
	DD	FLAT:$SG138827
	DD	FLAT:_Cmd_GetMusicList
	DD	FLAT:$SG138828
	DD	FLAT:_Cmd_GetMovieList
	DD	FLAT:$SG138829
	DD	FLAT:_Cmd_GetConfigList
	DD	FLAT:$SG138830
	DD	FLAT:_Cmd_GetItemsList
	DD	FLAT:$SG138831
	DD	FLAT:_Cmd_GetItemsList
	DD	FLAT:$SG138832
	DD	FLAT:_Cmd_GetGamesList
	DD	FLAT:$SG138833
	DD	FLAT:_Cmd_GetSavesList
	DD	FLAT:$SG138834
	DD	FLAT:_Cmd_GetSavesList
	DD	FLAT:$SG138835
	DD	FLAT:_Cmd_GetSoundList
	DD	FLAT:$SG138836
	DD	FLAT:_Cmd_GetMapList
	DD	FLAT:$SG138837
	DD	FLAT:_Cmd_GetCDList
	DD	00H
	ORG $+4
$SG138819 DB	'map_background', 00H
	ORG $+1
$SG138820 DB	'changelevel2', 00H
	ORG $+3
$SG138821 DB	'changelevel', 00H
$SG138822 DB	'playdemo', 00H
	ORG $+3
$SG138823 DB	'timedemo', 00H
	ORG $+3
$SG138824 DB	'playvol', 00H
$SG138825 DB	'hpkval', 00H
	ORG $+1
$SG138826 DB	'entpatch', 00H
	ORG $+3
$SG138827 DB	'music', 00H
	ORG $+2
$SG138828 DB	'movie', 00H
	ORG $+2
$SG138829 DB	'exec', 00H
	ORG $+3
$SG138830 DB	'give', 00H
	ORG $+3
$SG138831 DB	'drop', 00H
	ORG $+3
$SG138832 DB	'game', 00H
	ORG $+3
$SG138833 DB	'save', 00H
	ORG $+3
$SG138834 DB	'load', 00H
	ORG $+3
$SG138835 DB	'play', 00H
	ORG $+3
$SG138836 DB	'map', 00H
$SG138837 DB	'cd', 00H
_DATA	ENDS
PUBLIC	_Host_WriteServerConfig
PUBLIC	_Host_WriteOpenGLConfig
PUBLIC	_Host_WriteVideoConfig
PUBLIC	_Host_WriteConfig
PUBLIC	_Key_EnumCmds_f
PUBLIC	_Cmd_CheckMapsList
PUBLIC	_Cmd_AutocompleteName
PUBLIC	_Cmd_CheckMapsList_R
PUBLIC	_Cmd_WriteOpenGLVariables
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_Exists:PROC
EXTRN	_Cmd_LookupCmds:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_timestamp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_LookupVars:PROC
EXTRN	_Cvar_WriteVariables:PROC
EXTRN	_FS_AllowDirectPaths:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_COM_DefaultExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Search:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CSCR_LoadDefaultCVars:PROC
EXTRN	_CSCR_WriteGameCVars:PROC
EXTRN	_Key_WriteBindings:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_SV_InitGameProgs:PROC
EXTRN	_SV_FreeGameProgs:PROC
EXTRN	_Info_WriteVars:PROC
EXTRN	_Mod_TestBmodelLumps:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_clgame:BYTE
EXTRN	_con_gamemaps:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
$SG138370 DB	01H DUP (?)
$SG138371 DB	01H DUP (?)
$SG138882 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
	ORG $+1
$SG138363 DB	'maps/%s*.bsp', 00H
	ORG $+3
$SG138368 DB	'bsp', 00H
$SG138369 DB	'^1error^7', 00H
	ORG $+2
$SG138372 DB	'rb', 00H
	ORG $+1
$SG138376 DB	'.ent', 00H
	ORG $+3
$SG138382 DB	'{', 00H
	ORG $+2
$SG138378 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138385 DB	'}', 00H
	ORG $+2
$SG138388 DB	'message', 00H
$SG138392 DB	'compiler', 00H
	ORG $+3
$SG138393 DB	'_compiler', 00H
	ORG $+2
$SG138396 DB	'generator', 00H
	ORG $+2
$SG138397 DB	'_generator', 00H
	ORG $+1
$SG138403 DB	'Darkplaces BSP2', 00H
$SG138406 DB	'XashXT old format', 00H
	ORG $+2
$SG138398 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138401 DB	'Quake', 00H
	ORG $+2
$SG138408 DB	'Paranoia 2: Savior', 00H
	ORG $+1
$SG138410 DB	'Half-Life extended', 00H
	ORG $+1
$SG138412 DB	'Half-Life', 00H
	ORG $+2
$SG138414 DB	'??', 00H
	ORG $+1
$SG138415 DB	'%16s (%s) ^3%s^7 ^2%s %s^7', 0aH, 00H
$SG138416 DB	0aH, '^3 %i maps found.', 0aH, 00H
$SG138417 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138436 DB	'%s*.dem', 00H
$SG138441 DB	'dem', 00H
$SG138442 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138443 DB	0aH, '^3 %i demos found.', 0aH, 00H
	ORG $+3
$SG138464 DB	'media/%s*.avi', 00H
	ORG $+2
$SG138469 DB	'avi', 00H
$SG138444 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138470 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138471 DB	0aH, '^3 %i movies found.', 0aH, 00H
	ORG $+2
$SG138472 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138494 DB	'media/%s*.*', 00H
$SG138499 DB	'wav', 00H
$SG138500 DB	'mp3', 00H
$SG138501 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138502 DB	0aH, '^3 %i soundtracks found.', 0aH, 00H
	ORG $+1
$SG138503 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138524 DB	'save/', 00H
	ORG $+2
$SG138525 DB	'%s%s*.sav', 00H
	ORG $+2
$SG138530 DB	'sav', 00H
$SG138531 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138532 DB	0aH, '^3 %i saves found.', 0aH, 00H
	ORG $+3
$SG138533 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138554 DB	'%s*.cfg', 00H
$SG138559 DB	'cfg', 00H
$SG138560 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138561 DB	0aH, '^3 %i configs found.', 0aH, 00H
	ORG $+1
$SG138585 DB	'%s%s*.*', 00H
$SG138591 DB	'wav', 00H
$SG138562 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138584 DB	'sound/', 00H
	ORG $+1
$SG138587 DB	'sound/', 00H
	ORG $+1
$SG138592 DB	'mp3', 00H
$SG138593 DB	'sound/', 00H
	ORG $+1
$SG138594 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138595 DB	0aH, '^3 %i sounds found.', 0aH, 00H
	ORG $+2
$SG138618 DB	'%s/%s*.txt', 00H
	ORG $+1
$SG138596 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138623 DB	'txt', 00H
$SG138624 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138625 DB	0aH, '^3 %i items found.', 0aH, 00H
	ORG $+3
$SG138647 DB	'%s*.hpk', 00H
$SG138652 DB	'hpk', 00H
$SG138626 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138653 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138654 DB	0aH, '^3 %i items found.', 0aH, 00H
	ORG $+3
$SG138655 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138680 DB	'game', 00H
	ORG $+3
$SG138686 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138687 DB	0aH, '^3 %i games found.', 0aH, 00H
	ORG $+3
$SG138713 DB	'info', 00H
	ORG $+3
$SG138715 DB	'loop', 00H
	ORG $+3
$SG138717 DB	'off', 00H
$SG138719 DB	'on', 00H
	ORG $+1
$SG138721 DB	'pause', 00H
	ORG $+2
$SG138723 DB	'play', 00H
	ORG $+3
$SG138725 DB	'resume', 00H
	ORG $+1
$SG138727 DB	'stop', 00H
	ORG $+3
$SG138733 DB	'%16s', 0aH, 00H
	ORG $+2
$SG138734 DB	0aH, '^3 %i commands found.', 0aH, 00H
$SG138773 DB	'maps.lst', 00H
	ORG $+3
$SG138774 DB	'maps/%s', 00H
$SG138775 DB	'maps/*.bsp', 00H
	ORG $+1
$SG138778 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138780 DB	'bsp', 00H
$SG138782 DB	'rb', 00H
	ORG $+1
$SG138785 DB	'.ent', 00H
	ORG $+3
$SG138787 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138789 DB	'No Title', 00H
	ORG $+3
$SG138794 DB	'message', 00H
$SG138796 DB	'classname', 00H
	ORG $+2
$SG138800 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138803 DB	'%s "%s"', 0aH, 00H
	ORG $+3
$SG138811 DB	'maps.lst', 00H
	ORG $+3
$SG138805 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138808 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138813 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\con_utils.c', 00H
	ORG $+3
$SG138844 DB	'\%s', 00H
$SG138868 DB	'%s "%s"', 0aH, 00H
	ORG $+3
$SG138886 DB	'%s', 09H, 09H, 09H, '"%s"', 0aH, 00H
	ORG $+1
$SG138888 DB	'%s', 09H, 09H, '"%s"', 0aH, 00H
	ORG $+2
$SG138890 DB	'%s', 09H, '"%s"', 0aH, 00H
	ORG $+3
$SG138892 DB	'%s "%s"', 0aH, 00H
	ORG $+3
$SG138908 DB	'w', 00H
	ORG $+2
$SG138909 DB	'config.cfg', 00H
	ORG $+1
$SG138912 DB	'Host_WriteConfig()', 0aH, 00H
$SG138914 DB	'//', 09H, 09H, 09H, 'Copyright XashXT Group %s ', 0a9H, 0aH
	DB	00H
	ORG $+2
$SG138913 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138915 DB	'//', 09H, 09H, 09H, 'config.cfg - archive of cvars', 0aH
	DB	00H
$SG138916 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138918 DB	'in_mlook', 00H
	ORG $+3
$SG138919 DB	'in_jlook', 00H
	ORG $+3
$SG138921 DB	'+mlook', 0aH, 00H
$SG138923 DB	'+jlook', 0aH, 00H
$SG138924 DB	'exec userconfig.cfg', 00H
$SG138925 DB	'^1Error:^7 Couldn''t write config.cfg.', 0aH, 00H
	ORG $+1
$SG138931 DB	'settings.scr', 00H
	ORG $+3
$SG138934 DB	'w', 00H
	ORG $+2
$SG138936 DB	'//', 09H, 09H, 09H, 'Copyright XashXT Group %s ', 0a9H, 0aH
	DB	00H
	ORG $+2
$SG138935 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138937 DB	'//', 09H, 09H, 'game.cfg - multiplayer server temporare '
	DB	'config', 0aH, 00H
$SG138938 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138939 DB	'settings.scr', 00H
	ORG $+3
$SG138940 DB	'^1Error:^7 Couldn''t write %s.', 0aH, 00H
	ORG $+1
$SG138944 DB	'w', 00H
	ORG $+2
$SG138945 DB	'opengl.cfg', 00H
	ORG $+1
$SG138948 DB	'Host_WriteGLConfig()', 0aH, 00H
	ORG $+2
$SG138950 DB	'//', 09H, 09H, 09H, 'Copyright XashXT Group %s ', 0a9H, 0aH
	DB	00H
	ORG $+2
$SG138949 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138951 DB	'//', 09H, 09H, '    opengl.cfg - archive of opengl exten'
	DB	'sion cvars', 0aH, 00H
$SG138953 DB	0aH, 00H
	ORG $+2
$SG138952 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138954 DB	'^1Error:^7 can''t update opengl.cfg.', 0aH, 00H
	ORG $+3
$SG138958 DB	'w', 00H
	ORG $+2
$SG138959 DB	'video.cfg', 00H
	ORG $+2
$SG138962 DB	'Host_WriteVideoConfig()', 0aH, 00H
	ORG $+3
$SG138963 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138964 DB	'//', 09H, 09H, 09H, 'Copyright XashXT Group %s ', 0a9H, 0aH
	DB	00H
	ORG $+2
$SG138965 DB	'//', 09H, 09H, 'video.cfg - archive of renderer variable'
	DB	's', 0aH, 00H
	ORG $+1
$SG138966 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138967 DB	'^1Error:^7 can''t update video.cfg.', 0aH, 00H
$SG138974 DB	'../help.txt', 00H
$SG138975 DB	'help.txt already exist', 0aH, 00H
$SG138976 DB	'w', 00H
	ORG $+2
$SG138977 DB	'../help.txt', 00H
$SG138981 DB	'//', 09H, 09H, 09H, 'Copyright XashXT Group %s ', 0a9H, 0aH
	DB	00H
	ORG $+2
$SG138980 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138982 DB	'//', 09H, 09H, 'help.txt - xash commands and console var'
	DB	'iables', 0aH, 00H
$SG138983 DB	'//======================================================'
	DB	'=================', 0aH, 00H
	ORG $+1
$SG138984 DB	0aH, 0aH, 09H, 09H, 09H, 'console variables', 0aH, 0aH, 00H
	ORG $+3
$SG138985 DB	0aH, 0aH, 09H, 09H, 09H, 'console commands', 0aH, 0aH, 00H
$SG138986 DB	0aH, 0aH, 00H
	ORG $+1
$SG138987 DB	'help.txt created', 0aH, 00H
	ORG $+2
$SG138988 DB	'^1Error:^7 couldn''t write help.txt.', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_f$ = 8							; size = 4
_Cmd_WriteOpenGLVariables PROC

; 908  : {

	push	ebp
	mov	ebp, esp

; 909  : 	Cvar_LookupVars( FCVAR_GLCONFIG, NULL, f, Cmd_WriteOpenGLCvar ); 

	push	OFFSET _Cmd_WriteOpenGLCvar
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	0
	push	4096					; 00001000H
	call	_Cvar_LookupVars
	add	esp, 16					; 00000010H

; 910  : }

	pop	ebp
	ret	0
_Cmd_WriteOpenGLVariables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_length$ = -4						; size = 4
_name$ = 8						; size = 4
_unused$ = 12						; size = 4
_desc$ = 16						; size = 4
_f$ = 20						; size = 4
_Cmd_WriteHelp PROC

; 891  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 892  : 	int	length;
; 893  : 
; 894  : 	if( !desc || !Q_strcmp( desc, "" ))

	cmp	DWORD PTR _desc$[ebp], 0
	je	SHORT $LN3@Cmd_WriteH
	push	99999					; 0001869fH
	push	OFFSET $SG138882
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Cmd_WriteH
$LN3@Cmd_WriteH:

; 895  : 		return; // ignore fantom cmds

	jmp	$LN1@Cmd_WriteH
$LN2@Cmd_WriteH:

; 896  : 	if( name[0] == '+' || name[0] == '-' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN5@Cmd_WriteH
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN4@Cmd_WriteH
$LN5@Cmd_WriteH:

; 897  : 		return; // key bindings	

	jmp	$LN1@Cmd_WriteH
$LN4@Cmd_WriteH:

; 898  : 
; 899  : 	length = 3 - (Q_strlen( name ) / 10); // Asm_Ed default tab stop is 10

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	edx, 3
	sub	edx, eax
	mov	DWORD PTR _length$[ebp], edx

; 900  : 
; 901  : 	if( length == 3 ) FS_Printf( f, "%s\t\t\t\"%s\"\n", name, desc );

	cmp	DWORD PTR _length$[ebp], 3
	jne	SHORT $LN6@Cmd_WriteH
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138886
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN6@Cmd_WriteH:

; 902  : 	if( length == 2 ) FS_Printf( f, "%s\t\t\"%s\"\n", name, desc );

	cmp	DWORD PTR _length$[ebp], 2
	jne	SHORT $LN7@Cmd_WriteH
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138888
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN7@Cmd_WriteH:

; 903  : 	if( length == 1 ) FS_Printf( f, "%s\t\"%s\"\n", name, desc );

	cmp	DWORD PTR _length$[ebp], 1
	jne	SHORT $LN8@Cmd_WriteH
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138890
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN8@Cmd_WriteH:

; 904  : 	if( length == 0 ) FS_Printf( f, "%s \"%s\"\n", name, desc );

	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN1@Cmd_WriteH
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138892
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN1@Cmd_WriteH:

; 905  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_WriteHelp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_string$ = 12						; size = 4
_desc$ = 16						; size = 4
_f$ = 20						; size = 4
_Cmd_WriteOpenGLCvar PROC

; 884  : {

	push	ebp
	mov	ebp, esp

; 885  : 	if( !COM_CheckString( desc ))

	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Cmd_WriteO

; 886  : 		return; // ignore cvars without description (fantom variables)

	jmp	SHORT $LN1@Cmd_WriteO
$LN2@Cmd_WriteO:

; 887  : 	FS_Printf( f, "%s \"%s\"\n", name, string );

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG138868
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN1@Cmd_WriteO:

; 888  : }

	pop	ebp
	ret	0
_Cmd_WriteOpenGLCvar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Cmd_CheckName PROC

; 846  : {

	push	ebp
	mov	ebp, esp

; 847  : 	if( !Q_stricmp( Cmd_Argv( 0 ), name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Cmd_CheckN

; 848  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Cmd_CheckN
$LN2@Cmd_CheckN:

; 849  : 	if( !Q_stricmp( Cmd_Argv( 0 ), va( "\\%s", name )))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138844
	call	_va
	add	esp, 8
	push	eax
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Cmd_CheckN

; 850  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Cmd_CheckN
$LN3@Cmd_CheckN:

; 851  : 	return false;

	xor	eax, eax
$LN1@Cmd_CheckN:

; 852  : }

	pop	ebp
	ret	0
_Cmd_CheckName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_size$ = -4412						; size = 4
_lumpofs$1 = -4408					; size = 4
_header$2 = -4404					; size = 4
tv128 = -4400						; size = 4
_use_filter$ = -4396					; size = 4
_worldspawn$3 = -4392					; size = 4
_num_spawnpoints$4 = -4388				; size = 4
_lumplen$5 = -4384					; size = 4
_f$ = -4380						; size = 4
_ents$6 = -4376						; size = 4
_pfile$7 = -4372					; size = 4
_buffer$ = -4368					; size = 4
_i$ = -4364						; size = 4
_t$ = -4360						; size = 4
_token$8 = -4356					; size = 2048
_buf$ = -2308						; size = 1024
_result$ = -1284					; size = 256
_mapname$9 = -1028					; size = 256
_message$10 = -772					; size = 256
_mpfilter$ = -516					; size = 256
_entfilename$11 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_fRefresh$ = 8						; size = 4
_onlyingamedir$ = 12					; size = 4
_Cmd_CheckMapsList_R PROC

; 670  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4412				; 0000113cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 671  : 	qboolean	use_filter = false;

	mov	DWORD PTR _use_filter$[ebp], 0

; 672  : 	byte	buf[MAX_SYSPATH];
; 673  : 	string	mpfilter;
; 674  : 	char	*buffer;
; 675  : 	string	result;
; 676  : 	int	i, size;
; 677  : 	search_t	*t;
; 678  : 	file_t	*f;
; 679  : 
; 680  : 	if( FS_FileSize( "maps.lst", onlyingamedir ) > 0 && !fRefresh )

	mov	eax, DWORD PTR _onlyingamedir$[ebp]
	push	eax
	push	OFFSET $SG138773
	call	_FS_FileSize
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN7@Cmd_CheckM
	cmp	DWORD PTR _fRefresh$[ebp], 0
	jne	SHORT $LN7@Cmd_CheckM

; 681  : 		return true; // exist 

	mov	eax, 1
	jmp	$LN1@Cmd_CheckM
$LN7@Cmd_CheckM:

; 682  : 
; 683  : 	// setup mpfilter
; 684  : 	Q_snprintf( mpfilter, sizeof( mpfilter ), "maps/%s", GI->mp_filter );

	mov	ecx, DWORD PTR _SI+768
	add	ecx, 1368				; 00000558H
	push	ecx
	push	OFFSET $SG138774
	push	256					; 00000100H
	lea	edx, DWORD PTR _mpfilter$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 685  : 	t = FS_Search( "maps/*.bsp", false, onlyingamedir );

	mov	eax, DWORD PTR _onlyingamedir$[ebp]
	push	eax
	push	0
	push	OFFSET $SG138775
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 686  : 
; 687  : 	if( !t )

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_CheckM

; 688  : 	{
; 689  : 		if( onlyingamedir )

	cmp	DWORD PTR _onlyingamedir$[ebp], 0
	je	SHORT $LN9@Cmd_CheckM

; 690  : 		{
; 691  : 			// mod doesn't contain any maps (probably this is a bot)
; 692  : 			return Cmd_CheckMapsList_R( fRefresh, false );

	push	0
	mov	ecx, DWORD PTR _fRefresh$[ebp]
	push	ecx
	call	_Cmd_CheckMapsList_R
	add	esp, 8
	jmp	$LN1@Cmd_CheckM
$LN9@Cmd_CheckM:

; 693  : 		}
; 694  : 		return false;

	xor	eax, eax
	jmp	$LN1@Cmd_CheckM
$LN8@Cmd_CheckM:

; 695  : 	}
; 696  : 
; 697  : 	buffer = Mem_Calloc( host.mempool, t->numfilenames * 2 * sizeof( result ));

	push	697					; 000002b9H
	push	OFFSET $SG138778
	push	1
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx]
	shl	eax, 1
	shl	eax, 8
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buffer$[ebp], eax

; 698  : 	use_filter = Q_strlen( GI->mp_filter ) ? true : false;

	mov	edx, DWORD PTR _SI+768
	add	edx, 1368				; 00000558H
	push	edx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN33@Cmd_CheckM
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN34@Cmd_CheckM
$LN33@Cmd_CheckM:
	mov	DWORD PTR tv128[ebp], 0
$LN34@Cmd_CheckM:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR _use_filter$[ebp], eax

; 699  : 
; 700  : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Cmd_CheckM
$LN2@Cmd_CheckM:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Cmd_CheckM:
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN3@Cmd_CheckM

; 701  : 	{
; 702  : 		char		*ents = NULL, *pfile;

	mov	DWORD PTR _ents$6[ebp], 0

; 703  : 		int		lumpofs = 0, lumplen = 0;

	mov	DWORD PTR _lumpofs$1[ebp], 0
	mov	DWORD PTR _lumplen$5[ebp], 0

; 704  : 		string		mapname, message, entfilename;
; 705  : 
; 706  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "bsp" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138780
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@Cmd_CheckM

; 707  : 			continue;

	jmp	SHORT $LN2@Cmd_CheckM
$LN10@Cmd_CheckM:

; 708  : 
; 709  : 		if( use_filter && !Q_strnicmp( t->filenames[i], mpfilter, Q_strlen( mpfilter )))

	cmp	DWORD PTR _use_filter$[ebp], 0
	je	SHORT $LN11@Cmd_CheckM
	lea	edx, DWORD PTR _mpfilter$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _mpfilter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Cmd_CheckM

; 710  : 			continue;

	jmp	$LN2@Cmd_CheckM
$LN11@Cmd_CheckM:

; 711  : 
; 712  : 		f = FS_Open( t->filenames[i], "rb", onlyingamedir );

	mov	edx, DWORD PTR _onlyingamedir$[ebp]
	push	edx
	push	OFFSET $SG138782
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 713  : 		COM_FileBase( t->filenames[i], mapname );

	lea	ecx, DWORD PTR _mapname$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 714  : 
; 715  : 		if( f )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN12@Cmd_CheckM

; 716  : 		{
; 717  : 			int	num_spawnpoints = 0;

	mov	DWORD PTR _num_spawnpoints$4[ebp], 0

; 718  : 			dheader_t	*header;
; 719  : 
; 720  : 			memset( buf, 0, MAX_SYSPATH );

	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 721  : 			FS_Read( f, buf, MAX_SYSPATH );

	push	1024					; 00000400H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 722  : 			header = (dheader_t *)buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _header$2[ebp], eax

; 723  : 
; 724  : 			// check all the lumps and some other errors
; 725  : 			if( !Mod_TestBmodelLumps( t->filenames[i], buf, true ))

	push	1
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_Mod_TestBmodelLumps
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@Cmd_CheckM

; 726  : 			{
; 727  : 				FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 728  : 				continue;

	jmp	$LN2@Cmd_CheckM
$LN13@Cmd_CheckM:

; 729  : 			}
; 730  : 
; 731  : 			// after call Mod_TestBmodelLumps we gurantee what map is valid                              
; 732  : 			lumpofs = header->lumps[LUMP_ENTITIES].fileofs;

	mov	ecx, 8
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _header$2[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _lumpofs$1[ebp], ecx

; 733  : 			lumplen = header->lumps[LUMP_ENTITIES].filelen;

	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _header$2[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _lumplen$5[ebp], edx

; 734  : 
; 735  : 			Q_strncpy( entfilename, t->filenames[i], sizeof( entfilename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	ecx, DWORD PTR _entfilename$11[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 736  : 			COM_StripExtension( entfilename );

	lea	edx, DWORD PTR _entfilename$11[ebp]
	push	edx
	call	_COM_StripExtension
	add	esp, 4

; 737  : 			COM_DefaultExtension( entfilename, ".ent" );

	push	OFFSET $SG138785
	lea	eax, DWORD PTR _entfilename$11[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 738  : 			ents = FS_LoadFile( entfilename, NULL, true );

	push	1
	push	0
	lea	ecx, DWORD PTR _entfilename$11[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ents$6[ebp], eax

; 739  : 
; 740  : 			if( !ents && lumplen >= 10 )

	cmp	DWORD PTR _ents$6[ebp], 0
	jne	SHORT $LN14@Cmd_CheckM
	cmp	DWORD PTR _lumplen$5[ebp], 10		; 0000000aH
	jl	SHORT $LN14@Cmd_CheckM

; 741  : 			{
; 742  : 				FS_Seek( f, lumpofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _lumpofs$1[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 743  : 				ents = Z_Calloc( lumplen + 1 );

	push	743					; 000002e7H
	push	OFFSET $SG138787
	push	1
	mov	ecx, DWORD PTR _lumplen$5[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ents$6[ebp], eax

; 744  : 				FS_Read( f, ents, lumplen );

	mov	eax, DWORD PTR _lumplen$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _ents$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
$LN14@Cmd_CheckM:

; 745  : 			}
; 746  : 
; 747  : 			if( ents )

	cmp	DWORD PTR _ents$6[ebp], 0
	je	$LN15@Cmd_CheckM

; 748  : 			{
; 749  : 				// if there are entities to parse, a missing message key just
; 750  : 				// means there is no title, so clear the message string now
; 751  : 				char	token[MAX_TOKEN];
; 752  : 				qboolean	worldspawn = true;

	mov	DWORD PTR _worldspawn$3[ebp], 1

; 753  : 
; 754  : 				Q_strncpy( message, "No Title", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138789
	lea	eax, DWORD PTR _message$10[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 755  : 				pfile = ents;

	mov	ecx, DWORD PTR _ents$6[ebp]
	mov	DWORD PTR _pfile$7[ebp], ecx
$LN5@Cmd_CheckM:

; 756  : 
; 757  : 				while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	edx, DWORD PTR _token$8[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$7[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$7[ebp], eax
	cmp	DWORD PTR _pfile$7[ebp], 0
	je	$LN6@Cmd_CheckM

; 758  : 				{
; 759  : 					if( token[0] == '}' && worldspawn )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _token$8[ebp+edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN16@Cmd_CheckM
	cmp	DWORD PTR _worldspawn$3[ebp], 0
	je	SHORT $LN16@Cmd_CheckM

; 760  : 						worldspawn = false;

	mov	DWORD PTR _worldspawn$3[ebp], 0
	jmp	$LN17@Cmd_CheckM
$LN16@Cmd_CheckM:

; 761  : 					else if( !Q_strcmp( token, "message" ) && worldspawn )

	push	99999					; 0001869fH
	push	OFFSET $SG138794
	lea	ecx, DWORD PTR _token$8[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@Cmd_CheckM
	cmp	DWORD PTR _worldspawn$3[ebp], 0
	je	SHORT $LN18@Cmd_CheckM

; 762  : 					{
; 763  : 						// get the message contents
; 764  : 						pfile = COM_ParseFile( pfile, message );

	lea	edx, DWORD PTR _message$10[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$7[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$7[ebp], eax

; 765  : 					}

	jmp	SHORT $LN17@Cmd_CheckM
$LN18@Cmd_CheckM:

; 766  : 					else if( !Q_strcmp( token, "classname" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138796
	lea	ecx, DWORD PTR _token$8[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@Cmd_CheckM

; 767  : 					{
; 768  : 						pfile = COM_ParseFile( pfile, token );

	lea	edx, DWORD PTR _token$8[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$7[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$7[ebp], eax

; 769  : 						if( !Q_strcmp( token, GI->mp_entity ) || use_filter )

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 1336				; 00000538H
	push	ecx
	lea	edx, DWORD PTR _token$8[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN22@Cmd_CheckM
	cmp	DWORD PTR _use_filter$[ebp], 0
	je	SHORT $LN17@Cmd_CheckM
$LN22@Cmd_CheckM:

; 770  : 							num_spawnpoints++;

	mov	eax, DWORD PTR _num_spawnpoints$4[ebp]
	add	eax, 1
	mov	DWORD PTR _num_spawnpoints$4[ebp], eax
$LN17@Cmd_CheckM:

; 771  : 					}
; 772  : 					if( num_spawnpoints ) break; // valid map

	cmp	DWORD PTR _num_spawnpoints$4[ebp], 0
	je	SHORT $LN23@Cmd_CheckM
	jmp	SHORT $LN6@Cmd_CheckM
$LN23@Cmd_CheckM:

; 773  : 				}

	jmp	$LN5@Cmd_CheckM
$LN6@Cmd_CheckM:

; 774  : 				Mem_Free( ents );

	push	774					; 00000306H
	push	OFFSET $SG138800
	mov	ecx, DWORD PTR _ents$6[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN15@Cmd_CheckM:

; 775  : 			}
; 776  : 
; 777  : 			if( f ) FS_Close( f );

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN24@Cmd_CheckM
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4
$LN24@Cmd_CheckM:

; 778  : 
; 779  : 			if( num_spawnpoints )

	cmp	DWORD PTR _num_spawnpoints$4[ebp], 0
	je	SHORT $LN12@Cmd_CheckM

; 780  : 			{
; 781  : 				// format: mapname "maptitle"\n
; 782  : 				Q_sprintf( result, "%s \"%s\"\n", mapname, message );

	lea	eax, DWORD PTR _message$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapname$9[ebp]
	push	ecx
	push	OFFSET $SG138803
	lea	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 783  : 				Q_strcat( buffer, result ); // add new string

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN12@Cmd_CheckM:

; 784  : 			}
; 785  : 		}
; 786  : 	}

	jmp	$LN2@Cmd_CheckM
$LN3@Cmd_CheckM:

; 787  : 
; 788  : 	if( t ) Mem_Free( t ); // free search result

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN26@Cmd_CheckM
	push	788					; 00000314H
	push	OFFSET $SG138805
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN26@Cmd_CheckM:

; 789  : 	size = Q_strlen( buffer );

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 790  : 
; 791  : 	if( !size )

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN27@Cmd_CheckM

; 792  : 	{
; 793  :           	if( buffer ) Mem_Free( buffer );

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN28@Cmd_CheckM
	push	793					; 00000319H
	push	OFFSET $SG138808
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN28@Cmd_CheckM:

; 794  : 
; 795  : 		if( onlyingamedir )

	cmp	DWORD PTR _onlyingamedir$[ebp], 0
	je	SHORT $LN29@Cmd_CheckM

; 796  : 			return Cmd_CheckMapsList_R( fRefresh, false );

	push	0
	mov	edx, DWORD PTR _fRefresh$[ebp]
	push	edx
	call	_Cmd_CheckMapsList_R
	add	esp, 8
	jmp	SHORT $LN1@Cmd_CheckM
$LN29@Cmd_CheckM:

; 797  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Cmd_CheckM
$LN27@Cmd_CheckM:

; 798  : 	}
; 799  : 
; 800  : 	// write generated maps.lst
; 801  : 	if( FS_WriteFile( "maps.lst", buffer, Q_strlen( buffer )))

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET $SG138811
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN30@Cmd_CheckM

; 802  : 	{
; 803  :           	if( buffer ) Mem_Free( buffer );

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN31@Cmd_CheckM
	push	803					; 00000323H
	push	OFFSET $SG138813
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN31@Cmd_CheckM:

; 804  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Cmd_CheckM
$LN30@Cmd_CheckM:

; 805  : 	}
; 806  : 	return false;

	xor	eax, eax
$LN1@Cmd_CheckM:

; 807  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_CheckMapsList_R ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
tv85 = -2352						; size = 4
_numcdcommands$ = -2348					; size = 4
_i$ = -2344						; size = 4
_cd_command$ = -2340					; size = 32
_cdcommands$ = -2308					; size = 2048
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetCDList PROC

; 619  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2352				; 00000930H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 620  : 	int i, numcdcommands;
; 621  : 	string	cdcommands[8];
; 622  : 	string	matchbuf;
; 623  : 
; 624  : 	const char *cd_command[] =

	mov	DWORD PTR _cd_command$[ebp], OFFSET $SG138713
	mov	DWORD PTR _cd_command$[ebp+4], OFFSET $SG138715
	mov	DWORD PTR _cd_command$[ebp+8], OFFSET $SG138717
	mov	DWORD PTR _cd_command$[ebp+12], OFFSET $SG138719
	mov	DWORD PTR _cd_command$[ebp+16], OFFSET $SG138721
	mov	DWORD PTR _cd_command$[ebp+20], OFFSET $SG138723
	mov	DWORD PTR _cd_command$[ebp+24], OFFSET $SG138725
	mov	DWORD PTR _cd_command$[ebp+28], OFFSET $SG138727

; 625  : 	{
; 626  : 	"info",
; 627  : 	"loop",
; 628  : 	"off",
; 629  : 	"on",
; 630  : 	"pause",
; 631  : 	"play",
; 632  : 	"resume",
; 633  : 	"stop",
; 634  : 	};
; 635  : 
; 636  : 	// compare CD command list with current keyword
; 637  : 	for( i = 0, numcdcommands = 0; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numcdcommands$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetCDL
$LN2@Cmd_GetCDL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_GetCDL:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN3@Cmd_GetCDL

; 638  : 	{
; 639  : 		if(( *s == '*' ) || !Q_strnicmp( cd_command[i], s, Q_strlen( s )))

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN12@Cmd_GetCDL
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cd_command$[ebp+edx*4]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Cmd_GetCDL
$LN12@Cmd_GetCDL:

; 640  : 			Q_strcpy( cdcommands[numcdcommands++], cd_command[i] );

	mov	ecx, DWORD PTR _numcdcommands$[ebp]
	shl	ecx, 8
	lea	edx, DWORD PTR _cdcommands$[ebp+ecx]
	mov	DWORD PTR tv85[ebp], edx
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cd_command$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR tv85[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _numcdcommands$[ebp]
	add	eax, 1
	mov	DWORD PTR _numcdcommands$[ebp], eax
$LN11@Cmd_GetCDL:

; 641  : 	}

	jmp	$LN2@Cmd_GetCDL
$LN3@Cmd_GetCDL:

; 642  : 
; 643  : 	if( !numcdcommands ) return false;

	cmp	DWORD PTR _numcdcommands$[ebp], 0
	jne	SHORT $LN13@Cmd_GetCDL
	xor	eax, eax
	jmp	$LN1@Cmd_GetCDL
$LN13@Cmd_GetCDL:

; 644  : 	Q_strncpy( matchbuf, cdcommands[0], MAX_STRING );

	push	256					; 00000100H
	mov	ecx, 256				; 00000100H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _cdcommands$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 645  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN14@Cmd_GetCDL
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN14@Cmd_GetCDL

; 646  : 		Q_strncpy( completedname, matchbuf, length );

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _completedname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN14@Cmd_GetCDL:

; 647  : 	if( numcdcommands == 1 ) return true;

	cmp	DWORD PTR _numcdcommands$[ebp], 1
	jne	SHORT $LN15@Cmd_GetCDL
	mov	eax, 1
	jmp	$LN1@Cmd_GetCDL
$LN15@Cmd_GetCDL:

; 648  : 
; 649  : 	for( i = 0; i < numcdcommands; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetCDL
$LN5@Cmd_GetCDL:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Cmd_GetCDL:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numcdcommands$[ebp]
	jge	SHORT $LN6@Cmd_GetCDL

; 650  : 	{
; 651  : 		Q_strncpy( matchbuf, cdcommands[i], MAX_STRING );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 8
	lea	edx, DWORD PTR _cdcommands$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 652  : 		Con_Printf( "%16s\n", matchbuf );

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	push	OFFSET $SG138733
	call	_Con_Printf
	add	esp, 8

; 653  : 	}

	jmp	SHORT $LN5@Cmd_GetCDL
$LN6@Cmd_GetCDL:

; 654  : 
; 655  : 	Con_Printf( "\n^3 %i commands found.\n", numcdcommands );

	mov	edx, DWORD PTR _numcdcommands$[ebp]
	push	edx
	push	OFFSET $SG138734
	call	_Con_Printf
	add	esp, 8

; 656  : 
; 657  : 	// cut shortestMatch to the amount common with s
; 658  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN16@Cmd_GetCDL
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN16@Cmd_GetCDL

; 659  : 	{
; 660  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Cmd_GetCDL
$LN8@Cmd_GetCDL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Cmd_GetCDL:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN16@Cmd_GetCDL

; 661  : 		{
; 662  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN17@Cmd_GetCDL

; 663  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN17@Cmd_GetCDL:

; 664  : 		}

	jmp	SHORT $LN8@Cmd_GetCDL
$LN16@Cmd_GetCDL:

; 665  : 	}
; 666  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetCDL:

; 667  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetCDList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
tv90 = -131344						; size = 4
_numgamedirs$ = -131340					; size = 4
_i$ = -131336						; size = 4
_gamedirs$ = -131332					; size = 131072
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetGamesList PROC

; 569  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131344				; 00020110H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 570  : 	int	i, numgamedirs;
; 571  : 	string	gamedirs[MAX_MODS];
; 572  : 	string	matchbuf;
; 573  : 
; 574  : 	// stand-alone games doesn't have cmd "game"
; 575  : 	if( !Cmd_Exists( "game" ))

	push	OFFSET $SG138680
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@Cmd_GetGam

; 576  : 		return false;

	xor	eax, eax
	jmp	$LN1@Cmd_GetGam
$LN11@Cmd_GetGam:

; 577  : 
; 578  : 	// compare gamelist with current keyword
; 579  : 	for( i = 0, numgamedirs = 0; i < SI.numgames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numgamedirs$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetGam
$LN2@Cmd_GetGam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_GetGam:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _SI+2820
	jge	$LN3@Cmd_GetGam

; 580  : 	{
; 581  : 		if(( *s == '*' ) || !Q_strnicmp( SI.games[i]->gamefolder, s, Q_strlen( s )))

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN13@Cmd_GetGam
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _SI[eax*4+772]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@Cmd_GetGam
$LN13@Cmd_GetGam:

; 582  : 			Q_strcpy( gamedirs[numgamedirs++], SI.games[i]->gamefolder ); 

	mov	edx, DWORD PTR _numgamedirs$[ebp]
	shl	edx, 8
	lea	eax, DWORD PTR _gamedirs$[ebp+edx]
	mov	DWORD PTR tv90[ebp], eax
	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _SI[ecx*4+772]
	push	edx
	mov	eax, DWORD PTR tv90[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _numgamedirs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numgamedirs$[ebp], ecx
$LN12@Cmd_GetGam:

; 583  : 	}

	jmp	$LN2@Cmd_GetGam
$LN3@Cmd_GetGam:

; 584  : 
; 585  : 	if( !numgamedirs ) return false;

	cmp	DWORD PTR _numgamedirs$[ebp], 0
	jne	SHORT $LN14@Cmd_GetGam
	xor	eax, eax
	jmp	$LN1@Cmd_GetGam
$LN14@Cmd_GetGam:

; 586  : 	Q_strncpy( matchbuf, gamedirs[0], MAX_STRING ); 

	push	256					; 00000100H
	mov	edx, 256				; 00000100H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _gamedirs$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 587  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN15@Cmd_GetGam
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN15@Cmd_GetGam

; 588  : 		Q_strncpy( completedname, matchbuf, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _completedname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN15@Cmd_GetGam:

; 589  : 	if( numgamedirs == 1 ) return true;

	cmp	DWORD PTR _numgamedirs$[ebp], 1
	jne	SHORT $LN16@Cmd_GetGam
	mov	eax, 1
	jmp	$LN1@Cmd_GetGam
$LN16@Cmd_GetGam:

; 590  : 
; 591  : 	for( i = 0; i < numgamedirs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetGam
$LN5@Cmd_GetGam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetGam:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numgamedirs$[ebp]
	jge	SHORT $LN6@Cmd_GetGam

; 592  : 	{
; 593  : 		Q_strncpy( matchbuf, gamedirs[i], MAX_STRING ); 

	push	256					; 00000100H
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 8
	lea	eax, DWORD PTR _gamedirs$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 594  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138686
	call	_Con_Printf
	add	esp, 8

; 595  : 	}

	jmp	SHORT $LN5@Cmd_GetGam
$LN6@Cmd_GetGam:

; 596  : 
; 597  : 	Con_Printf( "\n^3 %i games found.\n", numgamedirs );

	mov	eax, DWORD PTR _numgamedirs$[ebp]
	push	eax
	push	OFFSET $SG138687
	call	_Con_Printf
	add	esp, 8

; 598  : 
; 599  : 	// cut shortestMatch to the amount common with s
; 600  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN17@Cmd_GetGam
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN17@Cmd_GetGam

; 601  : 	{
; 602  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Cmd_GetGam
$LN8@Cmd_GetGam:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@Cmd_GetGam:
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _matchbuf$[ebp+edx]
	test	eax, eax
	je	SHORT $LN17@Cmd_GetGam

; 603  : 		{
; 604  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	ecx, DWORD PTR _completedname$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _matchbuf$[ebp+eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	cmp	esi, edx
	je	SHORT $LN18@Cmd_GetGam

; 605  : 				completedname[i] = 0;

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 0
$LN18@Cmd_GetGam:

; 606  : 		}

	jmp	SHORT $LN8@Cmd_GetGam
$LN17@Cmd_GetGam:

; 607  : 	}
; 608  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetGam:

; 609  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetGamesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_numitems$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetCustomList PROC

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 524  : 	search_t		*t;
; 525  : 	string		matchbuf;
; 526  : 	int		i, numitems;
; 527  : 
; 528  : 	t = FS_Search( va( "%s*.hpk", s ), true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138647
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 529  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetCus
	xor	eax, eax
	jmp	$LN1@Cmd_GetCus
$LN8@Cmd_GetCus:

; 530  : 
; 531  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 532  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetCus
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetCus

; 533  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetCus:

; 534  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@Cmd_GetCus
	mov	eax, 1
	jmp	$LN1@Cmd_GetCus
$LN10@Cmd_GetCus:

; 535  : 
; 536  : 	for(i = 0, numitems = 0; i < t->numfilenames; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numitems$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetCus
$LN2@Cmd_GetCus:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetCus:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Cmd_GetCus

; 537  : 	{
; 538  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "hpk" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138652
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetCus

; 539  : 			continue;

	jmp	SHORT $LN2@Cmd_GetCus
$LN11@Cmd_GetCus:

; 540  : 
; 541  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 542  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138653
	call	_Con_Printf
	add	esp, 8

; 543  : 		numitems++;

	mov	eax, DWORD PTR _numitems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numitems$[ebp], eax

; 544  : 	}

	jmp	$LN2@Cmd_GetCus
$LN3@Cmd_GetCus:

; 545  : 
; 546  : 	Con_Printf( "\n^3 %i items found.\n", numitems );

	mov	ecx, DWORD PTR _numitems$[ebp]
	push	ecx
	push	OFFSET $SG138654
	call	_Con_Printf
	add	esp, 8

; 547  : 	Mem_Free( t );

	push	547					; 00000223H
	push	OFFSET $SG138655
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 548  : 
; 549  : 	// cut shortestMatch to the amount common with s
; 550  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetCus
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetCus

; 551  : 	{
; 552  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetCus
$LN5@Cmd_GetCus:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetCus:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@Cmd_GetCus

; 553  : 		{
; 554  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN13@Cmd_GetCus

; 555  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN13@Cmd_GetCus:

; 556  : 		}

	jmp	SHORT $LN5@Cmd_GetCus
$LN12@Cmd_GetCus:

; 557  : 	}
; 558  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetCus:

; 559  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetCustomList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_numitems$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetItemsList PROC

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 477  : 	search_t		*t;
; 478  : 	string		matchbuf;
; 479  : 	int		i, numitems;
; 480  : 
; 481  : 	if( !clgame.itemspath[0] ) return false; // not in game yet

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _clgame[ecx+744]
	test	edx, edx
	jne	SHORT $LN8@Cmd_GetIte
	xor	eax, eax
	jmp	$LN1@Cmd_GetIte
$LN8@Cmd_GetIte:

; 482  : 	t = FS_Search( va( "%s/%s*.txt", clgame.itemspath, s ), true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET _clgame+744
	push	OFFSET $SG138618
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 483  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN9@Cmd_GetIte
	xor	eax, eax
	jmp	$LN1@Cmd_GetIte
$LN9@Cmd_GetIte:

; 484  : 
; 485  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 486  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN10@Cmd_GetIte
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN10@Cmd_GetIte

; 487  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN10@Cmd_GetIte:

; 488  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN11@Cmd_GetIte
	mov	eax, 1
	jmp	$LN1@Cmd_GetIte
$LN11@Cmd_GetIte:

; 489  : 
; 490  : 	for(i = 0, numitems = 0; i < t->numfilenames; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numitems$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetIte
$LN2@Cmd_GetIte:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetIte:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Cmd_GetIte

; 491  : 	{
; 492  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "txt" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138623
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@Cmd_GetIte

; 493  : 			continue;

	jmp	SHORT $LN2@Cmd_GetIte
$LN12@Cmd_GetIte:

; 494  : 
; 495  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 496  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138624
	call	_Con_Printf
	add	esp, 8

; 497  : 		numitems++;

	mov	eax, DWORD PTR _numitems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numitems$[ebp], eax

; 498  : 	}

	jmp	$LN2@Cmd_GetIte
$LN3@Cmd_GetIte:

; 499  : 
; 500  : 	Con_Printf( "\n^3 %i items found.\n", numitems );

	mov	ecx, DWORD PTR _numitems$[ebp]
	push	ecx
	push	OFFSET $SG138625
	call	_Con_Printf
	add	esp, 8

; 501  : 	Mem_Free( t );

	push	501					; 000001f5H
	push	OFFSET $SG138626
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 502  : 
; 503  : 	// cut shortestMatch to the amount common with s
; 504  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN13@Cmd_GetIte
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN13@Cmd_GetIte

; 505  : 	{
; 506  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetIte
$LN5@Cmd_GetIte:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetIte:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN13@Cmd_GetIte

; 507  : 		{
; 508  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN14@Cmd_GetIte

; 509  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN14@Cmd_GetIte:

; 510  : 		}

	jmp	SHORT $LN5@Cmd_GetIte
$LN13@Cmd_GetIte:

; 511  : 	}
; 512  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetIte:

; 513  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetItemsList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_ext$1 = -276						; size = 4
_numsounds$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetSoundList PROC

; 425  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 426  : 	search_t		*t;
; 427  : 	string		matchbuf;
; 428  : 	int		i, numsounds;
; 429  : 
; 430  : 	t = FS_Search( va( "%s%s*.*", DEFAULT_SOUNDPATH, s ), true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138584
	push	OFFSET $SG138585
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 431  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetSou
	xor	eax, eax
	jmp	$LN1@Cmd_GetSou
$LN8@Cmd_GetSou:

; 432  : 
; 433  : 	Q_strncpy( matchbuf, t->filenames[0] + Q_strlen( DEFAULT_SOUNDPATH ), MAX_STRING ); 

	push	256					; 00000100H
	mov	ecx, 4
	imul	esi, ecx, 0
	mov	edx, DWORD PTR _t$[ebp]
	mov	edi, DWORD PTR [edx+4]
	push	OFFSET $SG138587
	call	_Q_strlen
	add	esp, 4
	add	eax, DWORD PTR [edi+esi]
	push	eax
	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 434  : 	COM_StripExtension( matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	call	_COM_StripExtension
	add	esp, 4

; 435  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetSou
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetSou

; 436  : 		Q_strncpy( completedname, matchbuf, length );

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _completedname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetSou:

; 437  : 	if( t->numfilenames == 1 ) return true;

	mov	edx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN10@Cmd_GetSou
	mov	eax, 1
	jmp	$LN1@Cmd_GetSou
$LN10@Cmd_GetSou:

; 438  : 
; 439  : 	for(i = 0, numsounds = 0; i < t->numfilenames; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numsounds$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetSou
$LN2@Cmd_GetSou:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_GetSou:
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN3@Cmd_GetSou

; 440  : 	{
; 441  : 		const char *ext = COM_FileExtension( t->filenames[i] ); 

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$1[ebp], eax

; 442  : 
; 443  : 		if( Q_stricmp( ext, "wav" ) && Q_stricmp( ext, "mp3" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138591
	mov	ecx, DWORD PTR _ext$1[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetSou
	push	99999					; 0001869fH
	push	OFFSET $SG138592
	mov	edx, DWORD PTR _ext$1[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetSou

; 444  : 			continue;

	jmp	SHORT $LN2@Cmd_GetSou
$LN11@Cmd_GetSou:

; 445  : 
; 446  : 		Q_strncpy( matchbuf, t->filenames[i] + Q_strlen( DEFAULT_SOUNDPATH ), MAX_STRING ); 

	push	256					; 00000100H
	mov	eax, DWORD PTR _t$[ebp]
	mov	esi, DWORD PTR [eax+4]
	push	OFFSET $SG138593
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR [esi+ecx*4]
	push	eax
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 447  : 		COM_StripExtension( matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 448  : 		Con_Printf( "%16s\n", matchbuf );

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	push	OFFSET $SG138594
	call	_Con_Printf
	add	esp, 8

; 449  : 		numsounds++;

	mov	edx, DWORD PTR _numsounds$[ebp]
	add	edx, 1
	mov	DWORD PTR _numsounds$[ebp], edx

; 450  : 	}

	jmp	$LN2@Cmd_GetSou
$LN3@Cmd_GetSou:

; 451  : 
; 452  : 	Con_Printf( "\n^3 %i sounds found.\n", numsounds );

	mov	eax, DWORD PTR _numsounds$[ebp]
	push	eax
	push	OFFSET $SG138595
	call	_Con_Printf
	add	esp, 8

; 453  : 	Mem_Free( t );

	push	453					; 000001c5H
	push	OFFSET $SG138596
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 454  : 
; 455  : 	// cut shortestMatch to the amount common with s
; 456  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetSou
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetSou

; 457  : 	{
; 458  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetSou
$LN5@Cmd_GetSou:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Cmd_GetSou:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _matchbuf$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN12@Cmd_GetSou

; 459  : 		{
; 460  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	eax, al
	cmp	esi, eax
	je	SHORT $LN13@Cmd_GetSou

; 461  : 				completedname[i] = 0;

	mov	ecx, DWORD PTR _completedname$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], 0
$LN13@Cmd_GetSou:

; 462  : 		}

	jmp	SHORT $LN5@Cmd_GetSou
$LN12@Cmd_GetSou:

; 463  : 	}
; 464  : 
; 465  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetSou:

; 466  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetSoundList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_numconfigs$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetConfigList PROC

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 379  : 	search_t		*t;
; 380  : 	string		matchbuf;
; 381  : 	int		i, numconfigs;
; 382  : 
; 383  : 	t = FS_Search( va( "%s*.cfg", s ), true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138554
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 384  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetCon
	xor	eax, eax
	jmp	$LN1@Cmd_GetCon
$LN8@Cmd_GetCon:

; 385  : 
; 386  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 387  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetCon
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetCon

; 388  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetCon:

; 389  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@Cmd_GetCon
	mov	eax, 1
	jmp	$LN1@Cmd_GetCon
$LN10@Cmd_GetCon:

; 390  : 
; 391  : 	for( i = 0, numconfigs = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numconfigs$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetCon
$LN2@Cmd_GetCon:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetCon:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Cmd_GetCon

; 392  : 	{
; 393  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "cfg" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138559
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetCon

; 394  : 			continue;

	jmp	SHORT $LN2@Cmd_GetCon
$LN11@Cmd_GetCon:

; 395  : 
; 396  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 397  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138560
	call	_Con_Printf
	add	esp, 8

; 398  : 		numconfigs++;

	mov	eax, DWORD PTR _numconfigs$[ebp]
	add	eax, 1
	mov	DWORD PTR _numconfigs$[ebp], eax

; 399  : 	}

	jmp	$LN2@Cmd_GetCon
$LN3@Cmd_GetCon:

; 400  : 
; 401  : 	Con_Printf( "\n^3 %i configs found.\n", numconfigs );

	mov	ecx, DWORD PTR _numconfigs$[ebp]
	push	ecx
	push	OFFSET $SG138561
	call	_Con_Printf
	add	esp, 8

; 402  : 	Mem_Free( t );

	push	402					; 00000192H
	push	OFFSET $SG138562
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 403  : 
; 404  : 	// cut shortestMatch to the amount common with s
; 405  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetCon
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetCon

; 406  : 	{
; 407  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetCon
$LN5@Cmd_GetCon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetCon:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@Cmd_GetCon

; 408  : 		{
; 409  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN13@Cmd_GetCon

; 410  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN13@Cmd_GetCon:

; 411  : 		}

	jmp	SHORT $LN5@Cmd_GetCon
$LN12@Cmd_GetCon:

; 412  : 	}
; 413  : 
; 414  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetCon:

; 415  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetConfigList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_numsaves$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetSavesList PROC

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 332  : 	search_t		*t;
; 333  : 	string		matchbuf;
; 334  : 	int		i, numsaves;
; 335  : 
; 336  : 	t = FS_Search( va( "%s%s*.sav", DEFAULT_SAVE_DIRECTORY, s ), true, true );	// lookup only in gamedir

	push	1
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138524
	push	OFFSET $SG138525
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 337  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetSav
	xor	eax, eax
	jmp	$LN1@Cmd_GetSav
$LN8@Cmd_GetSav:

; 338  : 
; 339  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 340  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetSav
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetSav

; 341  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetSav:

; 342  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@Cmd_GetSav
	mov	eax, 1
	jmp	$LN1@Cmd_GetSav
$LN10@Cmd_GetSav:

; 343  : 
; 344  : 	for( i = 0, numsaves = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numsaves$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetSav
$LN2@Cmd_GetSav:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetSav:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Cmd_GetSav

; 345  : 	{
; 346  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "sav" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138530
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetSav

; 347  : 			continue;

	jmp	SHORT $LN2@Cmd_GetSav
$LN11@Cmd_GetSav:

; 348  : 
; 349  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 350  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138531
	call	_Con_Printf
	add	esp, 8

; 351  : 		numsaves++;

	mov	eax, DWORD PTR _numsaves$[ebp]
	add	eax, 1
	mov	DWORD PTR _numsaves$[ebp], eax

; 352  : 	}

	jmp	$LN2@Cmd_GetSav
$LN3@Cmd_GetSav:

; 353  : 
; 354  : 	Con_Printf( "\n^3 %i saves found.\n", numsaves );

	mov	ecx, DWORD PTR _numsaves$[ebp]
	push	ecx
	push	OFFSET $SG138532
	call	_Con_Printf
	add	esp, 8

; 355  : 	Mem_Free( t );

	push	355					; 00000163H
	push	OFFSET $SG138533
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 356  : 
; 357  : 	// cut shortestMatch to the amount common with s
; 358  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetSav
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetSav

; 359  : 	{
; 360  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetSav
$LN5@Cmd_GetSav:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetSav:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@Cmd_GetSav

; 361  : 		{
; 362  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN13@Cmd_GetSav

; 363  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN13@Cmd_GetSav:

; 364  : 		}

	jmp	SHORT $LN5@Cmd_GetSav
$LN12@Cmd_GetSav:

; 365  : 	}
; 366  : 
; 367  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetSav:

; 368  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetSavesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_ext$1 = -276						; size = 4
_numtracks$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetMusicList PROC

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 284  : 	search_t		*t;
; 285  : 	string		matchbuf;
; 286  : 	int		i, numtracks;
; 287  : 
; 288  : 	t = FS_Search( va( "media/%s*.*", s ), true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138494
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 289  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetMus
	xor	eax, eax
	jmp	$LN1@Cmd_GetMus
$LN8@Cmd_GetMus:

; 290  : 
; 291  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 292  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetMus
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetMus

; 293  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetMus:

; 294  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@Cmd_GetMus
	mov	eax, 1
	jmp	$LN1@Cmd_GetMus
$LN10@Cmd_GetMus:

; 295  : 
; 296  : 	for(i = 0, numtracks = 0; i < t->numfilenames; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numtracks$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetMus
$LN2@Cmd_GetMus:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetMus:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN3@Cmd_GetMus

; 297  : 	{
; 298  : 		const char *ext = COM_FileExtension( t->filenames[i] ); 

	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$1[ebp], eax

; 299  : 
; 300  : 		if( Q_stricmp( ext, "wav" ) && Q_stricmp( ext, "mp3" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138499
	mov	eax, DWORD PTR _ext$1[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetMus
	push	99999					; 0001869fH
	push	OFFSET $SG138500
	mov	ecx, DWORD PTR _ext$1[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetMus

; 301  : 			continue;

	jmp	SHORT $LN2@Cmd_GetMus
$LN11@Cmd_GetMus:

; 302  : 
; 303  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 304  : 		Con_Printf( "%16s\n", matchbuf );

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	push	OFFSET $SG138501
	call	_Con_Printf
	add	esp, 8

; 305  : 		numtracks++;

	mov	edx, DWORD PTR _numtracks$[ebp]
	add	edx, 1
	mov	DWORD PTR _numtracks$[ebp], edx

; 306  : 	}

	jmp	$LN2@Cmd_GetMus
$LN3@Cmd_GetMus:

; 307  : 
; 308  : 	Con_Printf( "\n^3 %i soundtracks found.\n", numtracks );

	mov	eax, DWORD PTR _numtracks$[ebp]
	push	eax
	push	OFFSET $SG138502
	call	_Con_Printf
	add	esp, 8

; 309  : 	Mem_Free(t);

	push	309					; 00000135H
	push	OFFSET $SG138503
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 310  : 
; 311  : 	// cut shortestMatch to the amount common with s
; 312  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetMus
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetMus

; 313  : 	{
; 314  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetMus
$LN5@Cmd_GetMus:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Cmd_GetMus:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _matchbuf$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN12@Cmd_GetMus

; 315  : 		{
; 316  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	eax, al
	cmp	esi, eax
	je	SHORT $LN13@Cmd_GetMus

; 317  : 				completedname[i] = 0;

	mov	ecx, DWORD PTR _completedname$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], 0
$LN13@Cmd_GetMus:

; 318  : 		}

	jmp	SHORT $LN5@Cmd_GetMus
$LN12@Cmd_GetMus:

; 319  : 	}
; 320  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetMus:

; 321  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetMusicList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_list$ = -4						; size = 4
_source$ = 8						; size = 4
_buffer$ = 12						; size = 4
_bufsize$ = 16						; size = 4
_Cmd_AutocompleteName PROC

; 863  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 864  : 	autocomplete_list_t	*list;
; 865  : 
; 866  : 	for( list = cmd_list; list->name; list++ )

	mov	DWORD PTR _list$[ebp], OFFSET _cmd_list
	jmp	SHORT $LN4@Cmd_Autoco
$LN2@Cmd_Autoco:
	mov	eax, DWORD PTR _list$[ebp]
	add	eax, 8
	mov	DWORD PTR _list$[ebp], eax
$LN4@Cmd_Autoco:
	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Cmd_Autoco

; 867  : 	{
; 868  : 		if( Cmd_CheckName( list->name ))

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Cmd_CheckName
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@Cmd_Autoco

; 869  : 			return list->func( source, buffer, bufsize ); 

	mov	ecx, DWORD PTR _bufsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@Cmd_Autoco
$LN5@Cmd_Autoco:

; 870  : 	}

	jmp	SHORT $LN2@Cmd_Autoco
$LN3@Cmd_Autoco:

; 871  : 
; 872  : 	return false;

	xor	eax, eax
$LN1@Cmd_Autoco:

; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AutocompleteName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_fRefresh$ = 8						; size = 4
_Cmd_CheckMapsList PROC

; 810  : {

	push	ebp
	mov	ebp, esp

; 811  : 	return Cmd_CheckMapsList_R( fRefresh, true );

	push	1
	mov	eax, DWORD PTR _fRefresh$[ebp]
	push	eax
	call	_Cmd_CheckMapsList_R
	add	esp, 8

; 812  : }

	pop	ebp
	ret	0
_Cmd_CheckMapsList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_f$ = -4						; size = 4
_Key_EnumCmds_f PROC

; 1043 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1044 : 	file_t	*f;
; 1045 : 
; 1046 : 	FS_AllowDirectPaths( true );

	push	1
	call	_FS_AllowDirectPaths
	add	esp, 4

; 1047 : 	if( FS_FileExists( "../help.txt", false ))

	push	0
	push	OFFSET $SG138974
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@Key_EnumCm

; 1048 : 	{
; 1049 : 		Con_Printf( "help.txt already exist\n" );

	push	OFFSET $SG138975
	call	_Con_Printf
	add	esp, 4

; 1050 : 		FS_AllowDirectPaths( false );

	push	0
	call	_FS_AllowDirectPaths
	add	esp, 4

; 1051 : 		return;

	jmp	$LN1@Key_EnumCm
$LN2@Key_EnumCm:

; 1052 : 	}
; 1053 : 
; 1054 : 	f = FS_Open( "../help.txt", "w", false );

	push	0
	push	OFFSET $SG138976
	push	OFFSET $SG138977
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 1055 : 	if( f )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN3@Key_EnumCm

; 1056 : 	{
; 1057 : 		FS_Printf( f, "//=======================================================================\n");

	push	OFFSET $SG138980
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1058 : 		FS_Printf( f, "//\t\t\tCopyright XashXT Group %s \n", Q_timestamp( TIME_YEAR_ONLY ));

	push	4
	call	_Q_timestamp
	add	esp, 4
	push	eax
	push	OFFSET $SG138981
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 1059 : 		FS_Printf( f, "//\t\thelp.txt - xash commands and console variables\n");

	push	OFFSET $SG138982
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 8

; 1060 : 		FS_Printf( f, "//=======================================================================\n");

	push	OFFSET $SG138983
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1061 : 
; 1062 : 		FS_Printf( f, "\n\n\t\t\tconsole variables\n\n");

	push	OFFSET $SG138984
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 8

; 1063 : 		Cvar_LookupVars( 0, NULL, f, Cmd_WriteHelp ); 

	push	OFFSET _Cmd_WriteHelp
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	push	0
	push	0
	call	_Cvar_LookupVars
	add	esp, 16					; 00000010H

; 1064 : 		FS_Printf( f, "\n\n\t\t\tconsole commands\n\n");

	push	OFFSET $SG138985
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1065 : 		Cmd_LookupCmds( NULL, f, Cmd_WriteHelp ); 

	push	OFFSET _Cmd_WriteHelp
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	push	0
	call	_Cmd_LookupCmds
	add	esp, 12					; 0000000cH

; 1066 :   		FS_Printf( f, "\n\n");

	push	OFFSET $SG138986
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 8

; 1067 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1068 : 		Con_Printf( "help.txt created\n" );

	push	OFFSET $SG138987
	call	_Con_Printf
	add	esp, 4

; 1069 : 	}

	jmp	SHORT $LN4@Key_EnumCm
$LN3@Key_EnumCm:

; 1070 : 	else Con_Printf( S_ERROR "couldn't write help.txt.\n");

	push	OFFSET $SG138988
	call	_Con_Printf
	add	esp, 4
$LN4@Key_EnumCm:

; 1071 : 	FS_AllowDirectPaths( false );

	push	0
	call	_FS_AllowDirectPaths
	add	esp, 4
$LN1@Key_EnumCm:

; 1072 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Key_EnumCmds_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_jlook$ = -12						; size = 4
_mlook$ = -8						; size = 4
_f$ = -4						; size = 4
_Host_WriteConfig PROC

; 920  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 921  : 	kbutton_t	*mlook = NULL;

	mov	DWORD PTR _mlook$[ebp], 0

; 922  : 	kbutton_t	*jlook = NULL;

	mov	DWORD PTR _jlook$[ebp], 0

; 923  : 	file_t	*f;
; 924  : 
; 925  : 	if( !clgame.hInstance ) return;

	cmp	DWORD PTR _clgame, 0
	jne	SHORT $LN2@Host_Write
	jmp	$LN1@Host_Write
$LN2@Host_Write:

; 926  : 
; 927  : 
; 928  : 	f = FS_Open( "config.cfg", "w", false );

	push	0
	push	OFFSET $SG138908
	push	OFFSET $SG138909
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 929  : 	if( f )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN3@Host_Write

; 930  : 	{
; 931  : 		Con_Reportf( "Host_WriteConfig()\n" );

	push	OFFSET $SG138912
	call	_Con_Reportf
	add	esp, 4

; 932  : 		FS_Printf( f, "//=======================================================================\n");

	push	OFFSET $SG138913
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 933  : 		FS_Printf( f, "//\t\t\tCopyright XashXT Group %s \n", Q_timestamp( TIME_YEAR_ONLY ));

	push	4
	call	_Q_timestamp
	add	esp, 4
	push	eax
	push	OFFSET $SG138914
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 934  : 		FS_Printf( f, "//\t\t\tconfig.cfg - archive of cvars\n" );

	push	OFFSET $SG138915
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 8

; 935  : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138916
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 936  : 		Key_WriteBindings( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_Key_WriteBindings
	add	esp, 4

; 937  : 		Cvar_WriteVariables( f, FCVAR_ARCHIVE );

	push	1
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_Cvar_WriteVariables
	add	esp, 8

; 938  : 		Info_WriteVars( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_Info_WriteVars
	add	esp, 4

; 939  : 
; 940  : 		if( clgame.hInstance )

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN5@Host_Write

; 941  : 		{
; 942  : 			mlook = (kbutton_t *)clgame.dllFuncs.KB_Find( "in_mlook" );

	push	OFFSET $SG138918
	call	DWORD PTR _clgame+72
	add	esp, 4
	mov	DWORD PTR _mlook$[ebp], eax

; 943  : 			jlook = (kbutton_t *)clgame.dllFuncs.KB_Find( "in_jlook" );

	push	OFFSET $SG138919
	call	DWORD PTR _clgame+72
	add	esp, 4
	mov	DWORD PTR _jlook$[ebp], eax
$LN5@Host_Write:

; 944  : 		}
; 945  : 
; 946  : 		if( mlook && ( mlook->state & 1 )) 

	cmp	DWORD PTR _mlook$[ebp], 0
	je	SHORT $LN6@Host_Write
	mov	ecx, DWORD PTR _mlook$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 1
	je	SHORT $LN6@Host_Write

; 947  : 			FS_Printf( f, "+mlook\n" );

	push	OFFSET $SG138921
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8
$LN6@Host_Write:

; 948  : 
; 949  : 		if( jlook && ( jlook->state & 1 ))

	cmp	DWORD PTR _jlook$[ebp], 0
	je	SHORT $LN7@Host_Write
	mov	ecx, DWORD PTR _jlook$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 1
	je	SHORT $LN7@Host_Write

; 950  : 			FS_Printf( f, "+jlook\n" );

	push	OFFSET $SG138923
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8
$LN7@Host_Write:

; 951  : 
; 952  : 		FS_Printf( f, "exec userconfig.cfg" );

	push	OFFSET $SG138924
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 8

; 953  : 
; 954  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 955  : 	}

	jmp	SHORT $LN1@Host_Write
$LN3@Host_Write:

; 956  : 	else Con_DPrintf( S_ERROR "Couldn't write config.cfg.\n" );

	push	OFFSET $SG138925
	call	_Con_DPrintf
	add	esp, 4
$LN1@Host_Write:

; 957  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Host_WriteConfig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_f$ = -4						; size = 4
_Host_WriteVideoConfig PROC

; 1025 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1026 : 	file_t	*f;
; 1027 : 
; 1028 : 	f = FS_Open( "video.cfg", "w", false );

	push	0
	push	OFFSET $SG138958
	push	OFFSET $SG138959
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 1029 : 	if( f )

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN2@Host_Write

; 1030 : 	{
; 1031 : 		Con_Reportf( "Host_WriteVideoConfig()\n" );

	push	OFFSET $SG138962
	call	_Con_Reportf
	add	esp, 4

; 1032 : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138963
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1033 : 		FS_Printf( f, "//\t\t\tCopyright XashXT Group %s \n", Q_timestamp( TIME_YEAR_ONLY ));

	push	4
	call	_Q_timestamp
	add	esp, 4
	push	eax
	push	OFFSET $SG138964
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 1034 : 		FS_Printf( f, "//\t\tvideo.cfg - archive of renderer variables\n");

	push	OFFSET $SG138965
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 8

; 1035 : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138966
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1036 : 		Cvar_WriteVariables( f, FCVAR_RENDERINFO );

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_Cvar_WriteVariables
	add	esp, 8

; 1037 : 		FS_Close( f );	

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 1038 : 	}                                                

	jmp	SHORT $LN1@Host_Write
$LN2@Host_Write:

; 1039 : 	else Con_DPrintf( S_ERROR "can't update video.cfg.\n" );

	push	OFFSET $SG138967
	call	_Con_DPrintf
	add	esp, 4
$LN1@Host_Write:

; 1040 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Host_WriteVideoConfig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_f$ = -4						; size = 4
_Host_WriteOpenGLConfig PROC

; 998  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 999  : 	file_t	*f;
; 1000 : 
; 1001 : 
; 1002 : 	f = FS_Open( "opengl.cfg", "w", false );

	push	0
	push	OFFSET $SG138944
	push	OFFSET $SG138945
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 1003 : 	if( f )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN2@Host_Write

; 1004 : 	{
; 1005 : 		Con_Reportf( "Host_WriteGLConfig()\n" );

	push	OFFSET $SG138948
	call	_Con_Reportf
	add	esp, 4

; 1006 : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138949
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1007 : 		FS_Printf( f, "//\t\t\tCopyright XashXT Group %s \n", Q_timestamp( TIME_YEAR_ONLY ));

	push	4
	call	_Q_timestamp
	add	esp, 4
	push	eax
	push	OFFSET $SG138950
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 1008 : 		FS_Printf( f, "//\t\t    opengl.cfg - archive of opengl extension cvars\n");

	push	OFFSET $SG138951
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 8

; 1009 : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138952
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 1010 : 		FS_Printf( f, "\n" );

	push	OFFSET $SG138953
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 8

; 1011 : 		Cmd_WriteOpenGLVariables( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_Cmd_WriteOpenGLVariables
	add	esp, 4

; 1012 : 		FS_Close( f );	

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1013 : 	}                                                

	jmp	SHORT $LN1@Host_Write
$LN2@Host_Write:

; 1014 : 	else Con_DPrintf( S_ERROR "can't update opengl.cfg.\n" );

	push	OFFSET $SG138954
	call	_Con_DPrintf
	add	esp, 4
$LN1@Host_Write:

; 1015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Host_WriteOpenGLConfig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_f$ = -4						; size = 4
_name$ = 8						; size = 4
_Host_WriteServerConfig PROC

; 967  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 968  : 	file_t	*f;
; 969  : 
; 970  : 	SV_InitGameProgs();	// collect user variables

	call	_SV_InitGameProgs

; 971  : 
; 972  : 	// FIXME: move this out until menu parser is done
; 973  : 	CSCR_LoadDefaultCVars( "settings.scr" );

	push	OFFSET $SG138931
	call	_CSCR_LoadDefaultCVars
	add	esp, 4

; 974  : 	
; 975  : 	if(( f = FS_Open( name, "w", false )) != NULL )

	push	0
	push	OFFSET $SG138934
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN2@Host_Write

; 976  : 	{
; 977  : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138935
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 8

; 978  : 		FS_Printf( f, "//\t\t\tCopyright XashXT Group %s \n", Q_timestamp( TIME_YEAR_ONLY ));

	push	4
	call	_Q_timestamp
	add	esp, 4
	push	eax
	push	OFFSET $SG138936
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 979  : 		FS_Printf( f, "//\t\tgame.cfg - multiplayer server temporare config\n" );

	push	OFFSET $SG138937
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 8

; 980  : 		FS_Printf( f, "//=======================================================================\n" );

	push	OFFSET $SG138938
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 8

; 981  : 		Cvar_WriteVariables( f, FCVAR_SERVER );

	push	4
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_Cvar_WriteVariables
	add	esp, 8

; 982  : 		CSCR_WriteGameCVars( f, "settings.scr" );

	push	OFFSET $SG138939
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_CSCR_WriteGameCVars
	add	esp, 8

; 983  : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 984  : 	}

	jmp	SHORT $LN3@Host_Write
$LN2@Host_Write:

; 985  : 	else Con_DPrintf( S_ERROR "Couldn't write %s.\n", name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG138940
	call	_Con_DPrintf
	add	esp, 8
$LN3@Host_Write:

; 986  : 
; 987  : 	SV_FreeGameProgs();	// release progs with all variables

	call	_SV_FreeGameProgs

; 988  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Host_WriteServerConfig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_nummovies$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetMovieList PROC

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 237  : 	search_t		*t;
; 238  : 	string		matchbuf;
; 239  : 	int		i, nummovies;
; 240  : 
; 241  : 	t = FS_Search( va( "media/%s*.avi", s ), true, false );

	push	0
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138464
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 242  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetMov
	xor	eax, eax
	jmp	$LN1@Cmd_GetMov
$LN8@Cmd_GetMov:

; 243  : 
; 244  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 245  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetMov
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetMov

; 246  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetMov:

; 247  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@Cmd_GetMov
	mov	eax, 1
	jmp	$LN1@Cmd_GetMov
$LN10@Cmd_GetMov:

; 248  : 
; 249  : 	for(i = 0, nummovies = 0; i < t->numfilenames; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _nummovies$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetMov
$LN2@Cmd_GetMov:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetMov:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Cmd_GetMov

; 250  : 	{
; 251  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "avi" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138469
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetMov

; 252  : 			continue;

	jmp	SHORT $LN2@Cmd_GetMov
$LN11@Cmd_GetMov:

; 253  : 
; 254  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 255  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138470
	call	_Con_Printf
	add	esp, 8

; 256  : 		nummovies++;

	mov	eax, DWORD PTR _nummovies$[ebp]
	add	eax, 1
	mov	DWORD PTR _nummovies$[ebp], eax

; 257  : 	}

	jmp	$LN2@Cmd_GetMov
$LN3@Cmd_GetMov:

; 258  : 
; 259  : 	Con_Printf( "\n^3 %i movies found.\n", nummovies );

	mov	ecx, DWORD PTR _nummovies$[ebp]
	push	ecx
	push	OFFSET $SG138471
	call	_Con_Printf
	add	esp, 8

; 260  : 	Mem_Free( t );

	push	260					; 00000104H
	push	OFFSET $SG138472
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 261  : 
; 262  : 	// cut shortestMatch to the amount common with s
; 263  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetMov
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetMov

; 264  : 	{
; 265  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetMov
$LN5@Cmd_GetMov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetMov:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@Cmd_GetMov

; 266  : 		{
; 267  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN13@Cmd_GetMov

; 268  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN13@Cmd_GetMov:

; 269  : 		}

	jmp	SHORT $LN5@Cmd_GetMov
$LN12@Cmd_GetMov:

; 270  : 	}
; 271  : 
; 272  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetMov:

; 273  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetMovieList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_numdems$ = -272					; size = 4
_t$ = -268						; size = 4
_i$ = -264						; size = 4
_matchbuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetDemoList PROC

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 190  : 	search_t		*t;
; 191  : 	string		matchbuf;
; 192  : 	int		i, numdems;
; 193  : 
; 194  : 	// lookup only in gamedir
; 195  : 	t = FS_Search( va( "%s*.dem", s ), true, true );

	push	1
	push	1
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG138436
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 196  : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN8@Cmd_GetDem
	xor	eax, eax
	jmp	$LN1@Cmd_GetDem
$LN8@Cmd_GetDem:

; 197  : 
; 198  : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 199  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN9@Cmd_GetDem
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN9@Cmd_GetDem

; 200  : 		Q_strncpy( completedname, matchbuf, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _completedname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetDem:

; 201  : 	if( t->numfilenames == 1 ) return true;

	mov	ecx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN10@Cmd_GetDem
	mov	eax, 1
	jmp	$LN1@Cmd_GetDem
$LN10@Cmd_GetDem:

; 202  : 
; 203  : 	for( i = 0, numdems = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _numdems$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetDem
$LN2@Cmd_GetDem:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@Cmd_GetDem:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Cmd_GetDem

; 204  : 	{
; 205  : 		if( Q_stricmp( COM_FileExtension( t->filenames[i] ), "dem" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138441
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_GetDem

; 206  : 			continue;

	jmp	SHORT $LN2@Cmd_GetDem
$LN11@Cmd_GetDem:

; 207  : 
; 208  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 209  : 		Con_Printf( "%16s\n", matchbuf );

	lea	edx, DWORD PTR _matchbuf$[ebp]
	push	edx
	push	OFFSET $SG138442
	call	_Con_Printf
	add	esp, 8

; 210  : 		numdems++;

	mov	eax, DWORD PTR _numdems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numdems$[ebp], eax

; 211  : 	}

	jmp	$LN2@Cmd_GetDem
$LN3@Cmd_GetDem:

; 212  : 
; 213  : 	Con_Printf( "\n^3 %i demos found.\n", numdems );

	mov	ecx, DWORD PTR _numdems$[ebp]
	push	ecx
	push	OFFSET $SG138443
	call	_Con_Printf
	add	esp, 8

; 214  : 	Mem_Free( t );

	push	214					; 000000d6H
	push	OFFSET $SG138444
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 215  : 
; 216  : 	// cut shortestMatch to the amount common with s
; 217  : 	if( completedname && length )

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN12@Cmd_GetDem
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN12@Cmd_GetDem

; 218  : 	{
; 219  : 		for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cmd_GetDem
$LN5@Cmd_GetDem:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Cmd_GetDem:
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@Cmd_GetDem

; 220  : 		{
; 221  : 			if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	eax, DWORD PTR _completedname$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _matchbuf$[ebp+edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN13@Cmd_GetDem

; 222  : 				completedname[i] = 0;

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx], 0
$LN13@Cmd_GetDem:

; 223  : 		}

	jmp	SHORT $LN5@Cmd_GetDem
$LN12@Cmd_GetDem:

; 224  : 	}
; 225  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetDem:

; 226  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetDemoList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\con_utils.c
_TEXT	SEGMENT
_validmap$1 = -4232					; size = 4
_ext$2 = -4228						; size = 4
_version$3 = -4224					; size = 4
$T4 = -4220						; size = 4
_lumpofs$5 = -4216					; size = 4
_hdrext$6 = -4212					; size = 4
_nummaps$ = -4208					; size = 4
tv269 = -4204						; size = 4
tv268 = -4200						; size = 4
_ver$7 = -4196						; size = 4
_lumplen$8 = -4192					; size = 4
_header$9 = -4188					; size = 4
_f$ = -4184						; size = 4
_ents$10 = -4180					; size = 4
_pfile$11 = -4176					; size = 4
_t$ = -4172						; size = 4
_i$ = -4168						; size = 4
_token$12 = -4164					; size = 2048
_compiler$ = -2116					; size = 256
_generator$ = -1860					; size = 256
_buf$ = -1604						; size = 1024
_message$ = -580					; size = 256
_matchbuf$ = -324					; size = 256
_entfilename$13 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_completedname$ = 12					; size = 4
_length$ = 16						; size = 4
_Cmd_GetMapList PROC

; 43   : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4232				; 00001088H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 44   : 	search_t		*t;
; 45   : 	file_t		*f;
; 46   : 	string		message;
; 47   : 	string		compiler;
; 48   : 	string		generator;
; 49   : 	string		matchbuf;
; 50   : 	byte		buf[MAX_SYSPATH]; // 1 kb
; 51   : 	int		i, nummaps;
; 52   : 
; 53   : 	t = FS_Search( va( "maps/%s*.bsp", s ), true, con_gamemaps->value );

	mov	eax, DWORD PTR _con_gamemaps
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	push	1
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET $SG138363
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 54   : 	if( !t ) return false;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN14@Cmd_GetMap
	xor	eax, eax
	jmp	$LN1@Cmd_GetMap
$LN14@Cmd_GetMap:

; 55   : 
; 56   : 	COM_FileBase( t->filenames[0], matchbuf ); 

	lea	eax, DWORD PTR _matchbuf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 57   : 	if( completedname && length ) 

	cmp	DWORD PTR _completedname$[ebp], 0
	je	SHORT $LN15@Cmd_GetMap
	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN15@Cmd_GetMap

; 58   : 		Q_strncpy( completedname, matchbuf, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _completedname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN15@Cmd_GetMap:

; 59   : 	if( t->numfilenames == 1 ) return true;

	mov	eax, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN16@Cmd_GetMap
	mov	eax, 1
	jmp	$LN1@Cmd_GetMap
$LN16@Cmd_GetMap:

; 60   : 
; 61   : 	for( i = 0, nummaps = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _nummaps$[ebp], 0
	jmp	SHORT $LN4@Cmd_GetMap
$LN2@Cmd_GetMap:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@Cmd_GetMap:
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN3@Cmd_GetMap

; 62   : 	{
; 63   : 		char		entfilename[MAX_QPATH];
; 64   : 		const char	*ext = COM_FileExtension( t->filenames[i] ); 

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$2[ebp], eax

; 65   : 		int		ver = -1, lumpofs = 0, lumplen = 0;

	mov	DWORD PTR _ver$7[ebp], -1
	mov	DWORD PTR _lumpofs$5[ebp], 0
	mov	DWORD PTR _lumplen$8[ebp], 0

; 66   : 		char		*ents = NULL, *pfile;

	mov	DWORD PTR _ents$10[ebp], 0

; 67   : 		qboolean		validmap = false;

	mov	DWORD PTR _validmap$1[ebp], 0

; 68   : 		int		version = 0;

	mov	DWORD PTR _version$3[ebp], 0

; 69   : 
; 70   : 		if( Q_stricmp( ext, "bsp" )) continue;

	push	99999					; 0001869fH
	push	OFFSET $SG138368
	mov	edx, DWORD PTR _ext$2[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@Cmd_GetMap
	jmp	$LN2@Cmd_GetMap
$LN17@Cmd_GetMap:

; 71   : 		Q_strncpy( message, "^1error^7", sizeof( message ));

	push	256					; 00000100H
	push	OFFSET $SG138369
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 72   : 		Q_strncpy( compiler, "", sizeof( compiler ));

	push	256					; 00000100H
	push	OFFSET $SG138370
	lea	ecx, DWORD PTR _compiler$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 73   : 		Q_strncpy( generator, "", sizeof( generator ));

	push	256					; 00000100H
	push	OFFSET $SG138371
	lea	edx, DWORD PTR _generator$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 74   : 		f = FS_Open( t->filenames[i], "rb", con_gamemaps->value );

	mov	eax, DWORD PTR _con_gamemaps
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET $SG138372
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 75   : 	
; 76   : 		if( f )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN22@Cmd_GetMap

; 77   : 		{
; 78   : 			dheader_t		*header;
; 79   : 			dextrahdr_t	*hdrext;
; 80   : 
; 81   : 			memset( buf, 0, sizeof( buf ));

	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 82   : 			FS_Read( f, buf, sizeof( buf ));

	push	1024					; 00000400H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 83   : 			header = (dheader_t *)buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _header$9[ebp], eax

; 84   : 			ver = header->version;

	mov	ecx, DWORD PTR _header$9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ver$7[ebp], edx

; 85   : 
; 86   : 			// check all the lumps and some other errors
; 87   : 			if( Mod_TestBmodelLumps( t->filenames[i], buf, true ))

	push	1
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_Mod_TestBmodelLumps
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@Cmd_GetMap

; 88   : 			{
; 89   : 				lumpofs = header->lumps[LUMP_ENTITIES].fileofs;

	mov	edx, 8
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _header$9[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _lumpofs$5[ebp], edx

; 90   : 				lumplen = header->lumps[LUMP_ENTITIES].filelen;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$9[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _lumplen$8[ebp], eax

; 91   : 				ver = header->version;

	mov	ecx, DWORD PTR _header$9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ver$7[ebp], edx
$LN19@Cmd_GetMap:

; 92   : 			}
; 93   : 
; 94   : 			hdrext = (dextrahdr_t *)((byte *)buf + sizeof( dheader_t ));

	lea	eax, DWORD PTR _buf$[ebp+124]
	mov	DWORD PTR _hdrext$6[ebp], eax

; 95   : 			if( hdrext->id == IDEXTRAHEADER ) version = hdrext->version;

	mov	ecx, DWORD PTR _hdrext$6[ebp]
	cmp	DWORD PTR [ecx], 1213415768		; 48534158H
	jne	SHORT $LN20@Cmd_GetMap
	mov	edx, DWORD PTR _hdrext$6[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _version$3[ebp], eax
$LN20@Cmd_GetMap:

; 96   : 
; 97   : 			Q_strncpy( entfilename, t->filenames[i], sizeof( entfilename ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	lea	edx, DWORD PTR _entfilename$13[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 98   : 			COM_StripExtension( entfilename );

	lea	eax, DWORD PTR _entfilename$13[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 99   : 			COM_DefaultExtension( entfilename, ".ent" );

	push	OFFSET $SG138376
	lea	ecx, DWORD PTR _entfilename$13[ebp]
	push	ecx
	call	_COM_DefaultExtension
	add	esp, 8

; 100  : 			ents = FS_LoadFile( entfilename, NULL, true );

	push	1
	push	0
	lea	edx, DWORD PTR _entfilename$13[ebp]
	push	edx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ents$10[ebp], eax

; 101  : 
; 102  : 			if( !ents && lumplen >= 10 )

	cmp	DWORD PTR _ents$10[ebp], 0
	jne	SHORT $LN21@Cmd_GetMap
	cmp	DWORD PTR _lumplen$8[ebp], 10		; 0000000aH
	jl	SHORT $LN21@Cmd_GetMap

; 103  : 			{
; 104  : 				FS_Seek( f, lumpofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _lumpofs$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 105  : 				ents = (char *)Mem_Calloc( host.mempool, lumplen + 1 );

	push	105					; 00000069H
	push	OFFSET $SG138378
	push	1
	mov	edx, DWORD PTR _lumplen$8[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ents$10[ebp], eax

; 106  : 				FS_Read( f, ents, lumplen );

	mov	ecx, DWORD PTR _lumplen$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _ents$10[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
$LN21@Cmd_GetMap:

; 107  : 			}
; 108  : 
; 109  : 			if( ents )

	cmp	DWORD PTR _ents$10[ebp], 0
	je	$LN22@Cmd_GetMap

; 110  : 			{
; 111  : 				// if there are entities to parse, a missing message key just
; 112  : 				// means there is no title, so clear the message string now
; 113  : 				char	token[2048];
; 114  : 
; 115  : 				message[0] = 0; // remove 'error'

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN45@Cmd_GetMap
	jmp	SHORT $LN46@Cmd_GetMap
$LN45@Cmd_GetMap:
	call	___report_rangecheckfailure
$LN46@Cmd_GetMap:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _message$[ebp+eax], 0

; 116  : 				pfile = ents;

	mov	ecx, DWORD PTR _ents$10[ebp]
	mov	DWORD PTR _pfile$11[ebp], ecx
$LN47@Cmd_GetMap:

; 117  : 
; 118  : 				while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	edx, DWORD PTR _token$12[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$11[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$11[ebp], eax
	cmp	DWORD PTR _pfile$11[ebp], 0
	je	$LN6@Cmd_GetMap

; 119  : 				{
; 120  : 					if( !Q_strcmp( token, "{" )) continue;

	push	99999					; 0001869fH
	push	OFFSET $SG138382
	lea	ecx, DWORD PTR _token$12[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@Cmd_GetMap
	jmp	SHORT $LN47@Cmd_GetMap
	jmp	$LN32@Cmd_GetMap
$LN23@Cmd_GetMap:

; 121  : 					else if( !Q_strcmp( token, "}" )) break;

	push	99999					; 0001869fH
	push	OFFSET $SG138385
	lea	edx, DWORD PTR _token$12[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@Cmd_GetMap
	jmp	$LN6@Cmd_GetMap
	jmp	$LN32@Cmd_GetMap
$LN25@Cmd_GetMap:

; 122  : 					else if( !Q_strcmp( token, "message" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138388
	lea	eax, DWORD PTR _token$12[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@Cmd_GetMap

; 123  : 					{
; 124  : 						// get the message contents
; 125  : 						pfile = COM_ParseFile( pfile, message );

	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$11[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$11[ebp], eax

; 126  : 					}

	jmp	$LN32@Cmd_GetMap
$LN27@Cmd_GetMap:

; 127  : 					else if( !Q_strcmp( token, "compiler" ) || !Q_strcmp( token, "_compiler" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138392
	lea	eax, DWORD PTR _token$12[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN31@Cmd_GetMap
	push	99999					; 0001869fH
	push	OFFSET $SG138393
	lea	ecx, DWORD PTR _token$12[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@Cmd_GetMap
$LN31@Cmd_GetMap:

; 128  : 					{
; 129  : 						// get the message contents
; 130  : 						pfile = COM_ParseFile( pfile, compiler );

	lea	edx, DWORD PTR _compiler$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$11[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$11[ebp], eax

; 131  : 					}

	jmp	SHORT $LN32@Cmd_GetMap
$LN29@Cmd_GetMap:

; 132  : 					else if( !Q_strcmp( token, "generator" ) || !Q_strcmp( token, "_generator" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138396
	lea	ecx, DWORD PTR _token$12[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN33@Cmd_GetMap
	push	99999					; 0001869fH
	push	OFFSET $SG138397
	lea	edx, DWORD PTR _token$12[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@Cmd_GetMap
$LN33@Cmd_GetMap:

; 133  : 					{
; 134  : 						// get the message contents
; 135  : 						pfile = COM_ParseFile( pfile, generator );

	lea	eax, DWORD PTR _generator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$11[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$11[ebp], eax
$LN32@Cmd_GetMap:

; 136  : 					}
; 137  : 				}

	jmp	$LN47@Cmd_GetMap
$LN6@Cmd_GetMap:

; 138  : 				Mem_Free( ents );

	push	138					; 0000008aH
	push	OFFSET $SG138398
	mov	edx, DWORD PTR _ents$10[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN22@Cmd_GetMap:

; 139  : 			}
; 140  : 		}
; 141  : 
; 142  : 		if( f ) FS_Close(f);

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN34@Cmd_GetMap
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN34@Cmd_GetMap:

; 143  : 		COM_FileBase( t->filenames[i], matchbuf );

	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 144  : 
; 145  : 		switch( ver )

	mov	eax, DWORD PTR _ver$7[ebp]
	mov	DWORD PTR tv268[ebp], eax
	cmp	DWORD PTR tv268[ebp], 29		; 0000001dH
	je	SHORT $LN35@Cmd_GetMap
	cmp	DWORD PTR tv268[ebp], 30		; 0000001eH
	je	SHORT $LN37@Cmd_GetMap
	cmp	DWORD PTR tv268[ebp], 844124994		; 32505342H
	je	SHORT $LN36@Cmd_GetMap
	jmp	$LN42@Cmd_GetMap
$LN35@Cmd_GetMap:

; 146  : 		{
; 147  : 		case Q1BSP_VERSION:
; 148  : 			Q_strncpy( buf, "Quake", sizeof( buf ));

	push	1024					; 00000400H
	push	OFFSET $SG138401
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 149  : 			break;

	jmp	$LN7@Cmd_GetMap
$LN36@Cmd_GetMap:

; 150  : 		case QBSP2_VERSION:
; 151  : 			Q_strncpy( buf, "Darkplaces BSP2", sizeof( buf ));

	push	1024					; 00000400H
	push	OFFSET $SG138403
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 152  : 			break;

	jmp	$LN7@Cmd_GetMap
$LN37@Cmd_GetMap:

; 153  : 		case HLBSP_VERSION:
; 154  : 			switch( version )

	mov	eax, DWORD PTR _version$3[ebp]
	mov	DWORD PTR tv269[ebp], eax
	cmp	DWORD PTR tv269[ebp], 1
	je	SHORT $LN38@Cmd_GetMap
	cmp	DWORD PTR tv269[ebp], 2
	je	SHORT $LN39@Cmd_GetMap
	cmp	DWORD PTR tv269[ebp], 4
	je	SHORT $LN40@Cmd_GetMap
	jmp	SHORT $LN41@Cmd_GetMap
$LN38@Cmd_GetMap:

; 155  : 			{
; 156  : 			case 1: Q_strncpy( buf, "XashXT old format", sizeof( buf )); break;

	push	1024					; 00000400H
	push	OFFSET $SG138406
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Cmd_GetMap
$LN39@Cmd_GetMap:

; 157  : 			case 2: Q_strncpy( buf, "Paranoia 2: Savior", sizeof( buf )); break;

	push	1024					; 00000400H
	push	OFFSET $SG138408
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Cmd_GetMap
$LN40@Cmd_GetMap:

; 158  : 			case 4: Q_strncpy( buf, "Half-Life extended", sizeof( buf )); break;

	push	1024					; 00000400H
	push	OFFSET $SG138410
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Cmd_GetMap
$LN41@Cmd_GetMap:

; 159  : 			default: Q_strncpy( buf, "Half-Life", sizeof( buf )); break;

	push	1024					; 00000400H
	push	OFFSET $SG138412
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@Cmd_GetMap:

; 160  : 			}
; 161  : 			break;

	jmp	SHORT $LN7@Cmd_GetMap
$LN42@Cmd_GetMap:

; 162  : 		default:	Q_strncpy( buf, "??", sizeof( buf )); break;

	push	1024					; 00000400H
	push	OFFSET $SG138414
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN7@Cmd_GetMap:

; 163  : 		}
; 164  : 
; 165  : 		Con_Printf( "%16s (%s) ^3%s^7 ^2%s %s^7\n", matchbuf, buf, message, compiler, generator );

	lea	eax, DWORD PTR _generator$[ebp]
	push	eax
	lea	ecx, DWORD PTR _compiler$[ebp]
	push	ecx
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matchbuf$[ebp]
	push	ecx
	push	OFFSET $SG138415
	call	_Con_Printf
	add	esp, 24					; 00000018H

; 166  : 		nummaps++;

	mov	edx, DWORD PTR _nummaps$[ebp]
	add	edx, 1
	mov	DWORD PTR _nummaps$[ebp], edx

; 167  : 	}

	jmp	$LN2@Cmd_GetMap
$LN3@Cmd_GetMap:

; 168  : 
; 169  : 	Con_Printf( "\n^3 %i maps found.\n", nummaps );

	mov	eax, DWORD PTR _nummaps$[ebp]
	push	eax
	push	OFFSET $SG138416
	call	_Con_Printf
	add	esp, 8

; 170  : 	Mem_Free( t );

	push	170					; 000000aaH
	push	OFFSET $SG138417
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 171  : 
; 172  : 	// cut shortestMatch to the amount common with s
; 173  : 	for( i = 0; matchbuf[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Cmd_GetMap
$LN11@Cmd_GetMap:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@Cmd_GetMap:
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _matchbuf$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN12@Cmd_GetMap

; 174  : 	{
; 175  : 		if( Q_tolower( completedname[i] ) != Q_tolower( matchbuf[i] ))

	mov	edx, DWORD PTR _completedname$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	esi, al
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR _matchbuf$[ebp+ecx]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	eax, al
	cmp	esi, eax
	je	SHORT $LN43@Cmd_GetMap

; 176  : 			completedname[i] = 0;

	mov	ecx, DWORD PTR _completedname$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], 0
$LN43@Cmd_GetMap:

; 177  : 	}

	jmp	SHORT $LN11@Cmd_GetMap
$LN12@Cmd_GetMap:

; 178  : 	return true;

	mov	eax, 1
$LN1@Cmd_GetMap:

; 179  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_GetMapList ENDP
_TEXT	ENDS
END
