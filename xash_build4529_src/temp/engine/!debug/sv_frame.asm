; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\server\sv_frame.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_c_fullsend:DWORD
COMM	_c_notsend:DWORD
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetName
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetNumBytesLeft
PUBLIC	_MSG_GetData
PUBLIC	_MSG_GetBuf
PUBLIC	_SV_SendClientMessages
PUBLIC	_SV_InactivateClients
PUBLIC	_SV_FindBestBaselineForStatic
PUBLIC	_SV_SendMessagesToAll
PUBLIC	_SV_SkipUpdates
PUBLIC	_SV_FindBestBaseline
PUBLIC	_SV_EmitPings
PUBLIC	_SV_WriteClientdataToMessage
PUBLIC	_SV_WriteEntitiesToClient
PUBLIC	_SV_SendClientDatagram
PUBLIC	_SV_UpdateUserInfo
PUBLIC	_SV_UpdateToReliableMessages
PUBLIC	__real@00000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@42c80000
PUBLIC	__real@bf800000
EXTRN	_memcmp:PROC
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_SV_BroadcastPrintf:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteBitAngle:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteFloat:PROC
EXTRN	_MSG_WriteVec3Angles:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_TransmitBits:PROC
EXTRN	_Netchan_CanPacket:PROC
EXTRN	_SV_FinalMessage:PROC
EXTRN	_SV_DropClient:PROC
EXTRN	_SV_ShouldUpdatePing:PROC
EXTRN	_SV_FullClientUpdate:PROC
EXTRN	_SV_FullUpdateMovevars:PROC
EXTRN	_SV_GetPlayerStats:PROC
EXTRN	_SV_IsPlayerIndex:PROC
EXTRN	_SV_ClassName:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_ClientFromEdict:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_MSG_WriteDeltaEvent:PROC
EXTRN	_MSG_WriteClientData:PROC
EXTRN	_MSG_WriteWeaponData:PROC
EXTRN	_MSG_WriteDeltaEntity:PROC
EXTRN	_Delta_TestBaseline:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host_limitlocal:DWORD
EXTRN	_host:BYTE
EXTRN	_SV_UPDATE_BACKUP:DWORD
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_instancedbaseline:BYTE
EXTRN	_sv_failuretime:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?frame_ents@?1??SV_WriteEntitiesToClient@@9@9 DB 0aa404H DUP (?) ; `SV_WriteEntitiesToClient'::`2'::frame_ents
_BSS	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG136324 DB	'SV_SortEntities: duplicated entity', 0aH, 00H
$SG136466 DB	'^3Warning:^7 %s: delta request from out of date entities'
	DB	'.', 0aH, 00H
	ORG $+1
$SG136360 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_frame.c', 00H
	ORG $+3
$SG136361 DB	'assert failed at %s:%i', 0aH, 00H
$SG136376 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_frame.c', 00H
	ORG $+3
$SG136596 DB	'^1Error:^7 Too many entities in visible packet list. Ign'
	DB	'ored %d entities', 0aH, 00H
	ORG $+2
$SG136598 DB	'Server will restart due delta is outdated', 0aH, 00H
	ORG $+1
$SG136607 DB	'Datagram', 00H
	ORG $+3
$SG136610 DB	'^3Warning:^7 %s overflowed for %s', 0aH, 00H
	ORG $+1
$SG136613 DB	'^3Warning:^7 Ignoring unreliable datagram for %s, would '
	DB	'overflow on msg', 0aH, 00H
	ORG $+3
$SG136615 DB	'^1Error:^7 %s overflowed for %s', 0aH, 00H
	ORG $+3
$SG136637 DB	'^1Error:^7 sv.datagram overflowed!', 0aH, 00H
$SG136639 DB	'^1Error:^7 sv.spec_datagram overflowed!', 0aH, 00H
	ORG $+3
$SG136646 DB	'^3Warning:^7 Ignoring unreliable datagram for %s, would '
	DB	'overflow', 0aH, 00H
	ORG $+6
$SG136650 DB	'^3Warning:^7 Ignoring spectator datagram for %s, would o'
	DB	'verflow', 0aH, 00H
	ORG $+3
$SG136670 DB	'%s overflowed', 0aH, 00H
	ORG $+1
$SG136671 DB	'^1Error:^7 reliable overflow for %s', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_UpdateToReliableMessages PROC

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 767  : 	sv_client_t	*cl;
; 768  : 	int		i;
; 769  : 
; 770  : 	// check for changes to be sent over the reliable streams to all clients
; 771  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_UpdateT
$LN2@SV_UpdateT:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_UpdateT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_UpdateT

; 772  : 	{
; 773  : 		if( !cl->edict ) continue;	// not in game yet

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx+264980], 0
	jne	SHORT $LN8@SV_UpdateT
	jmp	SHORT $LN2@SV_UpdateT
$LN8@SV_UpdateT:

; 774  : 
; 775  : 		if( cl->state != cs_spawned )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	je	SHORT $LN9@SV_UpdateT

; 776  : 			continue;

	jmp	SHORT $LN2@SV_UpdateT
$LN9@SV_UpdateT:

; 777  : 
; 778  : 		if( FBitSet( cl->flags, FCL_RESEND_USERINFO ) && cl->next_sendinfotime <= host.realtime )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 1
	je	SHORT $LN11@SV_UpdateT
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [edx+264384]
	jb	SHORT $LN11@SV_UpdateT

; 779  : 		{
; 780  : 			if( MSG_GetNumBytesLeft( &sv.reliable_datagram ) >= ( Q_strlen( cl->userinfo ) + 6 ))

	push	OFFSET _sv+1195756
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 6
	cmp	esi, eax
	jl	SHORT $LN11@SV_UpdateT

; 781  : 				SV_UpdateUserInfo( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_UpdateUserInfo
	add	esp, 4
$LN11@SV_UpdateT:

; 782  : 		}
; 783  : 
; 784  : 		if( FBitSet( cl->flags, FCL_RESEND_MOVEVARS ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 2
	je	SHORT $LN12@SV_UpdateT

; 785  : 		{
; 786  : 			SV_FullUpdateMovevars( cl, &cl->netchan.message );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_FullUpdateMovevars
	add	esp, 8

; 787  : 			ClearBits( cl->flags, FCL_RESEND_MOVEVARS );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN12@SV_UpdateT:

; 788  : 		}
; 789  : 	}

	jmp	$LN2@SV_UpdateT
$LN3@SV_UpdateT:

; 790  : 
; 791  : 	// clear the server datagram if it overflowed.
; 792  : 	if( MSG_CheckOverflow( &sv.datagram ))

	push	OFFSET _sv+1179352
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@SV_UpdateT

; 793  : 	{
; 794  : 		Con_DPrintf( S_ERROR "sv.datagram overflowed!\n" );

	push	OFFSET $SG136637
	call	_Con_DPrintf
	add	esp, 4

; 795  : 		MSG_Clear( &sv.datagram );

	push	OFFSET _sv+1179352
	call	_MSG_Clear
	add	esp, 4
$LN13@SV_UpdateT:

; 796  : 	}
; 797  : 
; 798  : 	// clear the server datagram if it overflowed.
; 799  : 	if( MSG_CheckOverflow( &sv.spec_datagram ))

	push	OFFSET _sv+1351464
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@SV_UpdateT

; 800  : 	{
; 801  : 		Con_DPrintf( S_ERROR "sv.spec_datagram overflowed!\n" );

	push	OFFSET $SG136639
	call	_Con_DPrintf
	add	esp, 4

; 802  : 		MSG_Clear( &sv.spec_datagram );

	push	OFFSET _sv+1351464
	call	_MSG_Clear
	add	esp, 4
$LN14@SV_UpdateT:

; 803  : 	}
; 804  : 
; 805  : 	// now send the reliable and server datagrams to all clients.
; 806  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN7@SV_UpdateT
$LN5@SV_UpdateT:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN7@SV_UpdateT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN6@SV_UpdateT

; 807  : 	{
; 808  : 		if( cl->state < cs_connected || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN16@SV_UpdateT
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN15@SV_UpdateT
$LN16@SV_UpdateT:

; 809  : 			continue;	// reliables go to all connected or spawned

	jmp	SHORT $LN5@SV_UpdateT
$LN15@SV_UpdateT:

; 810  : 
; 811  : 		if( MSG_GetNumBytesWritten( &sv.reliable_datagram ) < MSG_GetNumBytesLeft( &cl->netchan.message ))

	push	OFFSET _sv+1195756
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN17@SV_UpdateT

; 812  : 			MSG_WriteBits( &cl->netchan.message, MSG_GetBuf( &sv.reliable_datagram ), MSG_GetNumBitsWritten( &sv.reliable_datagram ));

	push	OFFSET _sv+1195756
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1195756
	call	_MSG_GetBuf
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@SV_UpdateT
$LN17@SV_UpdateT:

; 813  : 		else Netchan_CreateFragments( &cl->netchan, &sv.reliable_datagram );

	push	OFFSET _sv+1195756
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_CreateFragments
	add	esp, 8
$LN18@SV_UpdateT:

; 814  : 
; 815  : 		if( MSG_GetNumBytesWritten( &sv.datagram ) < MSG_GetNumBytesLeft( &cl->datagram ))

	push	OFFSET _sv+1179352
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN19@SV_UpdateT

; 816  : 			MSG_WriteBits( &cl->datagram, MSG_GetBuf( &sv.datagram ), MSG_GetNumBitsWritten( &sv.datagram ));

	push	OFFSET _sv+1179352
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1179352
	call	_MSG_GetBuf
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 265512				; 00040d28H
	push	edx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN20@SV_UpdateT
$LN19@SV_UpdateT:

; 817  : 		else Con_DPrintf( S_WARN "Ignoring unreliable datagram for %s, would overflow\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG136646
	call	_Con_DPrintf
	add	esp, 8
$LN20@SV_UpdateT:

; 818  : 
; 819  : 		if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 256				; 00000100H
	je	SHORT $LN23@SV_UpdateT

; 820  : 		{
; 821  : 			if( MSG_GetNumBytesWritten( &sv.spec_datagram ) < MSG_GetNumBytesLeft( &cl->datagram ))

	push	OFFSET _sv+1351464
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 265512				; 00040d28H
	push	eax
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN22@SV_UpdateT

; 822  : 				MSG_WriteBits( &cl->datagram, MSG_GetBuf( &sv.spec_datagram ), MSG_GetNumBitsWritten( &sv.spec_datagram ));

	push	OFFSET _sv+1351464
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+1351464
	call	_MSG_GetBuf
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN23@SV_UpdateT
$LN22@SV_UpdateT:

; 823  : 			else Con_DPrintf( S_WARN "Ignoring spectator datagram for %s, would overflow\n", cl->name );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG136650
	call	_Con_DPrintf
	add	esp, 8
$LN23@SV_UpdateT:

; 824  : 		}
; 825  : 	}

	jmp	$LN5@SV_UpdateT
$LN6@SV_UpdateT:

; 826  : 
; 827  : 	// now clear the reliable and datagram buffers.
; 828  : 	MSG_Clear( &sv.reliable_datagram );

	push	OFFSET _sv+1195756
	call	_MSG_Clear
	add	esp, 4

; 829  : 	MSG_Clear( &sv.spec_datagram );

	push	OFFSET _sv+1351464
	call	_MSG_Clear
	add	esp, 4

; 830  : 	MSG_Clear( &sv.datagram );

	push	OFFSET _sv+1179352
	call	_MSG_Clear
	add	esp, 4

; 831  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UpdateToReliableMessages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_UpdateUserInfo PROC

; 754  : {

	push	ebp
	mov	ebp, esp

; 755  : 	SV_FullClientUpdate( cl, &sv.reliable_datagram );

	push	OFFSET _sv+1195756
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_FullClientUpdate
	add	esp, 8

; 756  : 	ClearBits( cl->flags, FCL_RESEND_USERINFO );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx

; 757  : 	cl->next_sendinfotime = host.realtime + 1.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [ecx+264384], xmm0

; 758  : }

	pop	ebp
	ret	0
_SV_UpdateUserInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_msg$ = -16408						; size = 20
_msg_buf$ = -16388					; size = 16384
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_SendClientDatagram PROC

; 709  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 16408				; 00004018H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 710  : 	byte	msg_buf[MAX_DATAGRAM];
; 711  : 	sizebuf_t	msg;
; 712  : 
; 713  : 	MSG_Init( &msg, "Datagram", msg_buf, sizeof( msg_buf ));

	push	-1
	push	16384					; 00004000H
	lea	eax, DWORD PTR _msg_buf$[ebp]
	push	eax
	push	OFFSET $SG136607
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 714  : 
; 715  : 	// always send servertime at new frame
; 716  : 	MSG_BeginServerCmd( &msg, svc_time );

	push	0
	push	1
	push	7
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 717  : 	MSG_WriteFloat( &msg, sv.time );

	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteFloat
	add	esp, 8

; 718  : 
; 719  : 	SV_WriteClientdataToMessage( cl, &msg );

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_WriteClientdataToMessage
	add	esp, 8

; 720  : 	SV_WriteEntitiesToClient( cl, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_WriteEntitiesToClient
	add	esp, 8

; 721  : 
; 722  : 	// copy the accumulated multicast datagram
; 723  : 	// for this client out to the message
; 724  : 	if( MSG_CheckOverflow( &cl->datagram ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 265512				; 00040d28H
	push	edx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SV_SendCli

; 725  : 	{
; 726  : 		Con_Printf( S_WARN "%s overflowed for %s\n", MSG_GetName( &cl->datagram ), cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_GetName
	add	esp, 4
	push	eax
	push	OFFSET $SG136610
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 727  : 	}

	jmp	SHORT $LN5@SV_SendCli
$LN2@SV_SendCli:

; 728  : 	else
; 729  : 	{
; 730  : 		if( MSG_GetNumBytesWritten( &cl->datagram ) < MSG_GetNumBytesLeft( &msg ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 265512				; 00040d28H
	push	edx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	esi, eax
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN4@SV_SendCli

; 731  : 			MSG_WriteBits( &msg, MSG_GetData( &cl->datagram ), MSG_GetNumBitsWritten( &cl->datagram ));

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 265512				; 00040d28H
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@SV_SendCli
$LN4@SV_SendCli:

; 732  : 		else Con_DPrintf( S_WARN "Ignoring unreliable datagram for %s, would overflow on msg\n", cl->name );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG136613
	call	_Con_DPrintf
	add	esp, 8
$LN5@SV_SendCli:

; 733  : 	}
; 734  : 
; 735  : 	MSG_Clear( &cl->datagram );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 265512				; 00040d28H
	push	edx
	call	_MSG_Clear
	add	esp, 4

; 736  : 
; 737  : 	if( MSG_CheckOverflow( &msg ))

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@SV_SendCli

; 738  : 	{	
; 739  : 		// must have room left for the packet header
; 740  : 		Con_Printf( S_ERROR "%s overflowed for %s\n", MSG_GetName( &msg ), cl->name );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetName
	add	esp, 4
	push	eax
	push	OFFSET $SG136615
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 741  : 		MSG_Clear( &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4
$LN6@SV_SendCli:

; 742  : 	}
; 743  : 
; 744  : 	// send the datagram
; 745  : 	Netchan_TransmitBits( &cl->netchan, MSG_GetNumBitsWritten( &msg ), MSG_GetData( &msg ));

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 746  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendClientDatagram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_send_pings$ = -16					; size = 4
_state$ = -12						; size = 4
_i$ = -8						; size = 4
_frame$ = -4						; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_WriteEntitiesToClient PROC

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi

; 638  : 	client_frame_t	*frame;
; 639  : 	entity_state_t	*state;
; 640  : 	static sv_ents_t	frame_ents;
; 641  : 	int		i, send_pings;
; 642  : 
; 643  : 	frame = &cl->frames[cl->netchan.outgoing_sequence & SV_UPDATE_MASK];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	and	eax, DWORD PTR [ecx+640]
	imul	edx, eax, 6128
	mov	eax, DWORD PTR _cl$[ebp]
	add	edx, DWORD PTR [eax+281916]
	mov	DWORD PTR _frame$[ebp], edx

; 644  : 	send_pings = SV_ShouldUpdatePing( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ShouldUpdatePing
	add	esp, 4
	mov	DWORD PTR _send_pings$[ebp], eax

; 645  : 
; 646  : 	memset( frame_ents.sended, 0, sizeof( frame_ents.sended ));

	push	1024					; 00000400H
	push	0
	push	OFFSET ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9+696324
	call	_memset
	add	esp, 12					; 0000000cH

; 647  : 	ClearBits( sv.hostflags, SVF_MERGE_VISIBILITY );

	mov	edx, DWORD PTR _sv+44
	and	edx, -3					; fffffffdH
	mov	DWORD PTR _sv+44, edx

; 648  : 
; 649  : 	// clear everything in this snapshot
; 650  : 	frame_ents.num_entities = c_fullsend = c_notsend = 0;

	mov	DWORD PTR _c_notsend, 0
	mov	eax, DWORD PTR _c_notsend
	mov	DWORD PTR _c_fullsend, eax
	mov	ecx, DWORD PTR _c_fullsend
	mov	DWORD PTR ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9, ecx

; 651  : 
; 652  : 	// add all the entities directly visible to the eye, which
; 653  : 	// may include portal entities that merge other viewpoints
; 654  : 	SV_AddEntitiesToPacket( cl->pViewEntity, cl->edict, frame, &frame_ents, true );

	push	1
	push	OFFSET ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9
	mov	edx, DWORD PTR _frame$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264984]
	push	eax
	call	_SV_AddEntitiesToPacket
	add	esp, 20					; 00000014H

; 655  : 
; 656  : 	if( c_notsend != cl->ignored_ents )

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR _c_notsend
	cmp	edx, DWORD PTR [ecx+264976]
	je	SHORT $LN5@SV_WriteEn

; 657  : 	{
; 658  : 		if( c_notsend > 0 )

	cmp	DWORD PTR _c_notsend, 0
	jle	SHORT $LN6@SV_WriteEn

; 659  : 			Con_Printf( S_ERROR "Too many entities in visible packet list. Ignored %d entities\n", c_notsend );

	mov	eax, DWORD PTR _c_notsend
	push	eax
	push	OFFSET $SG136596
	call	_Con_Printf
	add	esp, 8
$LN6@SV_WriteEn:

; 660  : 		cl->ignored_ents = c_notsend;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR _c_notsend
	mov	DWORD PTR [ecx+264976], edx
$LN5@SV_WriteEn:

; 661  : 	}
; 662  : 
; 663  : 	// if there were portals visible, there may be out of order entities
; 664  : 	// in the list which will need to be resorted for the delta compression
; 665  : 	// to work correctly.  This also catches the error condition
; 666  : 	// of an entity being included twice.
; 667  : 	qsort( frame_ents.entities, frame_ents.num_entities, sizeof( frame_ents.entities[0] ), SV_EntityNumbers );

	push	OFFSET _SV_EntityNumbers
	push	340					; 00000154H
	mov	eax, DWORD PTR ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9
	push	eax
	push	OFFSET ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9+4
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 668  : 
; 669  : 	// it will break all connected clients, but it takes more than one week to overflow it
; 670  : 	if(( (uint)svs.next_client_entities ) + frame_ents.num_entities >= 0x7FFFFFFE )

	mov	ecx, DWORD PTR _svs+33352
	add	ecx, DWORD PTR ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9
	cmp	ecx, 2147483646				; 7ffffffeH
	jb	SHORT $LN7@SV_WriteEn

; 671  : 	{
; 672  : 		svs.next_client_entities = 0;

	mov	DWORD PTR _svs+33352, 0

; 673  : 
; 674  : 		// delta is broken for now, cannot keep connected clients
; 675  : 		SV_FinalMessage( "Server will restart due delta is outdated\n", true );

	push	1
	push	OFFSET $SG136598
	call	_SV_FinalMessage
	add	esp, 8
$LN7@SV_WriteEn:

; 676  : 	}
; 677  : 
; 678  : 	// copy the entity states out
; 679  : 	frame->first_entity = svs.next_client_entities;

	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR _svs+33352
	mov	DWORD PTR [edx+6124], eax

; 680  : 	frame->num_entities = 0;

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+6120], 0

; 681  : 
; 682  : 	for( i = 0; i < frame_ents.num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_WriteEn
$LN2@SV_WriteEn:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_WriteEn:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9
	jge	SHORT $LN3@SV_WriteEn

; 683  : 	{
; 684  : 		// add it to the circular packet_entities array
; 685  : 		state = &svs.packet_entities[svs.next_client_entities % svs.num_client_entities];

	mov	eax, DWORD PTR _svs+33352
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], ecx

; 686  : 		*state = frame_ents.entities[i];

	imul	esi, DWORD PTR _i$[ebp], 340
	add	esi, OFFSET ?frame_ents@?1??SV_WriteEntitiesToClient@@9@9+4
	mov	ecx, 85					; 00000055H
	mov	edi, DWORD PTR _state$[ebp]
	rep movsd

; 687  : 		svs.next_client_entities++;

	mov	edx, DWORD PTR _svs+33352
	add	edx, 1
	mov	DWORD PTR _svs+33352, edx

; 688  : 		frame->num_entities++;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+6120]
	add	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+6120], ecx

; 689  : 	}

	jmp	SHORT $LN2@SV_WriteEn
$LN3@SV_WriteEn:

; 690  : 
; 691  : 	SV_EmitPacketEntities( cl, frame, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_EmitPacketEntities
	add	esp, 12					; 0000000cH

; 692  : 	SV_EmitEvents( cl, frame, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_EmitEvents
	add	esp, 12					; 0000000cH

; 693  : 	if( send_pings ) SV_EmitPings( msg );

	cmp	DWORD PTR _send_pings$[ebp], 0
	je	SHORT $LN1@SV_WriteEn
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SV_EmitPings
	add	esp, 4
$LN1@SV_WriteEn:

; 694  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WriteEntitiesToClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_to_wd$ = -600						; size = 4
_to_cd$ = -596						; size = 4
_from_wd$ = -592					; size = 4
_from_cd$ = -588					; size = 4
tv84 = -584						; size = 4
_i$ = -580						; size = 4
_frame$ = -576						; size = 4
_clent$ = -572						; size = 4
_nullcd$ = -568						; size = 476
_nullwd$ = -92						; size = 88
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_WriteClientdataToMessage PROC

; 550  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 600				; 00000258H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 551  : 	clientdata_t	nullcd;
; 552  : 	clientdata_t	*from_cd, *to_cd;
; 553  : 	weapon_data_t	nullwd;
; 554  : 	weapon_data_t	*from_wd, *to_wd;
; 555  : 	client_frame_t	*frame;
; 556  : 	edict_t		*clent;
; 557  : 	int		i;
; 558  : 
; 559  : 	memset( &nullcd, 0, sizeof( nullcd ));

	push	476					; 000001dcH
	push	0
	lea	eax, DWORD PTR _nullcd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 560  : 	frame = &cl->frames[cl->netchan.outgoing_sequence & SV_UPDATE_MASK];

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	and	ecx, DWORD PTR [edx+640]
	imul	eax, ecx, 6128
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+281916]
	mov	DWORD PTR _frame$[ebp], eax

; 561  : 	frame->senttime = host.realtime;

	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [edx], xmm0

; 562  : 	frame->ping_time = -1.0f;

	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+8], xmm0

; 563  : 	clent = cl->edict;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	DWORD PTR _clent$[ebp], edx

; 564  : 
; 565  : 	if( cl->chokecount != 0 )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264360], 0
	je	SHORT $LN7@SV_WriteCl

; 566  : 	{
; 567  : 		MSG_BeginServerCmd( msg, svc_choke );

	push	0
	push	1
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 568  : 		cl->chokecount = 0;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+264360], 0
$LN7@SV_WriteCl:

; 569  : 	}
; 570  : 
; 571  : 	// update client fixangle
; 572  : 	switch( clent->v.fixangle )

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 1
	je	SHORT $LN8@SV_WriteCl
	cmp	DWORD PTR tv84[ebp], 2
	je	SHORT $LN9@SV_WriteCl
	jmp	$LN2@SV_WriteCl
$LN8@SV_WriteCl:

; 573  : 	{
; 574  : 	case 1:
; 575  : 		MSG_BeginServerCmd( msg, svc_setangle );

	push	0
	push	1
	push	10					; 0000000aH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 576  : 		MSG_WriteVec3Angles( msg, clent->v.angles );

	mov	eax, DWORD PTR _clent$[ebp]
	add	eax, 208				; 000000d0H
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteVec3Angles
	add	esp, 8

; 577  : 		break;

	jmp	SHORT $LN2@SV_WriteCl
$LN9@SV_WriteCl:

; 578  : 	case 2:
; 579  : 		MSG_BeginServerCmd( msg, svc_addangle );

	push	0
	push	1
	push	38					; 00000026H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 580  : 		MSG_WriteBitAngle( msg, clent->v.avelocity[YAW], 16 );

	push	16					; 00000010H
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+220]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 581  : 		clent->v.avelocity[YAW] = 0.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+220], xmm0
$LN2@SV_WriteCl:

; 582  : 		break;
; 583  : 	}
; 584  : 
; 585  : 	clent->v.fixangle = 0; // reset fixangle

	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+288], 0

; 586  : 
; 587  : 	memset( &frame->clientdata, 0, sizeof( frame->clientdata ));

	push	476					; 000001dcH
	push	0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 588  : 
; 589  : 	// update clientdata_t
; 590  : 	svgame.dllFuncs.pfnUpdateClientData( clent, FBitSet( cl->flags, FCL_LOCAL_WEAPONS ), &frame->clientdata );

	mov	ecx, DWORD PTR _frame$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19392
	add	esp, 12					; 0000000cH

; 591  : 
; 592  : 	MSG_BeginServerCmd( msg, svc_clientdata );

	push	0
	push	1
	push	15					; 0000000fH
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 593  : 	if( FBitSet( cl->flags, FCL_HLTV_PROXY )) return;	// don't send more nothing

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	je	SHORT $LN10@SV_WriteCl
	jmp	$LN1@SV_WriteCl
$LN10@SV_WriteCl:

; 594  : 
; 595  : 	if( cl->delta_sequence == -1 ) from_cd = &nullcd;

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+264364], -1
	jne	SHORT $LN11@SV_WriteCl
	lea	eax, DWORD PTR _nullcd$[ebp]
	mov	DWORD PTR _from_cd$[ebp], eax
	jmp	SHORT $LN12@SV_WriteCl
$LN11@SV_WriteCl:

; 596  : 	else from_cd = &cl->frames[cl->delta_sequence & SV_UPDATE_MASK].clientdata;

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	and	ecx, DWORD PTR [edx+264364]
	imul	eax, ecx, 6128
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+281916]
	lea	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR _from_cd$[ebp], eax
$LN12@SV_WriteCl:

; 597  : 	to_cd = &frame->clientdata;

	mov	ecx, DWORD PTR _frame$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _to_cd$[ebp], ecx

; 598  : 
; 599  : 	if( cl->delta_sequence == -1 )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+264364], -1
	jne	SHORT $LN13@SV_WriteCl

; 600  : 	{
; 601  : 		MSG_WriteOneBit( msg, 0 );	// no delta-compression

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 602  : 	}

	jmp	SHORT $LN14@SV_WriteCl
$LN13@SV_WriteCl:

; 603  : 	else
; 604  : 	{
; 605  : 		MSG_WriteOneBit( msg, 1 );	// we are delta-ing from

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 606  : 		MSG_WriteByte( msg, cl->delta_sequence );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264364]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8
$LN14@SV_WriteCl:

; 607  : 	}
; 608  : 
; 609  : 	// write clientdata_t
; 610  : 	MSG_WriteClientData( msg, from_cd, to_cd, sv.time );

	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _to_cd$[ebp]
	push	edx
	mov	eax, DWORD PTR _from_cd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteClientData
	add	esp, 16					; 00000010H

; 611  : 
; 612  : 	if( FBitSet( cl->flags, FCL_LOCAL_WEAPONS ) && svgame.dllFuncs.pfnGetWeaponData( clent, frame->weapondata ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 32					; 00000020H
	je	$LN5@SV_WriteCl
	mov	ecx, DWORD PTR _frame$[ebp]
	add	ecx, 488				; 000001e8H
	push	ecx
	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19408
	add	esp, 8
	test	eax, eax
	je	$LN5@SV_WriteCl

; 613  : 	{
; 614  : 		memset( &nullwd, 0, sizeof( nullwd ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _nullwd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 615  : 
; 616  : 		for( i = 0; i < MAX_LOCAL_WEAPONS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SV_WriteCl
$LN4@SV_WriteCl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@SV_WriteCl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN5@SV_WriteCl

; 617  : 		{
; 618  : 			if( cl->delta_sequence == -1 ) from_wd = &nullwd;

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+264364], -1
	jne	SHORT $LN16@SV_WriteCl
	lea	eax, DWORD PTR _nullwd$[ebp]
	mov	DWORD PTR _from_wd$[ebp], eax
	jmp	SHORT $LN17@SV_WriteCl
$LN16@SV_WriteCl:

; 619  : 			else from_wd = &cl->frames[cl->delta_sequence & SV_UPDATE_MASK].weapondata[i];

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	and	ecx, DWORD PTR [edx+264364]
	imul	eax, ecx, 6128
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+281916]
	add	edx, eax
	imul	eax, DWORD PTR _i$[ebp], 88
	lea	ecx, DWORD PTR [edx+eax+488]
	mov	DWORD PTR _from_wd$[ebp], ecx
$LN17@SV_WriteCl:

; 620  : 			to_wd = &frame->weapondata[i];

	imul	edx, DWORD PTR _i$[ebp], 88
	mov	eax, DWORD PTR _frame$[ebp]
	lea	ecx, DWORD PTR [eax+edx+488]
	mov	DWORD PTR _to_wd$[ebp], ecx

; 621  : 
; 622  : 			MSG_WriteWeaponData( msg, from_wd, to_wd, sv.time, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _to_wd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from_wd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteWeaponData
	add	esp, 20					; 00000014H

; 623  : 		}

	jmp	$LN4@SV_WriteCl
$LN5@SV_WriteCl:

; 624  : 	}
; 625  : 
; 626  : 	// end marker
; 627  : 	MSG_WriteOneBit( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_WriteCl:

; 628  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WriteClientdataToMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_packet_loss$ = -16					; size = 4
_ping$ = -12						; size = 4
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_msg$ = 8						; size = 4
_SV_EmitPings PROC

; 518  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 519  : 	sv_client_t	*cl;
; 520  : 	int		packet_loss;
; 521  : 	int		i, ping;
; 522  : 
; 523  : 	MSG_BeginServerCmd( msg, svc_pings );

	push	0
	push	1
	push	17					; 00000011H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 524  : 
; 525  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], ecx
	jmp	SHORT $LN4@SV_EmitPin
$LN2@SV_EmitPin:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], eax
$LN4@SV_EmitPin:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_EmitPin

; 526  : 	{
; 527  : 		if( cl->state != cs_spawned )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	je	SHORT $LN5@SV_EmitPin

; 528  : 			continue;

	jmp	SHORT $LN2@SV_EmitPin
$LN5@SV_EmitPin:

; 529  : 
; 530  : 		SV_GetPlayerStats( cl, &ping, &packet_loss );

	lea	eax, DWORD PTR _packet_loss$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ping$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_GetPlayerStats
	add	esp, 12					; 0000000cH

; 531  : 
; 532  : 		// there are 25 bits for each client
; 533  : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 534  : 		MSG_WriteUBitLong( msg, i, MAX_CLIENT_BITS );

	push	5
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 535  : 		MSG_WriteUBitLong( msg, ping, 12 );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _ping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 536  : 		MSG_WriteUBitLong( msg, packet_loss, 7 );

	push	7
	mov	edx, DWORD PTR _packet_loss$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 537  : 	}

	jmp	$LN2@SV_EmitPin
$LN3@SV_EmitPin:

; 538  : 
; 539  : 	// end marker
; 540  : 	MSG_WriteOneBit( msg, 0 );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 541  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EmitPings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_state$ = -112						; size = 4
_ent_index$ = -108					; size = 4
_count$ = -104						; size = 4
_es$ = -100						; size = 4
_ev$ = -96						; size = 4
_j$ = -92						; size = 4
_ev_count$ = -88					; size = 4
_i$ = -84						; size = 4
_info$ = -80						; size = 4
_nullargs$ = -76					; size = 72
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_to$ = 12						; size = 4
_msg$ = 16						; size = 4
_SV_EmitEvents PROC

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 397  : 	event_state_t	*es;
; 398  : 	event_info_t	*info;
; 399  : 	entity_state_t	*state;
; 400  : 	event_args_t	nullargs;
; 401  : 	int		ev_count = 0;

	mov	DWORD PTR _ev_count$[ebp], 0

; 402  : 	int		count, ent_index;
; 403  : 	int		i, j, ev;
; 404  : 
; 405  : 	memset( &nullargs, 0, sizeof( nullargs ));

	push	72					; 00000048H
	push	0
	lea	eax, DWORD PTR _nullargs$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 406  : 	es = &cl->events;

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 281920				; 00044d40H
	mov	DWORD PTR _es$[ebp], ecx

; 407  : 
; 408  : 	// count events
; 409  : 	for( ev = 0; ev < MAX_EVENT_QUEUE; ev++ )

	mov	DWORD PTR _ev$[ebp], 0
	jmp	SHORT $LN4@SV_EmitEve
$LN2@SV_EmitEve:
	mov	edx, DWORD PTR _ev$[ebp]
	add	edx, 1
	mov	DWORD PTR _ev$[ebp], edx
$LN4@SV_EmitEve:
	cmp	DWORD PTR _ev$[ebp], 64			; 00000040H
	jge	SHORT $LN3@SV_EmitEve

; 410  : 	{
; 411  : 		if( es->ei[ev].index )

	imul	eax, DWORD PTR _ev$[ebp], 88
	mov	ecx, DWORD PTR _es$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN14@SV_EmitEve

; 412  : 			ev_count++;

	mov	eax, DWORD PTR _ev_count$[ebp]
	add	eax, 1
	mov	DWORD PTR _ev_count$[ebp], eax
$LN14@SV_EmitEve:

; 413  : 	}

	jmp	SHORT $LN2@SV_EmitEve
$LN3@SV_EmitEve:

; 414  : 
; 415  : 	// nothing to send
; 416  : 	if( !ev_count ) return; // nothing to send

	cmp	DWORD PTR _ev_count$[ebp], 0
	jne	SHORT $LN15@SV_EmitEve
	jmp	$LN12@SV_EmitEve
$LN15@SV_EmitEve:

; 417  : 
; 418  : 	if ( ev_count >= MAX_EVENT_QUEUE / 2 )

	cmp	DWORD PTR _ev_count$[ebp], 32		; 00000020H
	jl	SHORT $LN16@SV_EmitEve

; 419  : 		ev_count = ( MAX_EVENT_QUEUE / 2 ) - 1;

	mov	DWORD PTR _ev_count$[ebp], 31		; 0000001fH
$LN16@SV_EmitEve:

; 420  : 
; 421  : 	for( i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_EmitEve
$LN5@SV_EmitEve:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@SV_EmitEve:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN6@SV_EmitEve

; 422  : 	{
; 423  : 		info = &es->ei[i];

	imul	edx, DWORD PTR _i$[ebp], 88
	add	edx, DWORD PTR _es$[ebp]
	mov	DWORD PTR _info$[ebp], edx

; 424  : 		if( info->index == 0 )

	mov	eax, DWORD PTR _info$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN17@SV_EmitEve

; 425  : 			continue;

	jmp	SHORT $LN5@SV_EmitEve
$LN17@SV_EmitEve:

; 426  : 
; 427  : 		ent_index = info->entity_index;

	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+4]
	mov	DWORD PTR _ent_index$[ebp], eax

; 428  : 
; 429  : 		for( j = 0; j < to->num_entities; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_EmitEve
$LN8@SV_EmitEve:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@SV_EmitEve:
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+6120]
	jge	SHORT $LN9@SV_EmitEve

; 430  : 		{
; 431  : 			state = &svs.packet_entities[(to->first_entity+j) % svs.num_client_entities];

	mov	ecx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [ecx+6124]
	add	eax, DWORD PTR _j$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	edx, edx, 340
	add	edx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], edx

; 432  : 			if( state->number == ent_index )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _ent_index$[ebp]
	jne	SHORT $LN18@SV_EmitEve

; 433  : 				break;

	jmp	SHORT $LN9@SV_EmitEve
$LN18@SV_EmitEve:

; 434  : 		}

	jmp	SHORT $LN8@SV_EmitEve
$LN9@SV_EmitEve:

; 435  : 
; 436  : 		if( j < to->num_entities )

	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+6120]
	jge	$LN19@SV_EmitEve

; 437  : 		{
; 438  : 			info->packet_index = j;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	dx, WORD PTR _j$[ebp]
	mov	WORD PTR [ecx+2], dx

; 439  : 			info->args.ducking = 0;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+56], 0

; 440  : 
; 441  : 			if( !FBitSet( info->args.flags, FEVENT_ORIGIN ))

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 1
	jne	SHORT $LN21@SV_EmitEve

; 442  : 				VectorClear( info->args.origin );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+20], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+20], xmm0
$LN21@SV_EmitEve:

; 443  : 
; 444  : 			if( !FBitSet( info->args.flags, FEVENT_ANGLES ))

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 2
	jne	SHORT $LN22@SV_EmitEve

; 445  : 				VectorClear( info->args.angles );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+32], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+32], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+32], xmm0
$LN22@SV_EmitEve:

; 446  : 
; 447  : 			VectorClear( info->args.velocity );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+44], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+44], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+44], xmm0

; 448  : 		}

	jmp	SHORT $LN20@SV_EmitEve
$LN19@SV_EmitEve:

; 449  : 		else
; 450  : 		{
; 451  : 			// couldn't find
; 452  : 			info->packet_index = to->num_entities;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
	mov	cx, WORD PTR [eax+6120]
	mov	WORD PTR [edx+2], cx

; 453  : 			info->args.entindex = ent_index;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _ent_index$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN20@SV_EmitEve:

; 454  : 		}
; 455  : 	}

	jmp	$LN5@SV_EmitEve
$LN6@SV_EmitEve:

; 456  : 
; 457  : 	MSG_BeginServerCmd( msg, svc_event );	// create message

	push	0
	push	1
	push	3
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 458  : 	MSG_WriteUBitLong( msg, ev_count, 5 );	// up to MAX_EVENT_QUEUE events

	push	5
	mov	edx, DWORD PTR _ev_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 459  : 
; 460  : 	for( count = i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _count$[ebp], ecx
	jmp	SHORT $LN13@SV_EmitEve
$LN11@SV_EmitEve:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@SV_EmitEve:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN12@SV_EmitEve

; 461  : 	{
; 462  : 		info = &es->ei[i];

	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 463  : 
; 464  : 		if( info->index == 0 )

	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN23@SV_EmitEve

; 465  : 		{
; 466  : 			info->packet_index = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _info$[ebp]
	mov	WORD PTR [ecx+2], ax

; 467  : 			info->entity_index = -1;

	or	edx, -1
	mov	eax, DWORD PTR _info$[ebp]
	mov	WORD PTR [eax+4], dx

; 468  : 			continue;

	jmp	SHORT $LN11@SV_EmitEve
$LN23@SV_EmitEve:

; 469  : 		}
; 470  : 
; 471  : 		// only send if there's room
; 472  : 		if( count < ev_count )

	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _ev_count$[ebp]
	jge	$LN30@SV_EmitEve

; 473  : 		{
; 474  : 			MSG_WriteUBitLong( msg, info->index, MAX_EVENT_BITS ); // 1024 events

	push	10					; 0000000aH
	mov	edx, DWORD PTR _info$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 475  : 
; 476  : 			if( info->packet_index == -1 )

	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+2]
	cmp	eax, -1
	jne	SHORT $LN25@SV_EmitEve

; 477  : 			{
; 478  : 				MSG_WriteOneBit( msg, 0 );

	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 479  : 			}

	jmp	SHORT $LN28@SV_EmitEve
$LN25@SV_EmitEve:

; 480  : 			else
; 481  : 			{
; 482  : 				MSG_WriteOneBit( msg, 1 );

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8

; 483  : 				MSG_WriteUBitLong( msg, info->packet_index, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 484  : 
; 485  : 				if( !memcmp( &nullargs, &info->args, sizeof( event_args_t )))

	push	72					; 00000048H
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _nullargs$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@SV_EmitEve

; 486  : 				{
; 487  : 					MSG_WriteOneBit( msg, 0 );

	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8

; 488  : 				}

	jmp	SHORT $LN28@SV_EmitEve
$LN27@SV_EmitEve:

; 489  : 				else
; 490  : 				{
; 491  : 					MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 492  : 					MSG_WriteDeltaEvent( msg, &nullargs, &info->args );

	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR _nullargs$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteDeltaEvent
	add	esp, 12					; 0000000cH
$LN28@SV_EmitEve:

; 493  : 				}
; 494  : 			}
; 495  : 
; 496  : 			if( info->fire_time )

	mov	ecx, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@SV_EmitEve

; 497  : 			{
; 498  : 				MSG_WriteOneBit( msg, 1 );

	push	1
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteOneBit
	add	esp, 8

; 499  : 				MSG_WriteWord( msg, ( info->fire_time * 100.0f ));

	mov	eax, DWORD PTR _info$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteWord
	add	esp, 8

; 500  : 			}

	jmp	SHORT $LN30@SV_EmitEve
$LN29@SV_EmitEve:

; 501  : 			else MSG_WriteOneBit( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN30@SV_EmitEve:

; 502  : 		}
; 503  : 
; 504  : 		info->index = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	WORD PTR [edx], cx

; 505  : 		info->packet_index = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _info$[ebp]
	mov	WORD PTR [ecx+2], ax

; 506  : 		info->entity_index = -1;

	or	edx, -1
	mov	eax, DWORD PTR _info$[ebp]
	mov	WORD PTR [eax+4], dx

; 507  : 		count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 508  : 	}

	jmp	$LN11@SV_EmitEve
$LN12@SV_EmitEve:

; 509  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EmitEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_classname$1 = -60					; size = 4
_force$2 = -56						; size = 4
_ed$3 = -52						; size = 4
_baseline$4 = -48					; size = 4
_offset$5 = -44						; size = 4
_oldnum$ = -40						; size = 4
_player$ = -36						; size = 4
_oldmax$ = -32						; size = 4
_oldent$ = -28						; size = 4
_from$ = -24						; size = 4
_newent$ = -20						; size = 4
_i$ = -16						; size = 4
_oldindex$ = -12					; size = 4
_newnum$ = -8						; size = 4
_newindex$ = -4						; size = 4
_cl$ = 8						; size = 4
_to$ = 12						; size = 4
_msg$ = 16						; size = 4
_SV_EmitPacketEntities PROC

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 261  : 	entity_state_t	*oldent, *newent;
; 262  : 	int		oldindex, newindex;
; 263  : 	int		i, oldnum, newnum;
; 264  : 	qboolean		player;
; 265  : 	int		oldmax;
; 266  : 	client_frame_t	*from;
; 267  : 
; 268  : 	// this is the frame that we are going to delta update from
; 269  : 	if( cl->delta_sequence != -1 )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264364], -1
	je	$LN7@SV_EmitPac

; 270  : 	{
; 271  : 		from = &cl->frames[cl->delta_sequence & SV_UPDATE_MASK];

	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	and	ecx, DWORD PTR [edx+264364]
	imul	eax, ecx, 6128
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+281916]
	mov	DWORD PTR _from$[ebp], eax

; 272  : 		oldmax = from->num_entities;

	mov	edx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR [edx+6120]
	mov	DWORD PTR _oldmax$[ebp], eax

; 273  : 
; 274  : 		// the snapshot's entities may still have rolled off the buffer, though
; 275  : 		if( from->first_entity <= ( svs.next_client_entities - svs.num_client_entities ))

	mov	ecx, DWORD PTR _svs+33352
	sub	ecx, DWORD PTR _svs+33348
	mov	edx, DWORD PTR _from$[ebp]
	cmp	DWORD PTR [edx+6124], ecx
	jg	SHORT $LN9@SV_EmitPac

; 276  : 		{
; 277  : 			Con_DPrintf( S_WARN "%s: delta request from out of date entities.\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG136466
	call	_Con_DPrintf
	add	esp, 8

; 278  : 			MSG_BeginServerCmd( msg, svc_packetentities );

	push	0
	push	1
	push	40					; 00000028H
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 279  : 			MSG_WriteUBitLong( msg, to->num_entities - 1, MAX_VISIBLE_PACKET_BITS );

	push	11					; 0000000bH
	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [edx+6120]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 280  : 
; 281  : 			from = NULL;

	mov	DWORD PTR _from$[ebp], 0

; 282  : 			oldmax = 0;

	mov	DWORD PTR _oldmax$[ebp], 0

; 283  : 		}

	jmp	SHORT $LN10@SV_EmitPac
$LN9@SV_EmitPac:

; 284  : 		else
; 285  : 		{
; 286  : 			MSG_BeginServerCmd( msg, svc_deltapacketentities );

	push	0
	push	1
	push	41					; 00000029H
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 287  : 			MSG_WriteUBitLong( msg, to->num_entities - 1, MAX_VISIBLE_PACKET_BITS );

	push	11					; 0000000bH
	mov	eax, DWORD PTR _to$[ebp]
	mov	ecx, DWORD PTR [eax+6120]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 288  : 			MSG_WriteByte( msg, cl->delta_sequence );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264364]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8
$LN10@SV_EmitPac:

; 289  : 		}
; 290  : 	}

	jmp	SHORT $LN8@SV_EmitPac
$LN7@SV_EmitPac:

; 291  : 	else
; 292  : 	{
; 293  : 		from = NULL;

	mov	DWORD PTR _from$[ebp], 0

; 294  : 		oldmax = 0;

	mov	DWORD PTR _oldmax$[ebp], 0

; 295  : 
; 296  : 		MSG_BeginServerCmd( msg, svc_packetentities );

	push	0
	push	1
	push	40					; 00000028H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 297  : 		MSG_WriteUBitLong( msg, to->num_entities - 1, MAX_VISIBLE_PACKET_BITS );

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR [ecx+6120]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN8@SV_EmitPac:

; 298  : 	}
; 299  : 
; 300  : 	newent = NULL;

	mov	DWORD PTR _newent$[ebp], 0

; 301  : 	oldent = NULL;

	mov	DWORD PTR _oldent$[ebp], 0

; 302  : 	newindex = 0;

	mov	DWORD PTR _newindex$[ebp], 0

; 303  : 	oldindex = 0;

	mov	DWORD PTR _oldindex$[ebp], 0
$LN28@SV_EmitPac:

; 304  : 
; 305  : 	while( newindex < to->num_entities || oldindex < oldmax )

	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR _newindex$[ebp]
	cmp	edx, DWORD PTR [ecx+6120]
	jl	SHORT $LN11@SV_EmitPac
	mov	eax, DWORD PTR _oldindex$[ebp]
	cmp	eax, DWORD PTR _oldmax$[ebp]
	jge	$LN3@SV_EmitPac
$LN11@SV_EmitPac:

; 306  : 	{
; 307  : 		if( newindex >= to->num_entities )

	mov	ecx, DWORD PTR _to$[ebp]
	mov	edx, DWORD PTR _newindex$[ebp]
	cmp	edx, DWORD PTR [ecx+6120]
	jl	SHORT $LN12@SV_EmitPac

; 308  : 		{
; 309  : 			newnum = MAX_ENTNUMBER;

	mov	DWORD PTR _newnum$[ebp], 99999		; 0001869fH

; 310  : 			player = false;

	mov	DWORD PTR _player$[ebp], 0

; 311  : 		}

	jmp	SHORT $LN13@SV_EmitPac
$LN12@SV_EmitPac:

; 312  : 		else
; 313  : 		{
; 314  : 			newent = &svs.packet_entities[(to->first_entity+newindex) % svs.num_client_entities];

	mov	eax, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR [eax+6124]
	add	eax, DWORD PTR _newindex$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _newent$[ebp], ecx

; 315  : 			player = SV_IsPlayerIndex( newent->number );

	mov	edx, DWORD PTR _newent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_SV_IsPlayerIndex
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax

; 316  : 			newnum = newent->number;

	mov	ecx, DWORD PTR _newent$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _newnum$[ebp], edx
$LN13@SV_EmitPac:

; 317  : 		}
; 318  : 
; 319  : 		if( oldindex >= oldmax )

	mov	eax, DWORD PTR _oldindex$[ebp]
	cmp	eax, DWORD PTR _oldmax$[ebp]
	jl	SHORT $LN14@SV_EmitPac

; 320  : 		{
; 321  : 			oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 322  : 		}

	jmp	SHORT $LN15@SV_EmitPac
$LN14@SV_EmitPac:

; 323  : 		else
; 324  : 		{
; 325  : 			oldent = &svs.packet_entities[(from->first_entity+oldindex) % svs.num_client_entities];

	mov	ecx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR [ecx+6124]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	edx, edx, 340
	add	edx, DWORD PTR _svs+33356
	mov	DWORD PTR _oldent$[ebp], edx

; 326  : 			oldnum = oldent->number;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx
$LN15@SV_EmitPac:

; 327  : 		}
; 328  : 
; 329  : 		if( newnum == oldnum )

	mov	edx, DWORD PTR _newnum$[ebp]
	cmp	edx, DWORD PTR _oldnum$[ebp]
	jne	SHORT $LN16@SV_EmitPac

; 330  : 		{	
; 331  : 			// delta update from old position
; 332  : 			// because the force parm is false, this will not result
; 333  : 			// in any bytes being emited if the entity has not changed at all
; 334  : 			MSG_WriteDeltaEntity( oldent, newent, msg, false, player, sv.time, 0 );

	push	0
	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newent$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldent$[ebp]
	push	eax
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 335  : 			oldindex++;

	mov	ecx, DWORD PTR _oldindex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _oldindex$[ebp], ecx

; 336  : 			newindex++;

	mov	edx, DWORD PTR _newindex$[ebp]
	add	edx, 1
	mov	DWORD PTR _newindex$[ebp], edx

; 337  : 			continue;

	jmp	$LN28@SV_EmitPac
$LN16@SV_EmitPac:

; 338  : 		}
; 339  : 
; 340  : 		if( newnum < oldnum )

	mov	eax, DWORD PTR _newnum$[ebp]
	cmp	eax, DWORD PTR _oldnum$[ebp]
	jge	$LN17@SV_EmitPac

; 341  : 		{	
; 342  : 			entity_state_t	*baseline = &svs.baselines[newnum];

	imul	ecx, DWORD PTR _newnum$[ebp], 340
	add	ecx, DWORD PTR _svs+33360
	mov	DWORD PTR _baseline$4[ebp], ecx

; 343  : 			const char	*classname = SV_ClassName( EDICT_NUM( newnum ));

	mov	edx, DWORD PTR _newnum$[ebp]
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	push	eax
	call	_SV_ClassName
	add	esp, 4
	mov	DWORD PTR _classname$1[ebp], eax

; 344  : 			int		offset = 0;

	mov	DWORD PTR _offset$5[ebp], 0

; 345  : 
; 346  : 			// trying to reduce message by select optimal baseline
; 347  : 			if( !sv_instancedbaseline.value || !sv.num_instanced || sv.last_valid_baseline > newnum )

	movss	xmm0, DWORD PTR _sv_instancedbaseline+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@SV_EmitPac
	cmp	DWORD PTR _sv+1179348, 0
	je	SHORT $LN20@SV_EmitPac
	mov	eax, DWORD PTR _sv+1179344
	cmp	eax, DWORD PTR _newnum$[ebp]
	jle	SHORT $LN18@SV_EmitPac
$LN20@SV_EmitPac:

; 348  : 			{
; 349  : 				offset = SV_FindBestBaseline( cl, newindex, &baseline, newent, to, player );

	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	edx, DWORD PTR _to$[ebp]
	push	edx
	mov	eax, DWORD PTR _newent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _baseline$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _newindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_FindBestBaseline
	add	esp, 24					; 00000018H
	mov	DWORD PTR _offset$5[ebp], eax

; 350  : 			}

	jmp	SHORT $LN5@SV_EmitPac
$LN18@SV_EmitPac:

; 351  : 			else
; 352  : 			{
; 353  : 				for( i = 0; i < sv.num_instanced; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SV_EmitPac
$LN4@SV_EmitPac:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@SV_EmitPac:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _sv+1179348
	jge	SHORT $LN5@SV_EmitPac

; 354  : 				{
; 355  : 					if( !Q_strcmp( classname, sv.instanced[i].classname ))

	push	99999					; 0001869fH
	imul	eax, DWORD PTR _i$[ebp], 344
	mov	ecx, DWORD PTR _sv[eax+1157328]
	push	ecx
	mov	edx, DWORD PTR _classname$1[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@SV_EmitPac

; 356  : 					{
; 357  : 						baseline = &sv.instanced[i].baseline;

	imul	eax, DWORD PTR _i$[ebp], 344
	add	eax, OFFSET _sv+1157332
	mov	DWORD PTR _baseline$4[ebp], eax

; 358  : 						offset = -i;

	mov	ecx, DWORD PTR _i$[ebp]
	neg	ecx
	mov	DWORD PTR _offset$5[ebp], ecx

; 359  : 						break;

	jmp	SHORT $LN5@SV_EmitPac
$LN21@SV_EmitPac:

; 360  : 					}
; 361  : 				}

	jmp	SHORT $LN4@SV_EmitPac
$LN5@SV_EmitPac:

; 362  : 			}
; 363  : 
; 364  : 			// this is a new entity, send it from the baseline
; 365  : 			MSG_WriteDeltaEntity( baseline, newent, msg, true, player, sv.time, offset );

	mov	edx, DWORD PTR _offset$5[ebp]
	push	edx
	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newent$[ebp]
	push	edx
	mov	eax, DWORD PTR _baseline$4[ebp]
	push	eax
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 366  : 			newindex++;

	mov	ecx, DWORD PTR _newindex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _newindex$[ebp], ecx

; 367  : 			continue;

	jmp	$LN28@SV_EmitPac
$LN17@SV_EmitPac:

; 368  : 		}
; 369  : 
; 370  : 		if( newnum > oldnum )

	mov	edx, DWORD PTR _newnum$[ebp]
	cmp	edx, DWORD PTR _oldnum$[ebp]
	jle	SHORT $LN22@SV_EmitPac

; 371  : 		{	
; 372  : 			edict_t	*ed = EDICT_NUM( oldent->number );

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ed$3[ebp], eax

; 373  : 			qboolean	force = false;

	mov	DWORD PTR _force$2[ebp], 0

; 374  : 
; 375  : 			// check if entity completely removed from server
; 376  : 			if( ed->free || FBitSet( ed->v.flags, FL_KILLME ))

	mov	edx, DWORD PTR _ed$3[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN24@SV_EmitPac
	mov	eax, DWORD PTR _ed$3[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN23@SV_EmitPac
$LN24@SV_EmitPac:

; 377  : 				force = true;

	mov	DWORD PTR _force$2[ebp], 1
$LN23@SV_EmitPac:

; 378  : 
; 379  : 			// remove from message
; 380  : 			MSG_WriteDeltaEntity( oldent, NULL, msg, force, false, sv.time, 0 );

	push	0
	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _force$2[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _oldent$[ebp]
	push	ecx
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 381  : 			oldindex++;

	mov	edx, DWORD PTR _oldindex$[ebp]
	add	edx, 1
	mov	DWORD PTR _oldindex$[ebp], edx

; 382  : 			continue;

	jmp	$LN28@SV_EmitPac
$LN22@SV_EmitPac:

; 383  : 		}
; 384  : 	}

	jmp	$LN28@SV_EmitPac
$LN3@SV_EmitPac:

; 385  : 
; 386  : 	MSG_WriteUBitLong( msg, LAST_EDICT, MAX_ENTITY_BITS ); // end of packetentities

	push	13					; 0000000dH
	push	8191					; 00001fffH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 387  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EmitPacketEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_j$ = -24						; size = 4
_bitCount$ = -20					; size = 4
_test$1 = -16						; size = 4
_bestBitCount$ = -12					; size = 4
_bestfound$ = -8					; size = 4
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_index$ = 12						; size = 4
_baseline$ = 16						; size = 4
_to$ = 20						; size = 4
_frame$ = 24						; size = 4
_player$ = 28						; size = 4
_SV_FindBestBaseline PROC

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 184  : 	int	bestBitCount;
; 185  : 	int	i, bitCount;
; 186  : 	int	bestfound, j;
; 187  : 
; 188  : 	bestBitCount = j = Delta_TestBaseline( *baseline, to, player, sv.time );

	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseline$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Delta_TestBaseline
	add	esp, 16					; 00000010H
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _bestBitCount$[ebp], ecx

; 189  : 	bestfound = index;

	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _bestfound$[ebp], edx

; 190  : 
; 191  : 	// lookup backward for previous 64 states and try to interpret current delta as baseline
; 192  : 	for( i = index - 1; bestBitCount > 0 && i >= 0 && ( index - i ) < ( MAX_CUSTOM_BASELINES - 1 ); i-- )

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@SV_FindBes
$LN2@SV_FindBes:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_FindBes:
	cmp	DWORD PTR _bestBitCount$[ebp], 0
	jle	SHORT $LN3@SV_FindBes
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@SV_FindBes
	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	cmp	edx, 63					; 0000003fH
	jge	SHORT $LN3@SV_FindBes

; 193  : 	{
; 194  : 		// don't worry about underflow in circular buffer
; 195  : 		entity_state_t	*test = &svs.packet_entities[(frame->first_entity+i) % svs.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+6124]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _test$1[ebp], ecx

; 196  : 
; 197  : 		if( to->entityType == test->entityType )

	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, DWORD PTR _test$1[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN6@SV_FindBes

; 198  : 		{
; 199  : 			bitCount = Delta_TestBaseline( test, to, player, sv.time );

	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _test$1[ebp]
	push	ecx
	call	_Delta_TestBaseline
	add	esp, 16					; 00000010H
	mov	DWORD PTR _bitCount$[ebp], eax

; 200  : 
; 201  : 			if( bitCount < bestBitCount )

	mov	edx, DWORD PTR _bitCount$[ebp]
	cmp	edx, DWORD PTR _bestBitCount$[ebp]
	jge	SHORT $LN6@SV_FindBes

; 202  : 			{
; 203  : 				bestBitCount = bitCount;

	mov	eax, DWORD PTR _bitCount$[ebp]
	mov	DWORD PTR _bestBitCount$[ebp], eax

; 204  : 				bestfound = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bestfound$[ebp], ecx
$LN6@SV_FindBes:

; 205  : 			}
; 206  : 		}
; 207  : 	}

	jmp	$LN2@SV_FindBes
$LN3@SV_FindBes:

; 208  : 
; 209  : 	// using delta from previous entity as baseline for current
; 210  : 	if( index != bestfound )

	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _bestfound$[ebp]
	je	SHORT $LN7@SV_FindBes

; 211  : 		*baseline = &svs.packet_entities[(frame->first_entity+bestfound) % svs.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+6124]
	add	eax, DWORD PTR _bestfound$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _svs+33356
	mov	edx, DWORD PTR _baseline$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@SV_FindBes:

; 212  : 	return index - bestfound;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, DWORD PTR _bestfound$[ebp]

; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindBestBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
tv175 = -52						; size = 4
_state$ = -48						; size = 4
_clientphs$ = -44					; size = 4
_fullvis$ = -40						; size = 4
tv172 = -36						; size = 4
_pset$1 = -32						; size = 4
_clientpvs$ = -28					; size = 4
_cl$2 = -24						; size = 4
tv131 = -20						; size = 4
_player$ = -16						; size = 4
_ent$ = -12						; size = 4
_cl$ = -8						; size = 4
_e$ = -4						; size = 4
_pViewEnt$ = 8						; size = 4
_pClient$ = 12						; size = 4
_frame$ = 16						; size = 4
_ents$ = 20						; size = 4
_from_client$ = 24					; size = 4
_SV_AddEntitiesToPacket PROC

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 59   : 	edict_t		*ent;
; 60   : 	byte		*clientpvs;
; 61   : 	byte		*clientphs;
; 62   : 	qboolean		fullvis = false;

	mov	DWORD PTR _fullvis$[ebp], 0

; 63   : 	sv_client_t	*cl = NULL;

	mov	DWORD PTR _cl$[ebp], 0

; 64   : 	qboolean		player;
; 65   : 	entity_state_t	*state;
; 66   : 	int		e;
; 67   : 
; 68   : 	// during an error shutdown message we may need to transmit
; 69   : 	// the shutdown message after the server has shutdown, so
; 70   : 	// specifically check for it
; 71   : 	if( sv.state == ss_dead )

	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN5@SV_AddEnti

; 72   : 		return;

	jmp	$LN1@SV_AddEnti
$LN5@SV_AddEnti:

; 73   : 
; 74   : 	cl = SV_ClientFromEdict( pClient, true );

	push	1
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	_SV_ClientFromEdict
	add	esp, 8
	mov	DWORD PTR _cl$[ebp], eax

; 75   : 
; 76   : 	ASSERT( cl != NULL );

	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN6@SV_AddEnti
	push	76					; 0000004cH
	push	OFFSET $SG136360
	push	OFFSET $SG136361
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN6@SV_AddEnti:

; 77   : 
; 78   : 	// portals can't change hostflags
; 79   : 	if( from_client )

	cmp	DWORD PTR _from_client$[ebp], 0
	je	SHORT $LN7@SV_AddEnti

; 80   : 	{
; 81   : 		// setup hostflags
; 82   : 		if( FBitSet( cl->flags, FCL_LOCAL_WEAPONS ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 32					; 00000020H
	je	SHORT $LN8@SV_AddEnti

; 83   : 			SetBits( sv.hostflags, SVF_SKIPLOCALHOST );

	mov	eax, DWORD PTR _sv+44
	or	eax, 1
	mov	DWORD PTR _sv+44, eax
	jmp	SHORT $LN9@SV_AddEnti
$LN8@SV_AddEnti:

; 84   : 		else ClearBits( sv.hostflags, SVF_SKIPLOCALHOST );

	mov	ecx, DWORD PTR _sv+44
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR _sv+44, ecx
$LN9@SV_AddEnti:

; 85   : 
; 86   : 		// reset viewents each frame
; 87   : 		cl->num_viewents = 0;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+265500], 0
$LN7@SV_AddEnti:

; 88   : 	}
; 89   : 
; 90   : 	svgame.dllFuncs.pfnSetupVisibility( pViewEnt, pClient, &clientpvs, &clientphs );

	lea	eax, DWORD PTR _clientphs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _clientpvs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pClient$[ebp]
	push	edx
	mov	eax, DWORD PTR _pViewEnt$[ebp]
	push	eax
	call	DWORD PTR _svgame+19388
	add	esp, 16					; 00000010H

; 91   : 	if( !clientpvs ) fullvis = true;

	cmp	DWORD PTR _clientpvs$[ebp], 0
	jne	SHORT $LN10@SV_AddEnti
	mov	DWORD PTR _fullvis$[ebp], 1
$LN10@SV_AddEnti:

; 92   : 
; 93   : 	// g-cont: of course we can send world but not want to do it :-)
; 94   : 	for( e = 1; e < svgame.numEntities; e++ )

	mov	DWORD PTR _e$[ebp], 1
	jmp	SHORT $LN4@SV_AddEnti
$LN2@SV_AddEnti:
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 1
	mov	DWORD PTR _e$[ebp], ecx
$LN4@SV_AddEnti:
	mov	edx, DWORD PTR _e$[ebp]
	cmp	edx, DWORD PTR _svgame+7932
	jge	$LN1@SV_AddEnti

; 95   : 	{
; 96   : 		byte	*pset;
; 97   : 
; 98   : 		ent = EDICT_NUM( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 99   : 
; 100  : 		// don't double add an entity through portals (in case this already added)
; 101  : 		if( CHECKVISBIT( ents->sended, e ))

	cmp	DWORD PTR _e$[ebp], 0
	jl	SHORT $LN27@SV_AddEnti
	mov	ecx, DWORD PTR _e$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR _ents$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+696324]
	mov	ecx, DWORD PTR _e$[ebp]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN28@SV_AddEnti
$LN27@SV_AddEnti:
	mov	DWORD PTR tv131[ebp], 0
$LN28@SV_AddEnti:
	cmp	DWORD PTR tv131[ebp], 0
	je	SHORT $LN11@SV_AddEnti

; 102  : 			continue;

	jmp	SHORT $LN2@SV_AddEnti
$LN11@SV_AddEnti:

; 103  : 
; 104  : 		if( e >= 1 && e <= svs.maxclients )

	cmp	DWORD PTR _e$[ebp], 1
	jl	SHORT $LN12@SV_AddEnti
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jg	SHORT $LN12@SV_AddEnti

; 105  : 			player = 1;

	mov	DWORD PTR _player$[ebp], 1
	jmp	SHORT $LN13@SV_AddEnti
$LN12@SV_AddEnti:

; 106  : 		else player = 0;

	mov	DWORD PTR _player$[ebp], 0
$LN13@SV_AddEnti:

; 107  : 
; 108  : 		if( player )

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN14@SV_AddEnti

; 109  : 		{
; 110  : 			sv_client_t *cl = &svs.clients[e - 1];

	mov	edx, DWORD PTR _e$[ebp]
	sub	edx, 1
	imul	eax, edx, 287560
	add	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$2[ebp], eax

; 111  : 
; 112  : 			if( cl->state != cs_spawned )

	mov	ecx, DWORD PTR _cl$2[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN15@SV_AddEnti

; 113  : 				continue;

	jmp	$LN2@SV_AddEnti
$LN15@SV_AddEnti:

; 114  : 
; 115  : 			if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	edx, DWORD PTR _cl$2[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 256				; 00000100H
	je	SHORT $LN14@SV_AddEnti

; 116  : 				continue;

	jmp	$LN2@SV_AddEnti
$LN14@SV_AddEnti:

; 117  : 		}
; 118  : 
; 119  : 		if( FBitSet( ent->v.effects, EF_REQUEST_PHS ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN17@SV_AddEnti

; 120  : 			pset = clientphs;

	mov	eax, DWORD PTR _clientphs$[ebp]
	mov	DWORD PTR _pset$1[ebp], eax
	jmp	SHORT $LN18@SV_AddEnti
$LN17@SV_AddEnti:

; 121  : 		else pset = clientpvs;

	mov	ecx, DWORD PTR _clientpvs$[ebp]
	mov	DWORD PTR _pset$1[ebp], ecx
$LN18@SV_AddEnti:

; 122  : 
; 123  : 		state = &ents->entities[ents->num_entities];

	mov	edx, DWORD PTR _ents$[ebp]
	imul	eax, DWORD PTR [edx], 340
	mov	ecx, DWORD PTR _ents$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _state$[ebp], edx

; 124  : 
; 125  : 		// add entity to the net packet
; 126  : 		if( svgame.dllFuncs.pfnAddToFullPack( state, e, ent, pClient, sv.hostflags, player, pset ))

	mov	eax, DWORD PTR _pset$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sv+44
	push	edx
	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _svgame+19396
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	$LN19@SV_AddEnti

; 127  : 		{
; 128  : 			// to prevent adds it twice through portals
; 129  : 			SETVISBIT( ents->sended, e );

	cmp	DWORD PTR _e$[ebp], 0
	jl	SHORT $LN29@SV_AddEnti
	mov	edx, DWORD PTR _e$[ebp]
	sar	edx, 3
	mov	ecx, DWORD PTR _e$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _ents$[ebp]
	movzx	edx, BYTE PTR [ecx+edx+696324]
	or	edx, eax
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _e$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _ents$[ebp]
	mov	dl, BYTE PTR tv172[ebp]
	mov	BYTE PTR [ecx+eax+696324], dl
	movzx	eax, BYTE PTR tv172[ebp]
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN30@SV_AddEnti
$LN29@SV_AddEnti:
	mov	DWORD PTR tv175[ebp], 0
$LN30@SV_AddEnti:

; 130  : 
; 131  : 			if( SV_IsValidEdict( ent->v.aiment ) && FBitSet( ent->v.aiment->v.effects, EF_MERGE_VISIBILITY ))

	push	131					; 00000083H
	push	OFFSET $SG136376
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@SV_AddEnti
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	mov	edx, DWORD PTR [ecx+408]
	and	edx, 536870912				; 20000000H
	je	SHORT $LN20@SV_AddEnti

; 132  : 			{
; 133  : 				if( cl->num_viewents < MAX_VIEWENTS )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+265500], 128		; 00000080H
	jge	SHORT $LN20@SV_AddEnti

; 134  : 				{
; 135  : 					cl->viewentity[cl->num_viewents] = ent->v.aiment;

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+265500]
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [ecx+532]
	mov	DWORD PTR [eax+edx*4+264988], ecx

; 136  : 					cl->num_viewents++;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+265500]
	add	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+265500], eax
$LN20@SV_AddEnti:

; 137  : 				}
; 138  : 			}
; 139  : 
; 140  : 			// if we are full, silently discard entities
; 141  : 			if( ents->num_entities < ( MAX_VISIBLE_PACKET - 1 ))

	mov	edx, DWORD PTR _ents$[ebp]
	cmp	DWORD PTR [edx], 2047			; 000007ffH
	jge	SHORT $LN22@SV_AddEnti

; 142  : 			{
; 143  : 				ents->num_entities++;	// entity accepted

	mov	eax, DWORD PTR _ents$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ents$[ebp]
	mov	DWORD PTR [edx], ecx

; 144  : 				c_fullsend++;		// debug counter

	mov	eax, DWORD PTR _c_fullsend
	add	eax, 1
	mov	DWORD PTR _c_fullsend, eax

; 145  : 				
; 146  : 			}

	jmp	SHORT $LN19@SV_AddEnti
$LN22@SV_AddEnti:

; 147  : 			else
; 148  : 			{
; 149  : 				// visibility list is full
; 150  : 				// continue counting entities,
; 151  : 				// so we know how many it's ovreflowed
; 152  : 				c_notsend++;

	mov	ecx, DWORD PTR _c_notsend
	add	ecx, 1
	mov	DWORD PTR _c_notsend, ecx
$LN19@SV_AddEnti:

; 153  : 			}
; 154  : 		}
; 155  : 
; 156  : 		if( fullvis ) continue; // portal ents will be added anyway, ignore recursion

	cmp	DWORD PTR _fullvis$[ebp], 0
	je	SHORT $LN24@SV_AddEnti
	jmp	$LN2@SV_AddEnti
$LN24@SV_AddEnti:

; 157  : 
; 158  : 		// if it's a portal entity, add everything visible from its camera position
; 159  : 		if( from_client && FBitSet( ent->v.effects, EF_MERGE_VISIBILITY ))

	cmp	DWORD PTR _from_client$[ebp], 0
	je	SHORT $LN25@SV_AddEnti
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+408]
	and	eax, 536870912				; 20000000H
	je	SHORT $LN25@SV_AddEnti

; 160  : 		{
; 161  : 			SetBits( sv.hostflags, SVF_MERGE_VISIBILITY );

	mov	ecx, DWORD PTR _sv+44
	or	ecx, 2
	mov	DWORD PTR _sv+44, ecx

; 162  : 			SV_AddEntitiesToPacket( ent, pClient, frame, ents, false );

	push	0
	mov	edx, DWORD PTR _ents$[ebp]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pClient$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_AddEntitiesToPacket
	add	esp, 20					; 00000014H

; 163  : 			ClearBits( sv.hostflags, SVF_MERGE_VISIBILITY );

	mov	eax, DWORD PTR _sv+44
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _sv+44, eax
$LN25@SV_AddEnti:

; 164  : 		}
; 165  : 	}

	jmp	$LN2@SV_AddEnti
$LN1@SV_AddEnti:

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddEntitiesToPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_ent2$ = -8						; size = 4
_ent1$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_SV_EntityNumbers PROC

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 38   : 	int	ent1, ent2;
; 39   : 
; 40   : 	ent1 = ((entity_state_t *)a)->number;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ent1$[ebp], ecx

; 41   : 	ent2 = ((entity_state_t *)b)->number;

	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ent2$[ebp], eax

; 42   : 
; 43   : 	if( ent1 == ent2 )

	mov	ecx, DWORD PTR _ent1$[ebp]
	cmp	ecx, DWORD PTR _ent2$[ebp]
	jne	SHORT $LN2@SV_EntityN

; 44   : 		Host_Error( "SV_SortEntities: duplicated entity\n" );

	push	OFFSET $SG136324
	call	_Host_Error
	add	esp, 4
$LN2@SV_EntityN:

; 45   : 
; 46   : 	if( ent1 < ent2 )

	mov	edx, DWORD PTR _ent1$[ebp]
	cmp	edx, DWORD PTR _ent2$[ebp]
	jge	SHORT $LN3@SV_EntityN

; 47   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@SV_EntityN
$LN3@SV_EntityN:

; 48   : 	return 1;

	mov	eax, 1
$LN1@SV_EntityN:

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EntityNumbers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_SkipUpdates PROC

; 949  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 950  : 	sv_client_t	*cl;
; 951  : 	int		i;
; 952  : 
; 953  : 	if( sv.state == ss_dead )

	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN5@SV_SkipUpd

; 954  : 		return;

	jmp	SHORT $LN1@SV_SkipUpd
$LN5@SV_SkipUpd:

; 955  : 
; 956  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_SkipUpd
$LN2@SV_SkipUpd:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_SkipUpd:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_SkipUpd

; 957  : 	{
; 958  : 		if( cl->state != cs_spawned || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN7@SV_SkipUpd
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	je	SHORT $LN6@SV_SkipUpd
$LN7@SV_SkipUpd:

; 959  : 			continue;

	jmp	SHORT $LN2@SV_SkipUpd
$LN6@SV_SkipUpd:

; 960  : 
; 961  : 		SetBits( cl->flags, FCL_SKIP_NET_MESSAGE );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	or	edx, 4
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx

; 962  : 	}

	jmp	SHORT $LN2@SV_SkipUpd
$LN1@SV_SkipUpd:

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SkipUpdates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_SendMessagesToAll PROC

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 926  : 	sv_client_t	*cl;
; 927  : 	int		i;
; 928  : 
; 929  : 	if( sv.state == ss_dead )

	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN5@SV_SendMes

; 930  : 		return;

	jmp	SHORT $LN1@SV_SendMes
$LN5@SV_SendMes:

; 931  : 
; 932  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_SendMes
$LN2@SV_SendMes:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_SendMes:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_SendMes

; 933  : 	{
; 934  : 		if( cl->state >= cs_connected )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN6@SV_SendMes

; 935  : 			SetBits( cl->flags, FCL_SEND_NET_MESSAGE );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 8
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN6@SV_SendMes:

; 936  : 	}	

	jmp	SHORT $LN2@SV_SendMes
$LN3@SV_SendMes:

; 937  : 
; 938  : 	SV_SendClientMessages();

	call	_SV_SendClientMessages
$LN1@SV_SendMes:

; 939  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendMessagesToAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_test$1 = -24						; size = 4
_j$ = -20						; size = 4
_bitCount$ = -16					; size = 4
_bestBitCount$ = -12					; size = 4
_bestfound$ = -8					; size = 4
_i$ = -4						; size = 4
_index$ = 8						; size = 4
_baseline$ = 12						; size = 4
_to$ = 16						; size = 4
_SV_FindBestBaselineForStatic PROC

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 224  : 	int	bestBitCount;
; 225  : 	int	i, bitCount;
; 226  : 	int	bestfound, j;
; 227  : 
; 228  : 	bestBitCount = j = Delta_TestBaseline( *baseline, to, false, sv.time );

	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseline$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_Delta_TestBaseline
	add	esp, 16					; 00000010H
	mov	DWORD PTR _j$[ebp], eax
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _bestBitCount$[ebp], eax

; 229  : 	bestfound = index;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _bestfound$[ebp], ecx

; 230  : 
; 231  : 	// lookup backward for previous 64 states and try to interpret current delta as baseline
; 232  : 	for( i = index - 1; bestBitCount > 0 && i >= 0 && ( index - i ) < ( MAX_CUSTOM_BASELINES - 1 ); i-- )

	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN4@SV_FindBes
$LN2@SV_FindBes:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_FindBes:
	cmp	DWORD PTR _bestBitCount$[ebp], 0
	jle	SHORT $LN3@SV_FindBes
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@SV_FindBes
	mov	ecx, DWORD PTR _index$[ebp]
	sub	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, 63					; 0000003fH
	jge	SHORT $LN3@SV_FindBes

; 233  : 	{
; 234  : 		// don't worry about underflow in circular buffer
; 235  : 		entity_state_t	*test = &svs.static_entities[i];

	imul	edx, DWORD PTR _i$[ebp], 340
	add	edx, DWORD PTR _svs+33364
	mov	DWORD PTR _test$1[ebp], edx

; 236  : 
; 237  : 		bitCount = Delta_TestBaseline( test, to, false, sv.time );

	cvtsd2ss xmm0, QWORD PTR _sv+16
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _test$1[ebp]
	push	ecx
	call	_Delta_TestBaseline
	add	esp, 16					; 00000010H
	mov	DWORD PTR _bitCount$[ebp], eax

; 238  : 
; 239  : 		if( bitCount < bestBitCount )

	mov	edx, DWORD PTR _bitCount$[ebp]
	cmp	edx, DWORD PTR _bestBitCount$[ebp]
	jge	SHORT $LN5@SV_FindBes

; 240  : 		{
; 241  : 			bestBitCount = bitCount;

	mov	eax, DWORD PTR _bitCount$[ebp]
	mov	DWORD PTR _bestBitCount$[ebp], eax

; 242  : 			bestfound = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bestfound$[ebp], ecx
$LN5@SV_FindBes:

; 243  : 		}
; 244  : 	}

	jmp	SHORT $LN2@SV_FindBes
$LN3@SV_FindBes:

; 245  : 
; 246  : 	// using delta from previous entity as baseline for current
; 247  : 	if( index != bestfound )

	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _bestfound$[ebp]
	je	SHORT $LN6@SV_FindBes

; 248  : 		*baseline = &svs.static_entities[bestfound];

	imul	eax, DWORD PTR _bestfound$[ebp], 340
	add	eax, DWORD PTR _svs+33364
	mov	ecx, DWORD PTR _baseline$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@SV_FindBes:

; 249  : 	return index - bestfound;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, DWORD PTR _bestfound$[ebp]

; 250  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindBestBaselineForStatic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_InactivateClients PROC

; 973  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 974  : 	int		i;
; 975  : 	sv_client_t	*cl;
; 976  : 
; 977  : 	if( sv.state == ss_dead )

	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN5@SV_Inactiv

; 978  : 		return;

	jmp	$LN1@SV_Inactiv
$LN5@SV_Inactiv:

; 979  : 
; 980  : 	// send a message to each connected client
; 981  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Inactiv
$LN2@SV_Inactiv:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN4@SV_Inactiv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN1@SV_Inactiv

; 982  : 	{
; 983  : 		if( !cl->state || !cl->edict )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@SV_Inactiv
	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx+264980], 0
	jne	SHORT $LN6@SV_Inactiv
$LN7@SV_Inactiv:

; 984  : 			continue;

	jmp	SHORT $LN2@SV_Inactiv
$LN6@SV_Inactiv:

; 985  : 			
; 986  : 		if( !cl->edict || FBitSet( cl->edict->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264980], 0
	je	SHORT $LN9@SV_Inactiv
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8192				; 00002000H
	je	SHORT $LN8@SV_Inactiv
$LN9@SV_Inactiv:

; 987  : 			continue;

	jmp	SHORT $LN2@SV_Inactiv
$LN8@SV_Inactiv:

; 988  : 
; 989  : 		if( cl->state > cs_connected )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jle	SHORT $LN10@SV_Inactiv

; 990  : 			cl->state = cs_connected;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx], 2
$LN10@SV_Inactiv:

; 991  : 
; 992  : 		COM_ClearCustomizationList( &cl->customdata, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264452				; 00040904H
	push	eax
	call	_COM_ClearCustomizationList
	add	esp, 8

; 993  : 		memset( cl->physinfo, 0, MAX_PHYSINFO_STRING );

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 994  : 
; 995  : 		// NOTE: many mods sending messages that must be applied on a next level
; 996  : 		// e.g. CryOfFear sending HideHud and PlayMp3 that affected after map change
; 997  : 		if( svgame.globals->changelevel )

	mov	edx, DWORD PTR _svgame+19236
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN11@SV_Inactiv

; 998  : 			continue;

	jmp	$LN2@SV_Inactiv
$LN11@SV_Inactiv:

; 999  : 
; 1000 : 		MSG_Clear( &cl->netchan.message );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 1001 : 		MSG_Clear( &cl->datagram );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_Clear
	add	esp, 4

; 1002 : 	}

	jmp	$LN2@SV_Inactiv
$LN1@SV_Inactiv:

; 1003 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InactivateClients ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_frame.c
_TEXT	SEGMENT
tv168 = -12						; size = 4
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_SendClientMessages PROC

; 839  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 840  : 	sv_client_t	*cl;
; 841  : 	int		i;
; 842  : 
; 843  : 	if( sv.state == ss_dead )

	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN5@SV_SendCli

; 844  : 		return;

	jmp	$LN1@SV_SendCli
$LN5@SV_SendCli:

; 845  : 
; 846  : 	SV_UpdateToReliableMessages ();

	call	_SV_UpdateToReliableMessages

; 847  : 
; 848  : 	// send a message to each connected client
; 849  : 	for( i = 0, sv.current_client = svs.clients; i < svs.maxclients; i++, sv.current_client++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _sv+40, eax
	jmp	SHORT $LN4@SV_SendCli
$LN2@SV_SendCli:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _sv+40
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _sv+40, edx
$LN4@SV_SendCli:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_SendCli

; 850  : 	{
; 851  : 		cl = sv.current_client;

	mov	ecx, DWORD PTR _sv+40
	mov	DWORD PTR _cl$[ebp], ecx

; 852  : 
; 853  : 		if( cl->state <= cs_zombie || FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 1
	jle	SHORT $LN7@SV_SendCli
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN6@SV_SendCli
$LN7@SV_SendCli:

; 854  : 			continue;

	jmp	SHORT $LN2@SV_SendCli
$LN6@SV_SendCli:

; 855  : 
; 856  : 		if( FBitSet( cl->flags, FCL_SKIP_NET_MESSAGE ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 4
	je	SHORT $LN8@SV_SendCli

; 857  : 		{
; 858  : 			ClearBits( cl->flags, FCL_SKIP_NET_MESSAGE );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx

; 859  : 			continue;

	jmp	SHORT $LN2@SV_SendCli
$LN8@SV_SendCli:

; 860  : 		}
; 861  : 
; 862  : 		if( !host_limitlocal->value && NET_IsLocalAddress( cl->netchan.remote_address ))

	mov	ecx, DWORD PTR _host_limitlocal
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@SV_SendCli
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN9@SV_SendCli

; 863  : 			SetBits( cl->flags, FCL_SEND_NET_MESSAGE );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 8
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN9@SV_SendCli:

; 864  : 
; 865  : 		if( cl->state == cs_spawned )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN11@SV_SendCli

; 866  : 		{
; 867  : 			if(( host.realtime + sv.frametime ) >= cl->next_messagetime )

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _host+1440
	mov	ecx, DWORD PTR _cl$[ebp]
	comisd	xmm0, QWORD PTR [ecx+264368]
	jb	SHORT $LN11@SV_SendCli

; 868  : 				SetBits( cl->flags, FCL_SEND_NET_MESSAGE );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 8
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN11@SV_SendCli:

; 869  : 		}
; 870  : 
; 871  : 		// if the reliable message overflowed, drop the client
; 872  : 		if( MSG_CheckOverflow( &cl->netchan.message ))

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 660				; 00000294H
	push	edx
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@SV_SendCli

; 873  : 		{
; 874  : 			MSG_Clear( &cl->netchan.message );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 875  : 			MSG_Clear( &cl->datagram );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 265512				; 00040d28H
	push	ecx
	call	_MSG_Clear
	add	esp, 4

; 876  : 			SV_BroadcastPrintf( NULL, "%s overflowed\n", cl->name );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET $SG136670
	push	0
	call	_SV_BroadcastPrintf
	add	esp, 12					; 0000000cH

; 877  : 			Con_DPrintf( S_ERROR "reliable overflow for %s\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET $SG136671
	call	_Con_DPrintf
	add	esp, 8

; 878  : 			SV_DropClient( cl, false );

	push	0
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_DropClient
	add	esp, 8

; 879  : 			SetBits( cl->flags, FCL_SEND_NET_MESSAGE );

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	or	eax, 8
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 880  : 			cl->netchan.cleartime = 0.0;	// don't choke this message

	mov	edx, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [edx+616], xmm0

; 881  : 		}

	jmp	SHORT $LN15@SV_SendCli
$LN12@SV_SendCli:

; 882  : 		else if( FBitSet( cl->flags, FCL_SEND_NET_MESSAGE ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 8
	je	SHORT $LN15@SV_SendCli

; 883  : 		{
; 884  : 			// If we haven't gotten a message in sv_failuretime seconds, then stop sending messages to this client
; 885  : 			// until we get another packet in from the client. This prevents crash/drop and reconnect where they are
; 886  : 			// being hosed with "sequenced packet without connection" packets.
; 887  : 			if( sv_failuretime.value < ( host.realtime - cl->netchan.last_received ))

	cvtss2sd xmm0, DWORD PTR _sv_failuretime+12
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm1, QWORD PTR _host+1440
	subsd	xmm1, QWORD PTR [edx+592]
	comisd	xmm1, xmm0
	jbe	SHORT $LN15@SV_SendCli

; 888  : 				ClearBits( cl->flags, FCL_SEND_NET_MESSAGE );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN15@SV_SendCli:

; 889  : 		}
; 890  : 
; 891  : 		// only send messages if the client has sent one
; 892  : 		// and the bandwidth is not choked
; 893  : 		if( FBitSet( cl->flags, FCL_SEND_NET_MESSAGE ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 8
	je	$LN19@SV_SendCli

; 894  : 		{
; 895  : 			// bandwidth choke active?
; 896  : 			if( !Netchan_CanPacket( &cl->netchan, cl->state == cs_spawned ))

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN21@SV_SendCli
	mov	DWORD PTR tv168[ebp], 1
	jmp	SHORT $LN22@SV_SendCli
$LN21@SV_SendCli:
	mov	DWORD PTR tv168[ebp], 0
$LN22@SV_SendCli:
	mov	eax, DWORD PTR tv168[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CanPacket
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@SV_SendCli

; 897  : 			{
; 898  : 				cl->chokecount++;

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264360]
	add	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+264360], eax

; 899  : 				continue;

	jmp	$LN2@SV_SendCli
$LN17@SV_SendCli:

; 900  : 			}
; 901  : 
; 902  : 			// now that we were able to send, reset timer to point to next possible send time.
; 903  : 			cl->next_messagetime = host.realtime + sv.frametime + cl->cl_updaterate;

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _host+1440
	mov	edx, DWORD PTR _cl$[ebp]
	addsd	xmm0, QWORD PTR [edx+264392]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264368], xmm0

; 904  : 			ClearBits( cl->flags, FCL_SEND_NET_MESSAGE );

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+40], edx

; 905  : 
; 906  : 			// NOTE: we should send frame even if server is not simulated to prevent overflow
; 907  : 			if( cl->state == cs_spawned )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN18@SV_SendCli

; 908  : 				SV_SendClientDatagram( cl );

	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_SendClientDatagram
	add	esp, 4
	jmp	SHORT $LN19@SV_SendCli
$LN18@SV_SendCli:

; 909  : 			else Netchan_TransmitBits( &cl->netchan, 0, NULL ); // just update reliable

	push	0
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN19@SV_SendCli:

; 910  : 		}
; 911  : 	}

	jmp	$LN2@SV_SendCli
$LN3@SV_SendCli:

; 912  : 
; 913  : 	// reset current client
; 914  : 	sv.current_client = NULL;

	mov	DWORD PTR _sv+40, 0
$LN1@SV_SendCli:

; 915  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendClientMessages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetBuf
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetBuf PROC					; COMDAT

; 107  : _inline byte *MSG_GetBuf( sizebuf_t *sb ) { return sb->pData; } // just an alias

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetBuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 106  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesLeft PROC				; COMDAT

; 105  : _inline int MSG_GetNumBytesLeft( sizebuf_t *sb ) { return MSG_GetNumBitsLeft( sb ) >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetNumBytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 101  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 99   : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetName
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetName PROC					; COMDAT

; 64   : _inline const char *MSG_GetName( sizebuf_t *sb ) { return sb->pDebugName; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	ebp
	ret	0
_MSG_GetName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
