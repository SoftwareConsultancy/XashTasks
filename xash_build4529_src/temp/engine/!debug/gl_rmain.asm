; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\client\gl_rmain.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CL_GenericHandle
PUBLIC	_GL_TextureData
EXTRN	_GL_CleanUpTextureUnits:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_SetTexCoordArrayMode:PROC
EXTRN	_GL_LoadTexMatrixExt:PROC
EXTRN	_GL_TexGen:PROC
EXTRN	_GL_SelectTexture:PROC
EXTRN	_GL_LoadIdentityTexMatrix:PROC
EXTRN	_GL_TextureTarget:PROC
EXTRN	_R_DecalSetupVerts:PROC
EXTRN	_DrawSingleDecal:PROC
EXTRN	_R_EntityRemoveDecals:PROC
EXTRN	_R_UploadStretchRaw:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_LoadTextureArray:PROC
EXTRN	_GL_CreateTexture:PROC
EXTRN	_GL_CreateTextureArray:PROC
EXTRN	_GL_UpdateTexSize:PROC
EXTRN	_GL_FindTexture:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_StoreEfrags:PROC
EXTRN	_R_LightVec:PROC
EXTRN	_R_StudioGetTexture:PROC
EXTRN	_GL_GetProcAddress:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_SaveFile:PROC
EXTRN	_pfnTime:PROC
EXTRN	_AVI_GetVideoFrameNumber:PROC
EXTRN	_AVI_GetVideoFrame:PROC
EXTRN	_AVI_GetVideoInfo:PROC
EXTRN	_AVI_LoadVideo:PROC
EXTRN	_AVI_IsActive:PROC
EXTRN	_AVI_FreeVideo:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_pfnSPR_LoadExt:PROC
EXTRN	_COM_SetRandomSeed:PROC
EXTRN	_CL_DrawParticlesExternal:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_S_StreamAviSamples:PROC
EXTRN	_S_FadeMusicVolume:PROC
_DATA	SEGMENT
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_RI:BYTE:01320H
COMM	_gldepthmin:DWORD
COMM	_gldepthmax:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
_DATA	ENDS
PUBLIC	_R_ClearScene
PUBLIC	_R_LoadIdentity
PUBLIC	_R_RenderScene
PUBLIC	_R_DrawCubemapView
PUBLIC	_R_SetupRefParams
PUBLIC	_R_TranslateForEntity
PUBLIC	_R_RotateForEntity
PUBLIC	_R_SetupGL
PUBLIC	_R_InitRenderAPI
PUBLIC	_R_AllowFog
PUBLIC	_R_SetupFrustum
PUBLIC	_R_FindViewLeaf
PUBLIC	_R_CheckGamma
PUBLIC	_R_PushScene
PUBLIC	_R_PopScene
PUBLIC	_R_DrawFog
PUBLIC	_R_BeginFrame
PUBLIC	_R_RenderFrame
PUBLIC	_R_EndFrame
PUBLIC	_R_WorldToScreen
PUBLIC	_R_ScreenToWorld
PUBLIC	_R_AddEntity
PUBLIC	_R_DrawEntitiesOnList
PUBLIC	_R_DoResetGamma
PUBLIC	__real@00000000
PUBLIC	__real@37d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f91df46aaaaaaab
PUBLIC	__real@3f9eb851eb851eb8
PUBLIC	__real@3fdd70a4
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe66666
PUBLIC	__real@3fef0a3d70a3d70a
PUBLIC	__real@3ff07ae147ae147b
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@40490fdb
PUBLIC	__real@4076800000000000
PUBLIC	__real@42b40000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@45000000
PUBLIC	__real@47c35000
PUBLIC	__real@4e6e6b28
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Search:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_CL_ExtraUpdate:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_BuildGammaTable:PROC
EXTRN	_atan:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_Matrix4x4_ConcatTransforms:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_Invert_Full:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_Mod_SampleSizeForFace:PROC
EXTRN	_CL_IsDevOverviewMode:PROC
EXTRN	_CL_GetWaterEntity:PROC
EXTRN	_CL_FxBlend:PROC
EXTRN	_CL_DrawParticles:PROC
EXTRN	_CL_DrawTracers:PROC
EXTRN	_CL_DrawBeams:PROC
EXTRN	_GL_FrustumInitProj:PROC
EXTRN	_GL_FrustumInitOrtho:PROC
EXTRN	_GL_LoadMatrix:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_Set2DMode:PROC
EXTRN	_R_SetTextureParameters:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_TexMemory:PROC
EXTRN	_R_PushDlights:PROC
EXTRN	_Matrix4x4_Concat:PROC
EXTRN	_Matrix4x4_ConcatTranslate:PROC
EXTRN	_Matrix4x4_ConcatRotate:PROC
EXTRN	_Matrix4x4_CreateProjection:PROC
EXTRN	_Matrix4x4_CreateOrtho:PROC
EXTRN	_Matrix4x4_CreateModelview:PROC
EXTRN	_R_MarkLeaves:PROC
EXTRN	_R_DrawWorld:PROC
EXTRN	_R_DrawWaterSurfaces:PROC
EXTRN	_R_DrawBrushModel:PROC
EXTRN	_R_DrawAlphaTextureChains:PROC
EXTRN	_GL_RebuildLightmaps:PROC
EXTRN	_R_DrawSpriteModel:PROC
EXTRN	_R_GetEntityRenderMode:PROC
EXTRN	_R_DrawStudioModel:PROC
EXTRN	_R_GatherPlayerLight:PROC
EXTRN	_R_DrawAliasModel:PROC
EXTRN	_GL_CheckForErrors_:PROC
EXTRN	_GL_UpdateSwapInterval:PROC
EXTRN	_GL_MaxTextureUnits:PROC
EXTRN	_R_RunViewmodelEvents:PROC
EXTRN	_R_DrawViewModel:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_matrix4x4_identity:BYTE
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_r_stats:BYTE
EXTRN	_tr:BYTE
EXTRN	_cl_dlights:BYTE
EXTRN	_cl_elights:BYTE
EXTRN	_glConfig:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	_gl_texture_anisotropy:DWORD
EXTRN	_gl_texture_lodbias:DWORD
EXTRN	_gl_texture_nearest:DWORD
EXTRN	_gl_lightmap_nearest:DWORD
EXTRN	_gl_finish:DWORD
EXTRN	_gl_nosort:DWORD
EXTRN	_gl_clear:DWORD
EXTRN	_gl_msaa:DWORD
EXTRN	_r_norefresh:DWORD
EXTRN	_r_drawentities:DWORD
EXTRN	_r_lockfrustum:DWORD
EXTRN	_vid_brightness:DWORD
EXTRN	_vid_gamma:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?viewPoint@?1??R_EnvShot@@9@9 DD 03H DUP (?)		; `R_EnvShot'::`2'::viewPoint
?t@?1??pfnGetFilesList@@9@9 DD 01H DUP (?)		; `pfnGetFilesList'::`2'::t
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4e6e6b28
CONST	SEGMENT
__real@4e6e6b28 DD 04e6e6b28r			; 1e+09
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff07ae147ae147b
CONST	SEGMENT
__real@3ff07ae147ae147b DQ 03ff07ae147ae147br	; 1.03
CONST	ENDS
;	COMDAT __real@3fef0a3d70a3d70a
CONST	SEGMENT
__real@3fef0a3d70a3d70a DQ 03fef0a3d70a3d70ar	; 0.97
CONST	ENDS
;	COMDAT __real@3fe66666
CONST	SEGMENT
__real@3fe66666 DD 03fe66666r			; 1.8
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fdd70a4
CONST	SEGMENT
__real@3fdd70a4 DD 03fdd70a4r			; 1.73
CONST	ENDS
;	COMDAT __real@3f9eb851eb851eb8
CONST	SEGMENT
__real@3f9eb851eb851eb8 DQ 03f9eb851eb851eb8r	; 0.03
CONST	ENDS
;	COMDAT __real@3f91df46aaaaaaab
CONST	SEGMENT
__real@3f91df46aaaaaaab DQ 03f91df46aaaaaaabr	; 0.0174533
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@37d1b717
CONST	SEGMENT
__real@37d1b717 DD 037d1b717r			; 2.5e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG143602 DB	'draw stack overflow', 0aH, 00H
	ORG $+3
$SG143606 DB	'draw stack underflow', 0aH, 00H
	ORG $+2
$SG143738 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143739 DB	'node != NULL', 00H
	ORG $+3
$SG143821 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143822 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143823 DB	'RI.currententity != NULL', 00H
	ORG $+3
$SG143825 DB	'RI.currentmodel != NULL', 00H
$SG143833 DB	'RI.currententity != NULL', 00H
	ORG $+3
$SG143824 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143830 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143831 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143832 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143834 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143835 DB	'RI.currentmodel != NULL', 00H
$SG143837 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143839 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143841 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143845 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143846 DB	'RI.currententity != NULL', 00H
	ORG $+3
$SG143848 DB	'RI.currentmodel != NULL', 00H
$SG143940 DB	'arg >= 0 && arg < 6', 00H
$SG143847 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143854 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143856 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143858 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143860 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG143864 DB	'R_RenderView: NULL worldmodel', 0aH, 00H
	ORG $+1
$SG143907 DB	'failed to swap buffers', 0aH, 'Check your video driver a'
	DB	'nd as possible of reinstall it', 00H
	ORG $+1
$SG143939 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG144015 DB	'Sky', 00H
$SG144016 DB	'Env', 00H
$SG144017 DB	'^1Error:^7 R_%sShot: subsystem is busy, try for next fra'
	DB	'me.', 0aH, 00H
	ORG $+3
$SG144048 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG144049 DB	'number >= 0 && number < MAX_LIGHTSTYLES', 00H
$SG144055 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG144056 DB	'number >= 0 && number < MAX_DLIGHTS', 00H
$SG144063 DB	'number >= 0 && number < MAX_ELIGHTS', 00H
$SG144062 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
$SG144111 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_rmain.c', 00H
	ORG $+3
_gRenderAPI DD	FLAT:_GL_RenderGetParm
	DD	FLAT:_R_GetDetailScaleForTexture
	DD	FLAT:_R_GetExtraParmsForTexture
	DD	FLAT:_CL_GetLightStyle
	DD	FLAT:_CL_GetDynamicLight
	DD	FLAT:_CL_GetEntityLight
	DD	FLAT:_LightToTexGamma
	DD	FLAT:_R_GetFrameTime
	DD	FLAT:_R_SetCurrentEntity
	DD	FLAT:_R_SetCurrentModel
	DD	FLAT:_R_FatPVS
	DD	FLAT:_R_StoreEfrags
	DD	FLAT:_GL_FindTexture
	DD	FLAT:_GL_TextureName
	DD	FLAT:_GL_TextureData
	DD	FLAT:_GL_LoadTexture
	DD	FLAT:_GL_CreateTexture
	DD	FLAT:_GL_LoadTextureArray
	DD	FLAT:_GL_CreateTextureArray
	DD	FLAT:_GL_FreeTexture
	DD	FLAT:_DrawSingleDecal
	DD	FLAT:_R_DecalSetupVerts
	DD	FLAT:_R_EntityRemoveDecals
	DD	FLAT:_AVI_LoadVideo
	DD	FLAT:_AVI_GetVideoInfo
	DD	FLAT:_AVI_GetVideoFrameNumber
	DD	FLAT:_AVI_GetVideoFrame
	DD	FLAT:_R_UploadStretchRaw
	DD	FLAT:_AVI_FreeVideo
	DD	FLAT:_AVI_IsActive
	DD	FLAT:_S_StreamAviSamples
	DD	00H
	DD	00H
	DD	FLAT:_GL_Bind
	DD	FLAT:_GL_SelectTexture
	DD	FLAT:_GL_LoadTexMatrixExt
	DD	FLAT:_GL_LoadIdentityTexMatrix
	DD	FLAT:_GL_CleanUpTextureUnits
	DD	FLAT:_GL_TexGen
	DD	FLAT:_GL_TextureTarget
	DD	FLAT:_GL_SetTexCoordArrayMode
	DD	FLAT:_GL_GetProcAddress
	DD	FLAT:_GL_UpdateTexSize
	DD	00H
	DD	00H
	DD	FLAT:_CL_DrawParticlesExternal
	DD	FLAT:_R_EnvShot
	DD	FLAT:_pfnSPR_LoadExt
	DD	FLAT:_R_LightVec
	DD	FLAT:_R_StudioGetTexture
	DD	FLAT:_GL_GetOverviewParms
	DD	FLAT:_CL_GenericHandle
	DD	FLAT:_COM_SaveFile
	DD	00H
	DD	FLAT:_R_Mem_Alloc
	DD	FLAT:_R_Mem_Free
	DD	FLAT:_pfnGetFilesList
	DD	FLAT:_pfnFileBufferCRC32
	DD	FLAT:_COM_CompareFileTime
	DD	FLAT:_Host_Error
	DD	FLAT:_CL_ModelHandle
	DD	FLAT:_pfnTime
	DD	FLAT:_Cvar_Set
	DD	FLAT:_S_FadeMusicVolume
	DD	FLAT:_COM_SetRandomSeed
$SG144140 DB	'CL_LoadProgs: ^2initailized extended RenderAPI ^7ver. %i'
	DB	0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_fileindex$ = 8						; size = 4
_CL_GenericHandle PROC

; 1461 : {

	push	ebp
	mov	ebp, esp

; 1462 : 	if( fileindex < 0 || fileindex >= MAX_CUSTOM )

	cmp	DWORD PTR _fileindex$[ebp], 0
	jl	SHORT $LN3@CL_Generic
	cmp	DWORD PTR _fileindex$[ebp], 1024	; 00000400H
	jl	SHORT $LN2@CL_Generic
$LN3@CL_Generic:

; 1463 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CL_Generic
$LN2@CL_Generic:

; 1464 : 	return cl.files_precache[fileindex];

	mov	eax, DWORD PTR _fileindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _cl+1787208
$LN1@CL_Generic:

; 1465 : }

	pop	ebp
	ret	0
_CL_GenericHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_modelCRC$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
_pfnFileBufferCRC32 PROC

; 1443 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1444 : 	uint	modelCRC = 0;

	mov	DWORD PTR _modelCRC$[ebp], 0

; 1445 : 
; 1446 : 	if( !buffer || length <= 0 )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@pfnFileBuf
	cmp	DWORD PTR _length$[ebp], 0
	jg	SHORT $LN2@pfnFileBuf
$LN3@pfnFileBuf:

; 1447 : 		return modelCRC;

	mov	eax, DWORD PTR _modelCRC$[ebp]
	jmp	SHORT $LN1@pfnFileBuf
$LN2@pfnFileBuf:

; 1448 : 
; 1449 : 	CRC32_Init( &modelCRC );

	lea	eax, DWORD PTR _modelCRC$[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4

; 1450 : 	CRC32_ProcessBuffer( &modelCRC, buffer, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	lea	eax, DWORD PTR _modelCRC$[ebp]
	push	eax
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 1451 : 	return CRC32_Final( modelCRC );

	mov	ecx, DWORD PTR _modelCRC$[ebp]
	push	ecx
	call	_CRC32_Final
	add	esp, 4
$LN1@pfnFileBuf:

; 1452 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFileBufferCRC32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_numFiles$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_pfnGetFilesList PROC

; 1425 : {

	push	ebp
	mov	ebp, esp

; 1426 : 	static search_t	*t = NULL;
; 1427 : 
; 1428 : 	if( t ) Mem_Free( t ); // release prev search

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	je	SHORT $LN2@pfnGetFile
	push	1428					; 00000594H
	push	OFFSET $SG144111
	mov	eax, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@pfnGetFile:

; 1429 : 
; 1430 : 	t = FS_Search( pattern, true, gamedironly );

	mov	ecx, DWORD PTR _gamedironly$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _pattern$[ebp]
	push	edx
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, eax

; 1431 : 
; 1432 : 	if( !t )

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	jne	SHORT $LN3@pfnGetFile

; 1433 : 	{
; 1434 : 		if( numFiles ) *numFiles = 0;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN4@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@pfnGetFile:

; 1435 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetFile
$LN3@pfnGetFile:

; 1436 : 	}
; 1437 : 
; 1438 : 	if( numFiles ) *numFiles = t->numfilenames;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN5@pfnGetFile
	mov	ecx, DWORD PTR _numFiles$[ebp]
	mov	edx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN5@pfnGetFile:

; 1439 : 	return t->filenames;

	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	eax, DWORD PTR [ecx+4]
$LN1@pfnGetFile:

; 1440 : }

	pop	ebp
	ret	0
_pfnGetFilesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_R_Mem_Free PROC

; 1413 : {

	push	ebp
	mov	ebp, esp

; 1414 : 	if( !mem ) return;

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN2@R_Mem_Free
	jmp	SHORT $LN1@R_Mem_Free
$LN2@R_Mem_Free:

; 1415 : 	_Mem_Free( mem, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@R_Mem_Free:

; 1416 : }

	pop	ebp
	ret	0
_R_Mem_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_cb$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_R_Mem_Alloc PROC

; 1408 : {

	push	ebp
	mov	ebp, esp

; 1409 : 	return _Mem_Alloc( cls.mempool, cb, true, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H

; 1410 : }

	pop	ebp
	ret	0
_R_Mem_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_GL_GetOverviewParms PROC

; 1403 : {

	push	ebp
	mov	ebp, esp

; 1404 : 	return &clgame.overView;

	mov	eax, OFFSET _clgame+125416

; 1405 : }

	pop	ebp
	ret	0
_GL_GetOverviewParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_texnum$ = 8						; size = 4
_GL_TextureName PROC

; 1389 : {

	push	ebp
	mov	ebp, esp

; 1390 : 	return R_GetTexture( texnum )->name;	

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4

; 1391 : }

	pop	ebp
	ret	0
_GL_TextureName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_R_GetFrameTime PROC

; 1384 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1385 : 	return tr.frametime;

	cvtsd2ss xmm0, QWORD PTR _tr+66968
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetFrameTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_number$ = 8						; size = 4
_CL_GetEntityLight PROC

; 1378 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1379 : 	Assert( number >= 0 && number < MAX_ELIGHTS );

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN3@CL_GetEnti
	cmp	DWORD PTR _number$[ebp], 64		; 00000040H
	jge	SHORT $LN3@CL_GetEnti
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_GetEnti
$LN3@CL_GetEnti:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_GetEnti:
	push	0
	push	1379					; 00000563H
	push	OFFSET $SG144062
	push	OFFSET $SG144063
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1380 : 	return &cl_elights[number];

	imul	eax, DWORD PTR _number$[ebp], 40
	add	eax, OFFSET _cl_elights

; 1381 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetEntityLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_number$ = 8						; size = 4
_CL_GetDynamicLight PROC

; 1372 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1373 : 	Assert( number >= 0 && number < MAX_DLIGHTS );

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN3@CL_GetDyna
	cmp	DWORD PTR _number$[ebp], 32		; 00000020H
	jge	SHORT $LN3@CL_GetDyna
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_GetDyna
$LN3@CL_GetDyna:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_GetDyna:
	push	0
	push	1373					; 0000055dH
	push	OFFSET $SG144055
	push	OFFSET $SG144056
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1374 : 	return &cl_dlights[number];

	imul	eax, DWORD PTR _number$[ebp], 40
	add	eax, OFFSET _cl_dlights

; 1375 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetDynamicLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_number$ = 8						; size = 4
_CL_GetLightStyle PROC

; 1366 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1367 : 	Assert( number >= 0 && number < MAX_LIGHTSTYLES );

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN3@CL_GetLigh
	cmp	DWORD PTR _number$[ebp], 64		; 00000040H
	jge	SHORT $LN3@CL_GetLigh
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_GetLigh
$LN3@CL_GetLigh:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_GetLigh:
	push	0
	push	1367					; 00000557H
	push	OFFSET $SG144048
	push	OFFSET $SG144049
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1368 : 	return &cl.lightstyles[number];

	imul	eax, DWORD PTR _number$[ebp], 1296
	add	eax, OFFSET _cl+1852744

; 1369 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_visbuffer$ = 16					; size = 4
_merge$ = 20						; size = 4
_fullvis$ = 24						; size = 4
_R_FatPVS PROC

; 1361 : {

	push	ebp
	mov	ebp, esp

; 1362 : 	return Mod_FatPVS( org, radius, visbuffer, world.visbytes, merge, fullvis );

	mov	eax, DWORD PTR _fullvis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _merge$[ebp]
	push	ecx
	mov	edx, DWORD PTR _world+2592
	push	edx
	mov	eax, DWORD PTR _visbuffer$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 1363 : }

	pop	ebp
	ret	0
_R_FatPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_R_SetCurrentModel PROC

; 1356 : {

	push	ebp
	mov	ebp, esp

; 1357 : 	RI.currentmodel = mod;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _RI+32, eax

; 1358 : }

	pop	ebp
	ret	0
_R_SetCurrentModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_R_SetCurrentEntity PROC

; 1345 : {

	push	ebp
	mov	ebp, esp

; 1346 : 	RI.currententity = ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR _RI+28, eax

; 1347 : 
; 1348 : 	// set model also
; 1349 : 	if( RI.currententity != NULL )

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN1@R_SetCurre

; 1350 : 	{
; 1351 : 		RI.currentmodel = RI.currententity->model;

	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+2964]
	mov	DWORD PTR _RI+32, edx
$LN1@R_SetCurre:

; 1352 : 	}
; 1353 : }

	pop	ebp
	ret	0
_R_SetCurrentEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv92 = -8						; size = 4
tv71 = -4						; size = 4
_vieworg$ = 8						; size = 4
_name$ = 12						; size = 4
_skyshot$ = 16						; size = 4
_shotsize$ = 20						; size = 4
_R_EnvShot PROC

; 1312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1313 : 	static vec3_t viewPoint;
; 1314 : 
; 1315 : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@R_EnvShot

; 1316 : 		return; 

	jmp	$LN1@R_EnvShot
$LN2@R_EnvShot:

; 1317 : 
; 1318 : 	if( cls.scrshot_action != scrshot_inactive )

	cmp	DWORD PTR _cls+293060, 0
	je	SHORT $LN3@R_EnvShot

; 1319 : 	{
; 1320 : 		if( cls.scrshot_action != scrshot_skyshot && cls.scrshot_action != scrshot_envshot )

	cmp	DWORD PTR _cls+293060, 6
	je	SHORT $LN4@R_EnvShot
	cmp	DWORD PTR _cls+293060, 5
	je	SHORT $LN4@R_EnvShot

; 1321 : 			Con_Printf( S_ERROR "R_%sShot: subsystem is busy, try for next frame.\n", skyshot ? "Sky" : "Env" );

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN9@R_EnvShot
	mov	DWORD PTR tv71[ebp], OFFSET $SG144015
	jmp	SHORT $LN10@R_EnvShot
$LN9@R_EnvShot:
	mov	DWORD PTR tv71[ebp], OFFSET $SG144016
$LN10@R_EnvShot:
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	push	OFFSET $SG144017
	call	_Con_Printf
	add	esp, 8
$LN4@R_EnvShot:

; 1322 : 		return;

	jmp	$LN1@R_EnvShot
$LN3@R_EnvShot:

; 1323 : 	}
; 1324 : 
; 1325 : 	cls.envshot_vieworg = NULL; // use client view

	mov	DWORD PTR _cls+293064, 0

; 1326 : 	Q_strncpy( cls.shotname, name, sizeof( cls.shotname ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET _cls+293076
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1327 : 
; 1328 : 	if( vieworg )

	cmp	DWORD PTR _vieworg$[ebp], 0
	je	SHORT $LN5@R_EnvShot

; 1329 : 	{
; 1330 : 		// make sure what viewpoint don't temporare
; 1331 : 		VectorCopy( vieworg, viewPoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vieworg$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR ?viewPoint@?1??R_EnvShot@@9@9[eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vieworg$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?viewPoint@?1??R_EnvShot@@9@9[eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vieworg$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR ?viewPoint@?1??R_EnvShot@@9@9[ecx], eax

; 1332 : 		cls.envshot_vieworg = viewPoint;

	mov	DWORD PTR _cls+293064, OFFSET ?viewPoint@?1??R_EnvShot@@9@9

; 1333 : 		cls.envshot_disable_vis = true;

	mov	DWORD PTR _cls+293072, 1
$LN5@R_EnvShot:

; 1334 : 	}
; 1335 : 
; 1336 : 	// make request for envshot
; 1337 : 	if( skyshot ) cls.scrshot_action = scrshot_skyshot;

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN6@R_EnvShot
	mov	DWORD PTR _cls+293060, 6
	jmp	SHORT $LN7@R_EnvShot
$LN6@R_EnvShot:

; 1338 : 	else cls.scrshot_action = scrshot_envshot;

	mov	DWORD PTR _cls+293060, 5
$LN7@R_EnvShot:

; 1339 : 
; 1340 : 	// catch negative values
; 1341 : 	cls.envshot_viewsize = max( 0, shotsize );

	cmp	DWORD PTR _shotsize$[ebp], 0
	jge	SHORT $LN11@R_EnvShot
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN12@R_EnvShot
$LN11@R_EnvShot:
	mov	ecx, DWORD PTR _shotsize$[ebp]
	mov	DWORD PTR tv92[ebp], ecx
$LN12@R_EnvShot:
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _cls+293068, edx
$LN1@R_EnvShot:

; 1342 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_EnvShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_glt$ = -4						; size = 4
_texture$ = 8						; size = 4
_red$ = 12						; size = 4
_green$ = 16						; size = 4
_blue$ = 20						; size = 4
_density$ = 24						; size = 4
_R_GetExtraParmsForTexture PROC

; 1296 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1297 : 	gl_texture_t *glt = R_GetTexture( texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1298 : 
; 1299 : 	if( red ) *red = glt->fogParams[0];

	cmp	DWORD PTR _red$[ebp], 0
	je	SHORT $LN2@R_GetExtra
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _red$[ebp]
	mov	ecx, DWORD PTR _glt$[ebp]
	mov	dl, BYTE PTR [ecx+edx+288]
	mov	BYTE PTR [eax], dl
$LN2@R_GetExtra:

; 1300 : 	if( green ) *green = glt->fogParams[1];

	cmp	DWORD PTR _green$[ebp], 0
	je	SHORT $LN3@R_GetExtra
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _green$[ebp]
	mov	edx, DWORD PTR _glt$[ebp]
	mov	al, BYTE PTR [edx+eax+288]
	mov	BYTE PTR [ecx], al
$LN3@R_GetExtra:

; 1301 : 	if( blue ) *blue = glt->fogParams[2];

	cmp	DWORD PTR _blue$[ebp], 0
	je	SHORT $LN4@R_GetExtra
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _blue$[ebp]
	mov	eax, DWORD PTR _glt$[ebp]
	mov	cl, BYTE PTR [eax+ecx+288]
	mov	BYTE PTR [edx], cl
$LN4@R_GetExtra:

; 1302 : 	if( density ) *density = glt->fogParams[3];

	cmp	DWORD PTR _density$[ebp], 0
	je	SHORT $LN1@R_GetExtra
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _density$[ebp]
	mov	edx, DWORD PTR _glt$[ebp]
	mov	al, BYTE PTR [edx+eax+288]
	mov	BYTE PTR [ecx], al
$LN1@R_GetExtra:

; 1303 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetExtraParmsForTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_glt$ = -4						; size = 4
_texture$ = 8						; size = 4
_xScale$ = 12						; size = 4
_yScale$ = 16						; size = 4
_R_GetDetailScaleForTexture PROC

; 1288 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1289 : 	gl_texture_t *glt = R_GetTexture( texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1290 : 
; 1291 : 	if( xScale ) *xScale = glt->xscale;

	cmp	DWORD PTR _xScale$[ebp], 0
	je	SHORT $LN2@R_GetDetai
	mov	ecx, DWORD PTR _xScale$[ebp]
	mov	edx, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [edx+300]
	mov	DWORD PTR [ecx], eax
$LN2@R_GetDetai:

; 1292 : 	if( yScale ) *yScale = glt->yscale;

	cmp	DWORD PTR _yScale$[ebp], 0
	je	SHORT $LN3@R_GetDetai
	mov	ecx, DWORD PTR _yScale$[ebp]
	mov	edx, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [edx+304]
	mov	DWORD PTR [ecx], eax
$LN3@R_GetDetai:

; 1293 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetDetailScaleForTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv169 = -40						; size = 4
tv167 = -36						; size = 4
tv161 = -32						; size = 4
tv160 = -28						; size = 4
tv147 = -24						; size = 4
tv140 = -20						; size = 4
tv139 = -16						; size = 4
tv133 = -12						; size = 4
tv64 = -8						; size = 4
_glt$ = -4						; size = 4
_parm$ = 8						; size = 4
_arg$ = 12						; size = 4
_GL_RenderGetParm PROC

; 1181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1182 : 	gl_texture_t *glt;
; 1183 : 
; 1184 : 	switch( parm )

	mov	eax, DWORD PTR _parm$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 39			; 00000027H
	ja	$LN2@GL_RenderG
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN61@GL_RenderG[edx*4]
$LN4@GL_RenderG:

; 1185 : 	{
; 1186 : 	case PARM_TEX_WIDTH:
; 1187 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1188 : 		return glt->width;

	mov	ecx, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [ecx+260]
	jmp	$LN1@GL_RenderG
$LN5@GL_RenderG:

; 1189 : 	case PARM_TEX_HEIGHT:
; 1190 : 		glt = R_GetTexture( arg );

	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1191 : 		return glt->height;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+262]
	jmp	$LN1@GL_RenderG
$LN6@GL_RenderG:

; 1192 : 	case PARM_TEX_SRC_WIDTH:
; 1193 : 		glt = R_GetTexture( arg );

	mov	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1194 : 		return glt->srcWidth;

	mov	edx, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [edx+256]
	jmp	$LN1@GL_RenderG
$LN7@GL_RenderG:

; 1195 : 	case PARM_TEX_SRC_HEIGHT:
; 1196 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1197 : 		return glt->srcHeight;

	mov	ecx, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [ecx+258]
	jmp	$LN1@GL_RenderG
$LN8@GL_RenderG:

; 1198 : 	case PARM_TEX_GLFORMAT:
; 1199 : 		glt = R_GetTexture( arg );

	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1200 : 		return glt->format;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+276]
	jmp	$LN1@GL_RenderG
$LN9@GL_RenderG:

; 1201 : 	case PARM_TEX_ENCODE:
; 1202 : 		glt = R_GetTexture( arg );

	mov	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1203 : 		return glt->encode;

	mov	edx, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [edx+280]
	jmp	$LN1@GL_RenderG
$LN10@GL_RenderG:

; 1204 : 	case PARM_TEX_MIPCOUNT:
; 1205 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1206 : 		return glt->numMips;

	mov	ecx, DWORD PTR _glt$[ebp]
	movzx	eax, BYTE PTR [ecx+266]
	jmp	$LN1@GL_RenderG
$LN11@GL_RenderG:

; 1207 : 	case PARM_TEX_DEPTH:
; 1208 : 		glt = R_GetTexture( arg );

	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1209 : 		return glt->depth;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+264]
	jmp	$LN1@GL_RenderG
$LN12@GL_RenderG:

; 1210 : 	case PARM_BSP2_SUPPORTED:
; 1211 : #ifdef SUPPORT_BSP2_FORMAT
; 1212 : 		return 1;
; 1213 : #endif
; 1214 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_RenderG
$LN13@GL_RenderG:

; 1215 : 	case PARM_TEX_SKYBOX:
; 1216 : 		Assert( arg >= 0 && arg < 6 );

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN45@GL_RenderG
	cmp	DWORD PTR _arg$[ebp], 6
	jge	SHORT $LN45@GL_RenderG
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN46@GL_RenderG
$LN45@GL_RenderG:
	mov	DWORD PTR tv133[ebp], 0
$LN46@GL_RenderG:
	push	0
	push	1216					; 000004c0H
	push	OFFSET $SG143939
	push	OFFSET $SG143940
	mov	ecx, DWORD PTR tv133[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1217 : 		return tr.skyboxTextures[arg];

	mov	edx, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _tr[edx*4+1056]
	jmp	$LN1@GL_RenderG
$LN14@GL_RenderG:

; 1218 : 	case PARM_TEX_SKYTEXNUM:
; 1219 : 		return tr.skytexturenum;

	mov	eax, DWORD PTR _tr+1084
	jmp	$LN1@GL_RenderG
$LN15@GL_RenderG:

; 1220 : 	case PARM_TEX_LIGHTMAP:
; 1221 : 		arg = bound( 0, arg, MAX_LIGHTMAPS - 1 );

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN49@GL_RenderG
	cmp	DWORD PTR _arg$[ebp], 255		; 000000ffH
	jge	SHORT $LN47@GL_RenderG
	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN48@GL_RenderG
$LN47@GL_RenderG:
	mov	DWORD PTR tv139[ebp], 255		; 000000ffH
$LN48@GL_RenderG:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv140[ebp], ecx
	jmp	SHORT $LN50@GL_RenderG
$LN49@GL_RenderG:
	mov	DWORD PTR tv140[ebp], 0
$LN50@GL_RenderG:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR _arg$[ebp], edx

; 1222 : 		return tr.lightmapTextures[arg];

	mov	eax, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _tr[eax*4+28]
	jmp	$LN1@GL_RenderG
$LN16@GL_RenderG:

; 1223 : 	case PARM_SKY_SPHERE:
; 1224 : 		return FBitSet( world.flags, FWORLD_SKYSPHERE ) && !FBitSet( world.flags, FWORLD_CUSTOM_SKYBOX );

	mov	ecx, DWORD PTR _world+4
	and	ecx, 1
	je	SHORT $LN51@GL_RenderG
	mov	edx, DWORD PTR _world+4
	and	edx, 2
	jne	SHORT $LN51@GL_RenderG
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN52@GL_RenderG
$LN51@GL_RenderG:
	mov	DWORD PTR tv147[ebp], 0
$LN52@GL_RenderG:
	mov	eax, DWORD PTR tv147[ebp]
	jmp	$LN1@GL_RenderG
$LN17@GL_RenderG:

; 1225 : 	case PARAM_GAMEPAUSED:
; 1226 : 		return cl.paused;

	mov	eax, DWORD PTR _cl+24
	jmp	$LN1@GL_RenderG
$LN18@GL_RenderG:

; 1227 : 	case PARM_WIDESCREEN:
; 1228 : 		return glState.wideScreen;

	mov	eax, DWORD PTR _glState+12
	jmp	$LN1@GL_RenderG
$LN19@GL_RenderG:

; 1229 : 	case PARM_FULLSCREEN:
; 1230 : 		return glState.fullScreen;

	mov	eax, DWORD PTR _glState+8
	jmp	$LN1@GL_RenderG
$LN20@GL_RenderG:

; 1231 : 	case PARM_SCREEN_WIDTH:
; 1232 : 		return glState.width;

	mov	eax, DWORD PTR _glState
	jmp	$LN1@GL_RenderG
$LN21@GL_RenderG:

; 1233 : 	case PARM_SCREEN_HEIGHT:
; 1234 : 		return glState.height;

	mov	eax, DWORD PTR _glState+4
	jmp	$LN1@GL_RenderG
$LN22@GL_RenderG:

; 1235 : 	case PARM_CLIENT_INGAME:
; 1236 : 		return CL_IsInGame();

	call	_CL_IsInGame
	jmp	$LN1@GL_RenderG
$LN23@GL_RenderG:

; 1237 : 	case PARM_MAX_ENTITIES:
; 1238 : 		return clgame.maxEntities;

	mov	eax, DWORD PTR _clgame+1012
	jmp	$LN1@GL_RenderG
$LN24@GL_RenderG:

; 1239 : 	case PARM_TEX_TARGET:
; 1240 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1241 : 		return glt->target;

	mov	ecx, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [ecx+268]
	jmp	$LN1@GL_RenderG
$LN25@GL_RenderG:

; 1242 : 	case PARM_TEX_TEXNUM:
; 1243 : 		glt = R_GetTexture( arg );

	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1244 : 		return glt->texnum;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+272]
	jmp	$LN1@GL_RenderG
$LN26@GL_RenderG:

; 1245 : 	case PARM_TEX_FLAGS:
; 1246 : 		glt = R_GetTexture( arg );

	mov	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1247 : 		return glt->flags;

	mov	edx, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [edx+284]
	jmp	$LN1@GL_RenderG
$LN27@GL_RenderG:

; 1248 : 	case PARM_FEATURES:
; 1249 : 		return host.features;

	mov	eax, DWORD PTR _host+34748
	jmp	$LN1@GL_RenderG
$LN28@GL_RenderG:

; 1250 : 	case PARM_ACTIVE_TMU:
; 1251 : 		return glState.activeTMU;

	mov	eax, DWORD PTR _glState+16
	jmp	$LN1@GL_RenderG
$LN29@GL_RenderG:

; 1252 : 	case PARM_LIGHTSTYLEVALUE:
; 1253 : 		arg = bound( 0, arg, MAX_LIGHTSTYLES - 1 );

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN55@GL_RenderG
	cmp	DWORD PTR _arg$[ebp], 63		; 0000003fH
	jge	SHORT $LN53@GL_RenderG
	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR tv160[ebp], eax
	jmp	SHORT $LN54@GL_RenderG
$LN53@GL_RenderG:
	mov	DWORD PTR tv160[ebp], 63		; 0000003fH
$LN54@GL_RenderG:
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR tv161[ebp], ecx
	jmp	SHORT $LN56@GL_RenderG
$LN55@GL_RenderG:
	mov	DWORD PTR tv161[ebp], 0
$LN56@GL_RenderG:
	mov	edx, DWORD PTR tv161[ebp]
	mov	DWORD PTR _arg$[ebp], edx

; 1254 : 		return tr.lightstylevalue[arg];

	mov	eax, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _tr[eax*4+66708]
	jmp	$LN1@GL_RenderG
$LN30@GL_RenderG:

; 1255 : 	case PARM_MAP_HAS_DELUXE:
; 1256 : 		return FBitSet( world.flags, FWORLD_HAS_DELUXEMAP );

	mov	eax, DWORD PTR _world+4
	and	eax, 8
	jmp	$LN1@GL_RenderG
$LN31@GL_RenderG:

; 1257 : 	case PARM_MAX_IMAGE_UNITS:
; 1258 : 		return GL_MaxTextureUnits();

	call	_GL_MaxTextureUnits
	jmp	$LN1@GL_RenderG
$LN32@GL_RenderG:

; 1259 : 	case PARM_CLIENT_ACTIVE:
; 1260 : 		return (cls.state == ca_active);

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN57@GL_RenderG
	mov	DWORD PTR tv167[ebp], 1
	jmp	SHORT $LN58@GL_RenderG
$LN57@GL_RenderG:
	mov	DWORD PTR tv167[ebp], 0
$LN58@GL_RenderG:
	mov	eax, DWORD PTR tv167[ebp]
	jmp	$LN1@GL_RenderG
$LN33@GL_RenderG:

; 1261 : 	case PARM_REBUILD_GAMMA:
; 1262 : 		return glConfig.softwareGammaUpdate;

	mov	eax, DWORD PTR _glConfig+124
	jmp	$LN1@GL_RenderG
$LN34@GL_RenderG:

; 1263 : 	case PARM_DEDICATED_SERVER:
; 1264 : 		return (host.type == HOST_DEDICATED);

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN59@GL_RenderG
	mov	DWORD PTR tv169[ebp], 1
	jmp	SHORT $LN60@GL_RenderG
$LN59@GL_RenderG:
	mov	DWORD PTR tv169[ebp], 0
$LN60@GL_RenderG:
	mov	eax, DWORD PTR tv169[ebp]
	jmp	SHORT $LN1@GL_RenderG
$LN35@GL_RenderG:

; 1265 : 	case PARM_SURF_SAMPLESIZE:
; 1266 : 		if( arg >= 0 && arg < cl.worldmodel->numsurfaces )

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN36@GL_RenderG
	mov	ecx, DWORD PTR _cl+2686576
	mov	edx, DWORD PTR _arg$[ebp]
	cmp	edx, DWORD PTR [ecx+176]
	jge	SHORT $LN36@GL_RenderG

; 1267 : 			return Mod_SampleSizeForFace( &cl.worldmodel->surfaces[arg] );

	imul	eax, DWORD PTR _arg$[ebp], 92
	mov	ecx, DWORD PTR _cl+2686576
	add	eax, DWORD PTR [ecx+180]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	jmp	SHORT $LN1@GL_RenderG
$LN36@GL_RenderG:

; 1268 : 		return LM_SAMPLE_SIZE;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN1@GL_RenderG
$LN37@GL_RenderG:

; 1269 : 	case PARM_GL_CONTEXT_TYPE:
; 1270 : 		return glConfig.context;

	mov	eax, DWORD PTR _glConfig+116
	jmp	SHORT $LN1@GL_RenderG
$LN38@GL_RenderG:

; 1271 : 	case PARM_GLES_WRAPPER:
; 1272 : 		return glConfig.wrapper;

	mov	eax, DWORD PTR _glConfig+120
	jmp	SHORT $LN1@GL_RenderG
$LN39@GL_RenderG:

; 1273 : 	case PARM_STENCIL_ACTIVE:
; 1274 : 		return glState.stencilEnabled;

	mov	eax, DWORD PTR _glState+572
	jmp	SHORT $LN1@GL_RenderG
$LN40@GL_RenderG:

; 1275 : 	case PARM_WATER_ALPHA:
; 1276 : 		return FBitSet( world.flags, FWORLD_WATERALPHA );

	mov	eax, DWORD PTR _world+4
	and	eax, 4
	jmp	SHORT $LN1@GL_RenderG
$LN41@GL_RenderG:

; 1277 : 	case PARM_TEX_MEMORY:
; 1278 : 		return GL_TexMemory();

	call	_GL_TexMemory
	jmp	SHORT $LN1@GL_RenderG
$LN42@GL_RenderG:

; 1279 : 	case PARM_DELUXEDATA:
; 1280 : 		return *(int *)&world.deluxedata;

	mov	eax, DWORD PTR _world+2584
	jmp	SHORT $LN1@GL_RenderG
$LN43@GL_RenderG:

; 1281 : 	case PARM_SHADOWDATA:
; 1282 : 		return *(int *)&world.shadowdata;

	mov	eax, DWORD PTR _world+2588
	jmp	SHORT $LN1@GL_RenderG
$LN2@GL_RenderG:

; 1283 : 	}
; 1284 : 	return 0;

	xor	eax, eax
$LN1@GL_RenderG:

; 1285 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN61@GL_RenderG:
	DD	$LN4@GL_RenderG
	DD	$LN5@GL_RenderG
	DD	$LN6@GL_RenderG
	DD	$LN7@GL_RenderG
	DD	$LN13@GL_RenderG
	DD	$LN14@GL_RenderG
	DD	$LN15@GL_RenderG
	DD	$LN24@GL_RenderG
	DD	$LN25@GL_RenderG
	DD	$LN26@GL_RenderG
	DD	$LN11@GL_RenderG
	DD	$LN2@GL_RenderG
	DD	$LN8@GL_RenderG
	DD	$LN9@GL_RenderG
	DD	$LN10@GL_RenderG
	DD	$LN12@GL_RenderG
	DD	$LN16@GL_RenderG
	DD	$LN17@GL_RenderG
	DD	$LN30@GL_RenderG
	DD	$LN23@GL_RenderG
	DD	$LN18@GL_RenderG
	DD	$LN19@GL_RenderG
	DD	$LN20@GL_RenderG
	DD	$LN21@GL_RenderG
	DD	$LN22@GL_RenderG
	DD	$LN27@GL_RenderG
	DD	$LN28@GL_RenderG
	DD	$LN29@GL_RenderG
	DD	$LN31@GL_RenderG
	DD	$LN32@GL_RenderG
	DD	$LN33@GL_RenderG
	DD	$LN34@GL_RenderG
	DD	$LN35@GL_RenderG
	DD	$LN37@GL_RenderG
	DD	$LN38@GL_RenderG
	DD	$LN39@GL_RenderG
	DD	$LN40@GL_RenderG
	DD	$LN41@GL_RenderG
	DD	$LN42@GL_RenderG
	DD	$LN43@GL_RenderG
_GL_RenderGetParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_R_DoResetGamma PROC

; 987  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 988  : 	switch( cls.scrshot_action )

	mov	eax, DWORD PTR _cls+293060
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	jl	SHORT $LN5@R_DoResetG
	cmp	DWORD PTR tv64[ebp], 6
	jle	SHORT $LN4@R_DoResetG
	jmp	SHORT $LN5@R_DoResetG
$LN4@R_DoResetG:

; 989  : 	{
; 990  : 	case scrshot_envshot:
; 991  : 	case scrshot_skyshot:
; 992  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_DoResetG
$LN5@R_DoResetG:

; 993  : 	default:
; 994  : 		return false;

	xor	eax, eax
$LN1@R_DoResetG:

; 995  : 	}
; 996  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_DoResetGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv155 = -40						; size = 4
tv229 = -36						; size = 4
tv226 = -32						; size = 4
tv187 = -28						; size = 4
tv152 = -24						; size = 4
tv145 = -20						; size = 4
tv86 = -16						; size = 4
tv79 = -12						; size = 4
tv89 = -8						; size = 4
_i$ = -4						; size = 4
_R_DrawEntitiesOnList PROC

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 802  : 	int	i;
; 803  : 
; 804  : 	tr.blend = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+66976, xmm0

; 805  : 	GL_CheckForErrors();

	push	805					; 00000325H
	push	OFFSET $SG143821
	call	_GL_CheckForErrors_
	add	esp, 8

; 806  : 
; 807  : 	// first draw solid entities
; 808  : 	for( i = 0; i < tr.draw_list->num_solid_entities && !RI.onlyClientDraw; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawEnti
$LN2@R_DrawEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawEnti:
	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24576]
	jae	$LN3@R_DrawEnti
	cmp	DWORD PTR _RI+12, 0
	jne	$LN3@R_DrawEnti

; 809  : 	{
; 810  : 		RI.currententity = tr.draw_list->solid_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _RI+28, edx

; 811  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+2964]
	mov	DWORD PTR _RI+32, ecx

; 812  : 
; 813  : 		Assert( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN36@R_DrawEnti
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN37@R_DrawEnti
$LN36@R_DrawEnti:
	mov	DWORD PTR tv79[ebp], 0
$LN37@R_DrawEnti:
	push	0
	push	813					; 0000032dH
	push	OFFSET $SG143822
	push	OFFSET $SG143823
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 814  : 		Assert( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN38@R_DrawEnti
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN39@R_DrawEnti
$LN38@R_DrawEnti:
	mov	DWORD PTR tv86[ebp], 0
$LN39@R_DrawEnti:
	push	0
	push	814					; 0000032eH
	push	OFFSET $SG143824
	push	OFFSET $SG143825
	mov	eax, DWORD PTR tv86[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 815  : 
; 816  : 		switch( RI.currentmodel->type )

	mov	ecx, DWORD PTR _RI+32
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv89[ebp], edx
	cmp	DWORD PTR tv89[ebp], 0
	je	SHORT $LN17@R_DrawEnti
	cmp	DWORD PTR tv89[ebp], 2
	je	SHORT $LN18@R_DrawEnti
	cmp	DWORD PTR tv89[ebp], 3
	je	SHORT $LN19@R_DrawEnti
	jmp	SHORT $LN20@R_DrawEnti
$LN17@R_DrawEnti:

; 817  : 		{
; 818  : 		case mod_brush:
; 819  : 			R_DrawBrushModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawBrushModel
	add	esp, 4

; 820  : 			break;

	jmp	SHORT $LN5@R_DrawEnti
$LN18@R_DrawEnti:

; 821  : 		case mod_alias:
; 822  : 			R_DrawAliasModel( RI.currententity );

	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_DrawAliasModel
	add	esp, 4

; 823  : 			break;

	jmp	SHORT $LN5@R_DrawEnti
$LN19@R_DrawEnti:

; 824  : 		case mod_studio:
; 825  : 			R_DrawStudioModel( RI.currententity );

	mov	edx, DWORD PTR _RI+28
	push	edx
	call	_R_DrawStudioModel
	add	esp, 4
$LN20@R_DrawEnti:
$LN5@R_DrawEnti:

; 826  : 			break;
; 827  : 		default:
; 828  : 			break;
; 829  : 		}
; 830  : 	}

	jmp	$LN2@R_DrawEnti
$LN3@R_DrawEnti:

; 831  : 
; 832  : 	GL_CheckForErrors();

	push	832					; 00000340H
	push	OFFSET $SG143830
	call	_GL_CheckForErrors_
	add	esp, 8

; 833  : 
; 834  : 	// quake-specific feature
; 835  : 	R_DrawAlphaTextureChains();

	call	_R_DrawAlphaTextureChains

; 836  : 
; 837  : 	GL_CheckForErrors();

	push	837					; 00000345H
	push	OFFSET $SG143831
	call	_GL_CheckForErrors_
	add	esp, 8

; 838  : 
; 839  : 	// draw sprites seperately, because of alpha blending
; 840  : 	for( i = 0; i < tr.draw_list->num_solid_entities && !RI.onlyClientDraw; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@R_DrawEnti
$LN7@R_DrawEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@R_DrawEnti:
	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24576]
	jae	$LN8@R_DrawEnti
	cmp	DWORD PTR _RI+12, 0
	jne	$LN8@R_DrawEnti

; 841  : 	{
; 842  : 		RI.currententity = tr.draw_list->solid_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _RI+28, edx

; 843  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+2964]
	mov	DWORD PTR _RI+32, ecx

; 844  : 
; 845  : 		Assert( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN40@R_DrawEnti
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN41@R_DrawEnti
$LN40@R_DrawEnti:
	mov	DWORD PTR tv145[ebp], 0
$LN41@R_DrawEnti:
	push	0
	push	845					; 0000034dH
	push	OFFSET $SG143832
	push	OFFSET $SG143833
	mov	edx, DWORD PTR tv145[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 846  : 		Assert( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN42@R_DrawEnti
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN43@R_DrawEnti
$LN42@R_DrawEnti:
	mov	DWORD PTR tv152[ebp], 0
$LN43@R_DrawEnti:
	push	0
	push	846					; 0000034eH
	push	OFFSET $SG143834
	push	OFFSET $SG143835
	mov	eax, DWORD PTR tv152[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 847  : 
; 848  : 		switch( RI.currentmodel->type )

	mov	ecx, DWORD PTR _RI+32
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv155[ebp], edx
	cmp	DWORD PTR tv155[ebp], 1
	je	SHORT $LN21@R_DrawEnti
	jmp	SHORT $LN10@R_DrawEnti
$LN21@R_DrawEnti:

; 849  : 		{
; 850  : 		case mod_sprite:
; 851  : 			R_DrawSpriteModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawSpriteModel
	add	esp, 4
$LN10@R_DrawEnti:

; 852  : 			break;
; 853  : 		}
; 854  : 	}

	jmp	$LN7@R_DrawEnti
$LN8@R_DrawEnti:

; 855  : 
; 856  : 	GL_CheckForErrors();

	push	856					; 00000358H
	push	OFFSET $SG143837
	call	_GL_CheckForErrors_
	add	esp, 8

; 857  : 
; 858  : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN22@R_DrawEnti

; 859  :           {
; 860  : 		CL_DrawBeams( false );

	push	0
	call	_CL_DrawBeams
	add	esp, 4
$LN22@R_DrawEnti:

; 861  : 	}
; 862  : 
; 863  : 	GL_CheckForErrors();

	push	863					; 0000035fH
	push	OFFSET $SG143839
	call	_GL_CheckForErrors_
	add	esp, 8

; 864  : 
; 865  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN23@R_DrawEnti

; 866  : 		clgame.dllFuncs.pfnDrawNormalTriangles();

	call	DWORD PTR _clgame+92
$LN23@R_DrawEnti:

; 867  : 
; 868  : 	GL_CheckForErrors();

	push	868					; 00000364H
	push	OFFSET $SG143841
	call	_GL_CheckForErrors_
	add	esp, 8

; 869  : 
; 870  : 	// then draw translucent entities
; 871  : 	for( i = 0; i < tr.draw_list->num_trans_entities && !RI.onlyClientDraw; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@R_DrawEnti
$LN12@R_DrawEnti:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN14@R_DrawEnti:
	mov	edx, DWORD PTR _tr+50272
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24580]
	jae	$LN13@R_DrawEnti
	cmp	DWORD PTR _RI+12, 0
	jne	$LN13@R_DrawEnti

; 872  : 	{
; 873  : 		RI.currententity = tr.draw_list->trans_entities[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _tr+50272
	mov	eax, DWORD PTR [edx+ecx*4+8192]
	mov	DWORD PTR _RI+28, eax

; 874  : 		RI.currentmodel = RI.currententity->model;

	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+2964]
	mov	DWORD PTR _RI+32, edx

; 875  : 
; 876  : 		// handle studiomodels with custom rendermodes on texture
; 877  : 		if( RI.currententity->curstate.rendermode != kRenderNormal )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+760], 0
	je	SHORT $LN24@R_DrawEnti

; 878  : 			tr.blend = CL_FxBlend( RI.currententity ) / 255.0f;

	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_CL_FxBlend
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _tr+66976, xmm0
	jmp	SHORT $LN25@R_DrawEnti
$LN24@R_DrawEnti:

; 879  : 		else tr.blend = 1.0f; // draw as solid but sorted by distance

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+66976, xmm0
$LN25@R_DrawEnti:

; 880  : 
; 881  : 		if( tr.blend <= 0.0f ) continue;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _tr+66976
	jb	SHORT $LN26@R_DrawEnti
	jmp	$LN12@R_DrawEnti
$LN26@R_DrawEnti:

; 882  : 	
; 883  : 		Assert( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN44@R_DrawEnti
	mov	DWORD PTR tv187[ebp], 1
	jmp	SHORT $LN45@R_DrawEnti
$LN44@R_DrawEnti:
	mov	DWORD PTR tv187[ebp], 0
$LN45@R_DrawEnti:
	push	0
	push	883					; 00000373H
	push	OFFSET $SG143845
	push	OFFSET $SG143846
	mov	edx, DWORD PTR tv187[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 884  : 		Assert( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN46@R_DrawEnti
	mov	DWORD PTR tv226[ebp], 1
	jmp	SHORT $LN47@R_DrawEnti
$LN46@R_DrawEnti:
	mov	DWORD PTR tv226[ebp], 0
$LN47@R_DrawEnti:
	push	0
	push	884					; 00000374H
	push	OFFSET $SG143847
	push	OFFSET $SG143848
	mov	eax, DWORD PTR tv226[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 885  : 
; 886  : 		switch( RI.currentmodel->type )

	mov	ecx, DWORD PTR _RI+32
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv229[ebp], edx
	cmp	DWORD PTR tv229[ebp], 3
	ja	SHORT $LN31@R_DrawEnti
	mov	eax, DWORD PTR tv229[ebp]
	jmp	DWORD PTR $LN48@R_DrawEnti[eax*4]
$LN27@R_DrawEnti:

; 887  : 		{
; 888  : 		case mod_brush:
; 889  : 			R_DrawBrushModel( RI.currententity );

	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_DrawBrushModel
	add	esp, 4

; 890  : 			break;

	jmp	SHORT $LN15@R_DrawEnti
$LN28@R_DrawEnti:

; 891  : 		case mod_alias:
; 892  : 			R_DrawAliasModel( RI.currententity );

	mov	edx, DWORD PTR _RI+28
	push	edx
	call	_R_DrawAliasModel
	add	esp, 4

; 893  : 			break;

	jmp	SHORT $LN15@R_DrawEnti
$LN29@R_DrawEnti:

; 894  : 		case mod_studio:
; 895  : 			R_DrawStudioModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawStudioModel
	add	esp, 4

; 896  : 			break;

	jmp	SHORT $LN15@R_DrawEnti
$LN30@R_DrawEnti:

; 897  : 		case mod_sprite:
; 898  : 			R_DrawSpriteModel( RI.currententity );

	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_DrawSpriteModel
	add	esp, 4
$LN31@R_DrawEnti:
$LN15@R_DrawEnti:

; 899  : 			break;
; 900  : 		default:
; 901  : 			break;
; 902  : 		}
; 903  : 	}

	jmp	$LN12@R_DrawEnti
$LN13@R_DrawEnti:

; 904  : 
; 905  : 	GL_CheckForErrors();

	push	905					; 00000389H
	push	OFFSET $SG143854
	call	_GL_CheckForErrors_
	add	esp, 8

; 906  : 
; 907  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN32@R_DrawEnti

; 908  : 	{
; 909  : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 910  : 		clgame.dllFuncs.pfnDrawTransparentTriangles ();

	call	DWORD PTR _clgame+96
$LN32@R_DrawEnti:

; 911  : 	}
; 912  : 
; 913  : 	GL_CheckForErrors();

	push	913					; 00000391H
	push	OFFSET $SG143856
	call	_GL_CheckForErrors_
	add	esp, 8

; 914  : 
; 915  : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN33@R_DrawEnti

; 916  : 	{
; 917  : 		R_AllowFog( false );

	push	0
	call	_R_AllowFog
	add	esp, 4

; 918  : 		CL_DrawBeams( true );

	push	1
	call	_CL_DrawBeams

; 919  : 		CL_DrawParticles( tr.frametime );

	add	esp, -4					; fffffffcH
	movsd	xmm0, QWORD PTR _tr+66968
	movsd	QWORD PTR [esp], xmm0
	call	_CL_DrawParticles

; 920  : 		CL_DrawTracers( tr.frametime );

	movsd	xmm0, QWORD PTR _tr+66968
	movsd	QWORD PTR [esp], xmm0
	call	_CL_DrawTracers
	add	esp, 8

; 921  : 		R_AllowFog( true );

	push	1
	call	_R_AllowFog
	add	esp, 4
$LN33@R_DrawEnti:

; 922  : 	}
; 923  : 
; 924  : 	GL_CheckForErrors();

	push	924					; 0000039cH
	push	OFFSET $SG143858
	call	_GL_CheckForErrors_
	add	esp, 8

; 925  : 
; 926  : 	pglDisable( GL_BLEND );	// Trinity Render issues

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 927  : 
; 928  : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN34@R_DrawEnti

; 929  : 		R_DrawViewModel();

	call	_R_DrawViewModel
$LN34@R_DrawEnti:

; 930  : 	CL_ExtraUpdate();

	call	_CL_ExtraUpdate

; 931  : 
; 932  : 	GL_CheckForErrors();

	push	932					; 000003a4H
	push	OFFSET $SG143860
	call	_GL_CheckForErrors_
	add	esp, 8

; 933  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@R_DrawEnti:
	DD	$LN27@R_DrawEnti
	DD	$LN30@R_DrawEnti
	DD	$LN28@R_DrawEnti
	DD	$LN29@R_DrawEnti
_R_DrawEntitiesOnList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_CheckGLFog PROC

; 765  : {

	push	ebp
	mov	ebp, esp

; 766  : #ifdef HACKS_RELATED_HLMODS
; 767  : 	if(( !RI.fogEnabled && !RI.fogCustom ) && pglIsEnabled( GL_FOG ) && VectorIsNull( RI.fogColor ))

	cmp	DWORD PTR _RI+316, 0
	jne	$LN2@R_CheckGLF
	cmp	DWORD PTR _RI+312, 0
	jne	$LN2@R_CheckGLF
	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@R_CheckGLF
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _RI[edx+324]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_CheckGLF
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+324]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_CheckGLF
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[ecx+324]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_CheckGLF

; 768  : 	{
; 769  : 		// fill the fog color from GL-state machine
; 770  : 		pglGetFloatv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglGetFloatv

; 771  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1
$LN2@R_CheckGLF:

; 772  : 	}
; 773  : #endif
; 774  : }

	pop	ebp
	ret	0
_R_CheckGLFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv275 = -36						; size = 8
_count$ = -28						; size = 4
tv272 = -24						; size = 4
_i$ = -20						; size = 4
_cnt$ = -16						; size = 4
_surf$1 = -12						; size = 4
_tex$ = -8						; size = 4
_ent$ = -4						; size = 4
_R_CheckFog PROC

; 654  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 655  : 	cl_entity_t	*ent;
; 656  : 	gl_texture_t	*tex;
; 657  : 	int		i, cnt, count;
; 658  : 
; 659  : 	// quake global fog
; 660  : 	if( CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	$LN5@R_CheckFog

; 661  : 	{
; 662  : 		if( !clgame.movevars.fog_settings )

	cmp	DWORD PTR _clgame+1164, 0
	jne	SHORT $LN6@R_CheckFog

; 663  : 		{
; 664  : 			if( pglIsEnabled( GL_FOG ))

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@R_CheckFog

; 665  : 				pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN7@R_CheckFog:

; 666  : 			RI.fogEnabled = false;

	mov	DWORD PTR _RI+316, 0

; 667  : 			return;

	jmp	$LN15@R_CheckFog
$LN6@R_CheckFog:

; 668  : 		}
; 669  : 
; 670  : 		// quake-style global fog
; 671  : 		RI.fogColor[0] = ((clgame.movevars.fog_settings & 0xFF000000) >> 24) / 255.0f;

	mov	ecx, DWORD PTR _clgame+1164
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	DWORD PTR tv272[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv272[ebp]
	mov	edx, DWORD PTR tv272[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv275[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv275[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _RI[ecx+324], xmm0

; 672  : 		RI.fogColor[1] = ((clgame.movevars.fog_settings & 0xFF0000) >> 16) / 255.0f;

	mov	edx, DWORD PTR _clgame+1164
	and	edx, 16711680				; 00ff0000H
	sar	edx, 16					; 00000010H
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _RI[eax+324], xmm0

; 673  : 		RI.fogColor[2] = ((clgame.movevars.fog_settings & 0xFF00) >> 8) / 255.0f;

	mov	ecx, DWORD PTR _clgame+1164
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _RI[edx+324], xmm0

; 674  : 		RI.fogDensity = ((clgame.movevars.fog_settings & 0xFF) / 255.0f) * 0.01f;

	mov	eax, DWORD PTR _clgame+1164
	and	eax, 255				; 000000ffH
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _RI+340, xmm0

; 675  : 		RI.fogStart = RI.fogEnd = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+348, xmm0
	movss	xmm0, DWORD PTR _RI+348
	movss	DWORD PTR _RI+344, xmm0

; 676  : 		RI.fogColor[3] = 1.0f;

	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RI[edx+324], xmm0

; 677  : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 678  : 		RI.fogEnabled = true;

	mov	DWORD PTR _RI+316, 1

; 679  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1

; 680  : 		return;

	jmp	$LN15@R_CheckFog
$LN5@R_CheckFog:

; 681  : 	}
; 682  : 
; 683  : 	RI.fogEnabled = false;

	mov	DWORD PTR _RI+316, 0

; 684  : 
; 685  : 	if( RI.onlyClientDraw || cl.local.waterlevel < 3 || !RI.drawWorld || !RI.viewleaf )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN9@R_CheckFog
	cmp	DWORD PTR _cl+1568568, 3
	jl	SHORT $LN9@R_CheckFog
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN9@R_CheckFog
	cmp	DWORD PTR _RI+180, 0
	jne	SHORT $LN8@R_CheckFog
$LN9@R_CheckFog:

; 686  : 	{
; 687  : 		if( RI.cached_waterlevel == 3 )

	cmp	DWORD PTR _RI+356, 3
	jne	SHORT $LN11@R_CheckFog

; 688  :                     {
; 689  : 			// in some cases waterlevel jumps from 3 to 1. Catch it
; 690  : 			RI.cached_waterlevel = cl.local.waterlevel;

	mov	eax, DWORD PTR _cl+1568568
	mov	DWORD PTR _RI+356, eax

; 691  : 			RI.cached_contents = CONTENTS_EMPTY;

	mov	DWORD PTR _RI+352, -1

; 692  : 			if( !RI.fogCustom )

	cmp	DWORD PTR _RI+312, 0
	jne	SHORT $LN11@R_CheckFog

; 693  : 			{
; 694  : 				glState.isFogEnabled = false;

	mov	DWORD PTR _glState+564, 0

; 695  : 				pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN11@R_CheckFog:

; 696  : 			}
; 697  : 		}
; 698  : 		return;

	jmp	$LN15@R_CheckFog
$LN8@R_CheckFog:

; 699  : 	}
; 700  : 
; 701  : 	ent = CL_GetWaterEntity( RI.vieworg );

	push	OFFSET _RI+200
	call	_CL_GetWaterEntity
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 702  : 	if( ent && ent->model && ent->model->type == mod_brush && ent->curstate.skin < 0 )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN12@R_CheckFog
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	je	SHORT $LN12@R_CheckFog
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN12@R_CheckFog
	mov	ecx, DWORD PTR _ent$[ebp]
	movsx	edx, WORD PTR [ecx+744]
	test	edx, edx
	jge	SHORT $LN12@R_CheckFog

; 703  : 		cnt = ent->curstate.skin;

	mov	eax, DWORD PTR _ent$[ebp]
	movsx	ecx, WORD PTR [eax+744]
	mov	DWORD PTR _cnt$[ebp], ecx
	jmp	SHORT $LN13@R_CheckFog
$LN12@R_CheckFog:

; 704  : 	else cnt = RI.viewleaf->contents;

	mov	edx, DWORD PTR _RI+180
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cnt$[ebp], eax
$LN13@R_CheckFog:

; 705  : 
; 706  : 	RI.cached_waterlevel = cl.local.waterlevel;

	mov	ecx, DWORD PTR _cl+1568568
	mov	DWORD PTR _RI+356, ecx

; 707  : 
; 708  : 	if( !IsLiquidContents( RI.cached_contents ) && IsLiquidContents( cnt ))

	cmp	DWORD PTR _RI+352, -3			; fffffffdH
	je	$LN14@R_CheckFog
	cmp	DWORD PTR _RI+352, -4			; fffffffcH
	je	$LN14@R_CheckFog
	cmp	DWORD PTR _RI+352, -5			; fffffffbH
	je	$LN14@R_CheckFog
	cmp	DWORD PTR _cnt$[ebp], -3		; fffffffdH
	je	SHORT $LN16@R_CheckFog
	cmp	DWORD PTR _cnt$[ebp], -4		; fffffffcH
	je	SHORT $LN16@R_CheckFog
	cmp	DWORD PTR _cnt$[ebp], -5		; fffffffbH
	jne	$LN14@R_CheckFog
$LN16@R_CheckFog:

; 709  : 	{
; 710  : 		tex = NULL;

	mov	DWORD PTR _tex$[ebp], 0

; 711  : 
; 712  : 		// check for water texture
; 713  : 		if( ent && ent->model && ent->model->type == mod_brush )

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN17@R_CheckFog
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+2964], 0
	je	$LN17@R_CheckFog
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 0
	jne	$LN17@R_CheckFog

; 714  : 		{
; 715  : 			msurface_t	*surf;
; 716  : 	
; 717  : 			count = ent->model->nummodelsurfaces;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR _count$[ebp], ecx

; 718  : 
; 719  : 			for( i = 0, surf = &ent->model->surfaces[ent->model->firstmodelsurface]; i < count; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	imul	ecx, DWORD PTR [edx+112], 92
	add	ecx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$1[ebp], ecx
	jmp	SHORT $LN4@R_CheckFog
$LN2@R_CheckFog:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _surf$1[ebp]
	add	eax, 92					; 0000005cH
	mov	DWORD PTR _surf$1[ebp], eax
$LN4@R_CheckFog:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@R_CheckFog

; 720  : 			{
; 721  : 				if( surf->flags & SURF_DRAWTURB && surf->texinfo && surf->texinfo->texture )

	mov	edx, DWORD PTR _surf$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 16					; 00000010H
	je	SHORT $LN19@R_CheckFog
	mov	ecx, DWORD PTR _surf$1[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN19@R_CheckFog
	mov	edx, DWORD PTR _surf$1[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN19@R_CheckFog

; 722  : 				{
; 723  : 					tex = R_GetTexture( surf->texinfo->texture->gl_texturenum );

	mov	ecx, DWORD PTR _surf$1[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax

; 724  : 					RI.cached_contents = ent->curstate.skin;

	mov	edx, DWORD PTR _ent$[ebp]
	movsx	eax, WORD PTR [edx+744]
	mov	DWORD PTR _RI+352, eax

; 725  : 					break;

	jmp	SHORT $LN3@R_CheckFog
$LN19@R_CheckFog:

; 726  : 				}
; 727  : 			}

	jmp	SHORT $LN2@R_CheckFog
$LN3@R_CheckFog:

; 728  : 		}

	jmp	SHORT $LN20@R_CheckFog
$LN17@R_CheckFog:

; 729  : 		else
; 730  : 		{
; 731  : 			tex = R_RecursiveFindWaterTexture( RI.viewleaf->parent, NULL, false );

	push	0
	push	0
	mov	ecx, DWORD PTR _RI+180
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tex$[ebp], eax

; 732  : 			if( tex ) RI.cached_contents = RI.viewleaf->contents;

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN20@R_CheckFog
	mov	eax, DWORD PTR _RI+180
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _RI+352, ecx
$LN20@R_CheckFog:

; 733  : 		}
; 734  : 
; 735  : 		if( !tex ) return;	// no valid fogs

	cmp	DWORD PTR _tex$[ebp], 0
	jne	SHORT $LN21@R_CheckFog
	jmp	$LN15@R_CheckFog
$LN21@R_CheckFog:

; 736  : 
; 737  : 		// copy fog params
; 738  : 		RI.fogColor[0] = tex->fogParams[0] / 255.0f;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _tex$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+288]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _RI[ecx+324], xmm0

; 739  : 		RI.fogColor[1] = tex->fogParams[1] / 255.0f;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+288]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _RI[edx+324], xmm0

; 740  : 		RI.fogColor[2] = tex->fogParams[2] / 255.0f;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _tex$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+288]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _RI[eax+324], xmm0

; 741  : 		RI.fogDensity = tex->fogParams[3] * 0.000025f;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+288]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@37d1b717
	movss	DWORD PTR _RI+340, xmm0

; 742  : 		RI.fogStart = RI.fogEnd = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+348, xmm0
	movss	xmm0, DWORD PTR _RI+348
	movss	DWORD PTR _RI+344, xmm0

; 743  : 		RI.fogColor[3] = 1.0f;

	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RI[eax+324], xmm0

; 744  : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 745  : 		RI.fogEnabled = true;

	mov	DWORD PTR _RI+316, 1

; 746  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1

; 747  : 	}

	jmp	SHORT $LN15@R_CheckFog
$LN14@R_CheckFog:

; 748  : 	else
; 749  : 	{
; 750  : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 751  : 		RI.fogEnabled = true;

	mov	DWORD PTR _RI+316, 1

; 752  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1
$LN15@R_CheckFog:

; 753  : 	}
; 754  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_CheckFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_c$1 = -24						; size = 4
_pleaf$2 = -20						; size = 4
tv69 = -16						; size = 4
_i$3 = -12						; size = 4
_tex$ = -8						; size = 4
_mark$4 = -4						; size = 4
_node$ = 8						; size = 4
_ignore$ = 12						; size = 4
_down$ = 16						; size = 4
_R_RecursiveFindWaterTexture PROC

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 583  : 	gl_texture_t *tex = NULL;

	mov	DWORD PTR _tex$[ebp], 0

; 584  : 
; 585  : 	// assure the initial node is not null
; 586  : 	// we could check it here, but we would rather check it 
; 587  : 	// outside the call to get rid of one additional recursion level
; 588  : 	Assert( node != NULL );

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN16@R_Recursiv
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN17@R_Recursiv
$LN16@R_Recursiv:
	mov	DWORD PTR tv69[ebp], 0
$LN17@R_Recursiv:
	push	0
	push	588					; 0000024cH
	push	OFFSET $SG143738
	push	OFFSET $SG143739
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 589  : 
; 590  : 	// ignore solid nodes
; 591  : 	if( node->contents == CONTENTS_SOLID )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], -2			; fffffffeH
	jne	SHORT $LN5@R_Recursiv

; 592  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN5@R_Recursiv:

; 593  : 
; 594  : 	if( node->contents < 0 )

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], 0
	jge	$LN6@R_Recursiv

; 595  : 	{
; 596  : 		mleaf_t		*pleaf;
; 597  : 		msurface_t	**mark;
; 598  : 		int		i, c;
; 599  : 
; 600  : 		// ignore non-liquid leaves
; 601  : 		if( node->contents != CONTENTS_WATER && node->contents != CONTENTS_LAVA && node->contents != CONTENTS_SLIME )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -3			; fffffffdH
	je	SHORT $LN7@R_Recursiv
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], -5			; fffffffbH
	je	SHORT $LN7@R_Recursiv
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -4			; fffffffcH
	je	SHORT $LN7@R_Recursiv

; 602  : 			 return NULL;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN7@R_Recursiv:

; 603  : 
; 604  : 		// find texture
; 605  : 		pleaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _pleaf$2[ebp], eax

; 606  : 		mark = pleaf->firstmarksurface;

	mov	ecx, DWORD PTR _pleaf$2[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _mark$4[ebp], edx

; 607  : 		c = pleaf->nummarksurfaces;	

	mov	eax, DWORD PTR _pleaf$2[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _c$1[ebp], ecx

; 608  : 
; 609  : 		for( i = 0; i < c; i++, mark++ )

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@R_Recursiv
$LN2@R_Recursiv:
	mov	edx, DWORD PTR _i$3[ebp]
	add	edx, 1
	mov	DWORD PTR _i$3[ebp], edx
	mov	eax, DWORD PTR _mark$4[ebp]
	add	eax, 4
	mov	DWORD PTR _mark$4[ebp], eax
$LN4@R_Recursiv:
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR _c$1[ebp]
	jge	SHORT $LN3@R_Recursiv

; 610  : 		{
; 611  : 			if( (*mark)->flags & SURF_DRAWTURB && (*mark)->texinfo && (*mark)->texinfo->texture )

	mov	edx, DWORD PTR _mark$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN8@R_Recursiv
	mov	edx, DWORD PTR _mark$4[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@R_Recursiv
	mov	ecx, DWORD PTR _mark$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN8@R_Recursiv

; 612  : 				return R_GetTexture( (*mark)->texinfo->texture->gl_texturenum );

	mov	ecx, DWORD PTR _mark$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	jmp	$LN1@R_Recursiv
$LN8@R_Recursiv:

; 613  : 		}

	jmp	SHORT $LN2@R_Recursiv
$LN3@R_Recursiv:

; 614  : 
; 615  : 		// texture not found
; 616  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN6@R_Recursiv:

; 617  : 	}
; 618  : 
; 619  : 	// this is a regular node
; 620  : 	// traverse children
; 621  : 	if( node->children[0] && ( node->children[0] != ignore ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+ecx+40], 0
	je	SHORT $LN9@R_Recursiv
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	cmp	eax, DWORD PTR _ignore$[ebp]
	je	SHORT $LN9@R_Recursiv

; 622  : 	{
; 623  : 		tex = R_RecursiveFindWaterTexture( node->children[0], node, true );

	push	1
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tex$[ebp], eax

; 624  : 		if( tex ) return tex;

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN9@R_Recursiv
	mov	eax, DWORD PTR _tex$[ebp]
	jmp	SHORT $LN1@R_Recursiv
$LN9@R_Recursiv:

; 625  : 	}
; 626  : 
; 627  : 	if( node->children[1] && ( node->children[1] != ignore ))

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+eax+40], 0
	je	SHORT $LN11@R_Recursiv
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	cmp	ecx, DWORD PTR _ignore$[ebp]
	je	SHORT $LN11@R_Recursiv

; 628  : 	{
; 629  : 		tex = R_RecursiveFindWaterTexture( node->children[1], node, true );

	push	1
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tex$[ebp], eax

; 630  : 		if( tex )	return tex;

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN11@R_Recursiv
	mov	eax, DWORD PTR _tex$[ebp]
	jmp	SHORT $LN1@R_Recursiv
$LN11@R_Recursiv:

; 631  : 	}
; 632  : 
; 633  : 	// for down recursion, return immediately
; 634  : 	if( down ) return NULL;

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN13@R_Recursiv
	xor	eax, eax
	jmp	SHORT $LN1@R_Recursiv
$LN13@R_Recursiv:

; 635  : 
; 636  : 	// texture not found, step up if any
; 637  : 	if( node->parent )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN14@R_Recursiv

; 638  : 		return R_RecursiveFindWaterTexture( node->parent, node, false );

	push	0
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@R_Recursiv
$LN14@R_Recursiv:

; 639  : 
; 640  : 	// top-level node, bail out
; 641  : 	return NULL;

	xor	eax, eax
$LN1@R_Recursiv:

; 642  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RecursiveFindWaterTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_EndGL PROC

; 568  : {

	push	ebp
	mov	ebp, esp

; 569  : 	if( RI.params & RP_CLIPPLANE )

	mov	eax, DWORD PTR _RI
	and	eax, 4
	je	SHORT $LN1@R_EndGL

; 570  : 		pglDisable( GL_CLIP_PLANE0 );

	push	12288					; 00003000H
	call	DWORD PTR _pglDisable
$LN1@R_EndGL:

; 571  : }

	pop	ebp
	ret	0
_R_EndGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_SetupFrame PROC

; 482  : {

	push	ebp
	mov	ebp, esp

; 483  : 	// setup viewplane dist
; 484  : 	RI.viewplanedist = DotProduct( RI.vieworg, RI.vforward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	mulss	xmm0, DWORD PTR _RI[eax+224]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+200]
	mulss	xmm1, DWORD PTR _RI[edx+224]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+200]
	mulss	xmm1, DWORD PTR _RI[ecx+224]
	addss	xmm0, xmm1
	movss	DWORD PTR _RI+4872, xmm0

; 485  : 
; 486  : 	// NOTE: this request is the fps-killer on some NVidia drivers
; 487  : 	glState.isFogEnabled = pglIsEnabled( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	edx, al
	mov	DWORD PTR _glState+564, edx

; 488  : 
; 489  : 	if( !gl_nosort->value )

	mov	eax, DWORD PTR _gl_nosort
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_SetupFra

; 490  : 	{
; 491  : 		// sort translucents entities by rendermode and distance
; 492  : 		qsort( tr.draw_list->trans_entities, tr.draw_list->num_trans_entities, sizeof( cl_entity_t* ), R_TransEntityCompare );

	push	OFFSET _R_TransEntityCompare
	push	4
	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR [ecx+24580]
	push	edx
	mov	eax, DWORD PTR _tr+50272
	add	eax, 8192				; 00002000H
	push	eax
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H
$LN2@R_SetupFra:

; 493  : 	}
; 494  : 
; 495  : 	// current viewleaf
; 496  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN3@R_SetupFra

; 497  : 	{
; 498  : 		RI.isSkyVisible = false; // unknown at this moment

	mov	DWORD PTR _RI+8, 0

; 499  : 		R_FindViewLeaf();

	call	_R_FindViewLeaf
$LN3@R_SetupFra:

; 500  : 	}
; 501  : }

	pop	ebp
	ret	0
_R_SetupFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_m$ = 8							; size = 4
_R_SetupModelviewMatrix PROC

; 388  : {

	push	ebp
	mov	ebp, esp

; 389  : 	Matrix4x4_CreateModelview( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_CreateModelview

; 390  : 	Matrix4x4_ConcatRotate( m, -RI.viewangles[2], 1, 0, 0 );

	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[ecx+212]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	_Matrix4x4_ConcatRotate

; 391  : 	Matrix4x4_ConcatRotate( m, -RI.viewangles[0], 0, 1, 0 );

	add	esp, 16					; 00000010H
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	_Matrix4x4_ConcatRotate

; 392  : 	Matrix4x4_ConcatRotate( m, -RI.viewangles[1], 0, 0, 1 );

	add	esp, 16					; 00000010H
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_Matrix4x4_ConcatRotate
	add	esp, 20					; 00000014H

; 393  : 	Matrix4x4_ConcatTranslate( m, -RI.vieworg[0], -RI.vieworg[1], -RI.vieworg[2] );

	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _RI[edx+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _RI[edx+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_ConcatTranslate
	add	esp, 16					; 00000010H

; 394  : }

	pop	ebp
	ret	0
_R_SetupModelviewMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_xMin$ = -72						; size = 8
_yMin$ = -64						; size = 8
_zFar$ = -56						; size = 8
tv181 = -48						; size = 8
tv173 = -40						; size = 8
_xMax$ = -32						; size = 8
_yMax$ = -24						; size = 8
_zNear$ = -16						; size = 8
tv80 = -8						; size = 4
_ov$1 = -4						; size = 4
_m$ = 8							; size = 4
_R_SetupProjectionMatrix PROC

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 359  : 	GLdouble	xMin, xMax, yMin, yMax, zNear, zFar;
; 360  : 
; 361  : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN2@R_SetupPro

; 362  : 	{
; 363  : 		ref_overview_t *ov = &clgame.overView;

	mov	DWORD PTR _ov$1[ebp], OFFSET _clgame+125416

; 364  : 		Matrix4x4_CreateOrtho( m, ov->xLeft, ov->xRight, ov->yTop, ov->yBottom, ov->zNear, ov->zFar );

	mov	eax, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_CreateOrtho
	add	esp, 28					; 0000001cH

; 365  : 		return;

	jmp	$LN1@R_SetupPro
$LN2@R_SetupPro:

; 366  : 	}
; 367  : 
; 368  : 	RI.farClip = R_GetFarClip();

	call	_R_GetFarClip
	fstp	DWORD PTR _RI+308

; 369  : 
; 370  : 	zNear = 4.0f;

	movsd	xmm0, QWORD PTR __real@4010000000000000
	movsd	QWORD PTR _zNear$[ebp], xmm0

; 371  : 	zFar = max( 256.0f, RI.farClip );

	movss	xmm0, DWORD PTR __real@43800000
	comiss	xmm0, DWORD PTR _RI+308
	jbe	SHORT $LN4@R_SetupPro
	movss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN5@R_SetupPro
$LN4@R_SetupPro:
	movss	xmm0, DWORD PTR _RI+308
	movss	DWORD PTR tv80[ebp], xmm0
$LN5@R_SetupPro:
	cvtss2sd xmm0, DWORD PTR tv80[ebp]
	movsd	QWORD PTR _zFar$[ebp], xmm0

; 372  : 
; 373  : 	yMax = zNear * tan( RI.fov_y * M_PI / 360.0 );

	movss	xmm0, DWORD PTR _RI+24
	mulss	xmm0, DWORD PTR __real@40490fdb
	cvtss2sd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4076800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv173[ebp]
	movsd	xmm0, QWORD PTR tv173[ebp]
	mulsd	xmm0, QWORD PTR _zNear$[ebp]
	movsd	QWORD PTR _yMax$[ebp], xmm0

; 374  : 	yMin = -yMax;

	movsd	xmm0, QWORD PTR _yMax$[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _yMin$[ebp], xmm0

; 375  : 
; 376  : 	xMax = zNear * tan( RI.fov_x * M_PI / 360.0 );

	movss	xmm0, DWORD PTR _RI+20
	mulss	xmm0, DWORD PTR __real@40490fdb
	cvtss2sd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4076800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv181[ebp]
	movsd	xmm0, QWORD PTR tv181[ebp]
	mulsd	xmm0, QWORD PTR _zNear$[ebp]
	movsd	QWORD PTR _xMax$[ebp], xmm0

; 377  : 	xMin = -xMax;

	movsd	xmm0, QWORD PTR _xMax$[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _xMin$[ebp], xmm0

; 378  : 
; 379  : 	Matrix4x4_CreateProjection( m, xMax, xMin, yMax, yMin, zNear, zFar );

	cvtsd2ss xmm0, QWORD PTR _zFar$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _zNear$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _yMin$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _yMax$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _xMin$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _xMax$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_Matrix4x4_CreateProjection
	add	esp, 28					; 0000001cH
$LN1@R_SetupPro:

; 380  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupProjectionMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_R_GetFarClip PROC

; 315  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 316  : 	if( cl.worldmodel && RI.drawWorld )

	cmp	DWORD PTR _cl+2686576, 0
	je	SHORT $LN2@R_GetFarCl
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN2@R_GetFarCl

; 317  : 		return clgame.movevars.zmax * 1.73f;

	movss	xmm0, DWORD PTR _clgame+1084
	mulss	xmm0, DWORD PTR __real@3fdd70a4
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]
	jmp	SHORT $LN1@R_GetFarCl
$LN2@R_GetFarCl:

; 318  : 	return 2048.0f;

	fld	DWORD PTR __real@45000000
$LN1@R_GetFarCl:

; 319  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetFarClip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_bits$ = -4						; size = 4
_bitMask$ = 8						; size = 4
_R_Clear PROC

; 276  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 277  : 	int	bits;
; 278  : 
; 279  : 	if( CL_IsDevOverviewMode( ))

	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN2@R_Clear

; 280  : 		pglClearColor( 0.0f, 1.0f, 0.0f, 1.0f ); // green background (Valve rules)

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglClearColor
	jmp	SHORT $LN3@R_Clear
$LN2@R_Clear:

; 281  : 	else pglClearColor( 0.5f, 0.5f, 0.5f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglClearColor
$LN3@R_Clear:

; 282  : 
; 283  : 	bits = GL_DEPTH_BUFFER_BIT;

	mov	DWORD PTR _bits$[ebp], 256		; 00000100H

; 284  : 
; 285  : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+572, 0
	je	SHORT $LN4@R_Clear

; 286  : 		bits |= GL_STENCIL_BUFFER_BIT;

	mov	eax, DWORD PTR _bits$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _bits$[ebp], eax
$LN4@R_Clear:

; 287  : 
; 288  : 	bits &= bitMask;

	mov	ecx, DWORD PTR _bits$[ebp]
	and	ecx, DWORD PTR _bitMask$[ebp]
	mov	DWORD PTR _bits$[ebp], ecx

; 289  : 
; 290  : 	pglClear( bits );

	mov	edx, DWORD PTR _bits$[ebp]
	push	edx
	call	DWORD PTR _pglClear

; 291  : 
; 292  : 	// change ordering for overview
; 293  : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN5@R_Clear

; 294  : 	{
; 295  : 		gldepthmin = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gldepthmin, xmm0

; 296  : 		gldepthmax = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _gldepthmax, xmm0

; 297  : 	}

	jmp	SHORT $LN6@R_Clear
$LN5@R_Clear:

; 298  : 	else
; 299  : 	{
; 300  : 		gldepthmin = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _gldepthmin, xmm0

; 301  : 		gldepthmax = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gldepthmax, xmm0
$LN6@R_Clear:

; 302  : 	}
; 303  : 
; 304  : 	pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 305  : 	pglDepthRange( gldepthmin, gldepthmax );

	cvtss2sd xmm0, DWORD PTR _gldepthmax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _gldepthmin
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglDepthRange

; 306  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv305 = -76						; size = 4
tv284 = -72						; size = 4
tv260 = -68						; size = 4
tv193 = -64						; size = 4
tv172 = -60						; size = 4
tv148 = -56						; size = 4
_rendermode2$ = -52					; size = 4
_rendermode1$ = -48					; size = 4
_dist1$ = -44						; size = 4
_dist2$ = -40						; size = 4
_ent2$ = -36						; size = 4
_ent1$ = -32						; size = 4
_vecLen$ = -28						; size = 12
_org$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_R_TransEntityCompare PROC

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 81   : 	cl_entity_t	*ent1, *ent2;
; 82   : 	vec3_t		vecLen, org;
; 83   : 	float		dist1, dist2;
; 84   : 	int		rendermode1;
; 85   : 	int		rendermode2;
; 86   : 
; 87   : 	ent1 = (cl_entity_t *)*a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ent1$[ebp], ecx

; 88   : 	ent2 = (cl_entity_t *)*b;

	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ent2$[ebp], eax

; 89   : 	rendermode1 = R_GetEntityRenderMode( ent1 );

	mov	ecx, DWORD PTR _ent1$[ebp]
	push	ecx
	call	_R_GetEntityRenderMode
	add	esp, 4
	mov	DWORD PTR _rendermode1$[ebp], eax

; 90   : 	rendermode2 = R_GetEntityRenderMode( ent2 );

	mov	edx, DWORD PTR _ent2$[ebp]
	push	edx
	call	_R_GetEntityRenderMode
	add	esp, 4
	mov	DWORD PTR _rendermode2$[ebp], eax

; 91   : 
; 92   : 	// sort by distance
; 93   : 	if( ent1->model->type != mod_brush || rendermode1 != kRenderTransAlpha )

	mov	eax, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN4@R_TransEnt
	cmp	DWORD PTR _rendermode1$[ebp], 4
	je	$LN2@R_TransEnt
$LN4@R_TransEnt:

; 94   : 	{
; 95   : 		VectorAverage( ent1->model->mins, ent1->model->maxs, org );

	mov	edx, DWORD PTR _ent1$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [ecx+2964]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx+84]
	addss	xmm0, DWORD PTR [ecx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _ent1$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [ecx+2964]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [edx+eax+84]
	addss	xmm0, DWORD PTR [ecx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent1$[ebp]
	mov	eax, DWORD PTR [eax+2964]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+edx+84]
	addss	xmm0, DWORD PTR [eax+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv148[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _org$[ebp+ecx], xmm0

; 96   : 		VectorAdd( ent1->origin, org, org );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+2888]
	addss	xmm0, DWORD PTR _org$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _org$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent1$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+2888]
	addss	xmm0, DWORD PTR _org$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent1$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+2888]
	addss	xmm0, DWORD PTR _org$[ebp+eax]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _org$[ebp+edx], xmm0

; 97   : 		VectorSubtract( RI.vieworg, org, vecLen );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	subss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0

; 98   : 		dist1 = DotProduct( vecLen, vecLen );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecLen$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecLen$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecLen$[ebp+eax]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist1$[ebp], xmm0

; 99   : 	}

	jmp	SHORT $LN3@R_TransEnt
$LN2@R_TransEnt:

; 100  : 	else dist1 = 1000000000;

	movss	xmm0, DWORD PTR __real@4e6e6b28
	movss	DWORD PTR _dist1$[ebp], xmm0
$LN3@R_TransEnt:

; 101  : 
; 102  : 	if( ent2->model->type != mod_brush || rendermode2 != kRenderTransAlpha )

	mov	edx, DWORD PTR _ent2$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN7@R_TransEnt
	cmp	DWORD PTR _rendermode2$[ebp], 4
	je	$LN5@R_TransEnt
$LN7@R_TransEnt:

; 103  : 	{
; 104  : 		VectorAverage( ent2->model->mins, ent2->model->maxs, org );

	mov	ecx, DWORD PTR _ent2$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent2$[ebp]
	mov	eax, DWORD PTR [eax+2964]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+ecx+84]
	addss	xmm0, DWORD PTR [eax+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, DWORD PTR _ent2$[ebp]
	mov	ecx, DWORD PTR [eax+2964]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent2$[ebp]
	mov	eax, DWORD PTR [eax+2964]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx+84]
	addss	xmm0, DWORD PTR [eax+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _ent2$[ebp]
	mov	eax, DWORD PTR [edx+2964]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent2$[ebp]
	mov	edx, DWORD PTR [edx+2964]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [eax+ecx+84]
	addss	xmm0, DWORD PTR [edx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv260[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv260[ebp]
	movss	DWORD PTR _org$[ebp+eax], xmm0

; 105  : 		VectorAdd( ent2->origin, org, org );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent2$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+2888]
	addss	xmm0, DWORD PTR _org$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent2$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+2888]
	addss	xmm0, DWORD PTR _org$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _org$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent2$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+2888]
	addss	xmm0, DWORD PTR _org$[ebp+edx]
	movss	DWORD PTR tv284[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv284[ebp]
	movss	DWORD PTR _org$[ebp+ecx], xmm0

; 106  : 		VectorSubtract( RI.vieworg, org, vecLen );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecLen$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[edx+200]
	subss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecLen$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[edx+200]
	subss	xmm0, DWORD PTR _org$[ebp+eax]
	movss	DWORD PTR tv305[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv305[ebp]
	movss	DWORD PTR _vecLen$[ebp+ecx], xmm0

; 107  : 		dist2 = DotProduct( vecLen, vecLen );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _vecLen$[ebp+eax]
	mulss	xmm0, DWORD PTR _vecLen$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _vecLen$[ebp+eax]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _vecLen$[ebp+edx]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist2$[ebp], xmm0

; 108  : 	}

	jmp	SHORT $LN6@R_TransEnt
$LN5@R_TransEnt:

; 109  : 	else dist2 = 1000000000;

	movss	xmm0, DWORD PTR __real@4e6e6b28
	movss	DWORD PTR _dist2$[ebp], xmm0
$LN6@R_TransEnt:

; 110  : 
; 111  : 	if( dist1 > dist2 )

	movss	xmm0, DWORD PTR _dist1$[ebp]
	comiss	xmm0, DWORD PTR _dist2$[ebp]
	jbe	SHORT $LN8@R_TransEnt

; 112  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@R_TransEnt
$LN8@R_TransEnt:

; 113  : 	if( dist1 < dist2 )

	movss	xmm0, DWORD PTR _dist2$[ebp]
	comiss	xmm0, DWORD PTR _dist1$[ebp]
	jbe	SHORT $LN9@R_TransEnt

; 114  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_TransEnt
$LN9@R_TransEnt:

; 115  : 
; 116  : 	// then sort by rendermode
; 117  : 	if( R_RankForRenderMode( rendermode1 ) > R_RankForRenderMode( rendermode2 ))

	mov	ecx, DWORD PTR _rendermode1$[ebp]
	push	ecx
	call	_R_RankForRenderMode
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _rendermode2$[ebp]
	push	edx
	call	_R_RankForRenderMode
	add	esp, 4
	cmp	esi, eax
	jle	SHORT $LN10@R_TransEnt

; 118  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_TransEnt
$LN10@R_TransEnt:

; 119  : 	if( R_RankForRenderMode( rendermode1 ) < R_RankForRenderMode( rendermode2 ))

	mov	eax, DWORD PTR _rendermode1$[ebp]
	push	eax
	call	_R_RankForRenderMode
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _rendermode2$[ebp]
	push	ecx
	call	_R_RankForRenderMode
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN11@R_TransEnt

; 120  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@R_TransEnt
$LN11@R_TransEnt:

; 121  : 
; 122  : 	return 0;

	xor	eax, eax
$LN1@R_TransEnt:

; 123  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TransEntityCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_R_OpaqueEntity PROC

; 66   : {

	push	ebp
	mov	ebp, esp

; 67   : 	if( R_GetEntityRenderMode( ent ) == kRenderNormal )

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_R_GetEntityRenderMode
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@R_OpaqueEn

; 68   : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_OpaqueEn
$LN2@R_OpaqueEn:

; 69   : 	return false;

	xor	eax, eax
$LN1@R_OpaqueEn:

; 70   : }

	pop	ebp
	ret	0
_R_OpaqueEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_rendermode$ = 8					; size = 4
_R_RankForRenderMode PROC

; 31   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 32   : 	switch( rendermode )

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN4@R_RankForR
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN6@R_RankForR
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $LN5@R_RankForR
	jmp	SHORT $LN2@R_RankForR
$LN4@R_RankForR:

; 33   : 	{
; 34   : 	case kRenderTransTexture:
; 35   : 		return 1;	// draw second

	mov	eax, 1
	jmp	SHORT $LN1@R_RankForR
$LN5@R_RankForR:

; 36   : 	case kRenderTransAdd:
; 37   : 		return 2;	// draw third

	mov	eax, 2
	jmp	SHORT $LN1@R_RankForR
$LN6@R_RankForR:

; 38   : 	case kRenderGlow:
; 39   : 		return 3;	// must be last!

	mov	eax, 3
	jmp	SHORT $LN1@R_RankForR
$LN2@R_RankForR:

; 40   : 	}
; 41   : 	return 0;

	xor	eax, eax
$LN1@R_RankForR:

; 42   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RankForRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_clent$ = 8						; size = 4
_type$ = 12						; size = 4
_R_AddEntity PROC

; 232  : {

	push	ebp
	mov	ebp, esp

; 233  : 	if( !r_drawentities->value )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_AddEntit

; 234  : 		return false; // not allow to drawing

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN2@R_AddEntit:

; 235  : 
; 236  : 	if( !clent || !clent->model )

	cmp	DWORD PTR _clent$[ebp], 0
	je	SHORT $LN4@R_AddEntit
	mov	ecx, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [ecx+2964], 0
	jne	SHORT $LN3@R_AddEntit
$LN4@R_AddEntit:

; 237  : 		return false; // if set to invisible, skip

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN3@R_AddEntit:

; 238  : 
; 239  : 	if( FBitSet( clent->curstate.effects, EF_NODRAW ))

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [edx+748]
	and	eax, 128				; 00000080H
	je	SHORT $LN5@R_AddEntit

; 240  : 		return false; // done

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN5@R_AddEntit:

; 241  : 
; 242  : 	if( !R_ModelOpaque( clent->curstate.rendermode ) && CL_FxBlend( clent ) <= 0 )

	mov	ecx, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [ecx+760], 0
	je	SHORT $LN6@R_AddEntit
	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	_CL_FxBlend
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN6@R_AddEntit

; 243  : 		return true; // invisible

	mov	eax, 1
	jmp	$LN1@R_AddEntit
$LN6@R_AddEntit:

; 244  : 
; 245  : 	if( type == ET_FRAGMENTED )

	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN7@R_AddEntit

; 246  : 		r_stats.c_client_ents++;

	mov	eax, DWORD PTR _r_stats+44
	add	eax, 1
	mov	DWORD PTR _r_stats+44, eax
$LN7@R_AddEntit:

; 247  : 
; 248  : 	if( R_OpaqueEntity( clent ))

	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	call	_R_OpaqueEntity
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_AddEntit

; 249  : 	{
; 250  : 		// opaque
; 251  : 		if( tr.draw_list->num_solid_entities >= MAX_VISIBLE_PACKET )

	mov	edx, DWORD PTR _tr+50272
	cmp	DWORD PTR [edx+24576], 2048		; 00000800H
	jb	SHORT $LN10@R_AddEntit

; 252  : 			return false;

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN10@R_AddEntit:

; 253  : 
; 254  : 		tr.draw_list->solid_entities[tr.draw_list->num_solid_entities] = clent;

	mov	eax, DWORD PTR _tr+50272
	mov	ecx, DWORD PTR [eax+24576]
	mov	edx, DWORD PTR _tr+50272
	mov	eax, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 255  : 		tr.draw_list->num_solid_entities++;

	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR [ecx+24576]
	add	edx, 1
	mov	eax, DWORD PTR _tr+50272
	mov	DWORD PTR [eax+24576], edx

; 256  : 	}

	jmp	SHORT $LN9@R_AddEntit
$LN8@R_AddEntit:

; 257  : 	else
; 258  : 	{
; 259  : 		// translucent
; 260  : 		if( tr.draw_list->num_trans_entities >= MAX_VISIBLE_PACKET )

	mov	ecx, DWORD PTR _tr+50272
	cmp	DWORD PTR [ecx+24580], 2048		; 00000800H
	jb	SHORT $LN11@R_AddEntit

; 261  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_AddEntit
$LN11@R_AddEntit:

; 262  : 
; 263  : 		tr.draw_list->trans_entities[tr.draw_list->num_trans_entities] = clent;

	mov	edx, DWORD PTR _tr+50272
	mov	eax, DWORD PTR [edx+24580]
	mov	ecx, DWORD PTR _tr+50272
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+eax*4+8192], edx

; 264  : 		tr.draw_list->num_trans_entities++;

	mov	eax, DWORD PTR _tr+50272
	mov	ecx, DWORD PTR [eax+24580]
	add	ecx, 1
	mov	edx, DWORD PTR _tr+50272
	mov	DWORD PTR [edx+24580], ecx
$LN9@R_AddEntit:

; 265  : 	}
; 266  : 
; 267  : 	return true;

	mov	eax, 1
$LN1@R_AddEntit:

; 268  : }

	pop	ebp
	ret	0
_R_AddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv242 = -76						; size = 4
_w$ = -72						; size = 4
_screenToWorld$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_screen$ = 8						; size = 4
_point$ = 12						; size = 4
_R_ScreenToWorld PROC

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 174  : 	matrix4x4	screenToWorld;
; 175  : 	float	w;
; 176  : 
; 177  : 	if( !point || !screen )

	cmp	DWORD PTR _point$[ebp], 0
	je	SHORT $LN3@R_ScreenTo
	cmp	DWORD PTR _screen$[ebp], 0
	jne	SHORT $LN2@R_ScreenTo
$LN3@R_ScreenTo:

; 178  : 		return;

	jmp	$LN4@R_ScreenTo
$LN2@R_ScreenTo:

; 179  : 
; 180  : 	Matrix4x4_Invert_Full( screenToWorld, RI.worldviewProjectionMatrix );

	push	OFFSET _RI+712
	lea	eax, DWORD PTR _screenToWorld$[ebp]
	push	eax
	call	_Matrix4x4_Invert_Full
	add	esp, 8

; 181  : 
; 182  : 	point[0] = screen[0] * screenToWorld[0][0] + screen[1] * screenToWorld[0][1] + screen[2] * screenToWorld[0][2] + screenToWorld[0][3];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 183  : 	point[1] = screen[0] * screenToWorld[1][0] + screen[1] * screenToWorld[1][1] + screen[2] * screenToWorld[1][2] + screenToWorld[1][3];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 184  : 	point[2] = screen[0] * screenToWorld[2][0] + screen[1] * screenToWorld[2][1] + screen[2] * screenToWorld[2][2] + screenToWorld[2][3];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _point$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 185  : 	w = screen[0] * screenToWorld[3][0] + screen[1] * screenToWorld[3][1] + screen[2] * screenToWorld[3][2] + screenToWorld[3][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _w$[ebp], xmm0

; 186  : 	if( w != 0.0f ) VectorScale( point, ( 1.0f / w ), point );

	movss	xmm0, DWORD PTR _w$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@R_ScreenTo
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _point$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _point$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _point$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv242[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR tv242[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN4@R_ScreenTo:

; 187  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ScreenToWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_behind$ = -80						; size = 4
_invw$1 = -76						; size = 4
_w$ = -72						; size = 4
_worldToScreen$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_point$ = 8						; size = 4
_screen$ = 12						; size = 4
_R_WorldToScreen PROC

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 135  : 	matrix4x4	worldToScreen;
; 136  : 	qboolean	behind;
; 137  : 	float	w;
; 138  : 
; 139  : 	if( !point || !screen )

	cmp	DWORD PTR _point$[ebp], 0
	je	SHORT $LN3@R_WorldToS
	cmp	DWORD PTR _screen$[ebp], 0
	jne	SHORT $LN2@R_WorldToS
$LN3@R_WorldToS:

; 140  : 		return true;

	mov	eax, 1
	jmp	$LN1@R_WorldToS
$LN2@R_WorldToS:

; 141  : 
; 142  : 	Matrix4x4_Copy( worldToScreen, RI.worldviewProjectionMatrix );

	push	64					; 00000040H
	push	OFFSET _RI+712
	lea	eax, DWORD PTR _worldToScreen$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 143  : 	screen[0] = worldToScreen[0][0] * point[0] + worldToScreen[0][1] * point[1] + worldToScreen[0][2] * point[2] + worldToScreen[0][3];

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 144  : 	screen[1] = worldToScreen[1][0] * point[0] + worldToScreen[1][1] * point[1] + worldToScreen[1][2] * point[2] + worldToScreen[1][3];

	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 145  : 	w = worldToScreen[3][0] * point[0] + worldToScreen[3][1] * point[1] + worldToScreen[3][2] * point[2] + worldToScreen[3][3];

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [esi+ecx]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _w$[ebp], xmm0

; 146  : 	screen[2] = 0.0f; // just so we have something valid here

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _screen$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 147  : 
; 148  : 	if( w < 0.001f )

	movss	xmm0, DWORD PTR __real@3a83126f
	comiss	xmm0, DWORD PTR _w$[ebp]
	jbe	SHORT $LN4@R_WorldToS

; 149  : 	{
; 150  : 		screen[0] *= 100000;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR __real@47c35000
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 151  : 		screen[1] *= 100000;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@47c35000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 152  : 		behind = true;

	mov	DWORD PTR _behind$[ebp], 1

; 153  : 	}

	jmp	SHORT $LN5@R_WorldToS
$LN4@R_WorldToS:

; 154  : 	else
; 155  : 	{
; 156  : 		float invw = 1.0f / w;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR _invw$1[ebp], xmm0

; 157  : 		screen[0] *= invw;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _invw$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 158  : 		screen[1] *= invw;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _invw$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 159  : 		behind = false;

	mov	DWORD PTR _behind$[ebp], 0
$LN5@R_WorldToS:

; 160  : 	}
; 161  : 
; 162  : 	return behind;

	mov	eax, DWORD PTR _behind$[ebp]
$LN1@R_WorldToS:

; 163  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_WorldToScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_EndFrame PROC

; 1145 : {

	push	ebp
	mov	ebp, esp

; 1146 : 	// flush any remaining 2D bits
; 1147 : 	R_Set2DMode( false );

	push	0
	call	_R_Set2DMode
	add	esp, 4

; 1148 : 
; 1149 : 	if( !pwglSwapBuffers( glw_state.hDC ))

	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR _pwglSwapBuffers
	test	eax, eax
	jne	SHORT $LN1@R_EndFrame

; 1150 : 		Sys_Error( "failed to swap buffers\nCheck your video driver and as possible of reinstall it" );

	push	OFFSET $SG143907
	call	_Sys_Error
	add	esp, 4
$LN1@R_EndFrame:

; 1151 : }

	pop	ebp
	ret	0
_R_EndFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv77 = -4						; size = 4
_rvp$ = 8						; size = 4
_R_RenderFrame PROC

; 1099 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1100 : 	if( r_norefresh->value )

	mov	eax, DWORD PTR _r_norefresh
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@R_RenderFr

; 1101 : 		return;

	jmp	$LN1@R_RenderFr
$LN2@R_RenderFr:

; 1102 : 
; 1103 : 	// setup the initial render params
; 1104 : 	R_SetupRefParams( rvp );

	mov	ecx, DWORD PTR _rvp$[ebp]
	push	ecx
	call	_R_SetupRefParams
	add	esp, 4

; 1105 : 
; 1106 : 	if( gl_finish->value && RI.drawWorld )

	mov	edx, DWORD PTR _gl_finish
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@R_RenderFr
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN3@R_RenderFr

; 1107 : 		pglFinish();

	call	DWORD PTR _pglFinish
$LN3@R_RenderFr:

; 1108 : 
; 1109 : 	if( glConfig.max_multisamples > 1 && FBitSet( gl_msaa->flags, FCVAR_CHANGED ))

	cmp	DWORD PTR _glConfig+96, 1
	jle	SHORT $LN4@R_RenderFr
	mov	eax, DWORD PTR _gl_msaa
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN4@R_RenderFr

; 1110 : 	{
; 1111 : 		if( CVAR_TO_BOOL( gl_msaa ))

	cmp	DWORD PTR _gl_msaa, 0
	je	SHORT $LN11@R_RenderFr
	mov	edx, DWORD PTR _gl_msaa
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@R_RenderFr
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN12@R_RenderFr
$LN11@R_RenderFr:
	mov	DWORD PTR tv77[ebp], 0
$LN12@R_RenderFr:
	cmp	DWORD PTR tv77[ebp], 0
	je	SHORT $LN5@R_RenderFr

; 1112 : 			pglEnable( GL_MULTISAMPLE_ARB );

	push	32925					; 0000809dH
	call	DWORD PTR _pglEnable
	jmp	SHORT $LN6@R_RenderFr
$LN5@R_RenderFr:

; 1113 : 		else pglDisable( GL_MULTISAMPLE_ARB );

	push	32925					; 0000809dH
	call	DWORD PTR _pglDisable
$LN6@R_RenderFr:

; 1114 : 		ClearBits( gl_msaa->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_msaa
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_msaa
	mov	DWORD PTR [edx+8], ecx
$LN4@R_RenderFr:

; 1115 : 	}
; 1116 : 
; 1117 : 	// completely override rendering
; 1118 : 	if( clgame.drawFuncs.GL_RenderFrame != NULL )

	cmp	DWORD PTR _clgame+180, 0
	je	SHORT $LN8@R_RenderFr

; 1119 : 	{
; 1120 : 		tr.fCustomRendering = true;

	mov	DWORD PTR _tr+66688, 1

; 1121 : 
; 1122 : 		if( clgame.drawFuncs.GL_RenderFrame( rvp ))

	mov	eax, DWORD PTR _rvp$[ebp]
	push	eax
	call	DWORD PTR _clgame+180
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_RenderFr

; 1123 : 		{
; 1124 : 			R_GatherPlayerLight();

	call	_R_GatherPlayerLight

; 1125 : 			tr.realframecount++;

	mov	ecx, DWORD PTR _tr+66676
	add	ecx, 1
	mov	DWORD PTR _tr+66676, ecx

; 1126 : 			tr.fResetVis = true;

	mov	DWORD PTR _tr+66692, 1

; 1127 : 			return;

	jmp	SHORT $LN1@R_RenderFr
$LN8@R_RenderFr:

; 1128 : 		}
; 1129 : 	}
; 1130 : 
; 1131 : 	tr.fCustomRendering = false;

	mov	DWORD PTR _tr+66688, 0

; 1132 : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN9@R_RenderFr

; 1133 : 		R_RunViewmodelEvents();

	call	_R_RunViewmodelEvents
$LN9@R_RenderFr:

; 1134 : 
; 1135 : 	tr.realframecount++; // right called after viewmodel events

	mov	edx, DWORD PTR _tr+66676
	add	edx, 1
	mov	DWORD PTR _tr+66676, edx

; 1136 : 	R_RenderScene();

	call	_R_RenderScene
$LN1@R_RenderFr:

; 1137 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_clearScene$ = 8					; size = 4
_R_BeginFrame PROC

; 1029 : {

	push	ebp
	mov	ebp, esp

; 1030 : 	glConfig.softwareGammaUpdate = false;	// in case of possible fails

	mov	DWORD PTR _glConfig+124, 0

; 1031 : 
; 1032 : 	if(( gl_clear->value || CL_IsDevOverviewMode( )) && clearScene && cls.state != ca_cinematic )

	mov	eax, DWORD PTR _gl_clear
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@R_BeginFra
	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN2@R_BeginFra
$LN3@R_BeginFra:
	cmp	DWORD PTR _clearScene$[ebp], 0
	je	SHORT $LN2@R_BeginFra
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN2@R_BeginFra

; 1033 : 	{
; 1034 : 		pglClear( GL_COLOR_BUFFER_BIT );

	push	16384					; 00004000H
	call	DWORD PTR _pglClear
$LN2@R_BeginFra:

; 1035 : 	}
; 1036 : 
; 1037 : 	R_CheckGamma();

	call	_R_CheckGamma

; 1038 : 
; 1039 : 	R_Set2DMode( true );

	push	1
	call	_R_Set2DMode
	add	esp, 4

; 1040 : 
; 1041 : 	// draw buffer stuff
; 1042 : 	pglDrawBuffer( GL_BACK );

	push	1029					; 00000405H
	call	DWORD PTR _pglDrawBuffer

; 1043 : 
; 1044 : 	// update texture parameters
; 1045 : 	if( FBitSet( gl_texture_nearest->flags|gl_lightmap_nearest->flags|gl_texture_anisotropy->flags|gl_texture_lodbias->flags, FCVAR_CHANGED ))

	mov	ecx, DWORD PTR _gl_texture_nearest
	mov	edx, DWORD PTR _gl_lightmap_nearest
	mov	eax, DWORD PTR [ecx+8]
	or	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _gl_texture_anisotropy
	or	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _gl_texture_lodbias
	or	eax, DWORD PTR [edx+8]
	and	eax, 8192				; 00002000H
	je	SHORT $LN4@R_BeginFra

; 1046 : 		R_SetTextureParameters();

	call	_R_SetTextureParameters
$LN4@R_BeginFra:

; 1047 : 
; 1048 : 	// swapinterval stuff
; 1049 : 	GL_UpdateSwapInterval();

	call	_GL_UpdateSwapInterval

; 1050 : 
; 1051 : 	CL_ExtraUpdate ();

	call	_CL_ExtraUpdate

; 1052 : }

	pop	ebp
	ret	0
_R_BeginFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_DrawFog PROC

; 783  : {

	push	ebp
	mov	ebp, esp

; 784  : 	if( !RI.fogEnabled ) return;

	cmp	DWORD PTR _RI+316, 0
	jne	SHORT $LN2@R_DrawFog
	jmp	SHORT $LN1@R_DrawFog
$LN2@R_DrawFog:

; 785  : 
; 786  : 	pglEnable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglEnable

; 787  : 	if( CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN3@R_DrawFog

; 788  : 		pglFogi( GL_FOG_MODE, GL_EXP2 );

	push	2049					; 00000801H
	push	2917					; 00000b65H
	call	DWORD PTR _pglFogi
	jmp	SHORT $LN4@R_DrawFog
$LN3@R_DrawFog:

; 789  : 	else pglFogi( GL_FOG_MODE, GL_EXP );

	push	2048					; 00000800H
	push	2917					; 00000b65H
	call	DWORD PTR _pglFogi
$LN4@R_DrawFog:

; 790  : 	pglFogf( GL_FOG_DENSITY, RI.fogDensity );

	push	ecx
	movss	xmm0, DWORD PTR _RI+340
	movss	DWORD PTR [esp], xmm0
	push	2914					; 00000b62H
	call	DWORD PTR _pglFogf

; 791  : 	pglFogfv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv

; 792  : 	pglHint( GL_FOG_HINT, GL_NICEST );

	push	4354					; 00001102H
	push	3156					; 00000c54H
	call	DWORD PTR _pglHint
$LN1@R_DrawFog:

; 793  : }

	pop	ebp
	ret	0
_R_DrawFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_PopScene PROC

; 208  : {

	push	ebp
	mov	ebp, esp

; 209  : 	if( --tr.draw_stack_pos < 0 )

	mov	eax, DWORD PTR _tr+50268
	sub	eax, 1
	mov	DWORD PTR _tr+50268, eax
	jns	SHORT $LN2@R_PopScene

; 210  : 		Host_Error( "draw stack underflow\n" );

	push	OFFSET $SG143606
	call	_Host_Error
	add	esp, 4
$LN2@R_PopScene:

; 211  : 	tr.draw_list = &tr.draw_stack[tr.draw_stack_pos];

	imul	ecx, DWORD PTR _tr+50268, 24588
	add	ecx, OFFSET _tr+1092
	mov	DWORD PTR _tr+50272, ecx

; 212  : }

	pop	ebp
	ret	0
_R_PopScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_PushScene PROC

; 195  : {

	push	ebp
	mov	ebp, esp

; 196  : 	if( ++tr.draw_stack_pos >= MAX_DRAW_STACK )

	mov	eax, DWORD PTR _tr+50268
	add	eax, 1
	mov	DWORD PTR _tr+50268, eax
	cmp	DWORD PTR _tr+50268, 2
	jl	SHORT $LN2@R_PushScen

; 197  : 		Host_Error( "draw stack overflow\n" );

	push	OFFSET $SG143602
	call	_Host_Error
	add	esp, 4
$LN2@R_PushScen:

; 198  : 
; 199  : 	tr.draw_list = &tr.draw_stack[tr.draw_stack_pos];

	imul	ecx, DWORD PTR _tr+50268, 24588
	add	ecx, OFFSET _tr+1092
	mov	DWORD PTR _tr+50272, ecx

; 200  : }

	pop	ebp
	ret	0
_R_PushScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_CheckGamma PROC

; 1004 : {

	push	ebp
	mov	ebp, esp

; 1005 : 	if( R_DoResetGamma( ))

	call	_R_DoResetGamma
	test	eax, eax
	je	SHORT $LN2@R_CheckGam

; 1006 : 	{
; 1007 : 		// paranoia cubemaps uses this
; 1008 : 		BuildGammaTable( 1.8f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3fe66666
	movss	DWORD PTR [esp], xmm0
	call	_BuildGammaTable
	add	esp, 8

; 1009 : 
; 1010 : 		// paranoia cubemap rendering
; 1011 : 		if( clgame.drawFuncs.GL_BuildLightmaps )

	cmp	DWORD PTR _clgame+184, 0
	je	SHORT $LN4@R_CheckGam

; 1012 : 			clgame.drawFuncs.GL_BuildLightmaps( );

	call	DWORD PTR _clgame+184
$LN4@R_CheckGam:

; 1013 : 	}

	jmp	SHORT $LN5@R_CheckGam
$LN2@R_CheckGam:

; 1014 : 	else if( FBitSet( vid_gamma->flags, FCVAR_CHANGED ) || FBitSet( vid_brightness->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _vid_gamma
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	jne	SHORT $LN6@R_CheckGam
	mov	edx, DWORD PTR _vid_brightness
	mov	eax, DWORD PTR [edx+8]
	and	eax, 8192				; 00002000H
	je	SHORT $LN5@R_CheckGam
$LN6@R_CheckGam:

; 1015 : 	{
; 1016 : 		BuildGammaTable( vid_gamma->value, vid_brightness->value );

	mov	ecx, DWORD PTR _vid_brightness
	push	ecx
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _vid_gamma
	push	ecx
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR [esp], xmm0
	call	_BuildGammaTable
	add	esp, 8

; 1017 : 		glConfig.softwareGammaUpdate = true;

	mov	DWORD PTR _glConfig+124, 1

; 1018 : 		GL_RebuildLightmaps();

	call	_GL_RebuildLightmaps

; 1019 : 		glConfig.softwareGammaUpdate = false;

	mov	DWORD PTR _glConfig+124, 0
$LN5@R_CheckGam:

; 1020 : 	}
; 1021 : }

	pop	ebp
	ret	0
_R_CheckGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_FindViewLeaf PROC

; 471  : {

	push	ebp
	mov	ebp, esp

; 472  : 	RI.oldviewleaf = RI.viewleaf;

	mov	eax, DWORD PTR _RI+180
	mov	DWORD PTR _RI+184, eax

; 473  : 	RI.viewleaf = Mod_PointInLeaf( RI.pvsorigin, cl.worldmodel->nodes );

	mov	ecx, DWORD PTR _cl+2686576
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	push	OFFSET _RI+188
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _RI+180, eax

; 474  : }

	pop	ebp
	ret	0
_R_FindViewLeaf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
tv250 = -68						; size = 8
tv354 = -60						; size = 8
tv244 = -52						; size = 8
tv238 = -44						; size = 8
tv232 = -36						; size = 8
tv352 = -28						; size = 8
tv226 = -20						; size = 8
tv220 = -12						; size = 8
_ov$ = -4						; size = 4
_R_SetupFrustum PROC

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 328  : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+125416

; 329  : 
; 330  : 	if( RP_NORMALPASS() && ( cl.local.waterlevel >= 3 ))

	mov	eax, DWORD PTR _RI
	and	eax, 1
	jne	$LN2@R_SetupFru
	cmp	DWORD PTR _cl+1568568, 3
	jl	$LN2@R_SetupFru

; 331  : 	{
; 332  : 		RI.fov_x = atan( tan( DEG2RAD( RI.fov_x ) / 2 ) * ( 0.97 + sin( cl.time * 1.5 ) * 0.03 )) * 2 / (M_PI / 180.0);

	movss	xmm0, DWORD PTR _RI+20
	mulss	xmm0, DWORD PTR __real@3c8efa35
	divss	xmm0, DWORD PTR __real@40000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv220[ebp]
	movsd	xmm0, QWORD PTR tv220[ebp]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv352[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv226[ebp]
	movsd	xmm0, QWORD PTR tv226[ebp]
	mulsd	xmm0, QWORD PTR __real@3f9eb851eb851eb8
	addsd	xmm0, QWORD PTR __real@3fef0a3d70a3d70a
	movsd	xmm1, QWORD PTR tv352[ebp]
	mulsd	xmm1, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv232[ebp]
	movsd	xmm0, QWORD PTR tv232[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	divsd	xmm0, QWORD PTR __real@3f91df46aaaaaaab
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _RI+20, xmm0

; 333  : 		RI.fov_y = atan( tan( DEG2RAD( RI.fov_y ) / 2 ) * ( 1.03 - sin( cl.time * 1.5 ) * 0.03 )) * 2 / (M_PI / 180.0);

	movss	xmm0, DWORD PTR _RI+24
	mulss	xmm0, DWORD PTR __real@3c8efa35
	divss	xmm0, DWORD PTR __real@40000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv238[ebp]
	movsd	xmm0, QWORD PTR tv238[ebp]
	movsd	xmm1, QWORD PTR _cl+1525848
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv354[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv244[ebp]
	movsd	xmm0, QWORD PTR tv244[ebp]
	mulsd	xmm0, QWORD PTR __real@3f9eb851eb851eb8
	movsd	xmm1, QWORD PTR __real@3ff07ae147ae147b
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv354[ebp]
	mulsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv250[ebp]
	movsd	xmm0, QWORD PTR tv250[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	divsd	xmm0, QWORD PTR __real@3f91df46aaaaaaab
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _RI+24, xmm0
$LN2@R_SetupFru:

; 334  : 	}
; 335  : 
; 336  : 	// build the transformation matrix for the given view angles
; 337  : 	AngleVectors( RI.viewangles, RI.vforward, RI.vright, RI.vup );

	push	OFFSET _RI+248
	push	OFFSET _RI+236
	push	OFFSET _RI+224
	push	OFFSET _RI+212
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 338  : 
; 339  : 	if( !r_lockfrustum->value )

	mov	ecx, DWORD PTR _r_lockfrustum
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN3@R_SetupFru

; 340  : 	{
; 341  : 		VectorCopy( RI.vieworg, RI.cullorigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _RI[eax+200]
	mov	DWORD PTR _RI[edx+260], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR _RI[edx+260], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR _RI[edx+260], eax

; 342  : 		VectorCopy( RI.vforward, RI.cull_vforward );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI[edx+224]
	mov	DWORD PTR _RI[ecx+272], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _RI[eax+224]
	mov	DWORD PTR _RI[ecx+272], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI[eax+224]
	mov	DWORD PTR _RI[ecx+272], edx

; 343  : 		VectorCopy( RI.vright, RI.cull_vright );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+236]
	mov	DWORD PTR _RI[eax+284], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR _RI[eax+284], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR _RI[eax+284], ecx

; 344  : 		VectorCopy( RI.vup, RI.cull_vup );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _RI[eax+248]
	mov	DWORD PTR _RI[edx+296], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _RI[ecx+248]
	mov	DWORD PTR _RI[edx+296], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[ecx+248]
	mov	DWORD PTR _RI[edx+296], eax
$LN3@R_SetupFru:

; 345  : 	}
; 346  : 
; 347  : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN4@R_SetupFru

; 348  : 		GL_FrustumInitOrtho( &RI.frustum, ov->xLeft, ov->xRight, ov->yTop, ov->yBottom, ov->zNear, ov->zFar );

	mov	ecx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+24]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+56
	call	_GL_FrustumInitOrtho
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN5@R_SetupFru
$LN4@R_SetupFru:

; 349  : 	else GL_FrustumInitProj( &RI.frustum, 0.0f, R_GetFarClip(), RI.fov_x, RI.fov_y ); // NOTE: we ignore nearplane here (mirrors only)

	push	ecx
	movss	xmm0, DWORD PTR _RI+24
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _RI+20
	movss	DWORD PTR [esp], xmm0
	call	_R_GetFarClip
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+56
	call	_GL_FrustumInitProj
	add	esp, 20					; 00000014H
$LN5@R_SetupFru:

; 350  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupFrustum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_allowed$ = 8						; size = 4
_R_AllowFog PROC

; 45   : {

	push	ebp
	mov	ebp, esp

; 46   : 	if( allowed )

	cmp	DWORD PTR _allowed$[ebp], 0
	je	SHORT $LN2@R_AllowFog

; 47   : 	{
; 48   : 		if( glState.isFogEnabled )

	cmp	DWORD PTR _glState+564, 0
	je	SHORT $LN4@R_AllowFog

; 49   : 			pglEnable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglEnable
$LN4@R_AllowFog:

; 50   : 	}

	jmp	SHORT $LN1@R_AllowFog
$LN2@R_AllowFog:

; 51   : 	else
; 52   : 	{
; 53   : 		if( glState.isFogEnabled )

	cmp	DWORD PTR _glState+564, 0
	je	SHORT $LN1@R_AllowFog

; 54   : 			pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN1@R_AllowFog:

; 55   : 	}
; 56   : }

	pop	ebp
	ret	0
_R_AllowFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_InitRenderAPI PROC

; 1544 : {

	push	ebp
	mov	ebp, esp

; 1545 : 	// make sure what render functions is cleared
; 1546 : 	memset( &clgame.drawFuncs, 0, sizeof( clgame.drawFuncs ));

	push	52					; 00000034H
	push	0
	push	OFFSET _clgame+176
	call	_memset
	add	esp, 12					; 0000000cH

; 1547 : 	glConfig.fCustomRenderer = false;

	mov	DWORD PTR _glConfig+128, 0

; 1548 : 
; 1549 : 	if( clgame.dllFuncs.pfnGetRenderInterface )

	cmp	DWORD PTR _clgame+168, 0
	je	SHORT $LN2@R_InitRend

; 1550 : 	{
; 1551 : 		if( clgame.dllFuncs.pfnGetRenderInterface( CL_RENDER_INTERFACE_VERSION, &gRenderAPI, &clgame.drawFuncs ))

	push	OFFSET _clgame+176
	push	OFFSET _gRenderAPI
	push	37					; 00000025H
	call	DWORD PTR _clgame+168
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@R_InitRend

; 1552 : 		{
; 1553 : 			Con_Reportf( "CL_LoadProgs: ^2initailized extended RenderAPI ^7ver. %i\n", CL_RENDER_INTERFACE_VERSION );

	push	37					; 00000025H
	push	OFFSET $SG144140
	call	_Con_Reportf
	add	esp, 8

; 1554 : 			glConfig.fCustomRenderer = true;

	mov	DWORD PTR _glConfig+128, 1

; 1555 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_InitRend
$LN3@R_InitRend:

; 1556 : 		}
; 1557 : 
; 1558 : 		// make sure what render functions is cleared
; 1559 : 		memset( &clgame.drawFuncs, 0, sizeof( clgame.drawFuncs ));

	push	52					; 00000034H
	push	0
	push	OFFSET _clgame+176
	call	_memset
	add	esp, 12					; 0000000cH

; 1560 : 
; 1561 : 		return false; // just tell user about problems

	xor	eax, eax
	jmp	SHORT $LN1@R_InitRend
$LN2@R_InitRend:

; 1562 : 	}
; 1563 : 
; 1564 : 	// render interface is missed
; 1565 : 	return true;

	mov	eax, 1
$LN1@R_InitRend:

; 1566 : }

	pop	ebp
	ret	0
_R_InitRenderAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_x2$1 = -56						; size = 4
_y$2 = -52						; size = 4
_x$3 = -48						; size = 4
_y2$4 = -44						; size = 4
_p$5 = -40						; size = 4
_clip$6 = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_set_gl_state$ = 8					; size = 4
_R_SetupGL PROC

; 509  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 510  : 	R_SetupModelviewMatrix( RI.worldviewMatrix );

	push	OFFSET _RI+520
	call	_R_SetupModelviewMatrix
	add	esp, 4

; 511  : 	R_SetupProjectionMatrix( RI.projectionMatrix );

	push	OFFSET _RI+648
	call	_R_SetupProjectionMatrix
	add	esp, 4

; 512  : 
; 513  : 	Matrix4x4_Concat( RI.worldviewProjectionMatrix, RI.projectionMatrix, RI.worldviewMatrix );

	push	OFFSET _RI+520
	push	OFFSET _RI+648
	push	OFFSET _RI+712
	call	_Matrix4x4_Concat
	add	esp, 12					; 0000000cH

; 514  : 
; 515  : 	if( !set_gl_state ) return;

	cmp	DWORD PTR _set_gl_state$[ebp], 0
	jne	SHORT $LN2@R_SetupGL
	jmp	$LN1@R_SetupGL
$LN2@R_SetupGL:

; 516  : 
; 517  : 	if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 1
	jne	$LN3@R_SetupGL

; 518  : 	{
; 519  : 		int	x, x2, y, y2;
; 520  : 
; 521  : 		// set up viewport (main, playersetup)
; 522  : 		x = floor( RI.viewport[0] * glState.width / glState.width );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _RI[edx+40]
	imul	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _glState
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _x$3[ebp], eax

; 523  : 		x2 = ceil(( RI.viewport[0] + RI.viewport[2] ) * glState.width / glState.width );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[ecx+40]
	add	eax, DWORD PTR _RI[edx+40]
	imul	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _glState
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _x2$1[ebp], eax

; 524  : 		y = floor( glState.height - RI.viewport[1] * glState.height / glState.height );

	mov	eax, 4
	shl	eax, 0
	mov	eax, DWORD PTR _RI[eax+40]
	imul	eax, DWORD PTR _glState+4
	cdq
	idiv	DWORD PTR _glState+4
	mov	ecx, DWORD PTR _glState+4
	sub	ecx, eax
	cvtsi2sd xmm0, ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _y$2[ebp], eax

; 525  : 		y2 = ceil( glState.height - ( RI.viewport[1] + RI.viewport[3] ) * glState.height / glState.height );

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _RI[edx+40]
	add	eax, DWORD PTR _RI[ecx+40]
	imul	eax, DWORD PTR _glState+4
	cdq
	idiv	DWORD PTR _glState+4
	mov	edx, DWORD PTR _glState+4
	sub	edx, eax
	cvtsi2sd xmm0, edx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _y2$4[ebp], eax

; 526  : 
; 527  : 		pglViewport( x, y2, x2 - x, y - y2 );

	mov	eax, DWORD PTR _y$2[ebp]
	sub	eax, DWORD PTR _y2$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _x2$1[ebp]
	sub	ecx, DWORD PTR _x$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _y2$4[ebp]
	push	edx
	mov	eax, DWORD PTR _x$3[ebp]
	push	eax
	call	DWORD PTR _pglViewport

; 528  : 	}

	jmp	SHORT $LN4@R_SetupGL
$LN3@R_SetupGL:

; 529  : 	else
; 530  : 	{
; 531  : 		// envpass, mirrorpass
; 532  : 		pglViewport( RI.viewport[0], RI.viewport[1], RI.viewport[2], RI.viewport[3] );

	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _RI[edx+40]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI[ecx+40]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[eax+40]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[eax+40]
	push	ecx
	call	DWORD PTR _pglViewport
$LN4@R_SetupGL:

; 533  : 	}
; 534  : 
; 535  : 	pglMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR _pglMatrixMode

; 536  : 	GL_LoadMatrix( RI.projectionMatrix );

	push	OFFSET _RI+648
	call	_GL_LoadMatrix
	add	esp, 4

; 537  : 
; 538  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 539  : 	GL_LoadMatrix( RI.worldviewMatrix );

	push	OFFSET _RI+520
	call	_GL_LoadMatrix
	add	esp, 4

; 540  : 
; 541  : 	if( FBitSet( RI.params, RP_CLIPPLANE ))

	mov	edx, DWORD PTR _RI
	and	edx, 4
	je	$LN5@R_SetupGL

; 542  : 	{
; 543  : 		GLdouble	clip[4];
; 544  : 		mplane_t	*p = &RI.clipPlane;

	mov	DWORD PTR _p$5[ebp], OFFSET _RI+4876

; 545  : 
; 546  : 		clip[0] = p->normal[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 8
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$5[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx]
	movsd	QWORD PTR _clip$6[ebp+eax], xmm0

; 547  : 		clip[1] = p->normal[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _p$5[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	movsd	QWORD PTR _clip$6[ebp+ecx], xmm0

; 548  : 		clip[2] = p->normal[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _p$5[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	movsd	QWORD PTR _clip$6[ebp+ecx], xmm0

; 549  : 		clip[3] = -p->dist;

	mov	eax, DWORD PTR _p$5[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	edx, ecx, 3
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _clip$6[ebp+edx], xmm0

; 550  : 
; 551  : 		pglClipPlane( GL_CLIP_PLANE0, clip );

	lea	eax, DWORD PTR _clip$6[ebp]
	push	eax
	push	12288					; 00003000H
	call	DWORD PTR _pglClipPlane

; 552  : 		pglEnable( GL_CLIP_PLANE0 );

	push	12288					; 00003000H
	call	DWORD PTR _pglEnable
$LN5@R_SetupGL:

; 553  : 	}
; 554  : 
; 555  : 	GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	_GL_Cull
	add	esp, 4

; 556  : 
; 557  : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 558  : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 559  : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN1@R_SetupGL:

; 560  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_scale$ = -4						; size = 4
_e$ = 8							; size = 4
_R_RotateForEntity PROC

; 419  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 420  : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 421  : 
; 422  : 	if( e == clgame.entities )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _clgame+1000
	jne	SHORT $LN2@R_RotateFo

; 423  : 	{
; 424  : 		R_LoadIdentity();

	call	_R_LoadIdentity

; 425  : 		return;

	jmp	$LN1@R_RotateFo
$LN2@R_RotateFo:

; 426  : 	}
; 427  : 
; 428  : 	if( e->model->type != mod_brush && e->curstate.scale > 0.0f )

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN3@R_RotateFo
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+752]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@R_RotateFo

; 429  : 		scale = e->curstate.scale;

	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+752]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@R_RotateFo:

; 430  : 
; 431  : 	Matrix4x4_CreateFromEntity( RI.objectMatrix, e->angles, e->origin, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 2888				; 00000b48H
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 2900				; 00000b54H
	push	eax
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 432  : 	Matrix4x4_ConcatTransforms( RI.modelviewMatrix, RI.worldviewMatrix, RI.objectMatrix );

	push	OFFSET _RI+456
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 433  : 
; 434  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 435  : 	GL_LoadMatrix( RI.modelviewMatrix );

	push	OFFSET _RI+584
	call	_GL_LoadMatrix
	add	esp, 4

; 436  : 	tr.modelviewIdentity = false;

	mov	DWORD PTR _tr+66664, 0
$LN1@R_RotateFo:

; 437  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RotateForEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_scale$ = -4						; size = 4
_e$ = 8							; size = 4
_R_TranslateForEntity PROC

; 445  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 446  : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 447  : 
; 448  : 	if( e == clgame.entities )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _clgame+1000
	jne	SHORT $LN2@R_Translat

; 449  : 	{
; 450  : 		R_LoadIdentity();

	call	_R_LoadIdentity

; 451  : 		return;

	jmp	$LN1@R_Translat
$LN2@R_Translat:

; 452  : 	}
; 453  : 
; 454  : 	if( e->model->type != mod_brush && e->curstate.scale > 0.0f )

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+2964]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN3@R_Translat
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+752]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@R_Translat

; 455  : 		scale = e->curstate.scale;

	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+752]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@R_Translat:

; 456  : 
; 457  : 	Matrix4x4_CreateFromEntity( RI.objectMatrix, vec3_origin, e->origin, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 2888				; 00000b48H
	push	edx
	push	OFFSET _vec3_origin
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 458  : 	Matrix4x4_ConcatTransforms( RI.modelviewMatrix, RI.worldviewMatrix, RI.objectMatrix );

	push	OFFSET _RI+456
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 459  : 
; 460  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 461  : 	GL_LoadMatrix( RI.modelviewMatrix );

	push	OFFSET _RI+584
	call	_GL_LoadMatrix
	add	esp, 4

; 462  : 	tr.modelviewIdentity = false;

	mov	DWORD PTR _tr+66664, 0
$LN1@R_Translat:

; 463  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_TranslateForEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_rvp$ = 8						; size = 4
_R_SetupRefParams PROC

; 1062 : {

	push	ebp
	mov	ebp, esp

; 1063 : 	RI.params = RP_NONE;

	mov	DWORD PTR _RI, 0

; 1064 : 	RI.drawWorld = FBitSet( rvp->flags, RF_DRAW_WORLD );

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 1
	mov	DWORD PTR _RI+4, ecx

; 1065 : 	RI.onlyClientDraw = FBitSet( rvp->flags, RF_ONLY_CLIENTDRAW );

	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+52]
	and	eax, 8
	mov	DWORD PTR _RI+12, eax

; 1066 : 	RI.farClip = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+308, xmm0

; 1067 : 
; 1068 : 	if( !FBitSet( rvp->flags, RF_DRAW_CUBEMAP ))

	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	and	edx, 2
	jne	SHORT $LN2@R_SetupRef

; 1069 : 	{
; 1070 : 		RI.drawOrtho = FBitSet( rvp->flags, RF_DRAW_OVERVIEW );

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 4
	mov	DWORD PTR _RI+16, ecx

; 1071 : 	}

	jmp	SHORT $LN3@R_SetupRef
$LN2@R_SetupRef:

; 1072 : 	else 
; 1073 : 	{
; 1074 : 		SetBits( RI.params, RP_ENVVIEW );

	mov	edx, DWORD PTR _RI
	or	edx, 1
	mov	DWORD PTR _RI, edx

; 1075 : 		RI.drawOrtho = false;

	mov	DWORD PTR _RI+16, 0
$LN3@R_SetupRef:

; 1076 : 	}
; 1077 : 
; 1078 : 	// setup viewport
; 1079 : 	RI.viewport[0] = rvp->viewport[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _RI[eax+40], ecx

; 1080 : 	RI.viewport[1] = rvp->viewport[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _RI[eax+40], edx

; 1081 : 	RI.viewport[2] = rvp->viewport[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _RI[ecx+40], eax

; 1082 : 	RI.viewport[3] = rvp->viewport[3];

	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _RI[ecx+40], edx

; 1083 : 
; 1084 : 	// calc FOV
; 1085 : 	RI.fov_x = rvp->fov_x;

	mov	eax, DWORD PTR _rvp$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _RI+20, xmm0

; 1086 : 	RI.fov_y = rvp->fov_y;

	mov	ecx, DWORD PTR _rvp$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR _RI+24, xmm0

; 1087 : 
; 1088 : 	VectorCopy( rvp->vieworigin, RI.vieworg );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _RI[edx+200], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR _RI[edx+200], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _RI[eax+200], edx

; 1089 : 	VectorCopy( rvp->viewangles, RI.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+28]
	mov	DWORD PTR _RI[eax+212], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx+28]
	mov	DWORD PTR _RI[eax+212], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR _RI[ecx+212], eax

; 1090 : 	VectorCopy( rvp->vieworigin, RI.pvsorigin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _RI[ecx+188], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _RI[ecx+188], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+16]
	mov	DWORD PTR _RI[edx+188], ecx

; 1091 : }

	pop	ebp
	ret	0
_R_SetupRefParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_rvp$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
_size$ = 16						; size = 4
_R_DrawCubemapView PROC

; 1159 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1160 : 	ref_viewpass_t rvp;
; 1161 : 
; 1162 : 	// basic params
; 1163 : 	rvp.flags = rvp.viewentity = 0;

	mov	DWORD PTR _rvp$[ebp+40], 0
	mov	eax, DWORD PTR _rvp$[ebp+40]
	mov	DWORD PTR _rvp$[ebp+52], eax

; 1164 : 	SetBits( rvp.flags, RF_DRAW_WORLD );

	mov	ecx, DWORD PTR _rvp$[ebp+52]
	or	ecx, 1
	mov	DWORD PTR _rvp$[ebp+52], ecx

; 1165 : 	SetBits( rvp.flags, RF_DRAW_CUBEMAP );

	mov	edx, DWORD PTR _rvp$[ebp+52]
	or	edx, 2
	mov	DWORD PTR _rvp$[ebp+52], edx

; 1166 : 
; 1167 : 	rvp.viewport[0] = rvp.viewport[1] = 0;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR _rvp$[ebp+eax], 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _rvp$[ebp+edx], 0

; 1168 : 	rvp.viewport[2] = rvp.viewport[3] = size;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _rvp$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _rvp$[ebp+eax], ecx

; 1169 : 	rvp.fov_x = rvp.fov_y = 90.0f; // this is a final fov value

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _rvp$[ebp+48], xmm0
	movss	xmm0, DWORD PTR _rvp$[ebp+48]
	movss	DWORD PTR _rvp$[ebp+44], xmm0

; 1170 : 
; 1171 : 	// setup origin & angles
; 1172 : 	VectorCopy( origin, rvp.vieworigin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _rvp$[ebp+edx+16], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _rvp$[ebp+edx+16], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _rvp$[ebp+eax+16], edx

; 1173 : 	VectorCopy( angles, rvp.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _rvp$[ebp+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _rvp$[ebp+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _rvp$[ebp+ecx+28], eax

; 1174 : 
; 1175 : 	R_RenderFrame( &rvp );

	lea	ecx, DWORD PTR _rvp$[ebp]
	push	ecx
	call	_R_RenderFrame
	add	esp, 4

; 1176 : 
; 1177 : 	RI.viewleaf = NULL;		// force markleafs next frame

	mov	DWORD PTR _RI+180, 0

; 1178 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawCubemapView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_RenderScene PROC

; 943  : {

	push	ebp
	mov	ebp, esp

; 944  : 	if( !cl.worldmodel && RI.drawWorld )

	cmp	DWORD PTR _cl+2686576, 0
	jne	SHORT $LN2@R_RenderSc
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN2@R_RenderSc

; 945  : 		Host_Error( "R_RenderView: NULL worldmodel\n" );

	push	OFFSET $SG143864
	call	_Host_Error
	add	esp, 4
$LN2@R_RenderSc:

; 946  : 
; 947  : 	// frametime is valid only for normal pass
; 948  : 	if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 1
	jne	SHORT $LN3@R_RenderSc

; 949  : 		tr.frametime = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+1525848
	subsd	xmm0, QWORD PTR _cl+1525856
	movsd	QWORD PTR _tr+66968, xmm0
	jmp	SHORT $LN4@R_RenderSc
$LN3@R_RenderSc:

; 950  : 	else tr.frametime = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _tr+66968, xmm0
$LN4@R_RenderSc:

; 951  : 
; 952  : 	// begin a new frame
; 953  : 	tr.framecount++;

	mov	ecx, DWORD PTR _tr+66680
	add	ecx, 1
	mov	DWORD PTR _tr+66680, ecx

; 954  : 
; 955  : 	R_PushDlights();

	call	_R_PushDlights

; 956  : 
; 957  : 	R_SetupFrustum();

	call	_R_SetupFrustum

; 958  : 	R_SetupFrame();

	call	_R_SetupFrame

; 959  : 	R_SetupGL( true );

	push	1
	call	_R_SetupGL
	add	esp, 4

; 960  : 	R_Clear( ~0 );

	push	-1
	call	_R_Clear
	add	esp, 4

; 961  : 
; 962  : 	R_MarkLeaves();

	call	_R_MarkLeaves

; 963  : 	R_DrawFog ();

	call	_R_DrawFog

; 964  : 
; 965  : 	R_CheckGLFog();	

	call	_R_CheckGLFog

; 966  : 	R_DrawWorld();

	call	_R_DrawWorld

; 967  : 	R_CheckFog();

	call	_R_CheckFog

; 968  : 
; 969  : 	CL_ExtraUpdate ();	// don't let sound get messed up if going slow

	call	_CL_ExtraUpdate

; 970  : 
; 971  : 	R_DrawEntitiesOnList();

	call	_R_DrawEntitiesOnList

; 972  : 
; 973  : 	R_DrawWaterSurfaces();

	call	_R_DrawWaterSurfaces

; 974  : 
; 975  : 	R_EndGL();

	call	_R_EndGL

; 976  : }

	pop	ebp
	ret	0
_R_RenderScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_LoadIdentity PROC

; 402  : {

	push	ebp
	mov	ebp, esp

; 403  : 	if( tr.modelviewIdentity ) return;

	cmp	DWORD PTR _tr+66664, 0
	je	SHORT $LN2@R_LoadIden
	jmp	SHORT $LN1@R_LoadIden
$LN2@R_LoadIden:

; 404  : 
; 405  : 	Matrix4x4_LoadIdentity( RI.objectMatrix );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	push	OFFSET _RI+456
	call	_memcpy
	add	esp, 12					; 0000000cH

; 406  : 	Matrix4x4_Copy( RI.modelviewMatrix, RI.worldviewMatrix );

	push	64					; 00000040H
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_memcpy
	add	esp, 12					; 0000000cH

; 407  : 
; 408  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 409  : 	GL_LoadMatrix( RI.modelviewMatrix );

	push	OFFSET _RI+584
	call	_GL_LoadMatrix
	add	esp, 4

; 410  : 	tr.modelviewIdentity = true;

	mov	DWORD PTR _tr+66664, 1
$LN1@R_LoadIden:

; 411  : }

	pop	ebp
	ret	0
_R_LoadIdentity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_R_ClearScene PROC

; 220  : {

	push	ebp
	mov	ebp, esp

; 221  : 	tr.draw_list->num_solid_entities = 0;

	mov	eax, DWORD PTR _tr+50272
	mov	DWORD PTR [eax+24576], 0

; 222  : 	tr.draw_list->num_trans_entities = 0;

	mov	ecx, DWORD PTR _tr+50272
	mov	DWORD PTR [ecx+24580], 0

; 223  : 	tr.draw_list->num_beam_entities = 0;

	mov	edx, DWORD PTR _tr+50272
	mov	DWORD PTR [edx+24584], 0

; 224  : }

	pop	ebp
	ret	0
_R_ClearScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_rmain.c
_TEXT	SEGMENT
_pic$ = -4						; size = 4
_texnum$ = 8						; size = 4
_GL_TextureData PROC

; 1394 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1395 : 	rgbdata_t *pic = R_GetTexture( texnum )->original;

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR _pic$[ebp], ecx

; 1396 : 
; 1397 : 	if( pic != NULL )

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN2@GL_Texture

; 1398 : 		return pic->buffer;

	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	jmp	SHORT $LN1@GL_Texture
$LN2@GL_Texture:

; 1399 : 	return NULL;	

	xor	eax, eax
$LN1@GL_Texture:

; 1400 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureData ENDP
_TEXT	ENDS
END
