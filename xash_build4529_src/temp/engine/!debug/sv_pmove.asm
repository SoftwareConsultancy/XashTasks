; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\server\sv_pmove.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SV_ClipPMoveToEntity
PUBLIC	_SV_RunCmd
PUBLIC	_SV_InitClientMove
PUBLIC	_SV_GetTrueOrigin
PUBLIC	_SV_GetTrueMinMax
PUBLIC	_SV_PlayerIsFrozen
PUBLIC	_SV_ClearPhysEnts
PUBLIC	_SV_CopyEdictToPhysEnt
PUBLIC	_SV_ShouldUnlagForPlayer
PUBLIC	_SV_AddLinksToPmove
PUBLIC	_SV_AddLaddersToPmove
PUBLIC	_SV_TestLine
PUBLIC	_SV_FindEntInPack
PUBLIC	_SV_UnlagCheckTeleport
PUBLIC	_SV_SetupMoveInterpolant
PUBLIC	_SV_RestoreMoveInterpolant
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4050000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@43800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileSize:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_MemFgets:PROC
EXTRN	_pfnGetModelBounds:PROC
EXTRN	_pfnGetModelType:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_LoadFile:PROC
EXTRN	_SV_StartSound:PROC
EXTRN	_CL_Particle:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_fabs:PROC
EXTRN	_VectorCompareEpsilon:PROC
EXTRN	_BoundsIntersect:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_PlayerRunThink:PROC
EXTRN	_SV_Impact:PROC
EXTRN	_SV_RefreshUserinfo:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_SetMinMaxSize:PROC
EXTRN	_SV_PlaybackEventFull:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_UpdateBaseVelocity:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_LinkEdict:PROC
EXTRN	_Pmove_Init:PROC
EXTRN	_PM_HullForBsp:PROC
EXTRN	_PM_RecursiveHullCheck:PROC
EXTRN	_PM_PlayerTraceExt:PROC
EXTRN	_PM_TestPlayerPosition:PROC
EXTRN	_PM_HullPointContents:PROC
EXTRN	_PM_TruePointContents:PROC
EXTRN	_PM_PointContents:PROC
EXTRN	_PM_ConvertTrace:PROC
EXTRN	_PM_TraceTexture:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_PM_TestLineExt:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_SV_UPDATE_BACKUP:DWORD
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_areanodes:BYTE
EXTRN	_sv_unlag:BYTE
EXTRN	_sv_maxunlag:BYTE
EXTRN	_sv_unlagpush:BYTE
EXTRN	_sv_background_freeze:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_has_update DD	01H DUP (?)
?tr@?1??pfnTraceLine@@9@9 DB 044H DUP (?)		; `pfnTraceLine'::`2'::tr
?tr@?1??pfnTraceLineEx@@9@9 DB 044H DUP (?)		; `pfnTraceLineEx'::`2'::tr
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4050000000000000
CONST	SEGMENT
__real@4050000000000000 DQ 04050000000000000r	; 64
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG136516 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_pmove.c', 00H
$SG136517 DB	'tr != NULL', 00H
	ORG $+1
$SG136540 DB	'bot', 00H
$SG136543 DB	'player', 00H
	ORG $+5
$SG136607 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_pmove.c', 00H
$SG136608 DB	'SV_IsValidEdict( pl )', 00H
	ORG $+6
$SG136609 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_pmove.c', 00H
	ORG $+4
$SG136805 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_pmove.c', 00H
	ORG $+4
$SG136834 DB	'c:\users\user\downloads\xash_build4529_src\engine\server'
	DB	'\sv_pmove.c', 00H
$SG136892 DB	'SV: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g'
	DB	0aH, 00H
	ORG $+2
$SG136996 DB	'sv_maxunlag', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_i$ = -12						; size = 4
_oldlerp$ = -8						; size = 4
_check$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_RestoreMoveInterpolant PROC

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 966  : 	sv_client_t	*check;
; 967  : 	sv_interp_t	*oldlerp;
; 968  : 	int		i;
; 969  : 
; 970  : 	if( !has_update )

	cmp	DWORD PTR _has_update, 0
	jne	SHORT $LN5@SV_Restore

; 971  : 	{
; 972  : 		has_update = true;

	mov	DWORD PTR _has_update, 1

; 973  : 		return;

	jmp	$LN3@SV_Restore
$LN5@SV_Restore:

; 974  : 	}
; 975  : 
; 976  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_Restore

; 977  : 		return;

	jmp	$LN3@SV_Restore
$LN6@SV_Restore:

; 978  : 
; 979  : 	for( i = 0, check = svs.clients; i < svs.maxclients; i++, check++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _check$[ebp], ecx
	jmp	SHORT $LN4@SV_Restore
$LN2@SV_Restore:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _check$[ebp], eax
$LN4@SV_Restore:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	$LN3@SV_Restore

; 980  : 	{
; 981  : 		if( check->state != cs_spawned || check == cl )

	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN8@SV_Restore
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _cl$[ebp]
	jne	SHORT $LN7@SV_Restore
$LN8@SV_Restore:

; 982  : 			continue;

	jmp	SHORT $LN2@SV_Restore
$LN7@SV_Restore:

; 983  : 
; 984  : 		oldlerp = &svgame.interp[i];

	imul	ecx, DWORD PTR _i$[ebp], 88
	add	ecx, OFFSET _svgame+8228
	mov	DWORD PTR _oldlerp$[ebp], ecx

; 985  : 
; 986  : 		if( VectorCompareEpsilon( oldlerp->oldpos, oldlerp->newpos, ON_EPSILON ))

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _oldlerp$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	eax, DWORD PTR _oldlerp$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	call	_VectorCompareEpsilon
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@SV_Restore

; 987  : 			continue; // they didn't actually move.

	jmp	SHORT $LN2@SV_Restore
$LN9@SV_Restore:

; 988  : 
; 989  : 		if( !oldlerp->moving || !oldlerp->active )

	mov	ecx, DWORD PTR _oldlerp$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN11@SV_Restore
	mov	edx, DWORD PTR _oldlerp$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN10@SV_Restore
$LN11@SV_Restore:

; 990  : 			continue;

	jmp	SHORT $LN2@SV_Restore
$LN10@SV_Restore:

; 991  : 
; 992  : 		if( VectorCompare( oldlerp->curpos, check->edict->v.origin ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+40]
	ucomiss	xmm0, DWORD PTR [eax+edx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@SV_Restore
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+40]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@SV_Restore
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+40]
	ucomiss	xmm0, DWORD PTR [ecx+eax+136]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@SV_Restore

; 993  : 		{
; 994  : 			VectorCopy( oldlerp->oldpos, check->edict->v.origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	mov	edx, DWORD PTR [esi+edx+52]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	mov	eax, DWORD PTR [esi+eax+52]
	mov	DWORD PTR [edx+ecx+136], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _oldlerp$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+52]
	mov	DWORD PTR [eax+edx+136], ecx

; 995  : 			SV_LinkEdict( check->edict, false );

	push	0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN12@SV_Restore:

; 996  : 		}
; 997  : 	}

	jmp	$LN2@SV_Restore
$LN3@SV_Restore:

; 998  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestoreMoveInterpolant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv397 = -104						; size = 4
tv370 = -100						; size = 4
_clientnum$ = -96					; size = 4
tv298 = -92						; size = 4
tv297 = -88						; size = 4
tv185 = -84						; size = 4
tv179 = -80						; size = 4
_lerpstate$ = -76					; size = 4
_j$ = -72						; size = 4
_latency$ = -68						; size = 4
_finalpush$ = -64					; size = 4
_lerp_msec$ = -60					; size = 4
_frame2$ = -56						; size = 4
_lerpFrac$ = -52					; size = 4
_frame$ = -48						; size = 4
_i$ = -44						; size = 4
_check$ = -40						; size = 4
_state$ = -36						; size = 4
_lerp$ = -32						; size = 4
_newpos$ = -28						; size = 12
_curpos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_SetupMoveInterpolant PROC

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 816  : 	int		i, j, clientnum;
; 817  : 	float		finalpush, lerp_msec;
; 818  : 	float		latency, lerpFrac;
; 819  : 	client_frame_t	*frame, *frame2;
; 820  : 	entity_state_t	*state, *lerpstate;
; 821  : 	vec3_t		curpos, newpos;
; 822  : 	sv_client_t	*check;
; 823  : 	sv_interp_t	*lerp;
; 824  : 
; 825  : 	memset( svgame.interp, 0, sizeof( svgame.interp ));

	push	2816					; 00000b00H
	push	0
	push	OFFSET _svgame+8228
	call	_memset
	add	esp, 12					; 0000000cH

; 826  : 	has_update = false;

	mov	DWORD PTR _has_update, 0

; 827  : 
; 828  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@SV_SetupMo

; 829  : 		return;

	jmp	$LN12@SV_SetupMo
$LN14@SV_SetupMo:

; 830  : 
; 831  : 	has_update = true;

	mov	DWORD PTR _has_update, 1

; 832  : 
; 833  : 	for( i = 0, check = svs.clients; i < svs.maxclients; i++, check++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR _check$[ebp], ecx
	jmp	SHORT $LN4@SV_SetupMo
$LN2@SV_SetupMo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 287560				; 00046348H
	mov	DWORD PTR _check$[ebp], eax
$LN4@SV_SetupMo:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jge	$LN3@SV_SetupMo

; 834  : 	{
; 835  : 		if( check->state != cs_spawned || check == cl )

	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN16@SV_SetupMo
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _cl$[ebp]
	jne	SHORT $LN15@SV_SetupMo
$LN16@SV_SetupMo:

; 836  : 			continue;

	jmp	SHORT $LN2@SV_SetupMo
$LN15@SV_SetupMo:

; 837  : 
; 838  : 		lerp = &svgame.interp[i];

	imul	ecx, DWORD PTR _i$[ebp], 88
	add	ecx, OFFSET _svgame+8228
	mov	DWORD PTR _lerp$[ebp], ecx

; 839  : 
; 840  : 		VectorCopy( check->edict->v.origin, lerp->oldpos );

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR [eax+edx+136]
	mov	DWORD PTR [esi+ecx+52], edx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR [esi+eax+52], ecx
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR [esi+edx+52], eax

; 841  : 		VectorCopy( check->edict->v.absmin, lerp->mins );

	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+324]
	mov	DWORD PTR [esi+eax+16], ecx
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR [eax+ecx+324]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR [edx+eax+324]
	mov	DWORD PTR [esi+ecx+16], edx

; 842  : 		VectorCopy( check->edict->v.absmax, lerp->maxs );

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR [ecx+eax+336]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR [edx+eax+336]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+336]
	mov	DWORD PTR [esi+eax+28], ecx

; 843  : 		lerp->active = true;

	mov	edx, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [edx], 1

; 844  : 	}

	jmp	$LN2@SV_SetupMo
$LN3@SV_SetupMo:

; 845  : 
; 846  : 	latency = Q_min( cl->latency, 1.5f );

	mov	eax, DWORD PTR _cl$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [eax+264972]
	jbe	SHORT $LN48@SV_SetupMo
	mov	ecx, DWORD PTR _cl$[ebp]
	movss	xmm0, DWORD PTR [ecx+264972]
	movss	DWORD PTR tv179[ebp], xmm0
	jmp	SHORT $LN49@SV_SetupMo
$LN48@SV_SetupMo:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv179[ebp], xmm0
$LN49@SV_SetupMo:
	movss	xmm0, DWORD PTR tv179[ebp]
	movss	DWORD PTR _latency$[ebp], xmm0

; 847  : 
; 848  : 	if( sv_maxunlag.value != 0.0f )

	movss	xmm0, DWORD PTR _sv_maxunlag+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@SV_SetupMo

; 849  : 	{
; 850  : 		if (sv_maxunlag.value < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _sv_maxunlag+12
	jbe	SHORT $LN18@SV_SetupMo

; 851  : 			Cvar_SetValue( "sv_maxunlag", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136996
	call	_Cvar_SetValue
	add	esp, 8
$LN18@SV_SetupMo:

; 852  : 		latency = Q_min( latency, sv_maxunlag.value );

	movss	xmm0, DWORD PTR _sv_maxunlag+12
	comiss	xmm0, DWORD PTR _latency$[ebp]
	jbe	SHORT $LN50@SV_SetupMo
	movss	xmm0, DWORD PTR _latency$[ebp]
	movss	DWORD PTR tv185[ebp], xmm0
	jmp	SHORT $LN51@SV_SetupMo
$LN50@SV_SetupMo:
	movss	xmm0, DWORD PTR _sv_maxunlag+12
	movss	DWORD PTR tv185[ebp], xmm0
$LN51@SV_SetupMo:
	movss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR _latency$[ebp], xmm0
$LN17@SV_SetupMo:

; 853  : 	}
; 854  : 
; 855  : 	lerp_msec = cl->lastcmd.lerp_msec * 0.001f;

	mov	edx, DWORD PTR _cl$[ebp]
	movsx	eax, WORD PTR [edx+264888]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _lerp_msec$[ebp], xmm0

; 856  : 	if( lerp_msec > 0.1f ) lerp_msec = 0.1f;

	movss	xmm0, DWORD PTR _lerp_msec$[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN19@SV_SetupMo
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _lerp_msec$[ebp], xmm0
$LN19@SV_SetupMo:

; 857  : 
; 858  : 	if( lerp_msec < cl->cl_updaterate )

	cvtss2sd xmm0, DWORD PTR _lerp_msec$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	xmm1, QWORD PTR [ecx+264392]
	comisd	xmm1, xmm0
	jbe	SHORT $LN20@SV_SetupMo

; 859  : 		lerp_msec = cl->cl_updaterate;

	mov	edx, DWORD PTR _cl$[ebp]
	cvtsd2ss xmm0, QWORD PTR [edx+264392]
	movss	DWORD PTR _lerp_msec$[ebp], xmm0
$LN20@SV_SetupMo:

; 860  : 
; 861  : 	finalpush = ( host.realtime - latency - lerp_msec ) + sv_unlagpush.value;

	cvtss2sd xmm0, DWORD PTR _latency$[ebp]
	movsd	xmm1, QWORD PTR _host+1440
	subsd	xmm1, xmm0
	cvtss2sd xmm0, DWORD PTR _lerp_msec$[ebp]
	subsd	xmm1, xmm0
	cvtss2sd xmm0, DWORD PTR _sv_unlagpush+12
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _finalpush$[ebp], xmm0

; 862  : 	if( finalpush > host.realtime ) finalpush = host.realtime; // pushed too much ?

	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN21@SV_SetupMo
	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _finalpush$[ebp], xmm0
$LN21@SV_SetupMo:

; 863  : 
; 864  : 	frame = frame2 = NULL;

	mov	DWORD PTR _frame2$[ebp], 0
	mov	eax, DWORD PTR _frame2$[ebp]
	mov	DWORD PTR _frame$[ebp], eax

; 865  : 
; 866  : 	for( i = 0; i < SV_UPDATE_BACKUP; i++, frame2 = frame )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_SetupMo
$LN5@SV_SetupMo:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _frame2$[ebp], edx
$LN7@SV_SetupMo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SV_UPDATE_BACKUP
	jge	$LN6@SV_SetupMo

; 867  : 	{
; 868  : 		frame = &cl->frames[(cl->netchan.outgoing_sequence - (i + 1)) & SV_UPDATE_MASK];

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+640]
	sub	eax, ecx
	mov	ecx, DWORD PTR _SV_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	imul	edx, eax, 6128
	mov	eax, DWORD PTR _cl$[ebp]
	add	edx, DWORD PTR [eax+281916]
	mov	DWORD PTR _frame$[ebp], edx

; 869  : 
; 870  : 		for( j = 0; j < frame->num_entities; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_SetupMo
$LN8@SV_SetupMo:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN10@SV_SetupMo:
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+6120]
	jge	$LN9@SV_SetupMo

; 871  : 		{
; 872  : 			state = &svs.packet_entities[(frame->first_entity+j)%svs.num_client_entities];

	mov	ecx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [ecx+6124]
	add	eax, DWORD PTR _j$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	edx, edx, 340
	add	edx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], edx

; 873  : 
; 874  : 			if( state->number < 1 || state->number > svs.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN23@SV_SetupMo
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _svs+16
	jle	SHORT $LN22@SV_SetupMo
$LN23@SV_SetupMo:

; 875  : 				continue;

	jmp	SHORT $LN8@SV_SetupMo
$LN22@SV_SetupMo:

; 876  : 
; 877  : 			lerp = &svgame.interp[state->number-1];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	imul	edx, ecx, 88
	add	edx, OFFSET _svgame+8228
	mov	DWORD PTR _lerp$[ebp], edx

; 878  : 			if( lerp->nointerp ) continue;

	mov	eax, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN24@SV_SetupMo
	jmp	SHORT $LN8@SV_SetupMo
$LN24@SV_SetupMo:

; 879  : 
; 880  : 			if( state->health <= 0 || FBitSet( state->effects, EF_NOINTERP ))

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+172], 0
	jle	SHORT $LN26@SV_SetupMo
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+60]
	and	eax, 32					; 00000020H
	je	SHORT $LN25@SV_SetupMo
$LN26@SV_SetupMo:

; 881  : 				lerp->nointerp = true;

	mov	ecx, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [ecx+12], 1
$LN25@SV_SetupMo:

; 882  : 
; 883  : 			if( lerp->firstframe )

	mov	edx, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN27@SV_SetupMo

; 884  : 			{
; 885  : 				if( SV_UnlagCheckTeleport( state->origin, lerp->finalpos ))

	mov	eax, DWORD PTR _lerp$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_SV_UnlagCheckTeleport
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@SV_SetupMo

; 886  : 					lerp->nointerp = true;

	mov	edx, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [edx+12], 1
$LN29@SV_SetupMo:

; 887  : 			}

	jmp	SHORT $LN28@SV_SetupMo
$LN27@SV_SetupMo:

; 888  : 			else lerp->firstframe = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN28@SV_SetupMo:

; 889  : 
; 890  : 			VectorCopy( state->origin, lerp->finalpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _lerp$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [eax+ecx+76], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+76], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _lerp$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+76], ecx

; 891  : 		}

	jmp	$LN8@SV_SetupMo
$LN9@SV_SetupMo:

; 892  : 
; 893  : 		if( finalpush > frame->senttime )

	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	comisd	xmm0, QWORD PTR [edx]
	jbe	SHORT $LN30@SV_SetupMo

; 894  : 			break;

	jmp	SHORT $LN6@SV_SetupMo
$LN30@SV_SetupMo:

; 895  : 	}

	jmp	$LN5@SV_SetupMo
$LN6@SV_SetupMo:

; 896  : 
; 897  : 	if( i == SV_UPDATE_BACKUP || finalpush - frame->senttime > 1.0 )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SV_UPDATE_BACKUP
	je	SHORT $LN32@SV_SetupMo
	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	subsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN31@SV_SetupMo
$LN32@SV_SetupMo:

; 898  : 	{
; 899  : 		memset( svgame.interp, 0, sizeof( svgame.interp ));

	push	2816					; 00000b00H
	push	0
	push	OFFSET _svgame+8228
	call	_memset
	add	esp, 12					; 0000000cH

; 900  : 		has_update = false;

	mov	DWORD PTR _has_update, 0

; 901  : 		return;

	jmp	$LN12@SV_SetupMo
$LN31@SV_SetupMo:

; 902  : 	}
; 903  : 
; 904  : 	if( !frame2 )

	cmp	DWORD PTR _frame2$[ebp], 0
	jne	SHORT $LN33@SV_SetupMo

; 905  : 	{
; 906  : 		frame2 = frame;

	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _frame2$[ebp], edx

; 907  : 		lerpFrac = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 908  : 	}

	jmp	$LN36@SV_SetupMo
$LN33@SV_SetupMo:

; 909  : 	else
; 910  : 	{
; 911  : 		if( frame2->senttime - frame->senttime == 0.0 )

	mov	eax, DWORD PTR _frame2$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	subsd	xmm0, QWORD PTR [ecx]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN35@SV_SetupMo

; 912  : 		{
; 913  : 			lerpFrac = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 914  : 		}

	jmp	SHORT $LN36@SV_SetupMo
$LN35@SV_SetupMo:

; 915  : 		else
; 916  : 		{
; 917  : 			lerpFrac = (finalpush - frame->senttime) / (frame2->senttime - frame->senttime);

	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	subsd	xmm0, QWORD PTR [edx]
	mov	eax, DWORD PTR _frame2$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	movsd	xmm1, QWORD PTR [eax]
	subsd	xmm1, QWORD PTR [ecx]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 918  : 			lerpFrac = bound( 0.0f, lerpFrac, 1.0f );

	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN54@SV_SetupMo
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _lerpFrac$[ebp]
	jbe	SHORT $LN52@SV_SetupMo
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	movss	DWORD PTR tv297[ebp], xmm0
	jmp	SHORT $LN53@SV_SetupMo
$LN52@SV_SetupMo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv297[ebp], xmm0
$LN53@SV_SetupMo:
	movss	xmm0, DWORD PTR tv297[ebp]
	movss	DWORD PTR tv298[ebp], xmm0
	jmp	SHORT $LN55@SV_SetupMo
$LN54@SV_SetupMo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv298[ebp], xmm0
$LN55@SV_SetupMo:
	movss	xmm0, DWORD PTR tv298[ebp]
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN36@SV_SetupMo:

; 919  : 		}
; 920  : 	}
; 921  : 
; 922  : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@SV_SetupMo
$LN11@SV_SetupMo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@SV_SetupMo:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+6120]
	jge	$LN12@SV_SetupMo

; 923  : 	{
; 924  : 		state = &svs.packet_entities[(frame->first_entity+i)%svs.num_client_entities];

	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx+6124]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	eax, edx, 340
	add	eax, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], eax

; 925  : 
; 926  : 		if( state->number < 1 || state->number > svs.maxclients )

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jl	SHORT $LN38@SV_SetupMo
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN37@SV_SetupMo
$LN38@SV_SetupMo:

; 927  : 			continue;

	jmp	SHORT $LN11@SV_SetupMo
$LN37@SV_SetupMo:

; 928  : 
; 929  : 		clientnum = state->number - 1;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	DWORD PTR _clientnum$[ebp], edx

; 930  : 		check = &svs.clients[clientnum];

	imul	eax, DWORD PTR _clientnum$[ebp], 287560
	add	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _check$[ebp], eax

; 931  : 
; 932  : 		if( check->state != cs_spawned || check == cl )

	mov	ecx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN40@SV_SetupMo
	mov	edx, DWORD PTR _check$[ebp]
	cmp	edx, DWORD PTR _cl$[ebp]
	jne	SHORT $LN39@SV_SetupMo
$LN40@SV_SetupMo:

; 933  : 			continue;

	jmp	$LN11@SV_SetupMo
$LN39@SV_SetupMo:

; 934  : 
; 935  : 		lerp = &svgame.interp[clientnum];

	imul	eax, DWORD PTR _clientnum$[ebp], 88
	add	eax, OFFSET _svgame+8228
	mov	DWORD PTR _lerp$[ebp], eax

; 936  : 
; 937  : 		if( !lerp->active || lerp->nointerp )

	mov	ecx, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN42@SV_SetupMo
	mov	edx, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN41@SV_SetupMo
$LN42@SV_SetupMo:

; 938  : 			continue;

	jmp	$LN11@SV_SetupMo
$LN41@SV_SetupMo:

; 939  : 
; 940  : 		lerpstate = SV_FindEntInPack( state->number, frame2 );

	mov	eax, DWORD PTR _frame2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_SV_FindEntInPack
	add	esp, 8
	mov	DWORD PTR _lerpstate$[ebp], eax

; 941  : 
; 942  : 		if( !lerpstate )

	cmp	DWORD PTR _lerpstate$[ebp], 0
	jne	SHORT $LN43@SV_SetupMo

; 943  : 		{
; 944  : 			VectorCopy( state->origin, curpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _curpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _curpos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _curpos$[ebp+ecx], eax

; 945  : 		}

	jmp	$LN44@SV_SetupMo
$LN43@SV_SetupMo:

; 946  : 		else
; 947  : 		{
; 948  : 			VectorSubtract( lerpstate->origin, state->origin, newpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _lerpstate$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+16]
	subss	xmm0, DWORD PTR [esi+ecx+16]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _newpos$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _lerpstate$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx+16]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _newpos$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _lerpstate$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+16]
	subss	xmm0, DWORD PTR [esi+edx+16]
	movss	DWORD PTR tv370[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv370[ebp]
	movss	DWORD PTR _newpos$[ebp+ecx], xmm0

; 949  : 			VectorMA( state->origin, lerpFrac, newpos, curpos );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	mulss	xmm0, DWORD PTR _newpos$[ebp+edx]
	mov	ecx, DWORD PTR _state$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _curpos$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	mulss	xmm0, DWORD PTR _newpos$[ebp+edx]
	mov	eax, DWORD PTR _state$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+16]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _curpos$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	mulss	xmm0, DWORD PTR _newpos$[ebp+eax]
	mov	ecx, DWORD PTR _state$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+16]
	addss	xmm1, xmm0
	movss	DWORD PTR tv397[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR _curpos$[ebp+edx], xmm0
$LN44@SV_SetupMo:

; 950  : 		}
; 951  : 
; 952  : 		VectorCopy( curpos, lerp->curpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp+ecx]
	mov	DWORD PTR [edx+eax+40], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR _curpos$[ebp+edx]
	mov	DWORD PTR [ecx+eax+40], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp+eax]
	mov	DWORD PTR [edx+ecx+40], eax

; 953  : 		VectorCopy( curpos, lerp->newpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR _curpos$[ebp+edx]
	mov	DWORD PTR [eax+ecx+64], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp+eax]
	mov	DWORD PTR [edx+ecx+64], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp+ecx]
	mov	DWORD PTR [eax+edx+64], ecx

; 954  : 
; 955  : 		if( !VectorCompare( curpos, check->edict->v.origin ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _curpos$[ebp+eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@SV_SetupMo
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _curpos$[ebp+edx]
	ucomiss	xmm0, DWORD PTR [ecx+eax+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@SV_SetupMo
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _curpos$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR [eax+edx+136]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN45@SV_SetupMo
$LN46@SV_SetupMo:

; 956  : 		{
; 957  : 			VectorCopy( curpos, check->edict->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264980]
	mov	edx, 4
	imul	edx, edx, 0
	mov	ecx, DWORD PTR _curpos$[ebp+ecx]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	eax, 4
	shl	eax, 0
	mov	edx, DWORD PTR _curpos$[ebp+edx]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _curpos$[ebp+eax]
	mov	DWORD PTR [edx+ecx+136], eax

; 958  : 			SV_LinkEdict( check->edict, false );

	push	0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	_SV_LinkEdict
	add	esp, 8

; 959  : 			lerp->moving = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax+4], 1
$LN45@SV_SetupMo:

; 960  : 		}
; 961  : 	}

	jmp	$LN11@SV_SetupMo
$LN12@SV_SetupMo:

; 962  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetupMoveInterpolant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv85 = -12						; size = 8
_i$ = -4						; size = 4
_old_pos$ = 8						; size = 4
_new_pos$ = 12						; size = 4
_SV_UnlagCheckTeleport PROC

; 803  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 804  : 	int	i;
; 805  : 
; 806  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_UnlagCh
$LN2@SV_UnlagCh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_UnlagCh:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_UnlagCh

; 807  : 	{
; 808  : 		if( fabs( old_pos[i] - new_pos[i] ) > 64.0f )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _old_pos$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _new_pos$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [esi+eax*4]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv85[ebp]
	movsd	xmm0, QWORD PTR tv85[ebp]
	comisd	xmm0, QWORD PTR __real@4050000000000000
	jbe	SHORT $LN5@SV_UnlagCh

; 809  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_UnlagCh
$LN5@SV_UnlagCh:

; 810  : 	}

	jmp	SHORT $LN2@SV_UnlagCh
$LN3@SV_UnlagCh:

; 811  : 	return false;

	xor	eax, eax
$LN1@SV_UnlagCh:

; 812  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UnlagCheckTeleport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_state$ = -8						; size = 4
_i$ = -4						; size = 4
_index$ = 8						; size = 4
_frame$ = 12						; size = 4
_SV_FindEntInPack PROC

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 789  : 	entity_state_t	*state;
; 790  : 	int		i;	
; 791  : 
; 792  : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_FindEnt
$LN2@SV_FindEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_FindEnt:
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+6120]
	jge	SHORT $LN3@SV_FindEnt

; 793  : 	{
; 794  : 		state = &svs.packet_entities[(frame->first_entity+i)%svs.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+6124]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 340
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], ecx

; 795  : 
; 796  : 		if( state->number == index )

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _index$[ebp]
	jne	SHORT $LN5@SV_FindEnt

; 797  : 			return state;

	mov	eax, DWORD PTR _state$[ebp]
	jmp	SHORT $LN1@SV_FindEnt
$LN5@SV_FindEnt:

; 798  : 	}

	jmp	SHORT $LN2@SV_FindEnt
$LN3@SV_FindEnt:

; 799  : 	return NULL;

	xor	eax, eax
$LN1@SV_FindEnt:

; 800  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindEntInPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_clent$ = -4						; size = 4
_pmove$ = 8						; size = 4
_cl$ = 12						; size = 4
_SV_FinishPMove PROC

; 721  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 722  : 	edict_t	*clent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _clent$[ebp], ecx

; 723  : 
; 724  : 	clent->v.teleport_time = pmove->waterjumptime;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	DWORD PTR [edx+564], ecx

; 725  : 	VectorCopy( pmove->origin, clent->v.origin );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+56]
	mov	DWORD PTR [ecx+edx+136], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+56]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+56]
	mov	DWORD PTR [ecx+eax+136], edx

; 726  : 	VectorCopy( pmove->view_ofs, clent->v.view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+128]
	mov	DWORD PTR [edx+eax+500], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+128]
	mov	DWORD PTR [ecx+eax+500], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+128]
	mov	DWORD PTR [edx+ecx+500], eax

; 727  : 	VectorCopy( pmove->velocity, clent->v.velocity );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [eax+ecx+160], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+160], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [eax+edx+160], ecx

; 728  : 	VectorCopy( pmove->basevelocity, clent->v.basevelocity );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+116]
	mov	DWORD PTR [ecx+edx+172], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+116]
	mov	DWORD PTR [eax+edx+172], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+116]
	mov	DWORD PTR [ecx+eax+172], edx

; 729  : 	VectorCopy( pmove->punchangle, clent->v.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+160]
	mov	DWORD PTR [edx+eax+232], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+160]
	mov	DWORD PTR [ecx+eax+232], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+160]
	mov	DWORD PTR [edx+ecx+232], eax

; 730  : 	VectorCopy( pmove->movedir, clent->v.movedir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+104]
	mov	DWORD PTR [eax+ecx+196], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+104]
	mov	DWORD PTR [edx+ecx+196], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+104]
	mov	DWORD PTR [eax+edx+196], ecx

; 731  : 	clent->v.flTimeStepSound = pmove->flTimeStepSound;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR [edx+676], ecx

; 732  : 	clent->v.flFallVelocity = pmove->flFallVelocity;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	DWORD PTR [edx+692], ecx

; 733  : 	clent->v.oldbuttons = pmove->oldbuttons;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR [edx+700], ecx

; 734  : 	clent->v.waterlevel = pmove->waterlevel;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR [edx+576], ecx

; 735  : 	clent->v.watertype = pmove->watertype;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	mov	DWORD PTR [edx+580], ecx

; 736  : 	clent->v.maxspeed = pmove->clientmaxspeed;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+504]
	mov	DWORD PTR [edx+656], ecx

; 737  : 	clent->v.flDuckTime = pmove->flDuckTime;

	mov	edx, DWORD PTR _pmove$[ebp]
	cvttss2si eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+684], eax

; 738  : 	clent->v.flSwimTime = pmove->flSwimTime;

	mov	edx, DWORD PTR _pmove$[ebp]
	cvttss2si eax, DWORD PTR [edx+172]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 739  : 	clent->v.iStepLeft = pmove->iStepLeft;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR [edx+688], ecx

; 740  : 	clent->v.movetype = pmove->movetype;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	mov	DWORD PTR [edx+392], ecx

; 741  : 	clent->v.friction = pmove->friction;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR [edx+416], ecx

; 742  : 	clent->v.deadflag = pmove->deadflag;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR [edx+496], ecx

; 743  : 	clent->v.effects = pmove->effects;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	mov	DWORD PTR [edx+408], ecx

; 744  : 	clent->v.bInDuck = pmove->bInDuck;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR [edx+672], ecx

; 745  : 	clent->v.flags = pmove->flags;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+548], ecx

; 746  : 
; 747  : 	// copy back user variables
; 748  : 	clent->v.iuser1 = pmove->iuser1;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	mov	DWORD PTR [edx+708], ecx

; 749  : 	clent->v.iuser2 = pmove->iuser2;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR [edx+712], ecx

; 750  : 	clent->v.iuser3 = pmove->iuser3;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	mov	DWORD PTR [edx+716], ecx

; 751  : 	clent->v.iuser4 = pmove->iuser4;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+520]
	mov	DWORD PTR [edx+720], ecx

; 752  : 	clent->v.fuser1 = pmove->fuser1;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+524]
	mov	DWORD PTR [edx+724], ecx

; 753  : 	clent->v.fuser2 = pmove->fuser2;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+528]
	mov	DWORD PTR [edx+728], ecx

; 754  : 	clent->v.fuser3 = pmove->fuser3;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	mov	DWORD PTR [edx+732], ecx

; 755  : 	clent->v.fuser4 = pmove->fuser4;

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+536]
	mov	DWORD PTR [edx+736], ecx

; 756  : 	VectorCopy( pmove->vuser1, clent->v.vuser1 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+540]
	mov	DWORD PTR [ecx+edx+740], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+540]
	mov	DWORD PTR [eax+edx+740], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+540]
	mov	DWORD PTR [ecx+eax+740], edx

; 757  : 	VectorCopy( pmove->vuser2, clent->v.vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+552]
	mov	DWORD PTR [edx+eax+752], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+552]
	mov	DWORD PTR [ecx+eax+752], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+552]
	mov	DWORD PTR [edx+ecx+752], eax

; 758  : 	VectorCopy( pmove->vuser3, clent->v.vuser3 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+564]
	mov	DWORD PTR [eax+ecx+764], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+564]
	mov	DWORD PTR [edx+ecx+764], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+564]
	mov	DWORD PTR [eax+edx+764], ecx

; 759  : 	VectorCopy( pmove->vuser4, clent->v.vuser4 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+576]
	mov	DWORD PTR [ecx+edx+776], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+576]
	mov	DWORD PTR [eax+edx+776], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+576]
	mov	DWORD PTR [ecx+eax+776], edx

; 760  : 
; 761  : 	if( pmove->onground == -1 )

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+224], -1
	jne	SHORT $LN2@SV_FinishP

; 762  : 	{
; 763  : 		ClearBits( clent->v.flags, FL_ONGROUND );

	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [eax+548], edx

; 764  : 	}

	jmp	SHORT $LN4@SV_FinishP
$LN2@SV_FinishP:

; 765  : 	else if( pmove->onground >= 0 && pmove->onground < pmove->numphysent )

	mov	ecx, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [ecx+224], 0
	jl	SHORT $LN4@SV_FinishP
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [edx+224]
	cmp	ecx, DWORD PTR [eax+588]
	jge	SHORT $LN4@SV_FinishP

; 766  : 	{
; 767  : 		SetBits( clent->v.flags, FL_ONGROUND );

	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+548], eax

; 768  : 		clent->v.groundentity = EDICT_NUM( pmove->physents[pmove->onground].info );

	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+224], 224
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+eax+672]
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+540], eax
$LN4@SV_FinishP:

; 769  : 	}
; 770  : 
; 771  : 	// angles
; 772  : 	// show 1/3 the pitch angle and all the roll angle	
; 773  : 	if( !clent->v.fixangle )

	mov	edx, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [edx+288], 0
	jne	$LN5@SV_FinishP

; 774  : 	{
; 775  : 		VectorCopy( pmove->angles, clent->v.v_angle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+68]
	mov	DWORD PTR [edx+eax+244], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+68]
	mov	DWORD PTR [ecx+eax+244], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+68]
	mov	DWORD PTR [edx+ecx+244], eax

; 776  : 		clent->v.angles[PITCH] = -( clent->v.v_angle[PITCH] / 3.0f );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+244]
	divss	xmm0, DWORD PTR __real@40400000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	movss	DWORD PTR [eax+edx+208], xmm0

; 777  : 		clent->v.angles[ROLL] = clent->v.v_angle[ROLL];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [eax+edx+208], ecx

; 778  : 		clent->v.angles[YAW] = clent->v.v_angle[YAW];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [ecx+eax+208], edx
$LN5@SV_FinishP:

; 779  : 	}
; 780  : 
; 781  : 	SV_SetMinMaxSize( clent, pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], false );

	push	0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324900]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324852]
	push	ecx
	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H

; 782  : 
; 783  : 	// all next calls ignore footstep sounds
; 784  : 	pmove->runfuncs = false;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+325040], 0

; 785  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FinishPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv297 = -48						; size = 4
tv250 = -44						; size = 4
tv77 = -40						; size = 4
_i$ = -36						; size = 4
_clent$ = -32						; size = 4
_absmin$ = -28						; size = 12
_absmax$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_cl$ = 12						; size = 4
_ucmd$ = 16						; size = 4
_physinfo$ = 20						; size = 4
_SV_SetupPMove PROC

; 641  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 642  : 	vec3_t	absmin, absmax;
; 643  : 	edict_t	*clent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _clent$[ebp], ecx

; 644  : 	int	i;
; 645  : 
; 646  : 	svgame.globals->frametime = (ucmd->msec * 0.001f);

	mov	edx, DWORD PTR _ucmd$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3a83126f
	mov	ecx, DWORD PTR _svgame+19236
	movss	DWORD PTR [ecx+4], xmm0

; 647  : 
; 648  : 	pmove->player_index = NUM_FOR_EDICT( clent ) - 1;

	mov	eax, DWORD PTR _clent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	sub	eax, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [edx], eax

; 649  : 	pmove->multiplayer = (svs.maxclients > 1) ? true : false;

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN7@SV_SetupPM
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN8@SV_SetupPM
$LN7@SV_SetupPM:
	mov	DWORD PTR tv77[ebp], 0
$LN8@SV_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR [eax+8], ecx

; 650  : 	pmove->time = (float)(cl->timebase * 1000.0);

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [edx+264400]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 651  : 	VectorCopy( clent->v.origin, pmove->origin );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [eax+ecx+56], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+56], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [eax+edx+56], ecx

; 652  : 	VectorCopy( clent->v.v_angle, pmove->angles );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [ecx+edx+68], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [eax+edx+68], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [ecx+eax+68], edx

; 653  : 	VectorCopy( clent->v.v_angle, pmove->oldangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [edx+eax+80], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [ecx+eax+80], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+80], eax

; 654  : 	VectorCopy( clent->v.velocity, pmove->velocity );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+160]
	mov	DWORD PTR [eax+ecx+92], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+160]
	mov	DWORD PTR [edx+ecx+92], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+160]
	mov	DWORD PTR [eax+edx+92], ecx

; 655  : 	VectorCopy( clent->v.basevelocity, pmove->basevelocity );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+172]
	mov	DWORD PTR [ecx+edx+116], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+172]
	mov	DWORD PTR [eax+edx+116], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+172]
	mov	DWORD PTR [ecx+eax+116], edx

; 656  : 	VectorCopy( clent->v.view_ofs, pmove->view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+500]
	mov	DWORD PTR [edx+eax+128], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+500]
	mov	DWORD PTR [ecx+eax+128], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+500]
	mov	DWORD PTR [edx+ecx+128], eax

; 657  : 	VectorCopy( clent->v.movedir, pmove->movedir );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+196]
	mov	DWORD PTR [eax+ecx+104], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+196]
	mov	DWORD PTR [edx+ecx+104], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+196]
	mov	DWORD PTR [eax+edx+104], ecx

; 658  : 	pmove->flDuckTime = clent->v.flDuckTime;

	mov	edx, DWORD PTR _clent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+684]
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+140], xmm0

; 659  : 	pmove->bInDuck = clent->v.bInDuck;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR [ecx+144], eax

; 660  : 	pmove->usehull = (clent->v.flags & FL_DUCKING) ? 1 : 0; // reset hull

	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 16384				; 00004000H
	je	SHORT $LN9@SV_SetupPM
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN10@SV_SetupPM
$LN9@SV_SetupPM:
	mov	DWORD PTR tv250[ebp], 0
$LN10@SV_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv250[ebp]
	mov	DWORD PTR [eax+188], ecx

; 661  : 	pmove->flTimeStepSound = clent->v.flTimeStepSound;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+676]
	mov	DWORD PTR [edx+148], ecx

; 662  : 	pmove->iStepLeft = clent->v.iStepLeft;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+688]
	mov	DWORD PTR [edx+152], ecx

; 663  : 	pmove->flFallVelocity = clent->v.flFallVelocity;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	DWORD PTR [edx+156], ecx

; 664  : 	pmove->flSwimTime = clent->v.flSwimTime;

	mov	edx, DWORD PTR _clent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+680]
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+172], xmm0

; 665  : 	VectorCopy( clent->v.punchangle, pmove->punchangle );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+232]
	mov	DWORD PTR [eax+ecx+160], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+232]
	mov	DWORD PTR [edx+ecx+160], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+232]
	mov	DWORD PTR [eax+edx+160], ecx

; 666  : 	pmove->flSwimTime = clent->v.flSwimTime;

	mov	edx, DWORD PTR _clent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+680]
	mov	eax, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [eax+172], xmm0

; 667  : 	pmove->flNextPrimaryAttack = 0.0f; // not used by PM_ code

	mov	ecx, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+176], xmm0

; 668  : 	pmove->effects = clent->v.effects;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	DWORD PTR [edx+180], ecx

; 669  : 	pmove->flags = clent->v.flags;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	mov	DWORD PTR [edx+184], ecx

; 670  : 	pmove->gravity = clent->v.gravity;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+412]
	mov	DWORD PTR [edx+192], ecx

; 671  : 	pmove->friction = clent->v.friction;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+416]
	mov	DWORD PTR [edx+196], ecx

; 672  : 	pmove->oldbuttons = clent->v.oldbuttons;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+700]
	mov	DWORD PTR [edx+200], ecx

; 673  : 	pmove->waterjumptime = clent->v.teleport_time;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+564]
	mov	DWORD PTR [edx+204], ecx

; 674  : 	pmove->dead = (clent->v.health <= 0.0f ) ? true : false;

	mov	edx, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+480]
	jb	SHORT $LN11@SV_SetupPM
	mov	DWORD PTR tv297[ebp], 1
	jmp	SHORT $LN12@SV_SetupPM
$LN11@SV_SetupPM:
	mov	DWORD PTR tv297[ebp], 0
$LN12@SV_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv297[ebp]
	mov	DWORD PTR [eax+208], ecx

; 675  : 	pmove->deadflag = clent->v.deadflag;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+496]
	mov	DWORD PTR [edx+212], ecx

; 676  : 	pmove->spectator = 0; // spectator physic all execute on client

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [edx+216], 0

; 677  : 	pmove->movetype = clent->v.movetype;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+220], edx

; 678  : 	if( pmove->multiplayer ) pmove->onground = -1;

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@SV_SetupPM
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [ecx+224], -1
$LN5@SV_SetupPM:

; 679  : 	pmove->waterlevel = clent->v.waterlevel;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR [edx+228], ecx

; 680  : 	pmove->watertype = clent->v.watertype;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	mov	DWORD PTR [edx+232], ecx

; 681  : 	pmove->maxspeed = svgame.movevars.maxspeed;

	mov	edx, DWORD PTR _pmove$[ebp]
	movss	xmm0, DWORD PTR _svgame+7944
	movss	DWORD PTR [edx+500], xmm0

; 682  : 	pmove->clientmaxspeed = clent->v.maxspeed;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	mov	DWORD PTR [eax+504], edx

; 683  : 	pmove->iuser1 = clent->v.iuser1;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+708]
	mov	DWORD PTR [eax+508], edx

; 684  : 	pmove->iuser2 = clent->v.iuser2;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	mov	DWORD PTR [eax+512], edx

; 685  : 	pmove->iuser3 = clent->v.iuser3;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+716]
	mov	DWORD PTR [eax+516], edx

; 686  : 	pmove->iuser4 = clent->v.iuser4;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+720]
	mov	DWORD PTR [eax+520], edx

; 687  : 	pmove->fuser1 = clent->v.fuser1;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+724]
	mov	DWORD PTR [eax+524], edx

; 688  : 	pmove->fuser2 = clent->v.fuser2;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	mov	DWORD PTR [eax+528], edx

; 689  : 	pmove->fuser3 = clent->v.fuser3;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR [eax+532], edx

; 690  : 	pmove->fuser4 = clent->v.fuser4;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+736]
	mov	DWORD PTR [eax+536], edx

; 691  : 	VectorCopy( clent->v.vuser1, pmove->vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+740]
	mov	DWORD PTR [edx+eax+540], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+740]
	mov	DWORD PTR [ecx+eax+540], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+740]
	mov	DWORD PTR [edx+ecx+540], eax

; 692  : 	VectorCopy( clent->v.vuser2, pmove->vuser2 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+752]
	mov	DWORD PTR [eax+ecx+552], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+752]
	mov	DWORD PTR [edx+ecx+552], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+752]
	mov	DWORD PTR [eax+edx+552], ecx

; 693  : 	VectorCopy( clent->v.vuser3, pmove->vuser3 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+764]
	mov	DWORD PTR [ecx+edx+564], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+764]
	mov	DWORD PTR [eax+edx+564], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+764]
	mov	DWORD PTR [ecx+eax+564], edx

; 694  : 	VectorCopy( clent->v.vuser4, pmove->vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+776]
	mov	DWORD PTR [edx+eax+576], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+776]
	mov	DWORD PTR [ecx+eax+576], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+776]
	mov	DWORD PTR [edx+ecx+576], eax

; 695  : 	pmove->cmd = *ucmd;	// setup current cmds	

	mov	edi, DWORD PTR _pmove$[ebp]
	add	edi, 283736				; 00045458H
	mov	ecx, 13					; 0000000dH
	mov	esi, DWORD PTR _ucmd$[ebp]
	rep movsd

; 696  : 	pmove->runfuncs = true;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [ecx+325040], 1

; 697  : 	
; 698  : 	Q_strncpy( pmove->physinfo, physinfo, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	edx, DWORD PTR _physinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	add	eax, 324592				; 0004f3f0H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 699  : 
; 700  : 	// setup physents
; 701  : 	pmove->numvisent = 0;

	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [ecx+149332], 0

; 702  : 	pmove->numphysent = 0;

	mov	edx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [edx+588], 0

; 703  : 	pmove->nummoveent = 0;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+134992], 0

; 704  : 
; 705  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SetupPM
$LN2@SV_SetupPM:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_SetupPM:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_SetupPM

; 706  : 	{
; 707  : 		absmin[i] = clent->v.origin[i] - 256.0f;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+136]
	subss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _absmin$[ebp+ecx*4], xmm0

; 708  : 		absmax[i] = clent->v.origin[i] + 256.0f;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+136]
	addss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _absmax$[ebp+ecx*4], xmm0

; 709  : 	}

	jmp	SHORT $LN2@SV_SetupPM
$LN3@SV_SetupPM:

; 710  : 
; 711  : 	SV_CopyEdictToPhysEnt( &svgame.pmove->physents[0], &svgame.edicts[0] );

	mov	edx, 804				; 00000324H
	imul	eax, edx, 0
	add	eax, DWORD PTR _svgame+7928
	push	eax
	mov	ecx, 224				; 000000e0H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [eax+edx+592]
	push	ecx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8

; 712  : 	svgame.pmove->visents[0] = svgame.pmove->physents[0];

	mov	edx, 224				; 000000e0H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8224
	lea	esi, DWORD PTR [ecx+eax+592]
	mov	edx, 224				; 000000e0H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8224
	lea	edi, DWORD PTR [ecx+eax+149336]
	mov	ecx, 56					; 00000038H
	rep movsd

; 713  : 	svgame.pmove->numphysent = 1;	// always have world

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+588], 1

; 714  : 	svgame.pmove->numvisent = 1;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+149332], 1

; 715  : 
; 716  : 	SV_AddLinksToPmove( sv_areanodes, absmin, absmax );

	lea	ecx, DWORD PTR _absmax$[ebp]
	push	ecx
	lea	edx, DWORD PTR _absmin$[ebp]
	push	edx
	push	OFFSET _sv_areanodes
	call	_SV_AddLinksToPmove
	add	esp, 12					; 0000000cH

; 717  : 	SV_AddLaddersToPmove( sv_areanodes, absmin, absmax );

	lea	eax, DWORD PTR _absmax$[ebp]
	push	eax
	lea	ecx, DWORD PTR _absmin$[ebp]
	push	ecx
	push	OFFSET _sv_areanodes
	call	_SV_AddLaddersToPmove
	add	esp, 12					; 0000000cH

; 718  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetupPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv146 = -4						; size = 4
_ent$ = 8						; size = 4
_frametime$ = 12					; size = 4
_PM_CheckMovingGround PROC

; 620  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 621  : 	if( svgame.physFuncs.SV_UpdatePlayerBaseVelocity != NULL )

	cmp	DWORD PTR _svgame+19476, 0
	je	SHORT $LN2@PM_CheckMo

; 622  : 	{
; 623  : 		svgame.physFuncs.SV_UpdatePlayerBaseVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19476
	add	esp, 4

; 624  : 	}

	jmp	SHORT $LN3@PM_CheckMo
$LN2@PM_CheckMo:

; 625  : 	else
; 626  : 	{
; 627  : 		SV_UpdateBaseVelocity( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_UpdateBaseVelocity
	add	esp, 4
$LN3@PM_CheckMo:

; 628  : 	}
; 629  : 
; 630  : 	if( !FBitSet( ent->v.flags, FL_BASEVELOCITY ))

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 4194304				; 00400000H
	jne	$LN4@PM_CheckMo

; 631  : 	{
; 632  : 		// apply momentum (add in half of the previous frame of velocity first)
; 633  : 		VectorMA( ent->v.velocity, 1.0f + (frametime * 0.5f), ent->v.basevelocity, ent->v.velocity );

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx+172]
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx+160]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+172]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+edx+160]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+172]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+160]
	addss	xmm1, xmm0
	movss	DWORD PTR tv146[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 634  : 		VectorClear( ent->v.basevelocity );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+172], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+172], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+172], xmm0
$LN4@PM_CheckMo:

; 635  : 	}
; 636  : 
; 637  : 	ClearBits( ent->v.flags, FL_BASEVELOCITY );

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, -4194305				; ffbfffffH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+548], eax

; 638  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PM_CheckMovingGround ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceSurface PROC

; 545  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 546  : 	physent_t *pe;
; 547  : 
; 548  : 	if( ground < 0 || ground >= svgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceSu
	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceSu
$LN3@pfnTraceSu:

; 549  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceSu
$LN2@pfnTraceSu:

; 550  : 
; 551  : 	pe = &svgame.pmove->physents[ground];

	imul	edx, DWORD PTR _ground$[ebp], 224
	mov	eax, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 552  : 	return PM_TraceSurface( pe, vstart, vend );

	mov	edx, DWORD PTR _vend$[ebp]
	push	edx
	mov	eax, DWORD PTR _vstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
$LN1@pfnTraceSu:

; 553  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
$T1 = -144						; size = 68
$T2 = -76						; size = 68
_old_usehull$ = -8					; size = 4
tv66 = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_pmFilter$ = 24						; size = 4
_pfnTraceLineEx PROC

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	push	edi

; 523  : 	static pmtrace_t	tr;
; 524  : 	int		old_usehull;
; 525  : 
; 526  : 	old_usehull = svgame.pmove->usehull;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 527  : 	svgame.pmove->usehull = usehull;	

	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 528  : 
; 529  : 	switch( flags )

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 530  : 	{
; 531  : 	case PM_TRACELINE_PHYSENTSONLY:
; 532  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numphysent, svgame.pmove->physents, -1, pmFilter );

	mov	edx, DWORD PTR _pmFilter$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR _svgame+8224
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	push	0
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd

; 533  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 534  : 	case PM_TRACELINE_ANYVISIBLE:
; 535  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numvisent, svgame.pmove->visents, -1, pmFilter );

	mov	ecx, DWORD PTR _pmFilter$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _svgame+8224
	add	edx, 149336				; 00024758H
	push	edx
	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+149332]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 536  : 		break;
; 537  : 	}
; 538  : 
; 539  : 	svgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 540  : 
; 541  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLineEx@@9@9

; 542  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLineEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pmFilter$ = 16						; size = 4
_pfnTestPlayerPositionEx PROC

; 517  : {

	push	ebp
	mov	ebp, esp

; 518  : 	return PM_TestPlayerPosition( svgame.pmove, pos, ptrace, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptrace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8224
	push	eax
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 519  : }

	pop	ebp
	ret	0
_pfnTestPlayerPositionEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
$T1 = -68						; size = 68
$T2 = 8							; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_pmFilter$ = 24						; size = 4
_pfnPlayerTraceEx PROC

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi

; 513  : 	return PM_PlayerTraceExt( svgame.pmove, start, end, traceFlags, svgame.pmove->numphysent, svgame.pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _svgame+8224
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]

; 514  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTraceEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_flags$ = 8						; size = 4
_clientindex$ = 12					; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_pfnPlaybackEventFull PROC

; 495  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 496  : 	edict_t	*ent;
; 497  : 
; 498  : 	ent = EDICT_NUM( clientindex + 1 );

	mov	eax, DWORD PTR _clientindex$[ebp]
	add	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 499  : 	if( !SV_IsValidEdict( ent )) return;

	push	499					; 000001f3H
	push	OFFSET $SG136834
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnPlaybac
	jmp	SHORT $LN1@pfnPlaybac
$LN2@pfnPlaybac:

; 500  : 
; 501  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN3@pfnPlaybac

; 502  : 		flags |= FEV_NOTHOST; // no local clients for dedicated server

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 1
	mov	DWORD PTR _flags$[ebp], edx
$LN3@pfnPlaybac:

; 503  : 
; 504  : 	SV_PlaybackEventFull( flags, ent, eventindex,

	mov	eax, DWORD PTR _bparam2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bparam1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iparam2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iparam1$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	call	_SV_PlaybackEventFull
	add	esp, 48					; 00000030H
$LN1@pfnPlaybac:

; 505  : 		delay, origin, angles,
; 506  : 		fparam1, fparam2,
; 507  : 		iparam1, iparam2,
; 508  : 		bparam1, bparam2 );
; 509  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaybackEventFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_channel$ = 8						; size = 4
_sample$ = 12						; size = 4
_volume$ = 16						; size = 4
_attenuation$ = 20					; size = 4
_fFlags$ = 24						; size = 4
_pitch$ = 28						; size = 4
_pfnPlaySound PROC

; 484  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 485  : 	edict_t	*ent;
; 486  : 
; 487  : 	ent = EDICT_NUM( svgame.pmove->player_index + 1 );

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 488  : 	if( !SV_IsValidEdict( ent )) return;

	push	488					; 000001e8H
	push	OFFSET $SG136805
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnPlaySou
	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 489  : 
; 490  : 	SV_StartSound( ent, channel, sample, volume, attenuation, fFlags|SND_FILTER_CLIENT, pitch );

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fFlags$[ebp]
	or	ecx, 2048				; 00000800H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attenuation$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_StartSound
	add	esp, 28					; 0000001cH
$LN1@pfnPlaySou:

; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceTexture PROC

; 473  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 474  : 	physent_t *pe;
; 475  : 
; 476  : 	if( ground < 0 || ground >= svgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceTe
	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceTe
$LN3@pfnTraceTe:

; 477  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 478  : 
; 479  : 	pe = &svgame.pmove->physents[ground];

	imul	edx, DWORD PTR _ground$[ebp], 224
	mov	eax, DWORD PTR _svgame+8224
	lea	ecx, DWORD PTR [eax+edx+592]
	mov	DWORD PTR _pe$[ebp], ecx

; 480  : 	return PM_TraceTexture( pe, vstart, vend );

	mov	edx, DWORD PTR _vend$[ebp]
	push	edx
	mov	eax, DWORD PTR _vstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_PM_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 481  : }			

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv248 = -140						; size = 4
tv170 = -136						; size = 4
tv149 = -132						; size = 4
_old_usehull$ = -128					; size = 4
_hull$ = -124						; size = 4
_rotated$ = -120					; size = 4
_matrix$ = -116						; size = 64
_temp$ = -52						; size = 12
_start_l$ = -40						; size = 12
_end_l$ = -28						; size = 12
_offset$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_trace$ = 20						; size = 4
_pfnTraceModel PROC

; 427  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 428  : 	int	old_usehull;
; 429  : 	vec3_t	start_l, end_l;
; 430  : 	vec3_t	offset, temp;
; 431  : 	qboolean	rotated;
; 432  : 	matrix4x4	matrix;
; 433  : 	hull_t	*hull;
; 434  : 
; 435  : 	old_usehull = svgame.pmove->usehull;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 436  : 	svgame.pmove->usehull = 2;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+188], 2

; 437  : 
; 438  : 	hull = PM_HullForBsp( pe, svgame.pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 439  : 
; 440  : 	svgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 441  : 
; 442  : 	if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+96], 4
	jne	SHORT $LN2@pfnTraceMo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@pfnTraceMo
$LN4@pfnTraceMo:

; 443  : 		rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN3@pfnTraceMo
$LN2@pfnTraceMo:

; 444  : 	else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN3@pfnTraceMo:

; 445  : 
; 446  :  	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN5@pfnTraceMo

; 447  :  	{
; 448  :  		Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 449  :  		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	ecx, DWORD PTR _start_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 450  :  		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 451  :  	}

	jmp	$LN6@pfnTraceMo
$LN5@pfnTraceMo:

; 452  :  	else
; 453  :  	{
; 454  :  		VectorSubtract( start, offset, start_l );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _start_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	movss	DWORD PTR tv149[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0

; 455  :  		VectorSubtract( end, offset, end_l );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	movss	DWORD PTR tv170[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
$LN6@pfnTraceMo:

; 456  :  	}
; 457  : 
; 458  : 	PM_RecursiveHullCheck( hull, hull->firstclipnode, 0, 1, start_l, end_l, (pmtrace_t *)trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 459  : 	trace->ent = NULL;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+48], 0

; 460  : 
; 461  : 	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN7@pfnTraceMo

; 462  : 	{
; 463  : 		VectorCopy( trace->plane.normal, temp );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [eax+edx+32]
	mov	DWORD PTR _temp$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR _temp$[ebp+edx], ecx

; 464  : 		Matrix4x4_TransformPositivePlane( matrix, temp, trace->plane.dist, trace->plane.normal, &trace->plane.dist );

	mov	edx, DWORD PTR _trace$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H
$LN7@pfnTraceMo:

; 465  : 	}
; 466  : 
; 467  : 	VectorLerp( start, trace->fraction, end, trace->endpos );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mov	ecx, 4
	imul	eax, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mov	eax, 4
	shl	eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	subss	xmm1, DWORD PTR [edi+edx]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv248[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv248[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0

; 468  : 
; 469  : 	return trace->fraction;

	mov	edx, DWORD PTR _trace$[ebp]
	fld	DWORD PTR [edx+16]

; 470  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pe$ = 8						; size = 4
_offset$ = 12						; size = 4
_pfnHullForBsp PROC

; 422  : {

	push	ebp
	mov	ebp, esp

; 423  : 	return PM_HullForBsp( pe, svgame.pmove, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH

; 424  : }

	pop	ebp
	ret	0
_pfnHullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
$T1 = -144						; size = 68
$T2 = -76						; size = 68
_old_usehull$ = -8					; size = 4
tv66 = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_ignore_pe$ = 24					; size = 4
_pfnTraceLine PROC

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	push	edi

; 400  : 	static pmtrace_t	tr;
; 401  : 	int		old_usehull;
; 402  : 
; 403  : 	old_usehull = svgame.pmove->usehull;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 404  : 	svgame.pmove->usehull = usehull;	

	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [edx+188], eax

; 405  : 
; 406  : 	switch( flags )

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 407  : 	{
; 408  : 	case PM_TRACELINE_PHYSENTSONLY:
; 409  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numphysent, svgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	edx, DWORD PTR _ignore_pe$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8224
	add	eax, 592				; 00000250H
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	mov	edx, DWORD PTR [ecx+588]
	push	edx
	push	0
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd

; 410  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 411  : 	case PM_TRACELINE_ANYVISIBLE:
; 412  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numvisent, svgame.pmove->visents, ignore_pe, NULL );

	push	0
	mov	ecx, DWORD PTR _ignore_pe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	add	edx, 149336				; 00024758H
	push	edx
	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+149332]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 413  : 		break;
; 414  : 	}
; 415  : 
; 416  : 	svgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 417  : 
; 418  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLine@@9@9

; 419  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
$T1 = -68						; size = 68
$T2 = 8							; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_ignore_pe$ = 24					; size = 4
_pfnPlayerTrace PROC

; 394  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi

; 395  : 	return PM_PlayerTraceExt( svgame.pmove, start, end, traceFlags, svgame.pmove->numphysent, svgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]

; 396  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p$ = 16						; size = 4
_pfnHullPointContents PROC

; 389  : {

	push	ebp
	mov	ebp, esp

; 390  : 	return PM_HullPointContents( hull, num, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH

; 391  : }

	pop	ebp
	ret	0
_pfnHullPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pfnTruePointContents PROC

; 384  : {

	push	ebp
	mov	ebp, esp

; 385  : 	return PM_TruePointContents( svgame.pmove, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	call	_PM_TruePointContents
	add	esp, 8

; 386  : }

	pop	ebp
	ret	0
_pfnTruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_truecont$ = -8						; size = 4
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_truecontents$ = 12					; size = 4
_pfnPointContents PROC

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 373  : 	int	cont, truecont;
; 374  : 
; 375  : 	truecont = cont = PM_PointContents( svgame.pmove, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	call	_PM_PointContents
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax
	mov	edx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR _truecont$[ebp], edx

; 376  : 	if( truecontents ) *truecontents = truecont;

	cmp	DWORD PTR _truecontents$[ebp], 0
	je	SHORT $LN2@pfnPointCo
	mov	eax, DWORD PTR _truecontents$[ebp]
	mov	ecx, DWORD PTR _truecont$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnPointCo:

; 377  : 
; 378  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN3@pfnPointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN3@pfnPointCo

; 379  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN3@pfnPointCo:

; 380  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 381  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hitent$ = 8						; size = 4
_tr$ = 12						; size = 4
_pfnStuckTouch PROC

; 353  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 354  : 	int	i;
; 355  : 
; 356  : 	for( i = 0; i < svgame.pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnStuckTo
$LN2@pfnStuckTo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnStuckTo:
	mov	ecx, DWORD PTR _svgame+8224
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+283788]
	jge	SHORT $LN3@pfnStuckTo

; 357  : 	{
; 358  : 		if( svgame.pmove->touchindex[i].ent == hitent )

	imul	eax, DWORD PTR _i$[ebp], 68
	mov	ecx, DWORD PTR _svgame+8224
	mov	edx, DWORD PTR [ecx+eax+283840]
	cmp	edx, DWORD PTR _hitent$[ebp]
	jne	SHORT $LN5@pfnStuckTo

; 359  : 			return;

	jmp	$LN1@pfnStuckTo
$LN5@pfnStuckTo:

; 360  : 	}

	jmp	SHORT $LN2@pfnStuckTo
$LN3@pfnStuckTo:

; 361  : 
; 362  : 	if( svgame.pmove->numtouch >= MAX_PHYSENTS )

	mov	eax, DWORD PTR _svgame+8224
	cmp	DWORD PTR [eax+283788], 600		; 00000258H
	jl	SHORT $LN6@pfnStuckTo

; 363  : 		return;

	jmp	$LN1@pfnStuckTo
$LN6@pfnStuckTo:

; 364  : 
; 365  : 	VectorCopy( svgame.pmove->velocity, tr->deltavelocity );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _svgame+8224
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [eax+ecx+52], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+52], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [eax+edx+52], ecx

; 366  : 	tr->ent = hitent;

	mov	edx, DWORD PTR _tr$[ebp]
	mov	eax, DWORD PTR _hitent$[ebp]
	mov	DWORD PTR [edx+48], eax

; 367  : 
; 368  : 	svgame.pmove->touchindex[svgame.pmove->numtouch++] = *tr;

	mov	ecx, DWORD PTR _svgame+8224
	imul	edx, DWORD PTR [ecx+283788], 68
	mov	eax, DWORD PTR _svgame+8224
	lea	edi, DWORD PTR [eax+edx+283792]
	mov	ecx, 17					; 00000011H
	mov	esi, DWORD PTR _tr$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _svgame+8224
	mov	edx, DWORD PTR [ecx+283788]
	add	edx, 1
	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+283788], edx
$LN1@pfnStuckTo:

; 369  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStuckTouch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pfnTestPlayerPosition PROC

; 348  : {

	push	ebp
	mov	ebp, esp

; 349  : 	return PM_TestPlayerPosition( svgame.pmove, pos, ptrace, NULL );

	push	0
	mov	eax, DWORD PTR _ptrace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	push	edx
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 350  : }

	pop	ebp
	ret	0
_pfnTestPlayerPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_SV_TestLine PROC

; 343  : {

	push	ebp
	mov	ebp, esp

; 344  : 	return PM_TestLineExt( svgame.pmove, svgame.pmove->physents, svgame.pmove->numphysent, start, end, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+588]
	push	ecx
	mov	edx, DWORD PTR _svgame+8224
	add	edx, 592				; 00000250H
	push	edx
	mov	eax, DWORD PTR _svgame+8224
	push	eax
	call	_PM_TestLineExt
	add	esp, 24					; 00000018H

; 345  : }

	pop	ebp
	ret	0
_SV_TestLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pe$ = -20						; size = 4
_next$ = -16						; size = 4
_mod$ = -12						; size = 4
_l$ = -8						; size = 4
_check$ = -4						; size = 4
_node$ = 8						; size = 4
_pmove_mins$ = 12					; size = 4
_pmove_maxs$ = 16					; size = 4
_SV_AddLaddersToPmove PROC

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 302  : 	link_t	*l, *next;
; 303  : 	edict_t	*check;
; 304  : 	model_t	*mod;
; 305  : 	physent_t	*pe;
; 306  : 	
; 307  : 	// get ladder edicts
; 308  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_AddLadd
$LN2@SV_AddLadd:
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], edx
$LN4@SV_AddLadd:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_AddLadd

; 309  : 	{
; 310  : 		next = l->next;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _next$[ebp], edx

; 311  : 		check = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _check$[ebp], eax

; 312  : 
; 313  : 		if( check->v.solid != SOLID_NOT || check->v.skin != CONTENTS_LADDER )

	mov	ecx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [ecx+396], 0
	jne	SHORT $LN6@SV_AddLadd
	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx+400], -16		; fffffff0H
	je	SHORT $LN5@SV_AddLadd
$LN6@SV_AddLadd:

; 314  : 			continue;

	jmp	SHORT $LN2@SV_AddLadd
$LN5@SV_AddLadd:

; 315  : 
; 316  : 		mod = SV_ModelHandle( check->v.modelindex );

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 317  : 
; 318  : 		// only brushes can have special contents
; 319  : 		if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN8@SV_AddLadd
	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN7@SV_AddLadd
$LN8@SV_AddLadd:

; 320  : 			continue;

	jmp	SHORT $LN2@SV_AddLadd
$LN7@SV_AddLadd:

; 321  : 
; 322  : 		if( !BoundsIntersect( pmove_mins, pmove_maxs, check->v.absmin, check->v.absmax ))

	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 324				; 00000144H
	push	ecx
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN9@SV_AddLadd

; 323  : 			continue;

	jmp	$LN2@SV_AddLadd
$LN9@SV_AddLadd:

; 324  : 
; 325  : 		if( svgame.pmove->nummoveent == MAX_MOVEENTS )

	mov	ecx, DWORD PTR _svgame+8224
	cmp	DWORD PTR [ecx+134992], 64		; 00000040H
	jne	SHORT $LN10@SV_AddLadd

; 326  : 			return;

	jmp	$LN14@SV_AddLadd
$LN10@SV_AddLadd:

; 327  : 
; 328  : 		pe = &svgame.pmove->moveents[svgame.pmove->nummoveent];

	mov	edx, DWORD PTR _svgame+8224
	imul	eax, DWORD PTR [edx+134992], 224
	mov	ecx, DWORD PTR _svgame+8224
	lea	edx, DWORD PTR [ecx+eax+134996]
	mov	DWORD PTR _pe$[ebp], edx

; 329  : 		if( SV_CopyEdictToPhysEnt( pe, check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@SV_AddLadd

; 330  : 			svgame.pmove->nummoveent++;

	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR [edx+134992]
	add	eax, 1
	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+134992], eax
$LN11@SV_AddLadd:

; 331  : 	}

	jmp	$LN2@SV_AddLadd
$LN3@SV_AddLadd:

; 332  : 	
; 333  : 	// recurse down both sides
; 334  : 	if( node->axis == -1 ) return;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN12@SV_AddLadd
	jmp	SHORT $LN14@SV_AddLadd
$LN12@SV_AddLadd:

; 335  : 	
; 336  : 	if( pmove_maxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN13@SV_AddLadd

; 337  : 		SV_AddLaddersToPmove( node->children[0], pmove_mins, pmove_maxs );

	mov	ecx, DWORD PTR _pmove_maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove_mins$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_AddLaddersToPmove
	add	esp, 12					; 0000000cH
$LN13@SV_AddLadd:

; 338  : 	if( pmove_mins[node->axis] < node->dist )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _pmove_mins$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR [ecx+edx*4]
	jbe	SHORT $LN14@SV_AddLadd

; 339  : 		SV_AddLaddersToPmove( node->children[1], pmove_mins, pmove_maxs );

	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_AddLaddersToPmove
	add	esp, 12					; 0000000cH
$LN14@SV_AddLadd:

; 340  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddLaddersToPmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_next$ = -48						; size = 4
_pe$ = -44						; size = 4
_l$ = -40						; size = 4
_pl$ = -36						; size = 4
_check$ = -32						; size = 4
_mins$ = -28						; size = 12
_maxs$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_pmove_mins$ = 12					; size = 4
_pmove_maxs$ = 16					; size = 4
_SV_AddLinksToPmove PROC

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 210  : 	link_t	*l, *next;
; 211  : 	edict_t	*check, *pl;
; 212  : 	vec3_t	mins, maxs;
; 213  : 	physent_t	*pe;
; 214  : 
; 215  : 	pl = EDICT_NUM( svgame.pmove->player_index + 1 );

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pl$[ebp], eax

; 216  : 	Assert( SV_IsValidEdict( pl ));

	push	0
	push	216					; 000000d8H
	push	OFFSET $SG136607
	push	OFFSET $SG136608
	push	216					; 000000d8H
	push	OFFSET $SG136609
	mov	edx, DWORD PTR _pl$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 217  : 
; 218  : 	// touch linked edicts
; 219  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_AddLink
$LN2@SV_AddLink:
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], edx
$LN4@SV_AddLink:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_AddLink

; 220  : 	{
; 221  : 		next = l->next;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _next$[ebp], edx

; 222  : 		check = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _check$[ebp], eax

; 223  : 
; 224  : 		if( check->v.groupinfo != 0 )

	mov	ecx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [ecx+704], 0
	je	SHORT $LN7@SV_AddLink

; 225  : 		{
; 226  : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( check->v.groupinfo, pl->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN6@SV_AddLink
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR _pl$[ebp]
	mov	ecx, DWORD PTR [edx+704]
	and	ecx, DWORD PTR [eax+704]
	jne	SHORT $LN6@SV_AddLink

; 227  : 				continue;

	jmp	SHORT $LN2@SV_AddLink
$LN6@SV_AddLink:

; 228  : 
; 229  : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( check->v.groupinfo, pl->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN7@SV_AddLink
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR _pl$[ebp]
	mov	ecx, DWORD PTR [edx+704]
	and	ecx, DWORD PTR [eax+704]
	je	SHORT $LN7@SV_AddLink

; 230  : 				continue;

	jmp	SHORT $LN2@SV_AddLink
$LN7@SV_AddLink:

; 231  : 		}
; 232  : 
; 233  : 		if( check->v.owner == pl || check->v.solid == SOLID_TRIGGER )

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+536]
	cmp	eax, DWORD PTR _pl$[ebp]
	je	SHORT $LN9@SV_AddLink
	mov	ecx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [ecx+396], 1
	jne	SHORT $LN8@SV_AddLink
$LN9@SV_AddLink:

; 234  : 			continue; // player or player's own missile

	jmp	$LN2@SV_AddLink
$LN8@SV_AddLink:

; 235  : 
; 236  : 		if( svgame.pmove->numvisent < MAX_PHYSENTS )

	mov	edx, DWORD PTR _svgame+8224
	cmp	DWORD PTR [edx+149332], 600		; 00000258H
	jge	SHORT $LN11@SV_AddLink

; 237  : 		{
; 238  : 			pe = &svgame.pmove->visents[svgame.pmove->numvisent];

	mov	eax, DWORD PTR _svgame+8224
	imul	ecx, DWORD PTR [eax+149332], 224
	mov	edx, DWORD PTR _svgame+8224
	lea	eax, DWORD PTR [edx+ecx+149336]
	mov	DWORD PTR _pe$[ebp], eax

; 239  : 			if( SV_CopyEdictToPhysEnt( pe, check ))

	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@SV_AddLink

; 240  : 				svgame.pmove->numvisent++;

	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+149332]
	add	ecx, 1
	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+149332], ecx
$LN11@SV_AddLink:

; 241  : 		}
; 242  : 
; 243  : 		if( check->v.solid == SOLID_NOT && ( check->v.skin == CONTENTS_NONE || check->v.modelindex == 0 ))

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 0
	jne	SHORT $LN12@SV_AddLink
	mov	ecx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [ecx+400], 0
	je	SHORT $LN13@SV_AddLink
	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx+308], 0
	jne	SHORT $LN12@SV_AddLink
$LN13@SV_AddLink:

; 244  : 			continue;

	jmp	$LN2@SV_AddLink
$LN12@SV_AddLink:

; 245  : 
; 246  : 		// ignore monsterclip brushes
; 247  : 		if( FBitSet( check->v.flags, FL_MONSTERCLIP ) && check->v.solid == SOLID_BSP )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN14@SV_AddLink
	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx+396], 4
	jne	SHORT $LN14@SV_AddLink

; 248  : 			continue;

	jmp	$LN2@SV_AddLink
$LN14@SV_AddLink:

; 249  : 
; 250  : 		if( check == pl ) continue;	// himself

	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _pl$[ebp]
	jne	SHORT $LN15@SV_AddLink
	jmp	$LN2@SV_AddLink
$LN15@SV_AddLink:

; 251  : 
; 252  : 		// nehahra collision flags
; 253  : 		if( check->v.movetype != MOVETYPE_PUSH )

	mov	ecx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [ecx+392], 7
	je	SHORT $LN17@SV_AddLink

; 254  : 		{
; 255  : 			if(( FBitSet( check->v.flags, FL_CLIENT|FL_FAKECLIENT ) && check->v.health <= 0.0f ) || check->v.deadflag == DEAD_DEAD )

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8200				; 00002008H
	je	SHORT $LN19@SV_AddLink
	mov	ecx, DWORD PTR _check$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+480]
	jae	SHORT $LN18@SV_AddLink
$LN19@SV_AddLink:
	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx+496], 2
	jne	SHORT $LN17@SV_AddLink
$LN18@SV_AddLink:

; 256  : 				continue;	// dead body

	jmp	$LN2@SV_AddLink
$LN17@SV_AddLink:

; 257  : 		}
; 258  : 
; 259  : 		if( VectorIsNull( check->v.size ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+372]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_AddLink
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+372]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_AddLink
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+372]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_AddLink

; 260  : 			continue;

	jmp	$LN2@SV_AddLink
$LN20@SV_AddLink:

; 261  : 
; 262  : 		VectorCopy( check->v.absmin, mins );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [eax+edx+324]
	mov	DWORD PTR _mins$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+eax+324]
	mov	DWORD PTR _mins$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+324]
	mov	DWORD PTR _mins$[ebp+edx], ecx

; 263  : 		VectorCopy( check->v.absmax, maxs );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [ecx+eax+336]
	mov	DWORD PTR _maxs$[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+336]
	mov	DWORD PTR _maxs$[ebp+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+edx+336]
	mov	DWORD PTR _maxs$[ebp+eax], edx

; 264  : 
; 265  : 		if( FBitSet( check->v.flags, FL_CLIENT ) && !FBitSet( check->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 8
	je	SHORT $LN22@SV_AddLink
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8192				; 00002000H
	jne	SHORT $LN22@SV_AddLink

; 266  : 		{
; 267  : 			if( sv.current_client )

	cmp	DWORD PTR _sv+40, 0
	je	SHORT $LN22@SV_AddLink

; 268  : 			{
; 269  : 				// trying to get interpolated values
; 270  : 				SV_GetTrueMinMax( sv.current_client, NUM_FOR_EDICT( check ), mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _check$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _sv+40
	push	edx
	call	_SV_GetTrueMinMax
	add	esp, 16					; 00000010H
$LN22@SV_AddLink:

; 271  : 			}
; 272  : 		}
; 273  : 
; 274  : 		if( !BoundsIntersect( pmove_mins, pmove_maxs, mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN23@SV_AddLink

; 275  : 			continue;

	jmp	$LN2@SV_AddLink
$LN23@SV_AddLink:

; 276  : 
; 277  : 		if( svgame.pmove->numphysent < MAX_PHYSENTS )

	mov	ecx, DWORD PTR _svgame+8224
	cmp	DWORD PTR [ecx+588], 600		; 00000258H
	jge	SHORT $LN25@SV_AddLink

; 278  : 		{
; 279  : 			pe = &svgame.pmove->physents[svgame.pmove->numphysent];

	mov	edx, DWORD PTR _svgame+8224
	imul	eax, DWORD PTR [edx+588], 224
	mov	ecx, DWORD PTR _svgame+8224
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 280  : 
; 281  : 			if( SV_CopyEdictToPhysEnt( pe, check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@SV_AddLink

; 282  : 				svgame.pmove->numphysent++;

	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR [edx+588]
	add	eax, 1
	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+588], eax
$LN25@SV_AddLink:

; 283  : 		}
; 284  : 	}

	jmp	$LN2@SV_AddLink
$LN3@SV_AddLink:

; 285  : 	
; 286  : 	// recurse down both sides
; 287  : 	if( node->axis == -1 ) return;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN26@SV_AddLink
	jmp	SHORT $LN28@SV_AddLink
$LN26@SV_AddLink:

; 288  : 
; 289  : 	if( pmove_maxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN27@SV_AddLink

; 290  : 		SV_AddLinksToPmove( node->children[0], pmove_mins, pmove_maxs );

	mov	ecx, DWORD PTR _pmove_maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove_mins$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_AddLinksToPmove
	add	esp, 12					; 0000000cH
$LN27@SV_AddLink:

; 291  : 	if( pmove_mins[node->axis] < node->dist )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _pmove_mins$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR [ecx+edx*4]
	jbe	SHORT $LN28@SV_AddLink

; 292  : 		SV_AddLinksToPmove( node->children[1], pmove_mins, pmove_maxs );

	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_AddLinksToPmove
	add	esp, 12					; 0000000cH
$LN28@SV_AddLink:

; 293  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddLinksToPmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_ShouldUnlagForPlayer PROC

; 155  : {

	push	ebp
	mov	ebp, esp

; 156  : 	// can't unlag in singleplayer
; 157  : 	if( svs.maxclients <= 1 )

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN2@SV_ShouldU

; 158  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN2@SV_ShouldU:

; 159  : 
; 160  : 	// unlag disabled globally
; 161  : 	if( !svgame.dllFuncs.pfnAllowLagCompensation() || !sv_unlag.value )

	call	DWORD PTR _svgame+19436
	test	eax, eax
	je	SHORT $LN4@SV_ShouldU
	movss	xmm0, DWORD PTR _sv_unlag+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SV_ShouldU
$LN4@SV_ShouldU:

; 162  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN3@SV_ShouldU:

; 163  : 
; 164  : 	if( !FBitSet( cl->flags, FCL_LAG_COMPENSATION ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN5@SV_ShouldU

; 165  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN5@SV_ShouldU:

; 166  : 
; 167  : 	// player not ready
; 168  : 	if( cl->state != cs_spawned )

	mov	edx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [edx], 3
	je	SHORT $LN6@SV_ShouldU

; 169  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN6@SV_ShouldU:

; 170  : 
; 171  : 	return true;

	mov	eax, 1
$LN1@SV_ShouldU:

; 172  : }

	pop	ebp
	ret	0
_SV_ShouldUnlagForPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv283 = -20						; size = 4
tv243 = -16						; size = 4
tv239 = -12						; size = 4
tv173 = -8						; size = 4
_mod$ = -4						; size = 4
_pe$ = 8						; size = 4
_ed$ = 12						; size = 4
_SV_CopyEdictToPhysEnt PROC

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 64   : 	model_t	*mod = SV_ModelHandle( ed->v.modelindex );

	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 65   : 
; 66   : 	if( !mod ) return false;

	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN4@SV_CopyEdi
	xor	eax, eax
	jmp	$LN1@SV_CopyEdi
$LN4@SV_CopyEdi:

; 67   : 	pe->player = false;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+32], 0

; 68   : 
; 69   : 	pe->info = NUM_FOR_EDICT( ed );

	mov	eax, DWORD PTR _ed$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+80], eax

; 70   : 	VectorCopy( ed->v.origin, pe->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+36], eax

; 71   : 	VectorCopy( ed->v.angles, pe->angles );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [eax+ecx+84], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+84], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [eax+edx+84], ecx

; 72   : 
; 73   : 	if( FBitSet( ed->v.flags, FL_FAKECLIENT ))

	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8192				; 00002000H
	je	SHORT $LN5@SV_CopyEdi

; 74   : 	{
; 75   : 		// bot
; 76   : 		Q_strncpy( pe->name, "bot", sizeof( pe->name ));

	push	32					; 00000020H
	push	OFFSET $SG136540
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 77   : 		pe->player = pe->info;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+32], ecx

; 78   : 	}

	jmp	SHORT $LN8@SV_CopyEdi
$LN5@SV_CopyEdi:

; 79   : 	else if( FBitSet( ed->v.flags, FL_CLIENT ))

	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 8
	je	SHORT $LN7@SV_CopyEdi

; 80   : 	{
; 81   : 		// client
; 82   : 		SV_GetTrueOrigin( sv.current_client, pe->info, pe->origin );

	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _sv+40
	push	ecx
	call	_SV_GetTrueOrigin
	add	esp, 12					; 0000000cH

; 83   : 		Q_strncpy( pe->name, "player", sizeof( pe->name ));

	push	32					; 00000020H
	push	OFFSET $SG136543
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 84   : 		pe->player = pe->info;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+32], edx

; 85   : 	}

	jmp	SHORT $LN8@SV_CopyEdi
$LN7@SV_CopyEdi:

; 86   : 	else
; 87   : 	{
; 88   : 		// otherwise copy the classname
; 89   : 		Q_strncpy( pe->name, STRING( ed->v.classname ), sizeof( pe->name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@SV_CopyEdi:

; 90   : 	}
; 91   : 
; 92   : 	pe->model = pe->studiomodel = NULL;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 93   : 
; 94   : 	switch( ed->v.solid )

	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+396]
	mov	DWORD PTR tv173[ebp], eax
	cmp	DWORD PTR tv173[ebp], 5
	ja	$LN13@SV_CopyEdi
	mov	ecx, DWORD PTR tv173[ebp]
	jmp	DWORD PTR $LN21@SV_CopyEdi[ecx*4]
$LN9@SV_CopyEdi:

; 95   : 	{
; 96   : 	case SOLID_NOT:
; 97   : 	case SOLID_BSP:
; 98   : 		pe->model = mod;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+48], eax

; 99   : 		VectorClear( pe->mins );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+56], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+56], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+56], xmm0

; 100  : 		VectorClear( pe->maxs );

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+68], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+68], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+68], xmm0

; 101  : 		break;

	jmp	$LN2@SV_CopyEdi
$LN10@SV_CopyEdi:

; 102  : 	case SOLID_BBOX:
; 103  : 		if( mod && mod->type == mod_studio && mod->flags & STUDIO_TRACE_HITBOX )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN11@SV_CopyEdi
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN11@SV_CopyEdi
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 512				; 00000200H
	je	SHORT $LN11@SV_CopyEdi

; 104  : 			pe->studiomodel = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN11@SV_CopyEdi:

; 105  : 		VectorCopy( ed->v.mins, pe->mins );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+348]
	mov	DWORD PTR [ecx+edx+56], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+348]
	mov	DWORD PTR [eax+edx+56], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+348]
	mov	DWORD PTR [ecx+eax+56], edx

; 106  : 		VectorCopy( ed->v.maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+360]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+360]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+360]
	mov	DWORD PTR [edx+ecx+68], eax

; 107  : 		break;

	jmp	$LN2@SV_CopyEdi
$LN12@SV_CopyEdi:

; 108  : 	case SOLID_CUSTOM:
; 109  : 		pe->model = (mod->type == mod_brush) ? mod : NULL;

	mov	ecx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN15@SV_CopyEdi
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR tv239[ebp], edx
	jmp	SHORT $LN16@SV_CopyEdi
$LN15@SV_CopyEdi:
	mov	DWORD PTR tv239[ebp], 0
$LN16@SV_CopyEdi:
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR [eax+48], ecx

; 110  : 		pe->studiomodel = (mod->type == mod_studio) ? mod : NULL;

	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 3
	jne	SHORT $LN17@SV_CopyEdi
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR tv243[ebp], eax
	jmp	SHORT $LN18@SV_CopyEdi
$LN17@SV_CopyEdi:
	mov	DWORD PTR tv243[ebp], 0
$LN18@SV_CopyEdi:
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR tv243[ebp]
	mov	DWORD PTR [ecx+52], edx

; 111  : 		VectorCopy( ed->v.mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+348]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+348]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+348]
	mov	DWORD PTR [edx+ecx+56], eax

; 112  : 		VectorCopy( ed->v.maxs, pe->maxs );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+360]
	mov	DWORD PTR [eax+ecx+68], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+360]
	mov	DWORD PTR [edx+ecx+68], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+360]
	mov	DWORD PTR [eax+edx+68], ecx

; 113  : 		break;

	jmp	$LN2@SV_CopyEdi
$LN13@SV_CopyEdi:

; 114  : 	default:
; 115  : 		pe->studiomodel = (mod->type == mod_studio) ? mod : NULL;

	mov	edx, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [edx+68], 3
	jne	SHORT $LN19@SV_CopyEdi
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR tv283[ebp], eax
	jmp	SHORT $LN20@SV_CopyEdi
$LN19@SV_CopyEdi:
	mov	DWORD PTR tv283[ebp], 0
$LN20@SV_CopyEdi:
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR tv283[ebp]
	mov	DWORD PTR [ecx+52], edx

; 116  : 		VectorCopy( ed->v.mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+348]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+348]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+348]
	mov	DWORD PTR [edx+ecx+56], eax

; 117  : 		VectorCopy( ed->v.maxs, pe->maxs );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+360]
	mov	DWORD PTR [eax+ecx+68], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+360]
	mov	DWORD PTR [edx+ecx+68], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+360]
	mov	DWORD PTR [eax+edx+68], ecx
$LN2@SV_CopyEdi:

; 118  : 		break;
; 119  : 	}
; 120  : 
; 121  : 	pe->solid = ed->v.solid;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR [edx+96], ecx

; 122  : 	pe->rendermode = ed->v.rendermode;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+456]
	mov	DWORD PTR [edx+104], ecx

; 123  : 	pe->skin = ed->v.skin;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR [edx+100], ecx

; 124  : 	pe->frame = ed->v.frame;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	mov	DWORD PTR [edx+108], ecx

; 125  : 	pe->sequence = ed->v.sequence;

	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+424]
	mov	DWORD PTR [edx+112], ecx

; 126  : 
; 127  : 	memcpy( &pe->controller[0], &ed->v.controller[0], 4 * sizeof( byte ));

	push	4
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ed$[ebp]
	lea	edx, DWORD PTR [ecx+eax+444]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	lea	eax, DWORD PTR [edx+ecx+116]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 128  : 	memcpy( &pe->blending[0], &ed->v.blending[0], 2 * sizeof( byte ));

	push	2
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ed$[ebp]
	lea	ecx, DWORD PTR [eax+edx+448]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	lea	edx, DWORD PTR [ecx+eax+120]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 129  : 
; 130  : 	pe->movetype = ed->v.movetype;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+124], edx

; 131  : 	pe->takedamage = ed->v.takedamage;

	mov	eax, DWORD PTR _ed$[ebp]
	cvttss2si ecx, DWORD PTR [eax+492]
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 132  : 	pe->team = ed->v.team;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	mov	DWORD PTR [eax+136], edx

; 133  : 	pe->classnumber = ed->v.playerclass;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+652]
	mov	DWORD PTR [eax+140], edx

; 134  : 	pe->blooddecal = 0;	// unused in GoldSrc

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+132], 0

; 135  : 
; 136  : 	// for mods
; 137  : 	pe->iuser1 = ed->v.iuser1;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+708]
	mov	DWORD PTR [ecx+144], eax

; 138  : 	pe->iuser2 = ed->v.iuser2;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+712]
	mov	DWORD PTR [ecx+148], eax

; 139  : 	pe->iuser3 = ed->v.iuser3;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+716]
	mov	DWORD PTR [ecx+152], eax

; 140  : 	pe->iuser4 = ed->v.iuser4;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+720]
	mov	DWORD PTR [ecx+156], eax

; 141  : 	pe->fuser1 = ed->v.fuser1;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+724]
	mov	DWORD PTR [ecx+160], eax

; 142  : 	pe->fuser2 = ed->v.fuser2;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+728]
	mov	DWORD PTR [ecx+164], eax

; 143  : 	pe->fuser3 = ed->v.fuser3;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR [ecx+168], eax

; 144  : 	pe->fuser4 = ed->v.fuser4;

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [edx+736]
	mov	DWORD PTR [ecx+172], eax

; 145  : 
; 146  : 	VectorCopy( ed->v.vuser1, pe->vuser1 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+740]
	mov	DWORD PTR [eax+ecx+176], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+740]
	mov	DWORD PTR [edx+ecx+176], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+740]
	mov	DWORD PTR [eax+edx+176], ecx

; 147  : 	VectorCopy( ed->v.vuser2, pe->vuser2 );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+752]
	mov	DWORD PTR [ecx+edx+188], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+752]
	mov	DWORD PTR [eax+edx+188], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+752]
	mov	DWORD PTR [ecx+eax+188], edx

; 148  : 	VectorCopy( ed->v.vuser3, pe->vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+764]
	mov	DWORD PTR [edx+eax+200], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+764]
	mov	DWORD PTR [ecx+eax+200], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+764]
	mov	DWORD PTR [edx+ecx+200], eax

; 149  : 	VectorCopy( ed->v.vuser4, pe->vuser4 );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+776]
	mov	DWORD PTR [eax+ecx+212], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+776]
	mov	DWORD PTR [edx+ecx+212], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+776]
	mov	DWORD PTR [eax+edx+212], ecx

; 150  : 
; 151  : 	return true;

	mov	eax, 1
$LN1@SV_CopyEdi:

; 152  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN21@SV_CopyEdi:
	DD	$LN9@SV_CopyEdi
	DD	$LN13@SV_CopyEdi
	DD	$LN10@SV_CopyEdi
	DD	$LN13@SV_CopyEdi
	DD	$LN9@SV_CopyEdi
	DD	$LN12@SV_CopyEdi
_SV_CopyEdictToPhysEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_SV_ClearPhysEnts PROC

; 26   : {

	push	ebp
	mov	ebp, esp

; 27   : 	svgame.pmove->numtouch = 0;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+283788], 0

; 28   : 	svgame.pmove->numvisent = 0;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+149332], 0

; 29   : 	svgame.pmove->nummoveent = 0;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+134992], 0

; 30   : 	svgame.pmove->numphysent = 0;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+588], 0

; 31   : }

	pop	ebp
	ret	0
_SV_ClearPhysEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_pClient$ = 8						; size = 4
_SV_PlayerIsFrozen PROC

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	if( sv_background_freeze.value && sv.background )

	movss	xmm0, DWORD PTR _sv_background_freeze+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_PlayerI
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_PlayerI

; 36   : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_PlayerI
$LN2@SV_PlayerI:

; 37   : 
; 38   : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 2
	je	SHORT $LN3@SV_PlayerI

; 39   : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_PlayerI
$LN3@SV_PlayerI:

; 40   : 
; 41   : 	if( FBitSet( pClient->v.flags, FL_FROZEN ))

	mov	ecx, DWORD PTR _pClient$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 4096				; 00001000H
	je	SHORT $LN4@SV_PlayerI

; 42   : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_PlayerI
$LN4@SV_PlayerI:

; 43   : 	return false;

	xor	eax, eax
$LN1@SV_PlayerI:

; 44   : }

	pop	ebp
	ret	0
_SV_PlayerIsFrozen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_edictnum$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_SV_GetTrueMinMax PROC

; 187  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 188  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_GetTrue

; 189  : 		return;

	jmp	$LN5@SV_GetTrue
$LN2@SV_GetTrue:

; 190  : 
; 191  : 	if( edictnum < 1 || edictnum > svs.maxclients )

	cmp	DWORD PTR _edictnum$[ebp], 1
	jl	SHORT $LN4@SV_GetTrue
	mov	ecx, DWORD PTR _edictnum$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jle	SHORT $LN3@SV_GetTrue
$LN4@SV_GetTrue:

; 192  : 		return;

	jmp	$LN5@SV_GetTrue
$LN3@SV_GetTrue:

; 193  : 
; 194  : 	if( svgame.interp[edictnum-1].active && svgame.interp[edictnum-1].moving )

	mov	edx, DWORD PTR _edictnum$[ebp]
	sub	edx, 1
	imul	eax, edx, 88
	cmp	DWORD PTR _svgame[eax+8228], 0
	je	$LN5@SV_GetTrue
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	cmp	DWORD PTR _svgame[edx+8232], 0
	je	$LN5@SV_GetTrue

; 195  : 	{
; 196  : 		VectorCopy( svgame.interp[edictnum-1].mins, mins );

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR _svgame[ecx+eax+8244]
	mov	DWORD PTR [esi+edx], eax
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _svgame[edx+eax+8244]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR _svgame[ecx+edx+8244]
	mov	DWORD PTR [esi+eax], ecx

; 197  : 		VectorCopy( svgame.interp[edictnum-1].maxs, maxs );

	mov	edx, DWORD PTR _edictnum$[ebp]
	sub	edx, 1
	imul	eax, edx, 88
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR _svgame[eax+edx+8256]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR _svgame[ecx+edx+8256]
	mov	DWORD PTR [esi+eax], ecx
	mov	edx, DWORD PTR _edictnum$[ebp]
	sub	edx, 1
	imul	eax, edx, 88
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR _svgame[eax+ecx+8256]
	mov	DWORD PTR [esi+edx], eax
$LN5@SV_GetTrue:

; 198  : 	}
; 199  : }

	pop	esi
	pop	ebp
	ret	0
_SV_GetTrueMinMax ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_edictnum$ = 12						; size = 4
_origin$ = 16						; size = 4
_SV_GetTrueOrigin PROC

; 175  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 176  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_GetTrue

; 177  : 		return;

	jmp	$LN5@SV_GetTrue
$LN2@SV_GetTrue:

; 178  : 
; 179  : 	if( edictnum < 1 || edictnum > svs.maxclients )

	cmp	DWORD PTR _edictnum$[ebp], 1
	jl	SHORT $LN4@SV_GetTrue
	mov	ecx, DWORD PTR _edictnum$[ebp]
	cmp	ecx, DWORD PTR _svs+16
	jle	SHORT $LN3@SV_GetTrue
$LN4@SV_GetTrue:

; 180  : 		return;

	jmp	$LN5@SV_GetTrue
$LN3@SV_GetTrue:

; 181  : 
; 182  : 	if( svgame.interp[edictnum-1].active && svgame.interp[edictnum-1].moving )

	mov	edx, DWORD PTR _edictnum$[ebp]
	sub	edx, 1
	imul	eax, edx, 88
	cmp	DWORD PTR _svgame[eax+8228], 0
	je	$LN5@SV_GetTrue
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	cmp	DWORD PTR _svgame[edx+8232], 0
	je	SHORT $LN5@SV_GetTrue

; 183  : 		VectorCopy( svgame.interp[edictnum-1].oldpos, origin ); 

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR _svgame[ecx+eax+8280]
	mov	DWORD PTR [esi+edx], eax
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR _svgame[edx+eax+8280]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR _svgame[ecx+edx+8280]
	mov	DWORD PTR [esi+eax], ecx
$LN5@SV_GetTrue:

; 184  : }

	pop	esi
	pop	ebp
	ret	0
_SV_GetTrueOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_InitClientMove PROC

; 562  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 563  : 	int	i;
; 564  : 
; 565  : 	Pmove_Init ();

	call	_Pmove_Init

; 566  : 
; 567  : 	svgame.pmove->server = true;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+4], 1

; 568  : 	svgame.pmove->movevars = &svgame.movevars;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+324848], OFFSET _svgame+7936

; 569  : 	svgame.pmove->runfuncs = false;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325040], 0

; 570  : 
; 571  : 	// enumerate client hulls
; 572  : 	for( i = 0; i < MAX_MAP_HULLS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_InitCli
$LN2@SV_InitCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_InitCli:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@SV_InitCli

; 573  : 	{
; 574  : 		if( svgame.dllFuncs.pfnGetHullBounds( i, host.player_mins[i], host.player_maxs[i] ))

	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, OFFSET _host+34284
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, OFFSET _host+34236
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	DWORD PTR _svgame+19424
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@SV_InitCli

; 575  : 			Con_Reportf( "SV: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g\n", i,

	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR _host[ecx+edx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR _host[eax+ecx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _host[edx+ecx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	cvtss2sd xmm0, DWORD PTR _host[edx+eax+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _host[ecx+edx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtss2sd xmm0, DWORD PTR _host[eax+edx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG136892
	call	_Con_Reportf
	add	esp, 56					; 00000038H
$LN5@SV_InitCli:

; 576  : 			host.player_mins[i][0], host.player_mins[i][1], host.player_mins[i][2],
; 577  : 			host.player_maxs[i][0], host.player_maxs[i][1], host.player_maxs[i][2] );
; 578  : 	}

	jmp	$LN2@SV_InitCli
$LN3@SV_InitCli:

; 579  : 
; 580  : 	memcpy( svgame.pmove->player_mins, host.player_mins, sizeof( host.player_mins ));

	push	48					; 00000030H
	push	OFFSET _host+34236
	mov	ecx, DWORD PTR _svgame+8224
	add	ecx, 324852				; 0004f4f4H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 581  : 	memcpy( svgame.pmove->player_maxs, host.player_maxs, sizeof( host.player_maxs ));

	push	48					; 00000030H
	push	OFFSET _host+34284
	mov	edx, DWORD PTR _svgame+8224
	add	edx, 324900				; 0004f524H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 582  : 
; 583  : 	// common utilities
; 584  : 	svgame.pmove->PM_Info_ValueForKey = Info_ValueForKey;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+324948], OFFSET _Info_ValueForKey

; 585  : 	svgame.pmove->PM_Particle = CL_Particle; // for local system only

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+324952], OFFSET _CL_Particle

; 586  : 	svgame.pmove->PM_TestPlayerPosition = pfnTestPlayerPosition;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+324956], OFFSET _pfnTestPlayerPosition

; 587  : 	svgame.pmove->Con_NPrintf = Con_NPrintf;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+324960], OFFSET _Con_NPrintf

; 588  : 	svgame.pmove->Con_DPrintf = Con_DPrintf;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+324964], OFFSET _Con_DPrintf

; 589  : 	svgame.pmove->Con_Printf = Con_Printf;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+324968], OFFSET _Con_Printf

; 590  : 	svgame.pmove->Sys_FloatTime = Sys_DoubleTime;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+324972], OFFSET _Sys_DoubleTime

; 591  : 	svgame.pmove->PM_StuckTouch = pfnStuckTouch;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+324976], OFFSET _pfnStuckTouch

; 592  : 	svgame.pmove->PM_PointContents = pfnPointContents;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+324980], OFFSET _pfnPointContents

; 593  : 	svgame.pmove->PM_TruePointContents = pfnTruePointContents;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+324984], OFFSET _pfnTruePointContents

; 594  : 	svgame.pmove->PM_HullPointContents = pfnHullPointContents; 

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+324988], OFFSET _pfnHullPointContents

; 595  : 	svgame.pmove->PM_PlayerTrace = pfnPlayerTrace;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+324992], OFFSET _pfnPlayerTrace

; 596  : 	svgame.pmove->PM_TraceLine = pfnTraceLine;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+324996], OFFSET _pfnTraceLine

; 597  : 	svgame.pmove->RandomLong = COM_RandomLong;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+325000], OFFSET _COM_RandomLong

; 598  : 	svgame.pmove->RandomFloat = COM_RandomFloat;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325004], OFFSET _COM_RandomFloat

; 599  : 	svgame.pmove->PM_GetModelType = pfnGetModelType;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+325008], OFFSET _pfnGetModelType

; 600  : 	svgame.pmove->PM_GetModelBounds = pfnGetModelBounds;	

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+325012], OFFSET _pfnGetModelBounds

; 601  : 	svgame.pmove->PM_HullForBsp = pfnHullForBsp;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325016], OFFSET _pfnHullForBsp

; 602  : 	svgame.pmove->PM_TraceModel = pfnTraceModel;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+325020], OFFSET _pfnTraceModel

; 603  : 	svgame.pmove->COM_FileSize = COM_FileSize;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+325024], OFFSET _COM_FileSize

; 604  : 	svgame.pmove->COM_LoadFile = COM_LoadFile;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325028], OFFSET _COM_LoadFile

; 605  : 	svgame.pmove->COM_FreeFile = COM_FreeFile;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+325032], OFFSET _COM_FreeFile

; 606  : 	svgame.pmove->memfgets = COM_MemFgets;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+325036], OFFSET _COM_MemFgets

; 607  : 	svgame.pmove->PM_PlaySound = pfnPlaySound;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325044], OFFSET _pfnPlaySound

; 608  : 	svgame.pmove->PM_TraceTexture = pfnTraceTexture;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+325048], OFFSET _pfnTraceTexture

; 609  : 	svgame.pmove->PM_PlaybackEventFull = pfnPlaybackEventFull;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+325052], OFFSET _pfnPlaybackEventFull

; 610  : 	svgame.pmove->PM_PlayerTraceEx = pfnPlayerTraceEx;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325056], OFFSET _pfnPlayerTraceEx

; 611  : 	svgame.pmove->PM_TestPlayerPositionEx = pfnTestPlayerPositionEx;

	mov	eax, DWORD PTR _svgame+8224
	mov	DWORD PTR [eax+325060], OFFSET _pfnTestPlayerPositionEx

; 612  : 	svgame.pmove->PM_TraceLineEx = pfnTraceLineEx;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+325064], OFFSET _pfnTraceLineEx

; 613  : 	svgame.pmove->PM_TraceSurface = pfnTraceSurface;

	mov	edx, DWORD PTR _svgame+8224
	mov	DWORD PTR [edx+325068], OFFSET _pfnTraceSurface

; 614  : 
; 615  : 	// initalize pmove
; 616  : 	svgame.dllFuncs.pfnPM_Init( svgame.pmove );

	mov	eax, DWORD PTR _svgame+8224
	push	eax
	call	DWORD PTR _svgame+19380
	add	esp, 4

; 617  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitClientMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
_frametime$ = -152					; size = 8
_touch$ = -144						; size = 4
_oldmsec$ = -140					; size = 4
_i$ = -136						; size = 4
_pmtrace$ = -132					; size = 4
_clent$ = -128						; size = 4
_trace$ = -124						; size = 56
_cmd$ = -68						; size = 52
_oldvel$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_ucmd$ = 12						; size = 4
_random_seed$ = 16					; size = 4
_SV_RunCmd PROC

; 1006 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1007 : 	edict_t	*clent, *touch;
; 1008 : 	double	frametime;
; 1009 : 	int	i, oldmsec;
; 1010 : 	pmtrace_t	*pmtrace;
; 1011 : 	trace_t	trace;
; 1012 : 	vec3_t	oldvel;
; 1013 : 	usercmd_t cmd;
; 1014 :    
; 1015 : 	clent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264980]
	mov	DWORD PTR _clent$[ebp], ecx

; 1016 : 	cmd = *ucmd;

	mov	ecx, 13					; 0000000dH
	mov	esi, DWORD PTR _ucmd$[ebp]
	lea	edi, DWORD PTR _cmd$[ebp]
	rep movsd

; 1017 : 
; 1018 : 	if( cl->ignorecmdtime > host.realtime )

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [edx+264960]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN5@SV_RunCmd

; 1019 : 	{
; 1020 : 		cl->cmdtime += ((double)ucmd->msec / 1000.0 );

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	mov	edx, DWORD PTR _cl$[ebp]
	addsd	xmm0, QWORD PTR [edx+264952]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264952], xmm0

; 1021 : 		return;

	jmp	$LN16@SV_RunCmd
$LN5@SV_RunCmd:

; 1022 : 	}
; 1023 : 
; 1024 : 	cl->ignorecmdtime = 0.0;

	mov	ecx, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [ecx+264960], xmm0

; 1025 : 
; 1026 : 	// chop up very long commands
; 1027 : 	if( cmd.msec > 50 )

	movzx	edx, BYTE PTR _cmd$[ebp+2]
	cmp	edx, 50					; 00000032H
	jle	SHORT $LN6@SV_RunCmd

; 1028 : 	{
; 1029 : 		oldmsec = ucmd->msec;

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	DWORD PTR _oldmsec$[ebp], ecx

; 1030 : 		cmd.msec = oldmsec / 2;

	mov	eax, DWORD PTR _oldmsec$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _cmd$[ebp+2], al

; 1031 : 		SV_RunCmd( cl, &cmd, random_seed );

	mov	edx, DWORD PTR _random_seed$[ebp]
	push	edx
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 1032 : 		cmd.msec = oldmsec / 2;

	mov	eax, DWORD PTR _oldmsec$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _cmd$[ebp+2], al

; 1033 : 		cmd.impulse = 0;

	mov	BYTE PTR _cmd$[ebp+32], 0

; 1034 : 		SV_RunCmd( cl, &cmd, random_seed );

	mov	edx, DWORD PTR _random_seed$[ebp]
	push	edx
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 1035 : 		return;

	jmp	$LN16@SV_RunCmd
$LN6@SV_RunCmd:

; 1036 : 	}
; 1037 : 
; 1038 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+40]
	and	eax, 128				; 00000080H
	jne	SHORT $LN7@SV_RunCmd

; 1039 : 		SV_SetupMoveInterpolant( cl );

	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_SetupMoveInterpolant
	add	esp, 4
$LN7@SV_RunCmd:

; 1040 : 
; 1041 : 	svgame.dllFuncs.pfnCmdStart( cl->edict, ucmd, random_seed );

	mov	edx, DWORD PTR _random_seed$[ebp]
	push	edx
	mov	eax, DWORD PTR _ucmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264980]
	push	edx
	call	DWORD PTR _svgame+19412
	add	esp, 12					; 0000000cH

; 1042 : 
; 1043 : 	frametime = ((double)ucmd->msec / 1000.0 );

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _frametime$[ebp], xmm0

; 1044 : 	cl->timebase += frametime;

	mov	edx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [edx+264400]
	addsd	xmm0, QWORD PTR _frametime$[ebp]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264400], xmm0

; 1045 : 	cl->cmdtime += frametime;

	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [ecx+264952]
	addsd	xmm0, QWORD PTR _frametime$[ebp]
	mov	edx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [edx+264952], xmm0

; 1046 : 
; 1047 : 	PM_CheckMovingGround( clent, frametime );

	cvtsd2ss xmm0, QWORD PTR _frametime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	_PM_CheckMovingGround
	add	esp, 8

; 1048 : 
; 1049 : 	VectorCopy( clent->v.v_angle, svgame.pmove->oldangles ); // save oldangles

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _svgame+8224
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [eax+ecx+80], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _svgame+8224
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+80], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _svgame+8224
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [eax+edx+80], ecx

; 1050 : 	if( !clent->v.fixangle ) VectorCopy( ucmd->viewangles, clent->v.v_angle );

	mov	edx, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [edx+288], 0
	jne	SHORT $LN8@SV_RunCmd
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _ucmd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax+244], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _ucmd$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+244], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _ucmd$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+244], eax
$LN8@SV_RunCmd:

; 1051 : 
; 1052 : 	VectorClear( clent->v.clbasevelocity );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+184], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+184], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+184], xmm0

; 1053 : 
; 1054 : 	// copy player buttons
; 1055 : 	clent->v.button = ucmd->buttons;

	mov	edx, DWORD PTR _ucmd$[ebp]
	movzx	eax, WORD PTR [edx+30]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+512], eax

; 1056 : 	clent->v.light_level = ucmd->lightlevel;

	mov	edx, DWORD PTR _ucmd$[ebp]
	movzx	eax, BYTE PTR [edx+28]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+420], eax

; 1057 : 	if( ucmd->impulse ) clent->v.impulse = ucmd->impulse;

	mov	edx, DWORD PTR _ucmd$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	test	eax, eax
	je	SHORT $LN9@SV_RunCmd
	mov	ecx, DWORD PTR _ucmd$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	mov	eax, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [eax+516], edx
$LN9@SV_RunCmd:

; 1058 : 
; 1059 : 	if( ucmd->impulse == 204 )

	mov	ecx, DWORD PTR _ucmd$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	cmp	edx, 204				; 000000ccH
	jne	SHORT $LN10@SV_RunCmd

; 1060 : 	{
; 1061 : 		// force client.dll update
; 1062 : 		SV_RefreshUserinfo();

	call	_SV_RefreshUserinfo
$LN10@SV_RunCmd:

; 1063 : 	}
; 1064 : 
; 1065 : 	svgame.globals->time = cl->timebase;

	mov	eax, DWORD PTR _cl$[ebp]
	cvtsd2ss xmm0, QWORD PTR [eax+264400]
	mov	ecx, DWORD PTR _svgame+19236
	movss	DWORD PTR [ecx], xmm0

; 1066 : 	svgame.dllFuncs.pfnPlayerPreThink( clent );

	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19332
	add	esp, 4

; 1067 : 	SV_PlayerRunThink( clent, frametime, cl->timebase );

	mov	eax, DWORD PTR _cl$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+264400]
	movsd	QWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _frametime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	call	_SV_PlayerRunThink
	add	esp, 16					; 00000010H

; 1068 : 
; 1069 : 	// If conveyor, or think, set basevelocity, then send to client asap too.
; 1070 : 	if( !VectorIsNull( clent->v.basevelocity ))

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@SV_RunCmd
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@SV_RunCmd
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@SV_RunCmd
$LN12@SV_RunCmd:

; 1071 : 		VectorCopy( clent->v.basevelocity, clent->v.clbasevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+172]
	mov	DWORD PTR [edx+eax+184], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+172]
	mov	DWORD PTR [ecx+eax+184], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+172]
	mov	DWORD PTR [edx+ecx+184], eax
$LN11@SV_RunCmd:

; 1072 : 
; 1073 : 	// setup playermove state
; 1074 : 	SV_SetupPMove( svgame.pmove, cl, ucmd, cl->physinfo );

	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	mov	edx, DWORD PTR _ucmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	call	_SV_SetupPMove
	add	esp, 16					; 00000010H

; 1075 : 
; 1076 : 	// motor!
; 1077 : 	svgame.dllFuncs.pfnPM_Move( svgame.pmove, true );

	push	1
	mov	edx, DWORD PTR _svgame+8224
	push	edx
	call	DWORD PTR _svgame+19376
	add	esp, 8

; 1078 : 
; 1079 : 	// copy results back to client
; 1080 : 	SV_FinishPMove( svgame.pmove, cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	call	_SV_FinishPMove
	add	esp, 8

; 1081 : 
; 1082 : 	if( clent->v.solid != SOLID_NOT && !sv.playersonly )

	mov	edx, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [edx+396], 0
	je	$LN15@SV_RunCmd
	cmp	DWORD PTR _sv+1359680, 0
	jne	$LN15@SV_RunCmd

; 1083 : 	{
; 1084 : 		if( svgame.physFuncs.PM_PlayerTouch != NULL )

	cmp	DWORD PTR _svgame+19540, 0
	je	SHORT $LN14@SV_RunCmd

; 1085 : 		{
; 1086 : 			// run custom impact function
; 1087 : 			svgame.physFuncs.PM_PlayerTouch( svgame.pmove, clent );

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8224
	push	ecx
	call	DWORD PTR _svgame+19540
	add	esp, 8

; 1088 : 		}

	jmp	$LN15@SV_RunCmd
$LN14@SV_RunCmd:

; 1089 : 		else
; 1090 : 		{
; 1091 : 			// link into place and touch triggers
; 1092 : 			SV_LinkEdict( clent, true );

	push	1
	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	_SV_LinkEdict
	add	esp, 8

; 1093 : 			VectorCopy( clent->v.velocity, oldvel ); // save velocity

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+160]
	mov	DWORD PTR _oldvel$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+160]
	mov	DWORD PTR _oldvel$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [edx+eax+160]
	mov	DWORD PTR _oldvel$[ebp+ecx], eax

; 1094 : 
; 1095 : 			// touch other objects
; 1096 : 			for( i = 0; i < svgame.pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_RunCmd
$LN2@SV_RunCmd:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_RunCmd:
	mov	edx, DWORD PTR _svgame+8224
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+283788]
	jge	$LN3@SV_RunCmd

; 1097 : 			{
; 1098 : 				pmtrace = &svgame.pmove->touchindex[i];

	imul	ecx, DWORD PTR _i$[ebp], 68
	mov	edx, DWORD PTR _svgame+8224
	lea	eax, DWORD PTR [edx+ecx+283792]
	mov	DWORD PTR _pmtrace$[ebp], eax

; 1099 : 				touch = EDICT_NUM( svgame.pmove->physents[pmtrace->ent].info );

	mov	ecx, DWORD PTR _pmtrace$[ebp]
	imul	edx, DWORD PTR [ecx+48], 224
	mov	eax, DWORD PTR _svgame+8224
	mov	ecx, DWORD PTR [eax+edx+672]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _touch$[ebp], eax

; 1100 : 				VectorCopy( pmtrace->deltavelocity, clent->v.velocity );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmtrace$[ebp]
	mov	eax, DWORD PTR [esi+eax+52]
	mov	DWORD PTR [ecx+edx+160], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmtrace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+52]
	mov	DWORD PTR [eax+edx+160], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmtrace$[ebp]
	mov	edx, DWORD PTR [esi+edx+52]
	mov	DWORD PTR [ecx+eax+160], edx

; 1101 : 				PM_ConvertTrace( &trace, pmtrace, touch );

	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmtrace$[ebp]
	push	ecx
	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	call	_PM_ConvertTrace
	add	esp, 12					; 0000000cH

; 1102 : 				SV_Impact( touch, clent, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _touch$[ebp]
	push	edx
	call	_SV_Impact
	add	esp, 12					; 0000000cH

; 1103 : 			}

	jmp	$LN2@SV_RunCmd
$LN3@SV_RunCmd:

; 1104 : 
; 1105 : 			// restore velocity
; 1106 : 			VectorCopy( oldvel, clent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _oldvel$[ebp+ecx]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR _oldvel$[ebp+edx]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _oldvel$[ebp+eax]
	mov	DWORD PTR [edx+ecx+160], eax
$LN15@SV_RunCmd:

; 1107 : 		}
; 1108 : 	}
; 1109 : 
; 1110 : 	svgame.pmove->numtouch = 0;

	mov	ecx, DWORD PTR _svgame+8224
	mov	DWORD PTR [ecx+283788], 0

; 1111 : 	svgame.globals->time = cl->timebase;

	mov	edx, DWORD PTR _cl$[ebp]
	cvtsd2ss xmm0, QWORD PTR [edx+264400]
	mov	eax, DWORD PTR _svgame+19236
	movss	DWORD PTR [eax], xmm0

; 1112 : 	svgame.globals->frametime = frametime;

	cvtsd2ss xmm0, QWORD PTR _frametime$[ebp]
	mov	ecx, DWORD PTR _svgame+19236
	movss	DWORD PTR [ecx+4], xmm0

; 1113 : 
; 1114 : 	// run post-think
; 1115 : 	svgame.dllFuncs.pfnPlayerPostThink( clent );

	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19336
	add	esp, 4

; 1116 : 	svgame.dllFuncs.pfnCmdEnd( clent );

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19416
	add	esp, 4

; 1117 : 
; 1118 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 128				; 00000080H
	jne	SHORT $LN16@SV_RunCmd

; 1119 : 	{
; 1120 : 		SV_RestoreMoveInterpolant( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_RestoreMoveInterpolant
	add	esp, 4
$LN16@SV_RunCmd:

; 1121 : 	}
; 1122 : }                                                         

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RunCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\server\sv_pmove.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_tr$ = 28						; size = 4
_SV_ClipPMoveToEntity PROC

; 47   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 48   : 	Assert( tr != NULL );

	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $LN5@SV_ClipPMo
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN6@SV_ClipPMo
$LN5@SV_ClipPMo:
	mov	DWORD PTR tv69[ebp], 0
$LN6@SV_ClipPMo:
	push	0
	push	48					; 00000030H
	push	OFFSET $SG136516
	push	OFFSET $SG136517
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 49   : 
; 50   : 	if( svgame.physFuncs.ClipPMoveToEntity != NULL )

	cmp	DWORD PTR _svgame+19508, 0
	je	SHORT $LN2@SV_ClipPMo

; 51   : 	{
; 52   : 		// do custom sweep test
; 53   : 		svgame.physFuncs.ClipPMoveToEntity( pe, start, mins, maxs, end, tr );

	mov	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	DWORD PTR _svgame+19508
	add	esp, 24					; 00000018H

; 54   : 	}

	jmp	SHORT $LN1@SV_ClipPMo
$LN2@SV_ClipPMo:

; 55   : 	else
; 56   : 	{
; 57   : 		// function is missed, so we didn't hit anything
; 58   : 		tr->allsolid = false;

	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [ecx], 0
$LN1@SV_ClipPMo:

; 59   : 	}
; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipPMoveToEntity ENDP
_TEXT	ENDS
END
