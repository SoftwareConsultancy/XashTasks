; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\pm_surface.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_PM_TraceTexture
PUBLIC	_PM_RecursiveSurfCheck
PUBLIC	_PM_TraceSurface
PUBLIC	_PM_TestLineExt
PUBLIC	_PM_SampleMiptex
PUBLIC	_PM_TestLine_r
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3d000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bd000000
EXTRN	_Sys_Error:PROC
EXTRN	_fabs:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_PM_HullForBsp:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__dtoui3:PROC
EXTRN	__ftoui3:PROC
EXTRN	_vec3_origin:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@bd000000
CONST	SEGMENT
__real@bd000000 DD 0bd000000r			; -0.03125
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3d000000
CONST	SEGMENT
__real@3d000000 DD 03d000000r			; 0.03125
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG137856 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\pm_surface.c', 00H
	ORG $+1
$SG137857 DB	'assert failed at %s:%i', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
tv200 = -120						; size = 8
tv199 = -112						; size = 8
tv294 = -104						; size = 4
_info$1 = -100						; size = 4
tv237 = -96						; size = 4
tv386 = -92						; size = 4
_side$ = -88						; size = 4
tv361 = -84						; size = 4
tv190 = -80						; size = 4
tv174 = -76						; size = 4
tv136 = -72						; size = 4
_contents$2 = -68					; size = 4
_surf$3 = -64						; size = 4
_r$ = -60						; size = 4
_back$ = -56						; size = 4
_midf$ = -52						; size = 4
_i$ = -48						; size = 4
_front$ = -44						; size = 4
_frac$ = -40						; size = 4
_j$4 = -36						; size = 4
_fb$5 = -32						; size = 4
_delta$6 = -28						; size = 12
_mid$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_node$ = 12						; size = 4
_p1f$ = 16						; size = 4
_p2f$ = 20						; size = 4
_start$ = 24						; size = 4
_stop$ = 28						; size = 4
_trace$ = 32						; size = 4
_PM_TestLine_r PROC

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
$loc0$36:

; 234  : 	float	front, back;
; 235  : 	float	frac, midf;
; 236  : 	int	i, r, side;
; 237  : 	vec3_t	mid;
; 238  : loc0:
; 239  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN8@PM_TestLin

; 240  : 	{
; 241  : 		// water, slime or lava interpret as empty
; 242  : 		if( node->contents == CONTENTS_SOLID )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], -2			; fffffffeH
	jne	SHORT $LN9@PM_TestLin

; 243  : 			return CONTENTS_SOLID;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@PM_TestLin
$LN9@PM_TestLin:

; 244  : 		if( node->contents == CONTENTS_SKY )

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -6			; fffffffaH
	jne	SHORT $LN10@PM_TestLin

; 245  : 			return CONTENTS_SKY;

	mov	eax, -6					; fffffffaH
	jmp	$LN1@PM_TestLin
$LN10@PM_TestLin:

; 246  : 		trace->fraction = 1.0f;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0

; 247  : 		return CONTENTS_EMPTY;

	or	eax, -1
	jmp	$LN1@PM_TestLin
$LN8@PM_TestLin:

; 248  : 	}
; 249  : 
; 250  : 	front = PlaneDiff( start, node->plane );

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	eax, BYTE PTR [edx+16]
	cmp	eax, 3
	jge	SHORT $LN21@PM_TestLin
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv136[ebp], xmm0
	jmp	SHORT $LN22@PM_TestLin
$LN21@PM_TestLin:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv136[ebp], xmm0
$LN22@PM_TestLin:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR tv136[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _front$[ebp], xmm0

; 251  : 	back = PlaneDiff( stop, node->plane );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN23@PM_TestLin
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _stop$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR tv174[ebp], xmm0
	jmp	SHORT $LN24@PM_TestLin
$LN23@PM_TestLin:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _stop$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv174[ebp], xmm0
$LN24@PM_TestLin:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR tv174[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _back$[ebp], xmm0

; 252  : 
; 253  : 	if( front >= -FRAC_EPSILON && back >= -FRAC_EPSILON )

	movss	xmm0, DWORD PTR _front$[ebp]
	comiss	xmm0, DWORD PTR __real@bd000000
	jb	SHORT $LN11@PM_TestLin
	movss	xmm0, DWORD PTR _back$[ebp]
	comiss	xmm0, DWORD PTR __real@bd000000
	jb	SHORT $LN11@PM_TestLin

; 254  : 	{
; 255  : 		node = node->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax

; 256  : 		goto loc0;

	jmp	$loc0$36
$LN11@PM_TestLin:

; 257  : 	}
; 258  : 
; 259  : 	if( front < FRAC_EPSILON && back < FRAC_EPSILON )

	movss	xmm0, DWORD PTR __real@3d000000
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN12@PM_TestLin
	movss	xmm0, DWORD PTR __real@3d000000
	comiss	xmm0, DWORD PTR _back$[ebp]
	jbe	SHORT $LN12@PM_TestLin

; 260  : 	{
; 261  : 		node = node->children[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax

; 262  : 		goto loc0;

	jmp	$loc0$36
$LN12@PM_TestLin:

; 263  : 	}
; 264  : 
; 265  : 	side = (front < 0);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN25@PM_TestLin
	mov	DWORD PTR tv190[ebp], 1
	jmp	SHORT $LN26@PM_TestLin
$LN25@PM_TestLin:
	mov	DWORD PTR tv190[ebp], 0
$LN26@PM_TestLin:
	mov	ecx, DWORD PTR tv190[ebp]
	mov	DWORD PTR _side$[ebp], ecx

; 266  : 	frac = front / (front - back);

	movss	xmm0, DWORD PTR _front$[ebp]
	subss	xmm0, DWORD PTR _back$[ebp]
	movss	xmm1, DWORD PTR _front$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 267  : 	frac = bound( 0.0, frac, 1.0 );

	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN29@PM_TestLin
	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN27@PM_TestLin
	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	movsd	QWORD PTR tv199[ebp], xmm0
	jmp	SHORT $LN28@PM_TestLin
$LN27@PM_TestLin:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv199[ebp], xmm0
$LN28@PM_TestLin:
	movsd	xmm0, QWORD PTR tv199[ebp]
	movsd	QWORD PTR tv200[ebp], xmm0
	jmp	SHORT $LN30@PM_TestLin
$LN29@PM_TestLin:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv200[ebp], xmm0
$LN30@PM_TestLin:
	cvtsd2ss xmm0, QWORD PTR tv200[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 268  : 
; 269  : 	VectorLerp( start, frac, stop, mid );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _stop$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv237[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv237[ebp]
	movss	DWORD PTR _mid$[ebp+ecx], xmm0

; 270  : 	midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 271  : 
; 272  : 	r = PM_TestLine_r( mod, node->children[side], p1f, midf, start, mid, trace );

	mov	edx, DWORD PTR _trace$[ebp]
	push	edx
	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_PM_TestLine_r
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _r$[ebp], eax

; 273  : 
; 274  : 	if( r != CONTENTS_EMPTY )

	cmp	DWORD PTR _r$[ebp], -1
	je	SHORT $LN13@PM_TestLin

; 275  : 	{
; 276  : 		if( trace->surface == NULL )

	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN14@PM_TestLin

; 277  : 			trace->fraction = midf;

	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN14@PM_TestLin:

; 278  : 		trace->contents = r;

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx+4], eax

; 279  : 		return r;

	mov	eax, DWORD PTR _r$[ebp]
	jmp	$LN1@PM_TestLin
$LN13@PM_TestLin:

; 280  : 	}
; 281  : 
; 282  : 	// walk through real faces
; 283  : 	for( i = 0; i < node->numsurfaces; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_TestLin
$LN2@PM_TestLin:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@PM_TestLin:
	mov	edx, DWORD PTR _node$[ebp]
	movzx	eax, WORD PTR [edx+50]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@PM_TestLin

; 284  : 	{
; 285  : 		msurface_t	*surf = &mod->surfaces[node->firstsurface + i];

	mov	ecx, DWORD PTR _node$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	add	edx, DWORD PTR _i$[ebp]
	imul	eax, edx, 92
	mov	ecx, DWORD PTR _mod$[ebp]
	add	eax, DWORD PTR [ecx+180]
	mov	DWORD PTR _surf$3[ebp], eax

; 286  : 		mextrasurf_t	*info = surf->info;

	mov	edx, DWORD PTR _surf$3[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _info$1[ebp], eax

; 287  : 		mfacebevel_t	*fb = info->bevel;

	mov	ecx, DWORD PTR _info$1[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR _fb$5[ebp], edx

; 288  : 		int		j, contents;
; 289  : 		vec3_t		delta;
; 290  : 
; 291  : 		if( !fb ) continue;

	cmp	DWORD PTR _fb$5[ebp], 0
	jne	SHORT $LN15@PM_TestLin
	jmp	SHORT $LN2@PM_TestLin
$LN15@PM_TestLin:

; 292  : 
; 293  : 		VectorSubtract( mid, fb->origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _fb$5[ebp]
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax+8]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$6[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fb$5[ebp]
	movss	xmm0, DWORD PTR _mid$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+8]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$6[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _fb$5[ebp]
	movss	xmm0, DWORD PTR _mid$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+8]
	movss	DWORD PTR tv294[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv294[ebp]
	movss	DWORD PTR _delta$6[ebp+eax], xmm0

; 294  : 		if( DotProduct( delta, delta ) >= fb->radius )

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$6[ebp+edx]
	mulss	xmm0, DWORD PTR _delta$6[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _delta$6[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$6[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _delta$6[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$6[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _fb$5[ebp]
	comiss	xmm0, DWORD PTR [eax+20]
	jb	SHORT $LN16@PM_TestLin

; 295  : 			continue;	// no intersection

	jmp	$LN2@PM_TestLin
$LN16@PM_TestLin:

; 296  : 
; 297  : 		for( j = 0; j < fb->numedges; j++ )

	mov	DWORD PTR _j$4[ebp], 0
	jmp	SHORT $LN7@PM_TestLin
$LN5@PM_TestLin:
	mov	ecx, DWORD PTR _j$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$4[ebp], ecx
$LN7@PM_TestLin:
	mov	edx, DWORD PTR _fb$5[ebp]
	mov	eax, DWORD PTR _j$4[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	$LN6@PM_TestLin

; 298  : 		{
; 299  : 			if( PlaneDiff( mid, &fb->edges[j] ) > FRAC_EPSILON )

	imul	ecx, DWORD PTR _j$4[ebp], 20
	mov	edx, DWORD PTR _fb$5[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx+16]
	cmp	ecx, 3
	jge	SHORT $LN31@PM_TestLin
	imul	edx, DWORD PTR _j$4[ebp], 20
	mov	eax, DWORD PTR _fb$5[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx+16]
	movss	xmm0, DWORD PTR _mid$[ebp+edx*4]
	movss	DWORD PTR tv361[ebp], xmm0
	jmp	SHORT $LN32@PM_TestLin
$LN31@PM_TestLin:
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _j$4[ebp], 20
	mov	eax, DWORD PTR _fb$5[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _j$4[ebp], 20
	mov	edx, DWORD PTR _fb$5[ebp]
	mov	edx, DWORD PTR [edx]
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _j$4[ebp], 20
	mov	ecx, DWORD PTR _fb$5[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv361[ebp], xmm0
$LN32@PM_TestLin:
	imul	ecx, DWORD PTR _j$4[ebp], 20
	mov	edx, DWORD PTR _fb$5[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR tv361[ebp]
	subss	xmm0, DWORD PTR [eax+ecx+12]
	comiss	xmm0, DWORD PTR __real@3d000000
	jbe	SHORT $LN17@PM_TestLin

; 300  : 				break; // outside the bounds

	jmp	SHORT $LN6@PM_TestLin
$LN17@PM_TestLin:

; 301  : 		}

	jmp	$LN5@PM_TestLin
$LN6@PM_TestLin:

; 302  : 
; 303  : 		if( j != fb->numedges )

	mov	ecx, DWORD PTR _fb$5[ebp]
	mov	edx, DWORD PTR _j$4[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN18@PM_TestLin

; 304  : 			continue; // we are outside the bounds of the facet

	jmp	$LN2@PM_TestLin
$LN18@PM_TestLin:

; 305  : 
; 306  : 		// hit the surface
; 307  : 		contents = PM_SampleMiptex( surf, mid );

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surf$3[ebp]
	push	ecx
	call	_PM_SampleMiptex
	add	esp, 8
	mov	DWORD PTR _contents$2[ebp], eax

; 308  : 
; 309  : 		// fill the trace and out
; 310  : 		trace->contents = contents;

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _contents$2[ebp]
	mov	DWORD PTR [edx+4], eax

; 311  : 		trace->fraction = midf;

	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 312  : 
; 313  : 		if( contents != CONTENTS_EMPTY )

	cmp	DWORD PTR _contents$2[ebp], -1
	je	SHORT $LN19@PM_TestLin

; 314  : 			trace->surface = surf;

	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _surf$3[ebp]
	mov	DWORD PTR [edx+8], eax
$LN19@PM_TestLin:

; 315  : 
; 316  : 		return contents;

	mov	eax, DWORD PTR _contents$2[ebp]
	jmp	SHORT $LN1@PM_TestLin

; 317  : 	}

	jmp	$LN2@PM_TestLin
$LN3@PM_TestLin:

; 318  : 
; 319  : 	return PM_TestLine_r( mod, node->children[!side], midf, p2f, mid, stop, trace );

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN33@PM_TestLin
	mov	DWORD PTR tv386[ebp], 1
	jmp	SHORT $LN34@PM_TestLin
$LN33@PM_TestLin:
	mov	DWORD PTR tv386[ebp], 0
$LN34@PM_TestLin:
	mov	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stop$[ebp]
	push	edx
	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _p2f$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR tv386[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_PM_TestLine_r
	add	esp, 28					; 0000001cH
$LN1@PM_TestLin:

; 320  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TestLine_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
_data$ = -44						; size = 4
_dt$ = -40						; size = 4
_ds$ = -36						; size = 4
_info$ = -32						; size = 4
_x$ = -28						; size = 4
_y$ = -24						; size = 4
_src$ = -20						; size = 4
_fb$ = -16						; size = 4
_contents$ = -12					; size = 4
_mt$ = -8						; size = 4
_tx$ = -4						; size = 4
_surf$ = 8						; size = 4
_point$ = 12						; size = 4
_PM_SampleMiptex PROC

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 52   : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 53   : 	mfacebevel_t	*fb = info->bevel;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR _fb$[ebp], eax

; 54   : 	int		contents;
; 55   : 	vec_t		ds, dt;
; 56   : 	byte		*data;
; 57   : 	int		x, y;
; 58   : 	mtexinfo_t	*tx;
; 59   : 	texture_t		*mt;
; 60   : 	rgbdata_t		*src;
; 61   : 
; 62   : 	// fill the default contents
; 63   : 	if( fb ) contents = fb->contents;

	cmp	DWORD PTR _fb$[ebp], 0
	je	SHORT $LN2@PM_SampleM
	mov	ecx, DWORD PTR _fb$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _contents$[ebp], edx
	jmp	SHORT $LN3@PM_SampleM
$LN2@PM_SampleM:

; 64   : 	else contents = CONTENTS_SOLID;

	mov	DWORD PTR _contents$[ebp], -2		; fffffffeH
$LN3@PM_SampleM:

; 65   : 
; 66   : 	if( !surf->texinfo || !surf->texinfo->texture ) 

	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN5@PM_SampleM
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN4@PM_SampleM
$LN5@PM_SampleM:

; 67   : 		return contents;

	mov	eax, DWORD PTR _contents$[ebp]
	jmp	$LN1@PM_SampleM
$LN4@PM_SampleM:

; 68   : 
; 69   : 	tx = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tx$[ebp], ecx

; 70   : 	mt = tx->texture;

	mov	edx, DWORD PTR _tx$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _mt$[ebp], eax

; 71   : 
; 72   : 	if( mt->name[0] != '{' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mt$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN6@PM_SampleM

; 73   : 		return contents;

	mov	eax, DWORD PTR _contents$[ebp]
	jmp	$LN1@PM_SampleM
$LN6@PM_SampleM:

; 74   : 
; 75   : 	src = R_GetTexture( mt->gl_texturenum )->original;

	mov	edx, DWORD PTR _mt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR _src$[ebp], ecx

; 76   : 	if( !src ) return contents; // original doesn't kept

	cmp	DWORD PTR _src$[ebp], 0
	jne	SHORT $LN7@PM_SampleM
	mov	eax, DWORD PTR _contents$[ebp]
	jmp	$LN1@PM_SampleM
$LN7@PM_SampleM:

; 77   : 
; 78   : 	ds = DotProduct( point, tx->vecs[0] ) + tx->vecs[0][3];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _tx$[ebp]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _tx$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _tx$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _tx$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _ds$[ebp], xmm0

; 79   : 	dt = DotProduct( point, tx->vecs[1] ) + tx->vecs[1][3];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _tx$[ebp]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _tx$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _tx$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _tx$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _dt$[ebp], xmm0

; 80   : 
; 81   : 	// convert ST to real pixels position
; 82   : 	x = fix_coord( ds, mt->width - 1 );

	mov	edx, DWORD PTR _mt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _ds$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fix_coord
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax

; 83   : 	y = fix_coord( dt, mt->height - 1 );

	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, 1
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fix_coord
	add	esp, 8
	mov	DWORD PTR _y$[ebp], eax

; 84   : 
; 85   : 	ASSERT( x >= 0 && y >= 0 );

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN9@PM_SampleM
	cmp	DWORD PTR _y$[ebp], 0
	jge	SHORT $LN8@PM_SampleM
$LN9@PM_SampleM:
	push	85					; 00000055H
	push	OFFSET $SG137856
	push	OFFSET $SG137857
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN8@PM_SampleM:

; 86   : 
; 87   : 	data = src->buffer;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _data$[ebp], ecx

; 88   : 	if( data[(mt->width * y) + x] == 255 )

	mov	edx, DWORD PTR _mt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN10@PM_SampleM

; 89   : 		return CONTENTS_EMPTY;

	or	eax, -1
	jmp	SHORT $LN1@PM_SampleM
$LN10@PM_SampleM:

; 90   : 	return CONTENTS_SOLID;

	mov	eax, -2					; fffffffeH
$LN1@PM_SampleM:

; 91   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_SampleMiptex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
tv85 = -8						; size = 8
_in$ = 8						; size = 4
_width$ = 12						; size = 4
_fix_coord PROC

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 39   : 	if( in > 0 ) return (uint)in % width;

	movss	xmm0, DWORD PTR _in$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@fix_coord
	movss	xmm0, DWORD PTR _in$[ebp]
	call	__ftoui3
	xor	edx, edx
	div	DWORD PTR _width$[ebp]
	mov	eax, edx
	jmp	SHORT $LN1@fix_coord
$LN2@fix_coord:

; 40   : 	return width - ((uint)fabs( in ) % width);

	cvtss2sd xmm0, DWORD PTR _in$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv85[ebp]
	movsd	xmm0, QWORD PTR tv85[ebp]
	call	__dtoui3
	xor	edx, edx
	div	DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, edx
$LN1@fix_coord:

; 41   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fix_coord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
tv195 = -152						; size = 4
tv171 = -148						; size = 4
_trace$ = -144						; size = 12
_trace_bbox$ = -132					; size = 12
_rotated$ = -120					; size = 4
_hull$ = -116						; size = 4
_i$ = -112						; size = 4
_pe$ = -108						; size = 4
_matrix$ = -104						; size = 64
_offset$ = -40						; size = 12
_start_l$ = -28						; size = 12
_end_l$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_ents$ = 12						; size = 4
_numents$ = 16						; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_flags$ = 28						; size = 4
_PM_TestLineExt PROC

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 324  : 	linetrace_t	trace, trace_bbox;
; 325  : 	matrix4x4		matrix;
; 326  : 	hull_t		*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 327  : 	vec3_t		offset, start_l, end_l;
; 328  : 	qboolean		rotated;
; 329  : 	physent_t		*pe;
; 330  : 	int		i;
; 331  : 
; 332  : 	trace.contents = CONTENTS_EMPTY;

	mov	DWORD PTR _trace$[ebp+4], -1

; 333  : 	trace.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace$[ebp], xmm0

; 334  : 	trace.surface = NULL;

	mov	DWORD PTR _trace$[ebp+8], 0

; 335  : 
; 336  : 	for( i = 0; i < numents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_TestLin
$LN2@PM_TestLin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_TestLin:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numents$[ebp]
	jge	$LN3@PM_TestLin

; 337  : 	{
; 338  : 		pe = &ents[i];

	imul	edx, DWORD PTR _i$[ebp], 224
	add	edx, DWORD PTR _ents$[ebp]
	mov	DWORD PTR _pe$[ebp], edx

; 339  : 
; 340  : 		if( i != 0 && FBitSet( flags, PM_WORLD_ONLY ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN5@PM_TestLin
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN5@PM_TestLin

; 341  : 			break;

	jmp	$LN3@PM_TestLin
$LN5@PM_TestLin:

; 342  : 
; 343  : 		if( !pe->model || pe->model->type != mod_brush || pe->solid != SOLID_BSP )

	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN7@PM_TestLin
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+48]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN7@PM_TestLin
	mov	ecx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [ecx+96], 4
	je	SHORT $LN6@PM_TestLin
$LN7@PM_TestLin:

; 344  : 			continue;

	jmp	SHORT $LN2@PM_TestLin
$LN6@PM_TestLin:

; 345  : 
; 346  : 		if( FBitSet( flags, PM_GLASS_IGNORE ) && pe->rendermode != kRenderNormal )

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	je	SHORT $LN8@PM_TestLin
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN8@PM_TestLin

; 347  : 			continue;

	jmp	SHORT $LN2@PM_TestLin
$LN8@PM_TestLin:

; 348  : 
; 349  : 		hull = &pe->model->hulls[0];

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], edx

; 350  : 
; 351  : 		hull = PM_HullForBsp( pe, pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 352  : 
; 353  : 		if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	jne	SHORT $LN9@PM_TestLin
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PM_TestLin
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PM_TestLin
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@PM_TestLin
$LN11@PM_TestLin:

; 354  : 			rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN10@PM_TestLin
$LN9@PM_TestLin:

; 355  : 		else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN10@PM_TestLin:

; 356  : 
; 357  : 		if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN12@PM_TestLin

; 358  : 		{
; 359  : 			Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 360  : 			Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 361  : 			Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	edx, DWORD PTR _end_l$[ebp]
	push	edx
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 362  : 		}

	jmp	$LN13@PM_TestLin
$LN12@PM_TestLin:

; 363  : 		else
; 364  : 		{
; 365  : 			VectorSubtract( start, pe->origin, start_l );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _start$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [esi+edx+36]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _start_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _start$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx+36]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _start$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	movss	DWORD PTR tv171[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv171[ebp]
	movss	DWORD PTR _start_l$[ebp+edx], xmm0

; 366  : 			VectorSubtract( end, pe->origin, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+36]
	movss	DWORD PTR tv195[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv195[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
$LN13@PM_TestLin:

; 367  : 		}
; 368  : 
; 369  : 		trace_bbox.contents = CONTENTS_EMPTY;

	mov	DWORD PTR _trace_bbox$[ebp+4], -1

; 370  : 		trace_bbox.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_bbox$[ebp], xmm0

; 371  : 		trace_bbox.surface = NULL;

	mov	DWORD PTR _trace_bbox$[ebp+8], 0

; 372  : 
; 373  : 		PM_TestLine_r( pe->model, &pe->model->nodes[hull->firstclipnode], 0.0f, 1.0f, start_l, end_l, &trace_bbox );

	lea	ecx, DWORD PTR _trace_bbox$[ebp]
	push	ecx
	lea	edx, DWORD PTR _end_l$[ebp]
	push	edx
	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _hull$[ebp]
	imul	ecx, DWORD PTR [eax+8], 52
	add	ecx, DWORD PTR [edx+164]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_PM_TestLine_r
	add	esp, 28					; 0000001cH

; 374  : 
; 375  : 		if( trace_bbox.contents != CONTENTS_EMPTY || trace_bbox.fraction < trace.fraction )

	cmp	DWORD PTR _trace_bbox$[ebp+4], -1
	jne	SHORT $LN15@PM_TestLin
	movss	xmm0, DWORD PTR _trace$[ebp]
	comiss	xmm0, DWORD PTR _trace_bbox$[ebp]
	jbe	SHORT $LN14@PM_TestLin
$LN15@PM_TestLin:

; 376  : 		{
; 377  : 			trace = trace_bbox;

	mov	ecx, DWORD PTR _trace_bbox$[ebp]
	mov	DWORD PTR _trace$[ebp], ecx
	mov	edx, DWORD PTR _trace_bbox$[ebp+4]
	mov	DWORD PTR _trace$[ebp+4], edx
	mov	eax, DWORD PTR _trace_bbox$[ebp+8]
	mov	DWORD PTR _trace$[ebp+8], eax
$LN14@PM_TestLin:

; 378  : 		}
; 379  : 	}

	jmp	$LN2@PM_TestLin
$LN3@PM_TestLin:

; 380  : 
; 381  : 	return trace.contents;

	mov	eax, DWORD PTR _trace$[ebp+4]

; 382  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TestLineExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
tv193 = -128						; size = 4
tv172 = -124						; size = 4
tv151 = -120						; size = 4
tv95 = -116						; size = 4
_bmodel$ = -112						; size = 4
_hull$ = -108						; size = 4
_matrix$ = -104						; size = 64
_start_l$ = -40						; size = 12
_end_l$ = -28						; size = 12
_offset$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_PM_TraceSurface PROC

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 178  : 	matrix4x4		matrix;
; 179  : 	model_t		*bmodel;
; 180  : 	hull_t		*hull;
; 181  : 	vec3_t		start_l, end_l;
; 182  : 	vec3_t		offset;
; 183  : 
; 184  : 	bmodel = pe->model;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _bmodel$[ebp], ecx

; 185  : 
; 186  : 	if( !bmodel || bmodel->type != mod_brush )

	cmp	DWORD PTR _bmodel$[ebp], 0
	je	SHORT $LN3@PM_TraceSu
	mov	edx, DWORD PTR _bmodel$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN2@PM_TraceSu
$LN3@PM_TraceSu:

; 187  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@PM_TraceSu
$LN2@PM_TraceSu:

; 188  : 
; 189  : 	hull = &pe->model->hulls[0];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], ecx

; 190  : 	VectorSubtract( hull->clip_mins, vec3_origin, offset );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+16]
	subss	xmm0, DWORD PTR _vec3_origin[edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+16]
	subss	xmm0, DWORD PTR _vec3_origin[edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _vec3_origin[eax]
	movss	DWORD PTR tv95[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR _offset$[ebp+edx], xmm0

; 191  : 	VectorAdd( offset, pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR _offset$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR _offset$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+36]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR _offset$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+36]
	movss	DWORD PTR tv151[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv151[ebp]
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 192  : 
; 193  : 	VectorSubtract( start, offset, start_l );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _start_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0

; 194  : 	VectorSubtract( end, offset, end_l );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _end_l$[ebp+edx], xmm0

; 195  : 
; 196  : 	// rotate start and end into the models frame of reference
; 197  : 	if( !VectorIsNull( pe->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PM_TraceSu
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PM_TraceSu
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@PM_TraceSu
$LN5@PM_TraceSu:

; 198  : 	{
; 199  : 		Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 200  : 		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	ecx, DWORD PTR _start_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 201  : 		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN4@PM_TraceSu:

; 202  : 	}
; 203  : 
; 204  : 	return PM_RecursiveSurfCheck( bmodel, &bmodel->nodes[hull->firstclipnode], start_l, end_l );

	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	imul	ecx, DWORD PTR [eax+8], 52
	mov	edx, DWORD PTR _bmodel$[ebp]
	add	ecx, DWORD PTR [edx+164]
	push	ecx
	mov	eax, DWORD PTR _bmodel$[ebp]
	push	eax
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
$LN1@PM_TraceSu:

; 205  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
_contents$1 = -104					; size = 4
tv274 = -100						; size = 4
_info$2 = -96						; size = 4
tv228 = -92						; size = 4
_side$ = -88						; size = 4
tv341 = -84						; size = 4
_surf$ = -80						; size = 4
tv192 = -76						; size = 4
tv191 = -72						; size = 4
tv185 = -68						; size = 4
tv169 = -64						; size = 4
tv131 = -60						; size = 4
_surf$3 = -56						; size = 4
_t2$ = -52						; size = 4
_i$ = -48						; size = 4
_t1$ = -44						; size = 4
_frac$ = -40						; size = 4
_j$4 = -36						; size = 4
_fb$5 = -32						; size = 4
_delta$6 = -28						; size = 12
_mid$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_node$ = 12						; size = 4
_p1$ = 16						; size = 4
_p2$ = 20						; size = 4
_PM_RecursiveSurfCheck PROC

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
$loc0$31:

; 101  : 	float		t1, t2, frac;
; 102  : 	int		i, side;
; 103  : 	msurface_t	*surf;
; 104  : 	vec3_t		mid;
; 105  : loc0:
; 106  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN8@PM_Recursi

; 107  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN8@PM_Recursi:

; 108  : 
; 109  : 	t1 = PlaneDiff( p1, node->plane );

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	eax, BYTE PTR [edx+16]
	cmp	eax, 3
	jge	SHORT $LN18@PM_Recursi
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN19@PM_Recursi
$LN18@PM_Recursi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv131[ebp], xmm0
$LN19@PM_Recursi:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR tv131[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _t1$[ebp], xmm0

; 110  : 	t2 = PlaneDiff( p2, node->plane );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN20@PM_Recursi
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _p2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN21@PM_Recursi
$LN20@PM_Recursi:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _p2$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv169[ebp], xmm0
$LN21@PM_Recursi:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR tv169[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _t2$[ebp], xmm0

; 111  : 
; 112  : 	if( t1 >= -FRAC_EPSILON && t2 >= -FRAC_EPSILON )

	movss	xmm0, DWORD PTR _t1$[ebp]
	comiss	xmm0, DWORD PTR __real@bd000000
	jb	SHORT $LN9@PM_Recursi
	movss	xmm0, DWORD PTR _t2$[ebp]
	comiss	xmm0, DWORD PTR __real@bd000000
	jb	SHORT $LN9@PM_Recursi

; 113  : 	{
; 114  : 		node = node->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax

; 115  : 		goto loc0;

	jmp	$loc0$31
$LN9@PM_Recursi:

; 116  : 	}
; 117  : 
; 118  : 	if( t1 < FRAC_EPSILON && t2 < FRAC_EPSILON )

	movss	xmm0, DWORD PTR __real@3d000000
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN10@PM_Recursi
	movss	xmm0, DWORD PTR __real@3d000000
	comiss	xmm0, DWORD PTR _t2$[ebp]
	jbe	SHORT $LN10@PM_Recursi

; 119  : 	{
; 120  : 		node = node->children[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax

; 121  : 		goto loc0;

	jmp	$loc0$31
$LN10@PM_Recursi:

; 122  : 	}
; 123  : 
; 124  : 	side = (t1 < 0.0f);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN22@PM_Recursi
	mov	DWORD PTR tv185[ebp], 1
	jmp	SHORT $LN23@PM_Recursi
$LN22@PM_Recursi:
	mov	DWORD PTR tv185[ebp], 0
$LN23@PM_Recursi:
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR _side$[ebp], ecx

; 125  : 	frac = t1 / ( t1 - t2 );

	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR _t2$[ebp]
	movss	xmm1, DWORD PTR _t1$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 126  : 	frac = bound( 0.0f, frac, 1.0f );

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN26@PM_Recursi
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN24@PM_Recursi
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR tv191[ebp], xmm0
	jmp	SHORT $LN25@PM_Recursi
$LN24@PM_Recursi:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv191[ebp], xmm0
$LN25@PM_Recursi:
	movss	xmm0, DWORD PTR tv191[ebp]
	movss	DWORD PTR tv192[ebp], xmm0
	jmp	SHORT $LN27@PM_Recursi
$LN26@PM_Recursi:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv192[ebp], xmm0
$LN27@PM_Recursi:
	movss	xmm0, DWORD PTR tv192[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 127  : 
; 128  : 	VectorLerp( p1, frac, p2, mid );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	edx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv228[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv228[ebp]
	movss	DWORD PTR _mid$[ebp+ecx], xmm0

; 129  : 
; 130  : 	if(( surf = PM_RecursiveSurfCheck( mod, node->children[side], p1, mid )) != NULL )

	lea	edx, DWORD PTR _mid$[ebp]
	push	edx
	mov	eax, DWORD PTR _p1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _side$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
	mov	DWORD PTR _surf$[ebp], eax
	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN11@PM_Recursi

; 131  : 		return surf;

	mov	eax, DWORD PTR _surf$[ebp]
	jmp	$LN1@PM_Recursi
$LN11@PM_Recursi:

; 132  : 
; 133  : 	// walk through real faces
; 134  : 	for( i = 0; i < node->numsurfaces; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_Recursi
$LN2@PM_Recursi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@PM_Recursi:
	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN3@PM_Recursi

; 135  : 	{
; 136  : 		msurface_t	*surf = &mod->surfaces[node->firstsurface + i];

	mov	edx, DWORD PTR _node$[ebp]
	movzx	eax, WORD PTR [edx+48]
	add	eax, DWORD PTR _i$[ebp]
	imul	ecx, eax, 92
	mov	edx, DWORD PTR _mod$[ebp]
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _surf$3[ebp], ecx

; 137  : 		mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$3[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$2[ebp], ecx

; 138  : 		mfacebevel_t	*fb = info->bevel;

	mov	edx, DWORD PTR _info$2[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR _fb$5[ebp], eax

; 139  : 		int		j, contents;
; 140  : 		vec3_t		delta;
; 141  : 
; 142  : 		if( !fb ) continue;	// ???

	cmp	DWORD PTR _fb$5[ebp], 0
	jne	SHORT $LN12@PM_Recursi
	jmp	SHORT $LN2@PM_Recursi
$LN12@PM_Recursi:

; 143  : 
; 144  : 		VectorSubtract( mid, fb->origin, delta );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _fb$5[ebp]
	movss	xmm0, DWORD PTR _mid$[ebp+edx]
	subss	xmm0, DWORD PTR [eax+ecx+8]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$6[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fb$5[ebp]
	movss	xmm0, DWORD PTR _mid$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+8]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _delta$6[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _fb$5[ebp]
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	subss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR tv274[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv274[ebp]
	movss	DWORD PTR _delta$6[ebp+ecx], xmm0

; 145  : 		if( DotProduct( delta, delta ) >= fb->radius )

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _delta$6[ebp+eax]
	mulss	xmm0, DWORD PTR _delta$6[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _delta$6[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$6[ebp+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _delta$6[ebp+edx]
	mulss	xmm1, DWORD PTR _delta$6[ebp+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _fb$5[ebp]
	comiss	xmm0, DWORD PTR [ecx+20]
	jb	SHORT $LN13@PM_Recursi

; 146  : 			continue;	// no intersection

	jmp	$LN2@PM_Recursi
$LN13@PM_Recursi:

; 147  : 
; 148  : 		for( j = 0; j < fb->numedges; j++ )

	mov	DWORD PTR _j$4[ebp], 0
	jmp	SHORT $LN7@PM_Recursi
$LN5@PM_Recursi:
	mov	edx, DWORD PTR _j$4[ebp]
	add	edx, 1
	mov	DWORD PTR _j$4[ebp], edx
$LN7@PM_Recursi:
	mov	eax, DWORD PTR _fb$5[ebp]
	mov	ecx, DWORD PTR _j$4[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN6@PM_Recursi

; 149  : 		{
; 150  : 			if( PlaneDiff( mid, &fb->edges[j] ) > FRAC_EPSILON )

	imul	edx, DWORD PTR _j$4[ebp], 20
	mov	eax, DWORD PTR _fb$5[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx+16]
	cmp	edx, 3
	jge	SHORT $LN28@PM_Recursi
	imul	eax, DWORD PTR _j$4[ebp], 20
	mov	ecx, DWORD PTR _fb$5[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax+16]
	movss	xmm0, DWORD PTR _mid$[ebp+eax*4]
	movss	DWORD PTR tv341[ebp], xmm0
	jmp	SHORT $LN29@PM_Recursi
$LN28@PM_Recursi:
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	eax, DWORD PTR _j$4[ebp], 20
	mov	ecx, DWORD PTR _fb$5[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR _mid$[ebp+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _j$4[ebp], 20
	mov	eax, DWORD PTR _fb$5[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _j$4[ebp], 20
	mov	edx, DWORD PTR _fb$5[ebp]
	mov	edx, DWORD PTR [edx]
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv341[ebp], xmm0
$LN29@PM_Recursi:
	imul	edx, DWORD PTR _j$4[ebp], 20
	mov	eax, DWORD PTR _fb$5[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR tv341[ebp]
	subss	xmm0, DWORD PTR [ecx+edx+12]
	comiss	xmm0, DWORD PTR __real@3d000000
	jbe	SHORT $LN14@PM_Recursi

; 151  : 				break; // outside the bounds

	jmp	SHORT $LN6@PM_Recursi
$LN14@PM_Recursi:

; 152  : 		}

	jmp	$LN5@PM_Recursi
$LN6@PM_Recursi:

; 153  : 
; 154  : 		if( j != fb->numedges )

	mov	edx, DWORD PTR _fb$5[ebp]
	mov	eax, DWORD PTR _j$4[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN15@PM_Recursi

; 155  : 			continue; // we are outside the bounds of the facet

	jmp	$LN2@PM_Recursi
$LN15@PM_Recursi:

; 156  : 
; 157  : 		// hit the surface
; 158  : 		contents = PM_SampleMiptex( surf, mid );

	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$3[ebp]
	push	edx
	call	_PM_SampleMiptex
	add	esp, 8
	mov	DWORD PTR _contents$1[ebp], eax

; 159  : 
; 160  : 		if( contents != CONTENTS_EMPTY )

	cmp	DWORD PTR _contents$1[ebp], -1
	je	SHORT $LN16@PM_Recursi

; 161  : 			return surf;

	mov	eax, DWORD PTR _surf$3[ebp]
	jmp	SHORT $LN1@PM_Recursi
$LN16@PM_Recursi:

; 162  : 		return NULL; // through the fence

	xor	eax, eax
	jmp	SHORT $LN1@PM_Recursi

; 163  : 	}

	jmp	$LN2@PM_Recursi
$LN3@PM_Recursi:

; 164  : 
; 165  : 	return PM_RecursiveSurfCheck( mod, node->children[side^1], mid, p2 );

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _side$[ebp]
	xor	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
$LN1@PM_Recursi:

; 166  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_RecursiveSurfCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\pm_surface.c
_TEXT	SEGMENT
_surf$ = -4						; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_PM_TraceTexture PROC

; 216  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 217  : 	msurface_t	*surf = PM_TraceSurface( pe, start, end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _surf$[ebp], eax

; 218  : 
; 219  : 	if( !surf || !surf->texinfo || !surf->texinfo->texture )

	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN3@PM_TraceTe
	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@PM_TraceTe
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN2@PM_TraceTe
$LN3@PM_TraceTe:

; 220  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@PM_TraceTe
$LN2@PM_TraceTe:

; 221  : 
; 222  : 	return surf->texinfo->texture->name;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+36]
$LN1@PM_TraceTe:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TraceTexture ENDP
_TEXT	ENDS
END
