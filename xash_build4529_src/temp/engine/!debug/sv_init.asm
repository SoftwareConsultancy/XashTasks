; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\server\sv_init.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SV_UPDATE_BACKUP
_DATA	SEGMENT
COMM	_svs:BYTE:012260H
COMM	_sv:BYTE:014bf58H
COMM	_svgame:BYTE:04c6cH
_DATA	ENDS
_DATA	SEGMENT
_SV_UPDATE_BACKUP DD 010H
_DATA	ENDS
PUBLIC	_SV_Active
PUBLIC	_SV_GetMaxClients
PUBLIC	_SV_Initialized
PUBLIC	_SV_ShutdownGame
PUBLIC	_SV_ExecLoadLevel
PUBLIC	_SV_ExecLoadGame
PUBLIC	_SV_ExecChangeLevel
PUBLIC	_SV_InitGameProgs
PUBLIC	_SV_FreeGameProgs
PUBLIC	_SV_ModelIndex
PUBLIC	_SV_SoundIndex
PUBLIC	_SV_EventIndex
PUBLIC	_SV_GenericIndex
PUBLIC	_SV_InitGame
PUBLIC	_SV_ActivateServer
PUBLIC	_SV_SpawnServer
PUBLIC	_SV_ModelHandle
PUBLIC	_SV_DeactivateServer
PUBLIC	_SV_FreeOldEntities
PUBLIC	_SV_SendSingleResource
PUBLIC	_SV_CreateGenericResources
PUBLIC	_SV_CreateResourceList
PUBLIC	_SV_CreateBaseline
PUBLIC	_SV_SetupClients
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_EmptyPool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_NET_Config:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_ReplaceExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Host_EndGame:PROC
EXTRN	_Host_ShutdownServer:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_IsSafeFileToDownload:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_MapFile:PROC
EXTRN	_HPAK_FlushHostQueue:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_Log_Printf:PROC
EXTRN	_CL_StopPlayback:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	_Mod_LoadWorld:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_Mod_FreeUnused:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_Netchan_Clear:PROC
EXTRN	_SV_FinalMessage:PROC
EXTRN	_SV_UpdateMovevars:PROC
EXTRN	_SV_SendResource:PROC
EXTRN	_Host_SetServerState:PROC
EXTRN	_Master_Add:PROC
EXTRN	_SV_Physics:PROC
EXTRN	_SV_TransferConsistencyInfo:PROC
EXTRN	_SV_LoadProgs:PROC
EXTRN	_SV_UnloadProgs:PROC
EXTRN	_SV_FreeEdicts:PROC
EXTRN	_SV_FreeEdict:PROC
EXTRN	_SV_InitEdict:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_SpawnEntities:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_Log_Open:PROC
EXTRN	_Log_PrintServerVars:PROC
EXTRN	_SV_LoadGameState:PROC
EXTRN	_SV_ChangeLevel:PROC
EXTRN	_SV_ClearGameState:PROC
EXTRN	_SV_ClearWorld:PROC
EXTRN	_SV_ClearPhysEnts:PROC
EXTRN	_MSG_WriteDeltaEntity:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_sv_maxclients:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_deathmatch:BYTE
EXTRN	_hostname:BYTE
EXTRN	_skill:BYTE
EXTRN	_coop:BYTE
EXTRN	_public_server:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
$SG136564 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG136320 DB	'MAX_RESOURCES limit exceeded (%d)', 0aH, 00H
	ORG $+1
$SG136339 DB	'sound/', 00H
	ORG $+1
$SG136340 DB	'%s%s', 00H
	ORG $+3
$SG136355 DB	'MAX_MODELS limit exceeded (%d)', 0aH, 00H
$SG136357 DB	'^3Warning:^7 late precache of %s', 0aH, 00H
	ORG $+2
$SG136368 DB	'^3Warning:^7 ''%s'' do not precache sentence names!', 0aH
	DB	00H
	ORG $+1
$SG136373 DB	'MAX_SOUNDS limit exceeded (%d)', 0aH, 00H
$SG136375 DB	'^3Warning:^7 late precache of %s', 0aH, 00H
	ORG $+2
$SG136387 DB	'MAX_EVENTS limit exceeded (%d)', 0aH, 00H
$SG136400 DB	'MAX_CUSTOM limit exceeded (%d)', 0aH, 00H
$SG136419 DB	'.res', 00H
	ORG $+3
$SG136421 DB	'Precaching from %s', 0aH, 00H
$SG136422 DB	'----------------------------------', 0aH, 00H
$SG136424 DB	'  %s', 0aH, 00H
	ORG $+2
$SG136425 DB	'----------------------------------', 0aH, 00H
$SG136426 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136454 DB	'!', 00H
	ORG $+2
$SG136455 DB	'sound/', 00H
	ORG $+1
$SG136456 DB	'%s%s', 00H
	ORG $+3
$SG136481 DB	'progs/player.mdl', 00H
	ORG $+3
$SG136482 DB	'models/player.mdl', 00H
	ORG $+2
$SG136484 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136524 DB	'sv_newunit', 00H
	ORG $+1
$SG136491 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136523 DB	'ActivateServer', 00H
	ORG $+1
$SG136530 DB	'%i player server started', 0aH, 00H
	ORG $+2
$SG136531 DB	'Game started', 0aH, 00H
	ORG $+2
$SG136532 DB	'Started map "%s" (CRC "%i")', 0aH, 00H
	ORG $+3
$SG136534 DB	'level loaded at %.2f sec', 0aH, 00H
	ORG $+2
$SG136540 DB	'mapchangecfgfile', 00H
	ORG $+3
$SG136536 DB	'^3Warning:^7 %i static entities was rejected due buffer '
	DB	'overflow', 0aH, 00H
	ORG $+2
$SG136542 DB	'exec %s', 0aH, 00H
	ORG $+3
$SG136538 DB	'^3Warning:^7 %i static decals was rejected due buffer ov'
	DB	'erflow', 0aH, 00H
$SG136553 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136584 DB	'deathmatch', 00H
	ORG $+1
$SG136555 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136560 DB	'^1Error:^7 can''t initialize %s', 0aH, 00H
$SG136567 DB	'The End', 00H
$SG136585 DB	'deathmatch', 00H
	ORG $+1
$SG136587 DB	'deathmatch', 00H
	ORG $+1
$SG136588 DB	'%d', 00H
	ORG $+1
$SG136589 DB	'maxplayers', 00H
	ORG $+1
$SG136619 DB	'Loading map "%s"', 0aH, 00H
	ORG $+2
$SG136590 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136621 DB	'hostname', 00H
	ORG $+3
$SG136591 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_init.c', 00H
$SG136592 DB	'%s alloced by server packet entities', 0aH, 00H
	ORG $+2
$SG136624 DB	'Spawn Server: %s [%s]', 0aH, 00H
	ORG $+1
$SG136625 DB	'Spawn Server: %s', 0aH, 00H
	ORG $+2
$SG136626 DB	'Signon', 00H
	ORG $+1
$SG136627 DB	'Multicast', 00H
	ORG $+2
$SG136628 DB	'Datagram', 00H
	ORG $+3
$SG136629 DB	'Reliable Datagram', 00H
	ORG $+2
$SG136630 DB	'Spectator Datagram', 00H
	ORG $+1
$SG136632 DB	'deathmatch', 00H
	ORG $+1
$SG136633 DB	'skill', 00H
	ORG $+2
$SG136635 DB	'sv_clienttrace', 00H
	ORG $+1
$SG136638 DB	'1', 00H
	ORG $+2
$SG136639 DB	'sv_background', 00H
	ORG $+2
$SG136640 DB	'1', 00H
	ORG $+2
$SG136641 DB	'cl_background', 00H
	ORG $+2
$SG136642 DB	'0', 00H
	ORG $+2
$SG136643 DB	'sv_background', 00H
	ORG $+2
$SG136644 DB	'0', 00H
	ORG $+2
$SG136645 DB	'cl_background', 00H
	ORG $+2
$SG136647 DB	'sv_clienttrace', 00H
	ORG $+1
$SG136650 DB	'maps/%s.bsp', 00H
$SG136652 DB	'progs.dat', 00H
	ORG $+2
$SG136653 DB	'rb', 00H
	ORG $+1
$SG136654 DB	'progs.dat', 00H
	ORG $+2
$SG136655 DB	'*%i', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
tv190 = -40						; size = 8
tv154 = -32						; size = 4
tv187 = -28						; size = 4
tv95 = -24						; size = 4
tv79 = -20						; size = 4
tv78 = -16						; size = 4
tv75 = -12						; size = 4
tv74 = -8						; size = 4
_changed_maxclients$ = -4				; size = 4
_SV_SetupClients PROC

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 709  : 	qboolean	changed_maxclients = false;

	mov	DWORD PTR _changed_maxclients$[ebp], 0

; 710  : 
; 711  : 	// check if clients count was really changed
; 712  : 	if( svs.maxclients != (int)sv_maxclients->value )

	mov	eax, DWORD PTR _sv_maxclients
	cvttss2si ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR _svs+16, ecx
	je	SHORT $LN2@SV_SetupCl

; 713  : 		changed_maxclients = true;

	mov	DWORD PTR _changed_maxclients$[ebp], 1
$LN2@SV_SetupCl:

; 714  : 
; 715  : 	if( !changed_maxclients ) return; // nothing to change

	cmp	DWORD PTR _changed_maxclients$[ebp], 0
	jne	SHORT $LN3@SV_SetupCl
	jmp	$LN1@SV_SetupCl
$LN3@SV_SetupCl:

; 716  : 
; 717  : 	// if clients count was changed we need to run full shutdown procedure
; 718  : 	if( svs.maxclients ) Host_ShutdownServer();

	cmp	DWORD PTR _svs+16, 0
	je	SHORT $LN4@SV_SetupCl
	call	_Host_ShutdownServer
$LN4@SV_SetupCl:

; 719  : 
; 720  : 	// copy the actual value from cvar
; 721  : 	svs.maxclients = (int)sv_maxclients->value;

	mov	edx, DWORD PTR _sv_maxclients
	cvttss2si eax, DWORD PTR [edx+12]
	mov	DWORD PTR _svs+16, eax

; 722  : 
; 723  : 	// dedicated servers are can't be single player and are usually DM
; 724  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@SV_SetupCl

; 725  : 		svs.maxclients = bound( 4, svs.maxclients, MAX_CLIENTS );

	cmp	DWORD PTR _svs+16, 4
	jl	SHORT $LN13@SV_SetupCl
	cmp	DWORD PTR _svs+16, 32			; 00000020H
	jge	SHORT $LN11@SV_SetupCl
	mov	ecx, DWORD PTR _svs+16
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN12@SV_SetupCl
$LN11@SV_SetupCl:
	mov	DWORD PTR tv74[ebp], 32			; 00000020H
$LN12@SV_SetupCl:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], edx
	jmp	SHORT $LN14@SV_SetupCl
$LN13@SV_SetupCl:
	mov	DWORD PTR tv75[ebp], 4
$LN14@SV_SetupCl:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _svs+16, eax
	jmp	SHORT $LN6@SV_SetupCl
$LN5@SV_SetupCl:

; 726  : 	else svs.maxclients = bound( 1, svs.maxclients, MAX_CLIENTS );

	cmp	DWORD PTR _svs+16, 1
	jl	SHORT $LN17@SV_SetupCl
	cmp	DWORD PTR _svs+16, 32			; 00000020H
	jge	SHORT $LN15@SV_SetupCl
	mov	ecx, DWORD PTR _svs+16
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN16@SV_SetupCl
$LN15@SV_SetupCl:
	mov	DWORD PTR tv78[ebp], 32			; 00000020H
$LN16@SV_SetupCl:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN18@SV_SetupCl
$LN17@SV_SetupCl:
	mov	DWORD PTR tv79[ebp], 1
$LN18@SV_SetupCl:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _svs+16, eax
$LN6@SV_SetupCl:

; 727  : 
; 728  : 	if( svs.maxclients == 1 )

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN7@SV_SetupCl

; 729  : 		Cvar_SetValue( "deathmatch", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136584
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN8@SV_SetupCl
$LN7@SV_SetupCl:

; 730  : 	else Cvar_SetValue( "deathmatch", 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136585
	call	_Cvar_SetValue
	add	esp, 8
$LN8@SV_SetupCl:

; 731  : 
; 732  : 	// make cvars consistant
; 733  : 	if( coop.value ) Cvar_SetValue( "deathmatch", 0.0f );

	movss	xmm0, DWORD PTR _coop+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@SV_SetupCl
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136587
	call	_Cvar_SetValue
	add	esp, 8
$LN9@SV_SetupCl:

; 734  : 
; 735  : 	// feedback for cvar
; 736  : 	Cvar_FullSet( "maxplayers", va( "%d", svs.maxclients ), FCVAR_LATCH );

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _svs+16
	push	ecx
	push	OFFSET $SG136588
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG136589
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 737  : 	SV_UPDATE_BACKUP = ( svs.maxclients == 1 ) ? SINGLEPLAYER_BACKUP : MULTIPLAYER_BACKUP;

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN19@SV_SetupCl
	mov	DWORD PTR tv95[ebp], 16			; 00000010H
	jmp	SHORT $LN20@SV_SetupCl
$LN19@SV_SetupCl:
	mov	DWORD PTR tv95[ebp], 64			; 00000040H
$LN20@SV_SetupCl:
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _SV_UPDATE_BACKUP, edx

; 738  : 
; 739  : 	svs.clients = Z_Realloc( svs.clients, sizeof( sv_client_t ) * svs.maxclients );

	push	739					; 000002e3H
	push	OFFSET $SG136590
	push	1
	imul	eax, DWORD PTR _svs+16, 287560
	push	eax
	mov	ecx, DWORD PTR _svs+33344
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _svs+33344, eax

; 740  : 	svs.num_client_entities = svs.maxclients * SV_UPDATE_BACKUP * NUM_PACKET_ENTITIES;

	mov	eax, DWORD PTR _svs+16
	imul	eax, DWORD PTR _SV_UPDATE_BACKUP
	shl	eax, 8
	mov	DWORD PTR _svs+33348, eax

; 741  : 	svs.packet_entities = Z_Realloc( svs.packet_entities, sizeof( entity_state_t ) * svs.num_client_entities );

	push	741					; 000002e5H
	push	OFFSET $SG136591
	push	1
	imul	ecx, DWORD PTR _svs+33348, 340
	push	ecx
	mov	edx, DWORD PTR _svs+33356
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _svs+33356, eax

; 742  : 	Con_Reportf( "%s alloced by server packet entities\n", Q_memprint( sizeof( entity_state_t ) * svs.num_client_entities ));

	push	2
	imul	ecx, DWORD PTR _svs+33348, 340
	mov	DWORD PTR tv187[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv187[ebp]
	mov	edx, DWORD PTR tv187[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv190[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv190[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG136592
	call	_Con_Reportf
	add	esp, 8

; 743  : 
; 744  : 	// init network stuff
; 745  : 	NET_Config(( svs.maxclients > 1 ));

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN21@SV_SetupCl
	mov	DWORD PTR tv154[ebp], 1
	jmp	SHORT $LN22@SV_SetupCl
$LN21@SV_SetupCl:
	mov	DWORD PTR tv154[ebp], 0
$LN22@SV_SetupCl:
	mov	eax, DWORD PTR tv154[ebp]
	push	eax
	call	_NET_Config
	add	esp, 4

; 746  : 	svgame.numEntities = svs.maxclients + 1; // clients + world

	mov	ecx, DWORD PTR _svs+16
	add	ecx, 1
	mov	DWORD PTR _svgame+7932, ecx

; 747  : 	ClearBits( sv_maxclients->flags, FCVAR_CHANGED );

	mov	edx, DWORD PTR _sv_maxclients
	mov	eax, DWORD PTR [edx+8]
	and	eax, -8193				; ffffdfffH
	mov	ecx, DWORD PTR _sv_maxclients
	mov	DWORD PTR [ecx+8], eax
$LN1@SV_SetupCl:

; 748  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetupClients ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_pEdict$1 = -368					; size = 4
_playermodel$ = -364					; size = 4
_pEdict$2 = -360					; size = 4
_delta_type$ = -356					; size = 4
_base$ = -352						; size = 4
_entnum$ = -348						; size = 4
_nullstate$ = -344					; size = 340
__$ArrayPad$ = -4					; size = 4
_SV_CreateBaseline PROC

; 391  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 392  : 	entity_state_t	nullstate, *base;
; 393  : 	int		playermodel;
; 394  : 	int		delta_type;
; 395  : 	int		entnum;
; 396  : 
; 397  : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34748
	and	eax, 2
	je	SHORT $LN11@SV_CreateB

; 398  : 		playermodel = SV_ModelIndex( DEFAULT_PLAYER_PATH_QUAKE );

	push	OFFSET $SG136481
	call	_SV_ModelIndex
	add	esp, 4
	mov	DWORD PTR _playermodel$[ebp], eax
	jmp	SHORT $LN12@SV_CreateB
$LN11@SV_CreateB:

; 399  : 	else playermodel = SV_ModelIndex( DEFAULT_PLAYER_PATH_HALFLIFE );

	push	OFFSET $SG136482
	call	_SV_ModelIndex
	add	esp, 4
	mov	DWORD PTR _playermodel$[ebp], eax
$LN12@SV_CreateB:

; 400  : 
; 401  : 	memset( &nullstate, 0, sizeof( nullstate ));

	push	340					; 00000154H
	push	0
	lea	ecx, DWORD PTR _nullstate$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 402  : 
; 403  : 	for( entnum = 0; entnum < svgame.numEntities; entnum++ )

	mov	DWORD PTR _entnum$[ebp], 0
	jmp	SHORT $LN4@SV_CreateB
$LN2@SV_CreateB:
	mov	edx, DWORD PTR _entnum$[ebp]
	add	edx, 1
	mov	DWORD PTR _entnum$[ebp], edx
$LN4@SV_CreateB:
	mov	eax, DWORD PTR _entnum$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN3@SV_CreateB

; 404  : 	{
; 405  : 		edict_t	*pEdict = EDICT_NUM( entnum );

	mov	ecx, DWORD PTR _entnum$[ebp]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$2[ebp], eax

; 406  : 
; 407  : 		if( !SV_IsValidEdict( pEdict ))

	push	407					; 00000197H
	push	OFFSET $SG136484
	mov	edx, DWORD PTR _pEdict$2[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@SV_CreateB

; 408  : 			continue;

	jmp	SHORT $LN2@SV_CreateB
$LN13@SV_CreateB:

; 409  : 
; 410  : 		if( entnum != 0 && entnum <= svs.maxclients )

	cmp	DWORD PTR _entnum$[ebp], 0
	je	SHORT $LN14@SV_CreateB
	mov	eax, DWORD PTR _entnum$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN14@SV_CreateB

; 411  : 		{
; 412  : 			delta_type = DELTA_PLAYER;

	mov	DWORD PTR _delta_type$[ebp], 1

; 413  : 		}

	jmp	SHORT $LN15@SV_CreateB
$LN14@SV_CreateB:

; 414  : 		else
; 415  : 		{
; 416  : 			if( !pEdict->v.modelindex )

	mov	ecx, DWORD PTR _pEdict$2[ebp]
	cmp	DWORD PTR [ecx+308], 0
	jne	SHORT $LN16@SV_CreateB

; 417  : 				continue; // invisible

	jmp	$LN2@SV_CreateB
$LN16@SV_CreateB:

; 418  : 			delta_type = DELTA_ENTITY;

	mov	DWORD PTR _delta_type$[ebp], 0
$LN15@SV_CreateB:

; 419  : 		}
; 420  : 
; 421  : 		// take current state as baseline
; 422  : 		base = &svs.baselines[entnum];

	imul	edx, DWORD PTR _entnum$[ebp], 340
	add	edx, DWORD PTR _svs+33360
	mov	DWORD PTR _base$[ebp], edx

; 423  : 
; 424  : 		base->number = entnum;

	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR _entnum$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 425  : 
; 426  : 		// set entity type
; 427  : 		if( FBitSet( pEdict->v.flags, FL_CUSTOMENTITY ))

	mov	edx, DWORD PTR _pEdict$2[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 536870912				; 20000000H
	je	SHORT $LN17@SV_CreateB

; 428  : 			base->entityType = ENTITY_BEAM;

	mov	ecx, DWORD PTR _base$[ebp]
	mov	DWORD PTR [ecx], 2
	jmp	SHORT $LN18@SV_CreateB
$LN17@SV_CreateB:

; 429  : 		else base->entityType = ENTITY_NORMAL;

	mov	edx, DWORD PTR _base$[ebp]
	mov	DWORD PTR [edx], 1
$LN18@SV_CreateB:

; 430  : 
; 431  : 		svgame.dllFuncs.pfnCreateBaseline( delta_type, entnum, base, pEdict, playermodel, host.player_mins[0], host.player_maxs[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _host+34284
	push	ecx
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	add	eax, OFFSET _host+34236
	push	eax
	mov	ecx, DWORD PTR _playermodel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEdict$2[ebp]
	push	edx
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _delta_type$[ebp]
	push	edx
	call	DWORD PTR _svgame+19400
	add	esp, 28					; 0000001cH

; 432  : 		sv.last_valid_baseline = entnum;

	mov	eax, DWORD PTR _entnum$[ebp]
	mov	DWORD PTR _sv+1179344, eax

; 433  : 	}

	jmp	$LN2@SV_CreateB
$LN3@SV_CreateB:

; 434  : 
; 435  : 	// create the instanced baselines
; 436  : 	svgame.dllFuncs.pfnCreateInstancedBaselines();

	call	DWORD PTR _svgame+19428

; 437  : 
; 438  : 	// now put the baseline into the signon message.
; 439  : 	MSG_BeginServerCmd( &sv.signon, svc_spawnbaseline );

	push	0
	push	1
	push	22					; 00000016H
	push	OFFSET _sv+1220372
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 440  : 
; 441  : 	for( entnum = 0; entnum < svgame.numEntities; entnum++ )

	mov	DWORD PTR _entnum$[ebp], 0
	jmp	SHORT $LN7@SV_CreateB
$LN5@SV_CreateB:
	mov	ecx, DWORD PTR _entnum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _entnum$[ebp], ecx
$LN7@SV_CreateB:
	mov	edx, DWORD PTR _entnum$[ebp]
	cmp	edx, DWORD PTR _svgame+7932
	jge	$LN6@SV_CreateB

; 442  : 	{
; 443  : 		edict_t	*pEdict = EDICT_NUM( entnum );

	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pEdict$1[ebp], eax

; 444  : 
; 445  : 		if( !SV_IsValidEdict( pEdict ))

	push	445					; 000001bdH
	push	OFFSET $SG136491
	mov	ecx, DWORD PTR _pEdict$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@SV_CreateB

; 446  : 			continue;

	jmp	SHORT $LN5@SV_CreateB
$LN19@SV_CreateB:

; 447  : 
; 448  : 		if( entnum != 0 && entnum <= svs.maxclients )

	cmp	DWORD PTR _entnum$[ebp], 0
	je	SHORT $LN20@SV_CreateB
	mov	edx, DWORD PTR _entnum$[ebp]
	cmp	edx, DWORD PTR _svs+16
	jg	SHORT $LN20@SV_CreateB

; 449  : 		{
; 450  : 			delta_type = DELTA_PLAYER;

	mov	DWORD PTR _delta_type$[ebp], 1

; 451  : 		}

	jmp	SHORT $LN21@SV_CreateB
$LN20@SV_CreateB:

; 452  : 		else
; 453  : 		{
; 454  : 			if( !pEdict->v.modelindex )

	mov	eax, DWORD PTR _pEdict$1[ebp]
	cmp	DWORD PTR [eax+308], 0
	jne	SHORT $LN22@SV_CreateB

; 455  : 				continue; // invisible

	jmp	$LN5@SV_CreateB
$LN22@SV_CreateB:

; 456  : 			delta_type = DELTA_ENTITY;

	mov	DWORD PTR _delta_type$[ebp], 0
$LN21@SV_CreateB:

; 457  : 		}
; 458  : 
; 459  : 		// take current state as baseline
; 460  : 		base = &svs.baselines[entnum];

	imul	ecx, DWORD PTR _entnum$[ebp], 340
	add	ecx, DWORD PTR _svs+33360
	mov	DWORD PTR _base$[ebp], ecx

; 461  : 
; 462  : 		MSG_WriteDeltaEntity( &nullstate, base, &sv.signon, true, delta_type, 1.0f, 0 );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _delta_type$[ebp]
	push	edx
	push	1
	push	OFFSET _sv+1220372
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nullstate$[ebp]
	push	ecx
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 463  : 	}

	jmp	$LN5@SV_CreateB
$LN6@SV_CreateB:

; 464  : 
; 465  : 	MSG_WriteUBitLong( &sv.signon, LAST_EDICT, MAX_ENTITY_BITS ); // end of baselines

	push	13					; 0000000dH
	push	8191					; 00001fffH
	push	OFFSET _sv+1220372
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 466  : 	MSG_WriteUBitLong( &sv.signon, sv.num_instanced, 6 );

	push	6
	mov	edx, DWORD PTR _sv+1179348
	push	edx
	push	OFFSET _sv+1220372
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 467  : 
; 468  : 	for( entnum = 0; entnum < sv.num_instanced; entnum++ )

	mov	DWORD PTR _entnum$[ebp], 0
	jmp	SHORT $LN10@SV_CreateB
$LN8@SV_CreateB:
	mov	eax, DWORD PTR _entnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _entnum$[ebp], eax
$LN10@SV_CreateB:
	mov	ecx, DWORD PTR _entnum$[ebp]
	cmp	ecx, DWORD PTR _sv+1179348
	jge	SHORT $LN9@SV_CreateB

; 469  : 	{
; 470  : 		base = &sv.instanced[entnum].baseline;

	imul	edx, DWORD PTR _entnum$[ebp], 344
	add	edx, OFFSET _sv+1157332
	mov	DWORD PTR _base$[ebp], edx

; 471  : 		MSG_WriteDeltaEntity( &nullstate, base, &sv.signon, true, DELTA_ENTITY, 1.0f, 0 );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	push	1
	push	OFFSET _sv+1220372
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nullstate$[ebp]
	push	ecx
	call	_MSG_WriteDeltaEntity
	add	esp, 28					; 0000001cH

; 472  : 	}

	jmp	SHORT $LN8@SV_CreateB
$LN9@SV_CreateB:

; 473  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
tv154 = -20						; size = 4
_ffirstsent$ = -16					; size = 4
_nSize$ = -12						; size = 4
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_CreateResourceList PROC

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 321  : 	qboolean	ffirstsent = false;

	mov	DWORD PTR _ffirstsent$[ebp], 0

; 322  : 	int	i, nSize;
; 323  : 	char	*s;
; 324  : 
; 325  : 	sv.num_resources = 0;

	mov	DWORD PTR _sv+1157324, 0

; 326  : 
; 327  : 	for( i = 1; i < MAX_CUSTOM; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_CreateR
$LN2@SV_CreateR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CreateR:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_CreateR

; 328  : 	{
; 329  : 		s = sv.files_precache[i];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+196804
	mov	DWORD PTR _s$[ebp], ecx

; 330  : 		if( !COM_CheckString( s )) break; // end of list

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN17@SV_CreateR
	jmp	SHORT $LN3@SV_CreateR
$LN17@SV_CreateR:

; 331  : 		nSize = FS_FileSize( s, false );

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 332  : 		SV_AddResource( t_generic, s, nSize, RES_FATALIFMISSING, i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _nSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	4
	call	_SV_AddResource
	add	esp, 20					; 00000014H

; 333  : 	}

	jmp	SHORT $LN2@SV_CreateR
$LN3@SV_CreateR:

; 334  : 
; 335  : 	for( i = 1; i < MAX_SOUNDS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@SV_CreateR
$LN5@SV_CreateR:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@SV_CreateR:
	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jge	$LN6@SV_CreateR

; 336  : 	{
; 337  : 		s = sv.sound_precache[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+65732
	mov	DWORD PTR _s$[ebp], edx

; 338  : 		if( !COM_CheckString( s ))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@SV_CreateR

; 339  : 			break; // end of list

	jmp	SHORT $LN6@SV_CreateR
$LN18@SV_CreateR:

; 340  : 
; 341  : 		if( s[0] == '!' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN19@SV_CreateR

; 342  : 		{
; 343  : 			if( !ffirstsent )

	cmp	DWORD PTR _ffirstsent$[ebp], 0
	jne	SHORT $LN21@SV_CreateR

; 344  : 			{
; 345  : 				SV_AddResource( t_sound, "!", 0, RES_FATALIFMISSING, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	1
	push	0
	push	OFFSET $SG136454
	push	0
	call	_SV_AddResource
	add	esp, 20					; 00000014H

; 346  : 				ffirstsent = true;

	mov	DWORD PTR _ffirstsent$[ebp], 1
$LN21@SV_CreateR:

; 347  : 			}
; 348  : 		}

	jmp	SHORT $LN20@SV_CreateR
$LN19@SV_CreateR:

; 349  : 		else
; 350  : 		{
; 351  : 			nSize = FS_FileSize( va( "%s%s", DEFAULT_SOUNDPATH, s ), false );

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET $SG136455
	push	OFFSET $SG136456
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 352  : 			SV_AddResource( t_sound, s, nSize, 0, i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	0
	call	_SV_AddResource
	add	esp, 20					; 00000014H
$LN20@SV_CreateR:

; 353  : 		}
; 354  : 	}

	jmp	$LN5@SV_CreateR
$LN6@SV_CreateR:

; 355  : 
; 356  : 	for( i = 1; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN10@SV_CreateR
$LN8@SV_CreateR:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@SV_CreateR:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN9@SV_CreateR

; 357  : 	{
; 358  : 		s = sv.model_precache[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+196
	mov	DWORD PTR _s$[ebp], edx

; 359  : 		if( !COM_CheckString( s )) break; // end of list

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@SV_CreateR
	jmp	SHORT $LN9@SV_CreateR
$LN22@SV_CreateR:

; 360  : 		nSize = ( s[0] != '*' ) ? FS_FileSize( s, false ) : 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN25@SV_CreateR
	push	0
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $LN26@SV_CreateR
$LN25@SV_CreateR:
	mov	DWORD PTR tv154[ebp], 0
$LN26@SV_CreateR:
	mov	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR _nSize$[ebp], eax

; 361  : 		SV_AddResource( t_model, s, nSize, sv.model_precache_flags[i], i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _sv[edx+327876]
	push	eax
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	2
	call	_SV_AddResource
	add	esp, 20					; 00000014H

; 362  : 	}

	jmp	$LN8@SV_CreateR
$LN9@SV_CreateR:

; 363  : 
; 364  : 	// just send names
; 365  : 	for( i = 0; i < MAX_DECALS && host.draw_decals[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@SV_CreateR
$LN11@SV_CreateR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@SV_CreateR:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN12@SV_CreateR
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _host[ecx+eax+1468]
	test	ecx, ecx
	je	SHORT $LN12@SV_CreateR

; 366  : 	{
; 367  : 		SV_AddResource( t_decal, host.draw_decals[i], 0, 0, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _host+1468
	push	eax
	push	3
	call	_SV_AddResource
	add	esp, 20					; 00000014H

; 368  : 	}

	jmp	SHORT $LN11@SV_CreateR
$LN12@SV_CreateR:

; 369  : 
; 370  : 	for( i = 1; i < MAX_EVENTS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN16@SV_CreateR
$LN14@SV_CreateR:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN16@SV_CreateR:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN1@SV_CreateR

; 371  : 	{
; 372  : 		s = sv.event_precache[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+262340
	mov	DWORD PTR _s$[ebp], edx

; 373  : 		if( !COM_CheckString( s )) break; // end of list

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@SV_CreateR
	jmp	SHORT $LN1@SV_CreateR
$LN23@SV_CreateR:

; 374  : 		nSize = FS_FileSize( s, false );

	push	0
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 375  : 		SV_AddResource( t_eventscript, s, nSize, RES_FATALIFMISSING, i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	5
	call	_SV_AddResource
	add	esp, 20					; 00000014H

; 376  : 	}

	jmp	SHORT $LN14@SV_CreateR
$LN1@SV_CreateR:

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_afile$ = -524						; size = 4
_pfile$ = -520						; size = 4
_token$ = -516						; size = 256
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_SV_CreateGenericResources PROC

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 284  : 	string	filename, token;
; 285  : 	char	*afile, *pfile;
; 286  : 
; 287  : 	Q_strncpy( filename, sv.model_precache[1], sizeof( filename ));

	push	256					; 00000100H
	mov	eax, 64					; 00000040H
	shl	eax, 0
	add	eax, OFFSET _sv+196
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 288  : 	COM_ReplaceExtension( filename, ".res" );

	push	OFFSET $SG136419
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 289  : 	COM_FixSlashes( filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 290  : 
; 291  : 	afile = FS_LoadFile( filename, NULL, false );

	push	0
	push	0
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _afile$[ebp], eax

; 292  : 	if( !afile ) return;

	cmp	DWORD PTR _afile$[ebp], 0
	jne	SHORT $LN4@SV_CreateG
	jmp	$LN1@SV_CreateG
$LN4@SV_CreateG:

; 293  : 
; 294  : 	pfile = afile;

	mov	edx, DWORD PTR _afile$[ebp]
	mov	DWORD PTR _pfile$[ebp], edx

; 295  : 
; 296  : 	Con_DPrintf( "Precaching from %s\n", filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG136421
	call	_Con_DPrintf
	add	esp, 8

; 297  : 	Con_DPrintf( "----------------------------------\n" );

	push	OFFSET $SG136422
	call	_Con_DPrintf
	add	esp, 4
$LN2@SV_CreateG:

; 298  : 
; 299  : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	SHORT $LN3@SV_CreateG

; 300  : 	{
; 301  : 		if( !COM_IsSafeFileToDownload( token ))

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_COM_IsSafeFileToDownload
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_CreateG

; 302  : 			continue;

	jmp	SHORT $LN2@SV_CreateG
$LN5@SV_CreateG:

; 303  : 
; 304  : 		Con_DPrintf( "  %s\n", token );

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	push	OFFSET $SG136424
	call	_Con_DPrintf
	add	esp, 8

; 305  : 		SV_GenericIndex( token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_SV_GenericIndex
	add	esp, 4

; 306  : 	}

	jmp	SHORT $LN2@SV_CreateG
$LN3@SV_CreateG:

; 307  : 
; 308  : 	Con_DPrintf( "----------------------------------\n" );

	push	OFFSET $SG136425
	call	_Con_DPrintf
	add	esp, 4

; 309  : 	Mem_Free( afile );

	push	309					; 00000135H
	push	OFFSET $SG136426
	mov	eax, DWORD PTR _afile$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@SV_CreateG:

; 310  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateGenericResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_pResource$ = -16					; size = 4
tv77 = -12						; size = 4
tv69 = -8						; size = 4
_nSize$ = -4						; size = 4
_name$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_flags$ = 20						; size = 1
_SV_SendSingleResource PROC

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 57   : 	resource_t	*pResource = &sv.resources[sv.num_resources];

	imul	eax, DWORD PTR _sv+1157324, 136
	add	eax, OFFSET _sv+461000
	mov	DWORD PTR _pResource$[ebp], eax

; 58   : 	int		nSize = 0;

	mov	DWORD PTR _nSize$[ebp], 0

; 59   : 
; 60   : 	if( !COM_CheckString( name ))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@SV_SendSin

; 61   : 		return;

	jmp	$LN1@SV_SendSin
$LN4@SV_SendSin:

; 62   : 
; 63   : 	switch( type )

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN6@SV_SendSin
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN5@SV_SendSin
	jmp	SHORT $LN7@SV_SendSin
$LN5@SV_SendSin:

; 64   : 	{
; 65   : 	case t_model:
; 66   : 		nSize = ( name[0] != '*' ) ? FS_FileSize( name, false ) : 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN9@SV_SendSin
	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN10@SV_SendSin
$LN9@SV_SendSin:
	mov	DWORD PTR tv77[ebp], 0
$LN10@SV_SendSin:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _nSize$[ebp], edx

; 67   : 		break;

	jmp	SHORT $LN2@SV_SendSin
$LN6@SV_SendSin:

; 68   : 	case t_sound:
; 69   : 		nSize = FS_FileSize( va( "%s%s", DEFAULT_SOUNDPATH, name ), false );

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG136339
	push	OFFSET $SG136340
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 70   : 		break;

	jmp	SHORT $LN2@SV_SendSin
$LN7@SV_SendSin:

; 71   : 	default:
; 72   : 		nSize = FS_FileSize( name, false );

	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax
$LN2@SV_SendSin:

; 73   : 		break;
; 74   : 	}
; 75   : 
; 76   : 	SV_AddResource( type, name, nSize, flags, index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	movzx	eax, BYTE PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	_SV_AddResource
	add	esp, 20					; 00000014H

; 77   : 	MSG_BeginServerCmd( &sv.reliable_datagram, svc_resource );

	push	0
	push	1
	push	16					; 00000010H
	push	OFFSET _sv+1195756
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 78   : 	SV_SendResource( pResource, &sv.reliable_datagram );

	push	OFFSET _sv+1195756
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_SV_SendResource
	add	esp, 8
$LN1@SV_SendSin:

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendSingleResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_pResource$ = -4					; size = 4
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_size$ = 16						; size = 4
_flags$ = 20						; size = 1
_index$ = 24						; size = 4
_SV_AddResource PROC

; 34   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 35   : 	resource_t	*pResource = &sv.resources[sv.num_resources];

	imul	eax, DWORD PTR _sv+1157324, 136
	add	eax, OFFSET _sv+461000
	mov	DWORD PTR _pResource$[ebp], eax

; 36   : 
; 37   : 	if( sv.num_resources >= MAX_RESOURCES )

	cmp	DWORD PTR _sv+1157324, 5120		; 00001400H
	jl	SHORT $LN2@SV_AddReso

; 38   : 		Host_Error( "MAX_RESOURCES limit exceeded (%d)\n", MAX_RESOURCES );

	push	5120					; 00001400H
	push	OFFSET $SG136320
	call	_Host_Error
	add	esp, 8
$LN2@SV_AddReso:

; 39   : 	sv.num_resources++;

	mov	ecx, DWORD PTR _sv+1157324
	add	ecx, 1
	mov	DWORD PTR _sv+1157324, ecx

; 40   : 
; 41   : 	Q_strncpy( pResource->szFileName, name, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 42   : 	pResource->nDownloadSize = size;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 43   : 	pResource->ucFlags = flags;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	cl, BYTE PTR _flags$[ebp]
	mov	BYTE PTR [eax+76], cl

; 44   : 	pResource->nIndex = index;

	mov	edx, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [edx+68], eax

; 45   : 	pResource->type = type;

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 46   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_ent$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_FreeOldEntities PROC

; 483  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 484  : 	edict_t	*ent;
; 485  : 	int	i;
; 486  : 
; 487  : 	// at end of frame kill all entities which supposed to it 
; 488  : 	for( i = svs.maxclients + 1; i < svgame.numEntities; i++ )

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@SV_FreeOld
$LN2@SV_FreeOld:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_FreeOld:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _svgame+7932
	jge	SHORT $LN3@SV_FreeOld

; 489  : 	{
; 490  : 		ent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 491  : 
; 492  : 		if( !ent->free && FBitSet( ent->v.flags, FL_KILLME ))

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN8@SV_FreeOld
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN8@SV_FreeOld

; 493  : 			SV_FreeEdict( ent );

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_FreeEdict
	add	esp, 4
$LN8@SV_FreeOld:

; 494  : 	}

	jmp	SHORT $LN2@SV_FreeOld
$LN3@SV_FreeOld:

; 495  : 
; 496  : 	// decrement svgame.numEntities if the highest number entities died
; 497  : 	for( ; EDICT_NUM( svgame.numEntities - 1 )->free; svgame.numEntities-- );

	jmp	SHORT $LN7@SV_FreeOld
$LN5@SV_FreeOld:
	mov	edx, DWORD PTR _svgame+7932
	sub	edx, 1
	mov	DWORD PTR _svgame+7932, edx
$LN7@SV_FreeOld:
	mov	eax, DWORD PTR _svgame+7932
	sub	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@SV_FreeOld
	jmp	SHORT $LN5@SV_FreeOld
$LN1@SV_FreeOld:

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FreeOldEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_DeactivateServer PROC

; 617  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 618  : 	int	i;
; 619  : 
; 620  : 	if( !svs.initialized || sv.state == ss_dead )

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN6@SV_Deactiv
	cmp	DWORD PTR _sv, 0
	jne	SHORT $LN5@SV_Deactiv
$LN6@SV_Deactiv:

; 621  : 		return;

	jmp	$LN1@SV_Deactiv
$LN5@SV_Deactiv:

; 622  : 
; 623  : 	svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19236
	movss	DWORD PTR [eax], xmm0

; 624  : 	svgame.dllFuncs.pfnServerDeactivate();

	call	DWORD PTR _svgame+19328

; 625  : 	Host_SetServerState( ss_dead );

	push	0
	call	_Host_SetServerState
	add	esp, 4

; 626  : 
; 627  : 	SV_FreeEdicts ();

	call	_SV_FreeEdicts

; 628  : 
; 629  : 	SV_ClearPhysEnts ();

	call	_SV_ClearPhysEnts

; 630  : 
; 631  : 	Mem_EmptyPool( svgame.stringspool );

	push	631					; 00000277H
	push	OFFSET $SG136553
	mov	ecx, DWORD PTR _svgame+19560
	push	ecx
	call	__Mem_EmptyPool
	add	esp, 12					; 0000000cH

; 632  : 
; 633  : 	for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Deactiv
$LN2@SV_Deactiv:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_Deactiv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_Deactiv

; 634  : 	{
; 635  : 		// release client frames
; 636  : 		if( svs.clients[i].frames )

	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx+281916], 0
	je	SHORT $LN7@SV_Deactiv

; 637  : 			Mem_Free( svs.clients[i].frames );

	push	637					; 0000027dH
	push	OFFSET $SG136555
	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	edx, DWORD PTR [ecx+eax+281916]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@SV_Deactiv:

; 638  : 		svs.clients[i].frames = NULL;

	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+eax+281916], 0

; 639  : 	}

	jmp	SHORT $LN2@SV_Deactiv
$LN3@SV_Deactiv:

; 640  : 
; 641  : 	svgame.globals->maxEntities = GI->max_edicts;

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1656]
	mov	DWORD PTR [edx+148], ecx

; 642  : 	svgame.globals->maxClients = svs.maxclients;

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _svs+16
	mov	DWORD PTR [edx+144], eax

; 643  : 	svgame.numEntities = svs.maxclients + 1; // clients + world

	mov	ecx, DWORD PTR _svs+16
	add	ecx, 1
	mov	DWORD PTR _svgame+7932, ecx

; 644  : 	svgame.globals->startspot = 0;

	mov	edx, DWORD PTR _svgame+19236
	mov	DWORD PTR [edx+16], 0

; 645  : 	svgame.globals->mapname = 0;

	mov	eax, DWORD PTR _svgame+19236
	mov	DWORD PTR [eax+12], 0
$LN1@SV_Deactiv:

; 646  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DeactivateServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_modelindex$ = 8					; size = 4
_SV_ModelHandle PROC

; 269  : {

	push	ebp
	mov	ebp, esp

; 270  : 	if( modelindex < 0 || modelindex >= MAX_MODELS )

	cmp	DWORD PTR _modelindex$[ebp], 0
	jl	SHORT $LN3@SV_ModelHa
	cmp	DWORD PTR _modelindex$[ebp], 1024	; 00000400H
	jl	SHORT $LN2@SV_ModelHa
$LN3@SV_ModelHa:

; 271  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ModelHa
$LN2@SV_ModelHa:

; 272  : 	return sv.models[modelindex];

	mov	eax, DWORD PTR _modelindex$[ebp]
	mov	eax, DWORD PTR _sv[eax*4+328900]
$LN1@SV_ModelHa:

; 273  : }

	pop	ebp
	ret	0
_SV_ModelHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_ent$ = -40						; size = 4
tv289 = -36						; size = 4
tv282 = -32						; size = 4
tv200 = -28						; size = 4
tv199 = -24						; size = 4
tv196 = -20						; size = 4
tv76 = -16						; size = 4
_f$1 = -12						; size = 4
_current_skill$ = -8					; size = 4
_i$ = -4						; size = 4
_mapname$ = 8						; size = 4
_startspot$ = 12					; size = 4
_background$ = 16					; size = 4
_SV_SpawnServer PROC

; 759  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 760  : 	int	i, current_skill;
; 761  : 	edict_t	*ent;
; 762  : 
; 763  : 	SV_SetupClients();

	call	_SV_SetupClients

; 764  : 
; 765  : 	if( !SV_InitGame( ))

	call	_SV_InitGame
	test	eax, eax
	jne	SHORT $LN8@SV_SpawnSe

; 766  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_SpawnSe
$LN8@SV_SpawnSe:

; 767  : 
; 768  : 	Log_Open();

	call	_Log_Open

; 769  : 	Log_Printf( "Loading map \"%s\"\n", mapname );

	mov	eax, DWORD PTR _mapname$[ebp]
	push	eax
	push	OFFSET $SG136619
	call	_Log_Printf
	add	esp, 8

; 770  : 	Log_PrintServerVars();

	call	_Log_PrintServerVars

; 771  : 
; 772  : 	svs.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _svs+8

; 773  : 	svs.spawncount++; // any partially connected client will be restarted

	mov	ecx, DWORD PTR _svs+33340
	add	ecx, 1
	mov	DWORD PTR _svs+33340, ecx

; 774  : 
; 775  : 	// let's not have any servers with no name
; 776  : 	if( !COM_CheckString( hostname.string ))

	mov	edx, DWORD PTR _hostname+4
	push	edx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@SV_SpawnSe

; 777  : 		Cvar_Set( "hostname", svgame.dllFuncs.pfnGetGameDescription ? svgame.dllFuncs.pfnGetGameDescription() : FS_Title( ));

	cmp	DWORD PTR _svgame+19352, 0
	je	SHORT $LN22@SV_SpawnSe
	call	DWORD PTR _svgame+19352
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN23@SV_SpawnSe
$LN22@SV_SpawnSe:
	mov	eax, DWORD PTR _SI+768
	add	eax, 384				; 00000180H
	mov	DWORD PTR tv76[ebp], eax
$LN23@SV_SpawnSe:
	mov	ecx, DWORD PTR tv76[ebp]
	push	ecx
	push	OFFSET $SG136621
	call	_Cvar_Set
	add	esp, 8
$LN9@SV_SpawnSe:

; 778  : 
; 779  : 	if( startspot )

	cmp	DWORD PTR _startspot$[ebp], 0
	je	SHORT $LN10@SV_SpawnSe

; 780  : 	{
; 781  : 		Con_Printf( "Spawn Server: %s [%s]\n", mapname, startspot );

	mov	edx, DWORD PTR _startspot$[ebp]
	push	edx
	mov	eax, DWORD PTR _mapname$[ebp]
	push	eax
	push	OFFSET $SG136624
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 782  : 	}

	jmp	SHORT $LN11@SV_SpawnSe
$LN10@SV_SpawnSe:

; 783  : 	else
; 784  : 	{
; 785  : 		Con_DPrintf( "Spawn Server: %s\n", mapname );

	mov	ecx, DWORD PTR _mapname$[ebp]
	push	ecx
	push	OFFSET $SG136625
	call	_Con_DPrintf
	add	esp, 8
$LN11@SV_SpawnSe:

; 786  : 	}
; 787  : 
; 788  : 	memset( &sv, 0, sizeof( sv ));	// wipe the entire per-level structure

	push	1359704					; 0014bf58H
	push	0
	push	OFFSET _sv
	call	_memset
	add	esp, 12					; 0000000cH

; 789  : 	sv.time = svgame.globals->time = 1.0f;	// server spawn time it's always 1.0 second

	mov	edx, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx], xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _sv+16, xmm0

; 790  : 	sv.background = background;

	mov	eax, DWORD PTR _background$[ebp]
	mov	DWORD PTR _sv+4, eax

; 791  : 	
; 792  : 	// initialize buffers
; 793  : 	MSG_Init( &sv.signon, "Signon", sv.signon_buf, sizeof( sv.signon_buf ));

	push	-1
	push	131072					; 00020000H
	push	OFFSET _sv+1220392
	push	OFFSET $SG136626
	push	OFFSET _sv+1220372
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 794  : 	MSG_Init( &sv.multicast, "Multicast", sv.multicast_buf, sizeof( sv.multicast_buf ));

	push	-1
	push	8192					; 00002000H
	push	OFFSET _sv+1212180
	push	OFFSET $SG136627
	push	OFFSET _sv+1212160
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 795  : 	MSG_Init( &sv.datagram, "Datagram", sv.datagram_buf, sizeof( sv.datagram_buf ));

	push	-1
	push	16384					; 00004000H
	push	OFFSET _sv+1179372
	push	OFFSET $SG136628
	push	OFFSET _sv+1179352
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 796  : 	MSG_Init( &sv.reliable_datagram, "Reliable Datagram", sv.reliable_datagram_buf, sizeof( sv.reliable_datagram_buf ));

	push	-1
	push	16384					; 00004000H
	push	OFFSET _sv+1195776
	push	OFFSET $SG136629
	push	OFFSET _sv+1195756
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 797  : 	MSG_Init( &sv.spec_datagram, "Spectator Datagram", sv.spectator_buf, sizeof( sv.spectator_buf ));

	push	-1
	push	8192					; 00002000H
	push	OFFSET _sv+1351484
	push	OFFSET $SG136630
	push	OFFSET _sv+1351464
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 798  : 
; 799  : 	// clearing all the baselines
; 800  : 	memset( svs.static_entities, 0, sizeof( entity_state_t ) * MAX_STATIC_ENTITIES );

	push	1052640					; 00100fe0H
	push	0
	mov	ecx, DWORD PTR _svs+33364
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 801  : 	memset( svs.baselines, 0, sizeof( entity_state_t ) * GI->max_edicts );

	mov	edx, DWORD PTR _SI+768
	imul	eax, DWORD PTR [edx+1656], 340
	push	eax
	push	0
	mov	ecx, DWORD PTR _svs+33360
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 802  : 
; 803  : 	// make cvars consistant
; 804  : 	if( coop.value ) Cvar_SetValue( "deathmatch", 0 );

	movss	xmm0, DWORD PTR _coop+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SV_SpawnSe
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136632
	call	_Cvar_SetValue
	add	esp, 8
$LN12@SV_SpawnSe:

; 805  : 	current_skill = Q_rint( skill.value );

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _skill+12
	jbe	SHORT $LN24@SV_SpawnSe
	movss	xmm0, DWORD PTR _skill+12
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv196[ebp], edx
	jmp	SHORT $LN25@SV_SpawnSe
$LN24@SV_SpawnSe:
	movss	xmm0, DWORD PTR _skill+12
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv196[ebp], eax
$LN25@SV_SpawnSe:
	mov	ecx, DWORD PTR tv196[ebp]
	mov	DWORD PTR _current_skill$[ebp], ecx

; 806  : 	current_skill = bound( 0, current_skill, 3 );

	cmp	DWORD PTR _current_skill$[ebp], 0
	jl	SHORT $LN28@SV_SpawnSe
	cmp	DWORD PTR _current_skill$[ebp], 3
	jge	SHORT $LN26@SV_SpawnSe
	mov	edx, DWORD PTR _current_skill$[ebp]
	mov	DWORD PTR tv199[ebp], edx
	jmp	SHORT $LN27@SV_SpawnSe
$LN26@SV_SpawnSe:
	mov	DWORD PTR tv199[ebp], 3
$LN27@SV_SpawnSe:
	mov	eax, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN29@SV_SpawnSe
$LN28@SV_SpawnSe:
	mov	DWORD PTR tv200[ebp], 0
$LN29@SV_SpawnSe:
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR _current_skill$[ebp], ecx

; 807  : 	Cvar_SetValue( "skill", (float)current_skill );

	cvtsi2ss xmm0, DWORD PTR _current_skill$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136633
	call	_Cvar_SetValue
	add	esp, 8

; 808  : 
; 809  : 	// force normal player collisions for single player
; 810  : 	if( svs.maxclients == 1 )

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN13@SV_SpawnSe

; 811  : 		Cvar_SetValue( "sv_clienttrace", 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136635
	call	_Cvar_SetValue
	add	esp, 8
$LN13@SV_SpawnSe:

; 812  : 
; 813  : 	// copy gamemode into svgame.globals
; 814  : 	svgame.globals->deathmatch = deathmatch.value;

	mov	edx, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR _deathmatch+12
	movss	DWORD PTR [edx+20], xmm0

; 815  : 	svgame.globals->coop = coop.value;

	mov	eax, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR _coop+12
	movss	DWORD PTR [eax+24], xmm0

; 816  : 	svgame.globals->maxClients = svs.maxclients;

	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR _svs+16
	mov	DWORD PTR [ecx+144], edx

; 817  : 
; 818  : 	if( sv.background )

	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN14@SV_SpawnSe

; 819  : 	{
; 820  : 		// tell the game parts about background state
; 821  : 		Cvar_FullSet( "sv_background", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG136638
	push	OFFSET $SG136639
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 822  : 		Cvar_FullSet( "cl_background", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG136640
	push	OFFSET $SG136641
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 823  : 	}

	jmp	SHORT $LN15@SV_SpawnSe
$LN14@SV_SpawnSe:

; 824  : 	else
; 825  : 	{
; 826  : 		Cvar_FullSet( "sv_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG136642
	push	OFFSET $SG136643
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 827  : 		Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET $SG136644
	push	OFFSET $SG136645
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN15@SV_SpawnSe:

; 828  : 	}
; 829  : 
; 830  : 	// force normal player collisions for single player
; 831  : 	if( svs.maxclients == 1 ) Cvar_SetValue( "sv_clienttrace", 1 );

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN16@SV_SpawnSe
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136647
	call	_Cvar_SetValue
	add	esp, 8
$LN16@SV_SpawnSe:

; 832  : 
; 833  : 	// make sure what server name doesn't contain path and extension
; 834  : 	COM_FileBase( mapname, sv.name );

	push	OFFSET _sv+56
	mov	eax, DWORD PTR _mapname$[ebp]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 835  : 
; 836  : 	// precache and static commands can be issued during map initialization
; 837  : 	Host_SetServerState( ss_loading );

	push	1
	call	_Host_SetServerState
	add	esp, 4

; 838  : 
; 839  : 	if( startspot )

	cmp	DWORD PTR _startspot$[ebp], 0
	je	SHORT $LN17@SV_SpawnSe

; 840  : 		Q_strncpy( sv.startspot, startspot, sizeof( sv.startspot ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _startspot$[ebp]
	push	ecx
	push	OFFSET _sv+120
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@SV_SpawnSe
$LN17@SV_SpawnSe:

; 841  : 	else sv.startspot[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _sv[eax+120], 0
$LN18@SV_SpawnSe:

; 842  : 
; 843  : 	Q_snprintf( sv.model_precache[WORLD_INDEX], sizeof( sv.model_precache[0] ), "maps/%s.bsp", sv.name );

	push	OFFSET _sv+56
	push	OFFSET $SG136650
	push	64					; 00000040H
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	add	ecx, OFFSET _sv+196
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 844  : 	SetBits( sv.model_precache_flags[WORLD_INDEX], RES_FATALIFMISSING );

	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _sv[edx+327876]
	or	eax, 1
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _sv[ecx+327876], al

; 845  : 	sv.worldmodel = sv.models[WORLD_INDEX] = Mod_LoadWorld( sv.model_precache[WORLD_INDEX], true );

	push	1
	mov	edx, 64					; 00000040H
	shl	edx, 0
	add	edx, OFFSET _sv+196
	push	edx
	call	_Mod_LoadWorld
	add	esp, 8
	mov	DWORD PTR tv282[ebp], eax
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR _sv[eax+328900], ecx
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR _sv+1359676, edx

; 846  : 	CRC32_MapFile( &sv.worldmapCRC, sv.model_precache[WORLD_INDEX], svs.maxclients > 1 );

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN30@SV_SpawnSe
	mov	DWORD PTR tv289[ebp], 1
	jmp	SHORT $LN31@SV_SpawnSe
$LN30@SV_SpawnSe:
	mov	DWORD PTR tv289[ebp], 0
$LN31@SV_SpawnSe:
	mov	eax, DWORD PTR tv289[ebp]
	push	eax
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	add	ecx, OFFSET _sv+196
	push	ecx
	push	OFFSET _sv+48
	call	_CRC32_MapFile
	add	esp, 12					; 0000000cH

; 847  : 
; 848  : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ) && FS_FileExists( "progs.dat", false ))

	mov	edx, DWORD PTR _host+34748
	and	edx, 2
	je	SHORT $LN19@SV_SpawnSe
	push	0
	push	OFFSET $SG136652
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@SV_SpawnSe

; 849  : 	{
; 850  : 		file_t *f = FS_Open( "progs.dat", "rb", false );

	push	0
	push	OFFSET $SG136653
	push	OFFSET $SG136654
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$1[ebp], eax

; 851  : 		FS_Seek( f, sizeof( int ), SEEK_SET );

	push	0
	push	4
	mov	eax, DWORD PTR _f$1[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 852  : 		FS_Read( f, &sv.progsCRC, sizeof( int ));

	push	4
	push	OFFSET _sv+52
	mov	ecx, DWORD PTR _f$1[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 853  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$1[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4
$LN19@SV_SpawnSe:

; 854  : 	}
; 855  : 
; 856  : 	for( i = WORLD_INDEX; i < sv.worldmodel->numsubmodels; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_SpawnSe
$LN2@SV_SpawnSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_SpawnSe:
	mov	ecx, DWORD PTR _sv+1359676
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+120]
	jge	SHORT $LN3@SV_SpawnSe

; 857  : 	{
; 858  : 		Q_sprintf( sv.model_precache[i+1], "*%i", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG136655
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	shl	ecx, 6
	add	ecx, OFFSET _sv+196
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 859  : 		sv.models[i+1] = Mod_ForName( sv.model_precache[i+1], false, false );

	push	0
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	shl	edx, 6
	add	edx, OFFSET _sv+196
	push	edx
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sv[ecx*4+328904], eax

; 860  : 		SetBits( sv.model_precache_flags[i+1], RES_FATALIFMISSING );

	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR _sv[edx+327877]
	or	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _sv[ecx+327877], al

; 861  : 	}

	jmp	SHORT $LN2@SV_SpawnSe
$LN3@SV_SpawnSe:

; 862  : 
; 863  : 	// leave slots at start for clients only
; 864  : 	for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_SpawnSe
$LN5@SV_SpawnSe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@SV_SpawnSe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_SpawnSe

; 865  : 	{
; 866  : 		// needs to reconnect
; 867  : 		if( svs.clients[i].state > cs_connected )

	imul	ecx, DWORD PTR _i$[ebp], 287560
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 2
	jle	SHORT $LN20@SV_SpawnSe

; 868  : 			svs.clients[i].state = cs_connected;

	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+eax], 2
$LN20@SV_SpawnSe:

; 869  : 
; 870  : 		ent = EDICT_NUM( i + 1 );

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 871  : 		svs.clients[i].pViewEntity = NULL;

	imul	eax, DWORD PTR _i$[ebp], 287560
	mov	ecx, DWORD PTR _svs+33344
	mov	DWORD PTR [ecx+eax+264984], 0

; 872  : 		svs.clients[i].edict = ent;

	imul	edx, DWORD PTR _i$[ebp], 287560
	mov	eax, DWORD PTR _svs+33344
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+edx+264980], ecx

; 873  : 		SV_InitEdict( ent );

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_InitEdict
	add	esp, 4

; 874  : 	}

	jmp	$LN5@SV_SpawnSe
$LN6@SV_SpawnSe:

; 875  : 
; 876  : 	// heartbeats will always be sent to the id master
; 877  : 	svs.last_heartbeat = MAX_HEARTBEAT; // send immediately

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0

; 878  : 
; 879  : 	// get actual movevars
; 880  : 	SV_UpdateMovevars( true );

	push	1
	call	_SV_UpdateMovevars
	add	esp, 4

; 881  : 
; 882  : 	// clear physics interaction links
; 883  : 	SV_ClearWorld();

	call	_SV_ClearWorld

; 884  : 
; 885  : 	return true;

	mov	eax, 1
$LN1@SV_SpawnSe:

; 886  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SpawnServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_msg$ = -131124						; size = 20
tv215 = -131104						; size = 8
_cycle$1 = -131096					; size = 4
_numFrames$ = -131092					; size = 4
tv79 = -131088						; size = 4
_cl$ = -131084						; size = 4
_i$ = -131080						; size = 4
_msg_buf$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_runPhysics$ = 8					; size = 4
_SV_ActivateServer PROC

; 508  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131124				; 00020034H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 509  : 	int		i, numFrames;
; 510  : 	byte		msg_buf[MAX_INIT_MSG];
; 511  : 	sizebuf_t		msg;
; 512  : 	sv_client_t	*cl;
; 513  : 
; 514  : 	if( !svs.initialized )

	cmp	DWORD PTR _svs, 0
	jne	SHORT $LN8@SV_Activat

; 515  : 		return;

	jmp	$LN19@SV_Activat
$LN8@SV_Activat:

; 516  : 
; 517  : 	MSG_Init( &msg, "ActivateServer", msg_buf, sizeof( msg_buf ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _msg_buf$[ebp]
	push	eax
	push	OFFSET $SG136523
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt

; 518  : 
; 519  : 	// always clearing newunit variable
; 520  : 	Cvar_SetValue( "sv_newunit", 0 );

	add	esp, 16					; 00000010H
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG136524
	call	_Cvar_SetValue
	add	esp, 8

; 521  : 
; 522  : 	// relese all intermediate entities
; 523  : 	SV_FreeOldEntities ();

	call	_SV_FreeOldEntities

; 524  : 
; 525  : 	// Activate the DLL server code
; 526  : 	svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	edx, DWORD PTR _svgame+19236
	movss	DWORD PTR [edx], xmm0

; 527  : 	svgame.dllFuncs.pfnServerActivate( svgame.edicts, svgame.numEntities, svs.maxclients );

	mov	eax, DWORD PTR _svs+16
	push	eax
	mov	ecx, DWORD PTR _svgame+7932
	push	ecx
	mov	edx, DWORD PTR _svgame+7928
	push	edx
	call	DWORD PTR _svgame+19324
	add	esp, 12					; 0000000cH

; 528  : 
; 529  : 	// parse user-specified resources
; 530  : 	SV_CreateGenericResources();

	call	_SV_CreateGenericResources

; 531  : 
; 532  : 	if( runPhysics )

	cmp	DWORD PTR _runPhysics$[ebp], 0
	je	SHORT $LN9@SV_Activat

; 533  : 	{
; 534  : 		numFrames = (svs.maxclients <= 1) ? 2 : 8;

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN21@SV_Activat
	mov	DWORD PTR tv79[ebp], 2
	jmp	SHORT $LN22@SV_Activat
$LN21@SV_Activat:
	mov	DWORD PTR tv79[ebp], 8
$LN22@SV_Activat:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _numFrames$[ebp], eax

; 535  : 		sv.frametime = SV_SPAWN_TIME;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _sv+32, xmm0

; 536  : 	}

	jmp	SHORT $LN10@SV_Activat
$LN9@SV_Activat:

; 537  : 	else
; 538  : 	{
; 539  : 		sv.frametime = 0.001;

	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _sv+32, xmm0

; 540  : 		numFrames = 1;

	mov	DWORD PTR _numFrames$[ebp], 1
$LN10@SV_Activat:

; 541  : 	}
; 542  : 
; 543  : 	// run some frames to allow everything to settle
; 544  : 	for( i = 0; i < numFrames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Activat
$LN2@SV_Activat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_Activat:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numFrames$[ebp]
	jge	SHORT $LN3@SV_Activat

; 545  : 		SV_Physics();

	call	_SV_Physics
	jmp	SHORT $LN2@SV_Activat
$LN3@SV_Activat:

; 546  : 
; 547  : 	// create a baseline for more efficient communications
; 548  : 	SV_CreateBaseline();

	call	_SV_CreateBaseline

; 549  : 
; 550  : 	// collect all info from precached resources
; 551  : 	SV_CreateResourceList();

	call	_SV_CreateResourceList

; 552  : 
; 553  : 	// check and count all files that marked by user as unmodified (typically is a player models etc)
; 554  : 	SV_TransferConsistencyInfo();

	call	_SV_TransferConsistencyInfo

; 555  : 
; 556  : 	// send serverinfo to all connected clients
; 557  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN7@SV_Activat
$LN5@SV_Activat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 287560				; 00046348H
	mov	DWORD PTR _cl$[ebp], edx
$LN7@SV_Activat:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_Activat

; 558  : 	{
; 559  : 		if( cl->state < cs_connected )

	mov	ecx, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [ecx], 2
	jge	SHORT $LN11@SV_Activat

; 560  : 			continue;

	jmp	SHORT $LN5@SV_Activat
$LN11@SV_Activat:

; 561  : 
; 562  : 		Netchan_Clear( &cl->netchan );

	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 560				; 00000230H
	push	edx
	call	_Netchan_Clear
	add	esp, 4

; 563  : 		cl->delta_sequence = -1;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264364], -1

; 564  : 	}

	jmp	SHORT $LN5@SV_Activat
$LN6@SV_Activat:

; 565  : 
; 566  : 	// invoke to refresh all movevars
; 567  : 	memset( &svgame.oldmovevars, 0, sizeof( movevars_t ));

	push	144					; 00000090H
	push	0
	push	OFFSET _svgame+8080
	call	_memset
	add	esp, 12					; 0000000cH

; 568  : 	svgame.globals->changelevel = false;

	mov	ecx, DWORD PTR _svgame+19236
	mov	DWORD PTR [ecx+136], 0

; 569  : 
; 570  : 	// setup hostflags
; 571  : 	sv.hostflags = 0;

	mov	DWORD PTR _sv+44, 0

; 572  : 
; 573  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 574  : 
; 575  : 	// tell what kind of server has been started.
; 576  : 	if( svs.maxclients > 1 )

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN12@SV_Activat

; 577  : 		Con_Printf( "%i player server started\n", svs.maxclients );

	mov	edx, DWORD PTR _svs+16
	push	edx
	push	OFFSET $SG136530
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN13@SV_Activat
$LN12@SV_Activat:

; 578  : 	else Con_Printf( "Game started\n" );

	push	OFFSET $SG136531
	call	_Con_Printf
	add	esp, 4
$LN13@SV_Activat:

; 579  : 
; 580  : 	Log_Printf( "Started map \"%s\" (CRC \"%i\")\n", sv.name, sv.worldmapCRC );

	mov	eax, DWORD PTR _sv+48
	push	eax
	push	OFFSET _sv+56
	push	OFFSET $SG136532
	call	_Log_Printf
	add	esp, 12					; 0000000cH

; 581  : 
; 582  : 	// dedicated server purge unused resources here
; 583  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN14@SV_Activat

; 584  : 		Mod_FreeUnused ();

	call	_Mod_FreeUnused
$LN14@SV_Activat:

; 585  : 
; 586  : 	host.movevars_changed = true;

	mov	DWORD PTR _host+34412, 1

; 587  : 	Host_SetServerState( ss_active );

	push	2
	call	_Host_SetServerState
	add	esp, 4

; 588  : 
; 589  : 	Con_DPrintf( "level loaded at %.2f sec\n", Sys_DoubleTime() - svs.timestart );

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv215[ebp]
	movsd	xmm0, QWORD PTR tv215[ebp]
	subsd	xmm0, QWORD PTR _svs+8
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG136534
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 590  : 
; 591  : 	if( sv.ignored_static_ents )

	cmp	DWORD PTR _sv+1359692, 0
	je	SHORT $LN15@SV_Activat

; 592  : 		Con_Printf( S_WARN "%i static entities was rejected due buffer overflow\n", sv.ignored_static_ents );

	mov	ecx, DWORD PTR _sv+1359692
	push	ecx
	push	OFFSET $SG136536
	call	_Con_Printf
	add	esp, 8
$LN15@SV_Activat:

; 593  : 
; 594  : 	if( sv.ignored_world_decals )

	cmp	DWORD PTR _sv+1359696, 0
	je	SHORT $LN16@SV_Activat

; 595  : 		Con_Printf( S_WARN "%i static decals was rejected due buffer overflow\n", sv.ignored_world_decals );

	mov	edx, DWORD PTR _sv+1359696
	push	edx
	push	OFFSET $SG136538
	call	_Con_Printf
	add	esp, 8
$LN16@SV_Activat:

; 596  : 
; 597  : 	if( svs.maxclients > 1 )

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN19@SV_Activat

; 598  : 	{
; 599  : 		const char *cycle = Cvar_VariableString( "mapchangecfgfile" );

	push	OFFSET $SG136540
	call	_Cvar_VariableString
	add	esp, 4
	mov	DWORD PTR _cycle$1[ebp], eax

; 600  : 
; 601  : 		if( COM_CheckString( cycle ))

	mov	eax, DWORD PTR _cycle$1[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@SV_Activat

; 602  : 			Cbuf_AddText( va( "exec %s\n", cycle ));

	mov	ecx, DWORD PTR _cycle$1[ebp]
	push	ecx
	push	OFFSET $SG136542
	call	_va
	add	esp, 8
	push	eax
	call	_Cbuf_AddText
	add	esp, 4
$LN18@SV_Activat:

; 603  : 
; 604  : 		if( public_server->value )

	mov	edx, DWORD PTR _public_server
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@SV_Activat

; 605  : 			Master_Add( );

	call	_Master_Add
$LN19@SV_Activat:

; 606  : 	}
; 607  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ActivateServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_InitGame PROC

; 656  : {

	push	ebp
	mov	ebp, esp

; 657  : 	if( svs.initialized )

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN2@SV_InitGam

; 658  : 		return true; // already initialized ?

	mov	eax, 1
	jmp	SHORT $LN1@SV_InitGam
$LN2@SV_InitGam:

; 659  : 
; 660  : 	// first initialize?
; 661  : 	if( !SV_LoadProgs( GI->game_dll ))

	mov	eax, DWORD PTR _SI+768
	add	eax, 516				; 00000204H
	push	eax
	call	_SV_LoadProgs
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@SV_InitGam

; 662  : 	{
; 663  : 		Con_Printf( S_ERROR "can't initialize %s\n", GI->game_dll );

	mov	ecx, DWORD PTR _SI+768
	add	ecx, 516				; 00000204H
	push	ecx
	push	OFFSET $SG136560
	call	_Con_Printf
	add	esp, 8

; 664  : 		return false; // failed to loading server.dll

	xor	eax, eax
	jmp	SHORT $LN1@SV_InitGam
$LN3@SV_InitGam:

; 665  : 	}
; 666  : 
; 667  : 	// client frames will be allocated in SV_ClientConnect
; 668  : 	svs.initialized = true;

	mov	DWORD PTR _svs, 1

; 669  : 
; 670  : 	return true;

	mov	eax, 1
$LN1@SV_InitGam:

; 671  : }

	pop	ebp
	ret	0
_SV_InitGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_SV_GenericIndex PROC

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 228  : 	char	name[MAX_QPATH];
; 229  : 	int	i;
; 230  : 
; 231  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_Generic

; 232  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_Generic
$LN5@SV_Generic:

; 233  : 
; 234  : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 235  : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 236  : 
; 237  : 	for( i = 1; i < MAX_CUSTOM && sv.files_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_Generic
$LN2@SV_Generic:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_Generic:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_Generic
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sv[edx+ecx+196804]
	test	edx, edx
	je	SHORT $LN3@SV_Generic

; 238  : 	{
; 239  : 		if( !Q_stricmp( sv.files_precache[i], name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+196804
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_Generic

; 240  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@SV_Generic
$LN6@SV_Generic:

; 241  : 	}

	jmp	SHORT $LN2@SV_Generic
$LN3@SV_Generic:

; 242  : 
; 243  : 	if( i == MAX_CUSTOM )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN7@SV_Generic

; 244  : 	{
; 245  : 		Host_Error( "MAX_CUSTOM limit exceeded (%d)\n", MAX_CUSTOM );

	push	1024					; 00000400H
	push	OFFSET $SG136400
	call	_Host_Error
	add	esp, 8

; 246  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_Generic
$LN7@SV_Generic:

; 247  : 	}
; 248  : 
; 249  : 	// register new generic resource
; 250  : 	Q_strncpy( sv.files_precache[i], name, sizeof( sv.files_precache[i] ));

	push	64					; 00000040H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+196804
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 251  : 
; 252  : 	if( sv.state != ss_loading )

	cmp	DWORD PTR _sv, 1
	je	SHORT $LN8@SV_Generic

; 253  : 	{
; 254  : 		// send the update to everyone
; 255  : 		SV_SendSingleResource( name, t_generic, i, RES_FATALIFMISSING );

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_SV_SendSingleResource
	add	esp, 16					; 00000010H
$LN8@SV_Generic:

; 256  : 	}
; 257  : 
; 258  : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@SV_Generic:

; 259  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GenericIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_SV_EventIndex PROC

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 186  : 	char	name[MAX_QPATH];
; 187  : 	int	i;
; 188  : 
; 189  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_EventIn

; 190  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_EventIn
$LN5@SV_EventIn:

; 191  : 
; 192  : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 193  : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 194  : 
; 195  : 	for( i = 1; i < MAX_EVENTS && sv.event_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_EventIn
$LN2@SV_EventIn:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SV_EventIn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_EventIn
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sv[edx+ecx+262340]
	test	edx, edx
	je	SHORT $LN3@SV_EventIn

; 196  : 	{
; 197  : 		if( !Q_stricmp( sv.event_precache[i], name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+262340
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_EventIn

; 198  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@SV_EventIn
$LN6@SV_EventIn:

; 199  : 	}

	jmp	SHORT $LN2@SV_EventIn
$LN3@SV_EventIn:

; 200  : 
; 201  : 	if( i == MAX_EVENTS )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN7@SV_EventIn

; 202  : 	{
; 203  : 		Host_Error( "MAX_EVENTS limit exceeded (%d)\n", MAX_EVENTS );

	push	1024					; 00000400H
	push	OFFSET $SG136387
	call	_Host_Error
	add	esp, 8

; 204  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_EventIn
$LN7@SV_EventIn:

; 205  : 	}
; 206  : 
; 207  : 	// register new event
; 208  : 	Q_strncpy( sv.event_precache[i], name, sizeof( sv.event_precache[i] ));

	push	64					; 00000040H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+262340
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 209  : 
; 210  : 	if( sv.state != ss_loading )

	cmp	DWORD PTR _sv, 1
	je	SHORT $LN8@SV_EventIn

; 211  : 	{
; 212  : 		// send the update to everyone
; 213  : 		SV_SendSingleResource( name, t_eventscript, i, RES_FATALIFMISSING );

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	5
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_SV_SendSingleResource
	add	esp, 16					; 00000010H
$LN8@SV_EventIn:

; 214  : 	}
; 215  : 
; 216  : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@SV_EventIn:

; 217  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EventIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_SV_SoundIndex PROC

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	char	name[MAX_QPATH];
; 136  : 	int	i;
; 137  : 
; 138  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_SoundIn

; 139  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_SoundIn
$LN5@SV_SoundIn:

; 140  : 
; 141  : 	if( filename[0] == '!' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN6@SV_SoundIn

; 142  : 	{
; 143  : 		Con_Printf( S_WARN "'%s' do not precache sentence names!\n", filename );

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG136368
	call	_Con_Printf
	add	esp, 8

; 144  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_SoundIn
$LN6@SV_SoundIn:

; 145  : 	}
; 146  : 
; 147  : 	if( *filename == '\\' || *filename == '/' )

	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN8@SV_SoundIn
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN7@SV_SoundIn
$LN8@SV_SoundIn:

; 148  : 		filename++;

	mov	ecx, DWORD PTR _filename$[ebp]
	add	ecx, 1
	mov	DWORD PTR _filename$[ebp], ecx
$LN7@SV_SoundIn:

; 149  : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 150  : 	COM_FixSlashes( name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_FixSlashes
	add	esp, 4

; 151  : 
; 152  : 	for( i = 1; i < MAX_SOUNDS && sv.sound_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_SoundIn
$LN2@SV_SoundIn:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SV_SoundIn:
	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jge	SHORT $LN3@SV_SoundIn
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+65732]
	test	eax, eax
	je	SHORT $LN3@SV_SoundIn

; 153  : 	{
; 154  : 		if( !Q_stricmp( sv.sound_precache[i], name ))

	push	99999					; 0001869fH
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+65732
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_SoundIn

; 155  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@SV_SoundIn
$LN9@SV_SoundIn:

; 156  : 	}

	jmp	SHORT $LN2@SV_SoundIn
$LN3@SV_SoundIn:

; 157  : 
; 158  : 	if( i == MAX_SOUNDS )

	cmp	DWORD PTR _i$[ebp], 2048		; 00000800H
	jne	SHORT $LN10@SV_SoundIn

; 159  : 	{
; 160  : 		Host_Error( "MAX_SOUNDS limit exceeded (%d)\n", MAX_SOUNDS );

	push	2048					; 00000800H
	push	OFFSET $SG136373
	call	_Host_Error
	add	esp, 8

; 161  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_SoundIn
$LN10@SV_SoundIn:

; 162  : 	}
; 163  : 
; 164  : 	// register new sound
; 165  : 	Q_strncpy( sv.sound_precache[i], name, sizeof( sv.sound_precache[i] ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _sv+65732
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 166  : 
; 167  : 	if( sv.state != ss_loading )

	cmp	DWORD PTR _sv, 1
	je	SHORT $LN11@SV_SoundIn

; 168  : 	{	
; 169  : 		// send the update to everyone
; 170  : 		SV_SendSingleResource( name, t_sound, i, 0 );

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_SV_SendSingleResource
	add	esp, 16					; 00000010H

; 171  : 		Con_Printf( S_WARN "late precache of %s\n", name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG136375
	call	_Con_Printf
	add	esp, 8
$LN11@SV_SoundIn:

; 172  : 	}
; 173  : 
; 174  : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@SV_SoundIn:

; 175  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SoundIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_SV_ModelIndex PROC

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 90   : 	char	name[MAX_QPATH];
; 91   : 	int	i;
; 92   : 
; 93   : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_ModelIn

; 94   : 		return 0;

	xor	eax, eax
	jmp	$LN1@SV_ModelIn
$LN5@SV_ModelIn:

; 95   : 
; 96   : 	if( *filename == '\\' || *filename == '/' )

	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN7@SV_ModelIn
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@SV_ModelIn
$LN7@SV_ModelIn:

; 97   : 		filename++;

	mov	edx, DWORD PTR _filename$[ebp]
	add	edx, 1
	mov	DWORD PTR _filename$[ebp], edx
$LN6@SV_ModelIn:

; 98   : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 99   : 	COM_FixSlashes( name );

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_COM_FixSlashes
	add	esp, 4

; 100  : 
; 101  : 	for( i = 1; i < MAX_MODELS && sv.model_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@SV_ModelIn
$LN2@SV_ModelIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ModelIn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_ModelIn
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _sv[ecx+eax+196]
	test	ecx, ecx
	je	SHORT $LN3@SV_ModelIn

; 102  : 	{
; 103  : 		if( !Q_stricmp( sv.model_precache[i], name ))

	push	99999					; 0001869fH
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+196
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_ModelIn

; 104  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@SV_ModelIn
$LN8@SV_ModelIn:

; 105  : 	}

	jmp	SHORT $LN2@SV_ModelIn
$LN3@SV_ModelIn:

; 106  : 
; 107  : 	if( i == MAX_MODELS )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN9@SV_ModelIn

; 108  : 	{
; 109  : 		Host_Error( "MAX_MODELS limit exceeded (%d)\n", MAX_MODELS );

	push	1024					; 00000400H
	push	OFFSET $SG136355
	call	_Host_Error
	add	esp, 8

; 110  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ModelIn
$LN9@SV_ModelIn:

; 111  : 	}
; 112  : 
; 113  : 	// register new model
; 114  : 	Q_strncpy( sv.model_precache[i], name, sizeof( sv.model_precache[i] ));

	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, OFFSET _sv+196
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 115  : 
; 116  : 	if( sv.state != ss_loading )

	cmp	DWORD PTR _sv, 1
	je	SHORT $LN10@SV_ModelIn

; 117  : 	{	
; 118  : 		// send the update to everyone
; 119  : 		SV_SendSingleResource( name, t_model, i, sv.model_precache_flags[i] );

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _sv[eax+327876]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	2
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_SV_SendSingleResource
	add	esp, 16					; 00000010H

; 120  : 		Con_Printf( S_WARN "late precache of %s\n", name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG136357
	call	_Con_Printf
	add	esp, 8
$LN10@SV_ModelIn:

; 121  : 	}
; 122  : 
; 123  : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN1@SV_ModelIn:

; 124  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ModelIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_FreeGameProgs PROC

; 912  : {

	push	ebp
	mov	ebp, esp

; 913  : 	if( svs.initialized ) return;	// server is active

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN2@SV_FreeGam
	jmp	SHORT $LN1@SV_FreeGam
$LN2@SV_FreeGam:

; 914  : 
; 915  : 	// unload progs (free cvars and commands)
; 916  : 	SV_UnloadProgs();

	call	_SV_UnloadProgs
$LN1@SV_FreeGam:

; 917  : }

	pop	ebp
	ret	0
_SV_FreeGameProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_InitGameProgs PROC

; 904  : {

	push	ebp
	mov	ebp, esp

; 905  : 	if( svgame.hInstance ) return; // already loaded

	cmp	DWORD PTR _svgame+7920, 0
	je	SHORT $LN2@SV_InitGam
	jmp	SHORT $LN1@SV_InitGam
$LN2@SV_InitGam:

; 906  : 
; 907  : 	// just try to initialize
; 908  : 	SV_LoadProgs( GI->game_dll );

	mov	eax, DWORD PTR _SI+768
	add	eax, 516				; 00000204H
	push	eax
	call	_SV_LoadProgs
	add	esp, 4
$LN1@SV_InitGam:

; 909  : }

	pop	ebp
	ret	0
_SV_InitGameProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_ExecChangeLevel PROC

; 960  : {

	push	ebp
	mov	ebp, esp

; 961  : 	SV_ChangeLevel( GameState->loadGame, GameState->levelName, GameState->landmarkName, GameState->backgroundMap );

	mov	eax, DWORD PTR _host+152
	push	eax
	push	OFFSET _host+88
	push	OFFSET _host+24
	mov	ecx, DWORD PTR _host+156
	push	ecx
	call	_SV_ChangeLevel
	add	esp, 16					; 00000010H

; 962  : }

	pop	ebp
	ret	0
_SV_ExecChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_ExecLoadGame PROC

; 943  : {

	push	ebp
	mov	ebp, esp

; 944  : 	if( SV_SpawnServer( GameState->levelName, NULL, false ))

	push	0
	push	0
	push	OFFSET _host+24
	call	_SV_SpawnServer
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@SV_ExecLoa

; 945  : 	{
; 946  : 		if( !SV_LoadGameState( GameState->levelName ))

	push	OFFSET _host+24
	call	_SV_LoadGameState
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@SV_ExecLoa

; 947  : 			SV_SpawnEntities( GameState->levelName );

	push	OFFSET _host+24
	call	_SV_SpawnEntities
	add	esp, 4
$LN3@SV_ExecLoa:

; 948  : 		SV_ActivateServer( false );

	push	0
	call	_SV_ActivateServer
	add	esp, 4
$LN1@SV_ExecLoa:

; 949  : 	}
; 950  : }

	pop	ebp
	ret	0
_SV_ExecLoadGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_ExecLoadLevel PROC

; 927  : {

	push	ebp
	mov	ebp, esp

; 928  : 	if( SV_SpawnServer( GameState->levelName, NULL, GameState->backgroundMap ))

	mov	eax, DWORD PTR _host+152
	push	eax
	push	0
	push	OFFSET _host+24
	call	_SV_SpawnServer
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@SV_ExecLoa

; 929  : 	{
; 930  : 		SV_SpawnEntities( GameState->levelName );

	push	OFFSET _host+24
	call	_SV_SpawnEntities
	add	esp, 4

; 931  : 		SV_ActivateServer( true );

	push	1
	call	_SV_ActivateServer
	add	esp, 4
$LN1@SV_ExecLoa:

; 932  : 	}
; 933  : }

	pop	ebp
	ret	0
_SV_ExecLoadLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_ShutdownGame PROC

; 681  : {

	push	ebp
	mov	ebp, esp

; 682  : 	if( !GameState->loadGame )

	cmp	DWORD PTR _host+156, 0
	jne	SHORT $LN2@SV_Shutdow

; 683  : 		SV_ClearGameState();

	call	_SV_ClearGameState
$LN2@SV_Shutdow:

; 684  : 
; 685  : 	SV_FinalMessage( "", true );

	push	1
	push	OFFSET $SG136564
	call	_SV_FinalMessage
	add	esp, 8

; 686  : 	S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 687  : 	CL_StopPlayback(); // stop demo too

	call	_CL_StopPlayback

; 688  : 
; 689  : 	if( GameState->newGame )

	cmp	DWORD PTR _host+160, 0
	je	SHORT $LN3@SV_Shutdow

; 690  : 	{
; 691  : 		Host_EndGame( false, DEFAULT_ENDGAME_MESSAGE );

	push	OFFSET $SG136567
	push	0
	call	_Host_EndGame
	add	esp, 8

; 692  : 	}

	jmp	SHORT $LN1@SV_Shutdow
$LN3@SV_Shutdow:

; 693  : 	else
; 694  : 	{
; 695  : 		S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 696  : 		SV_DeactivateServer();

	call	_SV_DeactivateServer
$LN1@SV_Shutdow:

; 697  : 	}
; 698  : }

	pop	ebp
	ret	0
_SV_ShutdownGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_Initialized PROC

; 894  : {

	push	ebp
	mov	ebp, esp

; 895  : 	return svs.initialized;

	mov	eax, DWORD PTR _svs

; 896  : }

	pop	ebp
	ret	0
_SV_Initialized ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
_SV_GetMaxClients PROC

; 899  : {

	push	ebp
	mov	ebp, esp

; 900  : 	return svs.maxclients;

	mov	eax, DWORD PTR _svs+16

; 901  : }

	pop	ebp
	ret	0
_SV_GetMaxClients ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_init.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_SV_Active PROC

; 889  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 890  : 	return (sv.state != ss_dead);

	cmp	DWORD PTR _sv, 0
	je	SHORT $LN3@SV_Active
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@SV_Active
$LN3@SV_Active:
	mov	DWORD PTR tv65[ebp], 0
$LN4@SV_Active:
	mov	eax, DWORD PTR tv65[ebp]

; 891  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Active ENDP
_TEXT	ENDS
END
