; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\xash_build4529_src\engine\common\cmd.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_cmd_wait:DWORD
COMM	_cmd_text:BYTE:0cH
COMM	_cmd_text_buf:BYTE:08000H
COMM	_cmd_alias:DWORD
COMM	_cmd_condition:DWORD
COMM	_cmd_condlevel:DWORD
_DATA	ENDS
PUBLIC	_Cbuf_Init
PUBLIC	_Cbuf_Clear
PUBLIC	_Cbuf_AddText
PUBLIC	_Cbuf_InsertText
PUBLIC	_Cbuf_ExecStuffCmds
PUBLIC	_Cbuf_Execute
PUBLIC	_Cmd_Argc
PUBLIC	_Cmd_Args
PUBLIC	_Cmd_Argv
PUBLIC	_Cmd_Init
PUBLIC	_Cmd_Unlink
PUBLIC	_Cmd_AddCommand
PUBLIC	_Cmd_AddServerCommand
PUBLIC	_Cmd_AddClientCommand
PUBLIC	_Cmd_AddGameUICommand
PUBLIC	_Cmd_RemoveCommand
PUBLIC	_Cmd_Exists
PUBLIC	_Cmd_LookupCmds
PUBLIC	_Cmd_TokenizeString
PUBLIC	_Cmd_ExecuteString
PUBLIC	_Cmd_ForwardToServer
PUBLIC	_Cmd_Null_f
PUBLIC	_Cbuf_GetSpace
PUBLIC	_Cmd_StuffCmds_f
PUBLIC	_Cmd_Wait_f
PUBLIC	_Cmd_Echo_f
PUBLIC	_Cmd_Alias_f
PUBLIC	_Cmd_If_f
PUBLIC	_Cmd_Else_f
PUBLIC	_Cmd_List_f
PUBLIC	__real@00000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_stricmpext:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_Cvar_Command:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_cmd_scripting:DWORD
EXTRN	_host:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_cmd_argc DD	01H DUP (?)
_cmd_args DD	01H DUP (?)
_cmd_argv DD	050H DUP (?)
_cmd_functions DD 01H DUP (?)
$SG139865 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
$SG139686 DB	'Cbuf_GetSpace: overflow', 0aH, 00H
	ORG $+3
$SG139693 DB	'^3Warning:^7 Cbuf_AddText: overflow', 0aH, 00H
	ORG $+3
$SG139700 DB	'^3Warning:^7 Cbuf_InsertText: overflow', 0aH, 00H
$SG139731 DB	'^1Error:^7 Cbuf_Execute: command string owerflow', 0aH, 00H
	ORG $+2
$SG139764 DB	'stuffcmds', 00H
	ORG $+2
$SG139778 DB	'%s', 00H
	ORG $+1
$SG139779 DB	0aH, 00H
	ORG $+2
$SG139807 DB	'Current alias commands:', 0aH, 00H
	ORG $+3
$SG139808 DB	'^2%s^7 : ^3%s^7', 0aH, 00H
	ORG $+3
$SG139810 DB	'Alias name is too long', 0aH, 00H
$SG139813 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139815 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139819 DB	' ', 00H
	ORG $+2
$SG139820 DB	0aH, 00H
	ORG $+2
$SG139821 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139837 DB	'Usage: unalias alias1 [alias2 ...]', 0aH, 00H
$SG139841 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139842 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139844 DB	'%s not found', 0aH, 00H
	ORG $+2
$SG139884 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139893 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139910 DB	'^1Error:^7 Cmd_AddCommand: %s already defined as a var', 0aH
	DB	00H
$SG139912 DB	'^1Error:^7 Cmd_AddCommand: %s already defined', 0aH, 00H
	ORG $+1
$SG139913 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139914 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139915 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139933 DB	'^1Error:^7 Cmd_AddServerCommand: %s already defined as a'
	DB	' var', 0aH, 00H
	ORG $+2
$SG139935 DB	'^1Error:^7 Cmd_AddServerCommand: %s already defined', 0aH
	DB	00H
	ORG $+3
$SG139936 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139937 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139938 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139939 DB	'server command', 00H
	ORG $+1
$SG139957 DB	'^1Error:^7 Cmd_AddClientCommand: %s already defined as a'
	DB	' var', 0aH, 00H
	ORG $+2
$SG139959 DB	'^1Error:^7 Cmd_AddClientCommand: %s already defined', 0aH
	DB	00H
	ORG $+3
$SG139960 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139961 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139962 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139963 DB	'client command', 00H
	ORG $+1
$SG139981 DB	'^1Error:^7 Cmd_AddGameUICommand: %s already defined as a'
	DB	' var', 0aH, 00H
	ORG $+2
$SG139983 DB	'^1Error:^7 Cmd_AddGameUICommand: %s already defined', 0aH
	DB	00H
	ORG $+3
$SG139984 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139985 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139986 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG139987 DB	'GameUI command', 00H
	ORG $+1
$SG140002 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG140004 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG140005 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG140040 DB	'Usage: if <op1> [ <operator> <op2> ]', 0aH, 00H
	ORG $+2
$SG140041 DB	':<action1>', 0aH, 00H
$SG140042 DB	':<action2>', 0aH, 00H
$SG140043 DB	'else', 0aH, 00H
	ORG $+2
$SG140044 DB	':<action3>', 0aH, 00H
$SG140045 DB	'operands are string or float values', 0aH, 00H
	ORG $+3
$SG140046 DB	'and substituted cvars like ''$cl_lw''', 0aH, 00H
	ORG $+3
$SG140047 DB	'operator is ''='''', ''=='', ''>'', ''<'', ''>='', ''<='''
	DB	' or ''!=''', 0aH, 00H
	ORG $+2
$SG140102 DB	'exec', 00H
	ORG $+3
$SG140110 DB	'host_gameloaded', 00H
$SG140111 DB	'^3Warning:^7 Unknown command "%s"', 0aH, 00H
	ORG $+1
$SG140119 DB	'pause', 00H
	ORG $+2
$SG140123 DB	'setinfo', 00H
$SG140124 DB	'Can''t "%s", not connected', 0aH, 00H
	ORG $+1
$SG140126 DB	'cmd', 00H
$SG140127 DB	' ', 00H
	ORG $+2
$SG140130 DB	0aH, 00H
	ORG $+2
$SG140145 DB	' %-*s ^3%s^7', 0aH, 00H
	ORG $+2
$SG140146 DB	'%i commands', 0aH, 00H
	ORG $+3
$SG140156 DB	'host_gameloaded', 00H
$SG140158 DB	'host_clientloaded', 00H
	ORG $+2
$SG140160 DB	'host_gameuiloaded', 00H
	ORG $+2
$SG140164 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG140166 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG140167 DB	'c:\users\user\downloads\xash_build4529_src\engine\common'
	DB	'\cmd.c', 00H
	ORG $+1
$SG140168 DB	'unlink %i commands', 0aH, 00H
$SG140176 DB	'print a message to the console (useful in scripts)', 00H
	ORG $+1
$SG140177 DB	'echo', 00H
	ORG $+3
$SG140178 DB	'make script execution wait for some rendered frames', 00H
$SG140179 DB	'wait', 00H
	ORG $+3
$SG140181 DB	'cmdlist', 00H
$SG140183 DB	'stuffcmds', 00H
	ORG $+2
$SG140180 DB	'display all console commands beginning with the specifie'
	DB	'd prefix', 00H
	ORG $+3
$SG140182 DB	'execute commandline parameters (must be present in .rc s'
	DB	'cript)', 00H
	ORG $+1
$SG140184 DB	'send a console commandline to the server', 00H
	ORG $+3
$SG140185 DB	'cmd', 00H
$SG140188 DB	'remove a script function', 00H
	ORG $+3
$SG140186 DB	'create a script function. Without arguments show the lis'
	DB	't of all alias', 00H
	ORG $+1
$SG140187 DB	'alias', 00H
	ORG $+2
$SG140189 DB	'unalias', 00H
$SG140190 DB	'compare and set condition bits', 00H
	ORG $+1
$SG140191 DB	'if', 00H
	ORG $+1
$SG140192 DB	'invert condition bit', 00H
	ORG $+3
$SG140193 DB	'else', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_i$ = -12						; size = 4
_match$ = -8						; size = 4
_cmd$ = -4						; size = 4
_Cmd_List_f PROC

; 1035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1036 : 	cmd_t	*cmd;
; 1037 : 	int	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1038 : 	char	*match;
; 1039 : 
; 1040 : 	if( Cmd_Argc() > 1 ) match = Cmd_Argv( 1 );

	call	_Cmd_Argc
	cmp	eax, 1
	jbe	SHORT $LN5@Cmd_List_f
	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _match$[ebp], eax
	jmp	SHORT $LN6@Cmd_List_f
$LN5@Cmd_List_f:

; 1041 : 	else match = NULL;

	mov	DWORD PTR _match$[ebp], 0
$LN6@Cmd_List_f:

; 1042 : 
; 1043 : 	for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN4@Cmd_List_f
$LN2@Cmd_List_f:
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cmd$[ebp], edx
$LN4@Cmd_List_f:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN3@Cmd_List_f

; 1044 : 	{
; 1045 : 		if( cmd->name[0] == '@' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN7@Cmd_List_f

; 1046 : 			continue;	// never show system cmds

	jmp	SHORT $LN2@Cmd_List_f
$LN7@Cmd_List_f:

; 1047 : 
; 1048 : 		if( match && !Q_stricmpext( match, cmd->name ))

	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN8@Cmd_List_f
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _match$[ebp]
	push	ecx
	call	_Q_stricmpext
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@Cmd_List_f

; 1049 : 			continue;

	jmp	SHORT $LN2@Cmd_List_f
$LN8@Cmd_List_f:

; 1050 : 
; 1051 : 		Con_Printf( " %-*s ^3%s^7\n", 32, cmd->name, cmd->desc );

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	32					; 00000020H
	push	OFFSET $SG140145
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 1052 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1053 : 	}

	jmp	SHORT $LN2@Cmd_List_f
$LN3@Cmd_List_f:

; 1054 : 
; 1055 : 	Con_Printf( "%i commands\n", i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET $SG140146
	call	_Con_Printf
	add	esp, 8

; 1056 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_List_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_Else_f PROC

; 870  : {

	push	ebp
	mov	ebp, esp

; 871  : 	cmd_condition ^= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	xor	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax

; 872  : }

	pop	ebp
	ret	0
_Cmd_Else_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
tv197 = -12						; size = 4
_f1$1 = -8						; size = 4
_f2$2 = -4						; size = 4
_Cmd_If_f PROC

; 809  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 810  : 	// reset bit first
; 811  : 	cmd_condition &= ~BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax

; 812  : 
; 813  : 	// usage
; 814  : 	if( cmd_argc == 1 )

	cmp	DWORD PTR _cmd_argc, 1
	jne	SHORT $LN2@Cmd_If_f

; 815  : 	{
; 816  : 		Con_Printf( S_USAGE "if <op1> [ <operator> <op2> ]\n");

	push	OFFSET $SG140040
	call	_Con_Printf
	add	esp, 4

; 817  : 		Con_Printf( ":<action1>\n" );

	push	OFFSET $SG140041
	call	_Con_Printf
	add	esp, 4

; 818  : 		Con_Printf( ":<action2>\n" );

	push	OFFSET $SG140042
	call	_Con_Printf
	add	esp, 4

; 819  : 		Con_Printf( "else\n" );

	push	OFFSET $SG140043
	call	_Con_Printf
	add	esp, 4

; 820  : 		Con_Printf( ":<action3>\n" );

	push	OFFSET $SG140044
	call	_Con_Printf
	add	esp, 4

; 821  : 		Con_Printf( "operands are string or float values\n" );

	push	OFFSET $SG140045
	call	_Con_Printf
	add	esp, 4

; 822  : 		Con_Printf( "and substituted cvars like '$cl_lw'\n" );

	push	OFFSET $SG140046
	call	_Con_Printf
	add	esp, 4

; 823  : 		Con_Printf( "operator is '='', '==', '>', '<', '>=', '<=' or '!='\n" );

	push	OFFSET $SG140047
	call	_Con_Printf
	add	esp, 4

; 824  : 		return;

	jmp	$LN15@Cmd_If_f
$LN2@Cmd_If_f:

; 825  : 	}
; 826  : 
; 827  : 	// one argument - check if nonzero
; 828  : 	if( cmd_argc == 2 )

	cmp	DWORD PTR _cmd_argc, 2
	jne	SHORT $LN3@Cmd_If_f

; 829  : 	{
; 830  : 		if( Q_atof( cmd_argv[1] ))

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv197[ebp]
	movss	xmm0, DWORD PTR tv197[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@Cmd_If_f

; 831  : 			cmd_condition |= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	or	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax
$LN5@Cmd_If_f:

; 832  : 	}

	jmp	$LN15@Cmd_If_f
$LN3@Cmd_If_f:

; 833  : 	else if( cmd_argc == 4 )

	cmp	DWORD PTR _cmd_argc, 4
	jne	$LN15@Cmd_If_f

; 834  : 	{
; 835  : 		// simple compare
; 836  : 		float	f1 = Q_atof( cmd_argv[1] );

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR _f1$1[ebp]

; 837  : 		float	f2 = Q_atof( cmd_argv[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR _f2$2[ebp]

; 838  : 
; 839  : 		if( !cmd_argv[2][0] ) // this is wrong

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN7@Cmd_If_f

; 840  : 			return;

	jmp	$LN15@Cmd_If_f
$LN7@Cmd_If_f:

; 841  : 
; 842  : 		if(( cmd_argv[2][0] == '=' ) || ( cmd_argv[2][1] == '=' )) // =, ==, >=, <=

	mov	edx, 4
	shl	edx, 1
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cmd_argv[edx]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN9@Cmd_If_f
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cmd_argv[ecx]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 61					; 0000003dH
	jne	SHORT $LN10@Cmd_If_f
$LN9@Cmd_If_f:

; 843  : 		{
; 844  : 			if( !Q_strcmp( cmd_argv[1], cmd_argv[3] ) || (( f1 || f2 ) && ( f1 == f2 )))

	push	99999					; 0001869fH
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _cmd_argv[eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cmd_argv[edx]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_If_f
	movss	xmm0, DWORD PTR _f1$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@Cmd_If_f
	movss	xmm0, DWORD PTR _f2$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@Cmd_If_f
$LN12@Cmd_If_f:
	movss	xmm0, DWORD PTR _f1$1[ebp]
	ucomiss	xmm0, DWORD PTR _f2$2[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@Cmd_If_f
$LN11@Cmd_If_f:

; 845  : 				cmd_condition |= BIT( cmd_condlevel );

	mov	edx, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	edx, cl
	or	edx, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, edx
$LN10@Cmd_If_f:

; 846  : 		}
; 847  : 
; 848  : 		if( cmd_argv[2][0] == '!' ) 					// !=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN13@Cmd_If_f

; 849  : 		{
; 850  : 			cmd_condition ^= BIT( cmd_condlevel );

	mov	edx, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	edx, cl
	xor	edx, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, edx

; 851  : 			return;

	jmp	$LN15@Cmd_If_f
$LN13@Cmd_If_f:

; 852  : 		}
; 853  : 
; 854  : 		if(( cmd_argv[2][0] == '>' ) && ( f1 > f2 )) // >, >=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN14@Cmd_If_f
	movss	xmm0, DWORD PTR _f1$1[ebp]
	comiss	xmm0, DWORD PTR _f2$2[ebp]
	jbe	SHORT $LN14@Cmd_If_f

; 855  : 			cmd_condition |= BIT( cmd_condlevel );

	mov	edx, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	edx, cl
	or	edx, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, edx
$LN14@Cmd_If_f:

; 856  : 		
; 857  : 		if(( cmd_argv[2][0] == '<' ) && ( f1 < f2 )) // <, <=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN15@Cmd_If_f
	movss	xmm0, DWORD PTR _f2$2[ebp]
	comiss	xmm0, DWORD PTR _f1$1[ebp]
	jbe	SHORT $LN15@Cmd_If_f

; 858  : 			cmd_condition |= BIT( cmd_condlevel );

	mov	edx, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	edx, cl
	or	edx, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, edx
$LN15@Cmd_If_f:

; 859  : 	}
; 860  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_If_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_s$ = -16						; size = 4
_p$ = -12						; size = 4
_i$ = -8						; size = 4
_a$ = -4						; size = 4
_Cmd_UnAlias_f PROC

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 415  : 	cmdalias_t	*a, *p;
; 416  : 	const char	*s;
; 417  : 	int		i;
; 418  : 
; 419  : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN8@Cmd_UnAlia

; 420  : 	{
; 421  : 		Con_Printf( S_USAGE "unalias alias1 [alias2 ...]\n" );

	push	OFFSET $SG139837
	call	_Con_Printf
	add	esp, 4

; 422  : 		return;

	jmp	$LN1@Cmd_UnAlia
$LN8@Cmd_UnAlia:

; 423  : 	}
; 424  : 
; 425  : 	for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Cmd_UnAlia
$LN2@Cmd_UnAlia:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_UnAlia:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN1@Cmd_UnAlia

; 426  : 	{
; 427  : 		s = Cmd_Argv( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 428  : 		p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 429  : 
; 430  : 		for( a = cmd_alias; a; p = a, a = a->next )

	mov	edx, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], edx
	jmp	SHORT $LN7@Cmd_UnAlia
$LN5@Cmd_UnAlia:
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _a$[ebp], edx
$LN7@Cmd_UnAlia:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN6@Cmd_UnAlia

; 431  : 		{
; 432  : 			if( !Q_strcmp( s, a->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Cmd_UnAlia

; 433  : 			{
; 434  : 				if( a == cmd_alias )

	mov	edx, DWORD PTR _a$[ebp]
	cmp	edx, DWORD PTR _cmd_alias
	jne	SHORT $LN10@Cmd_UnAlia

; 435  : 					cmd_alias = a->next;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd_alias, ecx
$LN10@Cmd_UnAlia:

; 436  : 				if( p ) p->next = a->next;

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN11@Cmd_UnAlia
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
$LN11@Cmd_UnAlia:

; 437  : 				Mem_Free( a->value );

	push	437					; 000001b5H
	push	OFFSET $SG139841
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 438  : 				Mem_Free( a );

	push	438					; 000001b6H
	push	OFFSET $SG139842
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 439  : 				break;

	jmp	SHORT $LN6@Cmd_UnAlia
$LN9@Cmd_UnAlia:

; 440  : 			}
; 441  : 		}

	jmp	$LN5@Cmd_UnAlia
$LN6@Cmd_UnAlia:

; 442  : 
; 443  : 		if( !a ) Con_Printf( "%s not found\n", s );

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $LN12@Cmd_UnAlia
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET $SG139844
	call	_Con_Printf
	add	esp, 8
$LN12@Cmd_UnAlia:

; 444  : 	}

	jmp	$LN2@Cmd_UnAlia
$LN1@Cmd_UnAlia:

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_UnAlias_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_c$ = -2080						; size = 4
$T1 = -2076						; size = 4
_prev$2 = -2072						; size = 4
_s$ = -2068						; size = 4
_i$ = -2064						; size = 4
_cur$3 = -2060						; size = 4
_a$ = -2056						; size = 4
_cmd$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_Cmd_Alias_f PROC

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2080				; 00000820H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 344  : 	cmdalias_t	*a;
; 345  : 	char		cmd[MAX_CMD_LINE];
; 346  : 	int		i, c;
; 347  : 	char		*s;
; 348  : 
; 349  : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN14@Cmd_Alias_

; 350  : 	{
; 351  : 		Con_Printf( "Current alias commands:\n" );

	push	OFFSET $SG139807
	call	_Con_Printf
	add	esp, 4

; 352  : 		for( a = cmd_alias; a; a = a->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN4@Cmd_Alias_
$LN2@Cmd_Alias_:
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _a$[ebp], edx
$LN4@Cmd_Alias_:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN3@Cmd_Alias_

; 353  : 			Con_Printf( "^2%s^7 : ^3%s^7\n", a->name, a->value );

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 4
	push	edx
	push	OFFSET $SG139808
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Cmd_Alias_
$LN3@Cmd_Alias_:

; 354  : 		return;

	jmp	$LN22@Cmd_Alias_
$LN14@Cmd_Alias_:

; 355  : 	}
; 356  : 
; 357  : 	s = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 358  : 
; 359  : 	if( Q_strlen( s ) >= MAX_ALIAS_NAME )

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN15@Cmd_Alias_

; 360  : 	{
; 361  : 		Con_Printf( "Alias name is too long\n" );

	push	OFFSET $SG139810
	call	_Con_Printf
	add	esp, 4

; 362  : 		return;

	jmp	$LN22@Cmd_Alias_
$LN15@Cmd_Alias_:

; 363  : 	}
; 364  : 
; 365  : 	// if the alias already exists, reuse it
; 366  : 	for( a = cmd_alias; a; a = a->next )

	mov	ecx, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], ecx
	jmp	SHORT $LN7@Cmd_Alias_
$LN5@Cmd_Alias_:
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _a$[ebp], eax
$LN7@Cmd_Alias_:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN6@Cmd_Alias_

; 367  : 	{
; 368  : 		if( !Q_strcmp( s, a->name ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Cmd_Alias_

; 369  : 		{
; 370  : 			Z_Free( a->value );

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN17@Cmd_Alias_
	push	370					; 00000172H
	push	OFFSET $SG139813
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN17@Cmd_Alias_:

; 371  : 			break;

	jmp	SHORT $LN6@Cmd_Alias_
$LN16@Cmd_Alias_:

; 372  : 		}
; 373  : 	}

	jmp	SHORT $LN5@Cmd_Alias_
$LN6@Cmd_Alias_:

; 374  : 
; 375  : 	if( !a )

	cmp	DWORD PTR _a$[ebp], 0
	jne	$LN18@Cmd_Alias_

; 376  : 	{
; 377  : 		cmdalias_t	*cur, *prev;
; 378  : 
; 379  : 		a = Z_Malloc( sizeof( cmdalias_t ));

	push	379					; 0000017bH
	push	OFFSET $SG139815
	push	0
	push	40					; 00000028H
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _a$[ebp], eax

; 380  : 
; 381  : 		Q_strncpy( a->name, s, sizeof( a->name ));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 4
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 382  : 
; 383  : 		// insert it at the right alphanumeric position
; 384  : 		for( prev = NULL, cur = cmd_alias; cur && Q_strcmp( cur->name, a->name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$2[ebp], 0
	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _cur$3[ebp], eax
	jmp	SHORT $LN10@Cmd_Alias_
$LN8@Cmd_Alias_:
	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	DWORD PTR _prev$2[ebp], ecx
	mov	edx, DWORD PTR _cur$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$3[ebp], eax
$LN10@Cmd_Alias_:
	cmp	DWORD PTR _cur$3[ebp], 0
	je	SHORT $LN9@Cmd_Alias_
	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _cur$3[ebp]
	add	edx, 4
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN9@Cmd_Alias_
	jmp	SHORT $LN8@Cmd_Alias_
$LN9@Cmd_Alias_:

; 385  : 
; 386  : 		if( prev ) prev->next = a;

	cmp	DWORD PTR _prev$2[ebp], 0
	je	SHORT $LN19@Cmd_Alias_
	mov	eax, DWORD PTR _prev$2[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN20@Cmd_Alias_
$LN19@Cmd_Alias_:

; 387  : 		else cmd_alias = a;

	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR _cmd_alias, edx
$LN20@Cmd_Alias_:

; 388  : 		a->next = cur;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN18@Cmd_Alias_:

; 389  : 	}
; 390  : 
; 391  : 	// copy the rest of the command line
; 392  : 	cmd[0] = 0; // start out with a null string

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN23@Cmd_Alias_
	jmp	SHORT $LN24@Cmd_Alias_
$LN23@Cmd_Alias_:
	call	___report_rangecheckfailure
$LN24@Cmd_Alias_:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cmd$[ebp+ecx], 0

; 393  : 
; 394  : 	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 395  : 
; 396  : 	for( i = 2; i < c; i++ )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN13@Cmd_Alias_
$LN11@Cmd_Alias_:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@Cmd_Alias_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	SHORT $LN12@Cmd_Alias_

; 397  : 	{
; 398  : 		if( i != 2 ) Q_strncat( cmd, " ", sizeof( cmd ));

	cmp	DWORD PTR _i$[ebp], 2
	je	SHORT $LN21@Cmd_Alias_
	push	2048					; 00000800H
	push	OFFSET $SG139819
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN21@Cmd_Alias_:

; 399  : 		Q_strncat( cmd, Cmd_Argv( i ), sizeof( cmd ));

	push	2048					; 00000800H
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 400  : 	}

	jmp	SHORT $LN11@Cmd_Alias_
$LN12@Cmd_Alias_:

; 401  : 
; 402  : 	Q_strncat( cmd, "\n", sizeof( cmd ));

	push	2048					; 00000800H
	push	OFFSET $SG139820
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 403  : 	a->value = copystring( cmd );

	push	403					; 00000193H
	push	OFFSET $SG139821
	lea	edx, DWORD PTR _cmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN22@Cmd_Alias_:

; 404  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Alias_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Cmd_Echo_f PROC

; 327  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 328  : 	int	i;
; 329  : 	
; 330  : 	for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Cmd_Echo_f
$LN2@Cmd_Echo_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_Echo_f:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@Cmd_Echo_f

; 331  : 		Con_Printf( "%s", Cmd_Argv( i ));

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG139778
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN2@Cmd_Echo_f
$LN3@Cmd_Echo_f:

; 332  : 	Con_Printf( "\n" );

	push	OFFSET $SG139779
	call	_Con_Printf
	add	esp, 4

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Echo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_Wait_f PROC

; 315  : {

	push	ebp
	mov	ebp, esp

; 316  : 	cmd_wait = true;

	mov	DWORD PTR _cmd_wait, 1

; 317  : }

	pop	ebp
	ret	0
_Cmd_Wait_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_StuffCmds_f PROC

; 301  : {

	push	ebp
	mov	ebp, esp

; 302  : 	host.stuffcmds_pending = true;

	mov	DWORD PTR _host+34348, 1

; 303  : }

	pop	ebp
	ret	0
_Cmd_StuffCmds_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_data$ = -4						; size = 4
_buf$ = 8						; size = 4
_length$ = 12						; size = 4
_Cbuf_GetSpace PROC

; 81   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 82   : 	void    *data;
; 83   : 	
; 84   : 	if(( buf->cursize + length ) > buf->maxsize )

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	jle	SHORT $LN2@Cbuf_GetSp

; 85   : 	{
; 86   : 		buf->cursize = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		Host_Error( "Cbuf_GetSpace: overflow\n" );

	push	OFFSET $SG139686
	call	_Host_Error
	add	esp, 4
$LN2@Cbuf_GetSp:

; 88   : 	}
; 89   : 
; 90   : 	data = buf->data + buf->cursize;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _data$[ebp], edx

; 91   : 	buf->cursize += length;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+4], edx

; 92   : 	
; 93   : 	return data;

	mov	eax, DWORD PTR _data$[ebp]

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_GetSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_Null_f PROC

; 1114 : {

	push	ebp
	mov	ebp, esp

; 1115 : }

	pop	ebp
	ret	0
_Cmd_Null_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
$T1 = -32776						; size = 4
_str$ = -32772						; size = 32768
__$ArrayPad$ = -4					; size = 4
_Cmd_ForwardToServer PROC

; 996  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 32776				; 00008008H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 997  : 	char	str[MAX_CMD_BUFFER];
; 998  : 	
; 999  : 	if( cls.demoplayback )

	cmp	DWORD PTR _cls+297580, 0
	je	SHORT $LN2@Cmd_Forwar

; 1000 : 	{
; 1001 : 		if( !Q_stricmp( Cmd_Argv( 0 ), "pause" ))

	push	99999					; 0001869fH
	push	OFFSET $SG140119
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Cmd_Forwar

; 1002 : 			cl.paused ^= 1;

	mov	eax, DWORD PTR _cl+24
	xor	eax, 1
	mov	DWORD PTR _cl+24, eax
$LN3@Cmd_Forwar:

; 1003 : 		return;

	jmp	$LN10@Cmd_Forwar
$LN2@Cmd_Forwar:

; 1004 : 	}
; 1005 : 
; 1006 : 	if( cls.state < ca_connected || cls.state > ca_active )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN5@Cmd_Forwar
	cmp	DWORD PTR _cls, 4
	jle	SHORT $LN4@Cmd_Forwar
$LN5@Cmd_Forwar:

; 1007 : 	{
; 1008 : 		if( Q_stricmp( Cmd_Argv( 0 ), "setinfo" ))

	push	99999					; 0001869fH
	push	OFFSET $SG140123
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@Cmd_Forwar

; 1009 : 			Con_Printf( "Can't \"%s\", not connected\n", Cmd_Argv( 0 ));

	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET $SG140124
	call	_Con_Printf
	add	esp, 8
$LN6@Cmd_Forwar:

; 1010 : 		return; // not connected

	jmp	$LN10@Cmd_Forwar
$LN4@Cmd_Forwar:

; 1011 : 	}
; 1012 : 
; 1013 : 	MSG_BeginClientCmd( &cls.netchan.message, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+23620
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1014 : 
; 1015 : 	str[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 32768		; 00008000H
	jae	SHORT $LN11@Cmd_Forwar
	jmp	SHORT $LN12@Cmd_Forwar
$LN11@Cmd_Forwar:
	call	___report_rangecheckfailure
$LN12@Cmd_Forwar:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _str$[ebp+eax], 0

; 1016 : 	if( Q_stricmp( Cmd_Argv( 0 ), "cmd" ))

	push	99999					; 0001869fH
	push	OFFSET $SG140126
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@Cmd_Forwar

; 1017 : 	{
; 1018 : 		Q_strcat( str, Cmd_Argv( 0 ));

	push	99999					; 0001869fH
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1019 : 		Q_strcat( str, " " );

	push	99999					; 0001869fH
	push	OFFSET $SG140127
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN7@Cmd_Forwar:

; 1020 : 	}
; 1021 : 	
; 1022 : 	if( Cmd_Argc() > 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jbe	SHORT $LN8@Cmd_Forwar

; 1023 : 		Q_strcat( str, Cmd_Args( ));

	push	99999					; 0001869fH
	call	_Cmd_Args
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Cmd_Forwar
$LN8@Cmd_Forwar:

; 1024 : 	else Q_strcat( str, "\n" );

	push	99999					; 0001869fH
	push	OFFSET $SG140130
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN9@Cmd_Forwar:

; 1025 : 
; 1026 : 	MSG_WriteString( &cls.netchan.message, str );

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	push	OFFSET _cls+23620
	call	_MSG_WriteString
	add	esp, 8
$LN10@Cmd_Forwar:

; 1027 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_ForwardToServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_ptoken$1 = -4120					; size = 4
_a$ = -4116						; size = 4
_cmd$ = -4112						; size = 4
_pcmd$ = -4108						; size = 4
_len$ = -4104						; size = 4
_token$2 = -4100					; size = 2048
_command$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_Cmd_ExecuteString PROC

; 882  : {	

	push	ebp
	mov	ebp, esp
	mov	eax, 4120				; 00001018H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 883  : 	cmd_t		*cmd;
; 884  : 	cmdalias_t	*a;
; 885  : 	char		command[MAX_CMD_LINE];
; 886  : 	char		*pcmd = command;

	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR _pcmd$[ebp], eax

; 887  : 	int		len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 888  : 
; 889  : 	cmd_condlevel = 0;

	mov	DWORD PTR _cmd_condlevel, 0

; 890  : 
; 891  : 	// cvar value substitution
; 892  : 	if( cmd_scripting && cmd_scripting->value )

	cmp	DWORD PTR _cmd_scripting, 0
	je	$LN7@Cmd_Execut
	mov	ecx, DWORD PTR _cmd_scripting
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN7@Cmd_Execut
$LN2@Cmd_Execut:

; 893  : 	{
; 894  : 		while( *text )

	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@Cmd_Execut

; 895  : 		{
; 896  : 			// check for escape
; 897  : 			if(( *text == '\\' || *text == '$' ) && (*( text + 1 ) == '$' ))

	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN17@Cmd_Execut
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN15@Cmd_Execut
$LN17@Cmd_Execut:
	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN15@Cmd_Execut

; 898  : 			{
; 899  : 				text ++;

	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx

; 900  : 			}

	jmp	$LN23@Cmd_Execut
$LN15@Cmd_Execut:

; 901  : 			else if( *text == '$' )

	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	jne	$LN23@Cmd_Execut

; 902  : 			{
; 903  : 				char	token[MAX_CMD_LINE];
; 904  : 				char	*ptoken = token;

	lea	ecx, DWORD PTR _token$2[ebp]
	mov	DWORD PTR _ptoken$1[ebp], ecx

; 905  : 
; 906  : 				// check for correct cvar name
; 907  : 				text++;

	mov	edx, DWORD PTR _text$[ebp]
	add	edx, 1
	mov	DWORD PTR _text$[ebp], edx
$LN4@Cmd_Execut:

; 908  : 				while(( *text >= '0' && *text <= '9' ) || ( *text >= 'A' && *text <= 'Z' ) || ( *text >= 'a' && *text <= 'z' ) || ( *text == '_' ))

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN20@Cmd_Execut
	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN19@Cmd_Execut
$LN20@Cmd_Execut:
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN21@Cmd_Execut
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	SHORT $LN19@Cmd_Execut
$LN21@Cmd_Execut:
	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN22@Cmd_Execut
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	SHORT $LN19@Cmd_Execut
$LN22@Cmd_Execut:
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	jne	SHORT $LN5@Cmd_Execut
$LN19@Cmd_Execut:

; 909  : 					*ptoken++ = *text++;

	mov	edx, DWORD PTR _ptoken$1[ebp]
	mov	eax, DWORD PTR _text$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _ptoken$1[ebp]
	add	edx, 1
	mov	DWORD PTR _ptoken$1[ebp], edx
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
	jmp	SHORT $LN4@Cmd_Execut
$LN5@Cmd_Execut:

; 910  : 				*ptoken = 0;

	mov	ecx, DWORD PTR _ptoken$1[ebp]
	mov	BYTE PTR [ecx], 0

; 911  : 
; 912  : 				len += Q_strncpy( pcmd, Cvar_VariableString( token ), MAX_CMD_LINE - len );

	mov	edx, 2048				; 00000800H
	sub	edx, DWORD PTR _len$[ebp]
	push	edx
	lea	eax, DWORD PTR _token$2[ebp]
	push	eax
	call	_Cvar_VariableString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pcmd$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 913  : 				pcmd = command + len;

	mov	edx, DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR _command$[ebp+edx]
	mov	DWORD PTR _pcmd$[ebp], eax

; 914  : 
; 915  : 				if( !*text ) break;

	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN23@Cmd_Execut
	jmp	SHORT $LN3@Cmd_Execut
$LN23@Cmd_Execut:

; 916  : 			}
; 917  : 
; 918  : 			*pcmd++ = *text++;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 1
	mov	DWORD PTR _pcmd$[ebp], eax
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx

; 919  : 			len++;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 920  : 		}

	jmp	$LN2@Cmd_Execut
$LN3@Cmd_Execut:

; 921  : 
; 922  : 		*pcmd = 0;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	BYTE PTR [eax], 0

; 923  : 		text = command;

	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR _text$[ebp], ecx
$LN6@Cmd_Execut:

; 924  : 
; 925  : 		while( *text == ':' )

	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN7@Cmd_Execut

; 926  : 		{
; 927  : 			if( !FBitSet( cmd_condition, BIT( cmd_condlevel )))

	mov	edx, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	edx, cl
	and	edx, DWORD PTR _cmd_condition
	jne	SHORT $LN24@Cmd_Execut

; 928  : 				return;

	jmp	$LN36@Cmd_Execut
$LN24@Cmd_Execut:

; 929  : 			cmd_condlevel++;

	mov	eax, DWORD PTR _cmd_condlevel
	add	eax, 1
	mov	DWORD PTR _cmd_condlevel, eax

; 930  : 			text++;

	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx

; 931  : 		}

	jmp	SHORT $LN6@Cmd_Execut
$LN7@Cmd_Execut:

; 932  : 	}
; 933  : 
; 934  : 	// execute the command line
; 935  : 	Cmd_TokenizeString( text );		

	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_Cmd_TokenizeString
	add	esp, 4

; 936  : 
; 937  : 	if( !Cmd_Argc( )) return; // no tokens

	call	_Cmd_Argc
	test	eax, eax
	jne	SHORT $LN25@Cmd_Execut
	jmp	$LN36@Cmd_Execut
$LN25@Cmd_Execut:

; 938  : 
; 939  : 	if( !host.apply_game_config )

	cmp	DWORD PTR _host+34388, 0
	jne	SHORT $LN9@Cmd_Execut

; 940  : 	{
; 941  : 		// check aliases
; 942  : 		for( a = cmd_alias; a; a = a->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN10@Cmd_Execut
$LN8@Cmd_Execut:
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _a$[ebp], edx
$LN10@Cmd_Execut:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN9@Cmd_Execut

; 943  : 		{
; 944  : 			if( !Q_stricmp( cmd_argv[0], a->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[edx]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@Cmd_Execut

; 945  : 			{
; 946  : 				Cbuf_InsertText( a->value );

	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_Cbuf_InsertText
	add	esp, 4

; 947  : 				return;

	jmp	$LN36@Cmd_Execut
$LN27@Cmd_Execut:

; 948  : 			}
; 949  : 		}

	jmp	SHORT $LN8@Cmd_Execut
$LN9@Cmd_Execut:

; 950  : 	}
; 951  : 
; 952  : 	// special mode for restore game.dll archived cvars
; 953  : 	if( !host.apply_game_config || !Q_strcmp( cmd_argv[0], "exec" ))

	cmp	DWORD PTR _host+34388, 0
	je	SHORT $LN29@Cmd_Execut
	push	99999					; 0001869fH
	push	OFFSET $SG140102
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@Cmd_Execut
$LN29@Cmd_Execut:

; 954  : 	{
; 955  : 		// check functions
; 956  : 		for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN13@Cmd_Execut
$LN11@Cmd_Execut:
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cmd$[ebp], edx
$LN13@Cmd_Execut:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN12@Cmd_Execut

; 957  : 		{
; 958  : 			if( !Q_stricmp( cmd_argv[0], cmd->name ) && cmd->function )

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cmd_argv[eax]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@Cmd_Execut
	mov	edx, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN30@Cmd_Execut

; 959  : 			{
; 960  : 				cmd->function();

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx

; 961  : 				return;

	jmp	SHORT $LN36@Cmd_Execut
$LN30@Cmd_Execut:

; 962  : 			}
; 963  : 		}

	jmp	SHORT $LN11@Cmd_Execut
$LN12@Cmd_Execut:

; 964  : 	}
; 965  : 
; 966  : 	// check cvars
; 967  : 	if( Cvar_Command( )) return;

	call	_Cvar_Command
	test	eax, eax
	je	SHORT $LN31@Cmd_Execut
	jmp	SHORT $LN36@Cmd_Execut
$LN31@Cmd_Execut:

; 968  : 
; 969  : 	if( host.apply_game_config )

	cmp	DWORD PTR _host+34388, 0
	je	SHORT $LN32@Cmd_Execut

; 970  : 		return; // don't send nothing to server: we is a server!

	jmp	SHORT $LN36@Cmd_Execut
$LN32@Cmd_Execut:

; 971  : 
; 972  : 	// forward the command line to the server, so the entity DLL can parse it
; 973  : 	if( host.type == HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN36@Cmd_Execut

; 974  : 	{
; 975  : 		if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN34@Cmd_Execut

; 976  : 		{
; 977  : 			Cmd_ForwardToServer();

	call	_Cmd_ForwardToServer

; 978  : 		}

	jmp	SHORT $LN36@Cmd_Execut
$LN34@Cmd_Execut:

; 979  : 		else if( Cvar_VariableInteger( "host_gameloaded" ))

	push	OFFSET $SG140110
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@Cmd_Execut

; 980  : 		{
; 981  : 			Con_Printf( S_WARN "Unknown command \"%s\"\n", text );

	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	push	OFFSET $SG140111
	call	_Con_Printf
	add	esp, 8
$LN36@Cmd_Execut:

; 982  : 		}
; 983  : 	}
; 984  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_ExecuteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_i$ = -32776						; size = 4
_cmd_token$ = -32772					; size = 32768
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_Cmd_TokenizeString PROC

; 512  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 32776				; 00008008H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 513  : 	char	cmd_token[MAX_CMD_BUFFER];
; 514  : 	int	i;
; 515  : 
; 516  : 	// clear the args from the last string
; 517  : 	for( i = 0; i < cmd_argc; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Cmd_Tokeni
$LN2@Cmd_Tokeni:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_Tokeni:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cmd_argc
	jge	SHORT $LN3@Cmd_Tokeni

; 518  : 		Z_Free( cmd_argv[i] );

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _cmd_argv[edx*4], 0
	je	SHORT $LN9@Cmd_Tokeni
	push	518					; 00000206H
	push	OFFSET $SG139884
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cmd_argv[eax*4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@Cmd_Tokeni:
	jmp	SHORT $LN2@Cmd_Tokeni
$LN3@Cmd_Tokeni:

; 519  : 
; 520  : 	cmd_argc = 0; // clear previous args

	mov	DWORD PTR _cmd_argc, 0

; 521  : 	cmd_args = NULL;

	mov	DWORD PTR _cmd_args, 0

; 522  : 
; 523  : 	if( !text ) return;

	cmp	DWORD PTR _text$[ebp], 0
	jne	SHORT $LN5@Cmd_Tokeni
	jmp	$LN1@Cmd_Tokeni
$LN5@Cmd_Tokeni:

; 524  : 
; 525  : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN1@Cmd_Tokeni
$LN7@Cmd_Tokeni:

; 526  : 	{
; 527  : 		// skip whitespace up to a /n
; 528  : 		while( *text && ((byte)*text) <= ' ' && *text != '\r' && *text != '\n' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@Cmd_Tokeni
	mov	edx, DWORD PTR _text$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN8@Cmd_Tokeni
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN8@Cmd_Tokeni
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN8@Cmd_Tokeni

; 529  : 			text++;

	mov	edx, DWORD PTR _text$[ebp]
	add	edx, 1
	mov	DWORD PTR _text$[ebp], edx
	jmp	SHORT $LN7@Cmd_Tokeni
$LN8@Cmd_Tokeni:

; 530  : 
; 531  : 		if( *text == '\n' || *text == '\r' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN12@Cmd_Tokeni
	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN11@Cmd_Tokeni
$LN12@Cmd_Tokeni:

; 532  : 		{
; 533  : 			// a newline seperates commands in the buffer
; 534  : 			if( *text == '\r' && text[1] == '\n' )

	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN13@Cmd_Tokeni
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN13@Cmd_Tokeni

; 535  : 				text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
$LN13@Cmd_Tokeni:

; 536  : 			text++;

	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx

; 537  : 			break;

	jmp	$LN1@Cmd_Tokeni
$LN11@Cmd_Tokeni:

; 538  : 		}
; 539  : 
; 540  : 		if( !*text )

	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN14@Cmd_Tokeni

; 541  : 			return;

	jmp	$LN1@Cmd_Tokeni
$LN14@Cmd_Tokeni:

; 542  : 
; 543  : 		if( cmd_argc == 1 )

	cmp	DWORD PTR _cmd_argc, 1
	jne	SHORT $LN15@Cmd_Tokeni

; 544  : 			 cmd_args = text;

	mov	ecx, DWORD PTR _text$[ebp]
	mov	DWORD PTR _cmd_args, ecx
$LN15@Cmd_Tokeni:

; 545  : 
; 546  : 		host.com_ignorebracket = true;

	mov	DWORD PTR _host+34364, 1

; 547  : 		text = COM_ParseFile( text, cmd_token );

	lea	edx, DWORD PTR _cmd_token$[ebp]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _text$[ebp], eax

; 548  : 		host.com_ignorebracket = false;

	mov	DWORD PTR _host+34364, 0

; 549  : 
; 550  : 		if( !text ) return;

	cmp	DWORD PTR _text$[ebp], 0
	jne	SHORT $LN16@Cmd_Tokeni
	jmp	SHORT $LN1@Cmd_Tokeni
$LN16@Cmd_Tokeni:

; 551  : 
; 552  : 		if( cmd_argc < MAX_CMD_TOKENS )

	cmp	DWORD PTR _cmd_argc, 80			; 00000050H
	jge	SHORT $LN17@Cmd_Tokeni

; 553  : 		{
; 554  : 			cmd_argv[cmd_argc] = copystring( cmd_token );

	push	554					; 0000022aH
	push	OFFSET $SG139893
	lea	ecx, DWORD PTR _cmd_token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd_argc
	mov	DWORD PTR _cmd_argv[ecx*4], eax

; 555  : 			cmd_argc++;

	mov	edx, DWORD PTR _cmd_argc
	add	edx, 1
	mov	DWORD PTR _cmd_argc, edx
$LN17@Cmd_Tokeni:

; 556  : 		}
; 557  : 	}

	jmp	$LN5@Cmd_Tokeni
$LN1@Cmd_Tokeni:

; 558  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_TokenizeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_alias$ = -8						; size = 4
_cmd$ = -4						; size = 4
_buffer$ = 8						; size = 4
_ptr$ = 12						; size = 4
_callback$ = 16						; size = 4
_Cmd_LookupCmds PROC

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 767  : 	cmd_t	*cmd;
; 768  : 	cmdalias_t	*alias;
; 769  : 
; 770  : 	// nothing to process ?
; 771  : 	if( !callback ) return;

	cmp	DWORD PTR _callback$[ebp], 0
	jne	SHORT $LN8@Cmd_Lookup
	jmp	$LN1@Cmd_Lookup
$LN8@Cmd_Lookup:

; 772  : 	
; 773  : 	for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN4@Cmd_Lookup
$LN2@Cmd_Lookup:
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cmd$[ebp], edx
$LN4@Cmd_Lookup:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN3@Cmd_Lookup

; 774  : 	{
; 775  : 		if( !buffer ) callback( cmd->name, (char *)cmd->function, cmd->desc, ptr );

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN9@Cmd_Lookup
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@Cmd_Lookup
$LN9@Cmd_Lookup:

; 776  : 		else callback( cmd->name, (char *)cmd->function, buffer, ptr );

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
$LN10@Cmd_Lookup:

; 777  : 	}

	jmp	SHORT $LN2@Cmd_Lookup
$LN3@Cmd_Lookup:

; 778  : 
; 779  : 	// lookup an aliases too
; 780  : 	for( alias = cmd_alias; alias; alias = alias->next )

	mov	ecx, DWORD PTR _cmd_alias
	mov	DWORD PTR _alias$[ebp], ecx
	jmp	SHORT $LN7@Cmd_Lookup
$LN5@Cmd_Lookup:
	mov	edx, DWORD PTR _alias$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _alias$[ebp], eax
$LN7@Cmd_Lookup:
	cmp	DWORD PTR _alias$[ebp], 0
	je	SHORT $LN1@Cmd_Lookup

; 781  : 		callback( alias->name, alias->value, buffer, ptr );

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _alias$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _alias$[ebp]
	add	edx, 4
	push	edx
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@Cmd_Lookup
$LN1@Cmd_Lookup:

; 782  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_LookupCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_Cmd_Exists PROC

; 790  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 791  : 	cmd_t	*cmd;
; 792  : 
; 793  : 	for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN4@Cmd_Exists
$LN2@Cmd_Exists:
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cmd$[ebp], edx
$LN4@Cmd_Exists:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN3@Cmd_Exists

; 794  : 	{
; 795  : 		if( !Q_strcmp( cmd_name, cmd->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@Cmd_Exists

; 796  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Cmd_Exists
$LN5@Cmd_Exists:

; 797  : 	}

	jmp	SHORT $LN2@Cmd_Exists
$LN3@Cmd_Exists:

; 798  : 	return false;

	xor	eax, eax
$LN1@Cmd_Exists:

; 799  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Exists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_back$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_Cmd_RemoveCommand PROC

; 731  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 732  : 	cmd_t	*cmd, **back;
; 733  : 
; 734  : 	if( !cmd_name || !*cmd_name )

	cmp	DWORD PTR _cmd_name$[ebp], 0
	je	SHORT $LN5@Cmd_Remove
	mov	eax, DWORD PTR _cmd_name$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@Cmd_Remove
$LN5@Cmd_Remove:

; 735  : 		return;

	jmp	$LN1@Cmd_Remove
$LN4@Cmd_Remove:

; 736  : 
; 737  : 	back = &cmd_functions;

	mov	DWORD PTR _back$[ebp], OFFSET _cmd_functions
$LN2@Cmd_Remove:

; 738  : 	while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN1@Cmd_Remove

; 739  : 	{
; 740  : 		cmd = *back;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx

; 741  : 		if( !cmd ) return;

	cmp	DWORD PTR _cmd$[ebp], 0
	jne	SHORT $LN6@Cmd_Remove
	jmp	$LN1@Cmd_Remove
$LN6@Cmd_Remove:

; 742  : 
; 743  : 		if( !Q_strcmp( cmd_name, cmd->name ))

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@Cmd_Remove

; 744  : 		{
; 745  : 			*back = cmd->next;

	mov	edx, DWORD PTR _back$[ebp]
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 746  : 
; 747  : 			if( cmd->name )

	mov	edx, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN8@Cmd_Remove

; 748  : 				Mem_Free( cmd->name );

	push	748					; 000002ecH
	push	OFFSET $SG140002
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@Cmd_Remove:

; 749  : 
; 750  : 			if( cmd->desc )

	mov	edx, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN9@Cmd_Remove

; 751  : 				Mem_Free( cmd->desc );

	push	751					; 000002efH
	push	OFFSET $SG140004
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@Cmd_Remove:

; 752  : 
; 753  : 			Mem_Free( cmd );

	push	753					; 000002f1H
	push	OFFSET $SG140005
	mov	edx, DWORD PTR _cmd$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 754  : 			return;

	jmp	SHORT $LN1@Cmd_Remove
$LN7@Cmd_Remove:

; 755  : 		}
; 756  : 		back = &cmd->next;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _back$[ebp], eax

; 757  : 	}

	jmp	$LN2@Cmd_Remove
$LN1@Cmd_Remove:

; 758  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_RemoveCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_Cmd_AddGameUICommand PROC

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 689  : 	cmd_t	*cmd, *cur, *prev;
; 690  : 
; 691  : 	if( !COM_CheckString( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Cmd_AddGam

; 692  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddGam
$LN5@Cmd_AddGam:

; 693  : 
; 694  : 	// fail if the command is a variable name
; 695  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Cmd_AddGam

; 696  : 	{
; 697  : 		Con_DPrintf( S_ERROR "Cmd_AddGameUICommand: %s already defined as a var\n", cmd_name );

	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	push	OFFSET $SG139981
	call	_Con_DPrintf
	add	esp, 8

; 698  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddGam
$LN6@Cmd_AddGam:

; 699  : 	}
; 700  : 	
; 701  : 	// fail if the command already exists
; 702  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@Cmd_AddGam

; 703  : 	{
; 704  : 		Con_DPrintf( S_ERROR "Cmd_AddGameUICommand: %s already defined\n", cmd_name );

	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	push	OFFSET $SG139983
	call	_Con_DPrintf
	add	esp, 8

; 705  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddGam
$LN7@Cmd_AddGam:

; 706  : 	}
; 707  : 
; 708  : 	// use a small malloc to avoid zone fragmentation
; 709  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	push	709					; 000002c5H
	push	OFFSET $SG139984
	push	0
	push	20					; 00000014H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 710  : 	cmd->name = copystring( cmd_name );

	push	710					; 000002c6H
	push	OFFSET $SG139985
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+4], eax

; 711  : 	cmd->desc = copystring( "GameUI command" );

	push	711					; 000002c7H
	push	OFFSET $SG139986
	push	OFFSET $SG139987
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 712  : 	cmd->function = function;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR _function$[ebp]
	mov	DWORD PTR [edx+8], eax

; 713  : 	cmd->flags = CMD_GAMEUIDLL;

	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+16], 4

; 714  : 
; 715  : 	// insert it at the right alphanumeric position
; 716  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	edx, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@Cmd_AddGam
$LN2@Cmd_AddGam:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddGam:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddGam
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddGam
	jmp	SHORT $LN2@Cmd_AddGam
$LN3@Cmd_AddGam:

; 717  : 
; 718  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN8@Cmd_AddGam
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN9@Cmd_AddGam
$LN8@Cmd_AddGam:

; 719  : 	else cmd_functions = cmd;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, edx
$LN9@Cmd_AddGam:

; 720  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 721  : 
; 722  : 	return 1;

	mov	eax, 1
$LN1@Cmd_AddGam:

; 723  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddGameUICommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_Cmd_AddClientCommand PROC

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 646  : 	cmd_t	*cmd, *cur, *prev;
; 647  : 
; 648  : 	if( !COM_CheckString( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Cmd_AddCli

; 649  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddCli
$LN5@Cmd_AddCli:

; 650  : 
; 651  : 	// fail if the command is a variable name
; 652  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Cmd_AddCli

; 653  : 	{
; 654  : 		Con_DPrintf( S_ERROR "Cmd_AddClientCommand: %s already defined as a var\n", cmd_name );

	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	push	OFFSET $SG139957
	call	_Con_DPrintf
	add	esp, 8

; 655  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddCli
$LN6@Cmd_AddCli:

; 656  : 	}
; 657  : 	
; 658  : 	// fail if the command already exists
; 659  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@Cmd_AddCli

; 660  : 	{
; 661  : 		Con_DPrintf( S_ERROR "Cmd_AddClientCommand: %s already defined\n", cmd_name );

	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	push	OFFSET $SG139959
	call	_Con_DPrintf
	add	esp, 8

; 662  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddCli
$LN7@Cmd_AddCli:

; 663  : 	}
; 664  : 
; 665  : 	// use a small malloc to avoid zone fragmentation
; 666  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	push	666					; 0000029aH
	push	OFFSET $SG139960
	push	0
	push	20					; 00000014H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 667  : 	cmd->name = copystring( cmd_name );

	push	667					; 0000029bH
	push	OFFSET $SG139961
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+4], eax

; 668  : 	cmd->desc = copystring( "client command" );

	push	668					; 0000029cH
	push	OFFSET $SG139962
	push	OFFSET $SG139963
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 669  : 	cmd->function = function;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR _function$[ebp]
	mov	DWORD PTR [edx+8], eax

; 670  : 	cmd->flags = CMD_CLIENTDLL;

	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+16], 2

; 671  : 
; 672  : 	// insert it at the right alphanumeric position
; 673  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	edx, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@Cmd_AddCli
$LN2@Cmd_AddCli:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddCli:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddCli
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddCli
	jmp	SHORT $LN2@Cmd_AddCli
$LN3@Cmd_AddCli:

; 674  : 
; 675  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN8@Cmd_AddCli
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN9@Cmd_AddCli
$LN8@Cmd_AddCli:

; 676  : 	else cmd_functions = cmd;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, edx
$LN9@Cmd_AddCli:

; 677  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 678  : 
; 679  : 	return 1;

	mov	eax, 1
$LN1@Cmd_AddCli:

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddClientCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_Cmd_AddServerCommand PROC

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 605  : 	cmd_t	*cmd, *cur, *prev;
; 606  : 
; 607  : 	if( !COM_CheckString( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Cmd_AddSer

; 608  : 		return;

	jmp	$LN1@Cmd_AddSer
$LN5@Cmd_AddSer:

; 609  : 
; 610  : 	// fail if the command is a variable name
; 611  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Cmd_AddSer

; 612  : 	{
; 613  : 		Con_DPrintf( S_ERROR "Cmd_AddServerCommand: %s already defined as a var\n", cmd_name );

	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	push	OFFSET $SG139933
	call	_Con_DPrintf
	add	esp, 8

; 614  : 		return;

	jmp	$LN1@Cmd_AddSer
$LN6@Cmd_AddSer:

; 615  : 	}
; 616  : 	
; 617  : 	// fail if the command already exists
; 618  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@Cmd_AddSer

; 619  : 	{
; 620  : 		Con_DPrintf( S_ERROR "Cmd_AddServerCommand: %s already defined\n", cmd_name );

	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	push	OFFSET $SG139935
	call	_Con_DPrintf
	add	esp, 8

; 621  : 		return;

	jmp	$LN1@Cmd_AddSer
$LN7@Cmd_AddSer:

; 622  : 	}
; 623  : 
; 624  : 	// use a small malloc to avoid zone fragmentation
; 625  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	push	625					; 00000271H
	push	OFFSET $SG139936
	push	0
	push	20					; 00000014H
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 626  : 	cmd->name = copystring( cmd_name );

	push	626					; 00000272H
	push	OFFSET $SG139937
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+4], eax

; 627  : 	cmd->desc = copystring( "server command" );

	push	627					; 00000273H
	push	OFFSET $SG139938
	push	OFFSET $SG139939
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 628  : 	cmd->function = function;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR _function$[ebp]
	mov	DWORD PTR [edx+8], eax

; 629  : 	cmd->flags = CMD_SERVERDLL;

	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+16], 1

; 630  : 
; 631  : 	// insert it at the right alphanumeric position
; 632  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	edx, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@Cmd_AddSer
$LN2@Cmd_AddSer:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddSer:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddSer
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddSer
	jmp	SHORT $LN2@Cmd_AddSer
$LN3@Cmd_AddSer:

; 633  : 
; 634  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN8@Cmd_AddSer
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN9@Cmd_AddSer
$LN8@Cmd_AddSer:

; 635  : 	else cmd_functions = cmd;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, edx
$LN9@Cmd_AddSer:

; 636  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Cmd_AddSer:

; 637  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddServerCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_cmd_desc$ = 16						; size = 4
_Cmd_AddCommand PROC

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 567  : 	cmd_t	*cmd, *cur, *prev;
; 568  : 
; 569  : 	// fail if the command is a variable name
; 570  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@Cmd_AddCom

; 571  : 	{
; 572  : 		Con_Printf( S_ERROR "Cmd_AddCommand: %s already defined as a var\n", cmd_name );

	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	push	OFFSET $SG139910
	call	_Con_Printf
	add	esp, 8

; 573  : 		return;

	jmp	$LN1@Cmd_AddCom
$LN5@Cmd_AddCom:

; 574  : 	}
; 575  : 	
; 576  : 	// fail if the command already exists
; 577  : 	if( Cmd_Exists( cmd_name ))

	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@Cmd_AddCom

; 578  : 	{
; 579  : 		Con_Printf( S_ERROR "Cmd_AddCommand: %s already defined\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET $SG139912
	call	_Con_Printf
	add	esp, 8

; 580  : 		return;

	jmp	$LN1@Cmd_AddCom
$LN6@Cmd_AddCom:

; 581  : 	}
; 582  : 
; 583  : 	// use a small malloc to avoid zone fragmentation
; 584  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	push	584					; 00000248H
	push	OFFSET $SG139913
	push	0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 585  : 	cmd->name = copystring( cmd_name );

	push	585					; 00000249H
	push	OFFSET $SG139914
	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 586  : 	cmd->desc = copystring( cmd_desc );

	push	586					; 0000024aH
	push	OFFSET $SG139915
	mov	edx, DWORD PTR _cmd_desc$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 587  : 	cmd->function = function;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR _function$[ebp]
	mov	DWORD PTR [edx+8], eax

; 588  : 	cmd->flags = 0;

	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 589  : 
; 590  : 	// insert it at the right alphanumeric position
; 591  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	edx, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@Cmd_AddCom
$LN2@Cmd_AddCom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddCom:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddCom
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddCom
	jmp	SHORT $LN2@Cmd_AddCom
$LN3@Cmd_AddCom:

; 592  : 
; 593  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN7@Cmd_AddCom
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN8@Cmd_AddCom
$LN7@Cmd_AddCom:

; 594  : 	else cmd_functions = cmd;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, edx
$LN8@Cmd_AddCom:

; 595  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Cmd_AddCom:

; 596  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
_prev$ = -8						; size = 4
_cmd$ = -4						; size = 4
_group$ = 8						; size = 4
_Cmd_Unlink PROC

; 1066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1067 : 	cmd_t	*cmd;
; 1068 : 	cmd_t	**prev;
; 1069 : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1070 : 
; 1071 : 	if( Cvar_VariableInteger( "host_gameloaded" ) && FBitSet( group, CMD_SERVERDLL ))

	push	OFFSET $SG140156
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Cmd_Unlink
	mov	eax, DWORD PTR _group$[ebp]
	and	eax, 1
	je	SHORT $LN4@Cmd_Unlink

; 1072 : 		return;

	jmp	$LN1@Cmd_Unlink
$LN4@Cmd_Unlink:

; 1073 : 
; 1074 : 	if( Cvar_VariableInteger( "host_clientloaded" ) && FBitSet( group, CMD_CLIENTDLL ))

	push	OFFSET $SG140158
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@Cmd_Unlink
	mov	ecx, DWORD PTR _group$[ebp]
	and	ecx, 2
	je	SHORT $LN5@Cmd_Unlink

; 1075 : 		return;

	jmp	$LN1@Cmd_Unlink
$LN5@Cmd_Unlink:

; 1076 : 
; 1077 : 	if( Cvar_VariableInteger( "host_gameuiloaded" ) && FBitSet( group, CMD_GAMEUIDLL ))

	push	OFFSET $SG140160
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@Cmd_Unlink
	mov	edx, DWORD PTR _group$[ebp]
	and	edx, 4
	je	SHORT $LN6@Cmd_Unlink

; 1078 : 		return;

	jmp	$LN1@Cmd_Unlink
$LN6@Cmd_Unlink:

; 1079 : 
; 1080 : 	prev = &cmd_functions;

	mov	DWORD PTR _prev$[ebp], OFFSET _cmd_functions
$LN2@Cmd_Unlink:

; 1081 : 
; 1082 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Cmd_Unlink

; 1083 : 	{
; 1084 : 		cmd = *prev;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cmd$[ebp], edx

; 1085 : 		if( !cmd ) break;

	cmp	DWORD PTR _cmd$[ebp], 0
	jne	SHORT $LN7@Cmd_Unlink
	jmp	$LN3@Cmd_Unlink
$LN7@Cmd_Unlink:

; 1086 : 
; 1087 : 		// do filter by specified group
; 1088 : 		if( group && !FBitSet( cmd->flags, group ))

	cmp	DWORD PTR _group$[ebp], 0
	je	SHORT $LN8@Cmd_Unlink
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, DWORD PTR _group$[ebp]
	jne	SHORT $LN8@Cmd_Unlink

; 1089 : 		{
; 1090 : 			prev = &cmd->next;

	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 1091 : 			continue;

	jmp	SHORT $LN2@Cmd_Unlink
$LN8@Cmd_Unlink:

; 1092 : 		}
; 1093 : 
; 1094 : 		*prev = cmd->next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1095 : 
; 1096 : 		if( cmd->name ) Mem_Free( cmd->name );

	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN9@Cmd_Unlink
	push	1096					; 00000448H
	push	OFFSET $SG140164
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@Cmd_Unlink:

; 1097 : 		if( cmd->desc ) Mem_Free( cmd->desc );

	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN10@Cmd_Unlink
	push	1097					; 00000449H
	push	OFFSET $SG140166
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN10@Cmd_Unlink:

; 1098 : 
; 1099 : 		Mem_Free( cmd );

	push	1099					; 0000044bH
	push	OFFSET $SG140167
	mov	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1100 : 		count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 1101 : 	}

	jmp	$LN2@Cmd_Unlink
$LN3@Cmd_Unlink:

; 1102 : 
; 1103 : 	Con_Reportf( "unlink %i commands\n", count );

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	push	OFFSET $SG140168
	call	_Con_Reportf
	add	esp, 8
$LN1@Cmd_Unlink:

; 1104 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Unlink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_Init PROC

; 1123 : {

	push	ebp
	mov	ebp, esp

; 1124 : 	Cbuf_Init();

	call	_Cbuf_Init

; 1125 : 
; 1126 : 	cmd_functions = NULL;

	mov	DWORD PTR _cmd_functions, 0

; 1127 : 	cmd_condition = 0;

	mov	DWORD PTR _cmd_condition, 0

; 1128 : 	cmd_alias = NULL;

	mov	DWORD PTR _cmd_alias, 0

; 1129 : 	cmd_args = NULL;

	mov	DWORD PTR _cmd_args, 0

; 1130 : 	cmd_argc = 0;

	mov	DWORD PTR _cmd_argc, 0

; 1131 : 
; 1132 : 	// register our commands
; 1133 : 	Cmd_AddCommand( "echo", Cmd_Echo_f, "print a message to the console (useful in scripts)" );

	push	OFFSET $SG140176
	push	OFFSET _Cmd_Echo_f
	push	OFFSET $SG140177
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1134 : 	Cmd_AddCommand( "wait", Cmd_Wait_f, "make script execution wait for some rendered frames" );

	push	OFFSET $SG140178
	push	OFFSET _Cmd_Wait_f
	push	OFFSET $SG140179
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1135 : 	Cmd_AddCommand( "cmdlist", Cmd_List_f, "display all console commands beginning with the specified prefix" );

	push	OFFSET $SG140180
	push	OFFSET _Cmd_List_f
	push	OFFSET $SG140181
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1136 : 	Cmd_AddCommand( "stuffcmds", Cmd_StuffCmds_f, "execute commandline parameters (must be present in .rc script)" );

	push	OFFSET $SG140182
	push	OFFSET _Cmd_StuffCmds_f
	push	OFFSET $SG140183
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1137 : 	Cmd_AddCommand( "cmd", Cmd_ForwardToServer, "send a console commandline to the server" );

	push	OFFSET $SG140184
	push	OFFSET _Cmd_ForwardToServer
	push	OFFSET $SG140185
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1138 : 	Cmd_AddCommand( "alias", Cmd_Alias_f, "create a script function. Without arguments show the list of all alias" );

	push	OFFSET $SG140186
	push	OFFSET _Cmd_Alias_f
	push	OFFSET $SG140187
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1139 : 	Cmd_AddCommand( "unalias", Cmd_UnAlias_f, "remove a script function" );

	push	OFFSET $SG140188
	push	OFFSET _Cmd_UnAlias_f
	push	OFFSET $SG140189
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1140 : 	Cmd_AddCommand( "if", Cmd_If_f, "compare and set condition bits" );

	push	OFFSET $SG140190
	push	OFFSET _Cmd_If_f
	push	OFFSET $SG140191
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1141 : 	Cmd_AddCommand( "else", Cmd_Else_f, "invert condition bit" );

	push	OFFSET $SG140192
	push	OFFSET _Cmd_Else_f
	push	OFFSET $SG140193
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1142 : }

	pop	ebp
	ret	0
_Cmd_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_arg$ = 8						; size = 4
_Cmd_Argv PROC

; 485  : {

	push	ebp
	mov	ebp, esp

; 486  : 	if((uint)arg >= cmd_argc )

	mov	eax, DWORD PTR _arg$[ebp]
	cmp	eax, DWORD PTR _cmd_argc
	jb	SHORT $LN2@Cmd_Argv

; 487  : 		return "";

	mov	eax, OFFSET $SG139865
	jmp	SHORT $LN1@Cmd_Argv
$LN2@Cmd_Argv:

; 488  : 	return cmd_argv[arg];	

	mov	ecx, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _cmd_argv[ecx*4]
$LN1@Cmd_Argv:

; 489  : }

	pop	ebp
	ret	0
_Cmd_Argv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_Args PROC

; 497  : {

	push	ebp
	mov	ebp, esp

; 498  : 	return cmd_args;

	mov	eax, DWORD PTR _cmd_args

; 499  : }

	pop	ebp
	ret	0
_Cmd_Args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cmd_Argc PROC

; 475  : {

	push	ebp
	mov	ebp, esp

; 476  : 	return cmd_argc;

	mov	eax, DWORD PTR _cmd_argc

; 477  : }

	pop	ebp
	ret	0
_Cmd_Argc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
$T1 = -2088						; size = 4
tv168 = -2084						; size = 4
tv163 = -2080						; size = 4
$T2 = -2076						; size = 4
tv73 = -2072						; size = 4
_quotes$ = -2068					; size = 4
_comment$ = -2064					; size = 4
_text$ = -2060						; size = 4
_i$ = -2056						; size = 4
_line$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_Cbuf_Execute PROC

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2088				; 00000828H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
$LN2@Cbuf_Execu:

; 148  : 	char	*text;
; 149  : 	char	line[MAX_CMD_LINE];
; 150  : 	int	i, quotes;
; 151  : 	char	*comment;
; 152  : 
; 153  : 	while( cmd_text.cursize )

	cmp	DWORD PTR _cmd_text+4, 0
	je	$LN23@Cbuf_Execu

; 154  : 	{
; 155  : 		// find a \n or ; line break
; 156  : 		text = (char *)cmd_text.data;

	mov	eax, DWORD PTR _cmd_text
	mov	DWORD PTR _text$[ebp], eax

; 157  : 
; 158  : 		quotes = false;

	mov	DWORD PTR _quotes$[ebp], 0

; 159  : 		comment = NULL;

	mov	DWORD PTR _comment$[ebp], 0

; 160  : 
; 161  : 		for( i = 0; i < cmd_text.cursize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Cbuf_Execu
$LN4@Cbuf_Execu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@Cbuf_Execu:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _cmd_text+4
	jge	$LN5@Cbuf_Execu

; 162  : 		{
; 163  : 			if( !comment )

	cmp	DWORD PTR _comment$[ebp], 0
	jne	$LN7@Cbuf_Execu

; 164  : 			{
; 165  : 				if( text[i] == '"' ) quotes = !quotes;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN8@Cbuf_Execu
	cmp	DWORD PTR _quotes$[ebp], 0
	jne	SHORT $LN24@Cbuf_Execu
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN25@Cbuf_Execu
$LN24@Cbuf_Execu:
	mov	DWORD PTR tv73[ebp], 0
$LN25@Cbuf_Execu:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _quotes$[ebp], edx
$LN8@Cbuf_Execu:

; 166  : 
; 167  : 				if( quotes )

	cmp	DWORD PTR _quotes$[ebp], 0
	je	SHORT $LN9@Cbuf_Execu

; 168  : 				{
; 169  : 					// make sure i doesn't get > cursize which causes a negative size in memmove, which is fatal --blub
; 170  : 					if( i < ( cmd_text.cursize - 1 ) && ( text[i+0] == '\\' && (text[i+1] == '"' || text[i+1] == '\\')))

	mov	eax, DWORD PTR _cmd_text+4
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN11@Cbuf_Execu
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN11@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN12@Cbuf_Execu
	mov	edx, DWORD PTR _text$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN11@Cbuf_Execu
$LN12@Cbuf_Execu:

; 171  : 						i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN11@Cbuf_Execu:

; 172  : 				}

	jmp	SHORT $LN7@Cbuf_Execu
$LN9@Cbuf_Execu:

; 173  : 				else
; 174  : 				{
; 175  : 					if( text[i+0] == '/' && text[i+1] == '/' && ( i == 0 || (byte)text[i - 1] <= ' ' ))

	mov	edx, DWORD PTR _text$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN13@Cbuf_Execu
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN13@Cbuf_Execu
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN14@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN13@Cbuf_Execu
$LN14@Cbuf_Execu:

; 176  : 						comment = &text[i];

	mov	edx, DWORD PTR _text$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _comment$[ebp], edx
$LN13@Cbuf_Execu:

; 177  : 					if( text[i] == ';' ) break; // don't break if inside a quoted string or comment

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN7@Cbuf_Execu
	jmp	SHORT $LN5@Cbuf_Execu
$LN7@Cbuf_Execu:

; 178  : 				}
; 179  : 			}
; 180  : 
; 181  : 			if( text[i] == '\n' || text[i] == '\r' )

	mov	edx, DWORD PTR _text$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN17@Cbuf_Execu
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN16@Cbuf_Execu
$LN17@Cbuf_Execu:

; 182  : 				break;

	jmp	SHORT $LN5@Cbuf_Execu
$LN16@Cbuf_Execu:

; 183  : 		}

	jmp	$LN4@Cbuf_Execu
$LN5@Cbuf_Execu:

; 184  : 
; 185  : 		if( i >= ( MAX_CMD_LINE - 1 ))

	cmp	DWORD PTR _i$[ebp], 2047		; 000007ffH
	jl	SHORT $LN18@Cbuf_Execu

; 186  : 		{
; 187  : 			Con_DPrintf( S_ERROR "Cbuf_Execute: command string owerflow\n" );

	push	OFFSET $SG139731
	call	_Con_DPrintf
	add	esp, 4

; 188  : 			line[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 2048		; 00000800H
	jae	SHORT $LN26@Cbuf_Execu
	jmp	SHORT $LN27@Cbuf_Execu
$LN26@Cbuf_Execu:
	call	___report_rangecheckfailure
$LN27@Cbuf_Execu:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _line$[ebp+edx], 0

; 189  : 		}

	jmp	$LN19@Cbuf_Execu
$LN18@Cbuf_Execu:

; 190  : 		else
; 191  : 		{
; 192  : 			memcpy( line, text, comment ? (comment - text) : i );

	cmp	DWORD PTR _comment$[ebp], 0
	je	SHORT $LN28@Cbuf_Execu
	mov	eax, DWORD PTR _comment$[ebp]
	sub	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN29@Cbuf_Execu
$LN28@Cbuf_Execu:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
$LN29@Cbuf_Execu:
	mov	edx, DWORD PTR tv163[ebp]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	lea	ecx, DWORD PTR _line$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 193  : 			line[comment ? (comment - text) : i] = 0;

	cmp	DWORD PTR _comment$[ebp], 0
	je	SHORT $LN30@Cbuf_Execu
	mov	edx, DWORD PTR _comment$[ebp]
	sub	edx, DWORD PTR _text$[ebp]
	mov	DWORD PTR tv168[ebp], edx
	jmp	SHORT $LN31@Cbuf_Execu
$LN30@Cbuf_Execu:
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv168[ebp], eax
$LN31@Cbuf_Execu:
	mov	ecx, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN32@Cbuf_Execu
	jmp	SHORT $LN33@Cbuf_Execu
$LN32@Cbuf_Execu:
	call	___report_rangecheckfailure
$LN33@Cbuf_Execu:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _line$[ebp+edx], 0
$LN19@Cbuf_Execu:

; 194  : 		}
; 195  : 
; 196  : 		// delete the text from the command buffer and move remaining commands down
; 197  : 		// this is necessary because commands (exec) can insert data at the
; 198  : 		// beginning of the text buffer
; 199  : 		if( i == cmd_text.cursize )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cmd_text+4
	jne	SHORT $LN20@Cbuf_Execu

; 200  : 		{
; 201  : 			cmd_text.cursize = 0;

	mov	DWORD PTR _cmd_text+4, 0

; 202  : 		}

	jmp	SHORT $LN21@Cbuf_Execu
$LN20@Cbuf_Execu:

; 203  : 		else
; 204  : 		{
; 205  : 			i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 206  : 			cmd_text.cursize -= i;

	mov	edx, DWORD PTR _cmd_text+4
	sub	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cmd_text+4, edx

; 207  : 			memmove( cmd_text.data, text + i, cmd_text.cursize );

	mov	eax, DWORD PTR _cmd_text+4
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmd_text
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN21@Cbuf_Execu:

; 208  : 		}
; 209  : 
; 210  : 		// execute the command line
; 211  : 		Cmd_ExecuteString( line );

	lea	eax, DWORD PTR _line$[ebp]
	push	eax
	call	_Cmd_ExecuteString
	add	esp, 4

; 212  : 
; 213  : 		if( cmd_wait )

	cmp	DWORD PTR _cmd_wait, 0
	je	SHORT $LN22@Cbuf_Execu

; 214  : 		{
; 215  : 			// skip out while text still remains in buffer,
; 216  : 			// leaving it for next frame
; 217  : 			cmd_wait = false;

	mov	DWORD PTR _cmd_wait, 0

; 218  : 			break;

	jmp	SHORT $LN23@Cbuf_Execu
$LN22@Cbuf_Execu:

; 219  : 		}
; 220  : 	}

	jmp	$LN2@Cbuf_Execu
$LN23@Cbuf_Execu:

; 221  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_Execute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
$T1 = -2072						; size = 4
$T2 = -2068						; size = 4
_j$ = -2064						; size = 4
_l$ = -2060						; size = 4
_i$ = -2056						; size = 4
_build$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_Cbuf_ExecStuffCmds PROC

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2072				; 00000818H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 232  : 	char	build[MAX_CMD_LINE]; // this is for all commandline options combined (and is bounds checked)
; 233  : 	int	i, j, l = 0;

	mov	DWORD PTR _l$[ebp], 0

; 234  : 
; 235  : 	// no reason to run the commandline arguments twice
; 236  : 	if( !host.stuffcmds_pending )

	cmp	DWORD PTR _host+34348, 0
	jne	SHORT $LN13@Cbuf_ExecS

; 237  : 		return;

	jmp	$LN23@Cbuf_ExecS
$LN13@Cbuf_ExecS:

; 238  : 	build[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 2048		; 00000800H
	jae	SHORT $LN24@Cbuf_ExecS
	jmp	SHORT $LN25@Cbuf_ExecS
$LN24@Cbuf_ExecS:
	call	___report_rangecheckfailure
$LN25@Cbuf_ExecS:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _build$[ebp+edx], 0

; 239  : 
; 240  : 	for( i = 0; i < host.argc; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Cbuf_ExecS
$LN2@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cbuf_ExecS:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _host+920
	jge	$LN3@Cbuf_ExecS

; 241  : 	{
; 242  : 		if( host.argv[i] && host.argv[i][0] == '+' && ( host.argv[i][1] < '0' || host.argv[i][1] > '9' ) && l + Q_strlen( host.argv[i] ) - 1 <= sizeof( build ) - 1 )

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _host[edx*4+924], 0
	je	$LN14@Cbuf_ExecS
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 43					; 0000002bH
	jne	$LN14@Cbuf_ExecS
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN15@Cbuf_ExecS
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 57					; 00000039H
	jle	$LN14@Cbuf_ExecS
$LN15@Cbuf_ExecS:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _l$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	cmp	edx, 2047				; 000007ffH
	ja	$LN14@Cbuf_ExecS

; 243  : 		{
; 244  : 			j = 1;

	mov	DWORD PTR _j$[ebp], 1
$LN5@Cbuf_ExecS:

; 245  : 
; 246  : 			while( host.argv[i][j] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN6@Cbuf_ExecS

; 247  : 				build[l++] = host.argv[i][j++];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _build$[ebp+eax], dl
	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN5@Cbuf_ExecS
$LN6@Cbuf_ExecS:

; 248  : 
; 249  : 			for( i++; i < host.argc; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN9@Cbuf_ExecS
$LN7@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Cbuf_ExecS:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _host+920
	jge	$LN8@Cbuf_ExecS

; 250  : 			{
; 251  : 				if( !host.argv[i] ) continue;

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _host[edx*4+924], 0
	jne	SHORT $LN16@Cbuf_ExecS
	jmp	SHORT $LN7@Cbuf_ExecS
$LN16@Cbuf_ExecS:

; 252  : 				if(( host.argv[i][0] == '+' || host.argv[i][0] == '-' ) && ( host.argv[i][1] < '0' || host.argv[i][1] > '9' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN18@Cbuf_ExecS
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN17@Cbuf_ExecS
$LN18@Cbuf_ExecS:
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN19@Cbuf_ExecS
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN17@Cbuf_ExecS
$LN19@Cbuf_ExecS:

; 253  : 					break;

	jmp	$LN8@Cbuf_ExecS
$LN17@Cbuf_ExecS:

; 254  : 				if( l + Q_strlen( host.argv[i] ) + 4 > sizeof( build ) - 1 )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR [edx+eax+4]
	cmp	eax, 2047				; 000007ffH
	jbe	SHORT $LN20@Cbuf_ExecS

; 255  : 					break;

	jmp	$LN8@Cbuf_ExecS
$LN20@Cbuf_ExecS:

; 256  : 				build[l++] = ' ';

	mov	ecx, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+ecx], 32		; 00000020H
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx

; 257  : 	
; 258  : 				if( Q_strchr( host.argv[i], ' ' ))

	push	32					; 00000020H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@Cbuf_ExecS

; 259  : 					build[l++] = '\"';

	mov	edx, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+edx], 34		; 00000022H
	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$LN21@Cbuf_ExecS:

; 260  : 	
; 261  : 				for( j = 0; host.argv[i][j]; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN12@Cbuf_ExecS
$LN10@Cbuf_ExecS:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN12@Cbuf_ExecS:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN11@Cbuf_ExecS

; 262  : 					build[l++] = host.argv[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _build$[ebp+edx], cl
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $LN10@Cbuf_ExecS
$LN11@Cbuf_ExecS:

; 263  : 	
; 264  : 				if( Q_strchr( host.argv[i], ' ' ))

	push	32					; 00000020H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@Cbuf_ExecS

; 265  : 					build[l++] = '\"';

	mov	edx, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+edx], 34		; 00000022H
	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax
$LN22@Cbuf_ExecS:

; 266  : 			}

	jmp	$LN7@Cbuf_ExecS
$LN8@Cbuf_ExecS:

; 267  : 			build[l++] = '\n';

	mov	ecx, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+ecx], 10		; 0000000aH
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx

; 268  : 			i--;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@Cbuf_ExecS:

; 269  : 		}
; 270  : 	}

	jmp	$LN2@Cbuf_ExecS
$LN3@Cbuf_ExecS:

; 271  : 
; 272  : 	// now terminate the combined string and prepend it to the command buffer
; 273  : 	// we already reserved space for the terminator
; 274  : 	build[l++] = 0;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN26@Cbuf_ExecS
	jmp	SHORT $LN27@Cbuf_ExecS
$LN26@Cbuf_ExecS:
	call	___report_rangecheckfailure
$LN27@Cbuf_ExecS:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _build$[ebp+eax], 0

; 275  : 	Cbuf_InsertText( build );

	lea	ecx, DWORD PTR _build$[ebp]
	push	ecx
	call	_Cbuf_InsertText
	add	esp, 4

; 276  : 	Cbuf_Execute(); // apply now

	call	_Cbuf_Execute

; 277  : 
; 278  : 	// this command can be called only from .rc
; 279  : 	Cmd_RemoveCommand( "stuffcmds" );

	push	OFFSET $SG139764
	call	_Cmd_RemoveCommand
	add	esp, 4

; 280  : 	host.stuffcmds_pending = false;

	mov	DWORD PTR _host+34348, 0
$LN23@Cbuf_ExecS:

; 281  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_ExecStuffCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_l$ = -4						; size = 4
_text$ = 8						; size = 4
_Cbuf_InsertText PROC

; 126  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 127  : 	int	l = Q_strlen( text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 128  : 
; 129  : 	if(( cmd_text.cursize + l ) >= cmd_text.maxsize )

	mov	ecx, DWORD PTR _cmd_text+4
	add	ecx, DWORD PTR _l$[ebp]
	cmp	ecx, DWORD PTR _cmd_text+8
	jl	SHORT $LN2@Cbuf_Inser

; 130  : 	{
; 131  : 		Con_Reportf( S_WARN "Cbuf_InsertText: overflow\n" );

	push	OFFSET $SG139700
	call	_Con_Reportf
	add	esp, 4

; 132  : 	}

	jmp	SHORT $LN1@Cbuf_Inser
$LN2@Cbuf_Inser:

; 133  : 	else
; 134  : 	{
; 135  : 		memmove( cmd_text.data + l, cmd_text.data, cmd_text.cursize );

	mov	edx, DWORD PTR _cmd_text+4
	push	edx
	mov	eax, DWORD PTR _cmd_text
	push	eax
	mov	ecx, DWORD PTR _cmd_text
	add	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 136  : 		memcpy( cmd_text.data, text, l );

	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd_text
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 137  : 		cmd_text.cursize += l;

	mov	edx, DWORD PTR _cmd_text+4
	add	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _cmd_text+4, edx
$LN1@Cbuf_Inser:

; 138  : 	}
; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_InsertText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_l$ = -4						; size = 4
_text$ = 8						; size = 4
_Cbuf_AddText PROC

; 104  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 105  : 	int	l = Q_strlen( text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 106  : 
; 107  : 	if(( cmd_text.cursize + l ) >= cmd_text.maxsize )

	mov	ecx, DWORD PTR _cmd_text+4
	add	ecx, DWORD PTR _l$[ebp]
	cmp	ecx, DWORD PTR _cmd_text+8
	jl	SHORT $LN2@Cbuf_AddTe

; 108  : 	{
; 109  : 		Con_Reportf( S_WARN "Cbuf_AddText: overflow\n" );

	push	OFFSET $SG139693
	call	_Con_Reportf
	add	esp, 4

; 110  : 	}

	jmp	SHORT $LN1@Cbuf_AddTe
$LN2@Cbuf_AddTe:

; 111  : 	else
; 112  : 	{
; 113  : 		memcpy( Cbuf_GetSpace( &cmd_text, l ), text, l );

	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET _cmd_text
	call	_Cbuf_GetSpace
	add	esp, 8
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Cbuf_AddTe:

; 114  : 	}
; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_AddText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cbuf_Clear PROC

; 70   : {

	push	ebp
	mov	ebp, esp

; 71   : 	memset( cmd_text.data, 0, sizeof( cmd_text_buf ));

	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _cmd_text
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 72   : 	cmd_text.cursize = 0;

	mov	DWORD PTR _cmd_text+4, 0

; 73   : }

	pop	ebp
	ret	0
_Cbuf_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xash_build4529_src\engine\common\cmd.c
_TEXT	SEGMENT
_Cbuf_Init PROC

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   : 	cmd_text.data = cmd_text_buf;

	mov	DWORD PTR _cmd_text, OFFSET _cmd_text_buf

; 60   : 	cmd_text.maxsize = MAX_CMD_BUFFER;

	mov	DWORD PTR _cmd_text+8, 32768		; 00008000H

; 61   : 	cmd_text.cursize = 0;

	mov	DWORD PTR _cmd_text+4, 0

; 62   : }

	pop	ebp
	ret	0
_Cbuf_Init ENDP
_TEXT	ENDS
END
