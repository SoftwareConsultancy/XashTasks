; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\zone.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_poolchain
_BSS	SEGMENT
_poolchain DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG129821 DB	'<corrupted>', 00H, 00H
_DATA	ENDS
PUBLIC	_Memory_Init
PUBLIC	__Mem_Realloc
PUBLIC	__Mem_Alloc
PUBLIC	__Mem_AllocPool
PUBLIC	__Mem_FreePool
PUBLIC	__Mem_EmptyPool
PUBLIC	__Mem_Free
PUBLIC	__Mem_Check
PUBLIC	_Mem_IsAllocatedExt
PUBLIC	_Mem_PrintList
PUBLIC	_Mem_PrintStats
PUBLIC	_Mem_CheckAlloc
PUBLIC	_Mem_CheckHeaderSentinels
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Con_Printf:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG129805 DB	'Mem_Alloc: pool == NULL (alloc at %s:%i)', 0aH, 00H
	ORG $+2
$SG129807 DB	'Mem_Alloc: out of memory (alloc at %s:%i)', 0aH, 00H
	ORG $+1
?dummy@?1??Mem_CheckFilename@@9@9 DD FLAT:$SG129821	; `Mem_CheckFilename'::`2'::dummy
$SG129843 DB	'Mem_Free: not allocated or double freed (free at %s:%i)', 0aH
	DB	00H
	ORG $+3
$SG129838 DB	'Mem_Free: trashed header sentinel 1 (alloc at %s:%i, fre'
	DB	'e at %s:%i)', 0aH, 00H
	ORG $+3
$SG129840 DB	'Mem_Free: trashed header sentinel 2 (alloc at %s:%i, fre'
	DB	'e at %s:%i)', 0aH, 00H
	ORG $+3
$SG129859 DB	'Mem_Free: data == NULL (called at %s:%i)', 0aH, 00H
	ORG $+2
$SG129901 DB	'Mem_AllocPool: out of memory (allocpool at %s:%i)', 0aH, 00H
	ORG $+1
$SG129921 DB	'Mem_FreePool: pool already free (freepool at %s:%i)', 0aH
	DB	00H
	ORG $+3
$SG129923 DB	'Mem_FreePool: trashed pool sentinel 1 (allocpool at %s:%'
	DB	'i, freepool at %s:%i)', 0aH, 00H
	ORG $+1
$SG129925 DB	'Mem_FreePool: trashed pool sentinel 2 (allocpool at %s:%'
	DB	'i, freepool at %s:%i)', 0aH, 00H
	ORG $+1
$SG129939 DB	'Mem_EmptyPool: pool == NULL (emptypool at %s:%i)', 0aH, 00H
	ORG $+2
$SG129990 DB	'Mem_CheckSentinels: data == NULL (sentinel check at %s:%'
	DB	'i)', 0aH, 00H
$SG129941 DB	'Mem_EmptyPool: trashed pool sentinel 1 (allocpool at %s:'
	DB	'%i, emptypool at %s:%i)', 0aH, 00H
	ORG $+3
$SG130029 DB	'^3%lu^7 memory pools, totalling: ^1%s', 0aH, 00H
	ORG $+1
$SG130030 DB	'total allocated size: ^1%s', 0aH, 00H
$SG129943 DB	'Mem_EmptyPool: trashed pool sentinel 2 (allocpool at %s:'
	DB	'%i, emptypool at %s:%i)', 0aH, 00H
	ORG $+3
$SG130047 DB	'memory pool list:', 0aH, '  ^3size                      '
	DB	'    name', 0aH, 00H
	ORG $+2
$SG129992 DB	'Mem_CheckSentinels: trashed header sentinel 1 (block all'
	DB	'ocated at %s:%i, sentinel check at %s:%i)', 0aH, 00H
	ORG $+1
$SG130053 DB	'%10s allocated at %s:%i', 0aH, 00H
	ORG $+3
$SG129994 DB	'Mem_CheckSentinels: trashed header sentinel 2 (block all'
	DB	'ocated at %s:%i, sentinel check at %s:%i)', 0aH, 00H
	ORG $+5
$SG130015 DB	'Mem_CheckSentinelsGlobal: trashed pool sentinel 1 (alloc'
	DB	'pool at %s:%i, sentinel check at %s:%i)', 0aH, 00H
	ORG $+7
$SG130017 DB	'Mem_CheckSentinelsGlobal: trashed pool sentinel 2 (alloc'
	DB	'pool at %s:%i, sentinel check at %s:%i)', 0aH, 00H
	ORG $+7
$SG130028 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\zone.c', 00H
	ORG $+7
$SG130046 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\zone.c', 00H
	ORG $+3
$SG130050 DB	'%10s (%10s actual) %s (^7%c%s change)', 0aH, 00H
	ORG $+1
$SG130051 DB	'%5s (%5s actual) %s', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_mem$ = -4						; size = 4
_data$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_Mem_CheckHeaderSentinels PROC

; 258  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 259  : 	memheader_t	*mem;
; 260  : 
; 261  : 	if( data == NULL )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@Mem_CheckH

; 262  : 		Sys_Error( "Mem_CheckSentinels: data == NULL (sentinel check at %s:%i)\n", filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG129990
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mem_CheckH:

; 263  : 
; 264  : 	mem = (memheader_t *)((byte *) data - sizeof(memheader_t));

	mov	edx, DWORD PTR _data$[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR _mem$[ebp], edx

; 265  : 
; 266  : 	if( mem->sentinel1 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax+24], -559026163		; deadf00dH
	je	SHORT $LN3@Mem_CheckH

; 267  : 	{
; 268  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 269  : 		Sys_Error( "Mem_CheckSentinels: trashed header sentinel 1 (block allocated at %s:%i, sentinel check at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET $SG129992
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN3@Mem_CheckH:

; 270  : 	}
; 271  : 
; 272  : 	if( *((byte *)mem + sizeof(memheader_t) + mem->size) != MEMHEADER_SENTINEL2 )

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _mem$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+28]
	cmp	edx, 223				; 000000dfH
	je	SHORT $LN1@Mem_CheckH

; 273  : 	{	
; 274  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+16], eax

; 275  : 		Sys_Error( "Mem_CheckSentinels: trashed header sentinel 2 (block allocated at %s:%i, sentinel check at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET $SG129994
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN1@Mem_CheckH:

; 276  : 	}
; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_CheckHeaderSentinels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_target$ = -8						; size = 4
_header$ = -4						; size = 4
_pool$ = 8						; size = 4
_data$ = 12						; size = 4
_Mem_CheckAlloc PROC

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 225  : 	memheader_t *header, *target;
; 226  : 
; 227  : 	if( pool )

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN8@Mem_CheckA

; 228  : 	{
; 229  : 		// search only one pool
; 230  : 		target = (memheader_t *)((byte *)data - sizeof( memheader_t ));

	mov	eax, DWORD PTR _data$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _target$[ebp], eax

; 231  : 		for( header = pool->chain; header; header = header->next )

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _header$[ebp], edx
	jmp	SHORT $LN4@Mem_CheckA
$LN2@Mem_CheckA:
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _header$[ebp], ecx
$LN4@Mem_CheckA:
	cmp	DWORD PTR _header$[ebp], 0
	je	SHORT $LN3@Mem_CheckA

; 232  : 			if( header == target ) return true;

	mov	edx, DWORD PTR _header$[ebp]
	cmp	edx, DWORD PTR _target$[ebp]
	jne	SHORT $LN10@Mem_CheckA
	mov	eax, 1
	jmp	SHORT $LN1@Mem_CheckA
$LN10@Mem_CheckA:
	jmp	SHORT $LN2@Mem_CheckA
$LN3@Mem_CheckA:

; 233  : 	}

	jmp	SHORT $LN9@Mem_CheckA
$LN8@Mem_CheckA:

; 234  : 	else
; 235  : 	{
; 236  : 		// search all pools
; 237  : 		for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN7@Mem_CheckA
$LN5@Mem_CheckA:
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _pool$[ebp], edx
$LN7@Mem_CheckA:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN9@Mem_CheckA

; 238  : 			if( Mem_CheckAlloc( pool, data ))

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	push	ecx
	call	_Mem_CheckAlloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@Mem_CheckA

; 239  : 				return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mem_CheckA
$LN11@Mem_CheckA:
	jmp	SHORT $LN5@Mem_CheckA
$LN9@Mem_CheckA:

; 240  : 	}
; 241  : 	return false;

	xor	eax, eax
$LN1@Mem_CheckA:

; 242  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_CheckAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
tv135 = -16						; size = 4
tv132 = -12						; size = 4
tv133 = -8						; size = 4
_pool$ = -4						; size = 4
_mem$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_Mem_FreeBlock PROC

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 102  : 	mempool_t		*pool;
; 103  : 
; 104  : 	if( mem->sentinel1 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax+24], -559026163		; deadf00dH
	je	SHORT $LN2@Mem_FreeBl

; 105  : 	{
; 106  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 107  : 		Sys_Error( "Mem_Free: trashed header sentinel 1 (alloc at %s:%i, free at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET $SG129838
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN2@Mem_FreeBl:

; 108  : 	}
; 109  : 
; 110  : 	if( *((byte *)mem + sizeof( memheader_t ) + mem->size ) != MEMHEADER_SENTINEL2 )

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _mem$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+28]
	cmp	edx, 223				; 000000dfH
	je	SHORT $LN3@Mem_FreeBl

; 111  : 	{	
; 112  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+16], eax

; 113  : 		Sys_Error( "Mem_Free: trashed header sentinel 2 (alloc at %s:%i, free at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET $SG129840
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN3@Mem_FreeBl:

; 114  : 	}
; 115  : 
; 116  : 	pool = mem->pool;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pool$[ebp], ecx

; 117  : 	// unlink memheader from doubly linked list
; 118  : 	if(( mem->prev ? mem->prev->next != mem : pool->chain != mem ) || ( mem->next && mem->next->prev != mem ))

	mov	edx, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN14@Mem_FreeBl
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _mem$[ebp]
	je	SHORT $LN12@Mem_FreeBl
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN13@Mem_FreeBl
$LN12@Mem_FreeBl:
	mov	DWORD PTR tv133[ebp], 0
$LN13@Mem_FreeBl:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN15@Mem_FreeBl
$LN14@Mem_FreeBl:
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _mem$[ebp]
	je	SHORT $LN10@Mem_FreeBl
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN11@Mem_FreeBl
$LN10@Mem_FreeBl:
	mov	DWORD PTR tv132[ebp], 0
$LN11@Mem_FreeBl:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv135[ebp], eax
$LN15@Mem_FreeBl:
	cmp	DWORD PTR tv135[ebp], 0
	jne	SHORT $LN5@Mem_FreeBl
	mov	ecx, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@Mem_FreeBl
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _mem$[ebp]
	je	SHORT $LN4@Mem_FreeBl
$LN5@Mem_FreeBl:

; 119  : 		Sys_Error( "Mem_Free: not allocated or double freed (free at %s:%i)\n", filename, fileline );

	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG129843
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mem_FreeBl:

; 120  : 
; 121  : 	if( mem->prev ) mem->prev->next = mem->next;

	mov	ecx, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN6@Mem_FreeBl
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN7@Mem_FreeBl
$LN6@Mem_FreeBl:

; 122  : 	else pool->chain = mem->next;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
$LN7@Mem_FreeBl:

; 123  : 
; 124  : 	if( mem->next )

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Mem_FreeBl

; 125  : 		mem->next->prev = mem->prev;

	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
$LN8@Mem_FreeBl:

; 126  : 
; 127  : 	// memheader has been unlinked, do the actual free now
; 128  : 	pool->totalsize -= mem->size;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 129  : 
; 130  : 	pool->realsize -= sizeof( memheader_t ) + mem->size + sizeof( int );

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 131  : 	free( mem );

	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_FreeBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_filename$ = 8						; size = 4
_Mem_CheckFilename PROC

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 84   : 	static const char	*dummy = "<corrupted>\0";
; 85   : 	const char	*out = filename;

	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 86   : 	int		i;
; 87   : 
; 88   : 	if( !COM_CheckString( out ))

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Mem_CheckF

; 89   : 		return dummy;

	mov	eax, DWORD PTR ?dummy@?1??Mem_CheckFilename@@9@9
	jmp	SHORT $LN1@Mem_CheckF
$LN5@Mem_CheckF:

; 90   : 
; 91   : 	for( i = 0; i < MAX_OSPATH; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mem_CheckF
$LN2@Mem_CheckF:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
$LN4@Mem_CheckF:
	cmp	DWORD PTR _i$[ebp], 260			; 00000104H
	jge	SHORT $LN3@Mem_CheckF

; 92   : 	{
; 93   : 		if( *out == '\0' )

	mov	ecx, DWORD PTR _out$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@Mem_CheckF

; 94   : 			return filename; // valid name

	mov	eax, DWORD PTR _filename$[ebp]
	jmp	SHORT $LN1@Mem_CheckF
$LN6@Mem_CheckF:

; 95   : 	}

	jmp	SHORT $LN2@Mem_CheckF
$LN3@Mem_CheckF:

; 96   : 
; 97   : 	return dummy;

	mov	eax, DWORD PTR ?dummy@?1??Mem_CheckFilename@@9@9
$LN1@Mem_CheckF:

; 98   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_CheckFilename ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
tv144 = -40						; size = 8
tv132 = -32						; size = 8
tv140 = -24						; size = 4
tv128 = -20						; size = 4
_realsize$ = -16					; size = 4
_count$ = -12						; size = 4
_size$ = -8						; size = 4
_pool$ = -4						; size = 4
_Mem_PrintStats PROC

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 299  : 	size_t	count = 0, size = 0, realsize = 0;

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _size$[ebp], 0
	mov	DWORD PTR _realsize$[ebp], 0

; 300  : 	mempool_t	*pool;
; 301  : 
; 302  : 	Mem_Check();

	push	302					; 0000012eH
	push	OFFSET $SG130028
	call	__Mem_Check
	add	esp, 8

; 303  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN4@Mem_PrintS
$LN2@Mem_PrintS:
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _pool$[ebp], edx
$LN4@Mem_PrintS:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@Mem_PrintS

; 304  : 	{
; 305  : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 306  : 		size += pool->totalsize;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	add	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _size$[ebp], edx

; 307  : 		realsize += pool->realsize;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _realsize$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _realsize$[ebp], ecx

; 308  : 	}

	jmp	SHORT $LN2@Mem_PrintS
$LN3@Mem_PrintS:

; 309  : 
; 310  : 	Con_Printf( "^3%lu^7 memory pools, totalling: ^1%s\n", (dword)count, Q_memprint( size ));

	push	2
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv128[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR tv128[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv132[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv132[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	OFFSET $SG130029
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 311  : 	Con_Printf( "total allocated size: ^1%s\n", Q_memprint( realsize ));

	push	2
	mov	edx, DWORD PTR _realsize$[ebp]
	mov	DWORD PTR tv140[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR tv140[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv144[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv144[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG130030
	call	_Con_Printf
	add	esp, 8

; 312  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_PrintStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
tv240 = -80						; size = 8
tv219 = -72						; size = 8
tv207 = -64						; size = 8
tv194 = -56						; size = 8
tv182 = -48						; size = 8
tv236 = -40						; size = 4
tv215 = -36						; size = 4
tv203 = -32						; size = 4
tv190 = -28						; size = 4
tv178 = -24						; size = 4
tv74 = -20						; size = 4
_changed_size$1 = -16					; size = 4
_mem$ = -12						; size = 4
_pool$ = -8						; size = 4
_sign$2 = -1						; size = 1
_minallocationsize$ = 8					; size = 4
_Mem_PrintList PROC

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 316  : 	mempool_t		*pool;
; 317  : 	memheader_t	*mem;
; 318  : 
; 319  : 	Mem_Check();

	push	319					; 0000013fH
	push	OFFSET $SG130046
	call	__Mem_Check
	add	esp, 8

; 320  : 
; 321  : 	Con_Printf( "memory pool list:\n""  ^3size                          name\n");

	push	OFFSET $SG130047
	call	_Con_Printf
	add	esp, 4

; 322  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN4@Mem_PrintL
$LN2@Mem_PrintL:
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _pool$[ebp], edx
$LN4@Mem_PrintL:
	cmp	DWORD PTR _pool$[ebp], 0
	je	$LN3@Mem_PrintL

; 323  : 	{
; 324  : 		long	changed_size = (long)pool->totalsize - (long)pool->lastchecksize;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _changed_size$1[ebp], edx

; 325  : 
; 326  : 		// poolnames can contain color symbols, make sure what color is reset
; 327  : 		if( changed_size != 0 )

	je	$LN8@Mem_PrintL

; 328  : 		{
; 329  : 			char	sign = (changed_size < 0) ? '-' : '+';

	cmp	DWORD PTR _changed_size$1[ebp], 0
	jge	SHORT $LN12@Mem_PrintL
	mov	DWORD PTR tv74[ebp], 45			; 0000002dH
	jmp	SHORT $LN13@Mem_PrintL
$LN12@Mem_PrintL:
	mov	DWORD PTR tv74[ebp], 43			; 0000002bH
$LN13@Mem_PrintL:
	mov	al, BYTE PTR tv74[ebp]
	mov	BYTE PTR _sign$2[ebp], al

; 330  : 
; 331  : 			Con_Printf( "%10s (%10s actual) %s (^7%c%s change)\n", Q_memprint( pool->totalsize ), Q_memprint( pool->realsize ),

	push	2
	mov	ecx, DWORD PTR _changed_size$1[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	movsx	edx, BYTE PTR _sign$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	push	2
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv178[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv178[ebp]
	mov	eax, DWORD PTR tv178[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv182[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv182[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	2
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv190[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv190[ebp]
	mov	eax, DWORD PTR tv190[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv194[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv194[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG130050
	call	_Con_Printf
	add	esp, 24					; 00000018H

; 332  : 			pool->name, sign, Q_memprint( abs( changed_size )));
; 333  : 		}

	jmp	$LN9@Mem_PrintL
$LN8@Mem_PrintL:

; 334  : 		else
; 335  : 		{
; 336  : 			Con_Printf( "%5s (%5s actual) %s\n", Q_memprint( pool->totalsize ), Q_memprint( pool->realsize ), pool->name );

	mov	ecx, DWORD PTR _pool$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	2
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv203[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv203[ebp]
	mov	ecx, DWORD PTR tv203[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv207[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv207[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	2
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv215[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv215[ebp]
	mov	ecx, DWORD PTR tv215[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv219[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv219[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG130051
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN9@Mem_PrintL:

; 337  : 		}
; 338  : 
; 339  : 		pool->lastchecksize = pool->totalsize;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+16], ecx

; 340  : 		for( mem = pool->chain; mem; mem = mem->next )

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mem$[ebp], eax
	jmp	SHORT $LN7@Mem_PrintL
$LN5@Mem_PrintL:
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _mem$[ebp], edx
$LN7@Mem_PrintL:
	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN6@Mem_PrintL

; 341  : 			if( mem->size >= minallocationsize )

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _minallocationsize$[ebp]
	jb	SHORT $LN10@Mem_PrintL

; 342  : 				Con_Printf( "%10s allocated at %s:%i\n", Q_memprint( mem->size ), mem->filename, mem->fileline );

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	2
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv236[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv236[ebp]
	mov	edx, DWORD PTR tv236[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv240[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv240[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG130053
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN10@Mem_PrintL:
	jmp	SHORT $LN5@Mem_PrintL
$LN6@Mem_PrintL:

; 343  : 	}

	jmp	$LN2@Mem_PrintL
$LN3@Mem_PrintL:

; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_PrintList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_data$ = 12						; size = 4
_Mem_IsAllocatedExt PROC

; 250  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 251  : 	mempool_t	*pool = NULL;

	mov	DWORD PTR _pool$[ebp], 0

; 252  : 	if( poolptr ) pool = (mempool_t *)poolptr;

	cmp	DWORD PTR _poolptr$[ebp], 0
	je	SHORT $LN2@Mem_IsAllo
	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR _pool$[ebp], eax
$LN2@Mem_IsAllo:

; 253  : 
; 254  : 	return Mem_CheckAlloc( pool, data );

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	push	edx
	call	_Mem_CheckAlloc
	add	esp, 8

; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_IsAllocatedExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_mem$ = -8						; size = 4
_pool$ = -4						; size = 4
_filename$ = 8						; size = 4
_fileline$ = 12						; size = 4
__Mem_Check PROC

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 281  : 	memheader_t	*mem;
; 282  : 	mempool_t		*pool;
; 283  : 
; 284  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN4@Mem_Check
$LN2@Mem_Check:
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _pool$[ebp], edx
$LN4@Mem_Check:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@Mem_Check

; 285  : 	{
; 286  : 		if( pool->sentinel1 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax], -559026163		; deadf00dH
	je	SHORT $LN11@Mem_Check

; 287  : 			Sys_Error( "Mem_CheckSentinelsGlobal: trashed pool sentinel 1 (allocpool at %s:%i, sentinel check at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET $SG130015
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN11@Mem_Check:

; 288  : 		if( pool->sentinel2 != MEMHEADER_SENTINEL1 )

	mov	ecx, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [ecx+96], -559026163		; deadf00dH
	je	SHORT $LN12@Mem_Check

; 289  : 			Sys_Error( "Mem_CheckSentinelsGlobal: trashed pool sentinel 2 (allocpool at %s:%i, sentinel check at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET $SG130017
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN12@Mem_Check:

; 290  : 	}

	jmp	SHORT $LN2@Mem_Check
$LN3@Mem_Check:

; 291  : 
; 292  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	edx, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], edx
	jmp	SHORT $LN7@Mem_Check
$LN5@Mem_Check:
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pool$[ebp], ecx
$LN7@Mem_Check:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN1@Mem_Check

; 293  : 		for( mem = pool->chain; mem; mem = mem->next )

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mem$[ebp], eax
	jmp	SHORT $LN10@Mem_Check
$LN8@Mem_Check:
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _mem$[ebp], edx
$LN10@Mem_Check:
	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN9@Mem_Check

; 294  : 			Mem_CheckHeaderSentinels((void *)((byte *) mem + sizeof(memheader_t)), filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	call	_Mem_CheckHeaderSentinels
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@Mem_Check
$LN9@Mem_Check:
	jmp	SHORT $LN5@Mem_Check
$LN1@Mem_Check:

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_data$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_Free PROC

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  : 	if( data == NULL ) Sys_Error( "Mem_Free: data == NULL (called at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@Mem_Free
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG129859
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mem_Free:

; 137  : 	Mem_FreeBlock((memheader_t *)((byte *)data - sizeof( memheader_t )), filename, fileline );

	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	ecx, 28					; 0000001cH
	push	ecx
	call	_Mem_FreeBlock
	add	esp, 12					; 0000000cH

; 138  : }

	pop	ebp
	ret	0
__Mem_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_EmptyPool PROC

; 212  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 213  : 	mempool_t *pool = (mempool_t *)poolptr;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR _pool$[ebp], eax

; 214  : 	if( poolptr == NULL ) Sys_Error( "Mem_EmptyPool: pool == NULL (emptypool at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _poolptr$[ebp], 0
	jne	SHORT $LN4@Mem_EmptyP
	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG129939
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mem_EmptyP:

; 215  : 
; 216  : 	if( pool->sentinel1 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_EmptyPool: trashed pool sentinel 1 (allocpool at %s:%i, emptypool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax], -559026163		; deadf00dH
	je	SHORT $LN5@Mem_EmptyP
	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET $SG129941
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN5@Mem_EmptyP:

; 217  : 	if( pool->sentinel2 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_EmptyPool: trashed pool sentinel 2 (allocpool at %s:%i, emptypool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	ecx, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [ecx+96], -559026163		; deadf00dH
	je	SHORT $LN2@Mem_EmptyP
	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET $SG129943
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN2@Mem_EmptyP:

; 218  : 
; 219  : 	// free memory owned by the pool
; 220  : 	while( pool->chain ) Mem_FreeBlock( pool->chain, filename, fileline );

	mov	edx, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN1@Mem_EmptyP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Mem_FreeBlock
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Mem_EmptyP
$LN1@Mem_EmptyP:

; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_EmptyPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_chainaddress$ = -8					; size = 4
_pool$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_FreePool PROC

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 190  : 	mempool_t	*pool = (mempool_t *)*poolptr;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pool$[ebp], ecx

; 191  : 	mempool_t	**chainaddress;
; 192  :           
; 193  : 	if( pool )

	cmp	DWORD PTR _pool$[ebp], 0
	je	$LN1@Mem_FreePo

; 194  : 	{
; 195  : 		// unlink pool from chain
; 196  : 		for( chainaddress = &poolchain; *chainaddress && *chainaddress != pool; chainaddress = &((*chainaddress)->next));

	mov	DWORD PTR _chainaddress$[ebp], OFFSET _poolchain
	jmp	SHORT $LN4@Mem_FreePo
$LN2@Mem_FreePo:
	mov	edx, DWORD PTR _chainaddress$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _chainaddress$[ebp], eax
$LN4@Mem_FreePo:
	mov	ecx, DWORD PTR _chainaddress$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Mem_FreePo
	mov	edx, DWORD PTR _chainaddress$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _pool$[ebp]
	je	SHORT $LN3@Mem_FreePo
	jmp	SHORT $LN2@Mem_FreePo
$LN3@Mem_FreePo:

; 197  : 		if( *chainaddress != pool ) Sys_Error( "Mem_FreePool: pool already free (freepool at %s:%i)\n", filename, fileline );

	mov	ecx, DWORD PTR _chainaddress$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _pool$[ebp]
	je	SHORT $LN8@Mem_FreePo
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG129921
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN8@Mem_FreePo:

; 198  : 		if( pool->sentinel1 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_FreePool: trashed pool sentinel 1 (allocpool at %s:%i, freepool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	edx, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [edx], -559026163		; deadf00dH
	je	SHORT $LN9@Mem_FreePo
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET $SG129923
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN9@Mem_FreePo:

; 199  : 		if( pool->sentinel2 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_FreePool: trashed pool sentinel 2 (allocpool at %s:%i, freepool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax+96], -559026163		; deadf00dH
	je	SHORT $LN10@Mem_FreePo
	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET $SG129925
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN10@Mem_FreePo:

; 200  : 		*chainaddress = pool->next;

	mov	ecx, DWORD PTR _chainaddress$[ebp]
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax
$LN5@Mem_FreePo:

; 201  : 
; 202  : 		// free memory owned by the pool
; 203  : 		while( pool->chain ) Mem_FreeBlock( pool->chain, filename, fileline );

	mov	ecx, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN6@Mem_FreePo
	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Mem_FreeBlock
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@Mem_FreePo
$LN6@Mem_FreePo:

; 204  : 		// free the pool itself
; 205  : 		memset( pool, 0xBF, sizeof( mempool_t ));

	push	100					; 00000064H
	push	191					; 000000bfH
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 206  : 		free( pool );

	mov	ecx, DWORD PTR _pool$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 207  : 		*poolptr = NULL;

	mov	edx, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR [edx], 0
$LN1@Mem_FreePo:

; 208  : 	}
; 209  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_FreePool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_name$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_AllocPool PROC

; 166  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 167  : 	mempool_t *pool;
; 168  : 
; 169  : 	pool = (mempool_t *)malloc( sizeof( mempool_t ));

	push	100					; 00000064H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pool$[ebp], eax

; 170  : 	if( pool == NULL ) Sys_Error( "Mem_AllocPool: out of memory (allocpool at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _pool$[ebp], 0
	jne	SHORT $LN2@Mem_AllocP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG129901
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mem_AllocP:

; 171  : 	memset( pool, 0, sizeof( mempool_t ));

	push	100					; 00000064H
	push	0
	mov	edx, DWORD PTR _pool$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 172  : 
; 173  : 	// fill header
; 174  : 	pool->sentinel1 = MEMHEADER_SENTINEL1;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax], -559026163		; deadf00dH

; 175  : 	pool->sentinel2 = MEMHEADER_SENTINEL1;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+96], -559026163		; deadf00dH

; 176  : 	pool->filename = filename;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR [edx+24], eax

; 177  : 	pool->fileline = fileline;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR _fileline$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 178  : 	pool->chain = NULL;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], 0

; 179  : 	pool->totalsize = 0;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 180  : 	pool->realsize = sizeof( mempool_t );

	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+12], 100			; 00000064H

; 181  : 	Q_strncpy( pool->name, name, sizeof( pool->name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 182  : 	pool->next = poolchain;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR [edx+20], eax

; 183  : 	poolchain = pool;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR _poolchain, ecx

; 184  : 
; 185  : 	return (byte *)pool;

	mov	eax, DWORD PTR _pool$[ebp]

; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_AllocPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_pool$ = -8						; size = 4
_mem$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_size$ = 12						; size = 4
_clear$ = 16						; size = 4
_filename$ = 20						; size = 4
_fileline$ = 24						; size = 4
__Mem_Alloc PROC

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 52   : 	memheader_t	*mem;
; 53   : 	mempool_t		*pool = (mempool_t *)poolptr;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR _pool$[ebp], eax

; 54   : 
; 55   : 	if( size <= 0 ) return NULL;

	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $LN2@Mem_Alloc
	xor	eax, eax
	jmp	$LN1@Mem_Alloc
$LN2@Mem_Alloc:

; 56   : 	if( poolptr == NULL ) Sys_Error( "Mem_Alloc: pool == NULL (alloc at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _poolptr$[ebp], 0
	jne	SHORT $LN3@Mem_Alloc
	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG129805
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN3@Mem_Alloc:

; 57   : 	pool->totalsize += size;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 58   : 
; 59   : 	// big allocations are not clumped
; 60   : 	pool->realsize += sizeof( memheader_t ) + size + sizeof( int );

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+ecx+32]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 61   : 	mem = (memheader_t *)malloc( sizeof( memheader_t ) + size + sizeof( int ));

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _mem$[ebp], eax

; 62   : 	if( mem == NULL ) Sys_Error( "Mem_Alloc: out of memory (alloc at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN4@Mem_Alloc
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG129807
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mem_Alloc:

; 63   : 
; 64   : 	mem->filename = filename;

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR [edx+16], eax

; 65   : 	mem->fileline = fileline;

	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR _fileline$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 66   : 	mem->size = size;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 67   : 	mem->pool = pool;

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+8], eax

; 68   : 	mem->sentinel1 = MEMHEADER_SENTINEL1;

	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx+24], -559026163		; deadf00dH

; 69   : 	// we have to use only a single byte for this sentinel, because it may not be aligned
; 70   : 	// and some platforms can't use unaligned accesses
; 71   : 	*((byte *)mem + sizeof( memheader_t ) + mem->size ) = MEMHEADER_SENTINEL2;

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	BYTE PTR [ecx+eax+28], 223		; 000000dfH

; 72   : 	// append to head of list
; 73   : 	mem->next = pool->chain;

	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx

; 74   : 	mem->prev = NULL;

	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+4], 0

; 75   : 	pool->chain = mem;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 76   : 	if( mem->next ) mem->next->prev = mem;

	mov	edx, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN5@Mem_Alloc
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN5@Mem_Alloc:

; 77   : 	if( clear ) memset((void *)((byte *)mem + sizeof( memheader_t )), 0, mem->size );

	cmp	DWORD PTR _clear$[ebp], 0
	je	SHORT $LN6@Mem_Alloc
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	0
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@Mem_Alloc:

; 78   : 
; 79   : 	return (void *)((byte *)mem + sizeof( memheader_t ));

	mov	eax, DWORD PTR _mem$[ebp]
	add	eax, 28					; 0000001cH
$LN1@Mem_Alloc:

; 80   : }

	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_newsize$1 = -16					; size = 4
_nb$ = -12						; size = 4
tv79 = -8						; size = 4
_memhdr$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_memptr$ = 12						; size = 4
_size$ = 16						; size = 4
_clear$ = 20						; size = 4
_filename$ = 24						; size = 4
_fileline$ = 28						; size = 4
__Mem_Realloc PROC

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 142  : 	memheader_t	*memhdr = NULL;

	mov	DWORD PTR _memhdr$[ebp], 0

; 143  : 	char		*nb;
; 144  : 
; 145  : 	if( size <= 0 ) return memptr; // no need to reallocate

	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $LN2@Mem_Reallo
	mov	eax, DWORD PTR _memptr$[ebp]
	jmp	$LN1@Mem_Reallo
$LN2@Mem_Reallo:

; 146  : 
; 147  : 	if( memptr )

	cmp	DWORD PTR _memptr$[ebp], 0
	je	SHORT $LN3@Mem_Reallo

; 148  : 	{
; 149  : 		memhdr = (memheader_t *)((byte *)memptr - sizeof( memheader_t ));

	mov	eax, DWORD PTR _memptr$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _memhdr$[ebp], eax

; 150  : 		if( size == memhdr->size ) return memptr;

	mov	ecx, DWORD PTR _memhdr$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@Mem_Reallo
	mov	eax, DWORD PTR _memptr$[ebp]
	jmp	SHORT $LN1@Mem_Reallo
$LN3@Mem_Reallo:

; 151  : 	}
; 152  : 
; 153  : 	nb = _Mem_Alloc( poolptr, size, clear, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clear$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poolptr$[ebp]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _nb$[ebp], eax

; 154  : 
; 155  : 	if( memptr ) // first allocate?

	cmp	DWORD PTR _memptr$[ebp], 0
	je	SHORT $LN5@Mem_Reallo

; 156  : 	{ 
; 157  : 		size_t newsize = memhdr->size < size ? memhdr->size : size; // upper data can be trucnated!

	mov	edx, DWORD PTR _memhdr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN7@Mem_Reallo
	mov	ecx, DWORD PTR _memhdr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN8@Mem_Reallo
$LN7@Mem_Reallo:
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv79[ebp], eax
$LN8@Mem_Reallo:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _newsize$1[ebp], ecx

; 158  : 		memcpy( nb, memptr, newsize );

	mov	edx, DWORD PTR _newsize$1[ebp]
	push	edx
	mov	eax, DWORD PTR _memptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nb$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 159  : 		_Mem_Free( memptr, filename, fileline ); // free unused old block

	mov	edx, DWORD PTR _fileline$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _memptr$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@Mem_Reallo:

; 160  :           }
; 161  : 
; 162  : 	return (void *)nb;

	mov	eax, DWORD PTR _nb$[ebp]
$LN1@Mem_Reallo:

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Realloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\zone.c
_TEXT	SEGMENT
_Memory_Init PROC

; 352  : {

	push	ebp
	mov	ebp, esp

; 353  : 	poolchain = NULL; // init mem chain

	mov	DWORD PTR _poolchain, 0

; 354  : }

	pop	ebp
	ret	0
_Memory_Init ENDP
_TEXT	ENDS
END
