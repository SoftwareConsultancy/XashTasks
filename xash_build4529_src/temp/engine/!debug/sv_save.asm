; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\server\sv_save.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnSaveGameComment
_BSS	SEGMENT
_pfnSaveGameComment DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG137241 DB	'mapName', 00H
$SG137242 DB	'comment', 00H
$SG137243 DB	'mapCount', 00H
	ORG $+3
$SG137271 DB	'skillLevel', 00H
	ORG $+1
$SG137272 DB	'entityCount', 00H
$SG137273 DB	'connectionCount', 00H
$SG137274 DB	'lightStyleCount', 00H
$SG137275 DB	'time', 00H
	ORG $+3
$SG137276 DB	'mapName', 00H
$SG137277 DB	'skyName', 00H
$SG137278 DB	'skyColor_r', 00H
	ORG $+1
$SG137279 DB	'skyColor_g', 00H
	ORG $+1
$SG137280 DB	'skyColor_b', 00H
	ORG $+1
$SG137281 DB	'skyVec_x', 00H
	ORG $+3
$SG137282 DB	'skyVec_y', 00H
	ORG $+3
$SG137283 DB	'skyVec_z', 00H
	ORG $+3
$SG137293 DB	'mapName', 00H
$SG137294 DB	'landmarkName', 00H
	ORG $+3
$SG137295 DB	'pentLandmark', 00H
	ORG $+3
$SG137296 DB	'vecLandmarkOrigin', 00H
	ORG $+2
$SG137304 DB	'index', 00H
	ORG $+2
$SG137305 DB	'style', 00H
	ORG $+2
$SG137306 DB	'time', 00H
	ORG $+3
$SG137318 DB	'id', 00H
	ORG $+1
$SG137319 DB	'location', 00H
	ORG $+3
$SG137320 DB	'size', 00H
	ORG $+3
$SG137321 DB	'flags', 00H
	ORG $+2
$SG137322 DB	'classname', 00H
	ORG $+2
$SG137344 DB	'decalCount', 00H
	ORG $+1
$SG137345 DB	'entityCount', 00H
$SG137346 DB	'soundCount', 00H
	ORG $+1
$SG137347 DB	'tempEntsCount', 00H
	ORG $+2
$SG137348 DB	'introTrack', 00H
	ORG $+1
$SG137349 DB	'mainTrack', 00H
	ORG $+2
$SG137350 DB	'trackPosition', 00H
	ORG $+2
$SG137351 DB	'viewentity', 00H
	ORG $+1
$SG137352 DB	'wateralpha', 00H
	ORG $+1
$SG137353 DB	'wateramp', 00H
	ORG $+3
$SG137372 DB	'position', 00H
	ORG $+3
$SG137373 DB	'name', 00H
	ORG $+3
$SG137374 DB	'entityIndex', 00H
$SG137375 DB	'depth', 00H
	ORG $+2
$SG137376 DB	'flags', 00H
	ORG $+2
$SG137377 DB	'scale', 00H
	ORG $+2
$SG137378 DB	'impactPlaneNormal', 00H
	ORG $+2
$SG137379 DB	'studio_state', 00H
	ORG $+3
$SG137450 DB	'messagenum', 00H
	ORG $+1
$SG137451 DB	'origin', 00H
	ORG $+1
$SG137452 DB	'angles', 00H
	ORG $+1
$SG137453 DB	'sequence', 00H
	ORG $+3
$SG137454 DB	'frame', 00H
	ORG $+2
$SG137455 DB	'colormap', 00H
	ORG $+3
$SG137456 DB	'skin', 00H
	ORG $+3
$SG137457 DB	'body', 00H
	ORG $+3
$SG137458 DB	'scale', 00H
	ORG $+2
$SG137459 DB	'effects', 00H
$SG137460 DB	'framerate', 00H
	ORG $+2
$SG137461 DB	'mins', 00H
	ORG $+3
$SG137462 DB	'maxs', 00H
	ORG $+3
$SG137463 DB	'rendermode', 00H
	ORG $+1
$SG137464 DB	'renderamt', 00H
	ORG $+2
$SG137465 DB	'rendercolor', 00H
$SG137466 DB	'renderfx', 00H
	ORG $+3
$SG137467 DB	'controller', 00H
	ORG $+1
$SG137468 DB	'blending', 00H
	ORG $+3
$SG137469 DB	'solid', 00H
	ORG $+2
$SG137470 DB	'animtime', 00H
	ORG $+3
$SG137471 DB	'movetype', 00H
	ORG $+3
$SG137472 DB	'vuser1', 00H
	ORG $+1
$SG137473 DB	'vuser2', 00H
	ORG $+1
$SG137474 DB	'vuser3', 00H
	ORG $+1
$SG137475 DB	'vuser4', 00H
	ORG $+1
$SG137476 DB	'iuser1', 00H
	ORG $+1
$SG137477 DB	'iuser2', 00H
	ORG $+1
$SG137478 DB	'iuser3', 00H
	ORG $+1
$SG137479 DB	'iuser4', 00H
	ORG $+1
$SG137480 DB	'fuser1', 00H
	ORG $+1
$SG137481 DB	'fuser2', 00H
	ORG $+1
$SG137482 DB	'fuser3', 00H
	ORG $+1
$SG137483 DB	'fuser4', 00H
	ORG $+1
$SG137509 DB	'name', 00H
	ORG $+3
$SG137510 DB	'entnum', 00H
	ORG $+1
$SG137511 DB	'origin', 00H
	ORG $+1
$SG137512 DB	'volume', 00H
	ORG $+1
$SG137513 DB	'attenuation', 00H
$SG137514 DB	'looping', 00H
$SG137515 DB	'channel', 00H
$SG137516 DB	'pitch', 00H
	ORG $+2
$SG137517 DB	'wordIndex', 00H
	ORG $+2
$SG137518 DB	'samplePos', 00H
	ORG $+2
$SG137519 DB	'forcedEnd', 00H
	ORG $+2
$SG137525 DB	'classname', 00H
	ORG $+2
$SG137526 DB	'globalname', 00H
_DATA	ENDS
PUBLIC	_SV_GetSaveComment
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetNumBytesLeft
PUBLIC	_SV_SaveGame
PUBLIC	_SV_LoadGame
PUBLIC	_SV_LoadGameState
PUBLIC	_SV_ChangeLevel
PUBLIC	_SV_GetLatestSave
PUBLIC	_SV_InitSaveRestore
PUBLIC	_SV_ClearGameState
PUBLIC	__real@00000000
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@437f0000
PUBLIC	__real@c0a00000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___localtime64:PROC
EXTRN	__imp__strftime:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_COM_FileWithoutPath:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Search:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_FS_Rename:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_FileCopy:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Host_CompareFileTime:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_LoadGame:PROC
EXTRN	_CL_Active:PROC
EXTRN	_pfnDecalIndex:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_IsIntermission:PROC
EXTRN	_SV_CreateDecal:PROC
EXTRN	_SV_RestoreCustomDecal:PROC
EXTRN	_R_CreateDecalList:PROC
EXTRN	_S_StreamGetCurrentState:PROC
EXTRN	_CL_HudMessage:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_GL_FreeImage:PROC
EXTRN	_fmod:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_SV_FinalMessage:PROC
EXTRN	_SV_InitGame:PROC
EXTRN	_SV_ActivateServer:PROC
EXTRN	_SV_SpawnServer:PROC
EXTRN	_SV_DeactivateServer:PROC
EXTRN	_SV_FreeOldEntities:PROC
EXTRN	_SV_InactivateClients:PROC
EXTRN	_SV_InitEdict:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_BuildSoundMsg:PROC
EXTRN	_SV_SpawnEntities:PROC
EXTRN	_SV_CreateNamedEntity:PROC
EXTRN	_SV_MakeString:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_MapIsValid:PROC
EXTRN	_SV_FindGlobalEntity:PROC
EXTRN	_SV_CreateStaticEntity:PROC
EXTRN	_pfnIndexOfEdict:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_Move:PROC
EXTRN	_SV_PointContents:PROC
EXTRN	_SV_SetLightStyle:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_S_GetCurrentDynamicSounds:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_newunit:BYTE
EXTRN	_sv_wateralpha:BYTE
EXTRN	_sv_wateramp:BYTE
EXTRN	_sv_skyname:BYTE
EXTRN	_sv_skycolor_r:BYTE
EXTRN	_sv_skycolor_g:BYTE
EXTRN	_sv_skycolor_b:BYTE
EXTRN	_sv_skyvec_x:BYTE
EXTRN	_sv_skyvec_y:BYTE
EXTRN	_sv_skyvec_z:BYTE
EXTRN	_skill:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
$SG137782 DB	01H DUP (?)
	ALIGN	4

$SG138345 DB	01H DUP (?)
	ALIGN	4

?savename@?1??SV_GetLatestSave@@9@9 DB 040H DUP (?)	; `SV_GetLatestSave'::`2'::savename
$SG138481 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
_gGameHeader DD	0eH
	DD	FLAT:$SG137241
	DD	00H
	DW	020H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137242
	DD	020H
	DW	050H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137243
	DD	070H
	DW	01H
	DW	00H
_gSaveHeader DD	0aH
	DD	FLAT:$SG137271
	DD	00H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137272
	DD	04H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137273
	DD	08H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137274
	DD	0cH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:$SG137275
	DD	010H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137276
	DD	014H
	DW	020H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137277
	DD	034H
	DW	020H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137278
	DD	054H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137279
	DD	058H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137280
	DD	05cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137281
	DD	060H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137282
	DD	064H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137283
	DD	068H
	DW	01H
	DW	00H
_gAdjacency DD	0eH
	DD	FLAT:$SG137293
	DD	00H
	DW	020H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137294
	DD	020H
	DW	020H
	DW	00H
	DD	06H
	DD	FLAT:$SG137295
	DD	040H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137296
	DD	044H
	DW	01H
	DW	00H
_gLightStyle DD	0aH
	DD	FLAT:$SG137304
	DD	00H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137305
	DD	04H
	DW	0100H
	DW	00H
	DD	00H
	DD	FLAT:$SG137306
	DD	0104H
	DW	01H
	DW	00H
_gEntityTable DD 0aH
	DD	FLAT:$SG137318
	DD	00H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137319
	DD	08H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137320
	DD	0cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137321
	DD	010H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137322
	DD	014H
	DW	01H
	DW	00H
_gSaveClient DD	0aH
	DD	FLAT:$SG137344
	DD	00H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137345
	DD	04H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137346
	DD	08H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137347
	DD	0cH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137348
	DD	010H
	DW	040H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137349
	DD	050H
	DW	040H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137350
	DD	090H
	DW	01H
	DW	00H
	DD	0dH
	DD	FLAT:$SG137351
	DD	094H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137352
	DD	098H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137353
	DD	09cH
	DW	01H
	DW	00H
_gDecalEntry DD	07H
	DD	FLAT:$SG137372
	DD	00H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137373
	DD	0cH
	DW	040H
	DW	00H
	DD	0dH
	DD	FLAT:$SG137374
	DD	04cH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137375
	DD	04eH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137376
	DD	04fH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137377
	DD	050H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137378
	DD	054H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137379
	DD	060H
	DW	01eH
	DW	00H
_gStaticEntry DD 010H
	DD	FLAT:$SG137450
	DD	0cH
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137451
	DD	010H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137452
	DD	01cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137453
	DD	02cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137454
	DD	030H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137455
	DD	034H
	DW	01H
	DW	00H
	DD	0dH
	DD	FLAT:$SG137456
	DD	038H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137457
	DD	064H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137458
	DD	040H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137459
	DD	03cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137460
	DD	060H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137461
	DD	07cH
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137462
	DD	088H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137463
	DD	048H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137464
	DD	04cH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137465
	DD	050H
	DW	03H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137466
	DD	054H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137467
	DD	068H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137468
	DD	06cH
	DW	01H
	DW	00H
	DD	0dH
	DD	FLAT:$SG137469
	DD	03aH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:$SG137470
	DD	05cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137471
	DD	058H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137472
	DD	0124H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137473
	DD	0130H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137474
	DD	013cH
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137475
	DD	0148H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137476
	DD	0104H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137477
	DD	0108H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137478
	DD	010cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:$SG137479
	DD	0110H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137480
	DD	0114H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137481
	DD	0118H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137482
	DD	011cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137483
	DD	0120H
	DW	01H
	DW	00H
_gSoundEntry DD	0eH
	DD	FLAT:$SG137509
	DD	00H
	DW	040H
	DW	00H
	DD	0dH
	DD	FLAT:$SG137510
	DD	040H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:$SG137511
	DD	044H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137512
	DD	050H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:$SG137513
	DD	054H
	DW	01H
	DW	00H
	DD	0cH
	DD	FLAT:$SG137514
	DD	058H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137515
	DD	05cH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137516
	DD	05dH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137517
	DD	05eH
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137518
	DD	060H
	DW	08H
	DW	00H
	DD	0eH
	DD	FLAT:$SG137519
	DD	068H
	DW	08H
	DW	00H
_gTempEntvars DD 01H
	DD	FLAT:$SG137525
	DD	00H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:$SG137526
	DD	04H
	DW	01H
	DW	01H
$SG137541 DB	'%-64.64s %02d:%02d', 00H
	ORG $+1
$SG137614 DB	'%s*.HL?', 00H
$SG137624 DB	'Not playing a local game.', 0aH, 00H
	ORG $+1
$SG137549 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137629 DB	'Savegame is not allowed.', 0aH, 00H
	ORG $+2
$SG137562 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137631 DB	'Can''t save if not active.', 0aH, 00H
	ORG $+1
$SG137604 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137613 DB	'save/', 00H
	ORG $+2
$SG137633 DB	'Can''t save during intermission.', 0aH, 00H
	ORG $+3
$SG137616 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137635 DB	'Can''t save multiplayer games.', 0aH, 00H
	ORG $+1
$SG137638 DB	'Can''t savegame without a player!', 0aH, 00H
	ORG $+2
$SG137641 DB	'Can''t savegame with a dead player', 0aH, 00H
	ORG $+1
$SG137642 DB	'Can''t savegame without a client!', 0aH, 00H
	ORG $+2
$SG137655 DB	'save/', 00H
	ORG $+2
$SG137656 DB	'%s%s%02d.sav', 00H
	ORG $+3
$SG137657 DB	'save/', 00H
	ORG $+2
$SG137658 DB	'%s%s%02d.bmp', 00H
	ORG $+3
$SG137661 DB	'save/', 00H
	ORG $+2
$SG137662 DB	'%s%s.sav', 00H
	ORG $+3
$SG137663 DB	'save/', 00H
	ORG $+2
$SG137664 DB	'%s%s.bmp', 00H
	ORG $+3
$SG137665 DB	'save/', 00H
	ORG $+2
$SG137666 DB	'%s%s%02d.sav', 00H
	ORG $+3
$SG137667 DB	'save/', 00H
	ORG $+2
$SG137668 DB	'%s%s%02d.bmp', 00H
	ORG $+3
$SG137669 DB	'save/', 00H
	ORG $+2
$SG137670 DB	'%s%s%02d.sav', 00H
	ORG $+3
$SG137671 DB	'save/', 00H
	ORG $+2
$SG137672 DB	'%s%s%02d.bmp', 00H
	ORG $+3
$SG137684 DB	'save%i%i%i', 00H
	ORG $+1
$SG137701 DB	'rb', 00H
	ORG $+1
$SG137702 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137718 DB	'save/', 00H
	ORG $+2
$SG137719 DB	'%s%s', 00H
	ORG $+3
$SG137720 DB	'wb', 00H
	ORG $+1
$SG137732 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137814 DB	'%s%s.HL2', 00H
	ORG $+3
$SG137733 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137816 DB	'rb', 00H
	ORG $+1
$SG137749 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137844 DB	'%s%s.HL1', 00H
	ORG $+3
$SG137751 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137845 DB	'Loading game from %s...', 0aH, 00H
	ORG $+3
$SG137752 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137813 DB	'save/', 00H
	ORG $+2
$SG137843 DB	'save/', 00H
	ORG $+2
$SG137847 DB	'rb', 00H
	ORG $+1
$SG137848 DB	'^1Error:^7 couldn''t open.', 0aH, 00H
	ORG $+1
$SG137870 DB	'ETABLE', 00H
	ORG $+1
$SG137871 DB	'Save Header', 00H
$SG137872 DB	'ADJACENCY', 00H
	ORG $+2
$SG137874 DB	'LIGHTSTYLE', 00H
	ORG $+1
$SG137895 DB	'save/', 00H
	ORG $+2
$SG137896 DB	'%s%s.HL3', 00H
	ORG $+3
$SG137898 DB	'wb', 00H
	ORG $+1
$SG137918 DB	'save/', 00H
	ORG $+2
$SG137919 DB	'%s%s.HL3', 00H
	ORG $+3
$SG137921 DB	'rb', 00H
	ORG $+1
$SG137946 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG137952 DB	'^1Error:^7 RestoreDecal: couldn''t restore entity index '
	DB	'%i', 0aH, 00H
	ORG $+1
$SG137948 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138009 DB	'DECALLIST', 00H
	ORG $+2
$SG137951 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138013 DB	'SOUNDLIST', 00H
	ORG $+2
$SG138003 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138015 DB	'%s%s.HL2', 00H
	ORG $+3
$SG138006 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138007 DB	'ClientHeader', 00H
	ORG $+3
$SG138014 DB	'save/', 00H
	ORG $+2
$SG138017 DB	'wb', 00H
	ORG $+1
$SG138011 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138012 DB	'STATICENTITY', 00H
	ORG $+3
$SG138059 DB	'save/', 00H
	ORG $+2
$SG138060 DB	'%s%s.HL2', 00H
	ORG $+3
$SG138062 DB	'rb', 00H
	ORG $+1
$SG138067 DB	'assert failed at %s:%i', 0aH, 00H
$SG138069 DB	'DECALLIST', 00H
	ORG $+2
$SG138066 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138068 DB	'ClientHeader', 00H
	ORG $+3
$SG138072 DB	'STATICENTITY', 00H
	ORG $+3
$SG138075 DB	'SOUNDLIST', 00H
	ORG $+2
$SG138079 DB	'music "%s" "%s" %i', 0aH, 00H
$SG138081 DB	'sv_wateralpha', 00H
	ORG $+2
$SG138082 DB	'sv_wateramp', 00H
$SG138113 DB	'^1Error:^7 ENTITY IS NOT A PLAYER: %d', 0aH, 00H
	ORG $+1
$SG138115 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138158 DB	'save/', 00H
	ORG $+2
$SG138159 DB	'%s%s.HL1', 00H
	ORG $+3
$SG138161 DB	'Save Header', 00H
$SG138162 DB	'ADJACENCY', 00H
	ORG $+2
$SG138164 DB	'LIGHTSTYLE', 00H
	ORG $+1
$SG138170 DB	'wb', 00H
	ORG $+1
$SG138166 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138168 DB	'ETABLE', 00H
	ORG $+1
$SG138188 DB	'skill', 00H
	ORG $+2
$SG138189 DB	'sv_skyname', 00H
	ORG $+1
$SG138190 DB	'sv_skycolor_r', 00H
	ORG $+2
$SG138191 DB	'sv_skycolor_g', 00H
	ORG $+2
$SG138192 DB	'sv_skycolor_b', 00H
	ORG $+2
$SG138193 DB	'sv_skyvec_x', 00H
$SG138194 DB	'sv_skyvec_y', 00H
$SG138195 DB	'sv_skyvec_z', 00H
$SG138218 DB	'save/', 00H
	ORG $+2
$SG138219 DB	'%s*.HL?', 00H
$SG138220 DB	'GameHeader', 00H
	ORG $+1
$SG138221 DB	'save/', 00H
	ORG $+2
$SG138222 DB	'%s%s.sav', 00H
	ORG $+3
$SG138225 DB	'quick', 00H
	ORG $+2
$SG138226 DB	'autosave', 00H
	ORG $+3
$SG138228 DB	'wb', 00H
	ORG $+1
$SG138229 DB	'saveshot "%s"', 0aH, 00H
	ORG $+1
$SG138230 DB	'Saving game to %s...', 0aH, 00H
	ORG $+2
$SG138248 DB	'GameHeader', 00H
	ORG $+1
$SG138267 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138270 DB	'ENTVARS', 00H
$SG138271 DB	'Merging changes for global: %s', 0aH, 00H
$SG138317 DB	'Level transition ERROR', 0aH, 'Can''t find connection to'
	DB	' %s from %s', 0aH, 00H
$SG138275 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138276 DB	'Transferring %s (%d)', 0aH, 00H
	ORG $+2
$SG138281 DB	'Suppressing %s', 0aH, 00H
$SG138342 DB	'^1Error:^7 server not running', 0aH, 00H
	ORG $+1
$SG138364 DB	'rb', 00H
	ORG $+1
$SG138369 DB	'^1Error:^7 map %s is invalid or not supported', 0aH, 00H
	ORG $+1
$SG138371 DB	'^1Error:^7 map %s doesn''t exist', 0aH, 00H
	ORG $+3
$SG138373 DB	'^1Error:^7 Couldn''t load %s', 0aH, 00H
	ORG $+3
$SG138374 DB	'Loading game from %s...', 0aH, 00H
	ORG $+3
$SG138375 DB	'1', 00H
	ORG $+2
$SG138376 DB	'maxplayers', 00H
	ORG $+1
$SG138377 DB	'deathmatch', 00H
	ORG $+1
$SG138378 DB	'coop', 00H
	ORG $+3
$SG138393 DB	'new', 00H
$SG138396 DB	'save/', 00H
	ORG $+2
$SG138397 DB	'%s%s.sav', 00H
	ORG $+3
$SG138399 DB	'^1Error:^7 no free slots for savegame', 0aH, 00H
	ORG $+1
$SG138400 DB	'save/', 00H
	ORG $+2
$SG138401 DB	'%s%s.bmp', 00H
	ORG $+3
$SG138403 DB	'GAMESAVED', 00H
	ORG $+2
$SG138420 DB	'save/', 00H
	ORG $+2
$SG138421 DB	'%s*.sav', 00H
$SG138480 DB	'rb', 00H
	ORG $+1
$SG138425 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138483 DB	'<corrupted>', 00H
$SG138485 DB	'old version Xash3D <unsupported>', 00H
	ORG $+3
$SG138487 DB	'<old version>', 00H
	ORG $+2
$SG138489 DB	'<invalid version>', 00H
	ORG $+2
$SG138492 DB	'<corrupted hashtable>', 00H
	ORG $+2
$SG138495 DB	'<corrupted hashtable>', 00H
	ORG $+2
$SG138496 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138501 DB	'GameHeader', 00H
	ORG $+1
$SG138499 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138502 DB	'<missing GameHeader>', 00H
	ORG $+3
$SG138509 DB	'comment', 00H
$SG138518 DB	'<map %s has invalid format>', 00H
$SG138504 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138520 DB	'<map %s is missed>', 00H
	ORG $+1
$SG138506 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138511 DB	'mapName', 00H
$SG138526 DB	'autosave', 00H
	ORG $+3
$SG138513 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138527 DB	'[autosave]', 00H
	ORG $+1
$SG138515 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\server\sv_save.c', 00H
$SG138523 DB	'quick', 00H
	ORG $+2
$SG138524 DB	'[quick]', 00H
$SG138528 DB	'%b%d %Y', 00H
$SG138529 DB	'%H:%M', 00H
	ORG $+2
$SG138530 DB	'<unknown version>', 00H
	ORG $+2
$SG138533 DB	'SV_SaveGameComment', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
tv174 = -1552						; size = 4
_foundprevious$ = -1548					; size = 4
_movedCount$ = -1544					; size = 4
_index$ = -1540						; size = 4
_test$ = -1536						; size = 4
_flags$ = -1532						; size = 4
_i$ = -1528						; size = 4
_pSaveData$ = -1524					; size = 4
_currentLevelData$ = -1520				; size = 1396
_header$ = -124						; size = 108
_landmarkOrigin$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pOldLevel$ = 8						; size = 4
_pLandmarkName$ = 12					; size = 4
_LoadAdjacentEnts PROC

; 1830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1552				; 00000610H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1831 : 	SAVE_HEADER	header;
; 1832 : 	SAVERESTOREDATA	currentLevelData, *pSaveData;
; 1833 : 	int		i, test, flags, index, movedCount = 0;

	mov	DWORD PTR _movedCount$[ebp], 0

; 1834 : 	qboolean		foundprevious = false;

	mov	DWORD PTR _foundprevious$[ebp], 0

; 1835 : 	vec3_t		landmarkOrigin;
; 1836 : 	
; 1837 : 	memset( &currentLevelData, 0, sizeof( SAVERESTOREDATA ));

	push	1396					; 00000574H
	push	0
	lea	eax, DWORD PTR _currentLevelData$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1838 : 	svgame.globals->pSaveData = &currentLevelData;

	mov	ecx, DWORD PTR _svgame+19236
	lea	edx, DWORD PTR _currentLevelData$[ebp]
	mov	DWORD PTR [ecx+156], edx

; 1839 : 	sv.loadgame = sv.paused = true;

	mov	DWORD PTR _sv+1359688, 1
	mov	eax, DWORD PTR _sv+1359688
	mov	DWORD PTR _sv+8, eax

; 1840 : 
; 1841 : 	// build the adjacent map list
; 1842 : 	svgame.dllFuncs.pfnParmsChangeLevel();

	call	DWORD PTR _svgame+19348

; 1843 : 
; 1844 : 	for( i = 0; i < currentLevelData.connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LoadAdjace
$LN2@LoadAdjace:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@LoadAdjace:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _currentLevelData$[ebp+36]
	jge	$LN3@LoadAdjace

; 1845 : 	{
; 1846 : 		// make sure the previous level is in the connection list so we can
; 1847 : 		// bring over the player.
; 1848 : 		if( !Q_stricmp( currentLevelData.levelList[i].mapName, pOldLevel ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pOldLevel$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	lea	edx, DWORD PTR _currentLevelData$[ebp+ecx+44]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@LoadAdjace

; 1849 : 			foundprevious = true;

	mov	DWORD PTR _foundprevious$[ebp], 1
$LN10@LoadAdjace:

; 1850 : 
; 1851 : 		for( test = 0; test < i; test++ )

	mov	DWORD PTR _test$[ebp], 0
	jmp	SHORT $LN7@LoadAdjace
$LN5@LoadAdjace:
	mov	eax, DWORD PTR _test$[ebp]
	add	eax, 1
	mov	DWORD PTR _test$[ebp], eax
$LN7@LoadAdjace:
	mov	ecx, DWORD PTR _test$[ebp]
	cmp	ecx, DWORD PTR _i$[ebp]
	jge	SHORT $LN6@LoadAdjace

; 1852 : 		{
; 1853 : 			// only do maps once
; 1854 : 			if( !Q_stricmp( currentLevelData.levelList[i].mapName, currentLevelData.levelList[test].mapName ))

	push	99999					; 0001869fH
	imul	edx, DWORD PTR _test$[ebp], 80
	lea	eax, DWORD PTR _currentLevelData$[ebp+edx+44]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	lea	edx, DWORD PTR _currentLevelData$[ebp+ecx+44]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@LoadAdjace

; 1855 : 				break;

	jmp	SHORT $LN6@LoadAdjace
$LN11@LoadAdjace:

; 1856 : 		}

	jmp	SHORT $LN5@LoadAdjace
$LN6@LoadAdjace:

; 1857 : 
; 1858 : 		// map was already in the list
; 1859 : 		if( test < i ) continue;

	mov	eax, DWORD PTR _test$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $LN12@LoadAdjace
	jmp	$LN2@LoadAdjace
$LN12@LoadAdjace:

; 1860 : 
; 1861 : 		pSaveData = LoadSaveData( currentLevelData.levelList[i].mapName );

	imul	ecx, DWORD PTR _i$[ebp], 80
	lea	edx, DWORD PTR _currentLevelData$[ebp+ecx+44]
	push	edx
	call	_LoadSaveData
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1862 : 
; 1863 : 		if( pSaveData )

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	$LN13@LoadAdjace

; 1864 : 		{
; 1865 : 			ParseSaveTables( pSaveData, &header, false );

	push	0
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_ParseSaveTables
	add	esp, 12					; 0000000cH

; 1866 : 			EntityPatchRead( pSaveData, currentLevelData.levelList[i].mapName );

	imul	edx, DWORD PTR _i$[ebp], 80
	lea	eax, DWORD PTR _currentLevelData$[ebp+edx+44]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_EntityPatchRead
	add	esp, 8

; 1867 : 
; 1868 : 			pSaveData->time = sv.time; // - header.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	DWORD PTR [edx+1360], xmm0

; 1869 : 			pSaveData->fUseLandmark = true;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+1324], 1

; 1870 : 			flags = movedCount = 0;

	mov	DWORD PTR _movedCount$[ebp], 0
	mov	ecx, DWORD PTR _movedCount$[ebp]
	mov	DWORD PTR _flags$[ebp], ecx

; 1871 : 			index = -1;

	mov	DWORD PTR _index$[ebp], -1

; 1872 : 
; 1873 : 			// calculate landmark offset
; 1874 : 			LandmarkOrigin( &currentLevelData, landmarkOrigin, pLandmarkName );

	mov	edx, DWORD PTR _pLandmarkName$[ebp]
	push	edx
	lea	eax, DWORD PTR _landmarkOrigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentLevelData$[ebp]
	push	ecx
	call	_LandmarkOrigin
	add	esp, 12					; 0000000cH

; 1875 : 			LandmarkOrigin( pSaveData, pSaveData->vecLandmarkOffset, pLandmarkName );

	mov	edx, DWORD PTR _pLandmarkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 1348				; 00000544H
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_LandmarkOrigin
	add	esp, 12					; 0000000cH

; 1876 : 			VectorSubtract( landmarkOrigin, pSaveData->vecLandmarkOffset, pSaveData->vecLandmarkOffset );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _landmarkOrigin$[ebp+eax]
	subss	xmm0, DWORD PTR [ecx+edx+1348]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	DWORD PTR [ecx+eax+1348], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _landmarkOrigin$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+1348]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	movss	DWORD PTR [eax+edx+1348], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _landmarkOrigin$[ebp+ecx]
	subss	xmm0, DWORD PTR [eax+edx+1348]
	movss	DWORD PTR tv174[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR [edx+ecx+1348], xmm0

; 1877 : 
; 1878 : 			if( !Q_stricmp( currentLevelData.levelList[i].mapName, pOldLevel ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pOldLevel$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	lea	edx, DWORD PTR _currentLevelData$[ebp+ecx+44]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@LoadAdjace

; 1879 : 				SetBits( flags, FENTTABLE_PLAYER );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, -2147483648			; 80000000H
	mov	DWORD PTR _flags$[ebp], eax
$LN14@LoadAdjace:

; 1880 : 
; 1881 : 			while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN9@LoadAdjace

; 1882 : 			{
; 1883 : 				index = EntryInTable( pSaveData, sv.name, index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET _sv+56
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_EntryInTable
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _index$[ebp], eax

; 1884 : 				if( index < 0 ) break;

	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $LN15@LoadAdjace
	jmp	SHORT $LN9@LoadAdjace
$LN15@LoadAdjace:

; 1885 : 				SetBits( flags, BIT( index ));

	mov	edx, 1
	mov	ecx, DWORD PTR _index$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _flags$[ebp], edx

; 1886 : 			}

	jmp	SHORT $LN14@LoadAdjace
$LN9@LoadAdjace:

; 1887 : 
; 1888 : 			if( flags ) movedCount = CreateEntityTransitionList( pSaveData, flags );

	cmp	DWORD PTR _flags$[ebp], 0
	je	SHORT $LN16@LoadAdjace
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_CreateEntityTransitionList
	add	esp, 8
	mov	DWORD PTR _movedCount$[ebp], eax
$LN16@LoadAdjace:

; 1889 : 
; 1890 : 			// if ents were moved, rewrite entity table to save file
; 1891 : 			if( movedCount ) EntityPatchWrite( pSaveData, currentLevelData.levelList[i].mapName );

	cmp	DWORD PTR _movedCount$[ebp], 0
	je	SHORT $LN17@LoadAdjace
	imul	edx, DWORD PTR _i$[ebp], 80
	lea	eax, DWORD PTR _currentLevelData$[ebp+edx+44]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_EntityPatchWrite
	add	esp, 8
$LN17@LoadAdjace:

; 1892 : 
; 1893 : 			// move the decals from another level
; 1894 : 			LoadClientState( pSaveData, currentLevelData.levelList[i].mapName, true, true );

	push	1
	push	1
	imul	edx, DWORD PTR _i$[ebp], 80
	lea	eax, DWORD PTR _currentLevelData$[ebp+edx+44]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_LoadClientState
	add	esp, 16					; 00000010H

; 1895 : 
; 1896 : 			SaveFinish( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_SaveFinish
	add	esp, 4
$LN13@LoadAdjace:

; 1897 : 		}
; 1898 : 	}

	jmp	$LN2@LoadAdjace
$LN3@LoadAdjace:

; 1899 : 
; 1900 : 	svgame.globals->pSaveData = NULL;

	mov	eax, DWORD PTR _svgame+19236
	mov	DWORD PTR [eax+156], 0

; 1901 : 
; 1902 : 	if( !foundprevious )

	cmp	DWORD PTR _foundprevious$[ebp], 0
	jne	SHORT $LN18@LoadAdjace

; 1903 : 		Host_Error( "Level transition ERROR\nCan't find connection to %s from %s\n", pOldLevel, sv.name );

	push	OFFSET _sv+56
	mov	ecx, DWORD PTR _pOldLevel$[ebp]
	push	ecx
	push	OFFSET $SG138317
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN18@LoadAdjace:

; 1904 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadAdjacentEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pNewEnt$1 = -700					; size = 4
_movedCount$ = -696					; size = 4
_i$ = -692						; size = 4
_pent$ = -688						; size = 4
_pTable$ = -684						; size = 4
_tmpVars$2 = -680					; size = 676
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_levelMask$ = 12					; size = 4
_CreateEntityTransitionList PROC

; 1735 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 700				; 000002bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1736 : 	int		i, movedCount;
; 1737 : 	ENTITYTABLE	*pTable;
; 1738 : 	edict_t		*pent;
; 1739 : 
; 1740 : 	movedCount = 0;

	mov	DWORD PTR _movedCount$[ebp], 0

; 1741 : 
; 1742 : 	// create entity list
; 1743 : 	CreateEntitiesInRestoreList( pSaveData, levelMask, false );

	push	0
	mov	eax, DWORD PTR _levelMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_CreateEntitiesInRestoreList
	add	esp, 12					; 0000000cH

; 1744 : 
; 1745 : 	// now spawn entities
; 1746 : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CreateEnti
$LN2@CreateEnti:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@CreateEnti:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$LN3@CreateEnti

; 1747 : 	{
; 1748 : 		pTable = &pSaveData->pTable[i];

	imul	edx, DWORD PTR _i$[ebp], 24
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	edx, DWORD PTR [eax+40]
	mov	DWORD PTR _pTable$[ebp], edx

; 1749 : 		pSaveData->pCurrentData = pSaveData->pBaseData + pTable->location;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pTable$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1750 : 		pSaveData->size = pTable->location;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 1751 : 		pSaveData->currentIndex = i;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+28], eax

; 1752 : 		pent = pTable->pent;

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pent$[ebp], edx

; 1753 : 
; 1754 : 		if( SV_IsValidEdict( pent ) && FBitSet( pTable->flags, levelMask )) // screen out the player if he's not to be spawned

	push	1754					; 000006daH
	push	OFFSET $SG138267
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@CreateEnti
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, DWORD PTR _levelMask$[ebp]
	je	$LN5@CreateEnti

; 1755 : 		{
; 1756 : 			if( FBitSet( pTable->flags, FENTTABLE_GLOBAL ))

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 268435456				; 10000000H
	je	$LN6@CreateEnti

; 1757 : 			{
; 1758 : 				entvars_t	tmpVars;
; 1759 : 				edict_t	*pNewEnt;
; 1760 : 
; 1761 : 				// NOTE: we need to update table pointer so decals on the global entities with brush models can be
; 1762 : 				// correctly moved. found the classname and the globalname for our globalentity
; 1763 : 				svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ENTVARS", &tmpVars, gTempEntvars, ARRAYSIZE_XASH( gTempEntvars ));

	push	2
	push	OFFSET _gTempEntvars
	lea	edx, DWORD PTR _tmpVars$2[ebp]
	push	edx
	push	OFFSET $SG138270
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 1764 : 
; 1765 : 				// reset the save pointers, so dll can read this too
; 1766 : 				pSaveData->pCurrentData = pSaveData->pBaseData + pTable->location;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pTable$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1767 : 				pSaveData->size = pTable->location;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 1768 : 
; 1769 : 				// IMPORTANT: we should find the already spawned or local restored global entity
; 1770 : 				pNewEnt = SV_FindGlobalEntity( tmpVars.classname, tmpVars.globalname );

	mov	edx, DWORD PTR _tmpVars$2[ebp+4]
	push	edx
	mov	eax, DWORD PTR _tmpVars$2[ebp]
	push	eax
	call	_SV_FindGlobalEntity
	add	esp, 8
	mov	DWORD PTR _pNewEnt$1[ebp], eax

; 1771 : 
; 1772 : 				Con_DPrintf( "Merging changes for global: %s\n", STRING( pTable->classname ));

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET $SG138271
	call	_Con_DPrintf
	add	esp, 8

; 1773 : 
; 1774 : 				// -------------------------------------------------------------------------
; 1775 : 				// Pass the "global" flag to the DLL to indicate this entity should only override
; 1776 : 				// a matching entity, not be spawned
; 1777 : 				if( svgame.dllFuncs.pfnRestore( pent, pSaveData, 1 ) > 0 )

	push	1
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19272
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN8@CreateEnti

; 1778 : 				{
; 1779 : 					movedCount++;

	mov	edx, DWORD PTR _movedCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _movedCount$[ebp], edx

; 1780 : 				}

	jmp	SHORT $LN9@CreateEnti
$LN8@CreateEnti:

; 1781 : 				else
; 1782 : 				{
; 1783 : 					if( SV_IsValidEdict( pNewEnt )) // update the table so decals can find parent entity

	push	1783					; 000006f7H
	push	OFFSET $SG138275
	mov	eax, DWORD PTR _pNewEnt$1[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@CreateEnti

; 1784 : 						pTable->pent = pNewEnt;

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR _pNewEnt$1[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN10@CreateEnti:

; 1785 : 					SetBits( pent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [edx+548], ecx
$LN9@CreateEnti:

; 1786 : 				}
; 1787 : 			}

	jmp	$LN7@CreateEnti
$LN6@CreateEnti:

; 1788 : 			else 
; 1789 : 			{
; 1790 : 				Con_Reportf( "Transferring %s (%d)\n", STRING( pTable->classname ), NUM_FOR_EDICT( pent ));

	mov	eax, DWORD PTR _pent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET $SG138276
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 1791 : 
; 1792 : 				if( svgame.dllFuncs.pfnRestore( pent, pSaveData, 0 ) < 0 )

	push	0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19272
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN11@CreateEnti

; 1793 : 				{
; 1794 : 					SetBits( pent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [edx+548], ecx

; 1795 : 				}

	jmp	SHORT $LN7@CreateEnti
$LN11@CreateEnti:

; 1796 : 				else
; 1797 : 				{
; 1798 : 					if( !FBitSet( pTable->flags, FENTTABLE_PLAYER ) && EntityInSolid( pent ))

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN13@CreateEnti
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_EntityInSolid
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@CreateEnti

; 1799 : 					{
; 1800 : 						// this can happen during normal processing - PVS is just a guess,
; 1801 : 						// some map areas won't exist in the new map
; 1802 : 						Con_Reportf( "Suppressing %s\n", STRING( pTable->classname ));

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET $SG138281
	call	_Con_Reportf
	add	esp, 8

; 1803 : 						SetBits( pent->v.flags, FL_KILLME );

	mov	edx, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [edx+548]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [ecx+548], eax

; 1804 : 					}

	jmp	SHORT $LN7@CreateEnti
$LN13@CreateEnti:

; 1805 : 					else
; 1806 : 					{
; 1807 : 						pTable->flags = FENTTABLE_REMOVED;

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [edx+16], 1073741824		; 40000000H

; 1808 : 						movedCount++;

	mov	eax, DWORD PTR _movedCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _movedCount$[ebp], eax
$LN7@CreateEnti:

; 1809 : 					}
; 1810 : 				}
; 1811 : 			}
; 1812 : 
; 1813 : 			// remove any entities that were removed using UTIL_Remove()
; 1814 : 			// as a result of the above calls to UTIL_RemoveImmediate()
; 1815 : 			SV_FreeOldEntities ();

	call	_SV_FreeOldEntities
$LN5@CreateEnti:

; 1816 : 		}
; 1817 : 	}

	jmp	$LN2@CreateEnti
$LN3@CreateEnti:

; 1818 : 
; 1819 : 	return movedCount;

	mov	eax, DWORD PTR _movedCount$[ebp]

; 1820 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateEntityTransitionList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_version$ = -24						; size = 4
_id$ = -20						; size = 4
_size$ = -16						; size = 4
_tokenSize$ = -12					; size = 4
_tokenCount$ = -8					; size = 4
_pSaveData$ = -4					; size = 4
_pFile$ = 8						; size = 4
_pHeader$ = 12						; size = 4
_SaveReadHeader PROC

; 1682 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1683 : 	int		tokenCount, tokenSize;
; 1684 : 	int		size, id, version;
; 1685 : 	SAVERESTOREDATA	*pSaveData;
; 1686 : 
; 1687 : 	FS_Read( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1688 : 	if( id != SAVEGAME_HEADER )

	cmp	DWORD PTR _id$[ebp], 1447121738		; 5641534aH
	je	SHORT $LN2@SaveReadHe

; 1689 : 	{
; 1690 : 		FS_Close( pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 1691 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SaveReadHe
$LN2@SaveReadHe:

; 1692 : 	}
; 1693 : 		
; 1694 : 	FS_Read( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1695 : 	if( version != SAVEGAME_VERSION )

	cmp	DWORD PTR _version$[ebp], 113		; 00000071H
	je	SHORT $LN3@SaveReadHe

; 1696 : 	{
; 1697 : 		FS_Close( pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 1698 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SaveReadHe
$LN3@SaveReadHe:

; 1699 : 	}
; 1700 : 
; 1701 : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1702 : 	FS_Read( pFile, &tokenCount, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _tokenCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1703 : 	FS_Read( pFile, &tokenSize, sizeof( int ));

	push	4
	lea	ecx, DWORD PTR _tokenSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1704 : 
; 1705 : 	pSaveData = SaveInit( size + tokenSize, tokenCount );

	mov	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, DWORD PTR _tokenSize$[ebp]
	push	ecx
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1706 : 	pSaveData->tokenCount = tokenCount;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1707 : 	pSaveData->tokenSize = tokenSize;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1708 : 
; 1709 : 	// Parse the symbol table
; 1710 : 	BuildHashTable( pSaveData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_BuildHashTable
	add	esp, 8

; 1711 : 
; 1712 : 	// Set up the restore basis
; 1713 : 	pSaveData->fUseLandmark = false;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx+1324], 0

; 1714 : 	pSaveData->time = 0.0f;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1360], xmm0

; 1715 : 
; 1716 : 	FS_Read( pFile, pSaveData->pBaseData, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1717 : 
; 1718 : 	svgame.dllFuncs.pfnSaveReadFields( pSaveData, "GameHeader", pHeader, gGameHeader, ARRAYSIZE_XASH( gGameHeader ));	

	push	3
	push	OFFSET _gGameHeader
	mov	edx, DWORD PTR _pHeader$[ebp]
	push	edx
	push	OFFSET $SG138248
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 1719 : 
; 1720 : 	svgame.dllFuncs.pfnRestoreGlobalState( pSaveData );

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19292
	add	esp, 4

; 1721 : 
; 1722 : 	SaveFinish( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_SaveFinish
	add	esp, 4

; 1723 : 
; 1724 : 	return 1;

	mov	eax, 1
$LN1@SaveReadHe:

; 1725 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SaveReadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pTokenData$ = -268					; size = 4
_version$ = -264					; size = 4
_id$ = -260						; size = 4
_pFile$ = -256						; size = 4
_pSaveData$ = -252					; size = 4
_gameHeader$ = -248					; size = 116
_hlPath$ = -132						; size = 64
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveName$ = 8						; size = 4
_pSaveComment$ = 12					; size = 4
_SaveGameSlot PROC

; 1606 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1607 : 	char		hlPath[MAX_QPATH];
; 1608 : 	char		name[MAX_QPATH];
; 1609 : 	int		id, version;
; 1610 : 	char		*pTokenData;
; 1611 : 	SAVERESTOREDATA	*pSaveData;
; 1612 : 	GAME_HEADER	gameHeader;
; 1613 : 	file_t		*pFile;
; 1614 : 
; 1615 : 	pSaveData = SaveGameState( false );

	push	0
	call	_SaveGameState
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1616 : 	if( !pSaveData ) return 0;

	cmp	DWORD PTR _pSaveData$[ebp], 0
	jne	SHORT $LN2@SaveGameSl
	xor	eax, eax
	jmp	$LN1@SaveGameSl
$LN2@SaveGameSl:

; 1617 : 
; 1618 : 	SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1619 : 	pSaveData = SaveInit( SAVE_HEAPSIZE, SAVE_HASHSTRINGS ); // re-init the buffer

	push	4095					; 00000fffH
	push	4194304					; 00400000H
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1620 : 
; 1621 : 	Q_snprintf( hlPath, sizeof( hlPath ), "%s*.HL?", DEFAULT_SAVE_DIRECTORY );

	push	OFFSET $SG138218
	push	OFFSET $SG138219
	push	64					; 00000040H
	lea	ecx, DWORD PTR _hlPath$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1622 : 	Q_strncpy( gameHeader.mapName, sv.name, sizeof( gameHeader.mapName )); // get the name of level where a player

	push	32					; 00000020H
	push	OFFSET _sv+56
	lea	edx, DWORD PTR _gameHeader$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1623 : 	Q_strncpy( gameHeader.comment, pSaveComment, sizeof( gameHeader.comment ));

	push	80					; 00000050H
	mov	eax, DWORD PTR _pSaveComment$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gameHeader$[ebp+32]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1624 : 	gameHeader.mapCount = DirectoryCount( hlPath ); // counting all the adjacency maps

	lea	edx, DWORD PTR _hlPath$[ebp]
	push	edx
	call	_DirectoryCount
	add	esp, 4
	mov	DWORD PTR _gameHeader$[ebp+112], eax

; 1625 : 
; 1626 : 	// Store the game header
; 1627 : 	svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "GameHeader", &gameHeader, gGameHeader, ARRAYSIZE_XASH( gGameHeader ));

	push	3
	push	OFFSET _gGameHeader
	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	push	OFFSET $SG138220
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H

; 1628 : 
; 1629 : 	// Write the game globals
; 1630 : 	svgame.dllFuncs.pfnSaveGlobalState( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19288
	add	esp, 4

; 1631 : 
; 1632 : 	// Write entity string token table
; 1633 : 	pTokenData = StoreHashTable( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_StoreHashTable
	add	esp, 4
	mov	DWORD PTR _pTokenData$[ebp], eax

; 1634 : 
; 1635 : 	Q_snprintf( name, sizeof( name ), "%s%s.sav", DEFAULT_SAVE_DIRECTORY, pSaveName );

	mov	ecx, DWORD PTR _pSaveName$[ebp]
	push	ecx
	push	OFFSET $SG138221
	push	OFFSET $SG138222
	push	64					; 00000040H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1636 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1637 : 
; 1638 : 	// output to disk
; 1639 : 	if( !Q_stricmp( pSaveName, "quick" ) || !Q_stricmp( pSaveName, "autosave" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138225
	mov	ecx, DWORD PTR _pSaveName$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@SaveGameSl
	push	99999					; 0001869fH
	push	OFFSET $SG138226
	mov	edx, DWORD PTR _pSaveName$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SaveGameSl
$LN4@SaveGameSl:

; 1640 : 		AgeSaveList( pSaveName, SAVE_AGED_COUNT );

	push	2
	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	call	_AgeSaveList
	add	esp, 8
$LN3@SaveGameSl:

; 1641 : 
; 1642 : 	// output to disk
; 1643 : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET $SG138228
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN5@SaveGameSl

; 1644 : 	{
; 1645 : 		// something bad is happens
; 1646 : 		SaveFinish( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_SaveFinish
	add	esp, 4

; 1647 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SaveGameSl
$LN5@SaveGameSl:

; 1648 : 	}
; 1649 : 
; 1650 : 	// pending the preview image for savegame
; 1651 : 	Cbuf_AddText( va( "saveshot \"%s\"\n", pSaveName ));

	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	push	OFFSET $SG138229
	call	_va
	add	esp, 8
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 1652 : 	Con_Printf( "Saving game to %s...\n", name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG138230
	call	_Con_Printf
	add	esp, 8

; 1653 : 
; 1654 : 	version = SAVEGAME_VERSION;

	mov	DWORD PTR _version$[ebp], 113		; 00000071H

; 1655 : 	id = SAVEGAME_HEADER;

	mov	DWORD PTR _id$[ebp], 1447121738		; 5641534aH

; 1656 : 
; 1657 : 	FS_Write( pFile, &id, sizeof( id ));

	push	4
	lea	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1658 : 	FS_Write( pFile, &version, sizeof( version ));

	push	4
	lea	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1659 : 	FS_Write( pFile, &pSaveData->size, sizeof( int )); // does not include token table

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1660 : 
; 1661 : 	// write out the tokens first so we can load them before we load the entities
; 1662 : 	FS_Write( pFile, &pSaveData->tokenCount, sizeof( int ));

	push	4
	mov	edx, DWORD PTR _pSaveData$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1663 : 	FS_Write( pFile, &pSaveData->tokenSize, sizeof( int ));

	push	4
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1664 : 	FS_Write( pFile, pTokenData, pSaveData->tokenSize );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pTokenData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1665 : 	FS_Write( pFile, pSaveData->pBaseData, pSaveData->size ); // header and globals

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1666 : 
; 1667 : 	DirectoryCopy( hlPath, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _hlPath$[ebp]
	push	ecx
	call	_DirectoryCopy
	add	esp, 8

; 1668 : 	SaveFinish( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_SaveFinish
	add	esp, 4

; 1669 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1670 : 
; 1671 : 	return 1;

	mov	eax, 1
$LN1@SaveGameSl:

; 1672 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveGameSlot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pTable$ = -128						; size = 4
_pent$ = -124						; size = 4
_i$ = -120						; size = 4
_pSaveData$ = -116					; size = 4
_header$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_changelevel$ = 12					; size = 4
_LoadGameState PROC

; 1532 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1533 : 	SAVERESTOREDATA	*pSaveData;
; 1534 : 	ENTITYTABLE	*pTable;
; 1535 : 	SAVE_HEADER	header;
; 1536 : 	edict_t		*pent;
; 1537 : 	int		i;
; 1538 : 
; 1539 : 	pSaveData = LoadSaveData( level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_LoadSaveData
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1540 : 	if( !pSaveData ) return 0; // couldn't load the file

	cmp	DWORD PTR _pSaveData$[ebp], 0
	jne	SHORT $LN5@LoadGameSt
	xor	eax, eax
	jmp	$LN1@LoadGameSt
$LN5@LoadGameSt:

; 1541 : 
; 1542 : 	ParseSaveTables( pSaveData, &header, true );

	push	1
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_ParseSaveTables
	add	esp, 12					; 0000000cH

; 1543 : 	EntityPatchRead( pSaveData, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_EntityPatchRead
	add	esp, 8

; 1544 : 
; 1545 : 	// pause until all clients connect
; 1546 : 	sv.loadgame = sv.paused = true;

	mov	DWORD PTR _sv+1359688, 1
	mov	edx, DWORD PTR _sv+1359688
	mov	DWORD PTR _sv+8, edx

; 1547 : 
; 1548 : 	Cvar_SetValue( "skill", header.skillLevel );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138188
	call	_Cvar_SetValue
	add	esp, 8

; 1549 : 	Q_strncpy( sv.name, header.mapName, sizeof( sv.name ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _header$[ebp+20]
	push	eax
	push	OFFSET _sv+56
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1550 : 	svgame.globals->mapname = MAKE_STRING( sv.name );

	push	OFFSET _sv+56
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _svgame+19236
	mov	DWORD PTR [ecx+12], eax

; 1551 : 	Cvar_Set( "sv_skyname", header.skyName );

	lea	edx, DWORD PTR _header$[ebp+52]
	push	edx
	push	OFFSET $SG138189
	call	_Cvar_Set
	add	esp, 8

; 1552 : 
; 1553 : 	// restore sky parms
; 1554 : 	Cvar_SetValue( "sv_skycolor_r", header.skyColor_r );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp+84]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138190
	call	_Cvar_SetValue
	add	esp, 8

; 1555 : 	Cvar_SetValue( "sv_skycolor_g", header.skyColor_g );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp+88]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138191
	call	_Cvar_SetValue
	add	esp, 8

; 1556 : 	Cvar_SetValue( "sv_skycolor_b", header.skyColor_b );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp+92]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138192
	call	_Cvar_SetValue

; 1557 : 	Cvar_SetValue( "sv_skyvec_x", header.skyVec_x );

	add	esp, 4
	movss	xmm0, DWORD PTR _header$[ebp+96]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138193
	call	_Cvar_SetValue

; 1558 : 	Cvar_SetValue( "sv_skyvec_y", header.skyVec_y );

	add	esp, 4
	movss	xmm0, DWORD PTR _header$[ebp+100]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138194
	call	_Cvar_SetValue

; 1559 : 	Cvar_SetValue( "sv_skyvec_z", header.skyVec_z );

	add	esp, 4
	movss	xmm0, DWORD PTR _header$[ebp+104]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138195
	call	_Cvar_SetValue
	add	esp, 8

; 1560 : 
; 1561 : 	// create entity list
; 1562 : 	CreateEntitiesInRestoreList( pSaveData, 0, true );

	push	1
	push	0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_CreateEntitiesInRestoreList
	add	esp, 12					; 0000000cH

; 1563 : 
; 1564 : 	// now spawn entities
; 1565 : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LoadGameSt
$LN2@LoadGameSt:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@LoadGameSt:
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN3@LoadGameSt

; 1566 : 	{
; 1567 : 		pTable = &pSaveData->pTable[i];

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _pSaveData$[ebp]
	add	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR _pTable$[ebp], ecx

; 1568 : 		pSaveData->pCurrentData = pSaveData->pBaseData + pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pTable$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1569 : 		pSaveData->size = pTable->location;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 1570 : 		pSaveData->currentIndex = i;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 1571 : 		pent = pTable->pent;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pent$[ebp], ecx

; 1572 : 
; 1573 : 		if( pent != NULL )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN7@LoadGameSt

; 1574 : 		{
; 1575 : 			if( svgame.dllFuncs.pfnRestore( pent, pSaveData, 0 ) < 0 )

	push	0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19272
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN7@LoadGameSt

; 1576 : 			{
; 1577 : 				SetBits( pent->v.flags, FL_KILLME );

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax+548], edx

; 1578 : 				pTable->pent = NULL;

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN7@LoadGameSt:

; 1579 : 			}
; 1580 : 			else
; 1581 : 			{
; 1582 : 				// force the entity to be relinked
; 1583 : //				SV_LinkEdict( pent, false );
; 1584 : 			}
; 1585 : 		}
; 1586 : 	}

	jmp	$LN2@LoadGameSt
$LN3@LoadGameSt:

; 1587 : 
; 1588 : 	LoadClientState( pSaveData, level, changelevel, false );

	push	0
	mov	edx, DWORD PTR _changelevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_LoadClientState
	add	esp, 16					; 00000010H

; 1589 : 
; 1590 : 	SaveFinish( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_SaveFinish
	add	esp, 4

; 1591 : 
; 1592 : 	// restore server time
; 1593 : 	sv.time = header.time;

	cvtss2sd xmm0, DWORD PTR _header$[ebp+16]
	movsd	QWORD PTR _sv+16, xmm0

; 1594 : 	
; 1595 : 	return 1;

	mov	eax, 1
$LN1@LoadGameSt:

; 1596 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pTableData$ = -480					; size = 4
_tableSize$ = -476					; size = 4
_pTokenData$ = -472					; size = 4
_version$ = -468					; size = 4
_id$ = -464						; size = 4
_dataSize$ = -460					; size = 4
_pTable$ = -456						; size = 4
_pFile$ = -452						; size = 4
_i$ = -448						; size = 4
_pSaveData$ = -444					; size = 4
_light$ = -440						; size = 264
_header$ = -176						; size = 108
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_changelevel$ = 8					; size = 4
_SaveGameState PROC

; 1381 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1382 : 	char		name[MAX_QPATH];
; 1383 : 	int		i, id, version;
; 1384 : 	char		*pTableData;
; 1385 : 	char		*pTokenData;
; 1386 : 	SAVERESTOREDATA	*pSaveData;
; 1387 : 	int		tableSize;
; 1388 : 	int		dataSize;
; 1389 : 	ENTITYTABLE	*pTable;
; 1390 : 	SAVE_HEADER	header;
; 1391 : 	SAVE_LIGHTSTYLE	light;
; 1392 : 	file_t		*pFile;
; 1393 : 
; 1394 : 	if( !svgame.dllFuncs.pfnParmsChangeLevel )

	cmp	DWORD PTR _svgame+19348, 0
	jne	SHORT $LN17@SaveGameSt

; 1395 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SaveGameSt
$LN17@SaveGameSt:

; 1396 : 
; 1397 : 	pSaveData = SaveInit( SAVE_HEAPSIZE, SAVE_HASHSTRINGS );

	push	4095					; 00000fffH
	push	4194304					; 00400000H
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1398 : 
; 1399 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL1", DEFAULT_SAVE_DIRECTORY, sv.name );

	push	OFFSET _sv+56
	push	OFFSET $SG138158
	push	OFFSET $SG138159
	push	64					; 00000040H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1400 : 	COM_FixSlashes( name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_FixSlashes
	add	esp, 4

; 1401 : 
; 1402 : 	// initialize entity table to count moved entities
; 1403 : 	InitEntityTable( pSaveData, svgame.numEntities );

	mov	edx, DWORD PTR _svgame+7932
	push	edx
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_InitEntityTable
	add	esp, 8

; 1404 : 
; 1405 : 	// Build the adjacent map list
; 1406 : 	svgame.dllFuncs.pfnParmsChangeLevel();

	call	DWORD PTR _svgame+19348

; 1407 : 
; 1408 : 	// Write the global data
; 1409 : 	header.skillLevel = (int)skill.value;	// this is created from an int even though it's a float

	cvttss2si ecx, DWORD PTR _skill+12
	mov	DWORD PTR _header$[ebp], ecx

; 1410 : 	header.entityCount = pSaveData->tableCount;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _header$[ebp+4], eax

; 1411 : 	header.connectionCount = pSaveData->connectionCount;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _header$[ebp+8], edx

; 1412 : 	header.time = svgame.globals->time;	// use DLL time

	mov	eax, DWORD PTR _svgame+19236
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _header$[ebp+16], xmm0

; 1413 : 	Q_strncpy( header.mapName, sv.name, sizeof( header.mapName ));

	push	32					; 00000020H
	push	OFFSET _sv+56
	lea	ecx, DWORD PTR _header$[ebp+20]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1414 : 	Q_strncpy( header.skyName, sv_skyname.string, sizeof( header.skyName ));

	push	32					; 00000020H
	mov	edx, DWORD PTR _sv_skyname+4
	push	edx
	lea	eax, DWORD PTR _header$[ebp+52]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1415 : 	header.skyColor_r = sv_skycolor_r.value;

	cvttss2si ecx, DWORD PTR _sv_skycolor_r+12
	mov	DWORD PTR _header$[ebp+84], ecx

; 1416 : 	header.skyColor_g = sv_skycolor_g.value;

	cvttss2si edx, DWORD PTR _sv_skycolor_g+12
	mov	DWORD PTR _header$[ebp+88], edx

; 1417 : 	header.skyColor_b = sv_skycolor_b.value;

	cvttss2si eax, DWORD PTR _sv_skycolor_b+12
	mov	DWORD PTR _header$[ebp+92], eax

; 1418 : 	header.skyVec_x = sv_skyvec_x.value;

	movss	xmm0, DWORD PTR _sv_skyvec_x+12
	movss	DWORD PTR _header$[ebp+96], xmm0

; 1419 : 	header.skyVec_y = sv_skyvec_y.value;

	movss	xmm0, DWORD PTR _sv_skyvec_y+12
	movss	DWORD PTR _header$[ebp+100], xmm0

; 1420 : 	header.skyVec_z = sv_skyvec_z.value;

	movss	xmm0, DWORD PTR _sv_skyvec_z+12
	movss	DWORD PTR _header$[ebp+104], xmm0

; 1421 : 	header.lightStyleCount = 0;

	mov	DWORD PTR _header$[ebp+12], 0

; 1422 : 
; 1423 : 	// counting the lightstyles
; 1424 : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SaveGameSt
$LN2@SaveGameSt:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SaveGameSt:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@SaveGameSt

; 1425 : 	{
; 1426 : 		if( sv.lightstyles[i].pattern[0] )

	imul	edx, DWORD PTR _i$[ebp], 1296
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sv[edx+ecx+333000]
	test	edx, edx
	je	SHORT $LN18@SaveGameSt

; 1427 : 			header.lightStyleCount++;

	mov	eax, DWORD PTR _header$[ebp+12]
	add	eax, 1
	mov	DWORD PTR _header$[ebp+12], eax
$LN18@SaveGameSt:

; 1428 : 	}

	jmp	SHORT $LN2@SaveGameSt
$LN3@SaveGameSt:

; 1429 : 
; 1430 : 	// Write the main header
; 1431 : 	pSaveData->time = 0.0f; // prohibits rebase of header.time (keep compatibility with old saves)

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+1360], xmm0

; 1432 : 	svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "Save Header", &header, gSaveHeader, ARRAYSIZE_XASH( gSaveHeader ));

	push	13					; 0000000dH
	push	OFFSET _gSaveHeader
	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	push	OFFSET $SG138161
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H

; 1433 : 	pSaveData->time = header.time;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _header$[ebp+16]
	movss	DWORD PTR [ecx+1360], xmm0

; 1434 : 
; 1435 : 	// Write the adjacency list
; 1436 : 	for( i = 0; i < pSaveData->connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SaveGameSt
$LN5@SaveGameSt:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@SaveGameSt:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	SHORT $LN6@SaveGameSt

; 1437 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "ADJACENCY", &pSaveData->levelList[i], gAdjacency, ARRAYSIZE_XASH( gAdjacency ));

	push	4
	push	OFFSET _gAdjacency
	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _pSaveData$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	push	ecx
	push	OFFSET $SG138162
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@SaveGameSt
$LN6@SaveGameSt:

; 1438 : 
; 1439 : 	// Write the lightstyles
; 1440 : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SaveGameSt
$LN8@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@SaveGameSt:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN9@SaveGameSt

; 1441 : 	{
; 1442 : 		if( !sv.lightstyles[i].pattern[0] )

	imul	ecx, DWORD PTR _i$[ebp], 1296
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _sv[ecx+eax+333000]
	test	ecx, ecx
	jne	SHORT $LN19@SaveGameSt

; 1443 : 			continue;

	jmp	SHORT $LN8@SaveGameSt
$LN19@SaveGameSt:

; 1444 : 
; 1445 : 		Q_strncpy( light.style, sv.lightstyles[i].pattern, sizeof( light.style ));

	push	256					; 00000100H
	imul	edx, DWORD PTR _i$[ebp], 1296
	add	edx, OFFSET _sv+333000
	push	edx
	lea	eax, DWORD PTR _light$[ebp+4]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1446 : 		light.time = sv.lightstyles[i].time;

	imul	ecx, DWORD PTR _i$[ebp], 1296
	movss	xmm0, DWORD PTR _sv[ecx+334292]
	movss	DWORD PTR _light$[ebp+260], xmm0

; 1447 : 		light.index = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _light$[ebp], edx

; 1448 : 
; 1449 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "LIGHTSTYLE", &light, gLightStyle, ARRAYSIZE_XASH( gLightStyle ));

	push	3
	push	OFFSET _gLightStyle
	lea	eax, DWORD PTR _light$[ebp]
	push	eax
	push	OFFSET $SG138164
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H

; 1450 : 	}

	jmp	$LN8@SaveGameSt
$LN9@SaveGameSt:

; 1451 : 
; 1452 : 	// build the table of entities
; 1453 : 	// this is used to turn pointers into savable indices
; 1454 : 	// build up ID numbers for each entity, for use in pointer conversions
; 1455 : 	// if an entity requires a certain edict number upon restore, save that as well
; 1456 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@SaveGameSt
$LN11@SaveGameSt:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN12@SaveGameSt

; 1457 : 	{
; 1458 : 		pTable = &pSaveData->pTable[i];

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _pSaveData$[ebp]
	add	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR _pTable$[ebp], ecx

; 1459 : 		pTable->location = pSaveData->size;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1460 : 		pSaveData->currentIndex = i;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1461 : 		pTable->size = 0;

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1462 : 
; 1463 : 		if( !SV_IsValidEdict( pTable->pent ))

	push	1463					; 000005b7H
	push	OFFSET $SG138166
	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@SaveGameSt

; 1464 : 			continue;

	jmp	$LN11@SaveGameSt
$LN20@SaveGameSt:

; 1465 : 
; 1466 : 		svgame.dllFuncs.pfnSave( pTable->pent, pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _svgame+19268
	add	esp, 8

; 1467 : 
; 1468 : 		if( FBitSet( pTable->pent->v.flags, FL_CLIENT ))

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 8
	je	SHORT $LN21@SaveGameSt

; 1469 : 			SetBits( pTable->flags, FENTTABLE_PLAYER );

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+16]
	or	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN21@SaveGameSt:

; 1470 : 	}

	jmp	$LN11@SaveGameSt
$LN12@SaveGameSt:

; 1471 : 
; 1472 : 	// total data what includes:
; 1473 : 	// 1. save header
; 1474 : 	// 2. adjacency list
; 1475 : 	// 3. lightstyles
; 1476 : 	// 4. all the entity data
; 1477 : 	dataSize = pSaveData->size;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _dataSize$[ebp], eax

; 1478 : 
; 1479 : 	// Write entity table
; 1480 : 	pTableData = pSaveData->pCurrentData;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pTableData$[ebp], edx

; 1481 : 
; 1482 : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@SaveGameSt
$LN14@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@SaveGameSt:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jge	SHORT $LN15@SaveGameSt

; 1483 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "ETABLE", &pSaveData->pTable[i], gEntityTable, ARRAYSIZE_XASH( gEntityTable ));

	push	5
	push	OFFSET _gEntityTable
	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	push	eax
	push	OFFSET $SG138168
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H
	jmp	SHORT $LN14@SaveGameSt
$LN15@SaveGameSt:

; 1484 : 
; 1485 : 	tableSize = pSaveData->size - dataSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _dataSize$[ebp]
	mov	DWORD PTR _tableSize$[ebp], ecx

; 1486 : 	
; 1487 : 	// Write entity string token table
; 1488 : 	pTokenData = StoreHashTable( pSaveData );

	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_StoreHashTable
	add	esp, 4
	mov	DWORD PTR _pTokenData$[ebp], eax

; 1489 : 
; 1490 : 	// output to disk
; 1491 : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET $SG138170
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN22@SaveGameSt

; 1492 : 	{
; 1493 : 		// something bad is happens
; 1494 : 		SaveFinish( pSaveData );

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_SaveFinish
	add	esp, 4

; 1495 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SaveGameSt
$LN22@SaveGameSt:

; 1496 : 	}
; 1497 : 
; 1498 : 	// Write the header -- THIS SHOULD NEVER CHANGE STRUCTURE, USE SAVE_HEADER FOR NEW HEADER INFORMATION
; 1499 : 	// THIS IS ONLY HERE TO IDENTIFY THE FILE AND GET IT'S SIZE.
; 1500 : 	version = SAVEGAME_VERSION;

	mov	DWORD PTR _version$[ebp], 113		; 00000071H

; 1501 : 	id = SAVEFILE_HEADER;

	mov	DWORD PTR _id$[ebp], 1447838038		; 564c4156H

; 1502 : 
; 1503 : 	// write the header
; 1504 : 	FS_Write( pFile, &id, sizeof( id ));

	push	4
	lea	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1505 : 	FS_Write( pFile, &version, sizeof( version ));

	push	4
	lea	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1506 : 
; 1507 : 	// Write out the tokens and table FIRST so they are loaded in the right order, then write out the rest of the data in the file.
; 1508 : 	FS_Write( pFile, &pSaveData->size, sizeof( int ));	// total size of all data to initialize read buffer

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1509 : 	FS_Write( pFile, &pSaveData->tableCount, sizeof( int ));	// entities count to right initialize entity table

	push	4
	mov	edx, DWORD PTR _pSaveData$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1510 : 	FS_Write( pFile, &pSaveData->tokenCount, sizeof( int ));	// num hash tokens to prepare token table

	push	4
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1511 : 	FS_Write( pFile, &pSaveData->tokenSize, sizeof( int ));	// total size of hash tokens

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1512 : 	FS_Write( pFile, pTokenData, pSaveData->tokenSize );	// write tokens into the file

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _pTokenData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1513 : 	FS_Write( pFile, pTableData, tableSize );		// dump ETABLE structures

	mov	eax, DWORD PTR _tableSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTableData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1514 : 	FS_Write( pFile, pSaveData->pBaseData, dataSize );	// and finally store all the other data

	mov	eax, DWORD PTR _dataSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1515 : 	FS_Close( pFile );

	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 1516 : 
; 1517 : 	EntityPatchWrite( pSaveData, sv.name );

	push	OFFSET _sv+56
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EntityPatchWrite
	add	esp, 8

; 1518 : 
; 1519 : 	SaveClientState( pSaveData, sv.name, changelevel );

	mov	eax, DWORD PTR _changelevel$[ebp]
	push	eax
	push	OFFSET _sv+56
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_SaveClientState
	add	esp, 12					; 0000000cH

; 1520 : 
; 1521 : 	return pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
$LN1@SaveGameSt:

; 1522 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_ed$1 = -24						; size = 4
tv86 = -20						; size = 4
_active$ = -16						; size = 4
_i$ = -12						; size = 4
_pent$ = -8						; size = 4
_pTable$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_levelMask$ = 12					; size = 4
_create_world$ = 16					; size = 4
_CreateEntitiesInRestoreList PROC

; 1322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1323 : 	int		i, active;
; 1324 : 	ENTITYTABLE	*pTable;
; 1325 : 	edict_t		*pent;
; 1326 : 
; 1327 : 	// create entity list
; 1328 : 	if( svgame.physFuncs.pfnCreateEntitiesInRestoreList != NULL )

	cmp	DWORD PTR _svgame+19520, 0
	je	SHORT $LN5@CreateEnti

; 1329 : 	{
; 1330 : 		svgame.physFuncs.pfnCreateEntitiesInRestoreList( pSaveData, levelMask, create_world );

	mov	eax, DWORD PTR _create_world$[ebp]
	push	eax
	mov	ecx, DWORD PTR _levelMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19520
	add	esp, 12					; 0000000cH

; 1331 : 	}

	jmp	$LN1@CreateEnti
$LN5@CreateEnti:

; 1332 : 	else
; 1333 : 	{
; 1334 : 		for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CreateEnti
$LN2@CreateEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CreateEnti:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jge	$LN1@CreateEnti

; 1335 : 		{
; 1336 : 			pTable = &pSaveData->pTable[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _pTable$[ebp], eax

; 1337 : 			pent = NULL;

	mov	DWORD PTR _pent$[ebp], 0

; 1338 : 
; 1339 : 			if( pTable->classname && pTable->size && ( !FBitSet( pTable->flags, FENTTABLE_REMOVED ) || !create_world ))

	mov	edx, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN7@CreateEnti
	mov	eax, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN7@CreateEnti
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN8@CreateEnti
	cmp	DWORD PTR _create_world$[ebp], 0
	jne	$LN7@CreateEnti
$LN8@CreateEnti:

; 1340 : 			{
; 1341 : 				if( !create_world )

	cmp	DWORD PTR _create_world$[ebp], 0
	jne	SHORT $LN9@CreateEnti

; 1342 : 					active = FBitSet( pTable->flags, levelMask ) ? 1 : 0;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, DWORD PTR _levelMask$[ebp]
	je	SHORT $LN19@CreateEnti
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN20@CreateEnti
$LN19@CreateEnti:
	mov	DWORD PTR tv86[ebp], 0
$LN20@CreateEnti:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _active$[ebp], edx
	jmp	SHORT $LN10@CreateEnti
$LN9@CreateEnti:

; 1343 : 				else active = 1;

	mov	DWORD PTR _active$[ebp], 1
$LN10@CreateEnti:

; 1344 : 
; 1345 : 				if( pTable->id == 0 && create_world ) // worldspawn

	mov	eax, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN11@CreateEnti
	cmp	DWORD PTR _create_world$[ebp], 0
	je	SHORT $LN11@CreateEnti

; 1346 : 				{
; 1347 : 					pent = EDICT_NUM( 0 );

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax

; 1348 : 					SV_InitEdict( pent );

	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_InitEdict
	add	esp, 4

; 1349 : 					pent = SV_CreateNamedEntity( pent, pTable->classname );

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CreateNamedEntity
	add	esp, 8
	mov	DWORD PTR _pent$[ebp], eax

; 1350 : 				}

	jmp	$LN7@CreateEnti
$LN11@CreateEnti:

; 1351 : 				else if(( pTable->id > 0 ) && ( pTable->id < svs.maxclients + 1 ))

	mov	edx, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN13@CreateEnti
	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	ecx, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [ecx], eax
	jge	SHORT $LN13@CreateEnti

; 1352 : 				{
; 1353 : 					edict_t	*ed = EDICT_NUM( pTable->id );

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ed$1[ebp], eax

; 1354 : 
; 1355 : 					if( !FBitSet( pTable->flags, FENTTABLE_PLAYER ))

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN15@CreateEnti

; 1356 : 						Con_Printf( S_ERROR "ENTITY IS NOT A PLAYER: %d\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG138113
	call	_Con_Printf
	add	esp, 8
$LN15@CreateEnti:

; 1357 : 
; 1358 : 					// create the player
; 1359 : 					if( active && SV_IsValidEdict( ed ))

	cmp	DWORD PTR _active$[ebp], 0
	je	SHORT $LN16@CreateEnti
	push	1359					; 0000054fH
	push	OFFSET $SG138115
	mov	ecx, DWORD PTR _ed$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@CreateEnti

; 1360 : 						pent = SV_CreateNamedEntity( ed, pTable->classname );

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _ed$1[ebp]
	push	ecx
	call	_SV_CreateNamedEntity
	add	esp, 8
	mov	DWORD PTR _pent$[ebp], eax
$LN16@CreateEnti:

; 1361 : 				}

	jmp	SHORT $LN7@CreateEnti
$LN13@CreateEnti:

; 1362 : 				else if( active )

	cmp	DWORD PTR _active$[ebp], 0
	je	SHORT $LN7@CreateEnti

; 1363 : 				{
; 1364 : 					pent = SV_CreateNamedEntity( NULL, pTable->classname );

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	0
	call	_SV_CreateNamedEntity
	add	esp, 8
	mov	DWORD PTR _pent$[ebp], eax
$LN7@CreateEnti:

; 1365 : 				}
; 1366 : 			}
; 1367 : 
; 1368 : 			pTable->pent = pent;

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1369 : 		}

	jmp	$LN2@CreateEnti
$LN1@CreateEnti:

; 1370 : 	}
; 1371 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CreateEntitiesInRestoreList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pent$1 = -516						; size = 4
_cl$ = -512						; size = 4
tv181 = -508						; size = 4
_tokenCount$ = -504					; size = 4
_version$ = -500					; size = 4
tv224 = -496						; size = 4
tv223 = -492						; size = 4
_size$ = -488						; size = 4
_tokenSize$ = -484					; size = 4
_id$ = -480						; size = 4
_i$ = -476						; size = 4
_pFile$ = -472						; size = 4
_header$ = -468						; size = 160
_soundEntry$ = -308					; size = 112
_decalEntry$ = -196					; size = 128
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_changelevel$ = 16					; size = 4
_adjacent$ = 20						; size = 4
_LoadClientState PROC

; 1204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1205 : 	int		tokenCount, tokenSize;
; 1206 : 	int		i, size, id, version;
; 1207 : 	sv_client_t	*cl = svs.clients;

	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax

; 1208 : 	char		name[MAX_QPATH];
; 1209 : 	soundlist_t	soundEntry;
; 1210 : 	decallist_t	decalEntry;
; 1211 : 	SAVE_CLIENT	header;
; 1212 : 	file_t		*pFile;
; 1213 : 
; 1214 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, level );

	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	push	OFFSET $SG138059
	push	OFFSET $SG138060
	push	64					; 00000040H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1215 : 
; 1216 : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET $SG138062
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN11@LoadClient

; 1217 : 		return; // something bad is happens

	jmp	$LN20@LoadClient
$LN11@LoadClient:

; 1218 : 
; 1219 : 	FS_Read( pFile, &id, sizeof( id ));

	push	4
	lea	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1220 : 	if( id != SAVEGAME_HEADER )

	cmp	DWORD PTR _id$[ebp], 1447121738		; 5641534aH
	je	SHORT $LN12@LoadClient

; 1221 : 	{
; 1222 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1223 : 		return;

	jmp	$LN20@LoadClient
$LN12@LoadClient:

; 1224 : 	}
; 1225 : 		
; 1226 : 	FS_Read( pFile, &version, sizeof( version ));

	push	4
	lea	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1227 : 	if( version != CLIENT_SAVEGAME_VERSION )

	cmp	DWORD PTR _version$[ebp], 103		; 00000067H
	je	SHORT $LN13@LoadClient

; 1228 : 	{
; 1229 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1230 : 		return;

	jmp	$LN20@LoadClient
$LN13@LoadClient:

; 1231 : 	}
; 1232 : 
; 1233 : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1234 : 	FS_Read( pFile, &tokenCount, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1235 : 	FS_Read( pFile, &tokenSize, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _tokenSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1236 : 
; 1237 : 	// sanity check
; 1238 : 	ASSERT( pSaveData->bufferSize >= ( size + tokenSize ));

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, DWORD PTR _tokenSize$[ebp]
	mov	edx, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jge	SHORT $LN14@LoadClient
	push	1238					; 000004d6H
	push	OFFSET $SG138066
	push	OFFSET $SG138067
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN14@LoadClient:

; 1239 : 
; 1240 : 	// clearing the restore buffer to reuse
; 1241 : 	SaveClear( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveClear
	add	esp, 4

; 1242 : 	pSaveData->tokenCount = tokenCount;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 1243 : 	pSaveData->tokenSize = tokenSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1244 : 
; 1245 : 	// Parse the symbol table
; 1246 : 	BuildHashTable( pSaveData, pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_BuildHashTable
	add	esp, 8

; 1247 : 
; 1248 : 	FS_Read( pFile, pSaveData->pBaseData, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1249 : 	FS_Close( pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 1250 : 
; 1251 : 	// Read the client header
; 1252 : 	svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ClientHeader", &header, gSaveClient, ARRAYSIZE_XASH( gSaveClient ));

	push	10					; 0000000aH
	push	OFFSET _gSaveClient
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET $SG138068
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 1253 : 
; 1254 : 	// restore decals
; 1255 : 	for( i = 0; i < header.decalCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LoadClient
$LN2@LoadClient:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp]
	jge	$LN3@LoadClient

; 1256 : 	{
; 1257 : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "DECALLIST", &decalEntry, gDecalEntry, ARRAYSIZE_XASH( gDecalEntry ));

	push	8
	push	OFFSET _gDecalEntry
	lea	ecx, DWORD PTR _decalEntry$[ebp]
	push	ecx
	push	OFFSET $SG138069
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 1258 : 
; 1259 : 		// NOTE: apply landmark offset only for brush entities without origin brushes
; 1260 : 		if( pSaveData->fUseLandmark && FBitSet( decalEntry.flags, FDECAL_USE_LANDMARK ))

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+1324], 0
	je	$LN15@LoadClient
	movzx	ecx, BYTE PTR _decalEntry$[ebp+79]
	and	ecx, 2
	je	$LN15@LoadClient

; 1261 : 			VectorAdd( decalEntry.position, pSaveData->vecLandmarkOffset, decalEntry.position );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _decalEntry$[ebp+eax]
	addss	xmm0, DWORD PTR [ecx+edx+1348]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _decalEntry$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _decalEntry$[ebp+ecx]
	addss	xmm0, DWORD PTR [eax+edx+1348]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _decalEntry$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _decalEntry$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+1348]
	movss	DWORD PTR tv181[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv181[ebp]
	movss	DWORD PTR _decalEntry$[ebp+edx], xmm0
$LN15@LoadClient:

; 1262 : 		RestoreDecal( pSaveData, &decalEntry, adjacent );

	mov	eax, DWORD PTR _adjacent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _decalEntry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_RestoreDecal
	add	esp, 12					; 0000000cH

; 1263 : 	}

	jmp	$LN2@LoadClient
$LN3@LoadClient:

; 1264 : 
; 1265 : 	// clear old entities
; 1266 : 	if( !adjacent )

	cmp	DWORD PTR _adjacent$[ebp], 0
	jne	SHORT $LN16@LoadClient

; 1267 : 	{
; 1268 : 		memset( svs.static_entities, 0, sizeof( entity_state_t ) * MAX_STATIC_ENTITIES );

	push	1052640					; 00100fe0H
	push	0
	mov	eax, DWORD PTR _svs+33364
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1269 : 		sv.num_static_entities = 0;		

	mov	DWORD PTR _sv+332996, 0
$LN16@LoadClient:

; 1270 : 	}
; 1271 : 
; 1272 : 	// restore client entities
; 1273 : 	for( i = 0; i < header.entityCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@LoadClient
$LN5@LoadClient:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@LoadClient:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _header$[ebp+4]
	jge	SHORT $LN6@LoadClient

; 1274 : 	{
; 1275 : 		id = sv.num_static_entities;

	mov	eax, DWORD PTR _sv+332996
	mov	DWORD PTR _id$[ebp], eax

; 1276 : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "STATICENTITY", &svs.static_entities[id], gStaticEntry, ARRAYSIZE_XASH( gStaticEntry ));

	push	34					; 00000022H
	push	OFFSET _gStaticEntry
	imul	ecx, DWORD PTR _id$[ebp], 340
	add	ecx, DWORD PTR _svs+33364
	push	ecx
	push	OFFSET $SG138072
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 1277 : 		if( adjacent ) continue; // static entities won't loading from adjacent levels

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	SHORT $LN17@LoadClient
	jmp	SHORT $LN5@LoadClient
$LN17@LoadClient:

; 1278 : 
; 1279 : 		if( SV_CreateStaticEntity( &sv.signon, id ))

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET _sv+1220372
	call	_SV_CreateStaticEntity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@LoadClient

; 1280 : 			sv.num_static_entities++;

	mov	ecx, DWORD PTR _sv+332996
	add	ecx, 1
	mov	DWORD PTR _sv+332996, ecx
$LN18@LoadClient:

; 1281 : 	}

	jmp	$LN5@LoadClient
$LN6@LoadClient:

; 1282 : 
; 1283 : 	// restore sounds
; 1284 : 	for( i = 0; i < header.soundCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@LoadClient
$LN8@LoadClient:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp+8]
	jge	SHORT $LN9@LoadClient

; 1285 : 	{
; 1286 : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "SOUNDLIST", &soundEntry, gSoundEntry, ARRAYSIZE_XASH( gSoundEntry ));

	push	11					; 0000000bH
	push	OFFSET _gSoundEntry
	lea	ecx, DWORD PTR _soundEntry$[ebp]
	push	ecx
	push	OFFSET $SG138075
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 1287 : 		if( adjacent ) continue; // sounds don't going across the levels

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	SHORT $LN19@LoadClient
	jmp	SHORT $LN8@LoadClient
$LN19@LoadClient:

; 1288 : 
; 1289 : 		RestoreSound( pSaveData, &soundEntry );

	lea	eax, DWORD PTR _soundEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_RestoreSound
	add	esp, 8

; 1290 : 	}

	jmp	SHORT $LN8@LoadClient
$LN9@LoadClient:

; 1291 : 
; 1292 : 	if( !adjacent )

	cmp	DWORD PTR _adjacent$[ebp], 0
	jne	$LN20@LoadClient

; 1293 : 	{
; 1294 : 		// restore camera view here
; 1295 : 		edict_t	*pent = pSaveData->pTable[bound( 0, (word)header.viewentity, pSaveData->tableCount )].pent;

	movzx	edx, WORD PTR _header$[ebp+148]
	test	edx, edx
	jl	SHORT $LN26@LoadClient
	movzx	eax, WORD PTR _header$[ebp+148]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN24@LoadClient
	movzx	edx, WORD PTR _header$[ebp+148]
	mov	DWORD PTR tv223[ebp], edx
	jmp	SHORT $LN25@LoadClient
$LN24@LoadClient:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR tv223[ebp], ecx
$LN25@LoadClient:
	mov	edx, DWORD PTR tv223[ebp]
	mov	DWORD PTR tv224[ebp], edx
	jmp	SHORT $LN27@LoadClient
$LN26@LoadClient:
	mov	DWORD PTR tv224[ebp], 0
$LN27@LoadClient:
	imul	eax, DWORD PTR tv224[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _pent$1[ebp], eax

; 1296 : 
; 1297 : 		if( Q_strlen( header.introTrack ))

	lea	ecx, DWORD PTR _header$[ebp+16]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@LoadClient

; 1298 : 		{
; 1299 : 			// NOTE: music is automatically goes across transition, never restore it on changelevel
; 1300 : 			MSG_BeginServerCmd( &sv.signon, svc_stufftext );

	push	0
	push	1
	push	9
	push	OFFSET _sv+1220372
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1301 : 			MSG_WriteString( &sv.signon, va( "music \"%s\" \"%s\" %i\n", header.introTrack, header.mainTrack, header.trackPosition ));

	mov	edx, DWORD PTR _header$[ebp+144]
	push	edx
	lea	eax, DWORD PTR _header$[ebp+80]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp+16]
	push	ecx
	push	OFFSET $SG138079
	call	_va
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET _sv+1220372
	call	_MSG_WriteString
	add	esp, 8
$LN21@LoadClient:

; 1302 : 		}
; 1303 : 
; 1304 : 		// don't go camera across the levels
; 1305 : 		if( header.viewentity > svs.maxclients && !changelevel )

	movsx	edx, WORD PTR _header$[ebp+148]
	cmp	edx, DWORD PTR _svs+16
	jle	SHORT $LN22@LoadClient
	cmp	DWORD PTR _changelevel$[ebp], 0
	jne	SHORT $LN22@LoadClient

; 1306 : 			cl->pViewEntity = pent;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _pent$1[ebp]
	mov	DWORD PTR [eax+264984], ecx
$LN22@LoadClient:

; 1307 : 
; 1308 : 		// restore some client cvars
; 1309 : 		Cvar_SetValue( "sv_wateralpha", header.wateralpha );

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+152]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138081
	call	_Cvar_SetValue

; 1310 : 		Cvar_SetValue( "sv_wateramp", header.wateramp );

	add	esp, 4
	movss	xmm0, DWORD PTR _header$[ebp+156]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138082
	call	_Cvar_SetValue
	add	esp, 8
$LN20@LoadClient:

; 1311 : 	}
; 1312 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadClientState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pTokenData$ = -36100					; size = 4
_version$ = -36096					; size = 4
_id$ = -36092						; size = 4
tv184 = -36088						; size = 4
_cl$ = -36084						; size = 4
_pFile$ = -36080					; size = 4
_decalList$ = -36076					; size = 4
_i$ = -36072						; size = 4
_header$ = -36068					; size = 160
_soundInfo$ = -35908					; size = 35840
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_changelevel$ = 16					; size = 4
_SaveClientState PROC

; 1113 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 36100				; 00008d04H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1114 : 	soundlist_t	soundInfo[MAX_CHANNELS];
; 1115 : 	sv_client_t	*cl = svs.clients;

	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax

; 1116 : 	char		name[MAX_QPATH];
; 1117 : 	int		i, id, version;
; 1118 : 	char		*pTokenData;
; 1119 : 	decallist_t	*decalList;
; 1120 : 	SAVE_CLIENT	header;
; 1121 : 	file_t		*pFile;
; 1122 : 
; 1123 : 	// clearing the saving buffer to reuse
; 1124 : 	SaveClear( pSaveData );

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_SaveClear
	add	esp, 4

; 1125 : 
; 1126 : 	memset( &header, 0, sizeof( header ));

	push	160					; 000000a0H
	push	0
	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1127 : 
; 1128 : 	// g-cont. add space for studiodecals if present
; 1129 : 	decalList = (decallist_t *)Z_Calloc( sizeof( decallist_t ) * MAX_RENDER_DECALS * 2 );

	push	1129					; 00000469H
	push	OFFSET $SG138003
	push	1
	push	1048576					; 00100000H
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _decalList$[ebp], eax

; 1130 : 
; 1131 : 	// initialize client header
; 1132 : 	header.decalCount = R_CreateDecalList( decalList );

	mov	ecx, DWORD PTR _decalList$[ebp]
	push	ecx
	call	_R_CreateDecalList
	add	esp, 4
	mov	DWORD PTR _header$[ebp], eax

; 1133 : 	header.entityCount = sv.num_static_entities;

	mov	edx, DWORD PTR _sv+332996
	mov	DWORD PTR _header$[ebp+4], edx

; 1134 : 
; 1135 : 	if( !changelevel )

	cmp	DWORD PTR _changelevel$[ebp], 0
	jne	SHORT $LN11@SaveClient

; 1136 : 	{
; 1137 : 	 	// sounds won't going across transition
; 1138 : 		header.soundCount = S_GetCurrentDynamicSounds( soundInfo, MAX_CHANNELS );

	push	320					; 00000140H
	lea	eax, DWORD PTR _soundInfo$[ebp]
	push	eax
	call	_S_GetCurrentDynamicSounds
	add	esp, 8
	mov	DWORD PTR _header$[ebp+8], eax

; 1139 : 		// music not reqiured to save position: it's just continue playing on a next level
; 1140 : 		S_StreamGetCurrentState( header.introTrack, header.mainTrack, &header.trackPosition );

	lea	ecx, DWORD PTR _header$[ebp+144]
	push	ecx
	lea	edx, DWORD PTR _header$[ebp+80]
	push	edx
	lea	eax, DWORD PTR _header$[ebp+16]
	push	eax
	call	_S_StreamGetCurrentState
	add	esp, 12					; 0000000cH
$LN11@SaveClient:

; 1141 : 	}
; 1142 : 
; 1143 : 	// save viewentity to allow camera works after save\restore
; 1144 : 	if( SV_IsValidEdict( cl->pViewEntity ) && cl->pViewEntity != cl->edict )

	push	1144					; 00000478H
	push	OFFSET $SG138006
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264984]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@SaveClient
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [eax+264984]
	cmp	edx, DWORD PTR [ecx+264980]
	je	SHORT $LN12@SaveClient

; 1145 : 		header.viewentity = NUM_FOR_EDICT( cl->pViewEntity );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264984]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	WORD PTR _header$[ebp+148], ax
$LN12@SaveClient:

; 1146 : 
; 1147 : 	header.wateralpha = sv_wateralpha.value;

	movss	xmm0, DWORD PTR _sv_wateralpha+12
	movss	DWORD PTR _header$[ebp+152], xmm0

; 1148 : 	header.wateramp = sv_wateramp.value;

	movss	xmm0, DWORD PTR _sv_wateramp+12
	movss	DWORD PTR _header$[ebp+156], xmm0

; 1149 : 
; 1150 : 	// Store the client header
; 1151 : 	svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "ClientHeader", &header, gSaveClient, ARRAYSIZE_XASH( gSaveClient ));

	push	10					; 0000000aH
	push	OFFSET _gSaveClient
	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	push	OFFSET $SG138007
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H

; 1152 : 
; 1153 : 	// store decals
; 1154 : 	for( i = 0; i < header.decalCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SaveClient
$LN2@SaveClient:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SaveClient:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _header$[ebp]
	jge	$LN3@SaveClient

; 1155 : 	{
; 1156 : 		// NOTE: apply landmark offset only for brush entities without origin brushes
; 1157 : 		if( pSaveData->fUseLandmark && FBitSet( decalList[i].flags, FDECAL_USE_LANDMARK ))

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+1324], 0
	je	$LN13@SaveClient
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _decalList$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+79]
	and	eax, 2
	je	$LN13@SaveClient

; 1158 : 			VectorSubtract( decalList[i].position, pSaveData->vecLandmarkOffset, decalList[i].position );

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _decalList$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [esi+edx+1348]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _decalList$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _decalList$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR [esi+edx+1348]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _decalList$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _decalList$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+1348]
	movss	DWORD PTR tv184[ebp], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	add	edx, DWORD PTR _decalList$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv184[ebp]
	movss	DWORD PTR [edx+eax], xmm0
$LN13@SaveClient:

; 1159 : 
; 1160 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "DECALLIST", &decalList[i], gDecalEntry, ARRAYSIZE_XASH( gDecalEntry ));

	push	8
	push	OFFSET _gDecalEntry
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	add	ecx, DWORD PTR _decalList$[ebp]
	push	ecx
	push	OFFSET $SG138009
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H

; 1161 : 	}

	jmp	$LN2@SaveClient
$LN3@SaveClient:

; 1162 : 	Z_Free( decalList );

	cmp	DWORD PTR _decalList$[ebp], 0
	je	SHORT $LN14@SaveClient
	push	1162					; 0000048aH
	push	OFFSET $SG138011
	mov	eax, DWORD PTR _decalList$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN14@SaveClient:

; 1163 : 
; 1164 : 	// write client entities
; 1165 : 	for( i = 0; i < header.entityCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SaveClient
$LN5@SaveClient:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@SaveClient:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _header$[ebp+4]
	jge	SHORT $LN6@SaveClient

; 1166 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "STATICENTITY", &svs.static_entities[i], gStaticEntry, ARRAYSIZE_XASH( gStaticEntry ));

	push	34					; 00000022H
	push	OFFSET _gStaticEntry
	imul	eax, DWORD PTR _i$[ebp], 340
	add	eax, DWORD PTR _svs+33364
	push	eax
	push	OFFSET $SG138012
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@SaveClient
$LN6@SaveClient:

; 1167 : 
; 1168 : 	// write sounds
; 1169 : 	for( i = 0; i < header.soundCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SaveClient
$LN8@SaveClient:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp+8]
	jge	SHORT $LN9@SaveClient

; 1170 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "SOUNDLIST", &soundInfo[i], gSoundEntry, ARRAYSIZE_XASH( gSoundEntry ));

	push	11					; 0000000bH
	push	OFFSET _gSoundEntry
	imul	ecx, DWORD PTR _i$[ebp], 112
	lea	edx, DWORD PTR _soundInfo$[ebp+ecx]
	push	edx
	push	OFFSET $SG138013
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19280
	add	esp, 20					; 00000014H
	jmp	SHORT $LN8@SaveClient
$LN9@SaveClient:

; 1171 : 
; 1172 : 	// Write entity string token table
; 1173 : 	pTokenData = StoreHashTable( pSaveData );

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_StoreHashTable
	add	esp, 4
	mov	DWORD PTR _pTokenData$[ebp], eax

; 1174 : 
; 1175 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, level );

	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	push	OFFSET $SG138014
	push	OFFSET $SG138015
	push	64					; 00000040H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1176 : 
; 1177 : 	// output to disk
; 1178 : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET $SG138017
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN15@SaveClient

; 1179 : 		return; // something bad is happens

	jmp	$LN1@SaveClient
$LN15@SaveClient:

; 1180 : 
; 1181 : 	version = CLIENT_SAVEGAME_VERSION;

	mov	DWORD PTR _version$[ebp], 103		; 00000067H

; 1182 : 	id = SAVEGAME_HEADER;

	mov	DWORD PTR _id$[ebp], 1447121738		; 5641534aH

; 1183 : 
; 1184 : 	FS_Write( pFile, &id, sizeof( id ));

	push	4
	lea	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1185 : 	FS_Write( pFile, &version, sizeof( version ));

	push	4
	lea	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1186 : 	FS_Write( pFile, &pSaveData->size, sizeof( int )); // does not include token table

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1187 : 
; 1188 : 	// write out the tokens first so we can load them before we load the entities
; 1189 : 	FS_Write( pFile, &pSaveData->tokenCount, sizeof( int ));

	push	4
	mov	edx, DWORD PTR _pSaveData$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1190 : 	FS_Write( pFile, &pSaveData->tokenSize, sizeof( int ));

	push	4
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1191 : 	FS_Write( pFile, pTokenData, pSaveData->tokenSize );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pTokenData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1192 : 	FS_Write( pFile, pSaveData->pBaseData, pSaveData->size ); // header and globals

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1193 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@SaveClient:

; 1194 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveClientState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_ent$ = -8						; size = 4
_flags$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_snd$ = 12						; size = 4
_RestoreSound PROC

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1086 : 	edict_t	*ent = EdictFromTable( pSaveData, snd->entnum );

	mov	eax, DWORD PTR _snd$[ebp]
	movsx	ecx, WORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EdictFromTable
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax

; 1087 : 	int	flags = SND_RESTORE_POSITION;

	mov	DWORD PTR _flags$[ebp], 4096		; 00001000H

; 1088 : 
; 1089 : 	// this can happens if serialized map contain 4096 static decals...
; 1090 : 	if( MSG_GetNumBytesLeft( &sv.signon ) < 36 )

	push	OFFSET _sv+1220372
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jge	SHORT $LN2@RestoreSou

; 1091 : 		return;

	jmp	$LN4@RestoreSou
$LN2@RestoreSou:

; 1092 : 
; 1093 : 	if( !snd->looping )

	mov	eax, DWORD PTR _snd$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $LN3@RestoreSou

; 1094 : 		SetBits( flags, SND_STOP_LOOPING );

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR _flags$[ebp], ecx
$LN3@RestoreSou:

; 1095 : 
; 1096 : 	if( SV_BuildSoundMsg( &sv.signon, ent, snd->channel, snd->name, snd->volume * 255, snd->attenuation, flags, snd->pitch, snd->origin ))

	mov	edx, DWORD PTR _snd$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _snd$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _snd$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+84]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _snd$[ebp]
	movss	xmm0, DWORD PTR [ecx+80]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si edx, xmm0
	push	edx
	mov	eax, DWORD PTR _snd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _snd$[ebp]
	movzx	edx, BYTE PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	OFFSET _sv+1220372
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN4@RestoreSou

; 1097 : 	{
; 1098 : 		// write extradata for svc_restoresound
; 1099 : 		MSG_WriteByte( &sv.signon, snd->wordIndex );

	mov	ecx, DWORD PTR _snd$[ebp]
	movzx	edx, BYTE PTR [ecx+94]
	push	edx
	push	OFFSET _sv+1220372
	call	_MSG_WriteByte
	add	esp, 8

; 1100 : 		MSG_WriteBytes( &sv.signon, &snd->samplePos, sizeof( snd->samplePos ));

	push	8
	mov	eax, DWORD PTR _snd$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	push	OFFSET _sv+1220372
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1101 : 		MSG_WriteBytes( &sv.signon, &snd->forcedEnd, sizeof( snd->forcedEnd ));

	push	8
	mov	ecx, DWORD PTR _snd$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	push	OFFSET _sv+1220372
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH
$LN4@RestoreSou:

; 1102 : 	}
; 1103 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RestoreSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
$T1 = -172						; size = 56
_dot$2 = -116						; size = 4
tv225 = -112						; size = 4
tv183 = -108						; size = 4
_decalIndex$ = -104					; size = 4
_modelIndex$ = -100					; size = 4
_flags$ = -96						; size = 4
_entityIndex$ = -92					; size = 4
_pEdict$ = -88						; size = 4
_tr$3 = -84						; size = 56
_testspot$4 = -28					; size = 12
_testend$5 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_entry$ = 12						; size = 4
_adjacent$ = 16						; size = 4
_RestoreDecal PROC

; 1012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1013 : 	int	decalIndex, entityIndex = 0;

	mov	DWORD PTR _entityIndex$[ebp], 0

; 1014 : 	int	flags = entry->flags;

	mov	eax, DWORD PTR _entry$[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	mov	DWORD PTR _flags$[ebp], ecx

; 1015 : 	int	modelIndex = 0;

	mov	DWORD PTR _modelIndex$[ebp], 0

; 1016 : 	edict_t	*pEdict;
; 1017 : 
; 1018 : 	// never move permanent decals
; 1019 : 	if( adjacent && FBitSet( flags, FDECAL_PERMANENT ))

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	SHORT $LN2@RestoreDec
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	je	SHORT $LN2@RestoreDec

; 1020 : 		return;

	jmp	$LN8@RestoreDec
$LN2@RestoreDec:

; 1021 : 
; 1022 : 	// restore entity and model index
; 1023 : 	pEdict = EdictFromTable( pSaveData, entry->entityIndex );

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EdictFromTable
	add	esp, 8
	mov	DWORD PTR _pEdict$[ebp], eax

; 1024 : 
; 1025 : 	if( SV_RestoreCustomDecal( entry, pEdict, adjacent ))

	mov	eax, DWORD PTR _adjacent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_SV_RestoreCustomDecal
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@RestoreDec

; 1026 : 		return; // decal was sucessfully restored at the game-side

	jmp	$LN8@RestoreDec
$LN3@RestoreDec:

; 1027 : 
; 1028 : 	// studio decals are handled at game-side
; 1029 : 	if( FBitSet( flags, FDECAL_STUDIO ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN4@RestoreDec

; 1030 : 		return;

	jmp	$LN8@RestoreDec
$LN4@RestoreDec:

; 1031 : 
; 1032 : 	if( SV_IsValidEdict( pEdict ))

	push	1032					; 00000408H
	push	OFFSET $SG137946
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@RestoreDec

; 1033 : 		modelIndex = pEdict->v.modelindex;

	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+308]
	mov	DWORD PTR _modelIndex$[ebp], eax
$LN5@RestoreDec:

; 1034 : 
; 1035 : 	if( SV_IsValidEdict( pEdict ))

	push	1035					; 0000040bH
	push	OFFSET $SG137948
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@RestoreDec

; 1036 : 		entityIndex = NUM_FOR_EDICT( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 804				; 00000324H
	idiv	ecx
	mov	DWORD PTR _entityIndex$[ebp], eax
$LN6@RestoreDec:

; 1037 : 
; 1038 : 	decalIndex = pfnDecalIndex( entry->name );

	mov	edx, DWORD PTR _entry$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	_pfnDecalIndex
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 1039 : 
; 1040 : 	// this can happens if brush entity from previous level was turned into world geometry
; 1041 : 	if( adjacent && entry->entityIndex != 0 && !SV_IsValidEdict( pEdict ))

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	$LN7@RestoreDec
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	test	ecx, ecx
	je	$LN7@RestoreDec
	push	1041					; 00000411H
	push	OFFSET $SG137951
	mov	edx, DWORD PTR _pEdict$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@RestoreDec

; 1042 : 	{
; 1043 : 		vec3_t	testspot, testend;
; 1044 : 		trace_t	tr;
; 1045 : 
; 1046 : 		Con_Printf( S_ERROR "RestoreDecal: couldn't restore entity index %i\n", entry->entityIndex );

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	push	OFFSET $SG137952
	call	_Con_Printf
	add	esp, 8

; 1047 : 
; 1048 : 		VectorCopy( entry->position, testspot );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _testspot$4[ebp+edx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _testspot$4[ebp+edx], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _testspot$4[ebp+eax], edx

; 1049 : 		VectorMA( testspot, 5.0f, entry->impactPlaneNormal, testspot );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [edx+eax+84]
	addss	xmm0, DWORD PTR _testspot$4[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _testspot$4[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [ecx+eax+84]
	addss	xmm0, DWORD PTR _testspot$4[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _testspot$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [edx+ecx+84]
	movss	xmm1, DWORD PTR _testspot$4[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv183[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv183[ebp]
	movss	DWORD PTR _testspot$4[ebp+eax], xmm0

; 1050 : 
; 1051 : 		VectorCopy( entry->position, testend );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _testend$5[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _testend$5[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _testend$5[ebp+edx], ecx

; 1052 : 		VectorMA( testend, -5.0f, entry->impactPlaneNormal, testend );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@c0a00000
	mulss	xmm0, DWORD PTR [ecx+edx+84]
	addss	xmm0, DWORD PTR _testend$5[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _testend$5[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@c0a00000
	mulss	xmm0, DWORD PTR [eax+edx+84]
	addss	xmm0, DWORD PTR _testend$5[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _testend$5[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@c0a00000
	mulss	xmm0, DWORD PTR [ecx+eax+84]
	movss	xmm1, DWORD PTR _testend$5[ebp+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv225[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv225[ebp]
	movss	DWORD PTR _testend$5[ebp+edx], xmm0

; 1053 : 
; 1054 : 		tr = SV_Move( testspot, vec3_origin, vec3_origin, testend, MOVE_NOMONSTERS, NULL, false );

	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _testend$5[ebp]
	push	eax
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	ecx, DWORD PTR _testspot$4[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _tr$3[ebp]
	rep movsd

; 1055 : 
; 1056 : 		// NOTE: this code may does wrong result on moving brushes e.g. func_tracktrain
; 1057 : 		if( tr.fraction != 1.0f && !tr.allsolid )

	movss	xmm0, DWORD PTR _tr$3[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN10@RestoreDec
	cmp	DWORD PTR _tr$3[ebp], 0
	jne	$LN10@RestoreDec

; 1058 : 		{
; 1059 : 			// check impact plane normal
; 1060 : 			float	dot = DotProduct( entry->impactPlaneNormal, tr.plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	mulss	xmm0, DWORD PTR _tr$3[ebp+eax+32]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+84]
	mulss	xmm1, DWORD PTR _tr$3[ebp+ecx+32]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+84]
	mulss	xmm1, DWORD PTR _tr$3[ebp+ecx+32]
	addss	xmm0, xmm1
	movss	DWORD PTR _dot$2[ebp], xmm0

; 1061 : 
; 1062 : 			if( dot >= 0.95f )

	movss	xmm0, DWORD PTR _dot$2[ebp]
	comiss	xmm0, DWORD PTR __real@3f733333
	jb	SHORT $LN10@RestoreDec

; 1063 : 			{
; 1064 : 				entityIndex = pfnIndexOfEdict( tr.ent );

	mov	eax, DWORD PTR _tr$3[ebp+48]
	push	eax
	call	_pfnIndexOfEdict
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 1065 : 				if( entityIndex > 0 ) modelIndex = tr.ent->v.modelindex;

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN11@RestoreDec
	mov	ecx, DWORD PTR _tr$3[ebp+48]
	mov	edx, DWORD PTR [ecx+308]
	mov	DWORD PTR _modelIndex$[ebp], edx
$LN11@RestoreDec:

; 1066 : 				SV_CreateDecal( &sv.signon, tr.endpos, decalIndex, entityIndex, modelIndex, flags, entry->scale );

	mov	eax, DWORD PTR _entry$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tr$3[ebp+20]
	push	edx
	push	OFFSET _sv+1220372
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH
$LN10@RestoreDec:

; 1067 : 			}
; 1068 : 		}
; 1069 : 	}

	jmp	SHORT $LN8@RestoreDec
$LN7@RestoreDec:

; 1070 : 	else
; 1071 : 	{
; 1072 : 		// global entity is exist on new level so we can apply decal in local space
; 1073 : 		SV_CreateDecal( &sv.signon, entry->position, decalIndex, entityIndex, modelIndex, flags, entry->scale );

	mov	eax, DWORD PTR _entry$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	push	OFFSET _sv+1220372
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH
$LN8@RestoreDec:

; 1074 : 	}
; 1075 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_RestoreDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_entityId$ = -84					; size = 4
_size$ = -80						; size = 4
_i$ = -76						; size = 4
_pFile$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_EntityPatchRead PROC

; 982  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 983  : 	char	name[MAX_QPATH];
; 984  : 	int	i, size, entityId;
; 985  : 	file_t	*pFile;
; 986  : 
; 987  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL3", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET $SG137918
	push	OFFSET $SG137919
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 988  : 
; 989  : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET $SG137921
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN5@EntityPatc

; 990  : 		return;

	jmp	SHORT $LN1@EntityPatc
$LN5@EntityPatc:

; 991  : 
; 992  : 	// patch count
; 993  : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 994  : 
; 995  : 	for( i = 0; i < size; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@EntityPatc
$LN2@EntityPatc:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@EntityPatc:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN3@EntityPatc

; 996  : 	{
; 997  : 		FS_Read( pFile, &entityId, sizeof( int ));

	push	4
	lea	ecx, DWORD PTR _entityId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 998  : 		pSaveData->pTable[entityId].flags = FENTTABLE_REMOVED;

	imul	eax, DWORD PTR _entityId$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+eax+16], 1073741824	; 40000000H

; 999  : 	}

	jmp	SHORT $LN2@EntityPatc
$LN3@EntityPatc:

; 1000 : 
; 1001 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@EntityPatc:

; 1002 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_EntityPatchRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_size$ = -80						; size = 4
_pFile$ = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_EntityPatchWrite PROC

; 945  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 946  : 	char	name[MAX_QPATH];
; 947  : 	int	i, size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 948  : 	file_t	*pFile;
; 949  : 
; 950  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL3", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET $SG137895
	push	OFFSET $SG137896
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 951  : 
; 952  : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET $SG137898
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN8@EntityPatc

; 953  : 		return;

	jmp	$LN1@EntityPatc
$LN8@EntityPatc:

; 954  : 
; 955  : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@EntityPatc
$LN2@EntityPatc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@EntityPatc:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jge	SHORT $LN3@EntityPatc

; 956  : 	{
; 957  : 		if( FBitSet( pSaveData->pTable[i].flags, FENTTABLE_REMOVED ))

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+16]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN9@EntityPatc

; 958  : 			size++;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx
$LN9@EntityPatc:

; 959  : 	}

	jmp	SHORT $LN2@EntityPatc
$LN3@EntityPatc:

; 960  : 
; 961  : 	// patch count
; 962  : 	FS_Write( pFile, &size, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 963  : 
; 964  : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@EntityPatc
$LN5@EntityPatc:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@EntityPatc:
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN6@EntityPatc

; 965  : 	{
; 966  : 		if( FBitSet( pSaveData->pTable[i].flags, FENTTABLE_REMOVED ))

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx+16]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN10@EntityPatc

; 967  : 			FS_Write( pFile, &i, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN10@EntityPatc:

; 968  : 	}

	jmp	SHORT $LN5@EntityPatc
$LN6@EntityPatc:

; 969  : 
; 970  : 	FS_Close( pFile );

	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4
$LN1@EntityPatc:

; 971  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_EntityPatchWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_i$ = -272						; size = 4
_light$ = -268						; size = 264
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_pHeader$ = 12						; size = 4
_updateGlobals$ = 16					; size = 4
_ParseSaveTables PROC

; 901  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 902  : 	SAVE_LIGHTSTYLE	light;
; 903  : 	int		i;
; 904  : 
; 905  : 	// Re-base the savedata since we re-ordered the entity/table / restore fields
; 906  : 	InitEntityTable( pSaveData, pSaveData->tableCount );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_InitEntityTable
	add	esp, 8

; 907  : 
; 908  : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ParseSaveT
$LN2@ParseSaveT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@ParseSaveT:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jge	SHORT $LN3@ParseSaveT

; 909  : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ETABLE", &pSaveData->pTable[i], gEntityTable, ARRAYSIZE_XASH( gEntityTable ));

	push	5
	push	OFFSET _gEntityTable
	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	push	eax
	push	OFFSET $SG137870
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H
	jmp	SHORT $LN2@ParseSaveT
$LN3@ParseSaveT:

; 910  : 
; 911  : 	pSaveData->pBaseData = pSaveData->pCurrentData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 912  : 	pSaveData->size = 0;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+8], 0

; 913  : 
; 914  : 	// process SAVE_HEADER
; 915  : 	svgame.dllFuncs.pfnSaveReadFields( pSaveData, "Save Header", pHeader, gSaveHeader, ARRAYSIZE_XASH( gSaveHeader ));

	push	13					; 0000000dH
	push	OFFSET _gSaveHeader
	mov	ecx, DWORD PTR _pHeader$[ebp]
	push	ecx
	push	OFFSET $SG137871
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 916  : 
; 917  : 	pSaveData->connectionCount = pHeader->connectionCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pHeader$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+36], edx

; 918  : 	VectorClear( pSaveData->vecLandmarkOffset );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+1348], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+1348], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+1348], xmm0

; 919  : 	pSaveData->time = pHeader->time;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _pHeader$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+1360], eax

; 920  : 	pSaveData->fUseLandmark = true;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+1324], 1

; 921  : 
; 922  : 	// read adjacency list
; 923  : 	for( i = 0; i < pSaveData->connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ParseSaveT
$LN5@ParseSaveT:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@ParseSaveT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	SHORT $LN6@ParseSaveT

; 924  : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ADJACENCY", &pSaveData->levelList[i], gAdjacency, ARRAYSIZE_XASH( gAdjacency ));

	push	4
	push	OFFSET _gAdjacency
	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _pSaveData$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	push	ecx
	push	OFFSET $SG137872
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@ParseSaveT
$LN6@ParseSaveT:

; 925  : 
; 926  : 	if( updateGlobals )

	cmp	DWORD PTR _updateGlobals$[ebp], 0
	je	SHORT $LN11@ParseSaveT

; 927  : 		memset( sv.lightstyles, 0, sizeof( sv.lightstyles ));

	push	82944					; 00014400H
	push	0
	push	OFFSET _sv+333000
	call	_memset
	add	esp, 12					; 0000000cH
$LN11@ParseSaveT:

; 928  : 
; 929  : 	for( i = 0; i < pHeader->lightStyleCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@ParseSaveT
$LN8@ParseSaveT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@ParseSaveT:
	mov	ecx, DWORD PTR _pHeader$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN9@ParseSaveT

; 930  : 	{
; 931  : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "LIGHTSTYLE", &light, gLightStyle, ARRAYSIZE_XASH( gLightStyle ));

	push	3
	push	OFFSET _gLightStyle
	lea	eax, DWORD PTR _light$[ebp]
	push	eax
	push	OFFSET $SG137874
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19284
	add	esp, 20					; 00000014H

; 932  : 		if( updateGlobals ) SV_SetLightStyle( light.index, light.style, light.time );

	cmp	DWORD PTR _updateGlobals$[ebp], 0
	je	SHORT $LN12@ParseSaveT
	push	ecx
	movss	xmm0, DWORD PTR _light$[ebp+260]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _light$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _light$[ebp]
	push	eax
	call	_SV_SetLightStyle
	add	esp, 12					; 0000000cH
$LN12@ParseSaveT:

; 933  : 	}

	jmp	SHORT $LN8@ParseSaveT
$LN9@ParseSaveT:

; 934  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseSaveTables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_tableCount$ = -308					; size = 4
_totalSize$ = -304					; size = 4
_version$ = -300					; size = 4
_id$ = -296						; size = 4
_tokenCount$ = -292					; size = 4
tv135 = -288						; size = 4
_clientSize$ = -284					; size = 4
_size$ = -280						; size = 4
_tokenSize$ = -276					; size = 4
_pSaveData$ = -272					; size = 4
_pFile$ = -268						; size = 4
_name$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_LoadSaveData PROC

; 830  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 831  : 	int		tokenSize, tableCount;
; 832  : 	int		size, tokenCount;
; 833  : 	char		name[MAX_OSPATH];
; 834  : 	int		id, version;
; 835  : 	int		clientSize;
; 836  : 	SAVERESTOREDATA	*pSaveData;
; 837  : 	int		totalSize;
; 838  : 	file_t		*pFile;
; 839  : 	
; 840  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL1", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET $SG137843
	push	OFFSET $SG137844
	push	260					; 00000104H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 841  : 	Con_Printf( "Loading game from %s...\n", name );

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG137845
	call	_Con_Printf
	add	esp, 8

; 842  : 
; 843  : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET $SG137847
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN2@LoadSaveDa

; 844  : 	{
; 845  : 		Con_Printf( S_ERROR "couldn't open.\n" );

	push	OFFSET $SG137848
	call	_Con_Printf
	add	esp, 4

; 846  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@LoadSaveDa
$LN2@LoadSaveDa:

; 847  : 	}
; 848  : 
; 849  : 	// Read the header
; 850  : 	FS_Read( pFile, &id, sizeof( int ));

	push	4
	lea	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 851  : 	FS_Read( pFile, &version, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 852  : 
; 853  : 	// is this a valid save?
; 854  : 	if( id != SAVEFILE_HEADER || version != SAVEGAME_VERSION )

	cmp	DWORD PTR _id$[ebp], 1447838038		; 564c4156H
	jne	SHORT $LN4@LoadSaveDa
	cmp	DWORD PTR _version$[ebp], 113		; 00000071H
	je	SHORT $LN3@LoadSaveDa
$LN4@LoadSaveDa:

; 855  : 	{
; 856  : 		FS_Close( pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 857  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@LoadSaveDa
$LN3@LoadSaveDa:

; 858  : 	}
; 859  : 
; 860  : 	// Read the sections info and the data
; 861  : 	FS_Read( pFile, &size, sizeof( int ));		// total size of all data to initialize read buffer

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 862  : 	FS_Read( pFile, &tableCount, sizeof( int ));	// entities count to right initialize entity table

	push	4
	lea	edx, DWORD PTR _tableCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 863  : 	FS_Read( pFile, &tokenCount, sizeof( int ));	// num hash tokens to prepare token table

	push	4
	lea	ecx, DWORD PTR _tokenCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 864  : 	FS_Read( pFile, &tokenSize, sizeof( int ));	// total size of hash tokens

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 865  : 
; 866  : 	// determine highest size of seve-restore buffer
; 867  : 	// because it's used twice: for HL1 and HL2 restore
; 868  : 	clientSize = GetClientDataSize( level );

	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	call	_GetClientDataSize
	add	esp, 4
	mov	DWORD PTR _clientSize$[ebp], eax

; 869  : 	totalSize = Q_max( clientSize, ( size + tokenSize ));

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _tokenSize$[ebp]
	cmp	DWORD PTR _clientSize$[ebp], eax
	jle	SHORT $LN6@LoadSaveDa
	mov	ecx, DWORD PTR _clientSize$[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN7@LoadSaveDa
$LN6@LoadSaveDa:
	mov	edx, DWORD PTR _size$[ebp]
	add	edx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR tv135[ebp], edx
$LN7@LoadSaveDa:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _totalSize$[ebp], eax

; 870  : 
; 871  : 	// init the read buffer
; 872  : 	pSaveData = SaveInit( totalSize, tokenCount );

	mov	ecx, DWORD PTR _tokenCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _totalSize$[ebp]
	push	edx
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 873  : 
; 874  : 	Q_strncpy( pSaveData->szCurrentMapName, level, sizeof( pSaveData->szCurrentMapName ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 1364				; 00000554H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 875  : 	pSaveData->tableCount = tableCount;		// count ETABLE entries

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _tableCount$[ebp]
	mov	DWORD PTR [edx+32], eax

; 876  : 	pSaveData->tokenCount = tokenCount;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 877  : 	pSaveData->tokenSize = tokenSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 878  : 
; 879  : 	// Parse the symbol table
; 880  : 	BuildHashTable( pSaveData, pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_BuildHashTable
	add	esp, 8

; 881  : 
; 882  : 	// Set up the restore basis
; 883  : 	pSaveData->fUseLandmark = true;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+1324], 1

; 884  : 	pSaveData->time = 0.0f;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+1360], xmm0

; 885  : 
; 886  : 	// now reading all the rest of data
; 887  : 	FS_Read( pFile, pSaveData->pBaseData, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 888  : 	FS_Close( pFile ); // data is sucessfully moved into SaveRestore buffer (ETABLE will be init later)

	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 889  : 
; 890  : 	return pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
$LN1@LoadSaveDa:

; 891  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadSaveData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_tokenCount$ = -92					; size = 4
_tokenSize$ = -88					; size = 4
_size$ = -84						; size = 4
_version$ = -80						; size = 4
_id$ = -76						; size = 4
_pFile$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_GetClientDataSize PROC

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 789  : 	int	tokenCount, tokenSize;
; 790  : 	int	size, id, version;
; 791  : 	char	name[MAX_QPATH];
; 792  : 	file_t	*pFile;
; 793  : 
; 794  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET $SG137813
	push	OFFSET $SG137814
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 795  : 
; 796  : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET $SG137816
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN2@GetClientD

; 797  : 		return 0;

	xor	eax, eax
	jmp	$LN1@GetClientD
$LN2@GetClientD:

; 798  : 
; 799  : 	FS_Read( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 800  : 	if( id != SAVEGAME_HEADER )

	cmp	DWORD PTR _id$[ebp], 1447121738		; 5641534aH
	je	SHORT $LN3@GetClientD

; 801  : 	{
; 802  : 		FS_Close( pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 803  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetClientD
$LN3@GetClientD:

; 804  : 	}
; 805  : 		
; 806  : 	FS_Read( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 807  : 	if( version != CLIENT_SAVEGAME_VERSION )

	cmp	DWORD PTR _version$[ebp], 103		; 00000067H
	je	SHORT $LN4@GetClientD

; 808  : 	{
; 809  : 		FS_Close( pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 810  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetClientD
$LN4@GetClientD:

; 811  : 	}
; 812  : 
; 813  : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 814  : 	FS_Read( pFile, &tokenCount, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _tokenCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 815  : 	FS_Read( pFile, &tokenSize, sizeof( int ));

	push	4
	lea	ecx, DWORD PTR _tokenSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 816  : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 817  : 
; 818  : 	return ( size + tokenSize );

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _tokenSize$[ebp]
$LN1@GetClientD:

; 819  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GetClientDataSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv79 = -12						; size = 4
_i$ = -8						; size = 4
_pszTokenList$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_pFile$ = 12						; size = 4
_BuildHashTable PROC

; 757  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 758  : 	char	*pszTokenList = pSaveData->pBaseData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pszTokenList$[ebp], ecx

; 759  : 	int	i;
; 760  : 
; 761  : 	// Parse the symbol table
; 762  : 	if( pSaveData->tokenSize > 0 )

	mov	edx, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN7@BuildHashT

; 763  : 	{
; 764  : 		FS_Read( pFile, pszTokenList, pSaveData->tokenSize );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pszTokenList$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 765  : 
; 766  : 		// make sure the token strings pointed to by the pToken hashtable.
; 767  : 		for( i = 0; i < pSaveData->tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@BuildHashT
$LN2@BuildHashT:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@BuildHashT:
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jge	SHORT $LN7@BuildHashT

; 768  : 		{
; 769  : 			pSaveData->pTokens[i] = *pszTokenList ? pszTokenList : NULL;

	mov	ecx, DWORD PTR _pszTokenList$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@BuildHashT
	mov	eax, DWORD PTR _pszTokenList$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN10@BuildHashT
$LN9@BuildHashT:
	mov	DWORD PTR tv79[ebp], 0
$LN10@BuildHashT:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN5@BuildHashT:

; 770  : 			while( *pszTokenList++ );	// Find next token (after next null)

	mov	edx, DWORD PTR _pszTokenList$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR _pszTokenList$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pszTokenList$[ebp], ecx
	cmp	DWORD PTR tv83[ebp], 0
	je	SHORT $LN6@BuildHashT
	jmp	SHORT $LN5@BuildHashT
$LN6@BuildHashT:

; 771  : 		}

	jmp	SHORT $LN2@BuildHashT
$LN7@BuildHashT:

; 772  : 	}
; 773  : 
; 774  : 	// rebase the data pointer
; 775  : 	pSaveData->pBaseData = pszTokenList;	// pszTokenList now points after token data

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _pszTokenList$[ebp]
	mov	DWORD PTR [edx], eax

; 776  : 	pSaveData->pCurrentData = pSaveData->pBaseData;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 777  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pTokenData$ = -16					; size = 4
tv77 = -12						; size = 4
_pszToken$1 = -8					; size = 4
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_StoreHashTable PROC

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 727  : 	char	*pTokenData = pSaveData->pCurrentData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pTokenData$[ebp], ecx

; 728  : 	int	i;
; 729  : 
; 730  : 	// Write entity string token table
; 731  : 	if( pSaveData->pTokens )

	mov	edx, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$LN7@StoreHashT

; 732  : 	{
; 733  : 		for( i = 0; i < pSaveData->tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@StoreHashT
$LN2@StoreHashT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@StoreHashT:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	SHORT $LN7@StoreHashT

; 734  : 		{
; 735  : 			char *pszToken = pSaveData->pTokens[i] ? pSaveData->pTokens[i] : "";

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN9@StoreHashT
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN10@StoreHashT
$LN9@StoreHashT:
	mov	DWORD PTR tv77[ebp], OFFSET $SG137782
$LN10@StoreHashT:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _pszToken$1[ebp], ecx
$LN5@StoreHashT:

; 736  : 
; 737  : 			// just copy the token byte-by-byte
; 738  : 			while( *pszToken )

	mov	edx, DWORD PTR _pszToken$1[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@StoreHashT

; 739  : 				*pSaveData->pCurrentData++ = *pszToken++;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pszToken$1[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _pszToken$1[ebp]
	add	edx, 1
	mov	DWORD PTR _pszToken$1[ebp], edx
	jmp	SHORT $LN5@StoreHashT
$LN6@StoreHashT:

; 740  : 			*pSaveData->pCurrentData++ = 0; // Write the term

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 741  : 		}

	jmp	$LN2@StoreHashT
$LN7@StoreHashT:

; 742  : 	}
; 743  : 
; 744  : 	pSaveData->tokenSize = pSaveData->pCurrentData - pTokenData;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _pTokenData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 745  : 
; 746  : 	return pTokenData;

	mov	eax, DWORD PTR _pTokenData$[ebp]

; 747  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_StoreHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pSaveData$ = 8						; size = 4
_SaveFinish PROC

; 670  : {

	push	ebp
	mov	ebp, esp

; 671  : 	if( !pSaveData ) return;

	cmp	DWORD PTR _pSaveData$[ebp], 0
	jne	SHORT $LN2@SaveFinish
	jmp	$LN1@SaveFinish
$LN2@SaveFinish:

; 672  : 
; 673  : 	if( pSaveData->pTokens )

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@SaveFinish

; 674  : 	{
; 675  : 		Mem_Free( pSaveData->pTokens );

	push	675					; 000002a3H
	push	OFFSET $SG137749
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 676  : 		pSaveData->pTokens = NULL;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+24], 0

; 677  : 		pSaveData->tokenCount = 0;

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+20], 0
$LN3@SaveFinish:

; 678  : 	}
; 679  : 
; 680  : 	if( pSaveData->pTable )

	mov	edx, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN4@SaveFinish

; 681  : 	{
; 682  : 		Mem_Free( pSaveData->pTable );

	push	682					; 000002aaH
	push	OFFSET $SG137751
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 683  : 		pSaveData->pTable = NULL;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx+40], 0

; 684  : 		pSaveData->tableCount = 0;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+32], 0
$LN4@SaveFinish:

; 685  : 	}
; 686  : 
; 687  : 	svgame.globals->pSaveData = NULL;

	mov	ecx, DWORD PTR _svgame+19236
	mov	DWORD PTR [ecx+156], 0

; 688  : 	Mem_Free( pSaveData );

	push	688					; 000002b0H
	push	OFFSET $SG137752
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@SaveFinish:

; 689  : }

	pop	ebp
	ret	0
_SaveFinish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pSaveData$ = 8						; size = 4
_SaveClear PROC

; 649  : {

	push	ebp
	mov	ebp, esp

; 650  : 	memset( pSaveData->pTokens, 0, pSaveData->tokenCount * sizeof( char* ));

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 651  : 
; 652  : 	pSaveData->pBaseData = (char *)(pSaveData + 1); // skip the save structure);

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 1396				; 00000574H
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx], ecx

; 653  : 	pSaveData->pCurrentData = pSaveData->pBaseData; // reset the pointer

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 654  : 	pSaveData->time = svgame.globals->time;	// Use DLL time

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _svgame+19236
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1360], edx

; 655  : 	pSaveData->tokenSize = 0;	// reset the hashtable

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+16], 0

; 656  : 	pSaveData->size = 0;	// reset the pointer

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 657  : 
; 658  : 	// shared with dlls	
; 659  : 	svgame.globals->pSaveData = pSaveData;

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx+156], eax

; 660  : }

	pop	ebp
	ret	0
_SaveClear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pSaveData$ = -4					; size = 4
_size$ = 8						; size = 4
_tokenCount$ = 12					; size = 4
_SaveInit PROC

; 622  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 623  : 	SAVERESTOREDATA	*pSaveData;
; 624  : 
; 625  : 	pSaveData = Mem_Calloc( host.mempool, sizeof( SAVERESTOREDATA ) + size );

	push	625					; 00000271H
	push	OFFSET $SG137732
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1396				; 00000574H
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pSaveData$[ebp], eax

; 626  : 	pSaveData->pTokens = (char **)Mem_Calloc( host.mempool, tokenCount * sizeof( char* ));

	push	626					; 00000272H
	push	OFFSET $SG137733
	push	1
	mov	edx, DWORD PTR _tokenCount$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 627  : 	pSaveData->tokenCount = tokenCount;

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [edx+20], eax

; 628  : 
; 629  : 	pSaveData->pBaseData = (char *)(pSaveData + 1); // skip the save structure);

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 1396				; 00000574H
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx], ecx

; 630  : 	pSaveData->pCurrentData = pSaveData->pBaseData; // reset the pointer

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 631  : 	pSaveData->bufferSize = size;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 632  : 
; 633  : 	pSaveData->time = svgame.globals->time;	// Use DLL time

	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _svgame+19236
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+1360], ecx

; 634  : 
; 635  : 	// shared with dlls	
; 636  : 	svgame.globals->pSaveData = pSaveData;

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx+156], eax

; 637  : 
; 638  : 	return pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]

; 639  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SaveInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_fileSize$ = -536					; size = 4
_pCopy$ = -532						; size = 4
_i$ = -528						; size = 4
_szName$ = -524						; size = 260
_fileName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_pFile$ = 8						; size = 4
_fileCount$ = 12					; size = 4
_DirectoryExtract PROC

; 594  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 595  : 	char	szName[MAX_OSPATH];
; 596  : 	char	fileName[MAX_OSPATH];
; 597  : 	int	i, fileSize;
; 598  : 	file_t	*pCopy;
; 599  : 
; 600  : 	for( i = 0; i < fileCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DirectoryE
$LN2@DirectoryE:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@DirectoryE:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _fileCount$[ebp]
	jge	$LN1@DirectoryE

; 601  : 	{
; 602  : 		// filename can only be as long as a map name + extension
; 603  : 		FS_Read( pFile, szName, MAX_OSPATH );

	push	260					; 00000104H
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 604  : 		FS_Read( pFile, &fileSize, sizeof( int ));

	push	4
	lea	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 605  : 		Q_snprintf( fileName, sizeof( fileName ), "%s%s", DEFAULT_SAVE_DIRECTORY, szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET $SG137718
	push	OFFSET $SG137719
	push	260					; 00000104H
	lea	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 606  : 		COM_FixSlashes( fileName );

	lea	edx, DWORD PTR _fileName$[ebp]
	push	edx
	call	_COM_FixSlashes
	add	esp, 4

; 607  : 
; 608  : 		pCopy = FS_Open( fileName, "wb", true );

	push	1
	push	OFFSET $SG137720
	lea	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pCopy$[ebp], eax

; 609  : 		FS_FileCopy( pCopy, pFile, fileSize );

	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCopy$[ebp]
	push	eax
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 610  : 		FS_Close( pCopy );

	mov	ecx, DWORD PTR _pCopy$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 611  : 	}

	jmp	$LN2@DirectoryE
$LN1@DirectoryE:

; 612  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DirectoryExtract ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_fileSize$ = -280					; size = 4
_pCopy$ = -276						; size = 4
_t$ = -272						; size = 4
_i$ = -268						; size = 4
_szName$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_pPath$ = 8						; size = 4
_pFile$ = 12						; size = 4
_DirectoryCopy PROC

; 562  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 563  : 	char	szName[MAX_OSPATH];
; 564  : 	int	i, fileSize;
; 565  : 	file_t	*pCopy;
; 566  : 	search_t	*t;
; 567  : 
; 568  : 	t = FS_Search( pPath, true, true );

	push	1
	push	1
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 569  : 	if( !t ) return; // nothing to copy ?

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@DirectoryC
	jmp	$LN1@DirectoryC
$LN5@DirectoryC:

; 570  : 
; 571  : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DirectoryC
$LN2@DirectoryC:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@DirectoryC:
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN3@DirectoryC

; 572  : 	{
; 573  : 		pCopy = FS_Open( t->filenames[i], "rb", true );

	push	1
	push	OFFSET $SG137701
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pCopy$[ebp], eax

; 574  : 		fileSize = FS_FileLength( pCopy );

	mov	edx, DWORD PTR _pCopy$[ebp]
	push	edx
	call	_FS_FileLength
	add	esp, 4
	mov	DWORD PTR _fileSize$[ebp], eax

; 575  : 
; 576  : 		memset( szName, 0, sizeof( szName )); // clearing the string to prevent garbage in output file

	push	260					; 00000104H
	push	0
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 577  : 		Q_strncpy( szName, COM_FileWithoutPath( t->filenames[i] ), MAX_OSPATH );		

	push	260					; 00000104H
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_COM_FileWithoutPath
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 578  : 		FS_Write( pFile, szName, MAX_OSPATH );

	push	260					; 00000104H
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 579  : 		FS_Write( pFile, &fileSize, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 580  : 		FS_FileCopy( pFile, pCopy, fileSize );

	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCopy$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 581  : 		FS_Close( pCopy );

	mov	ecx, DWORD PTR _pCopy$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 582  : 	}

	jmp	$LN2@DirectoryC
$LN3@DirectoryC:

; 583  : 	Mem_Free( t );

	push	583					; 00000247H
	push	OFFSET $SG137702
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@DirectoryC:

; 584  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DirectoryCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_b$ = -12						; size = 4
_c$ = -8						; size = 4
_a$ = -4						; size = 4
_lastnum$ = 8						; size = 4
_filename$ = 12						; size = 4
_SaveGetName PROC

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 540  : 	int	a, b, c;
; 541  : 
; 542  : 	if( lastnum < 0 || lastnum > 999 )

	cmp	DWORD PTR _lastnum$[ebp], 0
	jl	SHORT $LN3@SaveGetNam
	cmp	DWORD PTR _lastnum$[ebp], 999		; 000003e7H
	jle	SHORT $LN2@SaveGetNam
$LN3@SaveGetNam:

; 543  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SaveGetNam
$LN2@SaveGetNam:

; 544  : 
; 545  : 	a = lastnum / 100;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _a$[ebp], eax

; 546  : 	lastnum -= a * 100;

	imul	edx, DWORD PTR _a$[ebp], 100
	mov	eax, DWORD PTR _lastnum$[ebp]
	sub	eax, edx
	mov	DWORD PTR _lastnum$[ebp], eax

; 547  : 	b = lastnum / 10;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _b$[ebp], eax

; 548  : 	c = lastnum % 10;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _c$[ebp], edx

; 549  : 
; 550  : 	Q_sprintf( filename, "save%i%i%i", a, b, c );

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	push	OFFSET $SG137684
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 551  : 	return true;

	mov	eax, 1
$LN1@SaveGetNam:

; 552  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SaveGetName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_oldName$ = -1044					; size = 260
_oldShot$ = -784					; size = 260
_newName$ = -524					; size = 260
_newShot$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_pName$ = 8						; size = 4
_count$ = 12						; size = 4
_AgeSaveList PROC

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1044				; 00000414H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 489  : 	char	newName[MAX_OSPATH], oldName[MAX_OSPATH];
; 490  : 	char	newShot[MAX_OSPATH], oldShot[MAX_OSPATH];
; 491  : 
; 492  : 	// delete last quick/autosave (e.g. quick05.sav)
; 493  : 	Q_snprintf( newName, sizeof( newName ), "%s%s%02d.sav", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET $SG137655
	push	OFFSET $SG137656
	push	260					; 00000104H
	lea	edx, DWORD PTR _newName$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 494  : 	Q_snprintf( newShot, sizeof( newShot ), "%s%s%02d.bmp", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET $SG137657
	push	OFFSET $SG137658
	push	260					; 00000104H
	lea	edx, DWORD PTR _newShot$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 495  : 
; 496  : 	// only delete from game directory, basedir is read-only
; 497  : 	FS_Delete( newName );

	lea	eax, DWORD PTR _newName$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 498  : 	FS_Delete( newShot );

	lea	ecx, DWORD PTR _newShot$[ebp]
	push	ecx
	call	_FS_Delete
	add	esp, 4

; 499  : 
; 500  : 	// unloading the shot footprint
; 501  : 	GL_FreeImage( newShot );

	lea	edx, DWORD PTR _newShot$[ebp]
	push	edx
	call	_GL_FreeImage
	add	esp, 4
$LN2@AgeSaveLis:

; 502  : 
; 503  : 	while( count > 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jle	$LN1@AgeSaveLis

; 504  : 	{
; 505  : 		if( count == 1 )

	cmp	DWORD PTR _count$[ebp], 1
	jne	SHORT $LN4@AgeSaveLis

; 506  : 		{	
; 507  : 			// quick.sav
; 508  : 			Q_snprintf( oldName, sizeof( oldName ), "%s%s.sav", DEFAULT_SAVE_DIRECTORY, pName );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	push	OFFSET $SG137661
	push	OFFSET $SG137662
	push	260					; 00000104H
	lea	ecx, DWORD PTR _oldName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 509  : 			Q_snprintf( oldShot, sizeof( oldShot ), "%s%s.bmp", DEFAULT_SAVE_DIRECTORY, pName );

	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG137663
	push	OFFSET $SG137664
	push	260					; 00000104H
	lea	eax, DWORD PTR _oldShot$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 510  : 		}

	jmp	SHORT $LN5@AgeSaveLis
$LN4@AgeSaveLis:

; 511  : 		else
; 512  : 		{	
; 513  : 			// quick04.sav, etc.
; 514  : 			Q_snprintf( oldName, sizeof( oldName ), "%s%s%02d.sav", DEFAULT_SAVE_DIRECTORY, pName, count - 1 );

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG137665
	push	OFFSET $SG137666
	push	260					; 00000104H
	lea	eax, DWORD PTR _oldName$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 515  : 			Q_snprintf( oldShot, sizeof( oldShot ), "%s%s%02d.bmp", DEFAULT_SAVE_DIRECTORY, pName, count - 1 );

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG137667
	push	OFFSET $SG137668
	push	260					; 00000104H
	lea	eax, DWORD PTR _oldShot$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN5@AgeSaveLis:

; 516  : 		}
; 517  : 
; 518  : 		Q_snprintf( newName, sizeof( newName ), "%s%s%02d.sav", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG137669
	push	OFFSET $SG137670
	push	260					; 00000104H
	lea	eax, DWORD PTR _newName$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 519  : 		Q_snprintf( newShot, sizeof( newShot ), "%s%s%02d.bmp", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG137671
	push	OFFSET $SG137672
	push	260					; 00000104H
	lea	eax, DWORD PTR _newShot$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 520  : 
; 521  : 		// unloading the oldshot footprint too
; 522  : 		GL_FreeImage( oldShot );

	lea	ecx, DWORD PTR _oldShot$[ebp]
	push	ecx
	call	_GL_FreeImage
	add	esp, 4

; 523  : 
; 524  : 		// scroll the name list down (e.g. rename quick04.sav to quick05.sav)
; 525  : 		FS_Rename( oldName, newName );

	lea	edx, DWORD PTR _newName$[ebp]
	push	edx
	lea	eax, DWORD PTR _oldName$[ebp]
	push	eax
	call	_FS_Rename
	add	esp, 8

; 526  : 		FS_Rename( oldShot, newShot );

	lea	ecx, DWORD PTR _newShot$[ebp]
	push	ecx
	lea	edx, DWORD PTR _oldShot$[ebp]
	push	edx
	call	_FS_Rename
	add	esp, 8

; 527  : 		count--;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 528  : 	}

	jmp	$LN2@AgeSaveLis
$LN1@AgeSaveLis:

; 529  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_AgeSaveList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pl$1 = -4						; size = 4
_IsValidSave PROC

; 417  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 418  : 	if( !svs.initialized || sv.state != ss_active )

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN3@IsValidSav
	cmp	DWORD PTR _sv, 2
	je	SHORT $LN2@IsValidSav
$LN3@IsValidSav:

; 419  : 	{
; 420  : 		Con_Printf( "Not playing a local game.\n" );

	push	OFFSET $SG137624
	call	_Con_Printf
	add	esp, 4

; 421  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN2@IsValidSav:

; 422  : 	}
; 423  : 
; 424  : 	// ignore autosave during background
; 425  : 	if( sv.background || UI_CreditsActive( ))

	cmp	DWORD PTR _sv+4, 0
	jne	SHORT $LN5@IsValidSav
	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN4@IsValidSav
$LN5@IsValidSav:

; 426  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN4@IsValidSav:

; 427  : 
; 428  : 	if( svgame.physFuncs.SV_AllowSaveGame != NULL )

	cmp	DWORD PTR _svgame+19480, 0
	je	SHORT $LN7@IsValidSav

; 429  : 	{
; 430  : 		if( !svgame.physFuncs.SV_AllowSaveGame( ))

	call	DWORD PTR _svgame+19480
	test	eax, eax
	jne	SHORT $LN7@IsValidSav

; 431  : 		{
; 432  : 			Con_Printf( "Savegame is not allowed.\n" );

	push	OFFSET $SG137629
	call	_Con_Printf
	add	esp, 4

; 433  : 			return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN7@IsValidSav:

; 434  : 		}
; 435  : 	}
; 436  : 
; 437  : 	if( !CL_Active( ))

	call	_CL_Active
	test	eax, eax
	jne	SHORT $LN8@IsValidSav

; 438  : 	{
; 439  : 		Con_Printf( "Can't save if not active.\n" );

	push	OFFSET $SG137631
	call	_Con_Printf
	add	esp, 4

; 440  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN8@IsValidSav:

; 441  : 	}
; 442  : 
; 443  : 	if( CL_IsIntermission( ))

	call	_CL_IsIntermission
	test	eax, eax
	je	SHORT $LN9@IsValidSav

; 444  : 	{
; 445  : 		Con_Printf( "Can't save during intermission.\n" );

	push	OFFSET $SG137633
	call	_Con_Printf
	add	esp, 4

; 446  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN9@IsValidSav:

; 447  : 	}
; 448  : 
; 449  : 	if( svs.maxclients != 1 )

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN10@IsValidSav

; 450  : 	{
; 451  : 		Con_Printf( "Can't save multiplayer games.\n" );

	push	OFFSET $SG137635
	call	_Con_Printf
	add	esp, 4

; 452  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN10@IsValidSav:

; 453  : 	}
; 454  : 
; 455  : 	if( svs.clients && svs.clients[0].state == cs_spawned )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN11@IsValidSav
	mov	eax, 287560				; 00046348H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 3
	jne	SHORT $LN11@IsValidSav

; 456  : 	{
; 457  : 		edict_t	*pl = svs.clients[0].edict;

	mov	eax, 287560				; 00046348H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svs+33344
	mov	eax, DWORD PTR [edx+ecx+264980]
	mov	DWORD PTR _pl$1[ebp], eax

; 458  : 		
; 459  : 		if( !pl )

	cmp	DWORD PTR _pl$1[ebp], 0
	jne	SHORT $LN12@IsValidSav

; 460  : 		{
; 461  : 			Con_Printf( "Can't savegame without a player!\n" );

	push	OFFSET $SG137638
	call	_Con_Printf
	add	esp, 4

; 462  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsValidSav
$LN12@IsValidSav:

; 463  : 		}
; 464  : 			
; 465  : 		if( pl->v.deadflag || pl->v.health <= 0.0f )

	mov	ecx, DWORD PTR _pl$1[ebp]
	cmp	DWORD PTR [ecx+496], 0
	jne	SHORT $LN14@IsValidSav
	mov	edx, DWORD PTR _pl$1[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+480]
	jb	SHORT $LN13@IsValidSav
$LN14@IsValidSav:

; 466  : 		{
; 467  : 			Con_Printf( "Can't savegame with a dead player\n" );

	push	OFFSET $SG137641
	call	_Con_Printf
	add	esp, 4

; 468  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsValidSav
$LN13@IsValidSav:

; 469  : 		}
; 470  : 
; 471  : 		// Passed all checks, it's ok to save
; 472  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsValidSav
$LN11@IsValidSav:

; 473  : 	}
; 474  : 
; 475  : 	Con_Printf( "Can't savegame without a client!\n" );

	push	OFFSET $SG137642
	call	_Con_Printf
	add	esp, 4

; 476  : 
; 477  : 	return 0;

	xor	eax, eax
$LN1@IsValidSav:

; 478  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_IsValidSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_t$ = -8						; size = 4
_i$ = -4						; size = 4
_ClearSaveDir PROC

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 396  : 	search_t	*t;
; 397  : 	int	i;
; 398  : 
; 399  : 	// just delete all HL? files
; 400  : 	t = FS_Search( va( "%s*.HL?", DEFAULT_SAVE_DIRECTORY ), true, true );

	push	1
	push	1
	push	OFFSET $SG137613
	push	OFFSET $SG137614
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 401  : 	if( !t ) return; // already empty

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@ClearSaveD
	jmp	SHORT $LN1@ClearSaveD
$LN5@ClearSaveD:

; 402  : 
; 403  : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ClearSaveD
$LN2@ClearSaveD:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@ClearSaveD:
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@ClearSaveD

; 404  : 		FS_Delete( t->filenames[i] );

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_FS_Delete
	add	esp, 4
	jmp	SHORT $LN2@ClearSaveD
$LN3@ClearSaveD:

; 405  : 
; 406  : 	Mem_Free( t );

	push	406					; 00000196H
	push	OFFSET $SG137616
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@ClearSaveD:

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ClearSaveDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
tv145 = -28						; size = 4
tv150 = -24						; size = 4
_aiment$ = -20						; size = 4
_point$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pent$ = 8						; size = 4
_EntityInSolid PROC

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 373  : 	edict_t	*aiment = pent->v.aiment;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	mov	DWORD PTR _aiment$[ebp], ecx

; 374  : 	vec3_t	point;
; 375  : 
; 376  : 	// if you're attached to a client, always go through
; 377  : 	if( pent->v.movetype == MOVETYPE_FOLLOW && SV_IsValidEdict( aiment ) && FBitSet( aiment->v.flags, FL_CLIENT ))

	mov	edx, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [edx+392], 12			; 0000000cH
	jne	SHORT $LN2@EntityInSo
	push	377					; 00000179H
	push	OFFSET $SG137604
	mov	eax, DWORD PTR _aiment$[ebp]
	push	eax
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@EntityInSo
	mov	ecx, DWORD PTR _aiment$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 8
	je	SHORT $LN2@EntityInSo

; 378  : 		return 0;

	xor	eax, eax
	jmp	$LN1@EntityInSo
$LN2@EntityInSo:

; 379  : 
; 380  : 	VectorAverage( pent->v.absmin, pent->v.absmax, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pent$[ebp]
	mov	esi, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+324]
	addss	xmm0, DWORD PTR [esi+eax+336]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	esi, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+324]
	addss	xmm0, DWORD PTR [esi+eax+336]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pent$[ebp]
	mov	esi, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+324]
	addss	xmm0, DWORD PTR [esi+ecx+336]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv145[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 381  : 	svs.groupmask = pent->v.groupinfo;

	mov	ecx, DWORD PTR _pent$[ebp]
	mov	edx, DWORD PTR [ecx+704]
	mov	DWORD PTR _svs+20, edx

; 382  : 
; 383  : 	return (SV_PointContents( point ) == CONTENTS_SOLID);

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN4@EntityInSo
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN5@EntityInSo
$LN4@EntityInSo:
	mov	DWORD PTR tv150[ebp], 0
$LN5@EntityInSo:
	mov	eax, DWORD PTR tv150[ebp]
$LN1@EntityInSo:

; 384  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_EntityInSolid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_output$ = 12						; size = 4
_pLandmarkName$ = 16					; size = 4
_LandmarkOrigin PROC

; 348  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 349  : 	int	i;
; 350  : 
; 351  : 	for( i = 0; i < pSaveData->connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LandmarkOr
$LN2@LandmarkOr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LandmarkOr:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jge	$LN3@LandmarkOr

; 352  : 	{
; 353  : 		if( !Q_strcmp( pSaveData->levelList[i].landmarkName, pLandmarkName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pLandmarkName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	mov	edx, DWORD PTR _pSaveData$[ebp]
	lea	eax, DWORD PTR [edx+ecx+76]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@LandmarkOr

; 354  : 		{
; 355  : 			VectorCopy( pSaveData->levelList[i].vecLandmarkOrigin, output );

	imul	ecx, DWORD PTR _i$[ebp], 80
	mov	edx, DWORD PTR _pSaveData$[ebp]
	lea	eax, DWORD PTR [edx+ecx+44]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _output$[ebp]
	mov	edx, DWORD PTR [eax+edx+68]
	mov	DWORD PTR [esi+ecx], edx
	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _output$[ebp]
	mov	edx, DWORD PTR [edx+eax+68]
	mov	DWORD PTR [esi+ecx], edx
	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _output$[ebp]
	mov	edx, DWORD PTR [edx+eax+68]
	mov	DWORD PTR [esi+ecx], edx

; 356  : 			return;

	jmp	SHORT $LN1@LandmarkOr
$LN5@LandmarkOr:

; 357  : 		}
; 358  : 	}

	jmp	$LN2@LandmarkOr
$LN3@LandmarkOr:

; 359  : 
; 360  : 	VectorClear( output );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN1@LandmarkOr:

; 361  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_LandmarkOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
tv74 = -8						; size = 4
tv73 = -4						; size = 4
_pSaveData$ = 8						; size = 4
_entityIndex$ = 12					; size = 4
_EdictFromTable PROC

; 330  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 331  : 	if( pSaveData && pSaveData->pTable )

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	SHORT $LN2@EdictFromT
	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN2@EdictFromT

; 332  : 	{
; 333  : 		entityIndex = bound( 0, entityIndex, pSaveData->tableCount - 1 );

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jl	SHORT $LN6@EdictFromT
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, 1
	cmp	DWORD PTR _entityIndex$[ebp], edx
	jge	SHORT $LN4@EdictFromT
	mov	eax, DWORD PTR _entityIndex$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN5@EdictFromT
$LN4@EdictFromT:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, 1
	mov	DWORD PTR tv73[ebp], edx
$LN5@EdictFromT:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN7@EdictFromT
$LN6@EdictFromT:
	mov	DWORD PTR tv74[ebp], 0
$LN7@EdictFromT:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _entityIndex$[ebp], ecx

; 334  : 		return pSaveData->pTable[entityIndex].pent;

	imul	edx, DWORD PTR _entityIndex$[ebp], 24
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN1@EdictFromT
$LN2@EdictFromT:

; 335  : 	}
; 336  : 
; 337  : 	return NULL;

	xor	eax, eax
$LN1@EdictFromT:

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_EdictFromTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_pMapName$ = 12						; size = 4
_index$ = 16						; size = 4
_EntryInTable PROC

; 310  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 311  : 	int	i;
; 312  : 
; 313  : 	for( i = index + 1; i < pSaveData->connectionCount; i++ )

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@EntryInTab
$LN2@EntryInTab:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@EntryInTab:
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jge	SHORT $LN3@EntryInTab

; 314  : 	{
; 315  : 		if ( !Q_stricmp( pSaveData->levelList[i].mapName, pMapName ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _pMapName$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _pSaveData$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@EntryInTab

; 316  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@EntryInTab
$LN5@EntryInTab:

; 317  : 	}

	jmp	SHORT $LN2@EntryInTab
$LN3@EntryInTab:

; 318  : 
; 319  : 	return -1;

	or	eax, -1
$LN1@EntryInTab:

; 320  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_EntryInTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pTable$ = -8						; size = 4
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_entityCount$ = 12					; size = 4
_InitEntityTable PROC

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 287  : 	ENTITYTABLE	*pTable;
; 288  : 	int		i;
; 289  : 
; 290  : 	pSaveData->pTable = Mem_Calloc( host.mempool, sizeof( ENTITYTABLE ) * entityCount );

	push	290					; 00000122H
	push	OFFSET $SG137562
	push	1
	imul	eax, DWORD PTR _entityCount$[ebp], 24
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx+40], eax

; 291  : 	pSaveData->tableCount = entityCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _entityCount$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 292  : 
; 293  : 	// setup entitytable
; 294  : 	for( i = 0; i < entityCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@InitEntity
$LN2@InitEntity:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@InitEntity:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _entityCount$[ebp]
	jge	SHORT $LN1@InitEntity

; 295  : 	{
; 296  : 		pTable = &pSaveData->pTable[i];

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _pSaveData$[ebp]
	add	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR _pTable$[ebp], ecx

; 297  : 		pTable->pent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 298  : 		pTable->id = i;

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 299  : 	}

	jmp	SHORT $LN2@InitEntity
$LN1@InitEntity:

; 300  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InitEntityTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_count$ = -8						; size = 4
_t$ = -4						; size = 4
_pPath$ = 8						; size = 4
_DirectoryCount PROC

; 265  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 266  : 	int	count;
; 267  : 	search_t	*t;
; 268  : 
; 269  : 	t = FS_Search( pPath, true, true );	// lookup only in gamedir

	push	1
	push	1
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 270  : 	if( !t ) return 0; // empty

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@DirectoryC
	xor	eax, eax
	jmp	SHORT $LN1@DirectoryC
$LN2@DirectoryC:

; 271  : 
; 272  : 	count = t->numfilenames;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _count$[ebp], edx

; 273  : 	Mem_Free( t );

	push	273					; 00000111H
	push	OFFSET $SG137549
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 274  : 
; 275  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@DirectoryC:

; 276  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DirectoryCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pName$ = -4						; size = 4
_text$ = 8						; size = 4
_maxlength$ = 12					; size = 4
_SaveBuildComment PROC

; 229  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 230  : 	const char	*pName;
; 231  : 
; 232  : 	text[0] = '\0'; // clear

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 233  : 
; 234  : 	if( pfnSaveGameComment != NULL )

	cmp	DWORD PTR _pfnSaveGameComment, 0
	je	SHORT $LN2@SaveBuildC

; 235  : 	{
; 236  : 		// get save comment from gamedll
; 237  : 		pfnSaveGameComment( text, maxlength );

	mov	eax, DWORD PTR _maxlength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR _pfnSaveGameComment
	add	esp, 8

; 238  : 	}

	jmp	$LN3@SaveBuildC
$LN2@SaveBuildC:

; 239  : 	else
; 240  : 	{
; 241  : 		if( svgame.edicts->v.message != 0 )

	mov	edx, DWORD PTR _svgame+7928
	cmp	DWORD PTR [edx+596], 0
	je	SHORT $LN4@SaveBuildC

; 242  : 		{
; 243  : 			// trying to extract message from the world
; 244  : 			pName = STRING( svgame.edicts->v.message );

	mov	eax, DWORD PTR _svgame+7928
	mov	ecx, DWORD PTR [eax+596]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _pName$[ebp], eax

; 245  : 		}

	jmp	SHORT $LN5@SaveBuildC
$LN4@SaveBuildC:

; 246  : 		else
; 247  : 		{
; 248  : 			// or use mapname
; 249  : 			pName = STRING( svgame.globals->mapname );

	mov	edx, DWORD PTR _svgame+19236
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _pName$[ebp], eax
$LN5@SaveBuildC:

; 250  : 		}
; 251  : 
; 252  : 		Q_snprintf( text, maxlength, "%-64.64s %02d:%02d", pName, (int)(sv.time / 60.0 ), (int)fmod( sv.time, 60.0 ));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _sv+16
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	push	eax
	movsd	xmm0, QWORD PTR _sv+16
	divsd	xmm0, QWORD PTR __real@404e000000000000
	cvttsd2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	push	OFFSET $SG137541
	mov	eax, DWORD PTR _maxlength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN3@SaveBuildC:

; 253  : 	}
; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SaveBuildComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_SV_ClearGameState PROC

; 1926 : {

	push	ebp
	mov	ebp, esp

; 1927 : 	ClearSaveDir();

	call	_ClearSaveDir

; 1928 : 
; 1929 : 	if( svgame.dllFuncs.pfnResetGlobalState != NULL )

	cmp	DWORD PTR _svgame+19296, 0
	je	SHORT $LN1@SV_ClearGa

; 1930 : 		svgame.dllFuncs.pfnResetGlobalState();

	call	DWORD PTR _svgame+19296
$LN1@SV_ClearGa:

; 1931 : }

	pop	ebp
	ret	0
_SV_ClearGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_SV_InitSaveRestore PROC

; 2355 : {

	push	ebp
	mov	ebp, esp

; 2356 : 	pfnSaveGameComment = COM_GetProcAddress( svgame.hInstance, "SV_SaveGameComment" );

	push	OFFSET $SG138533
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _pfnSaveGameComment, eax

; 2357 : }

	pop	ebp
	ret	0
_SV_InitSaveRestore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_newest$ = -20						; size = 4
_found$ = -16						; size = 4
_ft$ = -12						; size = 4
_t$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_GetLatestSave PROC

; 2130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2131 : 	static char	savename[MAX_QPATH];
; 2132 : 	long		newest = 0, ft;

	mov	DWORD PTR _newest$[ebp], 0

; 2133 : 	int		i, found = 0;

	mov	DWORD PTR _found$[ebp], 0

; 2134 : 	search_t		*t;
; 2135 : 
; 2136 : 	if(( t = FS_Search( va( "%s*.sav", DEFAULT_SAVE_DIRECTORY ), true, true )) == NULL )

	push	1
	push	1
	push	OFFSET $SG138420
	push	OFFSET $SG138421
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@SV_GetLate

; 2137 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_GetLate
$LN5@SV_GetLate:

; 2138 : 
; 2139 : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_GetLate
$LN2@SV_GetLate:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_GetLate:
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@SV_GetLate

; 2140 : 	{
; 2141 : 		ft = FS_FileTime( t->filenames[i], true );

	push	1
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft$[ebp], eax

; 2142 : 		
; 2143 : 		// found a match?
; 2144 : 		if( ft > 0 )

	cmp	DWORD PTR _ft$[ebp], 0
	jle	SHORT $LN6@SV_GetLate

; 2145 : 		{
; 2146 : 			// should we use the matched?
; 2147 : 			if( !found || Host_CompareFileTime( newest, ft ) < 0 )

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN8@SV_GetLate
	mov	ecx, DWORD PTR _ft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newest$[ebp]
	push	edx
	call	_Host_CompareFileTime
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN6@SV_GetLate
$LN8@SV_GetLate:

; 2148 : 			{
; 2149 : 				Q_strncpy( savename, t->filenames[i], sizeof( savename ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	OFFSET ?savename@?1??SV_GetLatestSave@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2150 : 				newest = ft;

	mov	ecx, DWORD PTR _ft$[ebp]
	mov	DWORD PTR _newest$[ebp], ecx

; 2151 : 				found = 1;

	mov	DWORD PTR _found$[ebp], 1
$LN6@SV_GetLate:

; 2152 : 			}
; 2153 : 		}
; 2154 : 	}

	jmp	SHORT $LN2@SV_GetLate
$LN3@SV_GetLate:

; 2155 : 
; 2156 : 	Mem_Free( t ); // release search

	push	2156					; 0000086cH
	push	OFFSET $SG138425
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2157 : 
; 2158 : 	if( found )

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN9@SV_GetLate

; 2159 : 		return savename;

	mov	eax, OFFSET ?savename@?1??SV_GetLatestSave@@9@9
	jmp	SHORT $LN1@SV_GetLate
$LN9@SV_GetLate:

; 2160 : 	return NULL; 

	xor	eax, eax
$LN1@SV_GetLate:

; 2161 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetLatestSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_pSaveData$ = -204					; size = 4
_startspot$ = -200					; size = 4
_oldlevel$ = -196					; size = 64
__startspot$ = -132					; size = 64
_level$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_loadfromsavedgame$ = 8					; size = 4
_mapname$ = 12						; size = 4
_start$ = 16						; size = 4
_background$ = 20					; size = 4
_SV_ChangeLevel PROC

; 1939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1940 : 	char		level[MAX_QPATH];
; 1941 : 	char		oldlevel[MAX_QPATH];
; 1942 : 	char		_startspot[MAX_QPATH];
; 1943 : 	char		*startspot = NULL;

	mov	DWORD PTR _startspot$[ebp], 0

; 1944 : 	SAVERESTOREDATA	*pSaveData = NULL;

	mov	DWORD PTR _pSaveData$[ebp], 0

; 1945 : 	
; 1946 : 	if( sv.state != ss_active )

	cmp	DWORD PTR _sv, 2
	je	SHORT $LN2@SV_ChangeL

; 1947 : 	{
; 1948 : 		Con_Printf( S_ERROR "server not running\n");

	push	OFFSET $SG138342
	call	_Con_Printf
	add	esp, 4

; 1949 : 		return;

	jmp	$LN7@SV_ChangeL
$LN2@SV_ChangeL:

; 1950 : 	}
; 1951 : 
; 1952 : 	if( start )

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN3@SV_ChangeL

; 1953 : 	{
; 1954 : 		Q_strncpy( _startspot, start, MAX_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR __startspot$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1955 : 		startspot = _startspot;

	lea	edx, DWORD PTR __startspot$[ebp]
	mov	DWORD PTR _startspot$[ebp], edx
$LN3@SV_ChangeL:

; 1956 : 	}
; 1957 : 
; 1958 : 	Q_strncpy( level, mapname, MAX_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _mapname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1959 : 	Q_strncpy( oldlevel, sv.name, MAX_STRING );

	push	256					; 00000100H
	push	OFFSET _sv+56
	lea	edx, DWORD PTR _oldlevel$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1960 : 
; 1961 : 	if( loadfromsavedgame )

	cmp	DWORD PTR _loadfromsavedgame$[ebp], 0
	je	SHORT $LN4@SV_ChangeL

; 1962 : 	{
; 1963 : 		// smooth transition in-progress
; 1964 : 		svgame.globals->changelevel = true;

	mov	eax, DWORD PTR _svgame+19236
	mov	DWORD PTR [eax+136], 1

; 1965 : 
; 1966 : 		// save the current level's state
; 1967 : 		pSaveData = SaveGameState( true );

	push	1
	call	_SaveGameState
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax
$LN4@SV_ChangeL:

; 1968 : 	}
; 1969 : 
; 1970 : 	SV_InactivateClients ();

	call	_SV_InactivateClients

; 1971 : 	SV_FinalMessage( "", true );

	push	1
	push	OFFSET $SG138345
	call	_SV_FinalMessage
	add	esp, 8

; 1972 : 	SV_DeactivateServer ();

	call	_SV_DeactivateServer

; 1973 : 
; 1974 : 	if( !SV_SpawnServer( level, startspot, background ))

	mov	ecx, DWORD PTR _background$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startspot$[ebp]
	push	edx
	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_SV_SpawnServer
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_ChangeL

; 1975 : 		return;	// ???

	jmp	$LN7@SV_ChangeL
$LN5@SV_ChangeL:

; 1976 : 
; 1977 : 	if( loadfromsavedgame )

	cmp	DWORD PTR _loadfromsavedgame$[ebp], 0
	je	SHORT $LN6@SV_ChangeL

; 1978 : 	{
; 1979 : 		// finish saving gamestate
; 1980 : 		SaveFinish( pSaveData );

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_SaveFinish
	add	esp, 4

; 1981 : 
; 1982 : 		if( !LoadGameState( level, true ))

	push	1
	lea	edx, DWORD PTR _level$[ebp]
	push	edx
	call	_LoadGameState
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@SV_ChangeL

; 1983 : 			SV_SpawnEntities( level );

	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_SV_SpawnEntities
	add	esp, 4
$LN8@SV_ChangeL:

; 1984 : 		LoadAdjacentEnts( oldlevel, startspot );

	mov	ecx, DWORD PTR _startspot$[ebp]
	push	ecx
	lea	edx, DWORD PTR _oldlevel$[ebp]
	push	edx
	call	_LoadAdjacentEnts
	add	esp, 8

; 1985 : 
; 1986 : 		if( sv_newunit.value )

	movss	xmm0, DWORD PTR _sv_newunit+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@SV_ChangeL

; 1987 : 			ClearSaveDir();

	call	_ClearSaveDir
$LN9@SV_ChangeL:

; 1988 : 		SV_ActivateServer( false );

	push	0
	call	_SV_ActivateServer
	add	esp, 4

; 1989 : 	}

	jmp	SHORT $LN7@SV_ChangeL
$LN6@SV_ChangeL:

; 1990 : 	else
; 1991 : 	{
; 1992 : 		// classic quake changelevel
; 1993 : 		svgame.dllFuncs.pfnResetGlobalState();

	call	DWORD PTR _svgame+19296

; 1994 : 		SV_SpawnEntities( level );

	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_SV_SpawnEntities
	add	esp, 4

; 1995 : 		SV_ActivateServer( true );

	push	1
	call	_SV_ActivateServer
	add	esp, 4
$LN7@SV_ChangeL:

; 1996 : 	}
; 1997 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_level$ = 8						; size = 4
_SV_LoadGameState PROC

; 1914 : {

	push	ebp
	mov	ebp, esp

; 1915 : 	return LoadGameState( level, false );

	push	0
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_LoadGameState
	add	esp, 8

; 1916 : }

	pop	ebp
	ret	0
_SV_LoadGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_flags$ = -132						; size = 4
_pFile$ = -128						; size = 4
_validload$ = -124					; size = 4
_gameHeader$ = -120					; size = 116
__$ArrayPad$ = -4					; size = 4
_pPath$ = 8						; size = 4
_SV_LoadGame PROC

; 2005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2006 : 	qboolean		validload = false;

	mov	DWORD PTR _validload$[ebp], 0

; 2007 : 	GAME_HEADER	gameHeader;
; 2008 : 	file_t		*pFile;
; 2009 : 	int		flags;
; 2010 : 
; 2011 : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@SV_LoadGam

; 2012 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN2@SV_LoadGam:

; 2013 : 
; 2014 : 	if( UI_CreditsActive( ))

	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN3@SV_LoadGam

; 2015 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN3@SV_LoadGam:

; 2016 : 
; 2017 : 	if( !COM_CheckString( pPath ))

	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@SV_LoadGam

; 2018 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN4@SV_LoadGam:

; 2019 : 
; 2020 : 	// silently ignore if missed
; 2021 : 	if( !FS_FileExists( pPath, true ))

	push	1
	mov	ecx, DWORD PTR _pPath$[ebp]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@SV_LoadGam

; 2022 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN5@SV_LoadGam:

; 2023 : 
; 2024 : 	// initialize game if needs
; 2025 : 	if( !SV_InitGame( ))

	call	_SV_InitGame
	test	eax, eax
	jne	SHORT $LN6@SV_LoadGam

; 2026 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN6@SV_LoadGam:

; 2027 : 
; 2028 : 	pFile = FS_Open( pPath, "rb", true );

	push	1
	push	OFFSET $SG138364
	mov	edx, DWORD PTR _pPath$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax

; 2029 : 
; 2030 : 	if( pFile )

	cmp	DWORD PTR _pFile$[ebp], 0
	je	$LN11@SV_LoadGam

; 2031 : 	{
; 2032 : 		SV_ClearGameState();

	call	_SV_ClearGameState

; 2033 : 
; 2034 : 		if( SaveReadHeader( pFile, &gameHeader ))

	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_SaveReadHeader
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@SV_LoadGam

; 2035 : 		{
; 2036 : 			DirectoryExtract( pFile, gameHeader.mapCount );

	mov	edx, DWORD PTR _gameHeader$[ebp+112]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_DirectoryExtract
	add	esp, 8

; 2037 : 			validload = true;

	mov	DWORD PTR _validload$[ebp], 1
$LN8@SV_LoadGam:

; 2038 : 		}
; 2039 : 		FS_Close( pFile );

	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 2040 : 
; 2041 : 		if( validload )

	cmp	DWORD PTR _validload$[ebp], 0
	je	SHORT $LN11@SV_LoadGam

; 2042 : 		{
; 2043 : 			// now check for map problems
; 2044 : 			flags = SV_MapIsValid( gameHeader.mapName, GI->sp_entity, NULL );

	push	0
	mov	edx, DWORD PTR _SI+768
	add	edx, 1304				; 00000518H
	push	edx
	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], eax

; 2045 : 
; 2046 : 			if( FBitSet( flags, MAP_INVALID_VERSION ))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 8
	je	SHORT $LN10@SV_LoadGam

; 2047 : 			{
; 2048 : 				Con_Printf( S_ERROR "map %s is invalid or not supported\n", gameHeader.mapName );

	lea	edx, DWORD PTR _gameHeader$[ebp]
	push	edx
	push	OFFSET $SG138369
	call	_Con_Printf
	add	esp, 8

; 2049 : 				validload = false;

	mov	DWORD PTR _validload$[ebp], 0
$LN10@SV_LoadGam:

; 2050 : 			}
; 2051 : 	
; 2052 : 			if( !FBitSet( flags, MAP_IS_EXIST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	jne	SHORT $LN11@SV_LoadGam

; 2053 : 			{
; 2054 : 				Con_Printf( S_ERROR "map %s doesn't exist\n", gameHeader.mapName );

	lea	ecx, DWORD PTR _gameHeader$[ebp]
	push	ecx
	push	OFFSET $SG138371
	call	_Con_Printf
	add	esp, 8

; 2055 : 				validload = false;

	mov	DWORD PTR _validload$[ebp], 0
$LN11@SV_LoadGam:

; 2056 : 			}
; 2057 : 		}
; 2058 : 	}
; 2059 : 
; 2060 : 	if( !validload )

	cmp	DWORD PTR _validload$[ebp], 0
	jne	SHORT $LN12@SV_LoadGam

; 2061 : 	{
; 2062 : 		Con_Printf( S_ERROR "Couldn't load %s\n", pPath );

	mov	edx, DWORD PTR _pPath$[ebp]
	push	edx
	push	OFFSET $SG138373
	call	_Con_Printf
	add	esp, 8

; 2063 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_LoadGam
$LN12@SV_LoadGam:

; 2064 : 	}
; 2065 : 
; 2066 : 	Con_Printf( "Loading game from %s...\n", pPath );

	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	push	OFFSET $SG138374
	call	_Con_Printf
	add	esp, 8

; 2067 : 	Cvar_FullSet( "maxplayers", "1", FCVAR_LATCH );

	push	2048					; 00000800H
	push	OFFSET $SG138375
	push	OFFSET $SG138376
	call	_Cvar_FullSet

; 2068 : 	Cvar_SetValue( "deathmatch", 0 );

	add	esp, 8
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138377
	call	_Cvar_SetValue

; 2069 : 	Cvar_SetValue( "coop", 0 );

	add	esp, 4
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG138378
	call	_Cvar_SetValue
	add	esp, 8

; 2070 : 	COM_LoadGame( gameHeader.mapName );

	lea	ecx, DWORD PTR _gameHeader$[ebp]
	push	ecx
	call	_COM_LoadGame
	add	esp, 4

; 2071 : 
; 2072 : 	return true;

	mov	eax, 1
$LN1@SV_LoadGam:

; 2073 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_result$ = -348						; size = 4
_n$ = -344						; size = 4
_savename$ = -340					; size = 256
_comment$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_pName$ = 8						; size = 4
_SV_SaveGame PROC

; 2081 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2082 : 	char	comment[80];
; 2083 : 	int	n, result;
; 2084 : 	string	savename;
; 2085 : 
; 2086 : 	if( !COM_CheckString( pName ))

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_SaveGam

; 2087 : 		return;

	jmp	$LN1@SV_SaveGam
$LN5@SV_SaveGam:

; 2088 : 
; 2089 : 	// can we save at this point?
; 2090 : 	if( !IsValidSave( )) return;

	call	_IsValidSave
	test	eax, eax
	jne	SHORT $LN6@SV_SaveGam
	jmp	$LN1@SV_SaveGam
$LN6@SV_SaveGam:

; 2091 : 
; 2092 : 	if( !Q_stricmp( pName, "new" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138393
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@SV_SaveGam

; 2093 : 	{
; 2094 : 		// scan for a free filename
; 2095 : 		for( n = 0; n < 1000; n++ )

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@SV_SaveGam
$LN2@SV_SaveGam:
	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx
$LN4@SV_SaveGam:
	cmp	DWORD PTR _n$[ebp], 1000		; 000003e8H
	jge	SHORT $LN3@SV_SaveGam

; 2096 : 		{
; 2097 : 			if( !SaveGetName( n, savename ))

	lea	eax, DWORD PTR _savename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_SaveGetName
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_SaveGam

; 2098 : 				return;

	jmp	$LN1@SV_SaveGam
$LN9@SV_SaveGam:

; 2099 : 
; 2100 : 			if( !FS_FileExists( va( "%s%s.sav", DEFAULT_SAVE_DIRECTORY, savename ), true ))

	push	1
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	push	OFFSET $SG138396
	push	OFFSET $SG138397
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@SV_SaveGam

; 2101 : 				break;

	jmp	SHORT $LN3@SV_SaveGam
$LN10@SV_SaveGam:

; 2102 : 		}

	jmp	SHORT $LN2@SV_SaveGam
$LN3@SV_SaveGam:

; 2103 : 
; 2104 : 		if( n == 1000 )

	cmp	DWORD PTR _n$[ebp], 1000		; 000003e8H
	jne	SHORT $LN11@SV_SaveGam

; 2105 : 		{
; 2106 : 			Con_Printf( S_ERROR "no free slots for savegame\n" );

	push	OFFSET $SG138399
	call	_Con_Printf
	add	esp, 4

; 2107 : 			return;

	jmp	$LN1@SV_SaveGam
$LN11@SV_SaveGam:

; 2108 : 		}
; 2109 : 	}

	jmp	SHORT $LN8@SV_SaveGam
$LN7@SV_SaveGam:

; 2110 : 	else Q_strncpy( savename, pName, sizeof( savename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _savename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@SV_SaveGam:

; 2111 : 
; 2112 : 	// unload previous image from memory (it's will be overwritten)
; 2113 : 	GL_FreeImage( va( "%s%s.bmp", DEFAULT_SAVE_DIRECTORY, savename ));

	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	push	OFFSET $SG138400
	push	OFFSET $SG138401
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_GL_FreeImage
	add	esp, 4

; 2114 : 
; 2115 : 	SaveBuildComment( comment, sizeof( comment ));

	push	80					; 00000050H
	lea	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_SaveBuildComment
	add	esp, 8

; 2116 : 	result = SaveGameSlot( savename, comment );

	lea	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	call	_SaveGameSlot
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 2117 : 
; 2118 : 	if( result && !FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN1@SV_SaveGam
	mov	eax, DWORD PTR _host+34748
	and	eax, 2
	jne	SHORT $LN1@SV_SaveGam

; 2119 : 		CL_HudMessage( "GAMESAVED" ); // defined in titles.txt

	push	OFFSET $SG138403
	call	_CL_HudMessage
	add	esp, 4
$LN1@SV_SaveGam:

; 2120 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SaveGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesLeft PROC				; COMDAT

; 105  : _inline int MSG_GetNumBytesLeft( sizebuf_t *sb ) { return MSG_GetNumBitsLeft( sb ) >> 3; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	sar	eax, 3
	pop	ebp
	ret	0
_MSG_GetNumBytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\server\sv_save.c
_TEXT	SEGMENT
_fileTime$1 = -848					; size = 8
_nNumberOfFields$ = -840				; size = 4
tv184 = -836						; size = 4
_file_tm$2 = -832					; size = 4
_flags$3 = -828						; size = 4
tv180 = -824						; size = 4
$T4 = -820						; size = 4
_pFieldName$ = -816					; size = 4
_tokenCount$ = -812					; size = 4
_tokenSize$ = -808					; size = 4
_size$ = -804						; size = 4
_nFieldSize$ = -800					; size = 4
_tag$ = -796						; size = 4
_pSaveData$ = -792					; size = 4
_pTokenList$ = -788					; size = 4
_i$ = -784						; size = 4
_f$ = -780						; size = 4
_pData$ = -776						; size = 4
_description$ = -772					; size = 256
_timestring$5 = -516					; size = 256
_mapName$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_savename$ = 8						; size = 4
_comment$ = 12						; size = 4
_SV_GetSaveComment PROC

; 2171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 848				; 00000350H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2172 : 	int	i, tag, size, nNumberOfFields, nFieldSize, tokenSize, tokenCount;
; 2173 : 	char	*pData, *pSaveData, *pFieldName, **pTokenList;
; 2174 : 	string	mapName, description;
; 2175 : 	file_t	*f;
; 2176 : 
; 2177 : 	if(( f = FS_Open( savename, "rb", true )) == NULL )

	push	1
	push	OFFSET $SG138480
	mov	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN10@SV_GetSave

; 2178 : 	{
; 2179 : 		// just not exist - clear comment
; 2180 : 		Q_strncpy( comment, "", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138481
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2181 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN10@SV_GetSave:

; 2182 : 	}
; 2183 : 
; 2184 : 	FS_Read( f, &tag, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _tag$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2185 : 	if( tag != SAVEGAME_HEADER )

	cmp	DWORD PTR _tag$[ebp], 1447121738	; 5641534aH
	je	SHORT $LN11@SV_GetSave

; 2186 : 	{
; 2187 : 		// invalid header
; 2188 : 		Q_strncpy( comment, "<corrupted>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138483
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2189 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 2190 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN11@SV_GetSave:

; 2191 : 	}
; 2192 : 		
; 2193 : 	FS_Read( f, &tag, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2194 : 
; 2195 : 	if( tag == 0x0065 )

	cmp	DWORD PTR _tag$[ebp], 101		; 00000065H
	jne	SHORT $LN12@SV_GetSave

; 2196 : 	{
; 2197 : 		Q_strncpy( comment, "old version Xash3D <unsupported>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138485
	mov	edx, DWORD PTR _comment$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2198 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2199 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN12@SV_GetSave:

; 2200 : 	}
; 2201 : 
; 2202 : 	if( tag < SAVEGAME_VERSION )

	cmp	DWORD PTR _tag$[ebp], 113		; 00000071H
	jge	SHORT $LN13@SV_GetSave

; 2203 : 	{
; 2204 : 		Q_strncpy( comment, "<old version>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138487
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2205 : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 2206 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN13@SV_GetSave:

; 2207 : 	}
; 2208 : 
; 2209 : 	if( tag > SAVEGAME_VERSION )

	cmp	DWORD PTR _tag$[ebp], 113		; 00000071H
	jle	SHORT $LN14@SV_GetSave

; 2210 : 	{
; 2211 : 		// old xash version ?
; 2212 : 		Q_strncpy( comment, "<invalid version>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138489
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2213 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 2214 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN14@SV_GetSave:

; 2215 : 	}
; 2216 : 
; 2217 : 	mapName[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN36@SV_GetSave
	jmp	SHORT $LN37@SV_GetSave
$LN36@SV_GetSave:
	call	___report_rangecheckfailure
$LN37@SV_GetSave:
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _mapName$[ebp+ecx], 0

; 2218 : 	comment[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _comment$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 2219 : 
; 2220 : 	FS_Read( f, &size, sizeof( int ));

	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2221 : 	FS_Read( f, &tokenCount, sizeof( int ));	// These two ints are the token list

	push	4
	lea	ecx, DWORD PTR _tokenCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2222 : 	FS_Read( f, &tokenSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2223 : 	size += tokenSize;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 2224 : 
; 2225 : 	// sanity check.
; 2226 : 	if( tokenCount < 0 || tokenCount > SAVE_HASHSTRINGS )

	cmp	DWORD PTR _tokenCount$[ebp], 0
	jl	SHORT $LN16@SV_GetSave
	cmp	DWORD PTR _tokenCount$[ebp], 4095	; 00000fffH
	jle	SHORT $LN15@SV_GetSave
$LN16@SV_GetSave:

; 2227 : 	{
; 2228 : 		Q_strncpy( comment, "<corrupted hashtable>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138492
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2229 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 2230 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN15@SV_GetSave:

; 2231 : 	}
; 2232 : 
; 2233 : 	if( tokenSize < 0 || tokenSize > SAVE_HEAPSIZE )

	cmp	DWORD PTR _tokenSize$[ebp], 0
	jl	SHORT $LN18@SV_GetSave
	cmp	DWORD PTR _tokenSize$[ebp], 4194304	; 00400000H
	jle	SHORT $LN17@SV_GetSave
$LN18@SV_GetSave:

; 2234 : 	{
; 2235 : 		Q_strncpy( comment, "<corrupted hashtable>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138495
	mov	edx, DWORD PTR _comment$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2236 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2237 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN17@SV_GetSave:

; 2238 : 	}
; 2239 : 
; 2240 : 	pSaveData = (char *)Mem_Malloc( host.mempool, size );

	push	2240					; 000008c0H
	push	OFFSET $SG138496
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pSaveData$[ebp], eax

; 2241 : 	FS_Read( f, pSaveData, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2242 : 	pData = pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR _pData$[ebp], eax

; 2243 : 
; 2244 : 	// allocate a table for the strings, and parse the table
; 2245 : 	if( tokenSize > 0 )

	cmp	DWORD PTR _tokenSize$[ebp], 0
	jle	$LN19@SV_GetSave

; 2246 : 	{
; 2247 : 		pTokenList = Mem_Calloc( host.mempool, tokenCount * sizeof( char* ));

	push	2247					; 000008c7H
	push	OFFSET $SG138499
	push	1
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pTokenList$[ebp], eax

; 2248 : 
; 2249 : 		// make sure the token strings pointed to by the pToken hashtable.
; 2250 : 		for( i = 0; i < tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_GetSave
$LN2@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_GetSave:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _tokenCount$[ebp]
	jge	SHORT $LN3@SV_GetSave

; 2251 : 		{
; 2252 : 			pTokenList[i] = *pData ? pData : NULL;	// point to each string in the pToken table

	mov	edx, DWORD PTR _pData$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN38@SV_GetSave
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR tv180[ebp], ecx
	jmp	SHORT $LN39@SV_GetSave
$LN38@SV_GetSave:
	mov	DWORD PTR tv180[ebp], 0
$LN39@SV_GetSave:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pTokenList$[ebp]
	mov	ecx, DWORD PTR tv180[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN5@SV_GetSave:

; 2253 : 			while( *pData++ );			// find next token (after next null)

	mov	edx, DWORD PTR _pData$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pData$[ebp], ecx
	cmp	DWORD PTR tv184[ebp], 0
	je	SHORT $LN6@SV_GetSave
	jmp	SHORT $LN5@SV_GetSave
$LN6@SV_GetSave:

; 2254 : 		}

	jmp	$LN2@SV_GetSave
$LN3@SV_GetSave:

; 2255 : 	}

	jmp	SHORT $LN20@SV_GetSave
$LN19@SV_GetSave:

; 2256 : 	else pTokenList = NULL;

	mov	DWORD PTR _pTokenList$[ebp], 0
$LN20@SV_GetSave:

; 2257 : 
; 2258 : 	// short, short (size, index of field name)
; 2259 : 	nFieldSize = *(short *)pData;

	mov	edx, DWORD PTR _pData$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _nFieldSize$[ebp], eax

; 2260 : 	pData += sizeof( short );

	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pData$[ebp], ecx

; 2261 : 	pFieldName = pTokenList[*(short *)pData];

	mov	edx, DWORD PTR _pData$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _pTokenList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pFieldName$[ebp], edx

; 2262 : 
; 2263 : 	if( Q_stricmp( pFieldName, "GameHeader" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138501
	mov	eax, DWORD PTR _pFieldName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@SV_GetSave

; 2264 : 	{
; 2265 : 		Q_strncpy( comment, "<missing GameHeader>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138502
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2266 : 		if( pTokenList ) Mem_Free( pTokenList );

	cmp	DWORD PTR _pTokenList$[ebp], 0
	je	SHORT $LN22@SV_GetSave
	push	2266					; 000008daH
	push	OFFSET $SG138504
	mov	edx, DWORD PTR _pTokenList$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN22@SV_GetSave:

; 2267 : 		if( pSaveData ) Mem_Free( pSaveData );

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	SHORT $LN23@SV_GetSave
	push	2267					; 000008dbH
	push	OFFSET $SG138506
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@SV_GetSave:

; 2268 : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 2269 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN21@SV_GetSave:

; 2270 : 	}
; 2271 : 
; 2272 : 	// int (fieldcount)
; 2273 : 	pData += sizeof( short );

	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 2
	mov	DWORD PTR _pData$[ebp], edx

; 2274 : 	nNumberOfFields = (int)*pData;

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _nNumberOfFields$[ebp], ecx

; 2275 : 	pData += nFieldSize;

	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, DWORD PTR _nFieldSize$[ebp]
	mov	DWORD PTR _pData$[ebp], edx

; 2276 : 
; 2277 : 	// each field is a short (size), short (index of name), binary string of "size" bytes (data)
; 2278 : 	for( i = 0; i < nNumberOfFields; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@SV_GetSave
$LN7@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@SV_GetSave:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nNumberOfFields$[ebp]
	jge	$LN8@SV_GetSave

; 2279 : 	{
; 2280 : 		// Data order is:
; 2281 : 		// Size
; 2282 : 		// szName
; 2283 : 		// Actual Data
; 2284 : 		nFieldSize = *(short *)pData;

	mov	edx, DWORD PTR _pData$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _nFieldSize$[ebp], eax

; 2285 : 		pData += sizeof( short );

	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pData$[ebp], ecx

; 2286 : 
; 2287 : 		pFieldName = pTokenList[*(short *)pData];

	mov	edx, DWORD PTR _pData$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _pTokenList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pFieldName$[ebp], edx

; 2288 : 		pData += sizeof( short );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 2
	mov	DWORD PTR _pData$[ebp], eax

; 2289 : 
; 2290 : 		if( !Q_stricmp( pFieldName, "comment" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138509
	mov	ecx, DWORD PTR _pFieldName$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@SV_GetSave

; 2291 : 		{
; 2292 : 			Q_strncpy( description, pData, nFieldSize );

	mov	edx, DWORD PTR _nFieldSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _description$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2293 : 		}

	jmp	SHORT $LN25@SV_GetSave
$LN24@SV_GetSave:

; 2294 : 		else if( !Q_stricmp( pFieldName, "mapName" ))

	push	99999					; 0001869fH
	push	OFFSET $SG138511
	mov	edx, DWORD PTR _pFieldName$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_GetSave

; 2295 : 		{
; 2296 : 			Q_strncpy( mapName, pData, nFieldSize );

	mov	eax, DWORD PTR _nFieldSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mapName$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN25@SV_GetSave:

; 2297 : 		}
; 2298 : 
; 2299 : 		// move to start of next field.
; 2300 : 		pData += nFieldSize;

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _nFieldSize$[ebp]
	mov	DWORD PTR _pData$[ebp], eax

; 2301 : 	}

	jmp	$LN7@SV_GetSave
$LN8@SV_GetSave:

; 2302 : 
; 2303 : 	// delete the string table we allocated
; 2304 : 	if( pTokenList ) Mem_Free( pTokenList );

	cmp	DWORD PTR _pTokenList$[ebp], 0
	je	SHORT $LN27@SV_GetSave
	push	2304					; 00000900H
	push	OFFSET $SG138513
	mov	ecx, DWORD PTR _pTokenList$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN27@SV_GetSave:

; 2305 : 	if( pSaveData ) Mem_Free( pSaveData );

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	SHORT $LN28@SV_GetSave
	push	2305					; 00000901H
	push	OFFSET $SG138515
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN28@SV_GetSave:

; 2306 : 	FS_Close( f );	

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2307 : 
; 2308 : 	// at least mapname should be filled
; 2309 : 	if( Q_strlen( mapName ) > 0 )

	lea	ecx, DWORD PTR _mapName$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jle	$LN29@SV_GetSave

; 2310 : 	{
; 2311 : 		time_t		fileTime;
; 2312 : 		const struct tm	*file_tm;
; 2313 : 		string		timestring;
; 2314 : 		int		flags;
; 2315 : 
; 2316 : 		// now check for map problems
; 2317 : 		flags = SV_MapIsValid( mapName, GI->sp_entity, NULL );

	push	0
	mov	edx, DWORD PTR _SI+768
	add	edx, 1304				; 00000518H
	push	edx
	lea	eax, DWORD PTR _mapName$[ebp]
	push	eax
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$3[ebp], eax

; 2318 : 
; 2319 : 		if( FBitSet( flags, MAP_INVALID_VERSION ))

	mov	ecx, DWORD PTR _flags$3[ebp]
	and	ecx, 8
	je	SHORT $LN30@SV_GetSave

; 2320 : 		{
; 2321 : 			Q_strncpy( comment, va( "<map %s has invalid format>", mapName ), MAX_STRING );

	push	256					; 00000100H
	lea	edx, DWORD PTR _mapName$[ebp]
	push	edx
	push	OFFSET $SG138518
	call	_va
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2322 : 			return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN30@SV_GetSave:

; 2323 : 		}
; 2324 : 	
; 2325 : 		if( !FBitSet( flags, MAP_IS_EXIST ))

	mov	ecx, DWORD PTR _flags$3[ebp]
	and	ecx, 1
	jne	SHORT $LN31@SV_GetSave

; 2326 : 		{
; 2327 : 			Q_strncpy( comment, va( "<map %s is missed>", mapName ), MAX_STRING );

	push	256					; 00000100H
	lea	edx, DWORD PTR _mapName$[ebp]
	push	edx
	push	OFFSET $SG138520
	call	_va
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2328 : 			return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN31@SV_GetSave:

; 2329 : 		}
; 2330 : 	
; 2331 : 		fileTime = FS_FileTime( savename, true );

	push	1
	mov	ecx, DWORD PTR _savename$[ebp]
	push	ecx
	call	_FS_FileTime
	add	esp, 8
	cdq
	mov	DWORD PTR _fileTime$1[ebp], eax
	mov	DWORD PTR _fileTime$1[ebp+4], edx

; 2332 : 		file_tm = localtime( &fileTime );

	lea	edx, DWORD PTR _fileTime$1[ebp]
	push	edx
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _file_tm$2[ebp], eax

; 2333 : 
; 2334 : 		// split comment to sections
; 2335 : 		if( Q_strstr( savename, "quick" ))

	push	OFFSET $SG138523
	mov	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@SV_GetSave

; 2336 : 			Q_strncat( comment, "[quick]", CS_SIZE );

	push	64					; 00000040H
	push	OFFSET $SG138524
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN33@SV_GetSave
$LN32@SV_GetSave:

; 2337 : 		else if( Q_strstr( savename, "autosave" ))

	push	OFFSET $SG138526
	mov	edx, DWORD PTR _savename$[ebp]
	push	edx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@SV_GetSave

; 2338 : 			Q_strncat( comment, "[autosave]", CS_SIZE );

	push	64					; 00000040H
	push	OFFSET $SG138527
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN33@SV_GetSave:

; 2339 : 		Q_strncat( comment, description, CS_SIZE );

	push	64					; 00000040H
	lea	ecx, DWORD PTR _description$[ebp]
	push	ecx
	mov	edx, DWORD PTR _comment$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 2340 : 		strftime( timestring, sizeof ( timestring ), "%b%d %Y", file_tm );

	mov	eax, DWORD PTR _file_tm$2[ebp]
	push	eax
	push	OFFSET $SG138528
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$5[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 2341 : 		Q_strncpy( comment + CS_SIZE, timestring, CS_TIME );

	push	16					; 00000010H
	lea	edx, DWORD PTR _timestring$5[ebp]
	push	edx
	mov	eax, DWORD PTR _comment$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2342 : 		strftime( timestring, sizeof( timestring ), "%H:%M", file_tm );

	mov	ecx, DWORD PTR _file_tm$2[ebp]
	push	ecx
	push	OFFSET $SG138529
	push	256					; 00000100H
	lea	edx, DWORD PTR _timestring$5[ebp]
	push	edx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 2343 : 		Q_strncpy( comment + CS_SIZE + CS_TIME, timestring, CS_TIME );

	push	16					; 00000010H
	lea	eax, DWORD PTR _timestring$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2344 : 		Q_strncpy( comment + CS_SIZE + (CS_TIME * 2), description + CS_SIZE, CS_SIZE );

	push	64					; 00000040H
	lea	edx, DWORD PTR _description$[ebp+64]
	push	edx
	mov	eax, DWORD PTR _comment$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2345 : 
; 2346 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN35@SV_GetSave
$LN29@SV_GetSave:

; 2347 : 	}	
; 2348 : 
; 2349 : 	Q_strncpy( comment, "<unknown version>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET $SG138530
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2350 : 
; 2351 : 	return 0;

	xor	eax, eax
$LN35@SV_GetSave:

; 2352 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetSaveComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC

; 509  :         {

	push	ebp
	mov	ebp, esp

; 510  :             #pragma warning(push)
; 511  :             #pragma warning(disable: 4996)
; 512  :             return _localtime64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64
	add	esp, 4

; 513  :             #pragma warning(pop)
; 514  :         }

	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
END
