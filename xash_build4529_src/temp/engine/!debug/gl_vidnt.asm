; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\client\gl_vidnt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vidmode
PUBLIC	_opengl_dll
_DATA	SEGMENT
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_r_temppool:DWORD
COMM	_tr:BYTE:0105b0H
COMM	_glConfig:BYTE:088H
COMM	_glState:BYTE:0244H
COMM	_glw_state:BYTE:01cH
COMM	_gl_texture_anisotropy:DWORD
COMM	_gl_extensions:DWORD
COMM	_gl_check_errors:DWORD
COMM	_gl_texture_lodbias:DWORD
COMM	_gl_texture_nearest:DWORD
COMM	_gl_lightmap_nearest:DWORD
COMM	_gl_keeptjunctions:DWORD
COMM	_gl_emboss_scale:DWORD
COMM	_gl_round_down:DWORD
COMM	_gl_detailscale:DWORD
COMM	_gl_wireframe:DWORD
COMM	_gl_polyoffset:DWORD
COMM	_gl_finish:DWORD
COMM	_gl_nosort:DWORD
COMM	_gl_clear:DWORD
COMM	_gl_test:DWORD
COMM	_gl_msaa:DWORD
COMM	_r_speeds:DWORD
COMM	_r_fullbright:DWORD
COMM	_r_norefresh:DWORD
COMM	_r_showtree:DWORD
COMM	_r_lighting_extended:DWORD
COMM	_r_lighting_modulate:DWORD
COMM	_r_lighting_ambient:DWORD
COMM	_r_detailtextures:DWORD
COMM	_r_drawentities:DWORD
COMM	_r_adjust_fov:DWORD
COMM	_r_decals:DWORD
COMM	_r_novis:DWORD
COMM	_r_nocull:DWORD
COMM	_r_lockpvs:DWORD
COMM	_r_lockfrustum:DWORD
COMM	_r_traceglow:DWORD
COMM	_r_dynamic:DWORD
COMM	_r_lightmap:DWORD
COMM	_vid_fullscreen:DWORD
COMM	_vid_brightness:DWORD
COMM	_vid_gamma:DWORD
COMM	_vid_mode:DWORD
COMM	_gl_wgl_msaa_samples:DWORD
COMM	_window_xpos:DWORD
COMM	_window_ypos:DWORD
COMM	_gl_vsync:DWORD
COMM	_vid_displayfrequency:DWORD
COMM	_gl_showtextures:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
_DATA	ENDS
_DATA	SEGMENT
_vidmode DD	FLAT:$SG143464
	DD	0280H
	DD	01e0H
	DD	00H
	DD	FLAT:$SG143465
	DD	0320H
	DD	0258H
	DD	00H
	DD	FLAT:$SG143466
	DD	03c0H
	DD	02d0H
	DD	00H
	DD	FLAT:$SG143467
	DD	0400H
	DD	0300H
	DD	00H
	DD	FLAT:$SG143468
	DD	0480H
	DD	0360H
	DD	00H
	DD	FLAT:$SG143469
	DD	0500H
	DD	0320H
	DD	00H
	DD	FLAT:$SG143470
	DD	0500H
	DD	03c0H
	DD	00H
	DD	FLAT:$SG143471
	DD	0500H
	DD	0400H
	DD	00H
	DD	FLAT:$SG143472
	DD	0640H
	DD	04b0H
	DD	00H
	DD	FLAT:$SG143473
	DD	0800H
	DD	0600H
	DD	00H
	DD	FLAT:$SG143474
	DD	0320H
	DD	01e0H
	DD	01H
	DD	FLAT:$SG143475
	DD	0358H
	DD	01e0H
	DD	01H
	DD	FLAT:$SG143476
	DD	03c0H
	DD	021cH
	DD	01H
	DD	FLAT:$SG143477
	DD	0400H
	DD	0240H
	DD	01H
	DD	FLAT:$SG143478
	DD	0400H
	DD	0258H
	DD	01H
	DD	FLAT:$SG143479
	DD	0500H
	DD	02d0H
	DD	01H
	DD	FLAT:$SG143480
	DD	0550H
	DD	0300H
	DD	01H
	DD	FLAT:$SG143481
	DD	0556H
	DD	0300H
	DD	01H
	DD	FLAT:$SG143482
	DD	05a0H
	DD	0384H
	DD	01H
	DD	FLAT:$SG143483
	DD	0690H
	DD	041aH
	DD	01H
	DD	FLAT:$SG143484
	DD	0780H
	DD	0438H
	DD	01H
	DD	FLAT:$SG143485
	DD	0780H
	DD	04b0H
	DD	01H
	DD	FLAT:$SG143486
	DD	0a00H
	DD	05a0H
	DD	01H
	DD	FLAT:$SG143487
	DD	0a00H
	DD	0640H
	DD	01H
	DD	FLAT:$SG143488
	DD	0640H
	DD	0384H
	DD	01H
	DD	FLAT:$SG143489
	DD	0f00H
	DD	0870H
	DD	01H
$SG143464 DB	'640 x 480', 00H
	ORG $+2
$SG143465 DB	'800 x 600', 00H
	ORG $+2
$SG143466 DB	'960 x 720', 00H
	ORG $+2
$SG143467 DB	'1024 x 768', 00H
	ORG $+1
$SG143468 DB	'1152 x 864', 00H
	ORG $+1
$SG143469 DB	'1280 x 800', 00H
	ORG $+1
$SG143470 DB	'1280 x 960', 00H
	ORG $+1
$SG143471 DB	'1280 x 1024', 00H
$SG143472 DB	'1600 x 1200', 00H
$SG143473 DB	'2048 x 1536', 00H
$SG143474 DB	'800 x 480 (wide)', 00H
	ORG $+3
$SG143475 DB	'856 x 480 (wide)', 00H
	ORG $+3
$SG143476 DB	'960 x 540 (wide)', 00H
	ORG $+3
$SG143477 DB	'1024 x 576 (wide)', 00H
	ORG $+2
$SG143478 DB	'1024 x 600 (wide)', 00H
	ORG $+2
$SG143479 DB	'1280 x 720 (wide)', 00H
	ORG $+2
$SG143480 DB	'1360 x 768 (wide)', 00H
	ORG $+2
$SG143481 DB	'1366 x 768 (wide)', 00H
	ORG $+2
$SG143482 DB	'1440 x 900 (wide)', 00H
	ORG $+2
$SG143483 DB	'1680 x 1050 (wide)', 00H
	ORG $+1
$SG143484 DB	'1920 x 1080 (wide)', 00H
	ORG $+1
$SG143485 DB	'1920 x 1200 (wide)', 00H
	ORG $+1
$SG143486 DB	'2560 x 1440 (wide)', 00H
	ORG $+1
$SG143487 DB	'2560 x 1600 (wide)', 00H
	ORG $+1
$SG143488 DB	'1600 x 900 (wide)', 00H
	ORG $+2
$SG143489 DB	'3840 x 2160 (wide)', 00H
	ORG $+1
$SG143617 DB	'glClearColor', 00H
	ORG $+3
$SG143618 DB	'glClear', 00H
$SG143619 DB	'glAlphaFunc', 00H
$SG143620 DB	'glBlendFunc', 00H
$SG143621 DB	'glCullFace', 00H
	ORG $+1
$SG143622 DB	'glDrawBuffer', 00H
	ORG $+3
$SG143623 DB	'glReadBuffer', 00H
	ORG $+3
$SG143624 DB	'glAccum', 00H
$SG143625 DB	'glEnable', 00H
	ORG $+3
$SG143626 DB	'glDisable', 00H
	ORG $+2
$SG143627 DB	'glEnableClientState', 00H
$SG143628 DB	'glDisableClientState', 00H
	ORG $+3
$SG143629 DB	'glGetBooleanv', 00H
	ORG $+2
$SG143630 DB	'glGetDoublev', 00H
	ORG $+3
$SG143631 DB	'glGetFloatv', 00H
$SG143632 DB	'glGetIntegerv', 00H
	ORG $+2
$SG143633 DB	'glGetError', 00H
	ORG $+1
$SG143634 DB	'glGetString', 00H
$SG143635 DB	'glFinish', 00H
	ORG $+3
$SG143636 DB	'glFlush', 00H
$SG143637 DB	'glClearDepth', 00H
	ORG $+3
$SG143638 DB	'glDepthFunc', 00H
$SG143639 DB	'glDepthMask', 00H
$SG143640 DB	'glDepthRange', 00H
	ORG $+3
$SG143641 DB	'glFrontFace', 00H
$SG143642 DB	'glDrawElements', 00H
	ORG $+1
$SG143643 DB	'glDrawArrays', 00H
	ORG $+3
$SG143644 DB	'glColorMask', 00H
$SG143645 DB	'glIndexPointer', 00H
	ORG $+1
$SG143646 DB	'glVertexPointer', 00H
$SG143647 DB	'glNormalPointer', 00H
$SG143648 DB	'glColorPointer', 00H
	ORG $+1
$SG143649 DB	'glTexCoordPointer', 00H
	ORG $+2
$SG143650 DB	'glArrayElement', 00H
	ORG $+1
$SG143651 DB	'glColor3f', 00H
	ORG $+2
$SG143652 DB	'glColor3fv', 00H
	ORG $+1
$SG143653 DB	'glColor4f', 00H
	ORG $+2
$SG143654 DB	'glColor4fv', 00H
	ORG $+1
$SG143655 DB	'glColor3ub', 00H
	ORG $+1
$SG143656 DB	'glColor4ub', 00H
	ORG $+1
$SG143657 DB	'glColor4ubv', 00H
$SG143658 DB	'glTexCoord1f', 00H
	ORG $+3
$SG143659 DB	'glTexCoord2f', 00H
	ORG $+3
$SG143660 DB	'glTexCoord3f', 00H
	ORG $+3
$SG143661 DB	'glTexCoord4f', 00H
	ORG $+3
$SG143662 DB	'glTexCoord1fv', 00H
	ORG $+2
$SG143663 DB	'glTexCoord2fv', 00H
	ORG $+2
$SG143664 DB	'glTexCoord3fv', 00H
	ORG $+2
$SG143665 DB	'glTexCoord4fv', 00H
	ORG $+2
$SG143666 DB	'glTexGenf', 00H
	ORG $+2
$SG143667 DB	'glTexGenfv', 00H
	ORG $+1
$SG143668 DB	'glTexGeni', 00H
	ORG $+2
$SG143669 DB	'glVertex2f', 00H
	ORG $+1
$SG143670 DB	'glVertex3f', 00H
	ORG $+1
$SG143671 DB	'glVertex3fv', 00H
$SG143672 DB	'glNormal3f', 00H
	ORG $+1
$SG143673 DB	'glNormal3fv', 00H
$SG143674 DB	'glBegin', 00H
$SG143675 DB	'glEnd', 00H
	ORG $+2
$SG143676 DB	'glLineWidth', 00H
$SG143677 DB	'glPointSize', 00H
$SG143678 DB	'glMatrixMode', 00H
	ORG $+3
$SG143679 DB	'glOrtho', 00H
$SG143680 DB	'glRasterPos2f', 00H
	ORG $+2
$SG143681 DB	'glFrustum', 00H
	ORG $+2
$SG143682 DB	'glViewport', 00H
	ORG $+1
$SG143683 DB	'glPushMatrix', 00H
	ORG $+3
$SG143684 DB	'glPopMatrix', 00H
$SG143685 DB	'glPushAttrib', 00H
	ORG $+3
$SG143686 DB	'glPopAttrib', 00H
$SG143687 DB	'glLoadIdentity', 00H
	ORG $+1
$SG143688 DB	'glLoadMatrixd', 00H
	ORG $+2
$SG143689 DB	'glLoadMatrixf', 00H
	ORG $+2
$SG143690 DB	'glMultMatrixd', 00H
	ORG $+2
$SG143691 DB	'glMultMatrixf', 00H
	ORG $+2
$SG143692 DB	'glRotated', 00H
	ORG $+2
$SG143693 DB	'glRotatef', 00H
	ORG $+2
$SG143694 DB	'glScaled', 00H
	ORG $+3
$SG143695 DB	'glScalef', 00H
	ORG $+3
$SG143696 DB	'glTranslated', 00H
	ORG $+3
$SG143697 DB	'glTranslatef', 00H
	ORG $+3
$SG143698 DB	'glReadPixels', 00H
	ORG $+3
$SG143699 DB	'glDrawPixels', 00H
	ORG $+3
$SG143700 DB	'glStencilFunc', 00H
	ORG $+2
$SG143701 DB	'glStencilMask', 00H
	ORG $+2
$SG143702 DB	'glStencilOp', 00H
$SG143703 DB	'glClearStencil', 00H
	ORG $+1
$SG143704 DB	'glIsEnabled', 00H
$SG143705 DB	'glIsList', 00H
	ORG $+3
$SG143706 DB	'glIsTexture', 00H
$SG143707 DB	'glTexEnvf', 00H
	ORG $+2
$SG143708 DB	'glTexEnvfv', 00H
	ORG $+1
$SG143709 DB	'glTexEnvi', 00H
	ORG $+2
$SG143710 DB	'glTexParameterf', 00H
$SG143711 DB	'glTexParameterfv', 00H
	ORG $+3
$SG143712 DB	'glTexParameteri', 00H
$SG143713 DB	'glHint', 00H
	ORG $+1
$SG143714 DB	'glPixelStoref', 00H
	ORG $+2
$SG143715 DB	'glPixelStorei', 00H
	ORG $+2
$SG143716 DB	'glGenTextures', 00H
	ORG $+2
$SG143717 DB	'glDeleteTextures', 00H
	ORG $+3
$SG143718 DB	'glBindTexture', 00H
	ORG $+2
$SG143719 DB	'glTexImage1D', 00H
	ORG $+3
$SG143720 DB	'glTexImage2D', 00H
	ORG $+3
$SG143721 DB	'glTexSubImage1D', 00H
$SG143722 DB	'glTexSubImage2D', 00H
$SG143723 DB	'glCopyTexImage1D', 00H
	ORG $+3
$SG143724 DB	'glCopyTexImage2D', 00H
	ORG $+3
$SG143725 DB	'glCopyTexSubImage1D', 00H
$SG143726 DB	'glCopyTexSubImage2D', 00H
$SG143727 DB	'glScissor', 00H
	ORG $+2
$SG143728 DB	'glGetTexImage', 00H
	ORG $+2
$SG143729 DB	'glGetTexEnviv', 00H
	ORG $+2
$SG143730 DB	'glPolygonOffset', 00H
$SG143731 DB	'glPolygonMode', 00H
	ORG $+2
$SG143732 DB	'glPolygonStipple', 00H
	ORG $+3
$SG143733 DB	'glClipPlane', 00H
$SG143734 DB	'glGetClipPlane', 00H
	ORG $+1
$SG143735 DB	'glShadeModel', 00H
	ORG $+3
$SG143736 DB	'glGetTexLevelParameteriv', 00H
	ORG $+3
$SG143737 DB	'glGetTexLevelParameterfv', 00H
	ORG $+3
$SG143738 DB	'glFogfv', 00H
$SG143739 DB	'glFogf', 00H
	ORG $+1
$SG143740 DB	'glFogi', 00H
	ORG $+1
$SG143748 DB	'glDebugMessageControlARB', 00H
	ORG $+3
$SG143749 DB	'glDebugMessageInsertARB', 00H
$SG143750 DB	'glDebugMessageCallbackARB', 00H
	ORG $+2
$SG143751 DB	'glGetDebugMessageLogARB', 00H
$SG143763 DB	'glMultiTexCoord1fARB', 00H
	ORG $+3
$SG143764 DB	'glMultiTexCoord2fARB', 00H
	ORG $+3
$SG143765 DB	'glMultiTexCoord3fARB', 00H
	ORG $+3
$SG143766 DB	'glMultiTexCoord4fARB', 00H
	ORG $+3
$SG143767 DB	'glActiveTextureARB', 00H
	ORG $+1
$SG143768 DB	'glActiveTextureARB', 00H
	ORG $+1
$SG143769 DB	'glClientActiveTextureARB', 00H
	ORG $+3
$SG143770 DB	'glClientActiveTextureARB', 00H
	ORG $+3
$SG143777 DB	'glTexImage3DEXT', 00H
$SG143778 DB	'glTexSubImage3DEXT', 00H
	ORG $+1
$SG143779 DB	'glCopyTexSubImage3DEXT', 00H
	ORG $+1
$SG143790 DB	'glCompressedTexImage3DARB', 00H
	ORG $+2
$SG143791 DB	'glCompressedTexImage2DARB', 00H
	ORG $+2
$SG143792 DB	'glCompressedTexImage1DARB', 00H
	ORG $+2
$SG143793 DB	'glCompressedTexSubImage3DARB', 00H
	ORG $+3
$SG143794 DB	'glCompressedTexSubImage2DARB', 00H
	ORG $+3
$SG143795 DB	'glCompressedTexSubImage1DARB', 00H
	ORG $+3
$SG143796 DB	'glGetCompressedTexImageARB', 00H
	ORG $+1
_wgl_funcs DD	FLAT:$SG143805
	DD	FLAT:_pwglSwapBuffers
	DD	FLAT:$SG143806
	DD	FLAT:_pwglCreateContext
	DD	FLAT:$SG143807
	DD	FLAT:_pwglDeleteContext
	DD	FLAT:$SG143808
	DD	FLAT:_pwglMakeCurrent
	DD	FLAT:$SG143809
	DD	FLAT:_pwglGetCurrentContext
	DD	00H
	DD	00H
$SG143805 DB	'wglSwapBuffers', 00H
	ORG $+1
$SG143806 DB	'wglCreateContext', 00H
	ORG $+3
$SG143807 DB	'wglDeleteContext', 00H
	ORG $+3
$SG143808 DB	'wglMakeCurrent', 00H
	ORG $+1
$SG143809 DB	'wglGetCurrentContext', 00H
	ORG $+3
$SG143814 DB	'wglGetProcAddress', 00H
	ORG $+2
$SG143819 DB	'wglSwapIntervalEXT', 00H
	ORG $+1
$SG143824 DB	'wglGetExtensionsStringEXT', 00H
	ORG $+2
_opengl_dll DD	FLAT:$SG143826
	DD	FLAT:_wgl_funcs
	DD	01H
	ORG $+4
$SG143826 DB	'opengl32.dll', 00H
_DATA	ENDS
PUBLIC	_VID_InitDefaultResolution
PUBLIC	_GL_CheckForErrors_
PUBLIC	_VID_GetModeString
PUBLIC	_GL_GetProcAddress
PUBLIC	_GL_ErrorString
PUBLIC	_GL_UpdateSwapInterval
PUBLIC	_GL_DeleteContext
PUBLIC	_GL_Support
PUBLIC	_VID_CheckChanges
PUBLIC	_GL_MaxTextureUnits
PUBLIC	_R_Init
PUBLIC	_R_Shutdown
PUBLIC	_GL_SetExtension
PUBLIC	_GL_CheckExtension
PUBLIC	_GL_CreateContext
PUBLIC	_GL_UpdateContext
PUBLIC	_VID_StartupGamma
PUBLIC	_VID_DestroyFakeWindow
PUBLIC	_VID_CreateFakeWindow
PUBLIC	_GL_SetPixelformat
PUBLIC	_R_SaveVideoMode
PUBLIC	_R_DescribeVIDMode
PUBLIC	_VID_CreateWindow
PUBLIC	_VID_DestroyWindow
PUBLIC	_R_ChangeDisplaySettings
PUBLIC	_VID_SetMode
PUBLIC	_R_Init_OpenGL
PUBLIC	_R_Free_OpenGL
PUBLIC	_R_RenderInfo_f
PUBLIC	_GL_InitCommands
PUBLIC	_GL_RemoveCommands
PUBLIC	_GL_InitExtensions
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
EXTRN	_memset:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__ChoosePixelFormat@8:PROC
EXTRN	__imp__DescribePixelFormat@16:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__SetPixelFormat@12:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__LoadImageA@24:PROC
EXTRN	__imp__ChangeDisplaySettingsA@8:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Sys_LoadLibrary:PROC
EXTRN	_Sys_GetProcAddress:PROC
EXTRN	_Sys_FreeLibrary:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_stristr:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Image_AddCmdFlags:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_SCR_Init:PROC
EXTRN	_BuildGammaTable:PROC
EXTRN	_SCR_VidInit:PROC
EXTRN	_SCR_RegisterTextures:PROC
EXTRN	_GL_CleanupAllTextureUnits:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_ClearDecals:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_InitImages:PROC
EXTRN	_R_ShutdownImages:PROC
EXTRN	_R_ClearScene:PROC
EXTRN	_GL_InitRandomTable:PROC
EXTRN	_R_SpriteInit:PROC
EXTRN	_R_StudioInit:PROC
EXTRN	_R_AliasInit:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_IN_WndProc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftoui3:PROC
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_hWndFake DD	01H DUP (?)
_hDCFake DD	01H DUP (?)
_hGLRCFake DD	01H DUP (?)
_context_flags DD 01H DUP (?)
?wndname@?1??VID_CreateWindow@@9@9 DB 0100H DUP (?)	; `VID_CreateWindow'::`2'::wndname
_BSS	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
_opengl_110funcs DD FLAT:$SG143617
	DD	FLAT:_pglClearColor
	DD	FLAT:$SG143618
	DD	FLAT:_pglClear
	DD	FLAT:$SG143619
	DD	FLAT:_pglAlphaFunc
	DD	FLAT:$SG143620
	DD	FLAT:_pglBlendFunc
	DD	FLAT:$SG143621
	DD	FLAT:_pglCullFace
	DD	FLAT:$SG143622
	DD	FLAT:_pglDrawBuffer
	DD	FLAT:$SG143623
	DD	FLAT:_pglReadBuffer
	DD	FLAT:$SG143624
	DD	FLAT:_pglAccum
	DD	FLAT:$SG143625
	DD	FLAT:_pglEnable
	DD	FLAT:$SG143626
	DD	FLAT:_pglDisable
	DD	FLAT:$SG143627
	DD	FLAT:_pglEnableClientState
	DD	FLAT:$SG143628
	DD	FLAT:_pglDisableClientState
	DD	FLAT:$SG143629
	DD	FLAT:_pglGetBooleanv
	DD	FLAT:$SG143630
	DD	FLAT:_pglGetDoublev
	DD	FLAT:$SG143631
	DD	FLAT:_pglGetFloatv
	DD	FLAT:$SG143632
	DD	FLAT:_pglGetIntegerv
	DD	FLAT:$SG143633
	DD	FLAT:_pglGetError
	DD	FLAT:$SG143634
	DD	FLAT:_pglGetString
	DD	FLAT:$SG143635
	DD	FLAT:_pglFinish
	DD	FLAT:$SG143636
	DD	FLAT:_pglFlush
	DD	FLAT:$SG143637
	DD	FLAT:_pglClearDepth
	DD	FLAT:$SG143638
	DD	FLAT:_pglDepthFunc
	DD	FLAT:$SG143639
	DD	FLAT:_pglDepthMask
	DD	FLAT:$SG143640
	DD	FLAT:_pglDepthRange
	DD	FLAT:$SG143641
	DD	FLAT:_pglFrontFace
	DD	FLAT:$SG143642
	DD	FLAT:_pglDrawElements
	DD	FLAT:$SG143643
	DD	FLAT:_pglDrawArrays
	DD	FLAT:$SG143644
	DD	FLAT:_pglColorMask
	DD	FLAT:$SG143645
	DD	FLAT:_pglIndexPointer
	DD	FLAT:$SG143646
	DD	FLAT:_pglVertexPointer
	DD	FLAT:$SG143647
	DD	FLAT:_pglNormalPointer
	DD	FLAT:$SG143648
	DD	FLAT:_pglColorPointer
	DD	FLAT:$SG143649
	DD	FLAT:_pglTexCoordPointer
	DD	FLAT:$SG143650
	DD	FLAT:_pglArrayElement
	DD	FLAT:$SG143651
	DD	FLAT:_pglColor3f
	DD	FLAT:$SG143652
	DD	FLAT:_pglColor3fv
	DD	FLAT:$SG143653
	DD	FLAT:_pglColor4f
	DD	FLAT:$SG143654
	DD	FLAT:_pglColor4fv
	DD	FLAT:$SG143655
	DD	FLAT:_pglColor3ub
	DD	FLAT:$SG143656
	DD	FLAT:_pglColor4ub
	DD	FLAT:$SG143657
	DD	FLAT:_pglColor4ubv
	DD	FLAT:$SG143658
	DD	FLAT:_pglTexCoord1f
	DD	FLAT:$SG143659
	DD	FLAT:_pglTexCoord2f
	DD	FLAT:$SG143660
	DD	FLAT:_pglTexCoord3f
	DD	FLAT:$SG143661
	DD	FLAT:_pglTexCoord4f
	DD	FLAT:$SG143662
	DD	FLAT:_pglTexCoord1fv
	DD	FLAT:$SG143663
	DD	FLAT:_pglTexCoord2fv
	DD	FLAT:$SG143664
	DD	FLAT:_pglTexCoord3fv
	DD	FLAT:$SG143665
	DD	FLAT:_pglTexCoord4fv
	DD	FLAT:$SG143666
	DD	FLAT:_pglTexGenf
	DD	FLAT:$SG143667
	DD	FLAT:_pglTexGenfv
	DD	FLAT:$SG143668
	DD	FLAT:_pglTexGeni
	DD	FLAT:$SG143669
	DD	FLAT:_pglVertex2f
	DD	FLAT:$SG143670
	DD	FLAT:_pglVertex3f
	DD	FLAT:$SG143671
	DD	FLAT:_pglVertex3fv
	DD	FLAT:$SG143672
	DD	FLAT:_pglNormal3f
	DD	FLAT:$SG143673
	DD	FLAT:_pglNormal3fv
	DD	FLAT:$SG143674
	DD	FLAT:_pglBegin
	DD	FLAT:$SG143675
	DD	FLAT:_pglEnd
	DD	FLAT:$SG143676
	DD	FLAT:_pglLineWidth
	DD	FLAT:$SG143677
	DD	FLAT:_pglPointSize
	DD	FLAT:$SG143678
	DD	FLAT:_pglMatrixMode
	DD	FLAT:$SG143679
	DD	FLAT:_pglOrtho
	DD	FLAT:$SG143680
	DD	FLAT:_pglRasterPos2f
	DD	FLAT:$SG143681
	DD	FLAT:_pglFrustum
	DD	FLAT:$SG143682
	DD	FLAT:_pglViewport
	DD	FLAT:$SG143683
	DD	FLAT:_pglPushMatrix
	DD	FLAT:$SG143684
	DD	FLAT:_pglPopMatrix
	DD	FLAT:$SG143685
	DD	FLAT:_pglPushAttrib
	DD	FLAT:$SG143686
	DD	FLAT:_pglPopAttrib
	DD	FLAT:$SG143687
	DD	FLAT:_pglLoadIdentity
	DD	FLAT:$SG143688
	DD	FLAT:_pglLoadMatrixd
	DD	FLAT:$SG143689
	DD	FLAT:_pglLoadMatrixf
	DD	FLAT:$SG143690
	DD	FLAT:_pglMultMatrixd
	DD	FLAT:$SG143691
	DD	FLAT:_pglMultMatrixf
	DD	FLAT:$SG143692
	DD	FLAT:_pglRotated
	DD	FLAT:$SG143693
	DD	FLAT:_pglRotatef
	DD	FLAT:$SG143694
	DD	FLAT:_pglScaled
	DD	FLAT:$SG143695
	DD	FLAT:_pglScalef
	DD	FLAT:$SG143696
	DD	FLAT:_pglTranslated
	DD	FLAT:$SG143697
	DD	FLAT:_pglTranslatef
	DD	FLAT:$SG143698
	DD	FLAT:_pglReadPixels
	DD	FLAT:$SG143699
	DD	FLAT:_pglDrawPixels
	DD	FLAT:$SG143700
	DD	FLAT:_pglStencilFunc
	DD	FLAT:$SG143701
	DD	FLAT:_pglStencilMask
	DD	FLAT:$SG143702
	DD	FLAT:_pglStencilOp
	DD	FLAT:$SG143703
	DD	FLAT:_pglClearStencil
	DD	FLAT:$SG143704
	DD	FLAT:_pglIsEnabled
	DD	FLAT:$SG143705
	DD	FLAT:_pglIsList
	DD	FLAT:$SG143706
	DD	FLAT:_pglIsTexture
	DD	FLAT:$SG143707
	DD	FLAT:_pglTexEnvf
	DD	FLAT:$SG143708
	DD	FLAT:_pglTexEnvfv
	DD	FLAT:$SG143709
	DD	FLAT:_pglTexEnvi
	DD	FLAT:$SG143710
	DD	FLAT:_pglTexParameterf
	DD	FLAT:$SG143711
	DD	FLAT:_pglTexParameterfv
	DD	FLAT:$SG143712
	DD	FLAT:_pglTexParameteri
	DD	FLAT:$SG143713
	DD	FLAT:_pglHint
	DD	FLAT:$SG143714
	DD	FLAT:_pglPixelStoref
	DD	FLAT:$SG143715
	DD	FLAT:_pglPixelStorei
	DD	FLAT:$SG143716
	DD	FLAT:_pglGenTextures
	DD	FLAT:$SG143717
	DD	FLAT:_pglDeleteTextures
	DD	FLAT:$SG143718
	DD	FLAT:_pglBindTexture
	DD	FLAT:$SG143719
	DD	FLAT:_pglTexImage1D
	DD	FLAT:$SG143720
	DD	FLAT:_pglTexImage2D
	DD	FLAT:$SG143721
	DD	FLAT:_pglTexSubImage1D
	DD	FLAT:$SG143722
	DD	FLAT:_pglTexSubImage2D
	DD	FLAT:$SG143723
	DD	FLAT:_pglCopyTexImage1D
	DD	FLAT:$SG143724
	DD	FLAT:_pglCopyTexImage2D
	DD	FLAT:$SG143725
	DD	FLAT:_pglCopyTexSubImage1D
	DD	FLAT:$SG143726
	DD	FLAT:_pglCopyTexSubImage2D
	DD	FLAT:$SG143727
	DD	FLAT:_pglScissor
	DD	FLAT:$SG143728
	DD	FLAT:_pglGetTexImage
	DD	FLAT:$SG143729
	DD	FLAT:_pglGetTexEnviv
	DD	FLAT:$SG143730
	DD	FLAT:_pglPolygonOffset
	DD	FLAT:$SG143731
	DD	FLAT:_pglPolygonMode
	DD	FLAT:$SG143732
	DD	FLAT:_pglPolygonStipple
	DD	FLAT:$SG143733
	DD	FLAT:_pglClipPlane
	DD	FLAT:$SG143734
	DD	FLAT:_pglGetClipPlane
	DD	FLAT:$SG143735
	DD	FLAT:_pglShadeModel
	DD	FLAT:$SG143736
	DD	FLAT:_pglGetTexLevelParameteriv
	DD	FLAT:$SG143737
	DD	FLAT:_pglGetTexLevelParameterfv
	DD	FLAT:$SG143738
	DD	FLAT:_pglFogfv
	DD	FLAT:$SG143739
	DD	FLAT:_pglFogf
	DD	FLAT:$SG143740
	DD	FLAT:_pglFogi
	DD	00H
	DD	00H
_debugoutputfuncs DD FLAT:$SG143748
	DD	FLAT:_pglDebugMessageControlARB
	DD	FLAT:$SG143749
	DD	FLAT:_pglDebugMessageInsertARB
	DD	FLAT:$SG143750
	DD	FLAT:_pglDebugMessageCallbackARB
	DD	FLAT:$SG143751
	DD	FLAT:_pglGetDebugMessageLogARB
	DD	00H
	DD	00H
_multitexturefuncs DD FLAT:$SG143763
	DD	FLAT:_pglMultiTexCoord1f
	DD	FLAT:$SG143764
	DD	FLAT:_pglMultiTexCoord2f
	DD	FLAT:$SG143765
	DD	FLAT:_pglMultiTexCoord3f
	DD	FLAT:$SG143766
	DD	FLAT:_pglMultiTexCoord4f
	DD	FLAT:$SG143767
	DD	FLAT:_pglActiveTexture
	DD	FLAT:$SG143768
	DD	FLAT:_pglActiveTextureARB
	DD	FLAT:$SG143769
	DD	FLAT:_pglClientActiveTexture
	DD	FLAT:$SG143770
	DD	FLAT:_pglClientActiveTextureARB
	DD	00H
	DD	00H
_texture3dextfuncs DD FLAT:$SG143777
	DD	FLAT:_pglTexImage3D
	DD	FLAT:$SG143778
	DD	FLAT:_pglTexSubImage3D
	DD	FLAT:$SG143779
	DD	FLAT:_pglCopyTexSubImage3D
	DD	00H
	DD	00H
_texturecompressionfuncs DD FLAT:$SG143790
	DD	FLAT:_pglCompressedTexImage3DARB
	DD	FLAT:$SG143791
	DD	FLAT:_pglCompressedTexImage2DARB
	DD	FLAT:$SG143792
	DD	FLAT:_pglCompressedTexImage1DARB
	DD	FLAT:$SG143793
	DD	FLAT:_pglCompressedTexSubImage3DARB
	DD	FLAT:$SG143794
	DD	FLAT:_pglCompressedTexSubImage2DARB
	DD	FLAT:$SG143795
	DD	FLAT:_pglCompressedTexSubImage1DARB
	DD	FLAT:$SG143796
	DD	FLAT:_pglGetCompressedTexImage
	DD	00H
	DD	00H
_wglproc_funcs DD FLAT:$SG143814
	DD	FLAT:_pwglGetProcAddress
	DD	00H
	DD	00H
_wglswapintervalfuncs DD FLAT:$SG143819
	DD	FLAT:_pwglSwapIntervalEXT
	DD	00H
	DD	00H
_wglgetextensionsstring DD FLAT:$SG143824
	DD	FLAT:_pwglGetExtensionsStringEXT
	DD	00H
	DD	00H
$SG143846 DB	'^3OpenGL Error:^7 %s', 0aH, 00H
	ORG $+2
$SG143848 DB	'^3OpenGL Warning:^7 %s', 0aH, 00H
$SG143850 DB	'^3OpenGL Warning:^7 %s', 0aH, 00H
$SG143853 DB	'^3OpenGL Warning:^7 %s', 0aH, 00H
$SG143855 DB	'^2OpenGL Note:^7 %s', 0aH, 00H
	ORG $+3
$SG143858 DB	'^2OpenGL Note:^7 %s', 0aH, 00H
	ORG $+3
$SG143867 DB	'^1Error:^7 GL_SetExtension: invalid extension %d', 0aH, 00H
	ORG $+2
$SG143872 DB	'^1Error:^7 GL_Support: invalid extension %d', 0aH, 00H
	ORG $+3
$SG143911 DB	'GL_CheckExtension: %s ', 00H
	ORG $+1
$SG143913 DB	'enable or disable %s', 00H
	ORG $+3
$SG143914 DB	'1', 00H
	ORG $+2
$SG143918 DB	'- disabled', 0aH, 00H
$SG143922 DB	'- ^1failed', 0aH, 00H
$SG143926 DB	'- ^2enabled', 0aH, 00H
	ORG $+3
$SG143927 DB	'- ^1failed', 0aH, 00H
$SG143951 DB	'-gldebug', 00H
	ORG $+3
$SG143958 DB	'2.0', 00H
$SG143959 DB	'^1Error:^7 Unsupported OpenGL context version (%s).', 0aH
	DB	00H
	ORG $+3
$SG143962 DB	'compat', 00H
	ORG $+1
$SG143963 DB	'^1Error:^7 Unsupported OpenGL profile (%s).', 0aH, 00H
	ORG $+3
$SG143969 DB	'^1Error:^7 wglCreateContextAttribsARB returned dc not fo'
	DB	'und.', 0aH, 00H
	ORG $+2
$SG143979 DB	'2.0', 00H
$SG143966 DB	'^1Error:^7 wglCreateContextAttribsARB returned invalid o'
	DB	'peration.', 0aH, 00H
	ORG $+1
$SG143972 DB	'^1Error:^7 wglCreateContextAttribsARB returned dc not fo'
	DB	'und.', 0aH, 00H
	ORG $+2
$SG143980 DB	'^1Error:^7 Unknown error creating an OpenGL (%s) Context'
	DB	'.', 0aH, 00H
	ORG $+1
$SG143975 DB	'^1Error:^7 wglCreateContextAttribsARB ran out of system '
	DB	'resources.', 0aH, 00H
$SG143994 DB	'wglCreateContextAttribsARB', 00H
	ORG $+1
$SG143978 DB	'^1Error:^7 wglCreateContextAttribsARB reported invalid p'
	DB	'arameter.', 0aH, 00H
	ORG $+1
$SG144000 DB	'GL_CreateContext: using extended context', 0aH, 00H
	ORG $+2
$SG144039 DB	'^3Warning:^7 MSAA is not allowed', 0aH, 00H
	ORG $+2
$SG144043 DB	'VID_StartupGamma: gamma %g brightness %g', 0aH, 00H
	ORG $+2
$SG144062 DB	'TestWindow', 00H
	ORG $+1
$SG144083 DB	'TestWindow', 00H
	ORG $+1
$SG144086 DB	'Xash3D', 00H
	ORG $+1
$SG144087 DB	'TestWindow', 00H
	ORG $+1
$SG144088 DB	'TestWindow', 00H
	ORG $+1
$SG144094 DB	'wglGetPixelFormatAttribivARB', 00H
	ORG $+3
$SG144095 DB	'wglChoosePixelFormatARB', 00H
$SG144112 DB	'^1Error:^7 GL_SetPixelformat: failed to find an appropri'
	DB	'ate PIXELFORMAT', 0aH, 00H
	ORG $+3
$SG144114 DB	'^1Error:^7 GL_SetPixelformat: failed', 0aH, 00H
	ORG $+2
$SG144119 DB	'VID_ChoosePFD: using Generic MCD acceleration', 0aH, 00H
	ORG $+1
$SG144120 DB	'^1Error:^7 GL_SetPixelformat: no hardware acceleration f'
	DB	'ound', 0aH, 00H
	ORG $+2
$SG144121 DB	'VID_ChoosePFD: using hardware acceleration', 0aH, 00H
$SG144124 DB	'PixelFormat: color: %d-bit, Z-Buffer: %d-bit, stencil: %'
	DB	'd-bit', 0aH, 00H
	ORG $+1
$SG144130 DB	'%i', 00H
	ORG $+1
$SG144131 DB	'width', 00H
	ORG $+2
$SG144132 DB	'%i', 00H
	ORG $+1
$SG144133 DB	'height', 00H
	ORG $+1
$SG144134 DB	'vid_mode', 00H
	ORG $+3
$SG144135 DB	'Set: %s [%dx%d]', 0aH, 00H
	ORG $+3
$SG144147 DB	'vid_mode', 00H
	ORG $+3
$SG144182 DB	'Xash3D Window', 00H
	ORG $+2
$SG144186 DB	'%s/%s', 00H
	ORG $+2
$SG144187 DB	'Extract %s from pak if you want to see it.', 0aH, 00H
$SG144190 DB	'^1Error:^7 VID_CreateWindow: couldn''t register window c'
	DB	'lass %s', 0aH, 'Xash3D Window', 00H
	ORG $+3
$SG144196 DB	'vid_mode', 00H
	ORG $+3
$SG144199 DB	'Xash3D Window', 00H
	ORG $+2
$SG144201 DB	'^3Warning:^7 VID_CreateWindow: bad hWnd for ''%s''', 0aH
	DB	00H
	ORG $+2
$SG144203 DB	'^1Error:^7 VID_CreateWindow: couldn''t create ''%s''', 0aH
	DB	00H
	ORG $+1
$SG144205 DB	'Xash3D Window', 00H
	ORG $+2
$SG144206 DB	'^1Error:^7 OpenGL driver not installed', 0aH, 00H
$SG144221 DB	'Xash3D Window', 00H
	ORG $+2
$SG144240 DB	'vid_displayfrequency', 00H
	ORG $+3
$SG144242 DB	'vid_displayfrequency', 00H
	ORG $+3
$SG144253 DB	'vid_displayfrequency', 00H
	ORG $+3
$SG144276 DB	'fullscreen', 00H
	ORG $+1
$SG144259 DB	'^1Error:^7 VID_SetMode: display frequency %i Hz is not s'
	DB	'upported', 0aH, 00H
	ORG $+2
$SG144275 DB	'found specified vid mode %i [%ix%i]', 0aH, 00H
	ORG $+3
$SG144277 DB	'failed to set specified vid mode [%ix%i]', 0aH, 00H
	ORG $+2
$SG144278 DB	'vid_mode', 00H
	ORG $+3
$SG144283 DB	'fullscreen', 00H
	ORG $+1
$SG144284 DB	'^1Error:^7 VID_SetMode: fullscreen unavailable in this m'
	DB	'ode', 0aH, 00H
	ORG $+3
$SG144287 DB	'^1Error:^7 VID_SetMode: invalid mode', 0aH, 00H
	ORG $+2
$SG144288 DB	'vid_mode', 00H
	ORG $+3
$SG144290 DB	'^1Error:^7 VID_SetMode: could not revert to safe mode', 0aH
	DB	00H
	ORG $+1
$SG144297 DB	'Can''t re-initialize video subsystem', 0aH, 00H
	ORG $+3
$SG144305 DB	'OpenGL Internal ProcAddress', 00H
$SG144319 DB	0aH, 00H
	ORG $+2
$SG144320 DB	'GL_VENDOR: %s', 0aH, 00H
	ORG $+1
$SG144321 DB	'GL_RENDERER: %s', 0aH, 00H
	ORG $+3
$SG144322 DB	'GL_VERSION: %s', 0aH, 00H
$SG144324 DB	'GL_EXTENSIONS: %s', 0aH, 00H
	ORG $+1
$SG144326 DB	0aH, 'WGL_EXTENSIONS: %s', 0aH, 00H
	ORG $+3
$SG144327 DB	'GL_MAX_TEXTURE_SIZE: %i', 0aH, 00H
	ORG $+3
$SG144329 DB	'GL_MAX_TEXTURE_UNITS_ARB: %i', 0aH, 00H
	ORG $+2
$SG144331 DB	'GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB: %i', 0aH, 00H
	ORG $+2
$SG144333 DB	'GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: %.1f', 0aH, 00H
	ORG $+3
$SG144335 DB	'GL_MAX_RECTANGLE_TEXTURE_SIZE: %i', 0aH, 00H
	ORG $+1
$SG144337 DB	'GL_MAX_ARRAY_TEXTURE_LAYERS_EXT: %i', 0aH, 00H
	ORG $+3
$SG144339 DB	'GL_MAX_TEXTURE_COORDS_ARB: %i', 0aH, 00H
	ORG $+1
$SG144340 DB	'GL_MAX_TEXTURE_IMAGE_UNITS_ARB: %i', 0aH, 00H
$SG144341 DB	'GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB: %i', 0aH, 00H
	ORG $+2
$SG144342 DB	'GL_MAX_VERTEX_ATTRIBS_ARB: %i', 0aH, 00H
	ORG $+1
$SG144343 DB	0aH, 00H
	ORG $+2
$SG144344 DB	'MODE: %s', 0aH, 00H
	ORG $+2
$SG144345 DB	0aH, 00H
	ORG $+2
$SG144346 DB	'enabled', 00H
$SG144347 DB	'disabled', 00H
	ORG $+3
$SG144348 DB	'VERTICAL SYNC: %s', 0aH, 00H
	ORG $+1
$SG144349 DB	'Color %d bits, Alpha %d bits, Depth %d bits, Stencil %d '
	DB	'bits', 0aH, 00H
	ORG $+2
$SG144353 DB	'shows renderer speeds', 00H
	ORG $+2
$SG144354 DB	'0', 00H
	ORG $+2
$SG144355 DB	'r_speeds', 00H
	ORG $+3
$SG144356 DB	'disable lightmaps, get fullbright for entities', 00H
	ORG $+1
$SG144357 DB	'0', 00H
	ORG $+2
$SG144358 DB	'r_fullbright', 00H
	ORG $+3
$SG144359 DB	'disable 3D rendering (use with caution)', 00H
$SG144360 DB	'0', 00H
	ORG $+2
$SG144361 DB	'r_norefresh', 00H
$SG144362 DB	'allow to get lighting from bmodels too', 00H
	ORG $+1
$SG144363 DB	'1', 00H
	ORG $+2
$SG144364 DB	'r_lighting_extended', 00H
$SG144365 DB	'lightstyles modulate scale', 00H
	ORG $+1
$SG144366 DB	'0.6', 00H
$SG144367 DB	'r_lighting_modulate', 00H
$SG144368 DB	'map ambient lighting scale', 00H
	ORG $+1
$SG144369 DB	'0.3', 00H
$SG144370 DB	'r_lighting_ambient', 00H
	ORG $+1
$SG144371 DB	'making FOV adjustment for wide-screens', 00H
	ORG $+1
$SG144372 DB	'1', 00H
	ORG $+2
$SG144373 DB	'r_adjust_fov', 00H
	ORG $+3
$SG144374 DB	'ignore vis information (perfomance test)', 00H
	ORG $+3
$SG144375 DB	'0', 00H
	ORG $+2
$SG144376 DB	'r_novis', 00H
$SG144377 DB	'ignore frustrum culling (perfomance test)', 00H
	ORG $+2
$SG144378 DB	'0', 00H
	ORG $+2
$SG144379 DB	'r_nocull', 00H
	ORG $+3
$SG144380 DB	'enable detail textures support, use ''2'' for autogenera'
	DB	'te detail.txt', 00H
$SG144381 DB	'1', 00H
	ORG $+2
$SG144382 DB	'r_detailtextures', 00H
	ORG $+3
$SG144383 DB	'lockpvs area at current point (pvs test)', 00H
	ORG $+3
$SG144384 DB	'0', 00H
	ORG $+2
$SG144385 DB	'r_lockpvs', 00H
	ORG $+2
$SG144386 DB	'lock frustrum area at current point (cull test)', 00H
$SG144387 DB	'0', 00H
	ORG $+2
$SG144388 DB	'r_lockfrustum', 00H
	ORG $+2
$SG144389 DB	'allow dynamic lighting (dlights, lightstyles)', 00H
	ORG $+2
$SG144390 DB	'1', 00H
	ORG $+2
$SG144391 DB	'r_dynamic', 00H
	ORG $+2
$SG144392 DB	'cull flares behind models', 00H
	ORG $+2
$SG144393 DB	'1', 00H
	ORG $+2
$SG144394 DB	'r_traceglow', 00H
$SG144395 DB	'lightmap debugging tool', 00H
$SG144396 DB	'0', 00H
	ORG $+2
$SG144397 DB	'r_lightmap', 00H
	ORG $+1
$SG144398 DB	'render entities', 00H
$SG144399 DB	'1', 00H
	ORG $+2
$SG144400 DB	'r_drawentities', 00H
	ORG $+1
$SG144401 DB	'sets the maximum number of decals', 00H
	ORG $+2
$SG144402 DB	'4096', 00H
	ORG $+3
$SG144403 DB	'r_decals', 00H
	ORG $+3
$SG144404 DB	'build the graph of visible BSP tree', 00H
$SG144405 DB	'0', 00H
	ORG $+2
$SG144406 DB	'r_showtree', 00H
	ORG $+1
$SG144407 DB	'window position by horizontal', 00H
	ORG $+2
$SG144408 DB	'130', 00H
$SG144409 DB	'_window_xpos', 00H
	ORG $+3
$SG144410 DB	'window position by vertical', 00H
$SG144411 DB	'48', 00H
	ORG $+1
$SG144412 DB	'_window_ypos', 00H
	ORG $+3
$SG144413 DB	'allow gl_extensions', 00H
$SG144414 DB	'1', 00H
	ORG $+2
$SG144415 DB	'gl_allow_extensions', 00H
$SG144416 DB	'enable multisample anti-aliasing', 00H
	ORG $+3
$SG144417 DB	'4', 00H
	ORG $+2
$SG144418 DB	'gl_wgl_msaa_samples', 00H
$SG144419 DB	'disable texture filter', 00H
	ORG $+1
$SG144420 DB	'0', 00H
	ORG $+2
$SG144421 DB	'gl_texture_nearest', 00H
	ORG $+1
$SG144422 DB	'disable lightmap filter', 00H
$SG144423 DB	'0', 00H
	ORG $+2
$SG144424 DB	'gl_lightmap_nearest', 00H
$SG144425 DB	'ignore video engine errors', 00H
	ORG $+1
$SG144426 DB	'1', 00H
	ORG $+2
$SG144427 DB	'gl_check_errors', 00H
$SG144428 DB	'enable vertical syncronization', 00H
	ORG $+1
$SG144429 DB	'0', 00H
	ORG $+2
$SG144430 DB	'gl_vsync', 00H
	ORG $+3
$SG144432 DB	'4.0', 00H
$SG144431 DB	'default scale applies while auto-generate list of detail'
	DB	' textures', 00H
	ORG $+2
$SG144433 DB	'gl_detailscale', 00H
	ORG $+1
$SG144434 DB	'textures anisotropic filter', 00H
$SG144435 DB	'8', 00H
	ORG $+2
$SG144436 DB	'gl_anisotropy', 00H
	ORG $+2
$SG144437 DB	'LOD bias for mipmapped textures (perfomance|quality)', 00H
	ORG $+3
$SG144438 DB	'0.0', 00H
$SG144439 DB	'gl_texture_lodbias', 00H
	ORG $+1
$SG144440 DB	'removing tjuncs causes blinking pixels', 00H
	ORG $+1
$SG144441 DB	'1', 00H
	ORG $+2
$SG144442 DB	'gl_keeptjunctions', 00H
	ORG $+2
$SG144443 DB	'fake bumpmapping scale', 00H
	ORG $+1
$SG144444 DB	'0', 00H
	ORG $+2
$SG144445 DB	'gl_emboss_scale', 00H
$SG144446 DB	'show all uploaded textures', 00H
	ORG $+1
$SG144447 DB	'0', 00H
	ORG $+2
$SG144448 DB	'r_showtextures', 00H
	ORG $+1
$SG144449 DB	'use glFinish instead of glFlush', 00H
$SG144450 DB	'0', 00H
	ORG $+2
$SG144451 DB	'gl_finish', 00H
	ORG $+2
$SG144452 DB	'disable sorting of translucent surfaces', 00H
$SG144453 DB	'0', 00H
	ORG $+2
$SG144454 DB	'gl_nosort', 00H
	ORG $+2
$SG144455 DB	'clearing screen after each frame', 00H
	ORG $+3
$SG144456 DB	'0', 00H
	ORG $+2
$SG144457 DB	'gl_clear', 00H
	ORG $+3
$SG144458 DB	'engine developer cvar for quick testing new features', 00H
	ORG $+3
$SG144459 DB	'0', 00H
	ORG $+2
$SG144460 DB	'gl_test', 00H
$SG144461 DB	'show wireframe overlay', 00H
	ORG $+1
$SG144462 DB	'0', 00H
	ORG $+2
$SG144463 DB	'gl_wireframe', 00H
	ORG $+3
$SG144464 DB	'round texture sizes to nearest POT value', 00H
	ORG $+3
$SG144465 DB	'2', 00H
	ORG $+2
$SG144466 DB	'gl_round_down', 00H
	ORG $+2
$SG144467 DB	'enable multi sample anti-aliasing', 00H
	ORG $+2
$SG144468 DB	'1', 00H
	ORG $+2
$SG144469 DB	'gl_msaa', 00H
$SG144470 DB	'polygon offset for decals', 00H
	ORG $+2
$SG144471 DB	'2.0', 00H
$SG144472 DB	'gl_polyoffset', 00H
	ORG $+2
$SG144473 DB	'gamma amount', 00H
	ORG $+3
$SG144474 DB	'2.5', 00H
$SG144475 DB	'gamma', 00H
	ORG $+2
$SG144476 DB	'brighntess factor', 00H
	ORG $+2
$SG144477 DB	'0.0', 00H
$SG144478 DB	'brightness', 00H
	ORG $+1
$SG144479 DB	'display resolution mode', 00H
$SG144480 DB	'-1', 00H
	ORG $+1
$SG144481 DB	'vid_mode', 00H
	ORG $+3
$SG144482 DB	'enable fullscreen mode', 00H
	ORG $+1
$SG144483 DB	'0', 00H
	ORG $+2
$SG144484 DB	'fullscreen', 00H
	ORG $+1
$SG144485 DB	'fullscreen refresh rate', 00H
$SG144486 DB	'0', 00H
	ORG $+2
$SG144487 DB	'vid_displayfrequency', 00H
	ORG $+3
$SG144488 DB	'display renderer info', 00H
	ORG $+2
$SG144489 DB	'r_info', 00H
	ORG $+1
$SG144490 DB	'exec opengl.cfg', 0aH, 00H
	ORG $+3
$SG144491 DB	'exec video.cfg', 0aH, 00H
$SG144495 DB	'r_info', 00H
	ORG $+1
$SG144527 DB	'OpenGL 1.1.0', 00H
	ORG $+3
$SG144528 DB	'^3Video:^7 %s', 0aH, 00H
	ORG $+1
$SG144531 DB	'geforce', 00H
$SG144534 DB	'quadro fx', 00H
	ORG $+2
$SG144537 DB	'rv770', 00H
	ORG $+2
$SG144540 DB	'radeon hd', 00H
	ORG $+2
$SG144544 DB	'eah4850', 00H
$SG144545 DB	'eah4870', 00H
$SG144548 DB	'radeon', 00H
	ORG $+1
$SG144551 DB	'intel', 00H
	ORG $+2
$SG144553 DB	'OpenGL Internal ProcAddress', 00H
$SG144554 DB	'WGL Extensions String', 00H
	ORG $+2
$SG144557 DB	'WGL_EXT_swap_control', 00H
	ORG $+3
$SG144558 DB	'gl_arb_multitexture', 00H
$SG144559 DB	'GL_ARB_multitexture', 00H
$SG144562 DB	'gl_texture_3d', 00H
	ORG $+2
$SG144563 DB	'GL_EXT_texture3D', 00H
	ORG $+3
$SG144567 DB	'gl_texture_2d_array', 00H
$SG144566 DB	'^1Error:^7 GL_EXT_texture3D reported bogus GL_MAX_3D_TEX'
	DB	'TURE_SIZE, disabled', 0aH, 00H
	ORG $+3
$SG144568 DB	'GL_EXT_texture_array', 00H
	ORG $+3
$SG144570 DB	'gl_texture_cubemap', 00H
	ORG $+1
$SG144571 DB	'GL_ARB_texture_cube_map', 00H
$SG144573 DB	'gl_texture_cubemap_seamless', 00H
$SG144574 DB	'GL_ARB_seamless_cube_map', 00H
	ORG $+3
$SG144575 DB	'gl_texture_npot', 00H
$SG144576 DB	'GL_ARB_texture_non_power_of_two', 00H
$SG144577 DB	'gl_texture_dxt_compression', 00H
	ORG $+1
$SG144578 DB	'GL_ARB_texture_compression', 00H
	ORG $+1
$SG144579 DB	'GL_EXT_texture_edge_clamp', 00H
	ORG $+2
$SG144581 DB	'GL_SGIS_texture_edge_clamp', 00H
	ORG $+1
$SG144582 DB	'gl_texture_anisotropic_filter', 00H
	ORG $+2
$SG144583 DB	'GL_EXT_texture_filter_anisotropic', 00H
	ORG $+2
$SG144586 DB	'gl_texture_mipmap_biasing', 00H
	ORG $+2
$SG144587 DB	'GL_EXT_texture_lod_bias', 00H
$SG144589 DB	'GL_ARB_texture_border_clamp', 00H
$SG144590 DB	'GL_ARB_depth_texture', 00H
	ORG $+3
$SG144591 DB	'gl_texture_float', 00H
	ORG $+3
$SG144592 DB	'GL_ARB_texture_float', 00H
	ORG $+3
$SG144593 DB	'gl_texture_depth_float', 00H
	ORG $+1
$SG144594 DB	'GL_ARB_depth_buffer_float', 00H
	ORG $+2
$SG144595 DB	'GL_EXT_gpu_shader4', 00H
	ORG $+1
$SG144596 DB	'GL_ARB_shading_language_100', 00H
$SG144598 DB	'gl_debug_output', 00H
$SG144599 DB	'GL_ARB_debug_output', 00H
$SG144600 DB	'gl_texture_rectangle', 00H
	ORG $+3
$SG144601 DB	'GL_ARB_texture_rectangle', 00H
	ORG $+3
$SG144607 DB	'opengl texture max dims', 00H
$SG144608 DB	'%i', 00H
	ORG $+1
$SG144609 DB	'gl_max_size', 00H
$SG144611 DB	'gdi', 00H
$SG144612 DB	'gl_finish', 00H
	ORG $+2
$SG144613 DB	'%f', 00H
	ORG $+1
$SG144614 DB	'gl_anisotropy', 00H
	ORG $+2
$SG144623 DB	'Render Zone', 00H
$SG144621 DB	'Can''t initialize video subsystem', 0aH, 'Probably drive'
	DB	'r was not installed', 00H
	ORG $+1
$SG144640 DB	'GL_STACK_OVERFLOW', 00H
	ORG $+2
$SG144622 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_vidnt.c', 00H
	ORG $+3
$SG144633 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\client\gl_vidnt.c', 00H
	ORG $+3
$SG144642 DB	'GL_STACK_UNDERFLOW', 00H
	ORG $+1
$SG144644 DB	'GL_INVALID_ENUM', 00H
$SG144646 DB	'GL_INVALID_VALUE', 00H
	ORG $+3
$SG144648 DB	'GL_INVALID_OPERATION', 00H
	ORG $+3
$SG144650 DB	'GL_OUT_OF_MEMORY', 00H
	ORG $+3
$SG144652 DB	'UNKNOWN ERROR', 00H
	ORG $+2
$SG144661 DB	'^3OpenGL Error:^7 %s (called at %s:%i)', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv421 = -12						; size = 4
tv420 = -8						; size = 4
tv146 = -4						; size = 4
_GL_InitExtensions PROC

; 1665 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1666 : 	// initialize gl extensions
; 1667 : 	GL_CheckExtension( "OpenGL 1.1.0", opengl_110funcs, NULL, GL_OPENGL_110 );

	push	0
	push	0
	push	OFFSET _opengl_110funcs
	push	OFFSET $SG144527
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1668 : 
; 1669 : 	// get our various GL strings
; 1670 : 	glConfig.vendor_string = pglGetString( GL_VENDOR );

	push	7936					; 00001f00H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig+4, eax

; 1671 : 	glConfig.renderer_string = pglGetString( GL_RENDERER );

	push	7937					; 00001f01H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig, eax

; 1672 : 	glConfig.version_string = pglGetString( GL_VERSION );

	push	7938					; 00001f02H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig+8, eax

; 1673 : 	glConfig.extensions_string = pglGetString( GL_EXTENSIONS );

	push	7939					; 00001f03H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig+16, eax

; 1674 : 	Con_Printf( "^3Video:^7 %s\n", glConfig.renderer_string );

	mov	eax, DWORD PTR _glConfig
	push	eax
	push	OFFSET $SG144528
	call	_Con_Printf
	add	esp, 8

; 1675 : 
; 1676 : 	// intialize wrapper type
; 1677 : 	glConfig.context = CONTEXT_TYPE_GL;

	mov	DWORD PTR _glConfig+116, 0

; 1678 : 	glConfig.wrapper = GLES_WRAPPER_NONE;

	mov	DWORD PTR _glConfig+120, 0

; 1679 : 
; 1680 : 	if( Q_stristr( glConfig.renderer_string, "geforce" ))

	push	OFFSET $SG144531
	mov	ecx, DWORD PTR _glConfig
	push	ecx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@GL_InitExt

; 1681 : 		glConfig.hardware_type = GLHW_NVIDIA;

	mov	DWORD PTR _glConfig+12, 2
	jmp	$LN16@GL_InitExt
$LN2@GL_InitExt:

; 1682 : 	else if( Q_stristr( glConfig.renderer_string, "quadro fx" ))

	push	OFFSET $SG144534
	mov	edx, DWORD PTR _glConfig
	push	edx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@GL_InitExt

; 1683 : 		glConfig.hardware_type = GLHW_NVIDIA;

	mov	DWORD PTR _glConfig+12, 2
	jmp	$LN16@GL_InitExt
$LN4@GL_InitExt:

; 1684 : 	else if( Q_stristr(glConfig.renderer_string, "rv770" ))

	push	OFFSET $SG144537
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@GL_InitExt

; 1685 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	$LN16@GL_InitExt
$LN6@GL_InitExt:

; 1686 : 	else if( Q_stristr(glConfig.renderer_string, "radeon hd" ))

	push	OFFSET $SG144540
	mov	ecx, DWORD PTR _glConfig
	push	ecx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@GL_InitExt

; 1687 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	$LN16@GL_InitExt
$LN8@GL_InitExt:

; 1688 : 	else if( Q_stristr( glConfig.renderer_string, "eah4850" ) || Q_stristr( glConfig.renderer_string, "eah4870" ))

	push	OFFSET $SG144544
	mov	edx, DWORD PTR _glConfig
	push	edx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@GL_InitExt
	push	OFFSET $SG144545
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@GL_InitExt
$LN12@GL_InitExt:

; 1689 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	SHORT $LN16@GL_InitExt
$LN10@GL_InitExt:

; 1690 : 	else if( Q_stristr( glConfig.renderer_string, "radeon" ))

	push	OFFSET $SG144548
	mov	ecx, DWORD PTR _glConfig
	push	ecx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@GL_InitExt

; 1691 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	SHORT $LN16@GL_InitExt
$LN13@GL_InitExt:

; 1692 : 	else if( Q_stristr( glConfig.renderer_string, "intel" ))

	push	OFFSET $SG144551
	mov	edx, DWORD PTR _glConfig
	push	edx
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@GL_InitExt

; 1693 : 		glConfig.hardware_type = GLHW_INTEL;

	mov	DWORD PTR _glConfig+12, 3
	jmp	SHORT $LN16@GL_InitExt
$LN15@GL_InitExt:

; 1694 : 	else glConfig.hardware_type = GLHW_GENERIC;

	mov	DWORD PTR _glConfig+12, 0
$LN16@GL_InitExt:

; 1695 : 
; 1696 : 	// initalize until base opengl functions loaded (old-context)
; 1697 : 	if( !context_flags && !CVAR_TO_BOOL( gl_wgl_msaa_samples ))

	cmp	DWORD PTR _context_flags, 0
	jne	SHORT $LN17@GL_InitExt
	cmp	DWORD PTR _gl_wgl_msaa_samples, 0
	je	SHORT $LN40@GL_InitExt
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@GL_InitExt
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN41@GL_InitExt
$LN40@GL_InitExt:
	mov	DWORD PTR tv146[ebp], 0
$LN41@GL_InitExt:
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN17@GL_InitExt

; 1698 : 		GL_CheckExtension( "OpenGL Internal ProcAddress", wglproc_funcs, NULL, GL_WGL_PROCADDRESS );

	push	3
	push	0
	push	OFFSET _wglproc_funcs
	push	OFFSET $SG144553
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN17@GL_InitExt:

; 1699 : 
; 1700 : 	// windows-specific extensions
; 1701 : 	GL_CheckExtension( "WGL Extensions String", wglgetextensionsstring, NULL, GL_WGL_EXTENSIONS );

	push	1
	push	0
	push	OFFSET _wglgetextensionsstring
	push	OFFSET $SG144554
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1702 : 
; 1703 : 	if( pwglGetExtensionsStringEXT != NULL )

	cmp	DWORD PTR _pwglGetExtensionsStringEXT, 0
	je	SHORT $LN18@GL_InitExt

; 1704 : 		glConfig.wgl_extensions_string = pwglGetExtensionsStringEXT();

	call	DWORD PTR _pwglGetExtensionsStringEXT
	mov	DWORD PTR _glConfig+20, eax
	jmp	SHORT $LN19@GL_InitExt
$LN18@GL_InitExt:

; 1705 : 	else glConfig.wgl_extensions_string = NULL;

	mov	DWORD PTR _glConfig+20, 0
$LN19@GL_InitExt:

; 1706 : 
; 1707 : 	// initalize until base opengl functions loaded
; 1708 : 	GL_CheckExtension( "WGL_EXT_swap_control", wglswapintervalfuncs, NULL, GL_WGL_SWAPCONTROL );

	push	2
	push	0
	push	OFFSET _wglswapintervalfuncs
	push	OFFSET $SG144557
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1709 : 
; 1710 : 	// multitexture
; 1711 : 	glConfig.max_texture_units = glConfig.max_texture_coords = glConfig.max_teximage_units = 1;

	mov	DWORD PTR _glConfig+56, 1
	mov	ecx, DWORD PTR _glConfig+56
	mov	DWORD PTR _glConfig+52, ecx
	mov	edx, DWORD PTR _glConfig+52
	mov	DWORD PTR _glConfig+48, edx

; 1712 : 	GL_CheckExtension( "GL_ARB_multitexture", multitexturefuncs, "gl_arb_multitexture", GL_ARB_MULTITEXTURE );

	push	4
	push	OFFSET $SG144558
	push	OFFSET _multitexturefuncs
	push	OFFSET $SG144559
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1713 : 
; 1714 : 	if( GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@GL_InitExt

; 1715 : 		pglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glConfig.max_texture_units );

	push	OFFSET _glConfig+48
	push	34018					; 000084e2H
	call	DWORD PTR _pglGetIntegerv
$LN20@GL_InitExt:

; 1716 : 
; 1717 : 	if( glConfig.max_texture_units == 1 )

	cmp	DWORD PTR _glConfig+48, 1
	jne	SHORT $LN21@GL_InitExt

; 1718 : 		GL_SetExtension( GL_ARB_MULTITEXTURE, false );

	push	0
	push	4
	call	_GL_SetExtension
	add	esp, 8
$LN21@GL_InitExt:

; 1719 : 
; 1720 : 	// 3d texture support
; 1721 : 	GL_CheckExtension( "GL_EXT_texture3D", texture3dextfuncs, "gl_texture_3d", GL_TEXTURE_3D_EXT );

	push	12					; 0000000cH
	push	OFFSET $SG144562
	push	OFFSET _texture3dextfuncs
	push	OFFSET $SG144563
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1722 : 
; 1723 : 	if( GL_Support( GL_TEXTURE_3D_EXT ))

	push	12					; 0000000cH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@GL_InitExt

; 1724 : 	{
; 1725 : 		pglGetIntegerv( GL_MAX_3D_TEXTURE_SIZE, &glConfig.max_3d_texture_size );

	push	OFFSET _glConfig+72
	push	32883					; 00008073H
	call	DWORD PTR _pglGetIntegerv

; 1726 : 
; 1727 : 		if( glConfig.max_3d_texture_size < 32 )

	cmp	DWORD PTR _glConfig+72, 32		; 00000020H
	jge	SHORT $LN23@GL_InitExt

; 1728 : 		{
; 1729 : 			GL_SetExtension( GL_TEXTURE_3D_EXT, false );

	push	0
	push	12					; 0000000cH
	call	_GL_SetExtension
	add	esp, 8

; 1730 : 			Con_Printf( S_ERROR "GL_EXT_texture3D reported bogus GL_MAX_3D_TEXTURE_SIZE, disabled\n" );

	push	OFFSET $SG144566
	call	_Con_Printf
	add	esp, 4
$LN23@GL_InitExt:

; 1731 : 		}
; 1732 : 	}
; 1733 : 
; 1734 : 	// 2d texture array support
; 1735 : 	GL_CheckExtension( "GL_EXT_texture_array", texture3dextfuncs, "gl_texture_2d_array", GL_TEXTURE_ARRAY_EXT );

	push	11					; 0000000bH
	push	OFFSET $SG144567
	push	OFFSET _texture3dextfuncs
	push	OFFSET $SG144568
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1736 : 
; 1737 : 	if( GL_Support( GL_TEXTURE_ARRAY_EXT ))

	push	11					; 0000000bH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@GL_InitExt

; 1738 : 		pglGetIntegerv( GL_MAX_ARRAY_TEXTURE_LAYERS_EXT, &glConfig.max_2d_texture_layers );

	push	OFFSET _glConfig+68
	push	35071					; 000088ffH
	call	DWORD PTR _pglGetIntegerv
$LN24@GL_InitExt:

; 1739 : 
; 1740 : 	// cubemaps support
; 1741 : 	GL_CheckExtension( "GL_ARB_texture_cube_map", NULL, "gl_texture_cubemap", GL_TEXTURE_CUBEMAP_EXT );

	push	5
	push	OFFSET $SG144570
	push	0
	push	OFFSET $SG144571
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1742 : 
; 1743 : 	if( GL_Support( GL_TEXTURE_CUBEMAP_EXT ))

	push	5
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@GL_InitExt

; 1744 : 	{
; 1745 : 		pglGetIntegerv( GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB, &glConfig.max_cubemap_size );

	push	OFFSET _glConfig+76
	push	34076					; 0000851cH
	call	DWORD PTR _pglGetIntegerv

; 1746 : 
; 1747 : 		// check for seamless cubemaps too
; 1748 : 		GL_CheckExtension( "GL_ARB_seamless_cube_map", NULL, "gl_texture_cubemap_seamless", GL_ARB_SEAMLESS_CUBEMAP );

	push	18					; 00000012H
	push	OFFSET $SG144573
	push	0
	push	OFFSET $SG144574
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN25@GL_InitExt:

; 1749 : 	}
; 1750 : 
; 1751 : 	GL_CheckExtension( "GL_ARB_texture_non_power_of_two", NULL, "gl_texture_npot", GL_ARB_TEXTURE_NPOT_EXT );

	push	14					; 0000000eH
	push	OFFSET $SG144575
	push	0
	push	OFFSET $SG144576
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1752 : 	GL_CheckExtension( "GL_ARB_texture_compression", texturecompressionfuncs, "gl_texture_dxt_compression", GL_TEXTURE_COMPRESSION_EXT );

	push	8
	push	OFFSET $SG144577
	push	OFFSET _texturecompressionfuncs
	push	OFFSET $SG144578
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1753 : 	GL_CheckExtension( "GL_EXT_texture_edge_clamp", NULL, NULL, GL_CLAMPTOEDGE_EXT );

	push	13					; 0000000dH
	push	0
	push	0
	push	OFFSET $SG144579
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1754 : 
; 1755 : 	if( !GL_Support( GL_CLAMPTOEDGE_EXT ))

	push	13					; 0000000dH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@GL_InitExt

; 1756 : 		GL_CheckExtension( "GL_SGIS_texture_edge_clamp", NULL, NULL, GL_CLAMPTOEDGE_EXT );

	push	13					; 0000000dH
	push	0
	push	0
	push	OFFSET $SG144581
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN26@GL_InitExt:

; 1757 : 
; 1758 : 	glConfig.max_texture_anisotropy = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _glConfig+80, xmm0

; 1759 : 	GL_CheckExtension( "GL_EXT_texture_filter_anisotropic", NULL, "gl_texture_anisotropic_filter", GL_ANISOTROPY_EXT );

	push	6
	push	OFFSET $SG144582
	push	0
	push	OFFSET $SG144583
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1760 : 
; 1761 : 	if( GL_Support( GL_ANISOTROPY_EXT ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@GL_InitExt

; 1762 : 		pglGetFloatv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &glConfig.max_texture_anisotropy );

	push	OFFSET _glConfig+80
	push	34047					; 000084ffH
	call	DWORD PTR _pglGetFloatv
$LN27@GL_InitExt:

; 1763 : 
; 1764 : 	// g-cont. because lodbias it too glitchy on Intel's cards
; 1765 : 	if( glConfig.hardware_type != GLHW_INTEL )

	cmp	DWORD PTR _glConfig+12, 3
	je	SHORT $LN28@GL_InitExt

; 1766 : 		GL_CheckExtension( "GL_EXT_texture_lod_bias", NULL, "gl_texture_mipmap_biasing", GL_TEXTURE_LOD_BIAS );

	push	7
	push	OFFSET $SG144586
	push	0
	push	OFFSET $SG144587
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN28@GL_InitExt:

; 1767 : 
; 1768 : 	if( GL_Support( GL_TEXTURE_LOD_BIAS ))

	push	7
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN29@GL_InitExt

; 1769 : 		pglGetFloatv( GL_MAX_TEXTURE_LOD_BIAS_EXT, &glConfig.max_texture_lod_bias );

	push	OFFSET _glConfig+84
	push	34045					; 000084fdH
	call	DWORD PTR _pglGetFloatv
$LN29@GL_InitExt:

; 1770 : 
; 1771 : 	GL_CheckExtension( "GL_ARB_texture_border_clamp", NULL, NULL, GL_CLAMP_TEXBORDER_EXT );

	push	15					; 0000000fH
	push	0
	push	0
	push	OFFSET $SG144589
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1772 : 
; 1773 : 	GL_CheckExtension( "GL_ARB_depth_texture", NULL, NULL, GL_DEPTH_TEXTURE );

	push	20					; 00000014H
	push	0
	push	0
	push	OFFSET $SG144590
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1774 : 	GL_CheckExtension( "GL_ARB_texture_float", NULL, "gl_texture_float", GL_ARB_TEXTURE_FLOAT_EXT );

	push	16					; 00000010H
	push	OFFSET $SG144591
	push	0
	push	OFFSET $SG144592
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1775 : 	GL_CheckExtension( "GL_ARB_depth_buffer_float", NULL, "gl_texture_depth_float", GL_ARB_DEPTH_FLOAT_EXT );

	push	17					; 00000011H
	push	OFFSET $SG144593
	push	0
	push	OFFSET $SG144594
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1776 : 	GL_CheckExtension( "GL_EXT_gpu_shader4", NULL, NULL, GL_EXT_GPU_SHADER4 ); // don't confuse users

	push	19					; 00000013H
	push	0
	push	0
	push	OFFSET $SG144595
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1777 : 	GL_CheckExtension( "GL_ARB_shading_language_100", NULL, NULL, GL_SHADER_GLSL100_EXT );

	push	9
	push	0
	push	0
	push	OFFSET $SG144596
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1778 : 
; 1779 : 	// this won't work without extended context
; 1780 : 	if( glw_state.extended )

	cmp	DWORD PTR _glw_state+24, 0
	je	SHORT $LN30@GL_InitExt

; 1781 : 		GL_CheckExtension( "GL_ARB_debug_output", debugoutputfuncs, "gl_debug_output", GL_DEBUG_OUTPUT );

	push	21					; 00000015H
	push	OFFSET $SG144598
	push	OFFSET _debugoutputfuncs
	push	OFFSET $SG144599
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN30@GL_InitExt:

; 1782 : 
; 1783 : 	// rectangle textures support
; 1784 : 	GL_CheckExtension( "GL_ARB_texture_rectangle", NULL, "gl_texture_rectangle", GL_TEXTURE_2D_RECT_EXT );

	push	10					; 0000000aH
	push	OFFSET $SG144600
	push	0
	push	OFFSET $SG144601
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1785 : 
; 1786 : 	if( GL_Support( GL_SHADER_GLSL100_EXT ))

	push	9
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@GL_InitExt

; 1787 : 	{
; 1788 : 		pglGetIntegerv( GL_MAX_TEXTURE_COORDS_ARB, &glConfig.max_texture_coords );

	push	OFFSET _glConfig+52
	push	34929					; 00008871H
	call	DWORD PTR _pglGetIntegerv

; 1789 : 		pglGetIntegerv( GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &glConfig.max_teximage_units );

	push	OFFSET _glConfig+56
	push	34930					; 00008872H
	call	DWORD PTR _pglGetIntegerv

; 1790 : 
; 1791 : 		// check for hardware skinning
; 1792 : 		pglGetIntegerv( GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB, &glConfig.max_vertex_uniforms );

	push	OFFSET _glConfig+88
	push	35658					; 00008b4aH
	call	DWORD PTR _pglGetIntegerv

; 1793 : 		pglGetIntegerv( GL_MAX_VERTEX_ATTRIBS_ARB, &glConfig.max_vertex_attribs );

	push	OFFSET _glConfig+92
	push	34921					; 00008869H
	call	DWORD PTR _pglGetIntegerv

; 1794 : 
; 1795 : 		if( glConfig.hardware_type == GLHW_RADEON && glConfig.max_vertex_uniforms > 512 )

	cmp	DWORD PTR _glConfig+12, 1
	jne	SHORT $LN33@GL_InitExt
	cmp	DWORD PTR _glConfig+88, 512		; 00000200H
	jle	SHORT $LN33@GL_InitExt

; 1796 : 			glConfig.max_vertex_uniforms /= 4; // radeon returns not correct info

	mov	eax, DWORD PTR _glConfig+88
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _glConfig+88, eax
$LN33@GL_InitExt:

; 1797 : 	}

	jmp	SHORT $LN32@GL_InitExt
$LN31@GL_InitExt:

; 1798 : 	else
; 1799 : 	{
; 1800 : 		// just get from multitexturing
; 1801 : 		glConfig.max_texture_coords = glConfig.max_teximage_units = glConfig.max_texture_units;

	mov	eax, DWORD PTR _glConfig+48
	mov	DWORD PTR _glConfig+56, eax
	mov	ecx, DWORD PTR _glConfig+56
	mov	DWORD PTR _glConfig+52, ecx
$LN32@GL_InitExt:

; 1802 : 	}
; 1803 : 
; 1804 : 	pglGetIntegerv( GL_MAX_TEXTURE_SIZE, &glConfig.max_2d_texture_size );

	push	OFFSET _glConfig+60
	push	3379					; 00000d33H
	call	DWORD PTR _pglGetIntegerv

; 1805 : 	if( glConfig.max_2d_texture_size <= 0 ) glConfig.max_2d_texture_size = 256;

	cmp	DWORD PTR _glConfig+60, 0
	jg	SHORT $LN34@GL_InitExt
	mov	DWORD PTR _glConfig+60, 256		; 00000100H
$LN34@GL_InitExt:

; 1806 : 
; 1807 : 	if( GL_Support( GL_TEXTURE_2D_RECT_EXT ))

	push	10					; 0000000aH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN35@GL_InitExt

; 1808 : 		pglGetIntegerv( GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT, &glConfig.max_2d_rectangle_size );

	push	OFFSET _glConfig+64
	push	34040					; 000084f8H
	call	DWORD PTR _pglGetIntegerv
$LN35@GL_InitExt:

; 1809 : 
; 1810 : 	Cvar_Get( "gl_max_size", va( "%i", glConfig.max_2d_texture_size ), 0, "opengl texture max dims" );

	push	OFFSET $SG144607
	push	0
	mov	edx, DWORD PTR _glConfig+60
	push	edx
	push	OFFSET $SG144608
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG144609
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 1811 : 
; 1812 : 	// MCD has buffering issues
; 1813 : 	if( Q_stristr( glConfig.renderer_string, "gdi" ))

	push	OFFSET $SG144611
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@GL_InitExt

; 1814 : 		Cvar_SetValue( "gl_finish", 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144612
	call	_Cvar_SetValue
	add	esp, 8
$LN36@GL_InitExt:

; 1815 : 
; 1816 : 	Cvar_Set( "gl_anisotropy", va( "%f", bound( 0, gl_texture_anisotropy->value, glConfig.max_texture_anisotropy )));

	mov	ecx, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN44@GL_InitExt
	mov	edx, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR _glConfig+80
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN42@GL_InitExt
	mov	eax, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR tv420[ebp], xmm0
	jmp	SHORT $LN43@GL_InitExt
$LN42@GL_InitExt:
	movss	xmm0, DWORD PTR _glConfig+80
	movss	DWORD PTR tv420[ebp], xmm0
$LN43@GL_InitExt:
	movss	xmm0, DWORD PTR tv420[ebp]
	movss	DWORD PTR tv421[ebp], xmm0
	jmp	SHORT $LN45@GL_InitExt
$LN44@GL_InitExt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv421[ebp], xmm0
$LN45@GL_InitExt:
	cvtss2sd xmm0, DWORD PTR tv421[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG144613
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG144614
	call	_Cvar_Set
	add	esp, 8

; 1817 : 
; 1818 : 	if( GL_Support( GL_TEXTURE_COMPRESSION_EXT ))

	push	8
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN37@GL_InitExt

; 1819 : 		Image_AddCmdFlags( IL_DDS_HARDWARE );

	push	16					; 00000010H
	call	_Image_AddCmdFlags
	add	esp, 4
$LN37@GL_InitExt:

; 1820 : 
; 1821 : 	// enable gldebug if allowed
; 1822 : 	if( GL_Support( GL_DEBUG_OUTPUT ))

	push	21					; 00000015H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN38@GL_InitExt

; 1823 : 	{
; 1824 : 		pglDebugMessageCallbackARB( GL_DebugOutput, NULL );

	push	0
	push	OFFSET _GL_DebugOutput@28
	call	DWORD PTR _pglDebugMessageCallbackARB

; 1825 : 
; 1826 : 		// force everything to happen in the main thread instead of in a separate driver thread
; 1827 : 		pglEnable( GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB );

	push	33346					; 00008242H
	call	DWORD PTR _pglEnable

; 1828 : 
; 1829 : 		// enable all the low priority messages
; 1830 : 		pglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_LOW_ARB, 0, NULL, true );

	push	1
	push	0
	push	0
	push	37192					; 00009148H
	push	4352					; 00001100H
	push	4352					; 00001100H
	call	DWORD PTR _pglDebugMessageControlARB
$LN38@GL_InitExt:

; 1831 : 	}
; 1832 : 
; 1833 : 	tr.framecount = tr.visframecount = 1;

	mov	DWORD PTR _tr+66668, 1
	mov	ecx, DWORD PTR _tr+66668
	mov	DWORD PTR _tr+66680, ecx

; 1834 : 	glw_state.initialized = true;

	mov	DWORD PTR _glw_state+20, 1

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_InitExtensions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_GL_RemoveCommands PROC

; 1655 : {

	push	ebp
	mov	ebp, esp

; 1656 : 	Cmd_RemoveCommand( "r_info");

	push	OFFSET $SG144495
	call	_Cmd_RemoveCommand
	add	esp, 4

; 1657 : }

	pop	ebp
	ret	0
_GL_RemoveCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_GL_InitCommands PROC

; 1581 : {

	push	ebp
	mov	ebp, esp

; 1582 : 	// system screen width and height (don't suppose for change from console at all)
; 1583 : 	r_speeds = Cvar_Get( "r_speeds", "0", FCVAR_ARCHIVE, "shows renderer speeds" );

	push	OFFSET $SG144353
	push	1
	push	OFFSET $SG144354
	push	OFFSET $SG144355
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_speeds, eax

; 1584 : 	r_fullbright = Cvar_Get( "r_fullbright", "0", FCVAR_CHEAT, "disable lightmaps, get fullbright for entities" );

	push	OFFSET $SG144356
	push	32768					; 00008000H
	push	OFFSET $SG144357
	push	OFFSET $SG144358
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_fullbright, eax

; 1585 : 	r_norefresh = Cvar_Get( "r_norefresh", "0", 0, "disable 3D rendering (use with caution)" );

	push	OFFSET $SG144359
	push	0
	push	OFFSET $SG144360
	push	OFFSET $SG144361
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_norefresh, eax

; 1586 : 	r_lighting_extended = Cvar_Get( "r_lighting_extended", "1", FCVAR_ARCHIVE, "allow to get lighting from bmodels too" );

	push	OFFSET $SG144362
	push	1
	push	OFFSET $SG144363
	push	OFFSET $SG144364
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lighting_extended, eax

; 1587 : 	r_lighting_modulate = Cvar_Get( "r_lighting_modulate", "0.6", FCVAR_ARCHIVE, "lightstyles modulate scale" );

	push	OFFSET $SG144365
	push	1
	push	OFFSET $SG144366
	push	OFFSET $SG144367
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lighting_modulate, eax

; 1588 : 	r_lighting_ambient = Cvar_Get( "r_lighting_ambient", "0.3", FCVAR_ARCHIVE, "map ambient lighting scale" );

	push	OFFSET $SG144368
	push	1
	push	OFFSET $SG144369
	push	OFFSET $SG144370
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lighting_ambient, eax

; 1589 : 	r_adjust_fov = Cvar_Get( "r_adjust_fov", "1", FCVAR_ARCHIVE, "making FOV adjustment for wide-screens" );

	push	OFFSET $SG144371
	push	1
	push	OFFSET $SG144372
	push	OFFSET $SG144373
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_adjust_fov, eax

; 1590 : 	r_novis = Cvar_Get( "r_novis", "0", 0, "ignore vis information (perfomance test)" );

	push	OFFSET $SG144374
	push	0
	push	OFFSET $SG144375
	push	OFFSET $SG144376
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_novis, eax

; 1591 : 	r_nocull = Cvar_Get( "r_nocull", "0", 0, "ignore frustrum culling (perfomance test)" );

	push	OFFSET $SG144377
	push	0
	push	OFFSET $SG144378
	push	OFFSET $SG144379
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_nocull, eax

; 1592 : 	r_detailtextures = Cvar_Get( "r_detailtextures", "1", FCVAR_ARCHIVE, "enable detail textures support, use '2' for autogenerate detail.txt" );

	push	OFFSET $SG144380
	push	1
	push	OFFSET $SG144381
	push	OFFSET $SG144382
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_detailtextures, eax

; 1593 : 	r_lockpvs = Cvar_Get( "r_lockpvs", "0", FCVAR_CHEAT, "lockpvs area at current point (pvs test)" );

	push	OFFSET $SG144383
	push	32768					; 00008000H
	push	OFFSET $SG144384
	push	OFFSET $SG144385
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lockpvs, eax

; 1594 : 	r_lockfrustum = Cvar_Get( "r_lockfrustum", "0", FCVAR_CHEAT, "lock frustrum area at current point (cull test)" );

	push	OFFSET $SG144386
	push	32768					; 00008000H
	push	OFFSET $SG144387
	push	OFFSET $SG144388
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lockfrustum, eax

; 1595 : 	r_dynamic = Cvar_Get( "r_dynamic", "1", FCVAR_ARCHIVE, "allow dynamic lighting (dlights, lightstyles)" );

	push	OFFSET $SG144389
	push	1
	push	OFFSET $SG144390
	push	OFFSET $SG144391
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_dynamic, eax

; 1596 : 	r_traceglow = Cvar_Get( "r_traceglow", "1", FCVAR_ARCHIVE, "cull flares behind models" );

	push	OFFSET $SG144392
	push	1
	push	OFFSET $SG144393
	push	OFFSET $SG144394
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_traceglow, eax

; 1597 : 	r_lightmap = Cvar_Get( "r_lightmap", "0", FCVAR_CHEAT, "lightmap debugging tool" );

	push	OFFSET $SG144395
	push	32768					; 00008000H
	push	OFFSET $SG144396
	push	OFFSET $SG144397
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lightmap, eax

; 1598 : 	r_drawentities = Cvar_Get( "r_drawentities", "1", FCVAR_CHEAT|FCVAR_ARCHIVE, "render entities" );

	push	OFFSET $SG144398
	push	32769					; 00008001H
	push	OFFSET $SG144399
	push	OFFSET $SG144400
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_drawentities, eax

; 1599 : 	r_decals = Cvar_Get( "r_decals", "4096", FCVAR_ARCHIVE, "sets the maximum number of decals" );

	push	OFFSET $SG144401
	push	1
	push	OFFSET $SG144402
	push	OFFSET $SG144403
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_decals, eax

; 1600 : 	r_showtree = Cvar_Get( "r_showtree", "0", FCVAR_ARCHIVE, "build the graph of visible BSP tree" );

	push	OFFSET $SG144404
	push	1
	push	OFFSET $SG144405
	push	OFFSET $SG144406
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_showtree, eax

; 1601 : 	window_xpos = Cvar_Get( "_window_xpos", "130", FCVAR_RENDERINFO, "window position by horizontal" );

	push	OFFSET $SG144407
	push	65536					; 00010000H
	push	OFFSET $SG144408
	push	OFFSET $SG144409
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _window_xpos, eax

; 1602 : 	window_ypos = Cvar_Get( "_window_ypos", "48", FCVAR_RENDERINFO, "window position by vertical" );

	push	OFFSET $SG144410
	push	65536					; 00010000H
	push	OFFSET $SG144411
	push	OFFSET $SG144412
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _window_ypos, eax

; 1603 : 
; 1604 : 	gl_extensions = Cvar_Get( "gl_allow_extensions", "1", FCVAR_GLCONFIG, "allow gl_extensions" );			

	push	OFFSET $SG144413
	push	4096					; 00001000H
	push	OFFSET $SG144414
	push	OFFSET $SG144415
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_extensions, eax

; 1605 : 	gl_wgl_msaa_samples = Cvar_Get( "gl_wgl_msaa_samples", "4", FCVAR_GLCONFIG, "enable multisample anti-aliasing" );

	push	OFFSET $SG144416
	push	4096					; 00001000H
	push	OFFSET $SG144417
	push	OFFSET $SG144418
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_wgl_msaa_samples, eax

; 1606 : 	gl_texture_nearest = Cvar_Get( "gl_texture_nearest", "0", FCVAR_ARCHIVE, "disable texture filter" );

	push	OFFSET $SG144419
	push	1
	push	OFFSET $SG144420
	push	OFFSET $SG144421
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texture_nearest, eax

; 1607 : 	gl_lightmap_nearest = Cvar_Get( "gl_lightmap_nearest", "0", FCVAR_ARCHIVE, "disable lightmap filter" );

	push	OFFSET $SG144422
	push	1
	push	OFFSET $SG144423
	push	OFFSET $SG144424
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_lightmap_nearest, eax

; 1608 : 	gl_check_errors = Cvar_Get( "gl_check_errors", "1", FCVAR_ARCHIVE, "ignore video engine errors" );

	push	OFFSET $SG144425
	push	1
	push	OFFSET $SG144426
	push	OFFSET $SG144427
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_check_errors, eax

; 1609 : 	gl_vsync = Cvar_Get( "gl_vsync", "0", FCVAR_ARCHIVE,  "enable vertical syncronization" );

	push	OFFSET $SG144428
	push	1
	push	OFFSET $SG144429
	push	OFFSET $SG144430
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_vsync, eax

; 1610 : 	gl_detailscale = Cvar_Get( "gl_detailscale", "4.0", FCVAR_ARCHIVE, "default scale applies while auto-generate list of detail textures" );

	push	OFFSET $SG144431
	push	1
	push	OFFSET $SG144432
	push	OFFSET $SG144433
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_detailscale, eax

; 1611 : 	gl_texture_anisotropy = Cvar_Get( "gl_anisotropy", "8", FCVAR_ARCHIVE, "textures anisotropic filter" );

	push	OFFSET $SG144434
	push	1
	push	OFFSET $SG144435
	push	OFFSET $SG144436
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texture_anisotropy, eax

; 1612 : 	gl_texture_lodbias =  Cvar_Get( "gl_texture_lodbias", "0.0", FCVAR_ARCHIVE, "LOD bias for mipmapped textures (perfomance|quality)" );

	push	OFFSET $SG144437
	push	1
	push	OFFSET $SG144438
	push	OFFSET $SG144439
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texture_lodbias, eax

; 1613 : 	gl_keeptjunctions = Cvar_Get( "gl_keeptjunctions", "1", FCVAR_ARCHIVE, "removing tjuncs causes blinking pixels" ); 

	push	OFFSET $SG144440
	push	1
	push	OFFSET $SG144441
	push	OFFSET $SG144442
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_keeptjunctions, eax

; 1614 : 	gl_emboss_scale = Cvar_Get( "gl_emboss_scale", "0", FCVAR_ARCHIVE|FCVAR_LATCH, "fake bumpmapping scale" ); 

	push	OFFSET $SG144443
	push	2049					; 00000801H
	push	OFFSET $SG144444
	push	OFFSET $SG144445
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_emboss_scale, eax

; 1615 : 	gl_showtextures = Cvar_Get( "r_showtextures", "0", FCVAR_CHEAT, "show all uploaded textures" );

	push	OFFSET $SG144446
	push	32768					; 00008000H
	push	OFFSET $SG144447
	push	OFFSET $SG144448
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_showtextures, eax

; 1616 : 	gl_finish = Cvar_Get( "gl_finish", "0", FCVAR_ARCHIVE, "use glFinish instead of glFlush" );

	push	OFFSET $SG144449
	push	1
	push	OFFSET $SG144450
	push	OFFSET $SG144451
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_finish, eax

; 1617 : 	gl_nosort = Cvar_Get( "gl_nosort", "0", FCVAR_ARCHIVE, "disable sorting of translucent surfaces" );

	push	OFFSET $SG144452
	push	1
	push	OFFSET $SG144453
	push	OFFSET $SG144454
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_nosort, eax

; 1618 : 	gl_clear = Cvar_Get( "gl_clear", "0", FCVAR_ARCHIVE, "clearing screen after each frame" );

	push	OFFSET $SG144455
	push	1
	push	OFFSET $SG144456
	push	OFFSET $SG144457
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_clear, eax

; 1619 : 	gl_test = Cvar_Get( "gl_test", "0", 0, "engine developer cvar for quick testing new features" );

	push	OFFSET $SG144458
	push	0
	push	OFFSET $SG144459
	push	OFFSET $SG144460
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_test, eax

; 1620 : 	gl_wireframe = Cvar_Get( "gl_wireframe", "0", FCVAR_ARCHIVE|FCVAR_SPONLY, "show wireframe overlay" );

	push	OFFSET $SG144461
	push	65					; 00000041H
	push	OFFSET $SG144462
	push	OFFSET $SG144463
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_wireframe, eax

; 1621 : 	gl_round_down = Cvar_Get( "gl_round_down", "2", FCVAR_RENDERINFO, "round texture sizes to nearest POT value" );

	push	OFFSET $SG144464
	push	65536					; 00010000H
	push	OFFSET $SG144465
	push	OFFSET $SG144466
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_round_down, eax

; 1622 : 	gl_msaa = Cvar_Get( "gl_msaa", "1", FCVAR_ARCHIVE, "enable multi sample anti-aliasing" );

	push	OFFSET $SG144467
	push	1
	push	OFFSET $SG144468
	push	OFFSET $SG144469
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_msaa, eax

; 1623 : 
; 1624 : 	// these cvar not used by engine but some mods requires this
; 1625 : 	gl_polyoffset = Cvar_Get( "gl_polyoffset", "2.0", FCVAR_ARCHIVE, "polygon offset for decals" );

	push	OFFSET $SG144470
	push	1
	push	OFFSET $SG144471
	push	OFFSET $SG144472
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_polyoffset, eax

; 1626 :  
; 1627 : 	// make sure gl_vsync is checked after vid_restart
; 1628 : 	SetBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _gl_vsync
	mov	DWORD PTR [edx+8], ecx

; 1629 : 
; 1630 : 	vid_gamma = Cvar_Get( "gamma", "2.5", FCVAR_ARCHIVE, "gamma amount" );

	push	OFFSET $SG144473
	push	1
	push	OFFSET $SG144474
	push	OFFSET $SG144475
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_gamma, eax

; 1631 : 	vid_brightness = Cvar_Get( "brightness", "0.0", FCVAR_ARCHIVE, "brighntess factor" );

	push	OFFSET $SG144476
	push	1
	push	OFFSET $SG144477
	push	OFFSET $SG144478
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_brightness, eax

; 1632 : 	vid_mode = Cvar_Get( "vid_mode", VID_AUTOMODE, FCVAR_RENDERINFO|FCVAR_VIDRESTART, "display resolution mode" );

	push	OFFSET $SG144479
	push	1114112					; 00110000H
	push	OFFSET $SG144480
	push	OFFSET $SG144481
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_mode, eax

; 1633 : 	vid_fullscreen = Cvar_Get( "fullscreen", "0", FCVAR_RENDERINFO|FCVAR_VIDRESTART, "enable fullscreen mode" );

	push	OFFSET $SG144482
	push	1114112					; 00110000H
	push	OFFSET $SG144483
	push	OFFSET $SG144484
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_fullscreen, eax

; 1634 : 	vid_displayfrequency = Cvar_Get ( "vid_displayfrequency", "0", FCVAR_RENDERINFO|FCVAR_VIDRESTART, "fullscreen refresh rate" );

	push	OFFSET $SG144485
	push	1114112					; 00110000H
	push	OFFSET $SG144486
	push	OFFSET $SG144487
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_displayfrequency, eax

; 1635 : 
; 1636 : 	Cmd_AddCommand( "r_info", R_RenderInfo_f, "display renderer info" );

	push	OFFSET $SG144488
	push	OFFSET _R_RenderInfo_f
	push	OFFSET $SG144489
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1637 : 
; 1638 : 	// give initial OpenGL configuration
; 1639 : 	host.apply_opengl_config = true;

	mov	DWORD PTR _host+34392, 1

; 1640 : 	Cbuf_AddText( "exec opengl.cfg\n" );

	push	OFFSET $SG144490
	call	_Cbuf_AddText
	add	esp, 4

; 1641 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 1642 : 	host.apply_opengl_config = false;

	mov	DWORD PTR _host+34392, 0

; 1643 : 
; 1644 : 	// apply actual video mode to window
; 1645 : 	Cbuf_AddText( "exec video.cfg\n" );

	push	OFFSET $SG144491
	call	_Cbuf_AddText
	add	esp, 4

; 1646 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 1647 : }

	pop	ebp
	ret	0
_GL_InitCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv159 = -4						; size = 4
_R_RenderInfo_f PROC

; 1530 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1531 : 	Con_Printf( "\n" );

	push	OFFSET $SG144319
	call	_Con_Printf
	add	esp, 4

; 1532 : 	Con_Printf( "GL_VENDOR: %s\n", glConfig.vendor_string );

	mov	eax, DWORD PTR _glConfig+4
	push	eax
	push	OFFSET $SG144320
	call	_Con_Printf
	add	esp, 8

; 1533 : 	Con_Printf( "GL_RENDERER: %s\n", glConfig.renderer_string );

	mov	ecx, DWORD PTR _glConfig
	push	ecx
	push	OFFSET $SG144321
	call	_Con_Printf
	add	esp, 8

; 1534 : 	Con_Printf( "GL_VERSION: %s\n", glConfig.version_string );

	mov	edx, DWORD PTR _glConfig+8
	push	edx
	push	OFFSET $SG144322
	call	_Con_Printf
	add	esp, 8

; 1535 : 
; 1536 : 	// don't spam about extensions
; 1537 : 	if( host_developer.value >= DEV_EXTENDED )

	movss	xmm0, DWORD PTR _host_developer+12
	comiss	xmm0, DWORD PTR __real@40000000
	jb	SHORT $LN3@R_RenderIn

; 1538 : 	{
; 1539 : 		Con_Printf( "GL_EXTENSIONS: %s\n", glConfig.extensions_string );

	mov	eax, DWORD PTR _glConfig+16
	push	eax
	push	OFFSET $SG144324
	call	_Con_Printf
	add	esp, 8

; 1540 : 
; 1541 : 		if( glConfig.wgl_extensions_string != NULL )

	cmp	DWORD PTR _glConfig+20, 0
	je	SHORT $LN3@R_RenderIn

; 1542 : 			Con_Printf( "\nWGL_EXTENSIONS: %s\n", glConfig.wgl_extensions_string );

	mov	ecx, DWORD PTR _glConfig+20
	push	ecx
	push	OFFSET $SG144326
	call	_Con_Printf
	add	esp, 8
$LN3@R_RenderIn:

; 1543 : 	}
; 1544 : 
; 1545 : 	Con_Printf( "GL_MAX_TEXTURE_SIZE: %i\n", glConfig.max_2d_texture_size );

	mov	edx, DWORD PTR _glConfig+60
	push	edx
	push	OFFSET $SG144327
	call	_Con_Printf
	add	esp, 8

; 1546 : 	
; 1547 : 	if( GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@R_RenderIn

; 1548 : 		Con_Printf( "GL_MAX_TEXTURE_UNITS_ARB: %i\n", glConfig.max_texture_units );

	mov	eax, DWORD PTR _glConfig+48
	push	eax
	push	OFFSET $SG144329
	call	_Con_Printf
	add	esp, 8
$LN4@R_RenderIn:

; 1549 : 	if( GL_Support( GL_TEXTURE_CUBEMAP_EXT ))

	push	5
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@R_RenderIn

; 1550 : 		Con_Printf( "GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB: %i\n", glConfig.max_cubemap_size );

	mov	ecx, DWORD PTR _glConfig+76
	push	ecx
	push	OFFSET $SG144331
	call	_Con_Printf
	add	esp, 8
$LN5@R_RenderIn:

; 1551 : 	if( GL_Support( GL_ANISOTROPY_EXT ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@R_RenderIn

; 1552 : 		Con_Printf( "GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: %.1f\n", glConfig.max_texture_anisotropy );

	cvtss2sd xmm0, DWORD PTR _glConfig+80
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG144333
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN6@R_RenderIn:

; 1553 : 	if( GL_Support( GL_TEXTURE_2D_RECT_EXT ))

	push	10					; 0000000aH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@R_RenderIn

; 1554 : 		Con_Printf( "GL_MAX_RECTANGLE_TEXTURE_SIZE: %i\n", glConfig.max_2d_rectangle_size );

	mov	edx, DWORD PTR _glConfig+64
	push	edx
	push	OFFSET $SG144335
	call	_Con_Printf
	add	esp, 8
$LN7@R_RenderIn:

; 1555 : 	if( GL_Support( GL_TEXTURE_ARRAY_EXT ))

	push	11					; 0000000bH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_RenderIn

; 1556 : 		Con_Printf( "GL_MAX_ARRAY_TEXTURE_LAYERS_EXT: %i\n", glConfig.max_2d_texture_layers );

	mov	eax, DWORD PTR _glConfig+68
	push	eax
	push	OFFSET $SG144337
	call	_Con_Printf
	add	esp, 8
$LN8@R_RenderIn:

; 1557 : 	if( GL_Support( GL_SHADER_GLSL100_EXT ))

	push	9
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@R_RenderIn

; 1558 : 	{
; 1559 : 		Con_Printf( "GL_MAX_TEXTURE_COORDS_ARB: %i\n", glConfig.max_texture_coords );

	mov	ecx, DWORD PTR _glConfig+52
	push	ecx
	push	OFFSET $SG144339
	call	_Con_Printf
	add	esp, 8

; 1560 : 		Con_Printf( "GL_MAX_TEXTURE_IMAGE_UNITS_ARB: %i\n", glConfig.max_teximage_units );

	mov	edx, DWORD PTR _glConfig+56
	push	edx
	push	OFFSET $SG144340
	call	_Con_Printf
	add	esp, 8

; 1561 : 		Con_Printf( "GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB: %i\n", glConfig.max_vertex_uniforms );

	mov	eax, DWORD PTR _glConfig+88
	push	eax
	push	OFFSET $SG144341
	call	_Con_Printf
	add	esp, 8

; 1562 : 		Con_Printf( "GL_MAX_VERTEX_ATTRIBS_ARB: %i\n", glConfig.max_vertex_attribs );

	mov	ecx, DWORD PTR _glConfig+92
	push	ecx
	push	OFFSET $SG144342
	call	_Con_Printf
	add	esp, 8
$LN9@R_RenderIn:

; 1563 : 	}
; 1564 : 
; 1565 : 	Con_Printf( "\n" );

	push	OFFSET $SG144343
	call	_Con_Printf
	add	esp, 4

; 1566 : 	Con_Printf( "MODE: %s\n", vidmode[(int)vid_mode->value].desc );

	mov	edx, DWORD PTR _vid_mode
	cvttss2si eax, DWORD PTR [edx+12]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax]
	push	ecx
	push	OFFSET $SG144344
	call	_Con_Printf
	add	esp, 8

; 1567 : 	Con_Printf( "\n" );

	push	OFFSET $SG144345
	call	_Con_Printf
	add	esp, 4

; 1568 : 	Con_Printf( "VERTICAL SYNC: %s\n", gl_vsync->value ? "enabled" : "disabled" );

	mov	edx, DWORD PTR _gl_vsync
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@R_RenderIn
	mov	DWORD PTR tv159[ebp], OFFSET $SG144346
	jmp	SHORT $LN12@R_RenderIn
$LN11@R_RenderIn:
	mov	DWORD PTR tv159[ebp], OFFSET $SG144347
$LN12@R_RenderIn:
	mov	eax, DWORD PTR tv159[ebp]
	push	eax
	push	OFFSET $SG144348
	call	_Con_Printf
	add	esp, 8

; 1569 : 	Con_Printf( "Color %d bits, Alpha %d bits, Depth %d bits, Stencil %d bits\n", glConfig.color_bits,

	mov	ecx, DWORD PTR _glConfig+112
	push	ecx
	mov	edx, DWORD PTR _glConfig+108
	push	edx
	mov	eax, DWORD PTR _glConfig+104
	push	eax
	mov	ecx, DWORD PTR _glConfig+100
	push	ecx
	push	OFFSET $SG144349
	call	_Con_Printf
	add	esp, 20					; 00000014H

; 1570 : 		glConfig.alpha_bits, glConfig.depth_bits, glConfig.stencil_bits );
; 1571 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_GL_SetDefaults PROC

; 1486 : {

	push	ebp
	mov	ebp, esp

; 1487 : 	pglFinish();

	call	DWORD PTR _pglFinish

; 1488 : 
; 1489 : 	pglClearColor( 0.5f, 0.5f, 0.5f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglClearColor

; 1490 : 
; 1491 : 	pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 1492 : 	pglDisable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR _pglDisable

; 1493 : 	pglDisable( GL_SCISSOR_TEST );

	push	3089					; 00000c11H
	call	DWORD PTR _pglDisable

; 1494 : 	pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 1495 : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1496 : 
; 1497 : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+572, 0
	je	SHORT $LN2@GL_SetDefa

; 1498 : 	{
; 1499 : 		pglDisable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglDisable

; 1500 : 		pglStencilMask( ( GLuint ) ~0 );

	push	-1
	call	DWORD PTR _pglStencilMask

; 1501 : 		pglStencilFunc( GL_EQUAL, 0, ~0 );

	push	-1
	push	0
	push	514					; 00000202H
	call	DWORD PTR _pglStencilFunc

; 1502 : 		pglStencilOp( GL_KEEP, GL_INCR, GL_INCR );

	push	7682					; 00001e02H
	push	7682					; 00001e02H
	push	7680					; 00001e00H
	call	DWORD PTR _pglStencilOp
$LN2@GL_SetDefa:

; 1503 : 	}
; 1504 : 
; 1505 : 	pglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );

	push	6914					; 00001b02H
	push	1032					; 00000408H
	call	DWORD PTR _pglPolygonMode

; 1506 : 	pglPolygonOffset( -1.0f, -2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPolygonOffset

; 1507 : 
; 1508 : 	GL_CleanupAllTextureUnits();

	call	_GL_CleanupAllTextureUnits

; 1509 : 
; 1510 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1511 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1512 : 	pglDisable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglDisable

; 1513 : 	pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1514 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1515 : 	pglShadeModel( GL_SMOOTH );

	push	7425					; 00001d01H
	call	DWORD PTR _pglShadeModel

; 1516 : 	pglFrontFace( GL_CCW );

	push	2305					; 00000901H
	call	DWORD PTR _pglFrontFace

; 1517 : 
; 1518 : 	pglPointSize( 1.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 1519 : 	pglLineWidth( 1.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 1520 : 
; 1521 : 	GL_Cull( GL_NONE );

	push	0
	call	_GL_Cull
	add	esp, 4

; 1522 : }

	pop	ebp
	ret	0
_GL_SetDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_R_Free_OpenGL PROC

; 1468 : {

	push	ebp
	mov	ebp, esp

; 1469 : 	GL_DeleteContext ();

	call	_GL_DeleteContext

; 1470 : 
; 1471 : 	VID_DestroyWindow ();

	call	_VID_DestroyWindow

; 1472 : 
; 1473 : 	Sys_FreeLibrary( &opengl_dll );

	push	OFFSET _opengl_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 1474 : 
; 1475 : 	// now all extensions are disabled
; 1476 : 	memset( glConfig.extension, 0, sizeof( glConfig.extension ));

	push	22					; 00000016H
	push	0
	push	OFFSET _glConfig+24
	call	_memset
	add	esp, 12					; 0000000cH

; 1477 : 	glw_state.initialized = false;

	mov	DWORD PTR _glw_state+20, 0

; 1478 : }

	pop	ebp
	ret	0
_R_Free_OpenGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_R_Init_OpenGL PROC

; 1450 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1451 : 	Sys_LoadLibrary( &opengl_dll );	// load opengl32.dll

	push	OFFSET _opengl_dll
	call	_Sys_LoadLibrary
	add	esp, 4

; 1452 : 
; 1453 : 	if( !opengl_dll.link )

	cmp	DWORD PTR _opengl_dll+12, 0
	jne	SHORT $LN2@R_Init_Ope

; 1454 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_Init_Ope
$LN2@R_Init_Ope:

; 1455 : 
; 1456 : 	if( context_flags || CVAR_TO_BOOL( gl_wgl_msaa_samples ))

	cmp	DWORD PTR _context_flags, 0
	jne	SHORT $LN4@R_Init_Ope
	cmp	DWORD PTR _gl_wgl_msaa_samples, 0
	je	SHORT $LN6@R_Init_Ope
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_Init_Ope
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@R_Init_Ope
$LN6@R_Init_Ope:
	mov	DWORD PTR tv70[ebp], 0
$LN7@R_Init_Ope:
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN3@R_Init_Ope
$LN4@R_Init_Ope:

; 1457 : 		GL_CheckExtension( "OpenGL Internal ProcAddress", wglproc_funcs, NULL, GL_WGL_PROCADDRESS );

	push	3
	push	0
	push	OFFSET _wglproc_funcs
	push	OFFSET $SG144305
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN3@R_Init_Ope:

; 1458 : 
; 1459 : 	return VID_SetMode();

	call	_VID_SetMode
$LN1@R_Init_Ope:

; 1460 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_Init_OpenGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_fullscreen$ = -20					; size = 4
_iScreenWidth$1 = -16					; size = 4
_iScreenHeight$2 = -12					; size = 4
_hDCScreen$3 = -8					; size = 4
_err$ = -4						; size = 4
_VID_SetMode PROC

; 1357 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1358 : 	qboolean	fullscreen;
; 1359 : 	rserr_t	err;
; 1360 : 
; 1361 : 	if( vid_mode->value == -1 )	// trying to get resolution automatically by default

	mov	eax, DWORD PTR _vid_mode
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN4@VID_SetMod

; 1362 : 	{
; 1363 : 		HDC	hDCScreen = GetDC( NULL );

	push	0
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDCScreen$3[ebp], eax

; 1364 : 		int	iScreenWidth = GetDeviceCaps( hDCScreen, HORZRES );

	push	8
	mov	ecx, DWORD PTR _hDCScreen$3[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _iScreenWidth$1[ebp], eax

; 1365 : 		int	iScreenHeight = GetDeviceCaps( hDCScreen, VERTRES );

	push	10					; 0000000aH
	mov	edx, DWORD PTR _hDCScreen$3[ebp]
	push	edx
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _iScreenHeight$2[ebp], eax

; 1366 : 
; 1367 : 		ReleaseDC( NULL, hDCScreen );

	mov	eax, DWORD PTR _hDCScreen$3[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__ReleaseDC@8

; 1368 : 
; 1369 : 		if( R_DescribeVIDMode( iScreenWidth, iScreenHeight ))

	mov	ecx, DWORD PTR _iScreenHeight$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _iScreenWidth$1[ebp]
	push	edx
	call	_R_DescribeVIDMode
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@VID_SetMod

; 1370 : 		{
; 1371 : 			Con_Reportf( "found specified vid mode %i [%ix%i]\n", (int)vid_mode->value, iScreenWidth, iScreenHeight );

	mov	eax, DWORD PTR _iScreenHeight$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _iScreenWidth$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _vid_mode
	cvttss2si eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET $SG144275
	call	_Con_Reportf

; 1372 : 			Cvar_SetValue( "fullscreen", 1 );

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144276
	call	_Cvar_SetValue
	add	esp, 8

; 1373 : 		}

	jmp	SHORT $LN4@VID_SetMod
$LN3@VID_SetMod:

; 1374 : 		else
; 1375 : 		{
; 1376 : 			Con_Reportf( "failed to set specified vid mode [%ix%i]\n", iScreenWidth, iScreenHeight );

	mov	ecx, DWORD PTR _iScreenHeight$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _iScreenWidth$1[ebp]
	push	edx
	push	OFFSET $SG144277
	call	_Con_Reportf

; 1377 : 			Cvar_SetValue( "vid_mode", VID_DEFAULTMODE );

	add	esp, 8
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144278
	call	_Cvar_SetValue
	add	esp, 8
$LN4@VID_SetMod:

; 1378 : 		}
; 1379 : 	}
; 1380 : 
; 1381 : 	fullscreen = vid_fullscreen->value;

	mov	eax, DWORD PTR _vid_fullscreen
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _fullscreen$[ebp], ecx

; 1382 : 	SetBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	edx, DWORD PTR _gl_vsync
	mov	eax, DWORD PTR [edx+8]
	or	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _gl_vsync
	mov	DWORD PTR [ecx+8], eax

; 1383 : 
; 1384 : 	if(( err = R_ChangeDisplaySettings( vid_mode->value, fullscreen )) == rserr_ok )

	mov	edx, DWORD PTR _fullscreen$[ebp]
	push	edx
	mov	eax, DWORD PTR _vid_mode
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	call	_R_ChangeDisplaySettings
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN5@VID_SetMod

; 1385 : 	{
; 1386 : 		glConfig.prev_mode = vid_mode->value;

	mov	edx, DWORD PTR _vid_mode
	cvttss2si eax, DWORD PTR [edx+12]
	mov	DWORD PTR _glConfig+132, eax

; 1387 : 	}

	jmp	$LN11@VID_SetMod
$LN5@VID_SetMod:

; 1388 : 	else
; 1389 : 	{
; 1390 : 		if( err == rserr_invalid_fullscreen )

	cmp	DWORD PTR _err$[ebp], 1
	jne	SHORT $LN7@VID_SetMod

; 1391 : 		{
; 1392 : 			Cvar_SetValue( "fullscreen", 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144283
	call	_Cvar_SetValue
	add	esp, 8

; 1393 : 			Con_Printf( S_ERROR "VID_SetMode: fullscreen unavailable in this mode\n" );

	push	OFFSET $SG144284
	call	_Con_Printf
	add	esp, 4

; 1394 : 			if(( err = R_ChangeDisplaySettings( vid_mode->value, false )) == rserr_ok )

	push	0
	mov	ecx, DWORD PTR _vid_mode
	cvttss2si edx, DWORD PTR [ecx+12]
	push	edx
	call	_R_ChangeDisplaySettings
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN9@VID_SetMod

; 1395 : 				return true;

	mov	eax, 1
	jmp	SHORT $LN1@VID_SetMod
$LN9@VID_SetMod:

; 1396 : 		}

	jmp	SHORT $LN10@VID_SetMod
$LN7@VID_SetMod:

; 1397 : 		else if( err == rserr_invalid_mode )

	cmp	DWORD PTR _err$[ebp], 2
	jne	SHORT $LN10@VID_SetMod

; 1398 : 		{
; 1399 : 			Con_Printf( S_ERROR "VID_SetMode: invalid mode\n" );

	push	OFFSET $SG144287
	call	_Con_Printf
	add	esp, 4

; 1400 : 			Cvar_SetValue( "vid_mode", glConfig.prev_mode );

	cvtsi2ss xmm0, DWORD PTR _glConfig+132
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144288
	call	_Cvar_SetValue
	add	esp, 8
$LN10@VID_SetMod:

; 1401 : 		}
; 1402 : 
; 1403 : 		// try setting it back to something safe
; 1404 : 		if(( err = R_ChangeDisplaySettings( glConfig.prev_mode, false )) != rserr_ok )

	push	0
	mov	eax, DWORD PTR _glConfig+132
	push	eax
	call	_R_ChangeDisplaySettings
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN11@VID_SetMod

; 1405 : 		{
; 1406 : 			Con_Printf( S_ERROR "VID_SetMode: could not revert to safe mode\n" );

	push	OFFSET $SG144290
	call	_Con_Printf
	add	esp, 4

; 1407 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@VID_SetMod
$LN11@VID_SetMod:

; 1408 : 		}
; 1409 : 	}
; 1410 : 
; 1411 : 	return true;

	mov	eax, 1
$LN1@VID_SetMod:

; 1412 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_VID_SetMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_cds_result$ = -180					; size = 4
_freq_specified$1 = -176				; size = 4
_hDC$ = -172						; size = 4
_width$ = -168						; size = 4
_height$ = -164						; size = 4
_dm$2 = -160						; size = 156
__$ArrayPad$ = -4					; size = 4
_vid_mode$ = 8						; size = 4
_fullscreen$ = 12					; size = 4
_R_ChangeDisplaySettings PROC

; 1231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1232 : 	int	width, height;
; 1233 : 	int	cds_result;
; 1234 : 	HDC	hDC;
; 1235 : 	
; 1236 : 	R_SaveVideoMode( vid_mode );

	mov	eax, DWORD PTR _vid_mode$[ebp]
	push	eax
	call	_R_SaveVideoMode
	add	esp, 4

; 1237 : 
; 1238 : 	width = glState.width;

	mov	ecx, DWORD PTR _glState
	mov	DWORD PTR _width$[ebp], ecx

; 1239 : 	height = glState.height;

	mov	edx, DWORD PTR _glState+4
	mov	DWORD PTR _height$[ebp], edx

; 1240 : 
; 1241 : 	// check our desktop attributes
; 1242 : 	hDC = GetDC( GetDesktopWindow( ));

	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDC$[ebp], eax

; 1243 : 	glw_state.desktopBitsPixel = GetDeviceCaps( hDC, BITSPIXEL );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _glw_state+8, eax

; 1244 : 	glw_state.desktopWidth = GetDeviceCaps( hDC, HORZRES );

	push	8
	mov	ecx, DWORD PTR _hDC$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _glw_state+12, eax

; 1245 : 	glw_state.desktopHeight = GetDeviceCaps( hDC, VERTRES );

	push	10					; 0000000aH
	mov	edx, DWORD PTR _hDC$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _glw_state+16, eax

; 1246 : 	ReleaseDC( GetDesktopWindow(), hDC );

	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__ReleaseDC@8

; 1247 : 
; 1248 : 	// destroy the existing window
; 1249 : 	if( host.hWnd ) VID_DestroyWindow();

	cmp	DWORD PTR _host+34332, 0
	je	SHORT $LN2@R_ChangeDi
	call	_VID_DestroyWindow
$LN2@R_ChangeDi:

; 1250 : 
; 1251 : 	// do a CDS if needed
; 1252 : 	if( fullscreen )

	cmp	DWORD PTR _fullscreen$[ebp], 0
	je	$LN3@R_ChangeDi

; 1253 : 	{
; 1254 : 		DEVMODE	dm;
; 1255 : 
; 1256 : 		memset( &dm, 0, sizeof( dm ));

	push	156					; 0000009cH
	push	0
	lea	ecx, DWORD PTR _dm$2[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1257 : 		dm.dmSize = sizeof( dm );

	mov	edx, 156				; 0000009cH
	mov	WORD PTR _dm$2[ebp+36], dx

; 1258 : 		dm.dmPelsWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _dm$2[ebp+108], eax

; 1259 : 		dm.dmPelsHeight = height;

	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _dm$2[ebp+112], ecx

; 1260 : 		dm.dmFields = DM_PELSWIDTH|DM_PELSHEIGHT;

	mov	DWORD PTR _dm$2[ebp+40], 1572864	; 00180000H

; 1261 : 
; 1262 : 		if( vid_displayfrequency->value > 0 )

	mov	edx, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@R_ChangeDi

; 1263 : 		{
; 1264 : 			if( vid_displayfrequency->value < 60 ) Cvar_SetValue( "vid_displayfrequency", 60 );

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN6@R_ChangeDi
	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144240
	call	_Cvar_SetValue
	add	esp, 8
$LN6@R_ChangeDi:

; 1265 : 			if( vid_displayfrequency->value > 100 ) Cvar_SetValue( "vid_displayfrequency", 100 );

	mov	ecx, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN7@R_ChangeDi
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144242
	call	_Cvar_SetValue
	add	esp, 8
$LN7@R_ChangeDi:

; 1266 : 
; 1267 : 			dm.dmFields |= DM_DISPLAYFREQUENCY;

	mov	edx, DWORD PTR _dm$2[ebp+40]
	or	edx, 4194304				; 00400000H
	mov	DWORD PTR _dm$2[ebp+40], edx

; 1268 : 			dm.dmDisplayFrequency = vid_displayfrequency->value;

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [eax+12]
	call	__ftoui3
	mov	DWORD PTR _dm$2[ebp+120], eax
$LN5@R_ChangeDi:

; 1269 : 		}
; 1270 : 
; 1271 : 		cds_result = ChangeDisplaySettings( &dm, CDS_FULLSCREEN );

	push	4
	lea	ecx, DWORD PTR _dm$2[ebp]
	push	ecx
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	mov	DWORD PTR _cds_result$[ebp], eax

; 1272 : 
; 1273 : 		if( cds_result == DISP_CHANGE_SUCCESSFUL )

	cmp	DWORD PTR _cds_result$[ebp], 0
	jne	SHORT $LN8@R_ChangeDi

; 1274 : 		{
; 1275 : 			glState.fullScreen = true;

	mov	DWORD PTR _glState+8, 1

; 1276 : 
; 1277 : 			if( !VID_CreateWindow( width, height, true ))

	push	1
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@R_ChangeDi

; 1278 : 				return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN10@R_ChangeDi:

; 1279 : 			return rserr_ok;

	xor	eax, eax
	jmp	$LN1@R_ChangeDi

; 1280 : 		}

	jmp	$LN19@R_ChangeDi
$LN8@R_ChangeDi:

; 1281 : 		else if( cds_result == DISP_CHANGE_BADDUALVIEW )

	cmp	DWORD PTR _cds_result$[ebp], -6		; fffffffaH
	jne	$LN11@R_ChangeDi

; 1282 : 		{
; 1283 : 			dm.dmPelsWidth = width * 2;

	mov	ecx, DWORD PTR _width$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _dm$2[ebp+108], ecx

; 1284 : 			dm.dmPelsHeight = height;

	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _dm$2[ebp+112], edx

; 1285 : 			dm.dmFields = DM_PELSWIDTH|DM_PELSHEIGHT;

	mov	DWORD PTR _dm$2[ebp+40], 1572864	; 00180000H

; 1286 : 
; 1287 : 			// our first CDS failed, so maybe we're running on some weird dual monitor system 
; 1288 : 			if( ChangeDisplaySettings( &dm, CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL )

	push	4
	lea	eax, DWORD PTR _dm$2[ebp]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	test	eax, eax
	je	SHORT $LN13@R_ChangeDi

; 1289 : 			{
; 1290 : 				ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1291 : 				glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0

; 1292 : 				if( !VID_CreateWindow( width, height, false ))

	push	0
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@R_ChangeDi

; 1293 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN15@R_ChangeDi:

; 1294 : 				return rserr_invalid_fullscreen;

	mov	eax, 1
	jmp	$LN1@R_ChangeDi

; 1295 : 			}

	jmp	SHORT $LN14@R_ChangeDi
$LN13@R_ChangeDi:

; 1296 : 			else
; 1297 : 			{
; 1298 : 				if( !VID_CreateWindow( width, height, true ))

	push	1
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@R_ChangeDi

; 1299 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN16@R_ChangeDi:

; 1300 : 				glState.fullScreen = true;

	mov	DWORD PTR _glState+8, 1

; 1301 : 				return rserr_ok;

	xor	eax, eax
	jmp	$LN1@R_ChangeDi
$LN14@R_ChangeDi:

; 1302 : 			}
; 1303 : 		}

	jmp	$LN19@R_ChangeDi
$LN11@R_ChangeDi:

; 1304 : 		else
; 1305 : 		{
; 1306 : 			int	freq_specified = 0;

	mov	DWORD PTR _freq_specified$1[ebp], 0

; 1307 : 
; 1308 : 			if( vid_displayfrequency->value > 0 )

	mov	edx, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN17@R_ChangeDi

; 1309 : 			{
; 1310 : 				// clear out custom frequency
; 1311 : 				freq_specified = vid_displayfrequency->value;

	mov	eax, DWORD PTR _vid_displayfrequency
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _freq_specified$1[ebp], ecx

; 1312 : 				Cvar_SetValue( "vid_displayfrequency", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144253
	call	_Cvar_SetValue
	add	esp, 8

; 1313 : 				dm.dmFields &= ~DM_DISPLAYFREQUENCY;

	mov	edx, DWORD PTR _dm$2[ebp+40]
	and	edx, -4194305				; ffbfffffH
	mov	DWORD PTR _dm$2[ebp+40], edx

; 1314 : 				dm.dmDisplayFrequency = 0;

	mov	DWORD PTR _dm$2[ebp+120], 0
$LN17@R_ChangeDi:

; 1315 : 			}
; 1316 : 
; 1317 : 			// our first CDS failed, so maybe we're running with too high displayfrequency
; 1318 : 			if( ChangeDisplaySettings( &dm, CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL )

	push	4
	lea	eax, DWORD PTR _dm$2[ebp]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	test	eax, eax
	je	SHORT $LN18@R_ChangeDi

; 1319 : 			{
; 1320 : 				ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1321 : 				glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0

; 1322 : 				if( !VID_CreateWindow( width, height, false ))

	push	0
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@R_ChangeDi

; 1323 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN20@R_ChangeDi:

; 1324 : 				return rserr_invalid_fullscreen;

	mov	eax, 1
	jmp	$LN1@R_ChangeDi

; 1325 : 			}

	jmp	SHORT $LN19@R_ChangeDi
$LN18@R_ChangeDi:

; 1326 : 			else
; 1327 : 			{
; 1328 : 				if( !VID_CreateWindow( width, height, true ))

	push	1
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@R_ChangeDi

; 1329 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	SHORT $LN1@R_ChangeDi
$LN21@R_ChangeDi:

; 1330 : 
; 1331 : 				if( freq_specified )

	cmp	DWORD PTR _freq_specified$1[ebp], 0
	je	SHORT $LN22@R_ChangeDi

; 1332 : 					Con_Printf( S_ERROR "VID_SetMode: display frequency %i Hz is not supported\n", freq_specified );

	mov	edx, DWORD PTR _freq_specified$1[ebp]
	push	edx
	push	OFFSET $SG144259
	call	_Con_Printf
	add	esp, 8
$LN22@R_ChangeDi:

; 1333 : 				glState.fullScreen = true;

	mov	DWORD PTR _glState+8, 1

; 1334 : 				return rserr_ok;

	xor	eax, eax
	jmp	SHORT $LN1@R_ChangeDi
$LN19@R_ChangeDi:

; 1335 : 			}
; 1336 : 		}
; 1337 : 	}

	jmp	SHORT $LN23@R_ChangeDi
$LN3@R_ChangeDi:

; 1338 : 	else
; 1339 : 	{
; 1340 : 		ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1341 : 		glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0

; 1342 : 		if( !VID_CreateWindow( width, height, false ))

	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@R_ChangeDi

; 1343 : 			return rserr_invalid_mode;

	mov	eax, 2
	jmp	SHORT $LN1@R_ChangeDi
$LN23@R_ChangeDi:

; 1344 : 	}
; 1345 : 
; 1346 : 	return rserr_ok;

	xor	eax, eax
$LN1@R_ChangeDi:

; 1347 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ChangeDisplaySettings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_VID_DestroyWindow PROC

; 1200 : {

	push	ebp
	mov	ebp, esp

; 1201 : 	if( pwglMakeCurrent )

	cmp	DWORD PTR _pwglMakeCurrent, 0
	je	SHORT $LN2@VID_Destro

; 1202 : 		pwglMakeCurrent( NULL, NULL );

	push	0
	push	0
	call	DWORD PTR _pwglMakeCurrent
$LN2@VID_Destro:

; 1203 : 
; 1204 : 	if( glw_state.hDC )

	cmp	DWORD PTR _glw_state, 0
	je	SHORT $LN3@VID_Destro

; 1205 : 	{
; 1206 : 		ReleaseDC( host.hWnd, glw_state.hDC );

	mov	eax, DWORD PTR _glw_state
	push	eax
	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8

; 1207 : 		glw_state.hDC = NULL;

	mov	DWORD PTR _glw_state, 0
$LN3@VID_Destro:

; 1208 : 	}
; 1209 : 
; 1210 : 	if( host.hWnd )

	cmp	DWORD PTR _host+34332, 0
	je	SHORT $LN4@VID_Destro

; 1211 : 	{
; 1212 : 		DestroyWindow ( host.hWnd );

	mov	edx, DWORD PTR _host+34332
	push	edx
	call	DWORD PTR __imp__DestroyWindow@4

; 1213 : 		host.hWnd = NULL;

	mov	DWORD PTR _host+34332, 0
$LN4@VID_Destro:

; 1214 : 	}
; 1215 : 
; 1216 : 	UnregisterClass( WINDOW_NAME, host.hInst );

	mov	eax, DWORD PTR _host
	push	eax
	push	OFFSET $SG144221
	call	DWORD PTR __imp__UnregisterClassA@8

; 1217 : 
; 1218 : 	if( glState.fullScreen )

	cmp	DWORD PTR _glState+8, 0
	je	SHORT $LN1@VID_Destro

; 1219 : 	{
; 1220 : 		ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1221 : 		glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0
$LN1@VID_Destro:

; 1222 : 	}
; 1223 : }

	pop	ebp
	ret	0
_VID_DestroyWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_wc$ = -344						; size = 40
_window$ = -304						; size = 4
_exstyle$ = -300					; size = 4
_stylebits$ = -296					; size = 4
_w$ = -292						; size = 4
_h$ = -288						; size = 4
_x$ = -284						; size = 4
_y$ = -280						; size = 4
_rect$ = -276						; size = 16
_localPath$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_fullscreen$ = 16					; size = 4
_VID_CreateWindow PROC

; 1055 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1056 : 	int		x = 0, y = 0, w, h;

	mov	DWORD PTR _x$[ebp], 0
	mov	DWORD PTR _y$[ebp], 0

; 1057 : 	int		stylebits = WINDOW_STYLE;

	mov	DWORD PTR _stylebits$[ebp], 281542656	; 10c80000H

; 1058 : 	int		exstyle = WINDOW_EX_STYLE;

	mov	DWORD PTR _exstyle$[ebp], 0

; 1059 : 	static string	wndname;
; 1060 : 	HWND		window;
; 1061 : 	RECT		rect;	
; 1062 : 	WNDCLASS		wc;
; 1063 : 
; 1064 : 	Q_strncpy( wndname, GI->title, sizeof( wndname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _SI+768
	add	eax, 384				; 00000180H
	push	eax
	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1065 : 
; 1066 : 	// register the frame class
; 1067 : 	wc.style         = CS_OWNDC|CS_NOCLOSE;

	mov	DWORD PTR _wc$[ebp], 544		; 00000220H

; 1068 : 	wc.lpfnWndProc   = (WNDPROC)IN_WndProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET _IN_WndProc

; 1069 : 	wc.cbClsExtra    = 0;

	mov	DWORD PTR _wc$[ebp+8], 0

; 1070 : 	wc.cbWndExtra    = 0;

	mov	DWORD PTR _wc$[ebp+12], 0

; 1071 : 	wc.hInstance     = host.hInst;

	mov	ecx, DWORD PTR _host
	mov	DWORD PTR _wc$[ebp+16], ecx

; 1072 : 	wc.hCursor       = LoadCursor( NULL, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 1073 : 	wc.hbrBackground = (void *)COLOR_3DSHADOW;

	mov	DWORD PTR _wc$[ebp+28], 16		; 00000010H

; 1074 : 	wc.lpszClassName = WINDOW_NAME;

	mov	DWORD PTR _wc$[ebp+36], OFFSET $SG144182

; 1075 : 	wc.lpszMenuName  = 0;

	mov	DWORD PTR _wc$[ebp+32], 0

; 1076 : 	wc.hIcon         = 0;

	mov	DWORD PTR _wc$[ebp+20], 0

; 1077 : 
; 1078 : 	// find the icon file in the filesystem
; 1079 : 	if( FS_FileExists( GI->iconpath, true ))

	push	1
	mov	edx, DWORD PTR _SI+768
	add	edx, 580				; 00000244H
	push	edx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	$LN4@VID_Create

; 1080 : 	{
; 1081 : 		if( FS_GetDiskPath( GI->iconpath, true ))

	push	1
	mov	eax, DWORD PTR _SI+768
	add	eax, 580				; 00000244H
	push	eax
	call	_FS_GetDiskPath
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@VID_Create

; 1082 : 		{
; 1083 : 			string	localPath;
; 1084 : 			Q_snprintf( localPath, sizeof( localPath ), "%s/%s", GI->gamedir, GI->iconpath );

	mov	ecx, DWORD PTR _SI+768
	add	ecx, 580				; 00000244H
	push	ecx
	mov	edx, DWORD PTR _SI+768
	add	edx, 128				; 00000080H
	push	edx
	push	OFFSET $SG144186
	push	256					; 00000100H
	lea	eax, DWORD PTR _localPath$1[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1085 : 			wc.hIcon = LoadImage( NULL, localPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE|LR_DEFAULTSIZE );

	push	80					; 00000050H
	push	0
	push	0
	push	1
	lea	ecx, DWORD PTR _localPath$1[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__LoadImageA@24
	mov	DWORD PTR _wc$[ebp+20], eax

; 1086 : 		}

	jmp	SHORT $LN4@VID_Create
$LN3@VID_Create:

; 1087 : 		else Con_Printf( "Extract %s from pak if you want to see it.\n", GI->iconpath );

	mov	edx, DWORD PTR _SI+768
	add	edx, 580				; 00000244H
	push	edx
	push	OFFSET $SG144187
	call	_Con_Printf
	add	esp, 8
$LN4@VID_Create:

; 1088 : 	}
; 1089 : 
; 1090 : 	// couldn't loaded for some reasons? use default
; 1091 : 	if( !wc.hIcon ) wc.hIcon = LoadIcon( host.hInst, MAKEINTRESOURCE( 101 ));

	cmp	DWORD PTR _wc$[ebp+20], 0
	jne	SHORT $LN5@VID_Create
	push	101					; 00000065H
	mov	eax, DWORD PTR _host
	push	eax
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax
$LN5@VID_Create:

; 1092 : 
; 1093 : 	if( !RegisterClass( &wc ))

	lea	ecx, DWORD PTR _wc$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	edx, ax
	test	edx, edx
	jne	SHORT $LN6@VID_Create

; 1094 : 	{ 
; 1095 : 		Con_Printf( S_ERROR "VID_CreateWindow: couldn't register window class %s\n" WINDOW_NAME );

	push	OFFSET $SG144190
	call	_Con_Printf
	add	esp, 4

; 1096 : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Create
$LN6@VID_Create:

; 1097 : 	}
; 1098 : 
; 1099 : 	if( fullscreen )

	cmp	DWORD PTR _fullscreen$[ebp], 0
	je	SHORT $LN7@VID_Create

; 1100 : 	{
; 1101 : 		stylebits = WS_POPUP|WS_VISIBLE;

	mov	DWORD PTR _stylebits$[ebp], -1879048192	; 90000000H

; 1102 : 		exstyle = WS_EX_TOPMOST;

	mov	DWORD PTR _exstyle$[ebp], 8
$LN7@VID_Create:

; 1103 : 	}
; 1104 : 
; 1105 : 	rect.left = 0;

	mov	DWORD PTR _rect$[ebp], 0

; 1106 : 	rect.top = 0;

	mov	DWORD PTR _rect$[ebp+4], 0

; 1107 : 	rect.right  = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _rect$[ebp+8], eax

; 1108 : 	rect.bottom = height;

	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _rect$[ebp+12], ecx

; 1109 : 
; 1110 : 	AdjustWindowRect( &rect, stylebits, FALSE );

	push	0
	mov	edx, DWORD PTR _stylebits$[ebp]
	push	edx
	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	call	DWORD PTR __imp__AdjustWindowRect@12

; 1111 : 	w = rect.right - rect.left;

	mov	ecx, DWORD PTR _rect$[ebp+8]
	sub	ecx, DWORD PTR _rect$[ebp]
	mov	DWORD PTR _w$[ebp], ecx

; 1112 : 	h = rect.bottom - rect.top;

	mov	edx, DWORD PTR _rect$[ebp+12]
	sub	edx, DWORD PTR _rect$[ebp+4]
	mov	DWORD PTR _h$[ebp], edx

; 1113 : 
; 1114 : #if 0
; 1115 : 	RECT WindowRect;
; 1116 : 	unsigned WindowHeight;
; 1117 : 	HWND WindowHandle;
; 1118 : 
; 1119 : 	WindowHandle = FindWindow("Shell_TrayWnd", NULL);
; 1120 : 	GetWindowRect(WindowHandle, &WindowRect);
; 1121 : 	WindowHeight = WindowRect.bottom - WindowRect.top;
; 1122 : #endif
; 1123 : 	if( !fullscreen )

	cmp	DWORD PTR _fullscreen$[ebp], 0
	jne	$LN13@VID_Create

; 1124 : 	{
; 1125 : 		x = window_xpos->value;

	mov	eax, DWORD PTR _window_xpos
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _x$[ebp], ecx

; 1126 : 		y = window_ypos->value;

	mov	edx, DWORD PTR _window_ypos
	cvttss2si eax, DWORD PTR [edx+12]
	mov	DWORD PTR _y$[ebp], eax

; 1127 : 
; 1128 : 		// adjust window coordinates if necessary 
; 1129 : 		// so that the window is completely on screen
; 1130 : 		if( x < 0 ) x = 0;

	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $LN9@VID_Create
	mov	DWORD PTR _x$[ebp], 0
$LN9@VID_Create:

; 1131 : 		if( y < 0 ) y = 0;

	cmp	DWORD PTR _y$[ebp], 0
	jge	SHORT $LN10@VID_Create
	mov	DWORD PTR _y$[ebp], 0
$LN10@VID_Create:

; 1132 : 
; 1133 : 		if( Cvar_VariableInteger( "vid_mode" ) != glConfig.prev_mode )

	push	OFFSET $SG144196
	call	_Cvar_VariableInteger
	add	esp, 4
	cmp	eax, DWORD PTR _glConfig+132
	je	SHORT $LN13@VID_Create

; 1134 : 		{
; 1135 : 			// adjust window in the screen size
; 1136 : 			if( x + w > glw_state.desktopWidth )

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	cmp	ecx, DWORD PTR _glw_state+12
	jle	SHORT $LN12@VID_Create

; 1137 : 				x = ( glw_state.desktopWidth - w );

	mov	edx, DWORD PTR _glw_state+12
	sub	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _x$[ebp], edx
$LN12@VID_Create:

; 1138 : 
; 1139 : 			if( y + h > glw_state.desktopHeight )

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cmp	eax, DWORD PTR _glw_state+16
	jle	SHORT $LN13@VID_Create

; 1140 : 				y = ( glw_state.desktopHeight - h );

	mov	ecx, DWORD PTR _glw_state+16
	sub	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR _y$[ebp], ecx
$LN13@VID_Create:

; 1141 : 		}
; 1142 : 	}
; 1143 : 
; 1144 : 	window = CreateWindowEx( exstyle, WINDOW_NAME, wndname, stylebits, x, y, w, h, NULL, NULL, host.hInst, NULL );

	push	0
	mov	edx, DWORD PTR _host
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stylebits$[ebp]
	push	ecx
	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	push	OFFSET $SG144199
	mov	edx, DWORD PTR _exstyle$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _window$[ebp], eax

; 1145 : 
; 1146 : 	if( host.hWnd != window )

	mov	eax, DWORD PTR _host+34332
	cmp	eax, DWORD PTR _window$[ebp]
	je	SHORT $LN14@VID_Create

; 1147 : 	{
; 1148 : 		// make sure what CreateWindowEx call the IN_WndProc
; 1149 : 		Con_Printf( S_WARN "VID_CreateWindow: bad hWnd for '%s'\n", wndname );

	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	push	OFFSET $SG144201
	call	_Con_Printf
	add	esp, 8
$LN14@VID_Create:

; 1150 : 	}
; 1151 : 
; 1152 : 	if( !host.hWnd ) 

	cmp	DWORD PTR _host+34332, 0
	jne	SHORT $LN15@VID_Create

; 1153 : 	{
; 1154 : 		// host.hWnd must be filled in IN_WndProc
; 1155 : 		Con_Printf( S_ERROR "VID_CreateWindow: couldn't create '%s'\n", wndname );

	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	push	OFFSET $SG144203
	call	_Con_Printf
	add	esp, 8

; 1156 : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Create
$LN15@VID_Create:

; 1157 : 	}
; 1158 : 
; 1159 : 	ShowWindow( host.hWnd, SW_SHOW );

	push	5
	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 1160 : 	UpdateWindow( host.hWnd );

	mov	edx, DWORD PTR _host+34332
	push	edx
	call	DWORD PTR __imp__UpdateWindow@4

; 1161 : 
; 1162 : 	// init all the gl stuff for the window
; 1163 : 	if( !GL_SetPixelformat( ))

	call	_GL_SetPixelformat
	test	eax, eax
	jne	SHORT $LN16@VID_Create

; 1164 : 	{
; 1165 : 		ShowWindow( host.hWnd, SW_HIDE );

	push	0
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1166 : 		DestroyWindow( host.hWnd );

	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4

; 1167 : 		host.hWnd = NULL;

	mov	DWORD PTR _host+34332, 0

; 1168 : 
; 1169 : 		UnregisterClass( WINDOW_NAME, host.hInst );

	mov	edx, DWORD PTR _host
	push	edx
	push	OFFSET $SG144205
	call	DWORD PTR __imp__UnregisterClassA@8

; 1170 : 		Con_Printf( S_ERROR "OpenGL driver not installed\n" );

	push	OFFSET $SG144206
	call	_Con_Printf
	add	esp, 4

; 1171 : 
; 1172 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@VID_Create
$LN16@VID_Create:

; 1173 : 	}
; 1174 : 
; 1175 : 	if( !glw_state.initialized )

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN17@VID_Create

; 1176 : 	{
; 1177 : 		if( !GL_CreateContext( ))

	call	_GL_CreateContext
	test	eax, eax
	jne	SHORT $LN19@VID_Create

; 1178 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@VID_Create
$LN19@VID_Create:

; 1179 : 
; 1180 : 		VID_StartupGamma();

	call	_VID_StartupGamma

; 1181 : 	}

	jmp	SHORT $LN20@VID_Create
$LN17@VID_Create:

; 1182 : 	else
; 1183 : 	{
; 1184 : 		if( !GL_UpdateContext( ))

	call	_GL_UpdateContext
	test	eax, eax
	jne	SHORT $LN20@VID_Create

; 1185 : 			return false;		

	xor	eax, eax
	jmp	SHORT $LN1@VID_Create
$LN20@VID_Create:

; 1186 : 	}
; 1187 : 
; 1188 : 	SetForegroundWindow( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 1189 : 	SetFocus( host.hWnd );

	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__SetFocus@4

; 1190 : 
; 1191 : 	return true;

	mov	eax, 1
$LN1@VID_Create:

; 1192 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CreateWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_R_DescribeVIDMode PROC

; 1033 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1034 : 	int	i;
; 1035 : 
; 1036 : 	for( i = 0; i < sizeof( vidmode ) / sizeof( vidmode[0] ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Describe
$LN2@R_Describe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Describe:
	cmp	DWORD PTR _i$[ebp], 26			; 0000001aH
	jae	SHORT $LN3@R_Describe

; 1037 : 	{
; 1038 : 		if( vidmode[i].width == width && vidmode[i].height == height )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _vidmode[ecx+4]
	cmp	edx, DWORD PTR _width$[ebp]
	jne	SHORT $LN5@R_Describe
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+8]
	cmp	ecx, DWORD PTR _height$[ebp]
	jne	SHORT $LN5@R_Describe

; 1039 : 		{
; 1040 : 			// found specified mode
; 1041 : 			Cvar_SetValue( "vid_mode", i );

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144147
	call	_Cvar_SetValue
	add	esp, 8

; 1042 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_Describe
$LN5@R_Describe:

; 1043 : 		}
; 1044 : 	}

	jmp	SHORT $LN2@R_Describe
$LN3@R_Describe:

; 1045 : 
; 1046 : 	return false;

	xor	eax, eax
$LN1@R_Describe:

; 1047 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_DescribeVIDMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv67 = -12						; size = 4
tv66 = -8						; size = 4
_mode$ = -4						; size = 4
_vid_mode$ = 8						; size = 4
_R_SaveVideoMode PROC

; 1014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1015 : 	int	mode = bound( 0, vid_mode, num_vidmodes ); // check range

	cmp	DWORD PTR _vid_mode$[ebp], 0
	jl	SHORT $LN5@R_SaveVide
	cmp	DWORD PTR _vid_mode$[ebp], 26		; 0000001aH
	jae	SHORT $LN3@R_SaveVide
	mov	eax, DWORD PTR _vid_mode$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@R_SaveVide
$LN3@R_SaveVide:
	mov	DWORD PTR tv66[ebp], 26			; 0000001aH
$LN4@R_SaveVide:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@R_SaveVide
$LN5@R_SaveVide:
	mov	DWORD PTR tv67[ebp], 0
$LN6@R_SaveVide:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _mode$[ebp], edx

; 1016 : 
; 1017 : 	glState.width = vidmode[mode].width;

	mov	eax, DWORD PTR _mode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+4]
	mov	DWORD PTR _glState, ecx

; 1018 : 	glState.height = vidmode[mode].height;

	mov	edx, DWORD PTR _mode$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _vidmode[edx+8]
	mov	DWORD PTR _glState+4, eax

; 1019 : 	glState.wideScreen = vidmode[mode].wideScreen;

	mov	ecx, DWORD PTR _mode$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _vidmode[ecx+12]
	mov	DWORD PTR _glState+12, edx

; 1020 : 	Cvar_FullSet( "width", va( "%i", glState.width ), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	mov	eax, DWORD PTR _glState
	push	eax
	push	OFFSET $SG144130
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG144131
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1021 : 	Cvar_FullSet( "height", va( "%i", glState.height ), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _glState+4
	push	ecx
	push	OFFSET $SG144132
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET $SG144133
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1022 : 	Cvar_SetValue( "vid_mode", mode ); // merge if it out of bounds

	cvtsi2ss xmm0, DWORD PTR _mode$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG144134
	call	_Cvar_SetValue
	add	esp, 8

; 1023 : 
; 1024 : 	Con_Reportf( "Set: %s [%dx%d]\n", vidmode[mode].desc, vidmode[mode].width, vidmode[mode].height );

	mov	edx, DWORD PTR _mode$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _vidmode[edx+8]
	push	eax
	mov	ecx, DWORD PTR _mode$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _vidmode[ecx+4]
	push	edx
	mov	eax, DWORD PTR _mode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax]
	push	ecx
	push	OFFSET $SG144135
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1025 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_SaveVideoMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_stencilBits$ = -64					; size = 4
_depthBits$ = -60					; size = 4
_alphaBits$ = -56					; size = 4
_colorBits$ = -52					; size = 4
_pixelFormat$ = -48					; size = 4
_PFD$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_GL_SetPixelformat PROC

; 929  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 930  : 	PIXELFORMATDESCRIPTOR	PFD;
; 931  : 	int			colorBits = 32;

	mov	DWORD PTR _colorBits$[ebp], 32		; 00000020H

; 932  : 	int			alphaBits = 8;

	mov	DWORD PTR _alphaBits$[ebp], 8

; 933  : 	int			stencilBits = 8;

	mov	DWORD PTR _stencilBits$[ebp], 8

; 934  : 	int			pixelFormat = 0;

	mov	DWORD PTR _pixelFormat$[ebp], 0

; 935  : 	int			depthBits = 24;

	mov	DWORD PTR _depthBits$[ebp], 24		; 00000018H

; 936  : 
; 937  : 	if(( glw_state.hDC = GetDC( host.hWnd )) == NULL )

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _glw_state, eax
	cmp	DWORD PTR _glw_state, 0
	jne	SHORT $LN2@GL_SetPixe

; 938  : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_SetPixe
$LN2@GL_SetPixe:

; 939  : 
; 940  : 	if( glw_state.desktopBitsPixel < 32 )

	cmp	DWORD PTR _glw_state+8, 32		; 00000020H
	jge	SHORT $LN3@GL_SetPixe

; 941  : 	{
; 942  : 		// clear alphabits in case we in 16-bit mode
; 943  : 		colorBits = glw_state.desktopBitsPixel;

	mov	ecx, DWORD PTR _glw_state+8
	mov	DWORD PTR _colorBits$[ebp], ecx

; 944  : 		alphaBits = 0;

	mov	DWORD PTR _alphaBits$[ebp], 0

; 945  : 	}

	jmp	SHORT $LN4@GL_SetPixe
$LN3@GL_SetPixe:

; 946  : 	else
; 947  : 	{
; 948  : 		// no reason to trying enable MSAA on a highcolor
; 949  : 		VID_CreateFakeWindow();

	call	_VID_CreateFakeWindow
$LN4@GL_SetPixe:

; 950  : 	}
; 951  : 
; 952  : 	// choose a pixel format
; 953  : 	pixelFormat = VID_ChoosePFD( &PFD, colorBits, alphaBits, depthBits, stencilBits );

	mov	edx, DWORD PTR _stencilBits$[ebp]
	push	edx
	mov	eax, DWORD PTR _depthBits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _alphaBits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _colorBits$[ebp]
	push	edx
	lea	eax, DWORD PTR _PFD$[ebp]
	push	eax
	call	_VID_ChoosePFD
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pixelFormat$[ebp], eax

; 954  : 
; 955  : 	if( !pixelFormat )

	cmp	DWORD PTR _pixelFormat$[ebp], 0
	jne	SHORT $LN5@GL_SetPixe

; 956  : 	{
; 957  : 		// try again with default color/depth/stencil
; 958  : 		pixelFormat = VID_ChoosePFD( &PFD, colorBits, 0, depthBits, 0 );

	push	0
	mov	ecx, DWORD PTR _depthBits$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _colorBits$[ebp]
	push	edx
	lea	eax, DWORD PTR _PFD$[ebp]
	push	eax
	call	_VID_ChoosePFD
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pixelFormat$[ebp], eax

; 959  : 
; 960  : 		if( !pixelFormat )

	cmp	DWORD PTR _pixelFormat$[ebp], 0
	jne	SHORT $LN5@GL_SetPixe

; 961  : 		{
; 962  : 			Con_Printf( S_ERROR "GL_SetPixelformat: failed to find an appropriate PIXELFORMAT\n" );

	push	OFFSET $SG144112
	call	_Con_Printf
	add	esp, 4

; 963  : 			return false;

	xor	eax, eax
	jmp	$LN1@GL_SetPixe
$LN5@GL_SetPixe:

; 964  : 		}
; 965  : 	}
; 966  : 
; 967  : 	// set the pixel format
; 968  : 	if( !SetPixelFormat( glw_state.hDC, pixelFormat, &PFD ))

	lea	ecx, DWORD PTR _PFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pixelFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR __imp__SetPixelFormat@12
	test	eax, eax
	jne	SHORT $LN7@GL_SetPixe

; 969  : 	{
; 970  : 		Con_Printf( S_ERROR "GL_SetPixelformat: failed\n" );

	push	OFFSET $SG144114
	call	_Con_Printf
	add	esp, 4

; 971  : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_SetPixe
$LN7@GL_SetPixe:

; 972  : 	}
; 973  : 
; 974  : 	DescribePixelFormat( glw_state.hDC, pixelFormat, sizeof( PIXELFORMATDESCRIPTOR ), &PFD );

	lea	ecx, DWORD PTR _PFD$[ebp]
	push	ecx
	push	40					; 00000028H
	mov	edx, DWORD PTR _pixelFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR __imp__DescribePixelFormat@16

; 975  : 
; 976  : 	if( PFD.dwFlags & PFD_GENERIC_FORMAT )

	mov	ecx, DWORD PTR _PFD$[ebp+4]
	and	ecx, 64					; 00000040H
	je	SHORT $LN8@GL_SetPixe

; 977  : 	{
; 978  : 		if( PFD.dwFlags & PFD_GENERIC_ACCELERATED )

	mov	edx, DWORD PTR _PFD$[ebp+4]
	and	edx, 4096				; 00001000H
	je	SHORT $LN10@GL_SetPixe

; 979  : 		{
; 980  : 			Con_Reportf( "VID_ChoosePFD: using Generic MCD acceleration\n" );

	push	OFFSET $SG144119
	call	_Con_Reportf
	add	esp, 4

; 981  : 		}

	jmp	SHORT $LN11@GL_SetPixe
$LN10@GL_SetPixe:

; 982  : 		else
; 983  : 		{
; 984  : 			Con_Printf( S_ERROR "GL_SetPixelformat: no hardware acceleration found\n" );

	push	OFFSET $SG144120
	call	_Con_Printf
	add	esp, 4

; 985  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@GL_SetPixe
$LN11@GL_SetPixe:

; 986  : 		}
; 987  : 	}

	jmp	SHORT $LN9@GL_SetPixe
$LN8@GL_SetPixe:

; 988  : 	else
; 989  : 	{
; 990  : 		Con_Reportf( "VID_ChoosePFD: using hardware acceleration\n" );

	push	OFFSET $SG144121
	call	_Con_Reportf
	add	esp, 4
$LN9@GL_SetPixe:

; 991  : 	}
; 992  : 
; 993  : 	glConfig.color_bits = PFD.cColorBits;

	movzx	eax, BYTE PTR _PFD$[ebp+9]
	mov	DWORD PTR _glConfig+100, eax

; 994  : 	glConfig.alpha_bits = PFD.cAlphaBits;

	movzx	ecx, BYTE PTR _PFD$[ebp+16]
	mov	DWORD PTR _glConfig+104, ecx

; 995  : 	glConfig.depth_bits = PFD.cDepthBits;

	movzx	edx, BYTE PTR _PFD$[ebp+23]
	mov	DWORD PTR _glConfig+108, edx

; 996  : 	glConfig.stencil_bits = PFD.cStencilBits;

	movzx	eax, BYTE PTR _PFD$[ebp+24]
	mov	DWORD PTR _glConfig+112, eax

; 997  : 
; 998  : 	if( PFD.cStencilBits != 0 )

	movzx	ecx, BYTE PTR _PFD$[ebp+24]
	test	ecx, ecx
	je	SHORT $LN12@GL_SetPixe

; 999  : 		glState.stencilEnabled = true;

	mov	DWORD PTR _glState+572, 1
	jmp	SHORT $LN13@GL_SetPixe
$LN12@GL_SetPixe:

; 1000 : 	else glState.stencilEnabled = false;

	mov	DWORD PTR _glState+572, 0
$LN13@GL_SetPixe:

; 1001 : 
; 1002 : 	// print out PFD specifics 
; 1003 : 	Con_Reportf( "PixelFormat: color: %d-bit, Z-Buffer: %d-bit, stencil: %d-bit\n", PFD.cColorBits, PFD.cDepthBits, PFD.cStencilBits );

	movzx	edx, BYTE PTR _PFD$[ebp+24]
	push	edx
	movzx	eax, BYTE PTR _PFD$[ebp+23]
	push	eax
	movzx	ecx, BYTE PTR _PFD$[ebp+9]
	push	ecx
	push	OFFSET $SG144124
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1004 : 
; 1005 : 	return true;

	mov	eax, 1
$LN1@GL_SetPixe:

; 1006 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetPixelformat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_wndClass$ = -100					; size = 48
_pixelFormat$ = -52					; size = 4
tv67 = -48						; size = 4
_pfd$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_VID_CreateFakeWindow PROC

; 838  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 839  : 	WNDCLASSEX		wndClass;
; 840  : 	PIXELFORMATDESCRIPTOR	pfd;
; 841  : 	int			pixelFormat;
; 842  : 
; 843  : 	// MSAA disabled
; 844  : 	if( !CVAR_TO_BOOL( gl_wgl_msaa_samples ))

	cmp	DWORD PTR _gl_wgl_msaa_samples, 0
	je	SHORT $LN11@VID_Create
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@VID_Create
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN12@VID_Create
$LN11@VID_Create:
	mov	DWORD PTR tv67[ebp], 0
$LN12@VID_Create:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN2@VID_Create

; 845  : 		return;

	jmp	$LN1@VID_Create
$LN2@VID_Create:

; 846  : 
; 847  : 	memset( &wndClass, 0, sizeof( WNDCLASSEX ));

	push	48					; 00000030H
	push	0
	lea	ecx, DWORD PTR _wndClass$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 848  : 	hGLRCFake = NULL;

	mov	DWORD PTR _hGLRCFake, 0

; 849  : 	hWndFake = NULL;

	mov	DWORD PTR _hWndFake, 0

; 850  : 	hDCFake = NULL;

	mov	DWORD PTR _hDCFake, 0

; 851  : 
; 852  : 	// register the window class
; 853  : 	wndClass.cbSize = sizeof( WNDCLASSEX );

	mov	DWORD PTR _wndClass$[ebp], 48		; 00000030H

; 854  : 	wndClass.lpfnWndProc = DefWindowProc;

	mov	edx, DWORD PTR __imp__DefWindowProcA@16
	mov	DWORD PTR _wndClass$[ebp+8], edx

; 855  : 	wndClass.hInstance = host.hInst;

	mov	eax, DWORD PTR _host
	mov	DWORD PTR _wndClass$[ebp+20], eax

; 856  : 	wndClass.lpszClassName = "TestWindow";

	mov	DWORD PTR _wndClass$[ebp+40], OFFSET $SG144083

; 857  : 
; 858  : 	if( !RegisterClassEx( &wndClass ))

	lea	ecx, DWORD PTR _wndClass$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegisterClassExA@4
	movzx	edx, ax
	test	edx, edx
	jne	SHORT $LN3@VID_Create

; 859  : 		return;

	jmp	$LN1@VID_Create
$LN3@VID_Create:

; 860  : 
; 861  : 	// Create the fake window
; 862  : 	if(( hWndFake = CreateWindowEx( 0, "TestWindow", "Xash3D", 0, 0, 0, 100, 100, NULL, NULL, wndClass.hInstance, NULL )) == NULL )

	push	0
	mov	eax, DWORD PTR _wndClass$[ebp+20]
	push	eax
	push	0
	push	0
	push	100					; 00000064H
	push	100					; 00000064H
	push	0
	push	0
	push	0
	push	OFFSET $SG144086
	push	OFFSET $SG144087
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hWndFake, eax
	cmp	DWORD PTR _hWndFake, 0
	jne	SHORT $LN4@VID_Create

; 863  : 	{
; 864  : 		UnregisterClass( "TestWindow", wndClass.hInstance );

	mov	ecx, DWORD PTR _wndClass$[ebp+20]
	push	ecx
	push	OFFSET $SG144088
	call	DWORD PTR __imp__UnregisterClassA@8

; 865  : 		return;

	jmp	$LN1@VID_Create
$LN4@VID_Create:

; 866  : 	}
; 867  : 
; 868  : 	// Get a DC for the fake window
; 869  : 	if(( hDCFake = GetDC( hWndFake )) == NULL )

	mov	edx, DWORD PTR _hWndFake
	push	edx
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDCFake, eax
	cmp	DWORD PTR _hDCFake, 0
	jne	SHORT $LN5@VID_Create

; 870  : 	{
; 871  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 872  : 		return;

	jmp	$LN1@VID_Create
$LN5@VID_Create:

; 873  : 	}
; 874  : 
; 875  : 	// Choose a pixel format
; 876  : 	memset( &pfd, 0, sizeof( PIXELFORMATDESCRIPTOR ));

	push	40					; 00000028H
	push	0
	lea	eax, DWORD PTR _pfd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 877  : 
; 878  : 	pfd.nSize = sizeof( PIXELFORMATDESCRIPTOR );

	mov	ecx, 40					; 00000028H
	mov	WORD PTR _pfd$[ebp], cx

; 879  : 	pfd.nVersion = 1;

	mov	edx, 1
	mov	WORD PTR _pfd$[ebp+2], dx

; 880  : 	pfd.dwFlags = PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER;

	mov	DWORD PTR _pfd$[ebp+4], 37		; 00000025H

; 881  : 	pfd.iPixelType = PFD_TYPE_RGBA;

	mov	BYTE PTR _pfd$[ebp+8], 0

; 882  : 	pfd.iLayerType = PFD_MAIN_PLANE;

	mov	BYTE PTR _pfd$[ebp+26], 0

; 883  : 	pfd.cColorBits = 32;

	mov	BYTE PTR _pfd$[ebp+9], 32		; 00000020H

; 884  : 	pfd.cAlphaBits = 8;

	mov	BYTE PTR _pfd$[ebp+16], 8

; 885  : 	pfd.cDepthBits = 24;

	mov	BYTE PTR _pfd$[ebp+23], 24		; 00000018H

; 886  : 	pfd.cStencilBits = 8;

	mov	BYTE PTR _pfd$[ebp+24], 8

; 887  : 
; 888  : 	if(( pixelFormat = ChoosePixelFormat( hDCFake, &pfd )) == 0 )

	lea	eax, DWORD PTR _pfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hDCFake
	push	ecx
	call	DWORD PTR __imp__ChoosePixelFormat@8
	mov	DWORD PTR _pixelFormat$[ebp], eax
	cmp	DWORD PTR _pixelFormat$[ebp], 0
	jne	SHORT $LN6@VID_Create

; 889  : 	{
; 890  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 891  : 		return;

	jmp	$LN1@VID_Create
$LN6@VID_Create:

; 892  : 	}
; 893  : 
; 894  : 	// Set the pixel format
; 895  : 	if( !SetPixelFormat( hDCFake, pixelFormat, &pfd ))

	lea	edx, DWORD PTR _pfd$[ebp]
	push	edx
	mov	eax, DWORD PTR _pixelFormat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hDCFake
	push	ecx
	call	DWORD PTR __imp__SetPixelFormat@12
	test	eax, eax
	jne	SHORT $LN7@VID_Create

; 896  : 	{
; 897  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 898  : 		return;

	jmp	SHORT $LN1@VID_Create
$LN7@VID_Create:

; 899  : 	}
; 900  : 
; 901  : 	// Create the fake GL context
; 902  : 	if(( hGLRCFake = pwglCreateContext( hDCFake )) == NULL )

	mov	edx, DWORD PTR _hDCFake
	push	edx
	call	DWORD PTR _pwglCreateContext
	mov	DWORD PTR _hGLRCFake, eax
	cmp	DWORD PTR _hGLRCFake, 0
	jne	SHORT $LN8@VID_Create

; 903  : 	{
; 904  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 905  : 		return;

	jmp	SHORT $LN1@VID_Create
$LN8@VID_Create:

; 906  : 	}
; 907  : 
; 908  : 	// Make the fake GL context current
; 909  : 	if( !pwglMakeCurrent( hDCFake, hGLRCFake ))

	mov	eax, DWORD PTR _hGLRCFake
	push	eax
	mov	ecx, DWORD PTR _hDCFake
	push	ecx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN9@VID_Create

; 910  : 	{
; 911  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 912  : 		return;

	jmp	SHORT $LN1@VID_Create
$LN9@VID_Create:

; 913  : 	}
; 914  : 
; 915  : 	// We only need these function pointers if available
; 916  : 	pwglGetPixelFormatAttribiv = GL_GetProcAddress( "wglGetPixelFormatAttribivARB" );

	push	OFFSET $SG144094
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR _pwglGetPixelFormatAttribiv, eax

; 917  : 	pwglChoosePixelFormat = GL_GetProcAddress( "wglChoosePixelFormatARB" );

	push	OFFSET $SG144095
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR _pwglChoosePixelFormat, eax

; 918  : 
; 919  : 	// destroy now it's no longer needed
; 920  : 	VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow
$LN1@VID_Create:

; 921  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CreateFakeWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_VID_DestroyFakeWindow PROC

; 810  : {

	push	ebp
	mov	ebp, esp

; 811  : 	if( hGLRCFake )

	cmp	DWORD PTR _hGLRCFake, 0
	je	SHORT $LN2@VID_Destro

; 812  : 	{
; 813  : 		pwglMakeCurrent( NULL, NULL );

	push	0
	push	0
	call	DWORD PTR _pwglMakeCurrent

; 814  : 		pwglDeleteContext( hGLRCFake );

	mov	eax, DWORD PTR _hGLRCFake
	push	eax
	call	DWORD PTR _pwglDeleteContext

; 815  : 		hGLRCFake = NULL;

	mov	DWORD PTR _hGLRCFake, 0
$LN2@VID_Destro:

; 816  : 	}
; 817  : 
; 818  : 	if( hDCFake )

	cmp	DWORD PTR _hDCFake, 0
	je	SHORT $LN3@VID_Destro

; 819  : 	{
; 820  : 		ReleaseDC( hWndFake, hDCFake );

	mov	ecx, DWORD PTR _hDCFake
	push	ecx
	mov	edx, DWORD PTR _hWndFake
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8

; 821  : 		hDCFake = NULL;

	mov	DWORD PTR _hDCFake, 0
$LN3@VID_Destro:

; 822  : 	}
; 823  : 
; 824  : 	if( hWndFake )

	cmp	DWORD PTR _hWndFake, 0
	je	SHORT $LN1@VID_Destro

; 825  : 	{
; 826  : 		DestroyWindow( hWndFake );

	mov	eax, DWORD PTR _hWndFake
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 827  : 		UnregisterClass( "TestWindow", host.hInst );

	mov	ecx, DWORD PTR _host
	push	ecx
	push	OFFSET $SG144062
	call	DWORD PTR __imp__UnregisterClassA@8

; 828  : 		hWndFake = NULL;

	mov	DWORD PTR _hWndFake, 0
$LN1@VID_Destro:

; 829  : 	}
; 830  : }

	pop	ebp
	ret	0
_VID_DestroyFakeWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_VID_StartupGamma PROC

; 772  : {

	push	ebp
	mov	ebp, esp

; 773  : 	BuildGammaTable( vid_gamma->value, vid_brightness->value );

	mov	eax, DWORD PTR _vid_brightness
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _vid_gamma
	push	ecx
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp], xmm0
	call	_BuildGammaTable
	add	esp, 8

; 774  : 	Con_Reportf( "VID_StartupGamma: gamma %g brightness %g\n", vid_gamma->value, vid_brightness->value );

	mov	edx, DWORD PTR _vid_brightness
	cvtss2sd xmm0, DWORD PTR [edx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _vid_gamma
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG144043
	call	_Con_Reportf
	add	esp, 20					; 00000014H

; 775  : 	ClearBits( vid_brightness->flags, FCVAR_CHANGED );

	mov	ecx, DWORD PTR _vid_brightness
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -8193				; ffffdfffH
	mov	eax, DWORD PTR _vid_brightness
	mov	DWORD PTR [eax+8], edx

; 776  : 	ClearBits( vid_gamma->flags, FCVAR_CHANGED );

	mov	ecx, DWORD PTR _vid_gamma
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -8193				; ffffdfffH
	mov	eax, DWORD PTR _vid_gamma
	mov	DWORD PTR [eax+8], edx

; 777  : }

	pop	ebp
	ret	0
_VID_StartupGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_numPixelFormats$1 = -116				; size = 4
tv150 = -112						; size = 4
tv149 = -108						; size = 4
_pixelFormat$2 = -104					; size = 4
_attribs$3 = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_pfd$ = 8						; size = 4
_colorBits$ = 12					; size = 4
_alphaBits$ = 16					; size = 4
_depthBits$ = 20					; size = 4
_stencilBits$ = 24					; size = 4
_VID_ChoosePFD PROC

; 684  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 685  : 	if( pwglChoosePixelFormat != NULL )

	cmp	DWORD PTR _pwglChoosePixelFormat, 0
	je	$LN3@VID_Choose

; 686  : 	{
; 687  : 		UINT	numPixelFormats;
; 688  : 		int	pixelFormat = 0;

	mov	DWORD PTR _pixelFormat$2[ebp], 0

; 689  : 		int	attribs[24];
; 690  : 
; 691  : 		attribs[0] = WGL_ACCELERATION_ARB;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _attribs$3[ebp+ecx], 8195	; 00002003H

; 692  : 		attribs[1] = WGL_FULL_ACCELERATION_ARB;

	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _attribs$3[ebp+edx], 8231	; 00002027H

; 693  : 		attribs[2] = WGL_DRAW_TO_WINDOW_ARB;

	mov	eax, 4
	shl	eax, 1
	mov	DWORD PTR _attribs$3[ebp+eax], 8193	; 00002001H

; 694  : 		attribs[3] = TRUE;

	mov	ecx, 4
	imul	edx, ecx, 3
	mov	DWORD PTR _attribs$3[ebp+edx], 1

; 695  : 		attribs[4] = WGL_SUPPORT_OPENGL_ARB;

	mov	eax, 4
	shl	eax, 2
	mov	DWORD PTR _attribs$3[ebp+eax], 8208	; 00002010H

; 696  : 		attribs[5] = TRUE;

	mov	ecx, 4
	imul	edx, ecx, 5
	mov	DWORD PTR _attribs$3[ebp+edx], 1

; 697  : 		attribs[6] = WGL_DOUBLE_BUFFER_ARB;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	DWORD PTR _attribs$3[ebp+ecx], 8209	; 00002011H

; 698  : 		attribs[7] = TRUE;

	mov	edx, 4
	imul	eax, edx, 7
	mov	DWORD PTR _attribs$3[ebp+eax], 1

; 699  : 		attribs[8] = WGL_PIXEL_TYPE_ARB;

	mov	ecx, 4
	shl	ecx, 3
	mov	DWORD PTR _attribs$3[ebp+ecx], 8211	; 00002013H

; 700  : 		attribs[9] = WGL_TYPE_RGBA_ARB;

	mov	edx, 4
	imul	eax, edx, 9
	mov	DWORD PTR _attribs$3[ebp+eax], 8235	; 0000202bH

; 701  : 		attribs[10] = WGL_COLOR_BITS_ARB;

	mov	ecx, 4
	imul	edx, ecx, 10
	mov	DWORD PTR _attribs$3[ebp+edx], 8212	; 00002014H

; 702  : 		attribs[11] = colorBits;

	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _colorBits$[ebp]
	mov	DWORD PTR _attribs$3[ebp+ecx], edx

; 703  : 		attribs[12] = WGL_ALPHA_BITS_ARB;

	mov	eax, 4
	imul	ecx, eax, 12
	mov	DWORD PTR _attribs$3[ebp+ecx], 8219	; 0000201bH

; 704  : 		attribs[13] = alphaBits;

	mov	edx, 4
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _alphaBits$[ebp]
	mov	DWORD PTR _attribs$3[ebp+eax], ecx

; 705  : 		attribs[14] = WGL_DEPTH_BITS_ARB;

	mov	edx, 4
	imul	eax, edx, 14
	mov	DWORD PTR _attribs$3[ebp+eax], 8226	; 00002022H

; 706  : 		attribs[15] = depthBits;

	mov	ecx, 4
	imul	edx, ecx, 15
	mov	eax, DWORD PTR _depthBits$[ebp]
	mov	DWORD PTR _attribs$3[ebp+edx], eax

; 707  : 		attribs[16] = WGL_STENCIL_BITS_ARB;

	mov	ecx, 4
	shl	ecx, 4
	mov	DWORD PTR _attribs$3[ebp+ecx], 8227	; 00002023H

; 708  : 		attribs[17] = stencilBits;

	mov	edx, 4
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _stencilBits$[ebp]
	mov	DWORD PTR _attribs$3[ebp+eax], ecx

; 709  : 		attribs[18] = WGL_SAMPLE_BUFFERS_ARB;

	mov	edx, 4
	imul	eax, edx, 18
	mov	DWORD PTR _attribs$3[ebp+eax], 8257	; 00002041H

; 710  : 		attribs[19] = TRUE;

	mov	ecx, 4
	imul	edx, ecx, 19
	mov	DWORD PTR _attribs$3[ebp+edx], 1

; 711  : 		attribs[20] = WGL_SAMPLES_ARB;

	mov	eax, 4
	imul	ecx, eax, 20
	mov	DWORD PTR _attribs$3[ebp+ecx], 8258	; 00002042H

; 712  : 		attribs[21] = bound( 1, (int)gl_wgl_msaa_samples->value, 16 );

	mov	edx, DWORD PTR _gl_wgl_msaa_samples
	cvttss2si eax, DWORD PTR [edx+12]
	cmp	eax, 1
	jl	SHORT $LN8@VID_Choose
	mov	ecx, DWORD PTR _gl_wgl_msaa_samples
	cvttss2si edx, DWORD PTR [ecx+12]
	cmp	edx, 16					; 00000010H
	jge	SHORT $LN6@VID_Choose
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv149[ebp], ecx
	jmp	SHORT $LN7@VID_Choose
$LN6@VID_Choose:
	mov	DWORD PTR tv149[ebp], 16		; 00000010H
$LN7@VID_Choose:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv150[ebp], edx
	jmp	SHORT $LN9@VID_Choose
$LN8@VID_Choose:
	mov	DWORD PTR tv150[ebp], 1
$LN9@VID_Choose:
	mov	eax, 4
	imul	ecx, eax, 21
	mov	edx, DWORD PTR tv150[ebp]
	mov	DWORD PTR _attribs$3[ebp+ecx], edx

; 713  : 		attribs[22] = 0;

	mov	eax, 4
	imul	ecx, eax, 22
	mov	DWORD PTR _attribs$3[ebp+ecx], 0

; 714  : 		attribs[23] = 0;

	mov	edx, 4
	imul	eax, edx, 23
	mov	DWORD PTR _attribs$3[ebp+eax], 0

; 715  : 
; 716  : 		pwglChoosePixelFormat( glw_state.hDC, attribs, NULL, 1, &pixelFormat, &numPixelFormats );

	lea	ecx, DWORD PTR _numPixelFormats$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _pixelFormat$2[ebp]
	push	edx
	push	1
	push	0
	lea	eax, DWORD PTR _attribs$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR _pwglChoosePixelFormat

; 717  : 
; 718  : 		if( pixelFormat )

	cmp	DWORD PTR _pixelFormat$2[ebp], 0
	je	SHORT $LN3@VID_Choose

; 719  : 		{
; 720  : 			attribs[0] = WGL_SAMPLES_ARB;

	mov	edx, 4
	imul	eax, edx, 0
	mov	DWORD PTR _attribs$3[ebp+eax], 8258	; 00002042H

; 721  : 			pwglGetPixelFormatAttribiv( glw_state.hDC, pixelFormat, 0, 1, attribs, &glConfig.max_multisamples );

	push	OFFSET _glConfig+96
	lea	ecx, DWORD PTR _attribs$3[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _pixelFormat$2[ebp]
	push	edx
	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR _pwglGetPixelFormatAttribiv

; 722  : 			if( glConfig.max_multisamples <= 1 ) Con_DPrintf( S_WARN "MSAA is not allowed\n" );

	cmp	DWORD PTR _glConfig+96, 1
	jg	SHORT $LN4@VID_Choose
	push	OFFSET $SG144039
	call	_Con_DPrintf
	add	esp, 4
$LN4@VID_Choose:

; 723  : 
; 724  : 			return pixelFormat;

	mov	eax, DWORD PTR _pixelFormat$2[ebp]
	jmp	$LN1@VID_Choose
$LN3@VID_Choose:

; 725  : 		}
; 726  : 	}
; 727  : 
; 728  : 	// fallback: fill out the PFD
; 729  : 	pfd->nSize = sizeof (PIXELFORMATDESCRIPTOR);

	mov	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _pfd$[ebp]
	mov	WORD PTR [edx], cx

; 730  : 	pfd->nVersion = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	WORD PTR [ecx+2], ax

; 731  : 	pfd->dwFlags = PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [edx+4], 37			; 00000025H

; 732  : 	pfd->iPixelType = PFD_TYPE_RGBA;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+8], 0

; 733  : 
; 734  : 	pfd->cColorBits = colorBits;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	dl, BYTE PTR _colorBits$[ebp]
	mov	BYTE PTR [ecx+9], dl

; 735  : 	pfd->cRedBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+10], 0

; 736  : 	pfd->cRedShift = 0;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [ecx+11], 0

; 737  : 	pfd->cGreenBits = 0;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [edx+12], 0

; 738  : 	pfd->cGreenShift = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+13], 0

; 739  : 	pfd->cBlueBits = 0;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [ecx+14], 0

; 740  : 	pfd->cBlueShift = 0;	// wow! Blue Shift %)

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [edx+15], 0

; 741  : 
; 742  : 	pfd->cAlphaBits = alphaBits;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	cl, BYTE PTR _alphaBits$[ebp]
	mov	BYTE PTR [eax+16], cl

; 743  : 	pfd->cAlphaShift = 0;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [edx+17], 0

; 744  : 
; 745  : 	pfd->cAccumBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+18], 0

; 746  : 	pfd->cAccumRedBits = 0;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [ecx+19], 0

; 747  : 	pfd->cAccumGreenBits = 0;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [edx+20], 0

; 748  : 	pfd->cAccumBlueBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+21], 0

; 749  : 	pfd->cAccumAlphaBits= 0;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [ecx+22], 0

; 750  : 
; 751  : 	pfd->cDepthBits = depthBits;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	al, BYTE PTR _depthBits$[ebp]
	mov	BYTE PTR [edx+23], al

; 752  : 	pfd->cStencilBits = stencilBits;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	dl, BYTE PTR _stencilBits$[ebp]
	mov	BYTE PTR [ecx+24], dl

; 753  : 
; 754  : 	pfd->cAuxBuffers = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+25], 0

; 755  : 	pfd->iLayerType = PFD_MAIN_PLANE;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [ecx+26], 0

; 756  : 	pfd->bReserved = 0;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [edx+27], 0

; 757  : 
; 758  : 	pfd->dwLayerMask = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [eax+28], 0

; 759  : 	pfd->dwVisibleMask = 0;

	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 760  : 	pfd->dwDamageMask = 0;

	mov	edx, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [edx+36], 0

; 761  : 
; 762  : 	// count PFDs
; 763  : 	return ChoosePixelFormat( glw_state.hDC, pfd );

	mov	eax, DWORD PTR _pfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR __imp__ChoosePixelFormat@8
$LN1@VID_Choose:

; 764  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_ChoosePFD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_GL_UpdateContext PROC

; 643  : {

	push	ebp
	mov	ebp, esp

; 644  : 	if(!( pwglMakeCurrent( glw_state.hDC, glw_state.hGLRC )))

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN2@GL_UpdateC

; 645  : 		return GL_DeleteContext();

	call	_GL_DeleteContext
	jmp	SHORT $LN1@GL_UpdateC
$LN2@GL_UpdateC:

; 646  : 
; 647  : 	return true;

	mov	eax, 1
$LN1@GL_UpdateC:

; 648  : }

	pop	ebp
	ret	0
_GL_UpdateContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_profile_mask$ = -52					; size = 4
_arb_flags$ = -48					; size = 4
_hBaseRC$ = -44						; size = 4
_attribs$1 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_GL_CreateContext PROC

; 576  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 577  : 	HGLRC	hBaseRC;
; 578  : 	int	profile_mask;
; 579  : 	int	arb_flags;
; 580  : 
; 581  : 	glw_state.extended = false;

	mov	DWORD PTR _glw_state+24, 0

; 582  : 
; 583  : 	if(!( glw_state.hGLRC = pwglCreateContext( glw_state.hDC )))

	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR _pwglCreateContext
	mov	DWORD PTR _glw_state+4, eax
	cmp	DWORD PTR _glw_state+4, 0
	jne	SHORT $LN2@GL_CreateC

; 584  : 		return GL_DeleteContext();

	call	_GL_DeleteContext
	jmp	$LN1@GL_CreateC
$LN2@GL_CreateC:

; 585  : 
; 586  : 	if(!( pwglMakeCurrent( glw_state.hDC, glw_state.hGLRC )))

	mov	ecx, DWORD PTR _glw_state+4
	push	ecx
	mov	edx, DWORD PTR _glw_state
	push	edx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN3@GL_CreateC

; 587  : 		return GL_DeleteContext();

	call	_GL_DeleteContext
	jmp	$LN1@GL_CreateC
$LN3@GL_CreateC:

; 588  : 
; 589  : 	if( !context_flags ) // debug bit kill the perfomance

	cmp	DWORD PTR _context_flags, 0
	jne	SHORT $LN4@GL_CreateC

; 590  : 		return true;

	mov	eax, 1
	jmp	$LN1@GL_CreateC
$LN4@GL_CreateC:

; 591  : 
; 592  : 	pwglCreateContextAttribsARB = GL_GetProcAddress( "wglCreateContextAttribsARB" );

	push	OFFSET $SG143994
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR _pwglCreateContextAttribsARB, eax

; 593  : 
; 594  : 	profile_mask = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;

	mov	DWORD PTR _profile_mask$[ebp], 2

; 595  : 
; 596  : 	if( FBitSet( context_flags, FCONTEXT_DEBUG_ARB ))

	mov	eax, DWORD PTR _context_flags
	and	eax, 1
	je	SHORT $LN5@GL_CreateC

; 597  : 		arb_flags = WGL_CONTEXT_DEBUG_BIT_ARB;

	mov	DWORD PTR _arb_flags$[ebp], 1
	jmp	SHORT $LN6@GL_CreateC
$LN5@GL_CreateC:

; 598  : 	else arb_flags = 0;

	mov	DWORD PTR _arb_flags$[ebp], 0
$LN6@GL_CreateC:

; 599  : 
; 600  : 	if( pwglCreateContextAttribsARB != NULL )

	cmp	DWORD PTR _pwglCreateContextAttribsARB, 0
	je	$LN7@GL_CreateC

; 601  : 	{
; 602  : 		int attribs[] =

	mov	DWORD PTR _attribs$1[ebp], 8337		; 00002091H
	mov	DWORD PTR _attribs$1[ebp+4], 2
	mov	DWORD PTR _attribs$1[ebp+8], 8338	; 00002092H
	mov	DWORD PTR _attribs$1[ebp+12], 0
	mov	DWORD PTR _attribs$1[ebp+16], 8340	; 00002094H
	mov	ecx, DWORD PTR _arb_flags$[ebp]
	mov	DWORD PTR _attribs$1[ebp+20], ecx
	mov	DWORD PTR _attribs$1[ebp+24], 37158	; 00009126H
	mov	edx, DWORD PTR _profile_mask$[ebp]
	mov	DWORD PTR _attribs$1[ebp+28], edx
	mov	DWORD PTR _attribs$1[ebp+32], 0

; 603  : 		{
; 604  : 		WGL_CONTEXT_MAJOR_VERSION_ARB, 2,
; 605  : 		WGL_CONTEXT_MINOR_VERSION_ARB, 0,
; 606  : 		WGL_CONTEXT_FLAGS_ARB, arb_flags,         
; 607  : 		WGL_CONTEXT_PROFILE_MASK_ARB, profile_mask,
; 608  : 		0
; 609  : 		};
; 610  : 
; 611  : 		hBaseRC = glw_state.hGLRC; // backup

	mov	eax, DWORD PTR _glw_state+4
	mov	DWORD PTR _hBaseRC$[ebp], eax

; 612  : 		glw_state.hGLRC = NULL;

	mov	DWORD PTR _glw_state+4, 0

; 613  : 
; 614  : 		if( !( glw_state.hGLRC = pwglCreateContextAttribsARB( glw_state.hDC, NULL, attribs )))

	lea	ecx, DWORD PTR _attribs$1[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _glw_state
	push	edx
	call	DWORD PTR _pwglCreateContextAttribsARB
	mov	DWORD PTR _glw_state+4, eax
	cmp	DWORD PTR _glw_state+4, 0
	jne	SHORT $LN8@GL_CreateC

; 615  : 		{
; 616  : 			glw_state.hGLRC = hBaseRC;

	mov	eax, DWORD PTR _hBaseRC$[ebp]
	mov	DWORD PTR _glw_state+4, eax

; 617  : 			GL_ContextError();

	call	_GL_ContextError

; 618  : 			return true; // just use old context

	mov	eax, 1
	jmp	SHORT $LN1@GL_CreateC
$LN8@GL_CreateC:

; 619  : 		}
; 620  : 
; 621  : 		if(!( pwglMakeCurrent( glw_state.hDC, glw_state.hGLRC )))

	mov	ecx, DWORD PTR _glw_state+4
	push	ecx
	mov	edx, DWORD PTR _glw_state
	push	edx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN9@GL_CreateC

; 622  : 		{
; 623  : 			pwglDeleteContext( glw_state.hGLRC );

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	call	DWORD PTR _pwglDeleteContext

; 624  : 			glw_state.hGLRC = hBaseRC;

	mov	ecx, DWORD PTR _hBaseRC$[ebp]
	mov	DWORD PTR _glw_state+4, ecx

; 625  : 			GL_ContextError();

	call	_GL_ContextError

; 626  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@GL_CreateC
$LN9@GL_CreateC:

; 627  : 		}
; 628  : 
; 629  : 		Con_Reportf( "GL_CreateContext: using extended context\n" );

	push	OFFSET $SG144000
	call	_Con_Reportf
	add	esp, 4

; 630  : 		pwglDeleteContext( hBaseRC );	// release first context

	mov	edx, DWORD PTR _hBaseRC$[ebp]
	push	edx
	call	DWORD PTR _pwglDeleteContext

; 631  : 		glw_state.extended = true;

	mov	DWORD PTR _glw_state+24, 1
$LN7@GL_CreateC:

; 632  : 	}
; 633  : 
; 634  : 	return true;

	mov	eax, 1
$LN1@GL_CreateC:

; 635  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CreateContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_error$ = -4						; size = 4
_GL_ContextError PROC

; 550  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 551  : 	DWORD error = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _error$[ebp], eax

; 552  : 
; 553  : 	if( error == ( 0xc0070000|ERROR_INVALID_VERSION_ARB ))

	cmp	DWORD PTR _error$[ebp], -1073274731	; c0072095H
	jne	SHORT $LN2@GL_Context

; 554  : 		Con_Printf( S_ERROR "Unsupported OpenGL context version (%s).\n", "2.0" );

	push	OFFSET $SG143958
	push	OFFSET $SG143959
	call	_Con_Printf
	add	esp, 8
	jmp	$LN1@GL_Context
$LN2@GL_Context:

; 555  : 	else if( error == ( 0xc0070000|ERROR_INVALID_PROFILE_ARB ))

	cmp	DWORD PTR _error$[ebp], -1073274730	; c0072096H
	jne	SHORT $LN4@GL_Context

; 556  : 		Con_Printf( S_ERROR "Unsupported OpenGL profile (%s).\n", "compat" );

	push	OFFSET $SG143962
	push	OFFSET $SG143963
	call	_Con_Printf
	add	esp, 8
	jmp	$LN1@GL_Context
$LN4@GL_Context:

; 557  : 	else if( error == ( 0xc0070000|ERROR_INVALID_OPERATION ))

	cmp	DWORD PTR _error$[ebp], -1073278755	; c00710ddH
	jne	SHORT $LN6@GL_Context

; 558  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB returned invalid operation.\n" );

	push	OFFSET $SG143966
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN6@GL_Context:

; 559  : 	else if( error == ( 0xc0070000|ERROR_DC_NOT_FOUND ))

	cmp	DWORD PTR _error$[ebp], -1073281647	; c0070591H
	jne	SHORT $LN8@GL_Context

; 560  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB returned dc not found.\n" );

	push	OFFSET $SG143969
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN8@GL_Context:

; 561  : 	else if( error == ( 0xc0070000|ERROR_INVALID_PIXEL_FORMAT ))

	cmp	DWORD PTR _error$[ebp], -1073281072	; c00707d0H
	jne	SHORT $LN10@GL_Context

; 562  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB returned dc not found.\n" );

	push	OFFSET $SG143972
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN10@GL_Context:

; 563  : 	else if( error == ( 0xc0070000|ERROR_NO_SYSTEM_RESOURCES ))

	cmp	DWORD PTR _error$[ebp], -1073281622	; c00705aaH
	jne	SHORT $LN12@GL_Context

; 564  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB ran out of system resources.\n" );

	push	OFFSET $SG143975
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN12@GL_Context:

; 565  : 	else if( error == ( 0xc0070000|ERROR_INVALID_PARAMETER ))

	cmp	DWORD PTR _error$[ebp], -1073282985	; c0070057H
	jne	SHORT $LN14@GL_Context

; 566  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB reported invalid parameter.\n" );

	push	OFFSET $SG143978
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN14@GL_Context:

; 567  : 	else Con_Printf( S_ERROR "Unknown error creating an OpenGL (%s) Context.\n", "2.0" );

	push	OFFSET $SG143979
	push	OFFSET $SG143980
	call	_Con_Printf
	add	esp, 8
$LN1@GL_Context:

; 568  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ContextError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_GL_SetDefaultState PROC

; 532  : {

	push	ebp
	mov	ebp, esp

; 533  : 	memset( &glState, 0, sizeof( glState ));

	push	580					; 00000244H
	push	0
	push	OFFSET _glState
	call	_memset
	add	esp, 12					; 0000000cH

; 534  : 	GL_SetDefaultTexState ();

	call	_GL_SetDefaultTexState

; 535  : 
; 536  : 	if( Sys_CheckParm( "-gldebug" ))

	push	OFFSET $SG143951
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@GL_SetDefa

; 537  : 		SetBits( context_flags, FCONTEXT_DEBUG_ARB );

	mov	eax, DWORD PTR _context_flags
	or	eax, 1
	mov	DWORD PTR _context_flags, eax
$LN2@GL_SetDefa:

; 538  : 
; 539  : 	// init draw stack
; 540  : 	tr.draw_list = &tr.draw_stack[0];

	mov	ecx, 24588				; 0000600cH
	imul	edx, ecx, 0
	add	edx, OFFSET _tr+1092
	mov	DWORD PTR _tr+50272, edx

; 541  : 	tr.draw_stack_pos = 0;

	mov	DWORD PTR _tr+50268, 0

; 542  : }

	pop	ebp
	ret	0
_GL_SetDefaultState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_GL_SetDefaultTexState PROC

; 512  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 513  : 	int	i;
; 514  : 
; 515  : 	memset( glState.currentTextures, -1, MAX_TEXTURE_UNITS * sizeof( *glState.currentTextures ));

	push	128					; 00000080H
	push	-1
	push	OFFSET _glState+20
	call	_memset
	add	esp, 12					; 0000000cH

; 516  : 	memset( glState.texCoordArrayMode, 0, MAX_TEXTURE_UNITS * sizeof( *glState.texCoordArrayMode ));

	push	128					; 00000080H
	push	0
	push	OFFSET _glState+436
	call	_memset
	add	esp, 12					; 0000000cH

; 517  : 	memset( glState.genSTEnabled, 0, MAX_TEXTURE_UNITS * sizeof( *glState.genSTEnabled ));

	push	128					; 00000080H
	push	0
	push	OFFSET _glState+308
	call	_memset
	add	esp, 12					; 0000000cH

; 518  : 
; 519  : 	for( i = 0; i < MAX_TEXTURE_UNITS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_SetDefa
$LN2@GL_SetDefa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_SetDefa:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN1@GL_SetDefa

; 520  : 	{
; 521  : 		glState.currentTextureTargets[i] = GL_NONE;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _glState[ecx*4+148], 0

; 522  : 		glState.texIdentityMatrix[i] = true;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _glState[edx+276], 1

; 523  : 	}

	jmp	SHORT $LN2@GL_SetDefa
$LN1@GL_SetDefa:

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetDefaultTexState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv163 = -24						; size = 4
_extensions_string$ = -20				; size = 4
tv86 = -16						; size = 4
tv81 = -12						; size = 4
_parm$ = -8						; size = 4
_func$ = -4						; size = 4
_name$ = 8						; size = 4
_funcs$ = 12						; size = 4
_cvarname$ = 16						; size = 4
_r_ext$ = 20						; size = 4
_GL_CheckExtension PROC

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 435  : 	const dllfunc_t	*func;
; 436  : 	convar_t		*parm = NULL;

	mov	DWORD PTR _parm$[ebp], 0

; 437  : 	const char	*extensions_string;
; 438  : 
; 439  : 	Con_Reportf( "GL_CheckExtension: %s ", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG143911
	call	_Con_Reportf
	add	esp, 8

; 440  : 	GL_SetExtension( r_ext, true );

	push	1
	mov	ecx, DWORD PTR _r_ext$[ebp]
	push	ecx
	call	_GL_SetExtension
	add	esp, 8

; 441  : 
; 442  : 	if( cvarname )

	cmp	DWORD PTR _cvarname$[ebp], 0
	je	SHORT $LN8@GL_CheckEx

; 443  : 	{
; 444  : 		// system config disable extensions
; 445  : 		parm = Cvar_Get( cvarname, "1", FCVAR_GLCONFIG, va( CVAR_GLCONFIG_DESCRIPTION, name ));

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG143913
	call	_va
	add	esp, 8
	push	eax
	push	4096					; 00001000H
	push	OFFSET $SG143914
	mov	eax, DWORD PTR _cvarname$[ebp]
	push	eax
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _parm$[ebp], eax
$LN8@GL_CheckEx:

; 446  :           }
; 447  : 
; 448  : 	if(( parm && !CVAR_TO_BOOL( parm )) || ( !CVAR_TO_BOOL( gl_extensions ) && r_ext != GL_OPENGL_110 ))

	cmp	DWORD PTR _parm$[ebp], 0
	je	SHORT $LN11@GL_CheckEx
	cmp	DWORD PTR _parm$[ebp], 0
	je	SHORT $LN19@GL_CheckEx
	mov	ecx, DWORD PTR _parm$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@GL_CheckEx
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN20@GL_CheckEx
$LN19@GL_CheckEx:
	mov	DWORD PTR tv81[ebp], 0
$LN20@GL_CheckEx:
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN10@GL_CheckEx
$LN11@GL_CheckEx:
	cmp	DWORD PTR _gl_extensions, 0
	je	SHORT $LN21@GL_CheckEx
	mov	edx, DWORD PTR _gl_extensions
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@GL_CheckEx
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN22@GL_CheckEx
$LN21@GL_CheckEx:
	mov	DWORD PTR tv86[ebp], 0
$LN22@GL_CheckEx:
	cmp	DWORD PTR tv86[ebp], 0
	jne	SHORT $LN9@GL_CheckEx
	cmp	DWORD PTR _r_ext$[ebp], 0
	je	SHORT $LN9@GL_CheckEx
$LN10@GL_CheckEx:

; 449  : 	{
; 450  : 		Con_Reportf( "- disabled\n" );

	push	OFFSET $SG143918
	call	_Con_Reportf
	add	esp, 4

; 451  : 		GL_SetExtension( r_ext, false );

	push	0
	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_SetExtension
	add	esp, 8

; 452  : 		return; // nothing to process at

	jmp	$LN17@GL_CheckEx
$LN9@GL_CheckEx:

; 453  : 	}
; 454  : 
; 455  : 	extensions_string = glConfig.extensions_string; 

	mov	ecx, DWORD PTR _glConfig+16
	mov	DWORD PTR _extensions_string$[ebp], ecx

; 456  : 
; 457  : 	if( name[0] == 'W' && name[1] == 'G' && name[2] == 'L' && glConfig.wgl_extensions_string != NULL )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 87					; 00000057H
	jne	SHORT $LN12@GL_CheckEx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 71					; 00000047H
	jne	SHORT $LN12@GL_CheckEx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN12@GL_CheckEx
	cmp	DWORD PTR _glConfig+20, 0
	je	SHORT $LN12@GL_CheckEx

; 458  : 		extensions_string = glConfig.wgl_extensions_string;

	mov	eax, DWORD PTR _glConfig+20
	mov	DWORD PTR _extensions_string$[ebp], eax
$LN12@GL_CheckEx:

; 459  : 
; 460  : 	if(( name[2] == '_' || name[3] == '_' ) && !Q_strstr( extensions_string, name ))

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN14@GL_CheckEx
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 95					; 0000005fH
	jne	SHORT $LN13@GL_CheckEx
$LN14@GL_CheckEx:
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _extensions_string$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@GL_CheckEx

; 461  : 	{
; 462  : 		GL_SetExtension( r_ext, false );	// update render info

	push	0
	mov	ecx, DWORD PTR _r_ext$[ebp]
	push	ecx
	call	_GL_SetExtension
	add	esp, 8

; 463  : 		Con_Reportf( "- ^1failed\n" );

	push	OFFSET $SG143922
	call	_Con_Reportf
	add	esp, 4

; 464  : 		return;

	jmp	$LN17@GL_CheckEx
$LN13@GL_CheckEx:

; 465  : 	}
; 466  : 
; 467  : 	// clear exports
; 468  : 	for( func = funcs; func && func->name; func++ )

	mov	edx, DWORD PTR _funcs$[ebp]
	mov	DWORD PTR _func$[ebp], edx
	jmp	SHORT $LN4@GL_CheckEx
$LN2@GL_CheckEx:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN4@GL_CheckEx:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN3@GL_CheckEx
	mov	ecx, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@GL_CheckEx

; 469  : 		*func->func = NULL;

	mov	edx, DWORD PTR _func$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN2@GL_CheckEx
$LN3@GL_CheckEx:

; 470  : 
; 471  : 	for( func = funcs; func && func->name != NULL; func++ )

	mov	ecx, DWORD PTR _funcs$[ebp]
	mov	DWORD PTR _func$[ebp], ecx
	jmp	SHORT $LN7@GL_CheckEx
$LN5@GL_CheckEx:
	mov	edx, DWORD PTR _func$[ebp]
	add	edx, 8
	mov	DWORD PTR _func$[ebp], edx
$LN7@GL_CheckEx:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN6@GL_CheckEx
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@GL_CheckEx

; 472  : 	{
; 473  : 		// functions are cleared before all the extensions are evaluated
; 474  : 		if((*func->func = (void *)GL_GetProcAddress( func->name )) == NULL )

	mov	ecx, DWORD PTR _func$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR tv163[ebp], eax
	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR tv163[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR tv163[ebp], 0
	jne	SHORT $LN15@GL_CheckEx

; 475  : 			GL_SetExtension( r_ext, false ); // one or more functions are invalid, extension will be disabled

	push	0
	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_SetExtension
	add	esp, 8
$LN15@GL_CheckEx:

; 476  : 	}

	jmp	SHORT $LN5@GL_CheckEx
$LN6@GL_CheckEx:

; 477  : 
; 478  : 	if( GL_Support( r_ext ))

	mov	ecx, DWORD PTR _r_ext$[ebp]
	push	ecx
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@GL_CheckEx

; 479  : 		Con_Reportf( "- ^2enabled\n" );

	push	OFFSET $SG143926
	call	_Con_Reportf
	add	esp, 4
	jmp	SHORT $LN17@GL_CheckEx
$LN16@GL_CheckEx:

; 480  : 	else Con_Reportf( "- ^1failed\n" );

	push	OFFSET $SG143927
	call	_Con_Reportf
	add	esp, 4
$LN17@GL_CheckEx:

; 481  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CheckExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_r_ext$ = 8						; size = 4
_enable$ = 12						; size = 4
_GL_SetExtension PROC

; 380  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 381  : 	if( r_ext >= 0 && r_ext < GL_EXTCOUNT )

	cmp	DWORD PTR _r_ext$[ebp], 0
	jl	SHORT $LN2@GL_SetExte
	cmp	DWORD PTR _r_ext$[ebp], 22		; 00000016H
	jge	SHORT $LN2@GL_SetExte

; 382  : 		glConfig.extension[r_ext] = enable ? GL_TRUE : GL_FALSE;

	cmp	DWORD PTR _enable$[ebp], 0
	je	SHORT $LN5@GL_SetExte
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN6@GL_SetExte
$LN5@GL_SetExte:
	mov	DWORD PTR tv69[ebp], 0
$LN6@GL_SetExte:
	mov	eax, DWORD PTR _r_ext$[ebp]
	mov	cl, BYTE PTR tv69[ebp]
	mov	BYTE PTR _glConfig[eax+24], cl
	jmp	SHORT $LN1@GL_SetExte
$LN2@GL_SetExte:

; 383  : 	else Con_Printf( S_ERROR "GL_SetExtension: invalid extension %d\n", r_ext );

	mov	edx, DWORD PTR _r_ext$[ebp]
	push	edx
	push	OFFSET $SG143867
	call	_Con_Printf
	add	esp, 8
$LN1@GL_SetExte:

; 384  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_source$ = 8						; size = 4
_type$ = 12						; size = 4
_id$ = 16						; size = 4
_severity$ = 20						; size = 4
_length$ = 24						; size = 4
_message$ = 28						; size = 4
_userParam$ = 32					; size = 4
_GL_DebugOutput@28 PROC

; 345  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 346  : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 33356				; 0000824cH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 4
	ja	SHORT $LN10@GL_DebugOu
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN13@GL_DebugOu[edx*4]
$LN4@GL_DebugOu:

; 347  : 	{
; 348  : 	case GL_DEBUG_TYPE_ERROR_ARB:
; 349  : 		Con_Printf( S_OPENGL_ERROR "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET $SG143846
	call	_Con_Printf
	add	esp, 8

; 350  : 		break;

	jmp	$LN2@GL_DebugOu
$LN5@GL_DebugOu:

; 351  : 	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB:
; 352  : 		Con_Printf( S_OPENGL_WARN "%s\n", message );

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	push	OFFSET $SG143848
	call	_Con_Printf
	add	esp, 8

; 353  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN6@GL_DebugOu:

; 354  : 	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB:
; 355  : 		Con_Printf( S_OPENGL_WARN "%s\n", message );

	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	push	OFFSET $SG143850
	call	_Con_Printf
	add	esp, 8

; 356  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN7@GL_DebugOu:

; 357  : 	case GL_DEBUG_TYPE_PORTABILITY_ARB:
; 358  : 		if( host_developer.value < DEV_EXTENDED )

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN8@GL_DebugOu

; 359  : 			return;

	jmp	SHORT $LN2@GL_DebugOu
$LN8@GL_DebugOu:

; 360  : 		Con_Printf( S_OPENGL_WARN "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET $SG143853
	call	_Con_Printf
	add	esp, 8

; 361  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN9@GL_DebugOu:

; 362  : 	case GL_DEBUG_TYPE_PERFORMANCE_ARB:
; 363  : 		Con_Printf( S_OPENGL_NOTE "%s\n", message );

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	push	OFFSET $SG143855
	call	_Con_Printf
	add	esp, 8

; 364  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN10@GL_DebugOu:

; 365  : 	case GL_DEBUG_TYPE_OTHER_ARB:
; 366  : 	default:
; 367  : 		if( host_developer.value < DEV_EXTENDED )

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN11@GL_DebugOu

; 368  : 			return;

	jmp	SHORT $LN2@GL_DebugOu
$LN11@GL_DebugOu:

; 369  : 		Con_Printf( S_OPENGL_NOTE "%s\n", message );

	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	push	OFFSET $SG143858
	call	_Con_Printf
	add	esp, 8
$LN2@GL_DebugOu:

; 370  : 		break;
; 371  : 	}
; 372  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	3
$LN13@GL_DebugOu:
	DD	$LN4@GL_DebugOu
	DD	$LN5@GL_DebugOu
	DD	$LN6@GL_DebugOu
	DD	$LN7@GL_DebugOu
	DD	$LN9@GL_DebugOu
_GL_DebugOutput@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mod$ = -4						; size = 4
_R_Shutdown PROC

; 1885 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1886 : 	model_t	*mod;
; 1887 : 	int	i;
; 1888 : 
; 1889 : 	if( !glw_state.initialized )

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN5@R_Shutdown

; 1890 : 		return;

	jmp	$LN1@R_Shutdown
$LN5@R_Shutdown:

; 1891 : 
; 1892 : 	// release SpriteTextures
; 1893 : 	for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+22288
	jmp	SHORT $LN4@R_Shutdown
$LN2@R_Shutdown:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@R_Shutdown:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@R_Shutdown

; 1894 : 	{
; 1895 : 		if( !mod->name[0] ) continue;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN6@R_Shutdown
	jmp	SHORT $LN2@R_Shutdown
$LN6@R_Shutdown:

; 1896 : 		Mod_UnloadSpriteModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 1897 : 	}

	jmp	SHORT $LN2@R_Shutdown
$LN3@R_Shutdown:

; 1898 : 	memset( clgame.sprites, 0, sizeof( clgame.sprites ));

	push	100352					; 00018800H
	push	0
	push	OFFSET _clgame+22288
	call	_memset
	add	esp, 12					; 0000000cH

; 1899 : 
; 1900 : 	GL_RemoveCommands();

	call	_GL_RemoveCommands

; 1901 : 	R_ShutdownImages();

	call	_R_ShutdownImages

; 1902 : 
; 1903 : 	Mem_FreePool( &r_temppool );

	push	1903					; 0000076fH
	push	OFFSET $SG144633
	push	OFFSET _r_temppool
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 1904 : 
; 1905 : 	// shut down OS specific OpenGL stuff like contexts, etc.
; 1906 : 	R_Free_OpenGL();

	call	_R_Free_OpenGL
$LN1@R_Shutdown:

; 1907 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_R_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_R_Init	PROC

; 1843 : {

	push	ebp
	mov	ebp, esp

; 1844 : 	if( glw_state.initialized )

	cmp	DWORD PTR _glw_state+20, 0
	je	SHORT $LN2@R_Init

; 1845 : 		return true;

	mov	eax, 1
	jmp	$LN1@R_Init
$LN2@R_Init:

; 1846 : 
; 1847 : 	GL_InitCommands();

	call	_GL_InitCommands

; 1848 : 	GL_InitRandomTable();

	call	_GL_InitRandomTable

; 1849 : 	GL_SetDefaultState();

	call	_GL_SetDefaultState

; 1850 : 
; 1851 : 	// create the window and set up the context
; 1852 : 	if( !R_Init_OpenGL( ))

	call	_R_Init_OpenGL
	test	eax, eax
	jne	SHORT $LN3@R_Init

; 1853 : 	{
; 1854 : 		GL_RemoveCommands();

	call	_GL_RemoveCommands

; 1855 : 		R_Free_OpenGL();

	call	_R_Free_OpenGL

; 1856 : 
; 1857 : 		Sys_Error( "Can't initialize video subsystem\nProbably driver was not installed" );

	push	OFFSET $SG144621
	call	_Sys_Error
	add	esp, 4

; 1858 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_Init
$LN3@R_Init:

; 1859 : 	}
; 1860 : 
; 1861 : 	host.renderinfo_changed = false;

	mov	DWORD PTR _host+34416, 0

; 1862 : 	r_temppool = Mem_AllocPool( "Render Zone" );

	push	1862					; 00000746H
	push	OFFSET $SG144622
	push	OFFSET $SG144623
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _r_temppool, eax

; 1863 : 
; 1864 : 	GL_InitExtensions();

	call	_GL_InitExtensions

; 1865 : 	GL_SetDefaults();

	call	_GL_SetDefaults

; 1866 : 	R_InitImages();

	call	_R_InitImages

; 1867 : 	R_SpriteInit();

	call	_R_SpriteInit

; 1868 : 	R_StudioInit();

	call	_R_StudioInit

; 1869 : 	R_AliasInit();

	call	_R_AliasInit

; 1870 : 	R_ClearDecals();

	call	_R_ClearDecals

; 1871 : 	R_ClearScene();

	call	_R_ClearScene

; 1872 : 
; 1873 : 	// initialize screen
; 1874 : 	SCR_Init();

	call	_SCR_Init

; 1875 : 
; 1876 : 	return true;

	mov	eax, 1
$LN1@R_Init:

; 1877 : }

	pop	ebp
	ret	0
_R_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv72 = -12						; size = 4
tv71 = -8						; size = 4
tv68 = -4						; size = 4
_GL_MaxTextureUnits PROC

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 407  : 	if( GL_Support( GL_SHADER_GLSL100_EXT ))

	push	9
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@GL_MaxText

; 408  : 		return Q_min( Q_max( glConfig.max_texture_coords, glConfig.max_teximage_units ), MAX_TEXTURE_UNITS );

	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glConfig+56
	jle	SHORT $LN4@GL_MaxText
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN5@GL_MaxText
$LN4@GL_MaxText:
	mov	edx, DWORD PTR _glConfig+56
	mov	DWORD PTR tv68[ebp], edx
$LN5@GL_MaxText:
	cmp	DWORD PTR tv68[ebp], 32			; 00000020H
	jge	SHORT $LN8@GL_MaxText
	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glConfig+56
	jle	SHORT $LN6@GL_MaxText
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN7@GL_MaxText
$LN6@GL_MaxText:
	mov	edx, DWORD PTR _glConfig+56
	mov	DWORD PTR tv71[ebp], edx
$LN7@GL_MaxText:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN9@GL_MaxText
$LN8@GL_MaxText:
	mov	DWORD PTR tv72[ebp], 32			; 00000020H
$LN9@GL_MaxText:
	mov	eax, DWORD PTR tv72[ebp]
	jmp	SHORT $LN1@GL_MaxText
$LN2@GL_MaxText:

; 409  : 	return glConfig.max_texture_units;

	mov	eax, DWORD PTR _glConfig+48
$LN1@GL_MaxText:

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_MaxTextureUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_VID_CheckChanges PROC

; 1422 : {

	push	ebp
	mov	ebp, esp

; 1423 : 	if( FBitSet( cl_allow_levelshots->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _cl_allow_levelshots
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN2@VID_CheckC

; 1424 :           {
; 1425 : 		GL_FreeTexture( cls.loadingBar );

	mov	edx, DWORD PTR _cls+287380
	push	edx
	call	_GL_FreeTexture
	add	esp, 4

; 1426 : 		SCR_RegisterTextures(); // reload 'lambda' image

	call	_SCR_RegisterTextures

; 1427 : 		ClearBits( cl_allow_levelshots->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _cl_allow_levelshots
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _cl_allow_levelshots
	mov	DWORD PTR [edx+8], ecx
$LN2@VID_CheckC:

; 1428 :           }
; 1429 :  
; 1430 : 	if( host.renderinfo_changed )

	cmp	DWORD PTR _host+34416, 0
	je	SHORT $LN1@VID_CheckC

; 1431 : 	{
; 1432 : 		if( !VID_SetMode( ))

	call	_VID_SetMode
	test	eax, eax
	jne	SHORT $LN4@VID_CheckC

; 1433 : 		{
; 1434 : 			Sys_Error( "Can't re-initialize video subsystem\n" );

	push	OFFSET $SG144297
	call	_Sys_Error
	add	esp, 4

; 1435 : 		}

	jmp	SHORT $LN1@VID_CheckC
$LN4@VID_CheckC:

; 1436 : 		else
; 1437 : 		{
; 1438 : 			host.renderinfo_changed = false;

	mov	DWORD PTR _host+34416, 0

; 1439 : 			SCR_VidInit(); // tell the client.dll what vid_mode has changed

	call	_SCR_VidInit
$LN1@VID_CheckC:

; 1440 : 		}
; 1441 : 	}
; 1442 : }

	pop	ebp
	ret	0
_VID_CheckChanges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv70 = -4						; size = 4
_r_ext$ = 8						; size = 4
_GL_Support PROC

; 392  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 393  : 	if( r_ext >= 0 && r_ext < GL_EXTCOUNT )

	cmp	DWORD PTR _r_ext$[ebp], 0
	jl	SHORT $LN2@GL_Support
	cmp	DWORD PTR _r_ext$[ebp], 22		; 00000016H
	jge	SHORT $LN2@GL_Support

; 394  : 		return glConfig.extension[r_ext] ? true : false;

	mov	eax, DWORD PTR _r_ext$[ebp]
	movzx	ecx, BYTE PTR _glConfig[eax+24]
	test	ecx, ecx
	je	SHORT $LN4@GL_Support
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@GL_Support
$LN4@GL_Support:
	mov	DWORD PTR tv70[ebp], 0
$LN5@GL_Support:
	mov	eax, DWORD PTR tv70[ebp]
	jmp	SHORT $LN1@GL_Support
$LN2@GL_Support:

; 395  : 	Con_Printf( S_ERROR "GL_Support: invalid extension %d\n", r_ext );

	mov	edx, DWORD PTR _r_ext$[ebp]
	push	edx
	push	OFFSET $SG143872
	call	_Con_Printf
	add	esp, 8

; 396  : 
; 397  : 	return false;		

	xor	eax, eax
$LN1@GL_Support:

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_Support ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_GL_DeleteContext PROC

; 658  : {

	push	ebp
	mov	ebp, esp

; 659  : 	if( pwglMakeCurrent )

	cmp	DWORD PTR _pwglMakeCurrent, 0
	je	SHORT $LN2@GL_DeleteC

; 660  : 		pwglMakeCurrent( NULL, NULL );

	push	0
	push	0
	call	DWORD PTR _pwglMakeCurrent
$LN2@GL_DeleteC:

; 661  : 
; 662  : 	if( glw_state.hGLRC )

	cmp	DWORD PTR _glw_state+4, 0
	je	SHORT $LN3@GL_DeleteC

; 663  : 	{
; 664  : 		if( pwglDeleteContext )

	cmp	DWORD PTR _pwglDeleteContext, 0
	je	SHORT $LN4@GL_DeleteC

; 665  : 			pwglDeleteContext( glw_state.hGLRC );

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	call	DWORD PTR _pwglDeleteContext
$LN4@GL_DeleteC:

; 666  : 		glw_state.hGLRC = NULL;

	mov	DWORD PTR _glw_state+4, 0
$LN3@GL_DeleteC:

; 667  : 	}
; 668  : 
; 669  : 	if( glw_state.hDC )

	cmp	DWORD PTR _glw_state, 0
	je	SHORT $LN5@GL_DeleteC

; 670  : 	{
; 671  : 		ReleaseDC( host.hWnd, glw_state.hDC );

	mov	ecx, DWORD PTR _glw_state
	push	ecx
	mov	edx, DWORD PTR _host+34332
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8

; 672  : 		glw_state.hDC = NULL;

	mov	DWORD PTR _glw_state, 0
$LN5@GL_DeleteC:

; 673  : 	}
; 674  : 
; 675  : 	return false;

	xor	eax, eax

; 676  : }

	pop	ebp
	ret	0
_GL_DeleteContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv87 = -8						; size = 4
tv86 = -4						; size = 4
_GL_UpdateSwapInterval PROC

; 489  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 490  : 	// disable VSync while level is loading
; 491  : 	if( cls.state < ca_active )

	cmp	DWORD PTR _cls, 4
	jge	SHORT $LN2@GL_UpdateS

; 492  : 	{
; 493  : 		if( pwglSwapIntervalEXT != NULL )

	cmp	DWORD PTR _pwglSwapIntervalEXT, 0
	je	SHORT $LN4@GL_UpdateS

; 494  : 			pwglSwapIntervalEXT( 0 );

	push	0
	call	DWORD PTR _pwglSwapIntervalEXT
$LN4@GL_UpdateS:

; 495  : 		SetBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _gl_vsync
	mov	DWORD PTR [edx+8], ecx

; 496  : 	}

	jmp	SHORT $LN6@GL_UpdateS
$LN2@GL_UpdateS:

; 497  : 	else if( FBitSet( gl_vsync->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN6@GL_UpdateS

; 498  : 	{
; 499  : 		ClearBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	edx, DWORD PTR _gl_vsync
	mov	eax, DWORD PTR [edx+8]
	and	eax, -8193				; ffffdfffH
	mov	ecx, DWORD PTR _gl_vsync
	mov	DWORD PTR [ecx+8], eax

; 500  : 
; 501  : 		if( pwglSwapIntervalEXT != NULL )

	cmp	DWORD PTR _pwglSwapIntervalEXT, 0
	je	SHORT $LN6@GL_UpdateS

; 502  : 			pwglSwapIntervalEXT( bound( -1, (int)gl_vsync->value, 1 ));

	mov	edx, DWORD PTR _gl_vsync
	cvttss2si eax, DWORD PTR [edx+12]
	cmp	eax, -1
	jl	SHORT $LN10@GL_UpdateS
	mov	ecx, DWORD PTR _gl_vsync
	cvttss2si edx, DWORD PTR [ecx+12]
	cmp	edx, 1
	jge	SHORT $LN8@GL_UpdateS
	mov	eax, DWORD PTR _gl_vsync
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN9@GL_UpdateS
$LN8@GL_UpdateS:
	mov	DWORD PTR tv86[ebp], 1
$LN9@GL_UpdateS:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], edx
	jmp	SHORT $LN11@GL_UpdateS
$LN10@GL_UpdateS:
	mov	DWORD PTR tv87[ebp], -1
$LN11@GL_UpdateS:
	mov	eax, DWORD PTR tv87[ebp]
	push	eax
	call	DWORD PTR _pwglSwapIntervalEXT
$LN6@GL_UpdateS:

; 503  : 	}
; 504  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_UpdateSwapInterval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_err$ = 8						; size = 4
_GL_ErrorString PROC

; 1918 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1919 : 	switch( err )

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1280				; 00000500H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN10@GL_ErrorSt
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@GL_ErrorSt[edx*4]
$LN4@GL_ErrorSt:

; 1920 : 	{
; 1921 : 	case GL_STACK_OVERFLOW:
; 1922 : 		return "GL_STACK_OVERFLOW";

	mov	eax, OFFSET $SG144640
	jmp	SHORT $LN1@GL_ErrorSt
$LN5@GL_ErrorSt:

; 1923 : 	case GL_STACK_UNDERFLOW:
; 1924 : 		return "GL_STACK_UNDERFLOW";

	mov	eax, OFFSET $SG144642
	jmp	SHORT $LN1@GL_ErrorSt
$LN6@GL_ErrorSt:

; 1925 : 	case GL_INVALID_ENUM:
; 1926 : 		return "GL_INVALID_ENUM";

	mov	eax, OFFSET $SG144644
	jmp	SHORT $LN1@GL_ErrorSt
$LN7@GL_ErrorSt:

; 1927 : 	case GL_INVALID_VALUE:
; 1928 : 		return "GL_INVALID_VALUE";

	mov	eax, OFFSET $SG144646
	jmp	SHORT $LN1@GL_ErrorSt
$LN8@GL_ErrorSt:

; 1929 : 	case GL_INVALID_OPERATION:
; 1930 : 		return "GL_INVALID_OPERATION";

	mov	eax, OFFSET $SG144648
	jmp	SHORT $LN1@GL_ErrorSt
$LN9@GL_ErrorSt:

; 1931 : 	case GL_OUT_OF_MEMORY:
; 1932 : 		return "GL_OUT_OF_MEMORY";

	mov	eax, OFFSET $SG144650
	jmp	SHORT $LN1@GL_ErrorSt
$LN10@GL_ErrorSt:

; 1933 : 	default:
; 1934 : 		return "UNKNOWN ERROR";

	mov	eax, OFFSET $SG144652
$LN1@GL_ErrorSt:

; 1935 : 	}
; 1936 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@GL_ErrorSt:
	DD	$LN6@GL_ErrorSt
	DD	$LN7@GL_ErrorSt
	DD	$LN8@GL_ErrorSt
	DD	$LN4@GL_ErrorSt
	DD	$LN5@GL_ErrorSt
	DD	$LN9@GL_ErrorSt
_GL_ErrorString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_p$ = -4						; size = 4
_name$ = 8						; size = 4
_GL_GetProcAddress PROC

; 418  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 419  : 	void	*p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 420  : 
; 421  : 	if( pwglGetProcAddress != NULL )

	cmp	DWORD PTR _pwglGetProcAddress, 0
	je	SHORT $LN2@GL_GetProc

; 422  : 		p = (void *)pwglGetProcAddress( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _pwglGetProcAddress
	mov	DWORD PTR _p$[ebp], eax
$LN2@GL_GetProc:

; 423  : 	if( !p ) p = (void *)Sys_GetProcAddress( &opengl_dll, name );

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN3@GL_GetProc
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET _opengl_dll
	call	_Sys_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
$LN3@GL_GetProc:

; 424  : 
; 425  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]

; 426  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_GetProcAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_vid_mode$ = 8						; size = 4
_VID_GetModeString PROC

; 798  : {

	push	ebp
	mov	ebp, esp

; 799  : 	if( vid_mode >= 0 && vid_mode < num_vidmodes )

	cmp	DWORD PTR _vid_mode$[ebp], 0
	jl	SHORT $LN2@VID_GetMod
	cmp	DWORD PTR _vid_mode$[ebp], 26		; 0000001aH
	jae	SHORT $LN2@VID_GetMod

; 800  : 		return vidmode[vid_mode].desc;

	mov	eax, DWORD PTR _vid_mode$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _vidmode[eax]
	jmp	SHORT $LN1@VID_GetMod
$LN2@VID_GetMod:

; 801  : 	return NULL; // out of bounds

	xor	eax, eax
$LN1@VID_GetMod:

; 802  : }

	pop	ebp
	ret	0
_VID_GetModeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_err$ = -8						; size = 4
tv67 = -4						; size = 4
_filename$ = 8						; size = 4
_fileline$ = 12						; size = 4
_GL_CheckForErrors_ PROC

; 1946 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1947 : 	int	err;
; 1948 : 
; 1949 : 	if( !CVAR_TO_BOOL( gl_check_errors ))

	cmp	DWORD PTR _gl_check_errors, 0
	je	SHORT $LN5@GL_CheckFo
	mov	eax, DWORD PTR _gl_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@GL_CheckFo
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN6@GL_CheckFo
$LN5@GL_CheckFo:
	mov	DWORD PTR tv67[ebp], 0
$LN6@GL_CheckFo:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN2@GL_CheckFo

; 1950 : 		return;

	jmp	SHORT $LN1@GL_CheckFo
$LN2@GL_CheckFo:

; 1951 : 
; 1952 : 	if(( err = pglGetError( )) == GL_NO_ERROR )

	call	DWORD PTR _pglGetError
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN3@GL_CheckFo

; 1953 : 		return;

	jmp	SHORT $LN1@GL_CheckFo
$LN3@GL_CheckFo:

; 1954 : 
; 1955 : 	Con_Printf( S_OPENGL_ERROR "%s (called at %s:%i)\n", GL_ErrorString( err ), filename, fileline );

	mov	ecx, DWORD PTR _fileline$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _err$[ebp]
	push	eax
	call	_GL_ErrorString
	add	esp, 4
	push	eax
	push	OFFSET $SG144661
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN1@GL_CheckFo:

; 1956 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CheckForErrors_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\client\gl_vidnt.c
_TEXT	SEGMENT
_VID_InitDefaultResolution PROC

; 785  : {

	push	ebp
	mov	ebp, esp

; 786  : 	// we need to have something valid here
; 787  : 	// until video subsystem initialized
; 788  : 	glState.width = 640;

	mov	DWORD PTR _glState, 640			; 00000280H

; 789  : 	glState.height = 480;

	mov	DWORD PTR _glState+4, 480		; 000001e0H

; 790  : }

	pop	ebp
	ret	0
_VID_InitDefaultResolution ENDP
_TEXT	ENDS
END
