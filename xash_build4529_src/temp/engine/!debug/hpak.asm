; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Documents\GitHub\XashTasks\xash_build4529_src\engine\common\hpak.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_gp_hpak_queue
_DATA	SEGMENT
COMM	_hpk_maxsize:DWORD
_DATA	ENDS
_BSS	SEGMENT
_gp_hpak_queue DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_hash_pack_header:BYTE:0cH
COMM	_hash_pack_info:QWORD
_DATA	ENDS
PUBLIC	_HPAK_Init
PUBLIC	_HPAK_GetDataPointer
PUBLIC	_HPAK_ResourceForHash
PUBLIC	_HPAK_AddLump
PUBLIC	_HPAK_RemoveLump
PUBLIC	_HPAK_CheckIntegrity
PUBLIC	_HPAK_CheckSize
PUBLIC	_HPAK_FlushHostQueue
PUBLIC	_HPAK_TypeFromIndex
PUBLIC	_HPAK_CreatePak
PUBLIC	_HPAK_ValidatePak
PUBLIC	_HPAK_List_f
PUBLIC	_HPAK_Extract_f
PUBLIC	_HPAK_Remove_f
PUBLIC	_HPAK_Validate_f
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_ReplaceExtension:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_Rename:PROC
EXTRN	_FS_FileCopy:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_MD5Init:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_Log_Printf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
$SG129817 DB	'decal', 00H
	ORG $+2
$SG129819 DB	'skin', 00H
	ORG $+3
$SG129821 DB	'model', 00H
	ORG $+2
$SG129823 DB	'decal', 00H
	ORG $+2
$SG129825 DB	'generic', 00H
$SG129827 DB	'event', 00H
	ORG $+2
$SG129829 DB	'map', 00H
$SG129830 DB	'?', 00H
	ORG $+2
$SG129845 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129852 DB	'HPAK_AddToQueue: data == NULL.', 0aH, 00H
$SG129900 DB	'creating HPAK %s.', 0aH, 00H
	ORG $+1
$SG129846 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129901 DB	'wb', 00H
	ORG $+1
$SG129847 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129903 DB	'^1Error:^7 HPAK_CreatePak: can''t write %s.', 0aH, 00H
$SG129865 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129909 DB	'^1Error:^7 HPAK_CreatePak: bad checksum for %s. Ignored', 0aH
	DB	00H
	ORG $+3
$SG129866 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129980 DB	'^1Error:^7 %s: invalid size %s', 0aH, 00H
$SG129989 DB	'rb', 00H
	ORG $+1
$SG129867 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129899 DB	'.hpk', 00H
	ORG $+3
$SG129986 DB	'^1Error:^7 HPAK_AddLump: bad checksum for %s. Ignored', 0aH
	DB	00H
	ORG $+1
$SG129992 DB	'wb', 00H
	ORG $+1
$SG129906 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129994 DB	'^1Error:^7 HPAK_AddLump: couldn''t open %s.', 0aH, 00H
$SG129907 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129996 DB	'^1Error:^7 HPAK_AddLump: %s does not have a valid header'
	DB	'.', 0aH, 00H
	ORG $+1
$SG129910 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130039 DB	'rb', 00H
	ORG $+1
$SG129914 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130041 DB	'^1Error:^7 Couldn''t find %s.', 0aH, 00H
	ORG $+2
$SG130043 DB	'Validating %s', 0aH, 00H
	ORG $+1
$SG130049 DB	'^1Error:^7 HPAK_ValidatePak: %s has too many lumps %u.', 0aH
	DB	00H
$SG130051 DB	'# of Entries:  %i', 0aH, 00H
	ORG $+1
$SG129983 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130054 DB	'# Type Size FileName : MD5 Hash', 0aH, 00H
	ORG $+3
$SG129984 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG129988 DB	'.hpk', 00H
	ORG $+3
$SG129991 DB	'.hp2', 00H
	ORG $+3
$SG129999 DB	'^1Error:^7 HPAK_AddLump: %s contain too many lumps.', 0aH
	DB	00H
	ORG $+3
$SG130057 DB	'^1Error:^7 HPAK_ValidatePak: lump %i has invalid size %s'
	DB	0aH, 00H
	ORG $+2
$SG130000 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130060 DB	'%i:      %s %s %s:   ', 00H
	ORG $+2
$SG130065 DB	'^1Error:^7 HPAK_ValidatePak: %s has invalid checksum.', 0aH
	DB	00H
	ORG $+1
$SG130068 DB	'^1Error:^7 failed', 0aH, 00H
	ORG $+1
$SG130003 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130070 DB	'OK', 0aH, 00H
$SG130004 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130094 DB	'Server: Size of %s > %f MB, deleting.', 0aH, 00H
	ORG $+1
$SG130120 DB	'rb', 00H
	ORG $+1
$SG130010 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130095 DB	'Server: Size of %s > %f MB, deleting.', 0aH, 00H
	ORG $+1
$SG130146 DB	'rb', 00H
	ORG $+1
$SG130012 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130038 DB	'.hpk', 00H
	ORG $+3
$SG130148 DB	'^1Error:^7 couldn''t open %s.', 0aH, 00H
	ORG $+2
$SG130150 DB	'^1Error:^7 %s is not an HPAK file', 0aH, 00H
	ORG $+1
$SG130046 DB	'^1Error:^7 HPAK_ValidatePak: %s does not have a valid HP'
	DB	'AK header.', 0aH, 00H
$SG130158 DB	'^1Error:^7 %s, lump with index %i doesn''t exist.', 0aH, 00H
	ORG $+2
$SG130052 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130152 DB	'^1Error:^7 %s has invalid version (%i should be %i).', 0aH
	DB	00H
	ORG $+2
$SG130197 DB	'rb', 00H
	ORG $+1
$SG130058 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130155 DB	'^1Error:^7 %s has too many lumps %u.', 0aH, 00H
	ORG $+2
$SG130200 DB	'^1Error:^7 %s it''s not a HPK file.', 0aH, 00H
$SG130059 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130202 DB	'^1Error:^7 %s has invalid version (%i should be %i).', 0aH
	DB	00H
	ORG $+2
$SG130205 DB	'^1Error:^7 HPAK_GetDataPointer: %s has too many lumps %u'
	DB	'.', 0aH, 00H
	ORG $+1
$SG130066 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130243 DB	'rb', 00H
	ORG $+1
$SG130067 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130245 DB	'^1Error:^7 %s couldn''t open.', 0aH, 00H
	ORG $+2
$SG130247 DB	'wb', 00H
	ORG $+1
$SG130071 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130249 DB	'^1Error:^7 %s couldn''t open.', 0aH, 00H
	ORG $+2
$SG130252 DB	'^1Error:^7 %s has invalid header.', 0aH, 00H
	ORG $+1
$SG130072 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130083 DB	'.hpk', 00H
	ORG $+3
$SG130092 DB	'.hpk', 00H
	ORG $+3
$SG130119 DB	'.hpk', 00H
	ORG $+3
$SG130255 DB	'^1Error:^7 %s has invalid number of lumps.', 0aH, 00H
$SG130126 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130257 DB	'^3Warning:^7 %s only has one element, so HPAK will be re'
	DB	'moved', 0aH, 00H
	ORG $+1
$SG130261 DB	'^1Error:^7 HPAK doesn''t contain specified lump: %s', 0aH
	DB	00H
$SG130127 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130145 DB	'.hpk', 00H
	ORG $+3
$SG130264 DB	'Removing %s from HPAK %s.', 0aH, 00H
	ORG $+1
$SG130159 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130287 DB	'Usage: hpklist <hpk>', 0aH, 00H
	ORG $+2
$SG130289 DB	'Contents for %s.', 0aH, 00H
	ORG $+2
$SG130161 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130290 DB	'rb', 00H
	ORG $+1
$SG130194 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130196 DB	'.hpk', 00H
	ORG $+3
$SG130292 DB	'^1Error:^7 couldn''t open %s.', 0aH, 00H
	ORG $+2
$SG130294 DB	'^1Error:^7 %s is not an HPAK file', 0aH, 00H
	ORG $+1
$SG130206 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130296 DB	'^1Error:^7 %s has invalid version (%i should be %i).', 0aH
	DB	00H
	ORG $+2
$SG130300 DB	'# of Entries:  %i', 0aH, 00H
	ORG $+1
$SG130209 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130299 DB	'^1Error:^7 %s has too many lumps %u.', 0aH, 00H
	ORG $+2
$SG130301 DB	'# Type Size FileName : MD5 Hash', 0aH, 00H
	ORG $+3
$SG130211 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130303 DB	'%i: %10s %s %s', 0aH, '  :  %s', 0aH, 00H
$SG130332 DB	'all', 00H
$SG130212 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130242 DB	'.hpk', 00H
	ORG $+3
$SG130246 DB	'.hp2', 00H
	ORG $+3
$SG130329 DB	'Usage: hpkextract hpkname [all | single index]', 0aH, 00H
$SG130334 DB	'Contents for %s.', 0aH, 00H
	ORG $+2
$SG130258 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130335 DB	'rb', 00H
	ORG $+1
$SG130259 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130337 DB	'^1Error:^7 couldn''t open %s.', 0aH, 00H
	ORG $+2
$SG130339 DB	'^1Error:^7 %s is not an HPAK file', 0aH, 00H
	ORG $+1
$SG130262 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130341 DB	'^1Error:^7 %s has invalid version (%i should be %i).', 0aH
	DB	00H
	ORG $+2
$SG130347 DB	'Extracting all lumps from %s.', 0aH, 00H
	ORG $+1
$SG130348 DB	'Extracting lump %i from %s', 0aH, 00H
$SG130263 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130344 DB	'^1Error:^7 %s has too many lumps %u.', 0aH, 00H
	ORG $+2
$SG130351 DB	'Extracting %i: %10s %s %s', 0aH, 00H
	ORG $+1
$SG130266 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130354 DB	'^3Warning:^7 Unable to extract data, size invalid:  %s', 0aH
	DB	00H
$SG130356 DB	'hpklmps\lmp%04i.bmp', 00H
$SG130267 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130288 DB	'.hpk', 00H
	ORG $+3
$SG130366 DB	'Usage: hpkremove <hpk> <index>', 0aH, 00H
$SG130374 DB	'Usage: hpkval <filename>', 0aH, 00H
	ORG $+2
$SG130302 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130369 DB	'^1Error:^7 Could not locate resource %i in %s', 0aH, 00H
	ORG $+1
$SG130379 DB	'hpklist', 00H
$SG130380 DB	'remove specified file from HPK-file', 00H
$SG130305 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130333 DB	'.hpk', 00H
	ORG $+3
$SG130381 DB	'hpkremove', 00H
	ORG $+2
$SG130349 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130382 DB	'validate specified HPK-file', 00H
$SG130355 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130383 DB	'hpkval', 00H
	ORG $+1
$SG130384 DB	'extract all lumps from specified HPK-file', 00H
	ORG $+2
$SG130358 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130385 DB	'hpkextract', 00H
	ORG $+1
$SG130360 DB	'c:\users\user\documents\github\xashtasks\xash_build4529_'
	DB	'src\engine\common\hpak.c', 00H
	ORG $+3
$SG130378 DB	'list all files in specified HPK-file', 00H
	ORG $+3
$SG130386 DB	'set limit by size for all HPK-files ( 0 - unlimited )', 00H
	ORG $+2
$SG130387 DB	'0', 00H
	ORG $+2
$SG130388 DB	'hpk_maxsize', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_HPAK_Validate_f PROC

; 1063 : {

	push	ebp
	mov	ebp, esp

; 1064 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@HPAK_Valid

; 1065 : 	{
; 1066 : 		Con_Printf( S_USAGE "hpkval <filename>\n" );

	push	OFFSET $SG130374
	call	_Con_Printf
	add	esp, 4

; 1067 : 		return;

	jmp	SHORT $LN1@HPAK_Valid
$LN2@HPAK_Valid:

; 1068 : 	}
; 1069 : 
; 1070 : 	HPAK_Validate( Cmd_Argv( 1 ), false );

	push	0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_HPAK_Validate
	add	esp, 8
$LN1@HPAK_Valid:

; 1071 : }

	pop	ebp
	ret	0
_HPAK_Validate_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_resource$ = -140					; size = 136
__$ArrayPad$ = -4					; size = 4
_HPAK_Remove_f PROC

; 1041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1042 : 	resource_t	resource;
; 1043 : 
; 1044 : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 1045 : 
; 1046 : 	if( Cmd_Argc() != 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	je	SHORT $LN2@HPAK_Remov

; 1047 : 	{
; 1048 : 		Con_Printf( S_USAGE "hpkremove <hpk> <index>\n" );

	push	OFFSET $SG130366
	call	_Con_Printf
	add	esp, 4

; 1049 : 		return;

	jmp	SHORT $LN1@HPAK_Remov
$LN2@HPAK_Remov:

; 1050 : 	}
; 1051 : 
; 1052 : 	if( HPAK_ResourceForIndex( Cmd_Argv( 1 ), Q_atoi( Cmd_Argv( 2 )), &resource ))

	lea	eax, DWORD PTR _resource$[ebp]
	push	eax
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_HPAK_ResourceForIndex
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@HPAK_Remov

; 1053 : 	{
; 1054 : 		HPAK_RemoveLump( Cmd_Argv( 1 ), &resource );

	lea	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_HPAK_RemoveLump
	add	esp, 8

; 1055 : 	}

	jmp	SHORT $LN1@HPAK_Remov
$LN3@HPAK_Remov:

; 1056 : 	else
; 1057 : 	{
; 1058 : 		Con_DPrintf( S_ERROR "Could not locate resource %i in %s\n", Q_atoi( Cmd_Argv( 2 )), Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	push	eax
	push	OFFSET $SG130369
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN1@HPAK_Remov:

; 1059 : 	}
; 1060 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Remove_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_type$ = -824						; size = 4
_size$ = -820						; size = 4
_nDataSize$ = -816					; size = 4
_pData$ = -812						; size = 4
_directory$ = -808					; size = 8
_nIndex$ = -800						; size = 4
_nCurrent$ = -796					; size = 4
_entry$ = -792						; size = 4
_f$ = -788						; size = 4
_header$ = -784						; size = 12
_szFileOut$ = -772					; size = 256
_lumpname$ = -516					; size = 256
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_HPAK_Extract_f PROC

; 930  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 824				; 00000338H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 931  : 	int		nCurrent;
; 932  : 	hpak_header_t	header;
; 933  : 	hpak_info_t	directory;
; 934  : 	hpak_lump_t	*entry;
; 935  : 	string		lumpname;
; 936  : 	string		pakname;
; 937  : 	string		szFileOut;
; 938  : 	int		nIndex;
; 939  : 	byte		*pData;
; 940  : 	int		nDataSize;
; 941  : 	const char	*type;
; 942  : 	const char	*size;
; 943  : 	file_t		*f;
; 944  : 
; 945  : 	if( Cmd_Argc() != 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	je	SHORT $LN5@HPAK_Extra

; 946  : 	{
; 947  : 		Con_Printf( S_USAGE "hpkextract hpkname [all | single index]\n" );

	push	OFFSET $SG130329
	call	_Con_Printf
	add	esp, 4

; 948  : 		return;

	jmp	$LN1@HPAK_Extra
$LN5@HPAK_Extra:

; 949  : 	}
; 950  : 
; 951  : 	if( !Q_stricmp( Cmd_Argv( 2 ), "all" ))

	push	99999					; 0001869fH
	push	OFFSET $SG130332
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@HPAK_Extra

; 952  : 	{
; 953  : 		nIndex = -1;

	mov	DWORD PTR _nIndex$[ebp], -1

; 954  : 	}

	jmp	SHORT $LN7@HPAK_Extra
$LN6@HPAK_Extra:

; 955  : 	else
; 956  : 	{
; 957  : 		nIndex = Q_atoi( Cmd_Argv( 2 ) );

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _nIndex$[ebp], eax
$LN7@HPAK_Extra:

; 958  : 	}
; 959  : 
; 960  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 961  : 
; 962  : 	Q_strncpy( pakname, Cmd_Argv( 1 ), sizeof( pakname ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 963  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130333
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_COM_ReplaceExtension
	add	esp, 8

; 964  : 	Con_Printf( "Contents for %s.\n", pakname );

	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130334
	call	_Con_Printf
	add	esp, 8

; 965  : 
; 966  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET $SG130335
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 967  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@HPAK_Extra

; 968  : 	{
; 969  : 		Con_DPrintf( S_ERROR "couldn't open %s.\n", pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130337
	call	_Con_DPrintf
	add	esp, 8

; 970  : 		return;

	jmp	$LN1@HPAK_Extra
$LN8@HPAK_Extra:

; 971  : 	}
; 972  : 
; 973  : 	FS_Read( f, &header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 974  : 
; 975  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN9@HPAK_Extra

; 976  : 	{
; 977  : 		Con_DPrintf( S_ERROR "%s is not an HPAK file\n", pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130339
	call	_Con_DPrintf
	add	esp, 8

; 978  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 979  : 		return;

	jmp	$LN1@HPAK_Extra
$LN9@HPAK_Extra:

; 980  : 	}
; 981  : 
; 982  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN10@HPAK_Extra

; 983  : 	{
; 984  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130341
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 985  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 986  : 		return;

	jmp	$LN1@HPAK_Extra
$LN10@HPAK_Extra:

; 987  : 	}
; 988  : 
; 989  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 990  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	edx, DWORD PTR _directory$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 991  : 
; 992  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN12@HPAK_Extra
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN11@HPAK_Extra
$LN12@HPAK_Extra:

; 993  : 	{
; 994  : 		Con_DPrintf( S_ERROR "%s has too many lumps %u.\n", pakname, directory.count );

	mov	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130344
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 995  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 996  : 		return;

	jmp	$LN1@HPAK_Extra
$LN11@HPAK_Extra:

; 997  : 	}
; 998  : 
; 999  : 	if( nIndex == -1 ) Con_Printf( "Extracting all lumps from %s.\n", pakname );

	cmp	DWORD PTR _nIndex$[ebp], -1
	jne	SHORT $LN13@HPAK_Extra
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130347
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN14@HPAK_Extra
$LN13@HPAK_Extra:

; 1000 : 	else Con_Printf( "Extracting lump %i from %s\n", nIndex, pakname );

	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	push	OFFSET $SG130348
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN14@HPAK_Extra:

; 1001 : 
; 1002 : 	directory.entries = Z_Malloc( directory.count * sizeof( hpak_lump_t ));

	push	1002					; 000003eaH
	push	OFFSET $SG130349
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 1003 : 	FS_Read( f, directory.entries, directory.count * sizeof( hpak_lump_t ));

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1004 : 
; 1005 : 	for( nCurrent = 0; nCurrent < directory.count; nCurrent++ )

	mov	DWORD PTR _nCurrent$[ebp], 0
	jmp	SHORT $LN4@HPAK_Extra
$LN2@HPAK_Extra:
	mov	eax, DWORD PTR _nCurrent$[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurrent$[ebp], eax
$LN4@HPAK_Extra:
	mov	ecx, DWORD PTR _nCurrent$[ebp]
	cmp	ecx, DWORD PTR _directory$[ebp]
	jge	$LN3@HPAK_Extra

; 1006 : 	{
; 1007 : 		entry = &directory.entries[nCurrent];

	imul	edx, DWORD PTR _nCurrent$[ebp], 144
	add	edx, DWORD PTR _directory$[ebp+4]
	mov	DWORD PTR _entry$[ebp], edx

; 1008 : 
; 1009 : 		if( nIndex != -1 && nIndex != nCurrent )

	cmp	DWORD PTR _nIndex$[ebp], -1
	je	SHORT $LN15@HPAK_Extra
	mov	eax, DWORD PTR _nIndex$[ebp]
	cmp	eax, DWORD PTR _nCurrent$[ebp]
	je	SHORT $LN15@HPAK_Extra

; 1010 : 			continue;

	jmp	SHORT $LN2@HPAK_Extra
$LN15@HPAK_Extra:

; 1011 : 
; 1012 : 		COM_FileBase( entry->resource.szFileName, lumpname );

	lea	ecx, DWORD PTR _lumpname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 1013 : 		type = HPAK_TypeFromIndex( entry->resource.type );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_HPAK_TypeFromIndex
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 1014 : 		size = Q_memprint( entry->resource.nDownloadSize );

	push	2
	mov	edx, DWORD PTR _entry$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 1015 : 
; 1016 : 		Con_Printf( "Extracting %i: %10s %s %s\n", nCurrent + 1, type, size, lumpname );

	lea	eax, DWORD PTR _lumpname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _nCurrent$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET $SG130351
	call	_Con_Printf
	add	esp, 20					; 00000014H

; 1017 : 
; 1018 : 		if( entry->disksize <= 0 || entry->disksize >= HPAK_MAX_SIZE )

	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+140], 0
	jle	SHORT $LN17@HPAK_Extra
	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+140], 131072		; 00020000H
	jl	SHORT $LN16@HPAK_Extra
$LN17@HPAK_Extra:

; 1019 : 		{
; 1020 : 			Con_DPrintf( S_WARN "Unable to extract data, size invalid:  %s\n", Q_memprint( entry->disksize ));

	push	2
	mov	eax, DWORD PTR _entry$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+140]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET $SG130354
	call	_Con_DPrintf
	add	esp, 8

; 1021 : 			continue;

	jmp	$LN2@HPAK_Extra
$LN16@HPAK_Extra:

; 1022 : 		}
; 1023 : 
; 1024 : 		nDataSize = entry->disksize;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR _nDataSize$[ebp], edx

; 1025 : 		pData = Z_Malloc( nDataSize + 1 );

	push	1025					; 00000401H
	push	OFFSET $SG130355
	push	0
	mov	eax, DWORD PTR _nDataSize$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pData$[ebp], eax

; 1026 : 		FS_Seek( f, entry->filepos, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+136]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1027 : 		FS_Read( f, pData, nDataSize );

	mov	edx, DWORD PTR _nDataSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1028 : 
; 1029 : 		Q_snprintf( szFileOut, sizeof( szFileOut ), "hpklmps\\lmp%04i.bmp", nCurrent );

	mov	edx, DWORD PTR _nCurrent$[ebp]
	push	edx
	push	OFFSET $SG130356
	push	256					; 00000100H
	lea	eax, DWORD PTR _szFileOut$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1030 : 		FS_WriteFile( szFileOut, pData, nDataSize );

	mov	ecx, DWORD PTR _nDataSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileOut$[ebp]
	push	eax
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 1031 : 		if( pData ) Mem_Free( pData );

	cmp	DWORD PTR _pData$[ebp], 0
	je	SHORT $LN18@HPAK_Extra
	push	1031					; 00000407H
	push	OFFSET $SG130358
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN18@HPAK_Extra:

; 1032 : 	}

	jmp	$LN2@HPAK_Extra
$LN3@HPAK_Extra:

; 1033 : 
; 1034 : 	if( directory.entries )

	cmp	DWORD PTR _directory$[ebp+4], 0
	je	SHORT $LN19@HPAK_Extra

; 1035 : 		Mem_Free( directory.entries );

	push	1035					; 0000040bH
	push	OFFSET $SG130360
	mov	edx, DWORD PTR _directory$[ebp+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN19@HPAK_Extra:

; 1036 : 
; 1037 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@HPAK_Extra:

; 1038 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Extract_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_type$ = -556						; size = 4
_size$ = -552						; size = 4
_entry$ = -548						; size = 4
_nCurrent$ = -544					; size = 4
_directory$ = -540					; size = 8
_f$ = -532						; size = 4
_header$ = -528						; size = 12
_lumpname$ = -516					; size = 256
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_HPAK_List_f PROC

; 852  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 853  : 	int		nCurrent;
; 854  : 	hpak_header_t	header;
; 855  : 	hpak_info_t	directory;
; 856  : 	hpak_lump_t	*entry;
; 857  : 	string		lumpname;
; 858  : 	string		pakname;
; 859  : 	const char	*type;
; 860  : 	const char	*size;
; 861  : 	file_t		*f;
; 862  : 
; 863  : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN5@HPAK_List_

; 864  : 	{
; 865  : 		Con_Printf( S_USAGE "hpklist <hpk>\n" );

	push	OFFSET $SG130287
	call	_Con_Printf
	add	esp, 4

; 866  : 		return;

	jmp	$LN1@HPAK_List_
$LN5@HPAK_List_:

; 867  : 	}
; 868  : 
; 869  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 870  : 
; 871  : 	Q_strncpy( pakname, Cmd_Argv( 1 ), sizeof( pakname ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 872  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130288
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_COM_ReplaceExtension
	add	esp, 8

; 873  : 	Con_Printf( "Contents for %s.\n", pakname );

	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130289
	call	_Con_Printf
	add	esp, 8

; 874  : 
; 875  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET $SG130290
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 876  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN6@HPAK_List_

; 877  : 	{
; 878  : 		Con_DPrintf( S_ERROR "couldn't open %s.\n", pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130292
	call	_Con_DPrintf
	add	esp, 8

; 879  : 		return;

	jmp	$LN1@HPAK_List_
$LN6@HPAK_List_:

; 880  : 	}
; 881  : 
; 882  : 	FS_Read( f, &header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	lea	edx, DWORD PTR _header$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 883  : 
; 884  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN7@HPAK_List_

; 885  : 	{
; 886  : 		Con_DPrintf( S_ERROR "%s is not an HPAK file\n", pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130294
	call	_Con_DPrintf
	add	esp, 8

; 887  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 888  : 		return;

	jmp	$LN1@HPAK_List_
$LN7@HPAK_List_:

; 889  : 	}
; 890  : 
; 891  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN8@HPAK_List_

; 892  : 	{
; 893  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130296
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 894  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 895  : 		return;

	jmp	$LN1@HPAK_List_
$LN8@HPAK_List_:

; 896  : 	}
; 897  : 
; 898  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 899  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	edx, DWORD PTR _directory$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 900  : 
; 901  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN10@HPAK_List_
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN9@HPAK_List_
$LN10@HPAK_List_:

; 902  : 	{
; 903  : 		Con_DPrintf( S_ERROR "%s has too many lumps %u.\n", pakname, directory.count );

	mov	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130299
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 904  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 905  : 		return;

	jmp	$LN1@HPAK_List_
$LN9@HPAK_List_:

; 906  : 	}
; 907  : 
; 908  : 	Con_Printf( "# of Entries:  %i\n", directory.count );

	mov	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	push	OFFSET $SG130300
	call	_Con_Printf
	add	esp, 8

; 909  : 	Con_Printf( "# Type Size FileName : MD5 Hash\n" );

	push	OFFSET $SG130301
	call	_Con_Printf
	add	esp, 4

; 910  : 
; 911  : 	directory.entries = Z_Malloc( directory.count * sizeof( hpak_lump_t ));

	push	911					; 0000038fH
	push	OFFSET $SG130302
	push	0
	imul	edx, DWORD PTR _directory$[ebp], 144
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 912  : 	FS_Read( f, directory.entries, directory.count * sizeof( hpak_lump_t ));

	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _directory$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 913  : 
; 914  : 	for( nCurrent = 0; nCurrent < directory.count; nCurrent++ )

	mov	DWORD PTR _nCurrent$[ebp], 0
	jmp	SHORT $LN4@HPAK_List_
$LN2@HPAK_List_:
	mov	ecx, DWORD PTR _nCurrent$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurrent$[ebp], ecx
$LN4@HPAK_List_:
	mov	edx, DWORD PTR _nCurrent$[ebp]
	cmp	edx, DWORD PTR _directory$[ebp]
	jge	$LN3@HPAK_List_

; 915  : 	{
; 916  : 		entry = &directory.entries[nCurrent];

	imul	eax, DWORD PTR _nCurrent$[ebp], 144
	add	eax, DWORD PTR _directory$[ebp+4]
	mov	DWORD PTR _entry$[ebp], eax

; 917  : 		COM_FileBase( entry->resource.szFileName, lumpname );

	lea	ecx, DWORD PTR _lumpname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 918  : 		type = HPAK_TypeFromIndex( entry->resource.type );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_HPAK_TypeFromIndex
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 919  : 		size = Q_memprint( entry->resource.nDownloadSize );

	push	2
	mov	edx, DWORD PTR _entry$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 920  : 
; 921  : 		Con_Printf( "%i: %10s %s %s\n  :  %s\n", nCurrent + 1, type, size, lumpname, MD5_Print( entry->resource.rgucMD5_hash ));

	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _lumpname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nCurrent$[ebp]
	add	ecx, 1
	push	ecx
	push	OFFSET $SG130303
	call	_Con_Printf
	add	esp, 24					; 00000018H

; 922  : 	}

	jmp	$LN2@HPAK_List_
$LN3@HPAK_List_:

; 923  : 
; 924  : 	if( directory.entries )

	cmp	DWORD PTR _directory$[ebp+4], 0
	je	SHORT $LN11@HPAK_List_

; 925  : 		Mem_Free( directory.entries );

	push	925					; 0000039dH
	push	OFFSET $SG130305
	mov	edx, DWORD PTR _directory$[ebp+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN11@HPAK_List_:

; 926  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@HPAK_List_:

; 927  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_List_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_directory$ = -284					; size = 8
_f$ = -276						; size = 4
_header$ = -272						; size = 12
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_index$ = 12						; size = 4
_pResource$ = 16					; size = 4
_HPAK_ResourceForIndex PROC

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 567  : 	hpak_header_t	header;
; 568  : 	hpak_info_t	directory;
; 569  : 	string		pakname;
; 570  : 	file_t		*f;
; 571  : 
; 572  : 	if( !filename || !filename[0] )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN3@HPAK_Resou
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@HPAK_Resou
$LN3@HPAK_Resou:

; 573  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN2@HPAK_Resou:

; 574  : 
; 575  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 576  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130145
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 577  : 
; 578  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET $SG130146
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 579  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN4@HPAK_Resou

; 580  : 	{
; 581  : 		Con_DPrintf( S_ERROR "couldn't open %s.\n", pakname );

	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130148
	call	_Con_DPrintf
	add	esp, 8

; 582  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN4@HPAK_Resou:

; 583  : 	}
; 584  : 
; 585  : 	FS_Read( f, &header, sizeof( header ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 586  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN5@HPAK_Resou

; 587  : 	{
; 588  : 		Con_DPrintf( S_ERROR "%s is not an HPAK file\n", pakname );

	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130150
	call	_Con_DPrintf
	add	esp, 8

; 589  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 590  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN5@HPAK_Resou:

; 591  : 	}
; 592  : 
; 593  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN6@HPAK_Resou

; 594  : 	{
; 595  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	ecx, DWORD PTR _header$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130152
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 596  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 597  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN6@HPAK_Resou:

; 598  : 	}
; 599  : 
; 600  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _header$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 601  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 602  : 
; 603  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN8@HPAK_Resou
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN7@HPAK_Resou
$LN8@HPAK_Resou:

; 604  : 	{
; 605  : 		Con_DPrintf( S_ERROR "%s has too many lumps %u.\n", pakname, directory.count );

	mov	edx, DWORD PTR _directory$[ebp]
	push	edx
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET $SG130155
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 606  : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 607  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN7@HPAK_Resou:

; 608  : 	}
; 609  : 
; 610  : 	if( index < 1 || index > directory.count )

	cmp	DWORD PTR _index$[ebp], 1
	jl	SHORT $LN10@HPAK_Resou
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _directory$[ebp]
	jle	SHORT $LN9@HPAK_Resou
$LN10@HPAK_Resou:

; 611  : 	{
; 612  : 		Con_DPrintf( S_ERROR "%s, lump with index %i doesn't exist.\n", pakname, index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130158
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 613  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 614  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN9@HPAK_Resou:

; 615  : 	}
; 616  : 
; 617  : 	directory.entries = Z_Malloc( sizeof( hpak_lump_t ) * directory.count );

	push	617					; 00000269H
	push	OFFSET $SG130159
	push	0
	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 618  : 	FS_Read( f, directory.entries, sizeof( hpak_lump_t ) * directory.count );

	imul	edx, DWORD PTR _directory$[ebp], 144
	push	edx
	mov	eax, DWORD PTR _directory$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 619  : 	*pResource = directory.entries[index-1].resource;

	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, 1
	imul	esi, edx, 144
	add	esi, DWORD PTR _directory$[ebp+4]
	mov	ecx, 34					; 00000022H
	mov	edi, DWORD PTR _pResource$[ebp]
	rep movsd

; 620  : 	Z_Free( directory.entries );

	cmp	DWORD PTR _directory$[ebp+4], 0
	je	SHORT $LN11@HPAK_Resou
	push	620					; 0000026cH
	push	OFFSET $SG130161
	mov	eax, DWORD PTR _directory$[ebp+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN11@HPAK_Resou:

; 621  : 	FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 622  : 
; 623  : 	return true;

	mov	eax, 1
$LN1@HPAK_Resou:

; 624  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_ResourceForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_HPAK_ValidatePak PROC

; 466  : {

	push	ebp
	mov	ebp, esp

; 467  : 	HPAK_Validate( filename, true );

	push	1
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_HPAK_Validate
	add	esp, 8

; 468  : }

	pop	ebp
	ret	0
_HPAK_ValidatePak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_dataPak$ = -400					; size = 4
_pRes$ = -396						; size = 4
_num_lumps$ = -392					; size = 4
_f$ = -388						; size = 4
_dataDir$ = -384					; size = 4
_i$ = -380						; size = 4
_MD5_Hash$ = -376					; size = 88
_hdr$ = -288						; size = 12
_pakname$ = -276					; size = 256
_md5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_quiet$ = 12						; size = 4
_HPAK_Validate PROC

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 361  : 	file_t		*f;
; 362  : 	hpak_lump_t	*dataDir;
; 363  : 	hpak_header_t	hdr;
; 364  : 	byte		*dataPak;
; 365  : 	int		i, num_lumps;
; 366  : 	MD5Context_t	MD5_Hash;
; 367  : 	string		pakname;
; 368  : 	resource_t	*pRes;
; 369  : 	char		md5[16];
; 370  : 
; 371  : 	if( quiet ) HPAK_FlushHostQueue();

	cmp	DWORD PTR _quiet$[ebp], 0
	je	SHORT $LN5@HPAK_Valid
	call	_HPAK_FlushHostQueue
$LN5@HPAK_Valid:

; 372  : 
; 373  : 	// not an error - just flush queue
; 374  : 	if( !filename || !*filename )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN7@HPAK_Valid
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@HPAK_Valid
$LN7@HPAK_Valid:

; 375  : 		return true;

	mov	eax, 1
	jmp	$LN1@HPAK_Valid
$LN6@HPAK_Valid:

; 376  : 
; 377  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 378  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130038
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_COM_ReplaceExtension
	add	esp, 8

; 379  : 
; 380  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET $SG130039
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 381  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@HPAK_Valid

; 382  : 	{
; 383  : 		Con_DPrintf( S_ERROR "Couldn't find %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET $SG130041
	call	_Con_DPrintf
	add	esp, 8

; 384  : 		return true;

	mov	eax, 1
	jmp	$LN1@HPAK_Valid
$LN8@HPAK_Valid:

; 385  : 	}
; 386  : 
; 387  : 	if( !quiet ) Con_Printf( "Validating %s\n", pakname );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN9@HPAK_Valid
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130043
	call	_Con_Printf
	add	esp, 8
$LN9@HPAK_Valid:

; 388  : 
; 389  : 	FS_Read( f, &hdr, sizeof( hdr ));

	push	12					; 0000000cH
	lea	edx, DWORD PTR _hdr$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 390  : 	if( hdr.ident != IDHPAKHEADER || hdr.version != IDHPAK_VERSION )

	cmp	DWORD PTR _hdr$[ebp], 1262571592	; 4b415048H
	jne	SHORT $LN11@HPAK_Valid
	cmp	DWORD PTR _hdr$[ebp+4], 1
	je	SHORT $LN10@HPAK_Valid
$LN11@HPAK_Valid:

; 391  : 	{
; 392  : 		Con_DPrintf( S_ERROR "HPAK_ValidatePak: %s does not have a valid HPAK header.\n", pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG130046
	call	_Con_DPrintf
	add	esp, 8

; 393  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 394  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Valid
$LN10@HPAK_Valid:

; 395  : 	}
; 396  : 
; 397  : 	FS_Seek( f, hdr.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _hdr$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 398  : 	FS_Read( f, &num_lumps, sizeof( num_lumps ));

	push	4
	lea	edx, DWORD PTR _num_lumps$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 399  : 
; 400  : 	if( num_lumps < 1 || num_lumps > MAX_FILES_IN_WAD )

	cmp	DWORD PTR _num_lumps$[ebp], 1
	jl	SHORT $LN13@HPAK_Valid
	cmp	DWORD PTR _num_lumps$[ebp], 65535	; 0000ffffH
	jle	SHORT $LN12@HPAK_Valid
$LN13@HPAK_Valid:

; 401  : 	{
; 402  : 		Con_DPrintf( S_ERROR "HPAK_ValidatePak: %s has too many lumps %u.\n", pakname, num_lumps );

	mov	ecx, DWORD PTR _num_lumps$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG130049
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 403  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 404  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Valid
$LN12@HPAK_Valid:

; 405  : 	}
; 406  : 
; 407  : 	if( !quiet ) Con_Printf( "# of Entries:  %i\n", num_lumps );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN14@HPAK_Valid
	mov	ecx, DWORD PTR _num_lumps$[ebp]
	push	ecx
	push	OFFSET $SG130051
	call	_Con_Printf
	add	esp, 8
$LN14@HPAK_Valid:

; 408  : 
; 409  : 	dataDir = Z_Malloc( sizeof( hpak_lump_t ) * num_lumps );

	push	409					; 00000199H
	push	OFFSET $SG130052
	push	0
	imul	edx, DWORD PTR _num_lumps$[ebp], 144
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _dataDir$[ebp], eax

; 410  : 	FS_Read( f, dataDir, sizeof( hpak_lump_t ) * num_lumps );

	imul	ecx, DWORD PTR _num_lumps$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _dataDir$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 411  : 
; 412  : 	if( !quiet ) Con_Printf( "# Type Size FileName : MD5 Hash\n" );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN15@HPAK_Valid
	push	OFFSET $SG130054
	call	_Con_Printf
	add	esp, 4
$LN15@HPAK_Valid:

; 413  : 
; 414  : 	for( i = 0; i < num_lumps; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HPAK_Valid
$LN2@HPAK_Valid:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@HPAK_Valid:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _num_lumps$[ebp]
	jge	$LN3@HPAK_Valid

; 415  : 	{
; 416  : 		if( dataDir[i].disksize < 1 || dataDir[i].disksize > 131071 )

	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	cmp	DWORD PTR [ecx+eax+140], 1
	jl	SHORT $LN17@HPAK_Valid
	imul	edx, DWORD PTR _i$[ebp], 144
	mov	eax, DWORD PTR _dataDir$[ebp]
	cmp	DWORD PTR [eax+edx+140], 131071		; 0001ffffH
	jle	SHORT $LN16@HPAK_Valid
$LN17@HPAK_Valid:

; 417  : 		{
; 418  : 			// odd max size
; 419  : 			Con_DPrintf( S_ERROR "HPAK_ValidatePak: lump %i has invalid size %s\n", i, Q_pretifymem( dataDir[i].disksize, 2 ));

	push	2
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _dataDir$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+140]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG130057
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 420  : 			Mem_Free( dataDir );

	push	420					; 000001a4H
	push	OFFSET $SG130058
	mov	ecx, DWORD PTR _dataDir$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 421  : 			FS_Close(f);

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 422  : 			return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Valid
$LN16@HPAK_Valid:

; 423  : 		}
; 424  : 
; 425  : 		dataPak = Z_Malloc( dataDir[i].disksize );

	push	425					; 000001a9H
	push	OFFSET $SG130059
	push	0
	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	mov	edx, DWORD PTR [ecx+eax+140]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _dataPak$[ebp], eax

; 426  : 		FS_Seek( f, dataDir[i].filepos, SEEK_SET );

	push	0
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _dataDir$[ebp]
	mov	eax, DWORD PTR [edx+ecx+136]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 427  : 		FS_Read( f, dataPak, dataDir[i].disksize );

	imul	edx, DWORD PTR _i$[ebp], 144
	mov	eax, DWORD PTR _dataDir$[ebp]
	mov	ecx, DWORD PTR [eax+edx+140]
	push	ecx
	mov	edx, DWORD PTR _dataPak$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 428  : 
; 429  : 		memset( &MD5_Hash, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	ecx, DWORD PTR _MD5_Hash$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 430  : 		MD5Init( &MD5_Hash );

	lea	edx, DWORD PTR _MD5_Hash$[ebp]
	push	edx
	call	_MD5Init
	add	esp, 4

; 431  : 		MD5Update( &MD5_Hash, dataPak, dataDir[i].disksize );

	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	mov	edx, DWORD PTR [ecx+eax+140]
	push	edx
	mov	eax, DWORD PTR _dataPak$[ebp]
	push	eax
	lea	ecx, DWORD PTR _MD5_Hash$[ebp]
	push	ecx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 432  : 		MD5Final( md5, &MD5_Hash );

	lea	edx, DWORD PTR _MD5_Hash$[ebp]
	push	edx
	lea	eax, DWORD PTR _md5$[ebp]
	push	eax
	call	_MD5Final
	add	esp, 8

; 433  : 
; 434  : 		pRes = &dataDir[i].resource;

	imul	ecx, DWORD PTR _i$[ebp], 144
	add	ecx, DWORD PTR _dataDir$[ebp]
	mov	DWORD PTR _pRes$[ebp], ecx

; 435  : 
; 436  : 		Con_Printf( "%i:      %s %s %s:   ", i, HPAK_TypeFromIndex( pRes->type ),

	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _pRes$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_HPAK_TypeFromIndex
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG130060
	call	_Con_Printf
	add	esp, 20					; 00000014H

; 437  : 		Q_pretifymem( pRes->nDownloadSize, 2 ), pRes->szFileName );  
; 438  : 
; 439  : 		if( memcmp( md5, pRes->rgucMD5_hash, 0x10 ))

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pRes$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	lea	edx, DWORD PTR _md5$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN18@HPAK_Valid

; 440  : 		{
; 441  : 			if( quiet )

	cmp	DWORD PTR _quiet$[ebp], 0
	je	SHORT $LN20@HPAK_Valid

; 442  : 			{
; 443  : 				Con_DPrintf( S_ERROR "HPAK_ValidatePak: %s has invalid checksum.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET $SG130065
	call	_Con_DPrintf
	add	esp, 8

; 444  : 				Mem_Free( dataPak );

	push	444					; 000001bcH
	push	OFFSET $SG130066
	mov	ecx, DWORD PTR _dataPak$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 445  : 				Mem_Free( dataDir );

	push	445					; 000001bdH
	push	OFFSET $SG130067
	mov	edx, DWORD PTR _dataDir$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 446  : 				FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 447  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@HPAK_Valid

; 448  : 			}

	jmp	SHORT $LN21@HPAK_Valid
$LN20@HPAK_Valid:

; 449  : 			else Con_DPrintf( S_ERROR "failed\n" );

	push	OFFSET $SG130068
	call	_Con_DPrintf
	add	esp, 4
$LN21@HPAK_Valid:

; 450  : 		}

	jmp	SHORT $LN22@HPAK_Valid
$LN18@HPAK_Valid:

; 451  : 		else
; 452  : 		{
; 453  : 			if( !quiet ) Con_Printf( "OK\n" );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN22@HPAK_Valid
	push	OFFSET $SG130070
	call	_Con_Printf
	add	esp, 4
$LN22@HPAK_Valid:

; 454  : 		}
; 455  : 
; 456  : 		// at this point, it's passed our checks.
; 457  : 		Mem_Free( dataPak );

	push	457					; 000001c9H
	push	OFFSET $SG130071
	mov	ecx, DWORD PTR _dataPak$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 458  : 	}

	jmp	$LN2@HPAK_Valid
$LN3@HPAK_Valid:

; 459  : 
; 460  : 	Mem_Free( dataDir );

	push	460					; 000001ccH
	push	OFFSET $SG130072
	mov	edx, DWORD PTR _dataDir$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 461  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 462  : 	return true;

	mov	eax, 1
$LN1@HPAK_Valid:

; 463  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hpk$ = 8						; size = 4
_hash$ = 12						; size = 4
_pResource$ = 16					; size = 4
_HPAK_FindResource PROC

; 175  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 176  : 	int	i;
; 177  : 
; 178  : 	for( i = 0; i < hpk->count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HPAK_FindR
$LN2@HPAK_FindR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HPAK_FindR:
	mov	ecx, DWORD PTR _hpk$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@HPAK_FindR

; 179  : 	{
; 180  : 		if( !memcmp( hpk->entries[i].resource.rgucMD5_hash, hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _hash$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _hpk$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+77]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@HPAK_FindR

; 181  : 		{
; 182  : 			if( pResource )

	cmp	DWORD PTR _pResource$[ebp], 0
	je	SHORT $LN6@HPAK_FindR

; 183  : 				*pResource = hpk->entries[i].resource;

	imul	edx, DWORD PTR _i$[ebp], 144
	mov	eax, DWORD PTR _hpk$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, edx
	mov	ecx, 34					; 00000022H
	mov	edi, DWORD PTR _pResource$[ebp]
	rep movsd
$LN6@HPAK_FindR:

; 184  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@HPAK_FindR
$LN5@HPAK_FindR:

; 185  : 		}
; 186  : 	}

	jmp	SHORT $LN2@HPAK_FindR
$LN3@HPAK_FindR:

; 187  : 
; 188  : 	return false;

	xor	eax, eax
$LN1@HPAK_FindR:

; 189  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_FindResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_filelocation$ = -376					; size = 4
_temp$ = -372						; size = 4
_fout$ = -368						; size = 4
_ctx$ = -364						; size = 88
_pakname$ = -276					; size = 256
_md5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pResource$ = 12					; size = 4
_pData$ = 16						; size = 4
_fin$ = 20						; size = 4
_HPAK_CreatePak PROC

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 87   : 	int		filelocation;
; 88   : 	string		pakname;
; 89   : 	char		md5[16];
; 90   : 	char		*temp;
; 91   : 	file_t		*fout;
; 92   : 	MD5Context_t	ctx;
; 93   : 
; 94   : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@HPAK_Creat

; 95   : 		return;

	jmp	$LN1@HPAK_Creat
$LN2@HPAK_Creat:

; 96   : 
; 97   : 	if(( fin != NULL && pData != NULL ) || ( fin == NULL && pData == NULL ))

	cmp	DWORD PTR _fin$[ebp], 0
	je	SHORT $LN5@HPAK_Creat
	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN4@HPAK_Creat
$LN5@HPAK_Creat:
	cmp	DWORD PTR _fin$[ebp], 0
	jne	SHORT $LN3@HPAK_Creat
	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN3@HPAK_Creat
$LN4@HPAK_Creat:

; 98   : 		return;

	jmp	$LN1@HPAK_Creat
$LN3@HPAK_Creat:

; 99   : 
; 100  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 101  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG129899
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 102  : 
; 103  : 	Con_Printf( "creating HPAK %s.\n", pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET $SG129900
	call	_Con_Printf
	add	esp, 8

; 104  : 
; 105  : 	fout = FS_Open( pakname, "wb", false );

	push	0
	push	OFFSET $SG129901
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fout$[ebp], eax

; 106  : 	if( !fout )

	cmp	DWORD PTR _fout$[ebp], 0
	jne	SHORT $LN6@HPAK_Creat

; 107  : 	{
; 108  : 		Con_DPrintf( S_ERROR "HPAK_CreatePak: can't write %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET $SG129903
	call	_Con_DPrintf
	add	esp, 8

; 109  : 		return;

	jmp	$LN1@HPAK_Creat
$LN6@HPAK_Creat:

; 110  : 	}
; 111  : 
; 112  : 	// let's hash it.
; 113  : 	memset( &ctx, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 114  : 	MD5Init( &ctx );

	lea	edx, DWORD PTR _ctx$[ebp]
	push	edx
	call	_MD5Init
	add	esp, 4

; 115  : 
; 116  : 	if( pData == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	$LN7@HPAK_Creat

; 117  : 	{
; 118  : 		// there are better ways
; 119  : 		filelocation = FS_Tell( fin );

	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _filelocation$[ebp], eax

; 120  : 		temp = Z_Malloc( pResource->nDownloadSize );

	push	120					; 00000078H
	push	OFFSET $SG129906
	push	0
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp], eax

; 121  : 		FS_Read( fin, temp, pResource->nDownloadSize );

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 122  : 		FS_Seek( fin, filelocation, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _filelocation$[ebp]
	push	edx
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 123  : 		MD5Update( &ctx, temp, pResource->nDownloadSize );

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 124  : 		Mem_Free( temp );

	push	124					; 0000007cH
	push	OFFSET $SG129907
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 125  : 	}

	jmp	SHORT $LN8@HPAK_Creat
$LN7@HPAK_Creat:

; 126  : 	else
; 127  : 	{
; 128  : 		MD5Update( &ctx, pData, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH
$LN8@HPAK_Creat:

; 129  : 	}
; 130  : 
; 131  : 	MD5Final( md5, &ctx );

	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _md5$[ebp]
	push	edx
	call	_MD5Final
	add	esp, 8

; 132  : 
; 133  : 	if( memcmp( md5, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@HPAK_Creat

; 134  : 	{
; 135  : 		Con_DPrintf( S_ERROR "HPAK_CreatePak: bad checksum for %s. Ignored\n", pakname );

	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	push	OFFSET $SG129909
	call	_Con_DPrintf
	add	esp, 8

; 136  : 		return;

	jmp	$LN1@HPAK_Creat
$LN9@HPAK_Creat:

; 137  : 	}
; 138  : 
; 139  : 	hash_pack_header.ident = IDHPAKHEADER;

	mov	DWORD PTR _hash_pack_header, 1262571592	; 4b415048H

; 140  : 	hash_pack_header.version = IDHPAK_VERSION;

	mov	DWORD PTR _hash_pack_header+4, 1

; 141  : 	hash_pack_header.infotableofs = 0;

	mov	DWORD PTR _hash_pack_header+8, 0

; 142  : 
; 143  : 	FS_Write( fout, &hash_pack_header, sizeof( hash_pack_header ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 144  : 
; 145  : 	hash_pack_info.count = 1;

	mov	DWORD PTR _hash_pack_info, 1

; 146  : 	hash_pack_info.entries = Z_Malloc( sizeof( hpak_lump_t ));

	push	146					; 00000092H
	push	OFFSET $SG129910
	push	0
	push	144					; 00000090H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hash_pack_info+4, eax

; 147  : 	hash_pack_info.entries[0].resource = *pResource;

	mov	edx, 144				; 00000090H
	imul	edi, edx, 0
	add	edi, DWORD PTR _hash_pack_info+4
	mov	ecx, 34					; 00000022H
	mov	esi, DWORD PTR _pResource$[ebp]
	rep movsd

; 148  : 	hash_pack_info.entries[0].filepos = FS_Tell( fout );

	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, 144				; 00000090H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _hash_pack_info+4
	mov	DWORD PTR [ecx+edx+136], eax

; 149  : 	hash_pack_info.entries[0].disksize = pResource->nDownloadSize;

	mov	edx, 144				; 00000090H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _hash_pack_info+4
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx+eax+140], edx

; 150  : 
; 151  : 	if( pData == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN10@HPAK_Creat

; 152  : 	{
; 153  : 		FS_FileCopy( fout, fin, hash_pack_info.entries[0].disksize );

	mov	eax, 144				; 00000090H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hash_pack_info+4
	mov	eax, DWORD PTR [edx+ecx+140]
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 154  : 	}

	jmp	SHORT $LN11@HPAK_Creat
$LN10@HPAK_Creat:

; 155  : 	else
; 156  : 	{
; 157  : 		FS_Write( fout, pData, hash_pack_info.entries[0].disksize );

	mov	eax, 144				; 00000090H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hash_pack_info+4
	mov	eax, DWORD PTR [edx+ecx+140]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN11@HPAK_Creat:

; 158  : 	}
; 159  : 
; 160  : 	filelocation = FS_Tell( fout );

	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _filelocation$[ebp], eax

; 161  : 	FS_Write( fout, &hash_pack_info.count, sizeof( hash_pack_info.count ));

	push	4
	push	OFFSET _hash_pack_info
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 162  : 	FS_Write( fout, &hash_pack_info.entries[0], sizeof( hpak_lump_t ));

	push	144					; 00000090H
	mov	edx, 144				; 00000090H
	imul	eax, edx, 0
	add	eax, DWORD PTR _hash_pack_info+4
	push	eax
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 163  : 
; 164  : 	if( hash_pack_info.entries )

	cmp	DWORD PTR _hash_pack_info+4, 0
	je	SHORT $LN12@HPAK_Creat

; 165  : 		Mem_Free( hash_pack_info.entries );

	push	165					; 000000a5H
	push	OFFSET $SG129914
	mov	edx, DWORD PTR _hash_pack_info+4
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN12@HPAK_Creat:

; 166  : 	memset( &hash_pack_info, 0, sizeof( hpak_info_t ));

	push	8
	push	0
	push	OFFSET _hash_pack_info
	call	_memset
	add	esp, 12					; 0000000cH

; 167  : 
; 168  : 	hash_pack_header.infotableofs = filelocation;

	mov	eax, DWORD PTR _filelocation$[ebp]
	mov	DWORD PTR _hash_pack_header+8, eax

; 169  : 	FS_Seek( fout, 0, SEEK_SET );

	push	0
	push	0
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 170  : 	FS_Write( fout, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 171  : 	FS_Close( fout );

	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@HPAK_Creat:

; 172  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_CreatePak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_p$ = -4						; size = 4
_name$ = 8						; size = 4
_pResource$ = 12					; size = 4
_data$ = 16						; size = 4
_f$ = 20						; size = 4
_HPAK_AddToQueue PROC

; 53   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 54   : 	hash_pack_queue_t	*p;
; 55   : 
; 56   : 	p = Z_Malloc( sizeof( hash_pack_queue_t ));

	push	56					; 00000038H
	push	OFFSET $SG129845
	push	0
	push	152					; 00000098H
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _p$[ebp], eax

; 57   : 	p->name = copystring( name );

	push	57					; 00000039H
	push	OFFSET $SG129846
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 58   : 	p->resource = *pResource;

	mov	edi, DWORD PTR _p$[ebp]
	add	edi, 4
	mov	ecx, 34					; 00000022H
	mov	esi, DWORD PTR _pResource$[ebp]
	rep movsd

; 59   : 	p->size = pResource->nDownloadSize;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+140], ecx

; 60   : 	p->data = Z_Malloc( p->size );

	push	60					; 0000003cH
	push	OFFSET $SG129847
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+144], eax

; 61   : 
; 62   : 	if( data != NULL ) memcpy( p->data, data, p->size );

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN2@HPAK_AddTo
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@HPAK_AddTo
$LN2@HPAK_AddTo:

; 63   : 	else if( f != NULL ) FS_Read( f, p->data, p->size );

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN4@HPAK_AddTo
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@HPAK_AddTo
$LN4@HPAK_AddTo:

; 64   : 	else Host_Error( "HPAK_AddToQueue: data == NULL.\n" );

	push	OFFSET $SG129852
	call	_Host_Error
	add	esp, 4
$LN3@HPAK_AddTo:

; 65   : 
; 66   : 	p->next = gp_hpak_queue;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR [ecx+148], edx

; 67   : 	gp_hpak_queue = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _gp_hpak_queue, eax

; 68   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_AddToQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_type$ = 8						; size = 4
_HPAK_TypeFromIndex PROC

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 39   : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 6
	ja	SHORT $LN2@HPAK_TypeF
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@HPAK_TypeF[ecx*4]
$LN4@HPAK_TypeF:

; 40   : 	{
; 41   : 	case t_sound: return "decal";

	mov	eax, OFFSET $SG129817
	jmp	SHORT $LN1@HPAK_TypeF
$LN5@HPAK_TypeF:

; 42   : 	case t_skin: return "skin";

	mov	eax, OFFSET $SG129819
	jmp	SHORT $LN1@HPAK_TypeF
$LN6@HPAK_TypeF:

; 43   : 	case t_model: return "model";

	mov	eax, OFFSET $SG129821
	jmp	SHORT $LN1@HPAK_TypeF
$LN7@HPAK_TypeF:

; 44   : 	case t_decal: return "decal";

	mov	eax, OFFSET $SG129823
	jmp	SHORT $LN1@HPAK_TypeF
$LN8@HPAK_TypeF:

; 45   : 	case t_generic: return "generic";

	mov	eax, OFFSET $SG129825
	jmp	SHORT $LN1@HPAK_TypeF
$LN9@HPAK_TypeF:

; 46   : 	case t_eventscript: return "event";

	mov	eax, OFFSET $SG129827
	jmp	SHORT $LN1@HPAK_TypeF
$LN10@HPAK_TypeF:

; 47   : 	case t_world: return "map";	

	mov	eax, OFFSET $SG129829
	jmp	SHORT $LN1@HPAK_TypeF
$LN2@HPAK_TypeF:

; 48   : 	}
; 49   : 	return "?";

	mov	eax, OFFSET $SG129830
$LN1@HPAK_TypeF:

; 50   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@HPAK_TypeF:
	DD	$LN4@HPAK_TypeF
	DD	$LN5@HPAK_TypeF
	DD	$LN6@HPAK_TypeF
	DD	$LN7@HPAK_TypeF
	DD	$LN8@HPAK_TypeF
	DD	$LN9@HPAK_TypeF
	DD	$LN10@HPAK_TypeF
_HPAK_TypeFromIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_p$ = -4						; size = 4
_HPAK_FlushHostQueue PROC

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 72   : 	hash_pack_queue_t	*p;
; 73   : 
; 74   : 	for( p = gp_hpak_queue; p != NULL; p = gp_hpak_queue )

	mov	eax, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@HPAK_Flush
$LN2@HPAK_Flush:
	mov	ecx, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], ecx
$LN4@HPAK_Flush:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@HPAK_Flush

; 75   : 	{
; 76   : 		gp_hpak_queue = p->next;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR _gp_hpak_queue, eax

; 77   : 		HPAK_AddLump( false, p->name, &p->resource, p->data, NULL );

	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H

; 78   : 		freestring( p->name );

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@HPAK_Flush
	push	78					; 0000004eH
	push	OFFSET $SG129865
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@HPAK_Flush:

; 79   : 		Mem_Free( p->data );

	push	79					; 0000004fH
	push	OFFSET $SG129866
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 80   : 		Mem_Free( p );

	push	80					; 00000050H
	push	OFFSET $SG129867
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 81   : 	}

	jmp	$LN2@HPAK_Flush
$LN3@HPAK_Flush:

; 82   : 	gp_hpak_queue = NULL;

	mov	DWORD PTR _gp_hpak_queue, 0

; 83   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_FlushHostQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_maxsize$ = -264					; size = 4
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_HPAK_CheckSize PROC

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 485  : 	string	pakname;
; 486  : 	int	maxsize;
; 487  : 
; 488  : 	maxsize = hpk_maxsize->value;

	mov	eax, DWORD PTR _hpk_maxsize
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _maxsize$[ebp], ecx

; 489  : 	if( maxsize <= 0 ) return;

	cmp	DWORD PTR _maxsize$[ebp], 0
	jg	SHORT $LN2@HPAK_Check
	jmp	$LN5@HPAK_Check
$LN2@HPAK_Check:

; 490  : 
; 491  : 	if( !filename || !filename[0] )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN4@HPAK_Check
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN3@HPAK_Check
$LN4@HPAK_Check:

; 492  : 		return;

	jmp	$LN5@HPAK_Check
$LN3@HPAK_Check:

; 493  : 
; 494  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 495  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130092
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 496  : 
; 497  : 	if( FS_FileSize( pakname, false ) > ( maxsize * 1000000 ))

	push	0
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	imul	ecx, DWORD PTR _maxsize$[ebp], 1000000
	cmp	eax, ecx
	jle	SHORT $LN5@HPAK_Check

; 498  : 	{
; 499  : 		Con_Printf( "Server: Size of %s > %f MB, deleting.\n", filename, hpk_maxsize->value );

	mov	edx, DWORD PTR _hpk_maxsize
	cvtss2sd xmm0, DWORD PTR [edx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET $SG130094
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 500  : 		Log_Printf( "Server: Size of %s > %f MB, deleting.\n", filename, hpk_maxsize->value );

	mov	ecx, DWORD PTR _hpk_maxsize
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET $SG130095
	call	_Log_Printf
	add	esp, 16					; 00000010H

; 501  : 		FS_Delete( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4
$LN5@HPAK_Check:

; 502  : 	}
; 503  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_CheckSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_HPAK_CheckIntegrity PROC

; 471  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 472  : 	string	pakname;
; 473  : 
; 474  : 	if( !filename || !filename[0] )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN3@HPAK_Check
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@HPAK_Check
$LN3@HPAK_Check:

; 475  : 		return;

	jmp	SHORT $LN1@HPAK_Check
$LN2@HPAK_Check:

; 476  : 
; 477  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 478  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130083
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 479  : 
; 480  : 	HPAK_ValidatePak( pakname );

	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_HPAK_ValidatePak
	add	esp, 4
$LN1@HPAK_Check:

; 481  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_CheckIntegrity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_hpak_save$ = -548					; size = 8
_j$ = -540						; size = 4
_hpak_read$ = -536					; size = 8
_i$ = -528						; size = 4
_file_src$ = -524					; size = 4
_file_dst$ = -520					; size = 4
_save_path$ = -516					; size = 256
_read_path$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_pResource$ = 12					; size = 4
_HPAK_RemoveLump PROC

; 728  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 729  : 	string		read_path;
; 730  : 	string		save_path;
; 731  : 	file_t		*file_src;
; 732  : 	file_t		*file_dst;
; 733  : 	hpak_info_t	hpak_read;
; 734  : 	hpak_info_t	hpak_save;
; 735  : 	int		i, j;
; 736  : 
; 737  : 	if( !COM_CheckString( name ) || !pResource )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@HPAK_Remov
	cmp	DWORD PTR _pResource$[ebp], 0
	jne	SHORT $LN8@HPAK_Remov
$LN9@HPAK_Remov:

; 738  : 		return;

	jmp	$LN1@HPAK_Remov
$LN8@HPAK_Remov:

; 739  : 
; 740  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 741  : 
; 742  : 	Q_strncpy( read_path, name, sizeof( read_path ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _read_path$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 743  : 	COM_ReplaceExtension( read_path, ".hpk" );

	push	OFFSET $SG130242
	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 744  : 
; 745  : 	file_src = FS_Open( read_path, "rb", false );

	push	0
	push	OFFSET $SG130243
	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_src$[ebp], eax

; 746  : 	if( !file_src )

	cmp	DWORD PTR _file_src$[ebp], 0
	jne	SHORT $LN10@HPAK_Remov

; 747  : 	{
; 748  : 		Con_DPrintf( S_ERROR "%s couldn't open.\n", read_path );

	lea	edx, DWORD PTR _read_path$[ebp]
	push	edx
	push	OFFSET $SG130245
	call	_Con_DPrintf
	add	esp, 8

; 749  : 		return;

	jmp	$LN1@HPAK_Remov
$LN10@HPAK_Remov:

; 750  : 	}
; 751  : 
; 752  : 	Q_strncpy( save_path, read_path, sizeof( save_path ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _save_path$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 753  : 	COM_ReplaceExtension( save_path, ".hp2" );

	push	OFFSET $SG130246
	lea	edx, DWORD PTR _save_path$[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 754  : 	file_dst = FS_Open( save_path, "wb", false );

	push	0
	push	OFFSET $SG130247
	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_dst$[ebp], eax

; 755  : 
; 756  : 	if( !file_dst )

	cmp	DWORD PTR _file_dst$[ebp], 0
	jne	SHORT $LN11@HPAK_Remov

; 757  : 	{
; 758  : 		Con_DPrintf( S_ERROR "%s couldn't open.\n", save_path );

	lea	ecx, DWORD PTR _save_path$[ebp]
	push	ecx
	push	OFFSET $SG130249
	call	_Con_DPrintf
	add	esp, 8

; 759  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 760  : 		return;

	jmp	$LN1@HPAK_Remov
$LN11@HPAK_Remov:

; 761  : 	}
; 762  : 
; 763  : 	FS_Seek( file_src, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 764  : 	FS_Seek( file_dst, 0, SEEK_SET );

	push	0
	push	0
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 765  : 
; 766  : 	// header copy
; 767  : 	FS_Read( file_src, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 768  : 	FS_Write( file_dst, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 769  : 
; 770  : 	if( hash_pack_header.ident != IDHPAKHEADER || hash_pack_header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _hash_pack_header, 1262571592	; 4b415048H
	jne	SHORT $LN13@HPAK_Remov
	cmp	DWORD PTR _hash_pack_header+4, 1
	je	SHORT $LN12@HPAK_Remov
$LN13@HPAK_Remov:

; 771  : 	{
; 772  : 		Con_DPrintf( S_ERROR "%s has invalid header.\n", read_path );

	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	push	OFFSET $SG130252
	call	_Con_DPrintf
	add	esp, 8

; 773  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 774  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 775  : 		FS_Delete( save_path ); // delete temp file

	lea	ecx, DWORD PTR _save_path$[ebp]
	push	ecx
	call	_FS_Delete
	add	esp, 4

; 776  : 		return;

	jmp	$LN1@HPAK_Remov
$LN12@HPAK_Remov:

; 777  : 	}
; 778  : 
; 779  : 	FS_Seek( file_src, hash_pack_header.infotableofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _hash_pack_header+8
	push	edx
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 780  : 	FS_Read( file_src, &hpak_read.count, sizeof( hpak_read.count ));

	push	4
	lea	ecx, DWORD PTR _hpak_read$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 781  : 
; 782  : 	if( hpak_read.count < 1 || hpak_read.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _hpak_read$[ebp], 1
	jl	SHORT $LN15@HPAK_Remov
	cmp	DWORD PTR _hpak_read$[ebp], 32768	; 00008000H
	jle	SHORT $LN14@HPAK_Remov
$LN15@HPAK_Remov:

; 783  : 	{
; 784  : 		Con_DPrintf( S_ERROR "%s has invalid number of lumps.\n", read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	push	OFFSET $SG130255
	call	_Con_DPrintf
	add	esp, 8

; 785  : 		FS_Close( file_src );

	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 786  : 		FS_Close( file_dst );

	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 787  : 		FS_Delete( save_path ); // delete temp file

	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 788  : 		return;

	jmp	$LN1@HPAK_Remov
$LN14@HPAK_Remov:

; 789  : 	}
; 790  : 
; 791  : 	if( hpak_read.count == 1 )

	cmp	DWORD PTR _hpak_read$[ebp], 1
	jne	SHORT $LN16@HPAK_Remov

; 792  : 	{
; 793  : 		Con_DPrintf( S_WARN "%s only has one element, so HPAK will be removed\n", read_path );

	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	push	OFFSET $SG130257
	call	_Con_DPrintf
	add	esp, 8

; 794  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 795  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 796  : 		FS_Delete( read_path );

	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	call	_FS_Delete
	add	esp, 4

; 797  : 		FS_Delete( save_path );

	lea	edx, DWORD PTR _save_path$[ebp]
	push	edx
	call	_FS_Delete
	add	esp, 4

; 798  : 		return;

	jmp	$LN1@HPAK_Remov
$LN16@HPAK_Remov:

; 799  : 	}
; 800  : 
; 801  : 	hpak_save.count = hpak_read.count - 1;

	mov	eax, DWORD PTR _hpak_read$[ebp]
	sub	eax, 1
	mov	DWORD PTR _hpak_save$[ebp], eax

; 802  : 	hpak_read.entries = Z_Malloc( sizeof( hpak_lump_t ) * hpak_read.count );

	push	802					; 00000322H
	push	OFFSET $SG130258
	push	0
	imul	ecx, DWORD PTR _hpak_read$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hpak_read$[ebp+4], eax

; 803  : 	hpak_save.entries = Z_Malloc( sizeof( hpak_lump_t ) * hpak_save.count );

	push	803					; 00000323H
	push	OFFSET $SG130259
	push	0
	imul	eax, DWORD PTR _hpak_save$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hpak_save$[ebp+4], eax

; 804  : 
; 805  : 	FS_Read( file_src, hpak_read.entries, sizeof( hpak_lump_t ) * hpak_read.count );

	imul	edx, DWORD PTR _hpak_read$[ebp], 144
	push	edx
	mov	eax, DWORD PTR _hpak_read$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 806  : 
; 807  : 	if( !HPAK_FindResource( &hpak_read, pResource->rgucMD5_hash, NULL ))

	push	0
	mov	edx, DWORD PTR _pResource$[ebp]
	add	edx, 77					; 0000004dH
	push	edx
	lea	eax, DWORD PTR _hpak_read$[ebp]
	push	eax
	call	_HPAK_FindResource
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@HPAK_Remov

; 808  : 	{
; 809  : 		Con_DPrintf( S_ERROR "HPAK doesn't contain specified lump: %s\n", pResource->szFileName, read_path );

	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	push	OFFSET $SG130261
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 810  : 		Mem_Free( hpak_read.entries );

	push	810					; 0000032aH
	push	OFFSET $SG130262
	mov	eax, DWORD PTR _hpak_read$[ebp+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 811  : 		Mem_Free( hpak_save.entries );

	push	811					; 0000032bH
	push	OFFSET $SG130263
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 812  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 813  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 814  : 		FS_Delete( save_path );

	lea	ecx, DWORD PTR _save_path$[ebp]
	push	ecx
	call	_FS_Delete
	add	esp, 4

; 815  : 		return;

	jmp	$LN1@HPAK_Remov
$LN17@HPAK_Remov:

; 816  : 	}
; 817  : 
; 818  : 	Con_Printf( "Removing %s from HPAK %s.\n", pResource->szFileName, read_path );

	lea	edx, DWORD PTR _read_path$[ebp]
	push	edx
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	push	OFFSET $SG130264
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 819  : 
; 820  : 	// If there's a collision, we've just corrupted this hpak.
; 821  : 	for( i = 0, j = 0; i < hpak_read.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@HPAK_Remov
$LN2@HPAK_Remov:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@HPAK_Remov:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _hpak_read$[ebp]
	jge	$LN3@HPAK_Remov

; 822  : 	{
; 823  : 		if( !memcmp( hpak_read.entries[i].resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _hpak_read$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx+77]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@HPAK_Remov

; 824  : 			continue;

	jmp	SHORT $LN2@HPAK_Remov
$LN18@HPAK_Remov:

; 825  : 
; 826  : 		hpak_save.entries[j] = hpak_read.entries[i];

	imul	esi, DWORD PTR _i$[ebp], 144
	add	esi, DWORD PTR _hpak_read$[ebp+4]
	imul	edi, DWORD PTR _j$[ebp], 144
	add	edi, DWORD PTR _hpak_save$[ebp+4]
	mov	ecx, 36					; 00000024H
	rep movsd

; 827  : 		hpak_save.entries[j].filepos = FS_Tell( file_dst );

	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Tell
	add	esp, 4
	imul	edx, DWORD PTR _j$[ebp], 144
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	mov	DWORD PTR [ecx+edx+136], eax

; 828  : 		FS_Seek( file_src, hpak_read.entries[j].filepos, SEEK_SET );

	push	0
	imul	edx, DWORD PTR _j$[ebp], 144
	mov	eax, DWORD PTR _hpak_read$[ebp+4]
	mov	ecx, DWORD PTR [eax+edx+136]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 829  : 		FS_FileCopy( file_dst, file_src, hpak_save.entries[j].disksize );

	imul	eax, DWORD PTR _j$[ebp], 144
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	mov	edx, DWORD PTR [ecx+eax+140]
	push	edx
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 830  : 		j++;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx

; 831  : 	}

	jmp	$LN2@HPAK_Remov
$LN3@HPAK_Remov:

; 832  : 
; 833  : 	hash_pack_header.infotableofs = FS_Tell( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _hash_pack_header+8, eax

; 834  : 	FS_Write( file_dst, &hpak_save.count, sizeof( hpak_save.count ));

	push	4
	lea	ecx, DWORD PTR _hpak_save$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 835  : 
; 836  : 	for( i = 0; i < hpak_save.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@HPAK_Remov
$LN5@HPAK_Remov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@HPAK_Remov:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _hpak_save$[ebp]
	jge	SHORT $LN6@HPAK_Remov

; 837  : 		FS_Write( file_dst, &hpak_save.entries[i], sizeof( hpak_lump_t ));

	push	144					; 00000090H
	imul	edx, DWORD PTR _i$[ebp], 144
	add	edx, DWORD PTR _hpak_save$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@HPAK_Remov
$LN6@HPAK_Remov:

; 838  : 
; 839  : 	FS_Seek( file_dst, 0, SEEK_SET );

	push	0
	push	0
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 840  : 	FS_Write( file_dst, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 841  : 
; 842  : 	Mem_Free( hpak_read.entries );

	push	842					; 0000034aH
	push	OFFSET $SG130266
	mov	eax, DWORD PTR _hpak_read$[ebp+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 843  : 	Mem_Free( hpak_save.entries );

	push	843					; 0000034bH
	push	OFFSET $SG130267
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 844  : 	FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 845  : 	FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 846  : 
; 847  : 	FS_Delete( read_path );

	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	call	_FS_Delete
	add	esp, 4

; 848  : 	FS_Rename( save_path, read_path );

	lea	edx, DWORD PTR _read_path$[ebp]
	push	edx
	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Rename
	add	esp, 8
$LN1@HPAK_Remov:

; 849  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_RemoveLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_length$ = -668						; size = 4
_position$ = -664					; size = 4
_temp$ = -660						; size = 4
_j$ = -656						; size = 4
_dstpak$ = -652						; size = 8
_srcpak$ = -644						; size = 8
_pCurrentEntry$ = -636					; size = 4
_i$ = -632						; size = 4
_file_src$ = -628					; size = 4
_file_dst$ = -624					; size = 4
_ctx$ = -620						; size = 88
_dstname$ = -532					; size = 256
_srcname$ = -276					; size = 256
_md5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_bUseQueue$ = 8						; size = 4
_name$ = 12						; size = 4
_pResource$ = 16					; size = 4
_pData$ = 20						; size = 4
_pFile$ = 24						; size = 4
_HPAK_AddLump PROC

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 668				; 0000029cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 193  : 	int		i, j, position, length;
; 194  : 	hpak_lump_t	*pCurrentEntry = NULL;

	mov	DWORD PTR _pCurrentEntry$[ebp], 0

; 195  : 	string		srcname, dstname;
; 196  : 	hpak_info_t	srcpak, dstpak;
; 197  : 	file_t		*file_src;
; 198  : 	file_t		*file_dst;
; 199  : 	char		md5[16];
; 200  : 	byte		*temp;
; 201  : 	MD5Context_t	ctx;
; 202  : 
; 203  : 	if( pData == NULL && pFile == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN11@HPAK_AddLu
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN11@HPAK_AddLu

; 204  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN11@HPAK_AddLu:

; 205  : 
; 206  : 	if( pResource->nDownloadSize < HPAK_MIN_SIZE || pResource->nDownloadSize > HPAK_MAX_SIZE )

	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [eax+72], 1024		; 00000400H
	jl	SHORT $LN13@HPAK_AddLu
	mov	ecx, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [ecx+72], 131072		; 00020000H
	jle	SHORT $LN12@HPAK_AddLu
$LN13@HPAK_AddLu:

; 207  : 	{
; 208  : 		Con_Printf( S_ERROR "%s: invalid size %s\n", name, Q_pretifymem( pResource->nDownloadSize, 2 ));

	push	2
	mov	edx, DWORD PTR _pResource$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET $SG129980
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 209  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN12@HPAK_AddLu:

; 210  : 	}
; 211  : 
; 212  : 	// hash it
; 213  : 	memset( &ctx, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 214  : 	MD5Init( &ctx );

	lea	edx, DWORD PTR _ctx$[ebp]
	push	edx
	call	_MD5Init
	add	esp, 4

; 215  : 
; 216  : 	if( pData == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	$LN14@HPAK_AddLu

; 217  : 	{
; 218  : 		// there are better ways
; 219  : 		position = FS_Tell( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _position$[ebp], eax

; 220  : 		temp = Z_Malloc( pResource->nDownloadSize );

	push	220					; 000000dcH
	push	OFFSET $SG129983
	push	0
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp], eax

; 221  : 		FS_Read( pFile, temp, pResource->nDownloadSize );

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 222  : 		FS_Seek( pFile, position, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _position$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 223  : 		MD5Update( &ctx, temp, pResource->nDownloadSize );

	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 224  : 		Mem_Free( temp );

	push	224					; 000000e0H
	push	OFFSET $SG129984
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 225  : 	}

	jmp	SHORT $LN15@HPAK_AddLu
$LN14@HPAK_AddLu:

; 226  : 	else
; 227  : 	{
; 228  : 		MD5Update( &ctx, pData, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH
$LN15@HPAK_AddLu:

; 229  : 	}
; 230  : 
; 231  : 	MD5Final( md5, &ctx );

	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _md5$[ebp]
	push	edx
	call	_MD5Final
	add	esp, 8

; 232  : 
; 233  : 	if( memcmp( md5, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@HPAK_AddLu

; 234  : 	{
; 235  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: bad checksum for %s. Ignored\n", pResource->szFileName );

	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	push	OFFSET $SG129986
	call	_Con_DPrintf
	add	esp, 8

; 236  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN16@HPAK_AddLu:

; 237  : 	}
; 238  : 
; 239  : 	if( bUseQueue )

	cmp	DWORD PTR _bUseQueue$[ebp], 0
	je	SHORT $LN17@HPAK_AddLu

; 240  : 	{
; 241  : 		HPAK_AddToQueue( name, pResource, pData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_HPAK_AddToQueue
	add	esp, 16					; 00000010H

; 242  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN17@HPAK_AddLu:

; 243  : 	}
; 244  : 
; 245  : 	Q_strncpy( srcname, name, sizeof( srcname ));

	push	256					; 00000100H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _srcname$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 246  : 	COM_ReplaceExtension( srcname, ".hpk" );

	push	OFFSET $SG129988
	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 247  : 
; 248  : 	file_src = FS_Open( srcname, "rb", false );

	push	0
	push	OFFSET $SG129989
	lea	ecx, DWORD PTR _srcname$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_src$[ebp], eax

; 249  : 
; 250  : 	if( !file_src )

	cmp	DWORD PTR _file_src$[ebp], 0
	jne	SHORT $LN18@HPAK_AddLu

; 251  : 	{
; 252  : 		// just create new pack
; 253  : 		HPAK_CreatePak( name, pResource, pData, pFile );

	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_HPAK_CreatePak
	add	esp, 16					; 00000010H

; 254  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN18@HPAK_AddLu:

; 255  : 	}
; 256  : 
; 257  : 	Q_strncpy( dstname, srcname, sizeof( dstname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dstname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 258  : 	COM_ReplaceExtension( dstname, ".hp2" );

	push	OFFSET $SG129991
	lea	edx, DWORD PTR _dstname$[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 259  : 
; 260  : 	file_dst = FS_Open( dstname, "wb", false );

	push	0
	push	OFFSET $SG129992
	lea	eax, DWORD PTR _dstname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_dst$[ebp], eax

; 261  : 
; 262  : 	if( !file_dst )

	cmp	DWORD PTR _file_dst$[ebp], 0
	jne	SHORT $LN19@HPAK_AddLu

; 263  : 	{
; 264  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: couldn't open %s.\n", srcname );

	lea	ecx, DWORD PTR _srcname$[ebp]
	push	ecx
	push	OFFSET $SG129994
	call	_Con_DPrintf
	add	esp, 8

; 265  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 266  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN19@HPAK_AddLu:

; 267  : 	}
; 268  : 
; 269  : 	// load headers
; 270  : 	FS_Read( file_src, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 271  : 
; 272  : 	if( hash_pack_header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _hash_pack_header+4, 1
	je	SHORT $LN20@HPAK_AddLu

; 273  : 	{
; 274  : 		// we don't check the HPAK bit for some reason.
; 275  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: %s does not have a valid header.\n", srcname );

	lea	ecx, DWORD PTR _srcname$[ebp]
	push	ecx
	push	OFFSET $SG129996
	call	_Con_DPrintf
	add	esp, 8

; 276  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 277  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN20@HPAK_AddLu:

; 278  : 	}
; 279  : 
; 280  : 	length = FS_FileLength( file_src );

	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_FileLength
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 281  : 	FS_Seek( file_src, 0, SEEK_SET ); // rewind to start of file

	push	0
	push	0
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 282  : 	FS_FileCopy( file_dst, file_src, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 283  : 
; 284  : 	FS_Seek( file_src, hash_pack_header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _hash_pack_header+8
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 285  : 	FS_Read( file_src, &srcpak.count, sizeof( srcpak.count ));

	push	4
	lea	edx, DWORD PTR _srcpak$[ebp]
	push	edx
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 286  : 
; 287  : 	if( srcpak.count < 1 || srcpak.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _srcpak$[ebp], 1
	jl	SHORT $LN22@HPAK_AddLu
	cmp	DWORD PTR _srcpak$[ebp], 32768		; 00008000H
	jle	SHORT $LN21@HPAK_AddLu
$LN22@HPAK_AddLu:

; 288  : 	{
; 289  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: %s contain too many lumps.\n", srcname );

	lea	ecx, DWORD PTR _srcname$[ebp]
	push	ecx
	push	OFFSET $SG129999
	call	_Con_DPrintf
	add	esp, 8

; 290  : 		FS_Close( file_src );

	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 291  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 292  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN21@HPAK_AddLu:

; 293  : 	}
; 294  : 
; 295  : 	// load the data
; 296  : 	srcpak.entries = Z_Malloc( sizeof( hpak_lump_t ) * srcpak.count );

	push	296					; 00000128H
	push	OFFSET $SG130000
	push	0
	imul	ecx, DWORD PTR _srcpak$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _srcpak$[ebp+4], eax

; 297  : 	FS_Read( file_src, srcpak.entries, sizeof( hpak_lump_t ) * srcpak.count );

	imul	eax, DWORD PTR _srcpak$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 298  : 	FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 299  : 
; 300  : 	// check if already exists
; 301  : 	if( HPAK_FindResource( &srcpak, pResource->rgucMD5_hash, NULL ))

	push	0
	mov	ecx, DWORD PTR _pResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	lea	edx, DWORD PTR _srcpak$[ebp]
	push	edx
	call	_HPAK_FindResource
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@HPAK_AddLu

; 302  : 	{
; 303  : 		Z_Free( srcpak.entries );

	cmp	DWORD PTR _srcpak$[ebp+4], 0
	je	SHORT $LN24@HPAK_AddLu
	push	303					; 0000012fH
	push	OFFSET $SG130003
	mov	eax, DWORD PTR _srcpak$[ebp+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN24@HPAK_AddLu:

; 304  : 		FS_Close( file_dst );

	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 305  : 		FS_Delete( dstname );

	lea	edx, DWORD PTR _dstname$[ebp]
	push	edx
	call	_FS_Delete
	add	esp, 4

; 306  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN23@HPAK_AddLu:

; 307  : 	}
; 308  : 
; 309  : 	// make a new container
; 310  : 	dstpak.count = srcpak.count + 1;

	mov	eax, DWORD PTR _srcpak$[ebp]
	add	eax, 1
	mov	DWORD PTR _dstpak$[ebp], eax

; 311  : 	dstpak.entries = Z_Malloc( sizeof( hpak_lump_t ) * dstpak.count );

	push	311					; 00000137H
	push	OFFSET $SG130004
	push	0
	imul	ecx, DWORD PTR _dstpak$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _dstpak$[ebp+4], eax

; 312  : 	memcpy( dstpak.entries, srcpak.entries, srcpak.count );

	mov	eax, DWORD PTR _srcpak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _dstpak$[ebp+4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 313  : 
; 314  : 	for( i = 0; i < srcpak.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HPAK_AddLu
$LN2@HPAK_AddLu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HPAK_AddLu:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _srcpak$[ebp]
	jge	$LN3@HPAK_AddLu

; 315  : 	{
; 316  : 		if( memcmp( md5, srcpak.entries[i].resource.rgucMD5_hash, 16 ))

	push	16					; 00000010H
	imul	edx, DWORD PTR _i$[ebp], 144
	mov	eax, DWORD PTR _srcpak$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx+77]
	push	ecx
	lea	edx, DWORD PTR _md5$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@HPAK_AddLu

; 317  : 		{
; 318  : 			pCurrentEntry = &dstpak.entries[i];

	imul	eax, DWORD PTR _i$[ebp], 144
	add	eax, DWORD PTR _dstpak$[ebp+4]
	mov	DWORD PTR _pCurrentEntry$[ebp], eax

; 319  : 
; 320  : 			for( j = i; j < srcpak.count; j++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN7@HPAK_AddLu
$LN5@HPAK_AddLu:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@HPAK_AddLu:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _srcpak$[ebp]
	jge	SHORT $LN6@HPAK_AddLu

; 321  : 				dstpak.entries[j + 1] = srcpak.entries[j];

	imul	esi, DWORD PTR _j$[ebp], 144
	add	esi, DWORD PTR _srcpak$[ebp+4]
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	imul	edi, ecx, 144
	add	edi, DWORD PTR _dstpak$[ebp+4]
	mov	ecx, 36					; 00000024H
	rep movsd
	jmp	SHORT $LN5@HPAK_AddLu
$LN6@HPAK_AddLu:

; 322  : 		}
; 323  : 	}

	jmp	$LN2@HPAK_AddLu
$LN3@HPAK_AddLu:

; 324  : 
; 325  : 	if( !pCurrentEntry )

	cmp	DWORD PTR _pCurrentEntry$[ebp], 0
	jne	SHORT $LN26@HPAK_AddLu

; 326  : 		pCurrentEntry = &dstpak.entries[dstpak.count-1];

	mov	edx, DWORD PTR _dstpak$[ebp]
	sub	edx, 1
	imul	eax, edx, 144
	add	eax, DWORD PTR _dstpak$[ebp+4]
	mov	DWORD PTR _pCurrentEntry$[ebp], eax
$LN26@HPAK_AddLu:

; 327  : 
; 328  : 	memset( pCurrentEntry, 0, sizeof( hpak_lump_t ));

	push	144					; 00000090H
	push	0
	mov	ecx, DWORD PTR _pCurrentEntry$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 329  : 	FS_Seek( file_dst, hash_pack_header.infotableofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _hash_pack_header+8
	push	edx
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 330  : 	pCurrentEntry->resource = *pResource;

	mov	ecx, 34					; 00000022H
	mov	esi, DWORD PTR _pResource$[ebp]
	mov	edi, DWORD PTR _pCurrentEntry$[ebp]
	rep movsd

; 331  : 	pCurrentEntry->filepos = FS_Tell( file_dst );

	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Tell
	add	esp, 4
	mov	edx, DWORD PTR _pCurrentEntry$[ebp]
	mov	DWORD PTR [edx+136], eax

; 332  : 	pCurrentEntry->disksize = pResource->nDownloadSize;

	mov	eax, DWORD PTR _pCurrentEntry$[ebp]
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+140], edx

; 333  : 
; 334  : 	if( !pData ) FS_FileCopy( file_dst, file_src, pCurrentEntry->disksize );

	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN27@HPAK_AddLu
	mov	eax, DWORD PTR _pCurrentEntry$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN28@HPAK_AddLu
$LN27@HPAK_AddLu:

; 335  : 	else FS_Write( file_dst, pData, pCurrentEntry->disksize );

	mov	ecx, DWORD PTR _pCurrentEntry$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN28@HPAK_AddLu:

; 336  : 
; 337  : 	hash_pack_header.infotableofs = FS_Tell( file_dst );

	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _hash_pack_header+8, eax

; 338  : 	FS_Write( file_dst, &dstpak.count, sizeof( dstpak.count ));

	push	4
	lea	eax, DWORD PTR _dstpak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 339  : 
; 340  : 	for( i = 0; i < dstpak.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@HPAK_AddLu
$LN8@HPAK_AddLu:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@HPAK_AddLu:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dstpak$[ebp]
	jge	SHORT $LN9@HPAK_AddLu

; 341  : 	{
; 342  : 		FS_Write( file_dst, &dstpak.entries[i], sizeof( hpak_lump_t ));

	push	144					; 00000090H
	imul	ecx, DWORD PTR _i$[ebp], 144
	add	ecx, DWORD PTR _dstpak$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 343  : 	}

	jmp	SHORT $LN8@HPAK_AddLu
$LN9@HPAK_AddLu:

; 344  : 
; 345  : 	// finalize
; 346  : 	if( srcpak.entries )

	cmp	DWORD PTR _srcpak$[ebp+4], 0
	je	SHORT $LN29@HPAK_AddLu

; 347  : 		Mem_Free( srcpak.entries );

	push	347					; 0000015bH
	push	OFFSET $SG130010
	mov	eax, DWORD PTR _srcpak$[ebp+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN29@HPAK_AddLu:

; 348  : 	if( dstpak.entries )

	cmp	DWORD PTR _dstpak$[ebp+4], 0
	je	SHORT $LN30@HPAK_AddLu

; 349  : 		Mem_Free( dstpak.entries );

	push	349					; 0000015dH
	push	OFFSET $SG130012
	mov	ecx, DWORD PTR _dstpak$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN30@HPAK_AddLu:

; 350  : 
; 351  : 	FS_Seek( file_dst, 0, SEEK_SET );

	push	0
	push	0
	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 352  : 	FS_Write( file_dst, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 353  : 	FS_Close( file_dst );

	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 354  : 
; 355  : 	FS_Delete( srcname );

	lea	edx, DWORD PTR _srcname$[ebp]
	push	edx
	call	_FS_Delete
	add	esp, 4

; 356  : 	FS_Rename( dstname, srcname );

	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dstname$[ebp]
	push	ecx
	call	_FS_Rename
	add	esp, 8
$LN1@HPAK_AddLu:

; 357  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_AddLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_bFound$ = -292						; size = 4
_directory$ = -288					; size = 8
_p$ = -280						; size = 4
_f$ = -276						; size = 4
_header$ = -272						; size = 12
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_hash$ = 12						; size = 4
_pResource$ = 16					; size = 4
_HPAK_ResourceForHash PROC

; 506  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 507  : 	hpak_info_t	directory;
; 508  : 	hpak_header_t	header;
; 509  : 	string		pakname;
; 510  : 	qboolean		bFound;
; 511  : 	file_t		*f;
; 512  : 	hash_pack_queue_t	*p;
; 513  : 
; 514  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@HPAK_Resou

; 515  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN5@HPAK_Resou:

; 516  : 	
; 517  : 	for( p = gp_hpak_queue; p != NULL; p = p->next )

	mov	ecx, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@HPAK_Resou
$LN2@HPAK_Resou:
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR _p$[ebp], eax
$LN4@HPAK_Resou:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@HPAK_Resou

; 518  : 	{
; 519  : 		if( !Q_stricmp( p->name, filename ) && !memcmp( p->resource.rgucMD5_hash, hash, 16 ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@HPAK_Resou
	push	16					; 00000010H
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 81					; 00000051H
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@HPAK_Resou

; 520  : 		{
; 521  : 			if( pResource != NULL )

	cmp	DWORD PTR _pResource$[ebp], 0
	je	SHORT $LN7@HPAK_Resou

; 522  : 				*pResource = p->resource;

	mov	esi, DWORD PTR _p$[ebp]
	add	esi, 4
	mov	ecx, 34					; 00000022H
	mov	edi, DWORD PTR _pResource$[ebp]
	rep movsd
$LN7@HPAK_Resou:

; 523  : 			return true;

	mov	eax, 1
	jmp	$LN1@HPAK_Resou
$LN6@HPAK_Resou:

; 524  : 		}
; 525  : 	}

	jmp	SHORT $LN2@HPAK_Resou
$LN3@HPAK_Resou:

; 526  : 
; 527  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 528  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130119
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 529  : 
; 530  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET $SG130120
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 531  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@HPAK_Resou
	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN8@HPAK_Resou:

; 532  : 
; 533  : 	FS_Read( f, &header, sizeof( header ));

	push	12					; 0000000cH
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 534  : 
; 535  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN9@HPAK_Resou

; 536  : 	{
; 537  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 538  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN9@HPAK_Resou:

; 539  : 	}
; 540  : 
; 541  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN10@HPAK_Resou

; 542  : 	{
; 543  : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 544  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN10@HPAK_Resou:

; 545  : 	}
; 546  : 
; 547  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _header$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 548  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 549  : 
; 550  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN12@HPAK_Resou
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN11@HPAK_Resou
$LN12@HPAK_Resou:

; 551  : 	{
; 552  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 553  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN11@HPAK_Resou:

; 554  : 	}
; 555  : 
; 556  : 	directory.entries = Z_Malloc( sizeof( hpak_lump_t ) * directory.count );

	push	556					; 0000022cH
	push	OFFSET $SG130126
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 557  : 	FS_Read( f, directory.entries, sizeof( hpak_lump_t ) * directory.count );

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 558  : 	bFound = HPAK_FindResource( &directory, hash, pResource );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	lea	edx, DWORD PTR _directory$[ebp]
	push	edx
	call	_HPAK_FindResource
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bFound$[ebp], eax

; 559  : 	Mem_Free( directory.entries );

	push	559					; 0000022fH
	push	OFFSET $SG130127
	mov	eax, DWORD PTR _directory$[ebp+4]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 560  : 	FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 561  : 
; 562  : 	return bFound;

	mov	eax, DWORD PTR _bFound$[ebp]
$LN1@HPAK_Resou:

; 563  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_ResourceForHash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_i$ = -300						; size = 4
_directory$ = -296					; size = 8
_tmpbuf$ = -288						; size = 4
_entry$ = -284						; size = 4
_p$ = -280						; size = 4
_f$ = -276						; size = 4
_header$ = -272						; size = 12
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pResource$ = 12					; size = 4
_buffer$ = 16						; size = 4
_bufsize$ = 20						; size = 4
_HPAK_GetDataPointer PROC

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 628  : 	byte		*tmpbuf;
; 629  : 	string		pakname;
; 630  : 	hpak_header_t	header;
; 631  : 	hpak_info_t	directory;
; 632  : 	hpak_lump_t	*entry;
; 633  : 	hash_pack_queue_t	*p;
; 634  : 	file_t		*f;
; 635  : 	int		i;
; 636  : 
; 637  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@HPAK_GetDa

; 638  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN8@HPAK_GetDa:

; 639  : 
; 640  : 	if( buffer ) *buffer = NULL;

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN9@HPAK_GetDa
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx], 0
$LN9@HPAK_GetDa:

; 641  : 	if( bufsize ) *bufsize = 0;

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN10@HPAK_GetDa
	mov	edx, DWORD PTR _bufsize$[ebp]
	mov	DWORD PTR [edx], 0
$LN10@HPAK_GetDa:

; 642  : 
; 643  : 	for( p = gp_hpak_queue; p != NULL; p = p->next )

	mov	eax, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@HPAK_GetDa
$LN2@HPAK_GetDa:
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR _p$[ebp], edx
$LN4@HPAK_GetDa:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@HPAK_GetDa

; 644  : 	{
; 645  : 		if( !Q_stricmp(p->name, filename ) && !memcmp( p->resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@HPAK_GetDa
	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@HPAK_GetDa

; 646  : 		{
; 647  : 			if( buffer )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN12@HPAK_GetDa

; 648  : 			{
; 649  : 				tmpbuf = Z_Malloc( p->size );

	push	649					; 00000289H
	push	OFFSET $SG130194
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmpbuf$[ebp], eax

; 650  : 				memcpy( tmpbuf, p->data, p->size );

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	mov	eax, DWORD PTR _tmpbuf$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 651  : 				*buffer = tmpbuf;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR _tmpbuf$[ebp]
	mov	DWORD PTR [ecx], edx
$LN12@HPAK_GetDa:

; 652  : 			}
; 653  : 
; 654  : 			if( bufsize )

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN13@HPAK_GetDa

; 655  : 				*bufsize = p->size;

	mov	eax, DWORD PTR _bufsize$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax], edx
$LN13@HPAK_GetDa:

; 656  : 
; 657  : 			return true;

	mov	eax, 1
	jmp	$LN1@HPAK_GetDa
$LN11@HPAK_GetDa:

; 658  : 		}
; 659  : 	}

	jmp	$LN2@HPAK_GetDa
$LN3@HPAK_GetDa:

; 660  : 
; 661  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 662  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET $SG130196
	lea	edx, DWORD PTR _pakname$[ebp]
	push	edx
	call	_COM_ReplaceExtension
	add	esp, 8

; 663  : 
; 664  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET $SG130197
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 665  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN14@HPAK_GetDa
	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN14@HPAK_GetDa:

; 666  : 
; 667  : 	FS_Read( f, &header, sizeof( header ));

	push	12					; 0000000cH
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 668  : 
; 669  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN15@HPAK_GetDa

; 670  : 	{
; 671  : 		Con_DPrintf( S_ERROR "%s it's not a HPK file.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET $SG130200
	call	_Con_DPrintf
	add	esp, 8

; 672  : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 673  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN15@HPAK_GetDa:

; 674  : 	}
; 675  : 
; 676  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN16@HPAK_GetDa

; 677  : 	{
; 678  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	edx, DWORD PTR _header$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET $SG130202
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 679  : 		FS_Close( f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Close
	add	esp, 4

; 680  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN16@HPAK_GetDa:

; 681  : 	}
; 682  : 
; 683  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _header$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 684  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 685  : 
; 686  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN18@HPAK_GetDa
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN17@HPAK_GetDa
$LN18@HPAK_GetDa:

; 687  : 	{
; 688  : 		Con_DPrintf( S_ERROR "HPAK_GetDataPointer: %s has too many lumps %u.\n", filename, directory.count );

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET $SG130205
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 689  : 		FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 690  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN17@HPAK_GetDa:

; 691  : 	}
; 692  : 
; 693  : 	directory.entries = Z_Malloc( sizeof( hpak_lump_t ) * directory.count );

	push	693					; 000002b5H
	push	OFFSET $SG130206
	push	0
	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 694  : 	FS_Read( f, directory.entries, sizeof( hpak_lump_t ) * directory.count );

	imul	edx, DWORD PTR _directory$[ebp], 144
	push	edx
	mov	eax, DWORD PTR _directory$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 695  : 
; 696  : 	for( i = 0; i < directory.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@HPAK_GetDa
$LN5@HPAK_GetDa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@HPAK_GetDa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _directory$[ebp]
	jge	$LN6@HPAK_GetDa

; 697  : 	{
; 698  : 		entry = &directory.entries[i];

	imul	ecx, DWORD PTR _i$[ebp], 144
	add	ecx, DWORD PTR _directory$[ebp+4]
	mov	DWORD PTR _entry$[ebp], ecx

; 699  : 
; 700  : 		if( !memcmp( entry->resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	edx, DWORD PTR _pResource$[ebp]
	add	edx, 77					; 0000004dH
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN19@HPAK_GetDa

; 701  : 		{
; 702  : 			FS_Seek( f, entry->filepos, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 703  : 
; 704  : 			if( buffer && entry->disksize > 0 )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN20@HPAK_GetDa
	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+140], 0
	jle	SHORT $LN20@HPAK_GetDa

; 705  : 			{
; 706  : 				tmpbuf = Z_Malloc( entry->disksize );

	push	706					; 000002c2H
	push	OFFSET $SG130209
	push	0
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmpbuf$[ebp], eax

; 707  : 				FS_Read( f, tmpbuf, entry->disksize );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _tmpbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 708  : 				*buffer = tmpbuf;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, DWORD PTR _tmpbuf$[ebp]
	mov	DWORD PTR [eax], ecx
$LN20@HPAK_GetDa:

; 709  : 			}
; 710  : 
; 711  : 			if( bufsize )

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN21@HPAK_GetDa

; 712  : 				*bufsize = entry->disksize;

	mov	edx, DWORD PTR _bufsize$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR [edx], ecx
$LN21@HPAK_GetDa:

; 713  : 
; 714  : 			Mem_Free( directory.entries );

	push	714					; 000002caH
	push	OFFSET $SG130211
	mov	edx, DWORD PTR _directory$[ebp+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 715  : 			FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 716  : 
; 717  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@HPAK_GetDa
$LN19@HPAK_GetDa:

; 718  : 		}
; 719  : 	}

	jmp	$LN5@HPAK_GetDa
$LN6@HPAK_GetDa:

; 720  : 
; 721  : 	Mem_Free( directory.entries );

	push	721					; 000002d1H
	push	OFFSET $SG130212
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 722  : 	FS_Close( f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Close
	add	esp, 4

; 723  : 
; 724  : 	return false;

	xor	eax, eax
$LN1@HPAK_GetDa:

; 725  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_GetDataPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\documents\github\xashtasks\xash_build4529_src\engine\common\hpak.c
_TEXT	SEGMENT
_HPAK_Init PROC

; 1074 : {

	push	ebp
	mov	ebp, esp

; 1075 : 	Cmd_AddCommand( "hpklist", HPAK_List_f, "list all files in specified HPK-file" );

	push	OFFSET $SG130378
	push	OFFSET _HPAK_List_f
	push	OFFSET $SG130379
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1076 : 	Cmd_AddCommand( "hpkremove", HPAK_Remove_f, "remove specified file from HPK-file" );

	push	OFFSET $SG130380
	push	OFFSET _HPAK_Remove_f
	push	OFFSET $SG130381
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1077 : 	Cmd_AddCommand( "hpkval", HPAK_Validate_f, "validate specified HPK-file" );

	push	OFFSET $SG130382
	push	OFFSET _HPAK_Validate_f
	push	OFFSET $SG130383
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1078 : 	Cmd_AddCommand( "hpkextract", HPAK_Extract_f, "extract all lumps from specified HPK-file" );

	push	OFFSET $SG130384
	push	OFFSET _HPAK_Extract_f
	push	OFFSET $SG130385
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1079 : 	hpk_maxsize = Cvar_Get( "hpk_maxsize", "0", FCVAR_ARCHIVE, "set limit by size for all HPK-files ( 0 - unlimited )" );

	push	OFFSET $SG130386
	push	1
	push	OFFSET $SG130387
	push	OFFSET $SG130388
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hpk_maxsize, eax

; 1080 : 
; 1081 : 	gp_hpak_queue = NULL;

	mov	DWORD PTR _gp_hpak_queue, 0

; 1082 : }

	pop	ebp
	ret	0
_HPAK_Init ENDP
_TEXT	ENDS
END
