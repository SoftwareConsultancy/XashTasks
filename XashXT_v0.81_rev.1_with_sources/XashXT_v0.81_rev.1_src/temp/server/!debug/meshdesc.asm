; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\server\physics\meshdesc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG74428 DB	'%s have too many triangles (%i)', 0aH, 00H
	ORG $+3
$SG74501 DB	'AddMeshTriangle: %s overflow (%i >= %i)', 0aH, 00H
	ORG $+3
$SG74545 DB	'FinishMeshBuild: failed to build triangle mesh (no sides'
	DB	')', 0aH, 00H
	ORG $+1
$SG74768 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG74771 DB	'0', 00H, 00H, 00H
$SG74601 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74602 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG74645 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG74777 DB	'0', 00H, 00H, 00H
$SG74646 DB	'(', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '+', 00H, ' ', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '(', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG74781 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG74647 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG74783 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG74648 DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')'
	DB	00H, 00H, 00H
$SG74720 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+4
$SG74721 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
	ORG $+4
$SG74767 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74770 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74776 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74780 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74782 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	??0mplane_s@@QAE@XZ				; mplane_s::mplane_s
PUBLIC	??0mmesh_t@@QAE@XZ				; mmesh_t::mmesh_t
PUBLIC	??0CMeshDesc@@QAE@XZ				; CMeshDesc::CMeshDesc
PUBLIC	??1CMeshDesc@@QAE@XZ				; CMeshDesc::~CMeshDesc
PUBLIC	?InitMeshBuild@CMeshDesc@@QAE_NPBDH@Z		; CMeshDesc::InitMeshBuild
PUBLIC	?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z	; CMeshDesc::AddMeshTrinagle
PUBLIC	?FinishMeshBuild@CMeshDesc@@QAE_NXZ		; CMeshDesc::FinishMeshBuild
PUBLIC	?FreeMesh@CMeshDesc@@QAEXXZ			; CMeshDesc::FreeMesh
PUBLIC	?InsertLinkBefore@CMeshDesc@@QAEXPAUlink_s@@0@Z	; CMeshDesc::InsertLinkBefore
PUBLIC	?RemoveLink@CMeshDesc@@QAEXPAUlink_s@@@Z	; CMeshDesc::RemoveLink
PUBLIC	?ClearLink@CMeshDesc@@QAEXPAUlink_s@@@Z		; CMeshDesc::ClearLink
PUBLIC	?CreateAreaNode@CMeshDesc@@QAEPAUareanode_s@@HABVVector@@0@Z ; CMeshDesc::CreateAreaNode
PUBLIC	?RelinkFacet@CMeshDesc@@QAEXPAUmfacet_t@@@Z	; CMeshDesc::RelinkFacet
PUBLIC	?CheckMesh@CMeshDesc@@QAEPAUmmesh_t@@ABVVector@@0@Z ; CMeshDesc::CheckMesh
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_memset:PROC
EXTRN	_calloc:PROC
EXTRN	_sqrt:PROC
EXTRN	?ClearBounds@@YAXAAVVector@@0@Z:PROC		; ClearBounds
EXTRN	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z:PROC	; AddPointToBounds
EXTRN	?PlaneFromPoints@@YA_NQBVVector@@PAUmplane_s@@@Z:PROC ; PlaneFromPoints
EXTRN	?ComparePlanes@@YA_NPAUmplane_s@@ABVVector@@M@Z:PROC ; ComparePlanes
EXTRN	?CategorizePlane@@YAXPAUmplane_s@@@Z:PROC	; CategorizePlane
EXTRN	?SnapPlaneToGrid@@YAXPAUmplane_s@@@Z:PROC	; SnapPlaneToGrid
EXTRN	?SnapVectorToGrid@@YAXAAVVector@@@Z:PROC	; SnapVectorToGrid
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z$0
__ehfuncinfo$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1CMeshDesc@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
?CheckMesh@CMeshDesc@@QAEPAUmmesh_t@@ABVVector@@0@Z PROC ; CMeshDesc::CheckMesh
; _this$ = ecx

; 355  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 	if( origin == m_origin && angles == m_angles )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN2@CheckMesh
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN2@CheckMesh

; 357  : 		return &m_mesh;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@CheckMesh
$LN2@CheckMesh:

; 358  : 
; 359  : 	// release old copy
; 360  : 	FreeMesh ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMesh@CMeshDesc@@QAEXXZ		; CMeshDesc::FreeMesh

; 361  : 
; 362  : 	// position are changed. Cache new values and rebuild mesh
; 363  : 	m_origin = origin;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 364  : 	m_angles = angles;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 365  : 
; 366  : 	return NULL;

	xor	eax, eax
$LN1@CheckMesh:

; 367  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CheckMesh@CMeshDesc@@QAEPAUmmesh_t@@ABVVector@@0@Z ENDP ; CMeshDesc::CheckMesh
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_node$ = -4						; size = 4
_facet$ = 8						; size = 4
?RelinkFacet@CMeshDesc@@QAEXPAUmfacet_t@@@Z PROC	; CMeshDesc::RelinkFacet
; _this$ = ecx

; 304  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 305  : 	// find the first node that the facet box crosses
; 306  : 	areanode_t *node = areanodes;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR _node$[ebp], eax
$LN2@RelinkFace:

; 307  : 
; 308  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@RelinkFace

; 309  : 	{
; 310  : 		if( node->axis == -1 ) break;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN4@RelinkFace
	jmp	SHORT $LN3@RelinkFace
$LN4@RelinkFace:

; 311  : 		if( facet->mins[node->axis] > node->dist )

	mov	ecx, DWORD PTR _facet$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	comiss	xmm0, DWORD PTR [ecx+4]
	jbe	SHORT $LN5@RelinkFace

; 312  : 			node = node->children[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _node$[ebp], edx
	jmp	SHORT $LN8@RelinkFace
$LN5@RelinkFace:

; 313  : 		else if( facet->maxs[node->axis] < node->dist )

	mov	ecx, DWORD PTR _facet$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, DWORD PTR [eax+edx*4]
	jbe	SHORT $LN7@RelinkFace

; 314  : 			node = node->children[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _node$[ebp], ecx

; 315  : 		else break; // crosses the node

	jmp	SHORT $LN8@RelinkFace
$LN7@RelinkFace:
	jmp	SHORT $LN3@RelinkFace
$LN8@RelinkFace:

; 316  : 	}

	jmp	SHORT $LN2@RelinkFace
$LN3@RelinkFace:

; 317  : 	
; 318  : 	// link it in	
; 319  : 	InsertLinkBefore( &facet->area, &node->solid_edicts );

	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _facet$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertLinkBefore@CMeshDesc@@QAEXPAUlink_s@@0@Z ; CMeshDesc::InsertLinkBefore

; 320  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RelinkFacet@CMeshDesc@@QAEXPAUmfacet_t@@@Z ENDP	; CMeshDesc::RelinkFacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 12
_mins1$ = -72						; size = 12
_maxs2$ = -60						; size = 12
_maxs1$ = -48						; size = 12
_mins2$ = -36						; size = 12
_size$ = -24						; size = 12
tv166 = -12						; size = 4
_this$ = -8						; size = 4
_anode$ = -4						; size = 4
_depth$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
?CreateAreaNode@CMeshDesc@@QAEPAUareanode_s@@HABVVector@@0@Z PROC ; CMeshDesc::CreateAreaNode
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	areanode_t	*anode;
; 66   : 	Vector		size;

	lea	ecx, DWORD PTR _size$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 67   : 	Vector		mins1, maxs1;

	lea	ecx, DWORD PTR _mins1$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _maxs1$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 68   : 	Vector		mins2, maxs2;

	lea	ecx, DWORD PTR _mins2$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _maxs2$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 69   : 
; 70   : 	anode = &areanodes[numareanodes++];

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+1348], 40
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+68]
	mov	DWORD PTR _anode$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1348]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1348], edx

; 71   : 
; 72   : 	// use 'solid_edicts' to store facets
; 73   : 	ClearLink( &anode->solid_edicts );

	mov	ecx, DWORD PTR _anode$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearLink@CMeshDesc@@QAEXPAUlink_s@@@Z	; CMeshDesc::ClearLink

; 74   : 	
; 75   : 	if( depth == AREA_DEPTH )

	cmp	DWORD PTR _depth$[ebp], 4
	jne	SHORT $LN2@CreateArea

; 76   : 	{
; 77   : 		anode->axis = -1;

	mov	edx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [edx], -1

; 78   : 		anode->children[0] = anode->children[1] = NULL;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0

; 79   : 		return anode;

	mov	eax, DWORD PTR _anode$[ebp]
	jmp	$LN1@CreateArea
$LN2@CreateArea:

; 80   : 	}
; 81   : 	
; 82   : 	size = maxs - mins;

	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _size$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _size$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _size$[ebp+8], eax

; 83   : 
; 84   : 	if( size[0] > size[1] )

	lea	ecx, DWORD PTR _size$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, 4
	imul	edi, ecx, 0
	lea	ecx, DWORD PTR _size$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN3@CreateArea

; 85   : 		anode->axis = 0;

	mov	eax, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN4@CreateArea
$LN3@CreateArea:

; 86   : 	else anode->axis = 1;

	mov	ecx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [ecx], 1
$LN4@CreateArea:

; 87   : 	
; 88   : 	anode->dist = 0.5f * ( maxs[anode->axis] + mins[anode->axis] );

	mov	ecx, DWORD PTR _maxs$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	edx, DWORD PTR _anode$[ebp]
	mov	edi, DWORD PTR [edx]
	mov	ecx, DWORD PTR _mins$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [esi+edi*4]
	addss	xmm0, DWORD PTR [eax+edx*4]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _anode$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 89   : 	mins1 = mins;	

	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _mins1$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _mins1$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _mins1$[ebp+8], ecx

; 90   : 	mins2 = mins;	

	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _mins2$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _mins2$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _mins2$[ebp+8], edx

; 91   : 	maxs1 = maxs;	

	mov	eax, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _maxs1$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _maxs1$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _maxs1$[ebp+8], eax

; 92   : 	maxs2 = maxs;	

	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _maxs2$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _maxs2$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _maxs2$[ebp+8], ecx

; 93   : 	
; 94   : 	maxs1[anode->axis] = mins2[anode->axis] = anode->dist;

	lea	ecx, DWORD PTR _mins2$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _anode$[ebp]
	mov	ecx, DWORD PTR [edx]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv166[ebp], edx
	mov	eax, DWORD PTR tv166[ebp]
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	lea	ecx, DWORD PTR _maxs1$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv166[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx*4], ecx

; 95   : 	anode->children[0] = CreateAreaNode( depth+1, mins2, maxs2 );

	lea	edx, DWORD PTR _maxs2$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateAreaNode@CMeshDesc@@QAEPAUareanode_s@@HABVVector@@0@Z ; CMeshDesc::CreateAreaNode
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 96   : 	anode->children[1] = CreateAreaNode( depth+1, mins1, maxs1 );

	lea	eax, DWORD PTR _maxs1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateAreaNode@CMeshDesc@@QAEPAUareanode_s@@HABVVector@@0@Z ; CMeshDesc::CreateAreaNode
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 97   : 
; 98   : 	return anode;

	mov	eax, DWORD PTR _anode$[ebp]
$LN1@CreateArea:

; 99   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreateAreaNode@CMeshDesc@@QAEPAUareanode_s@@HABVVector@@0@Z ENDP ; CMeshDesc::CreateAreaNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
?ClearLink@CMeshDesc@@QAEXPAUlink_s@@@Z PROC		; CMeshDesc::ClearLink
; _this$ = ecx

; 52   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 	l->prev = l->next = l;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR [edx], eax

; 54   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearLink@CMeshDesc@@QAEXPAUlink_s@@@Z ENDP		; CMeshDesc::ClearLink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
?RemoveLink@CMeshDesc@@QAEXPAUlink_s@@@Z PROC		; CMeshDesc::RemoveLink
; _this$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 	l->next->prev = l->prev;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 48   : 	l->prev->next = l->next;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveLink@CMeshDesc@@QAEXPAUlink_s@@@Z ENDP		; CMeshDesc::RemoveLink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
_before$ = 12						; size = 4
?InsertLinkBefore@CMeshDesc@@QAEXPAUlink_s@@0@Z PROC	; CMeshDesc::InsertLinkBefore
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 	l->next = before;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _before$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 40   : 	l->prev = before->prev;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _before$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 41   : 	l->prev->next = l;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 42   : 	l->next->prev = l;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [eax], ecx

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?InsertLinkBefore@CMeshDesc@@QAEXPAUlink_s@@0@Z ENDP	; CMeshDesc::InsertLinkBefore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
?FreeMesh@CMeshDesc@@QAEXXZ PROC			; CMeshDesc::FreeMesh
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	if( m_mesh.numfacets <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jg	SHORT $LN5@FreeMesh

; 104  : 		return;

	jmp	SHORT $LN1@FreeMesh
$LN5@FreeMesh:

; 105  : 
; 106  : 	// free all allocated memory by this mesh
; 107  : 	for( int i = 0; i < m_mesh.numfacets; i++ )

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@FreeMesh
$LN2@FreeMesh:
	mov	ecx, DWORD PTR _i$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$3[ebp], ecx
$LN4@FreeMesh:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN3@FreeMesh

; 108  : 		delete [] m_mesh.facets[i].planes;

	imul	ecx, DWORD PTR _i$3[ebp], 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+ecx+36]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	jmp	SHORT $LN2@FreeMesh
$LN3@FreeMesh:

; 109  : 	delete [] m_mesh.facets;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 110  : 
; 111  : 	m_mesh.facets = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 112  : 	m_mesh.numfacets = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$LN1@FreeMesh:

; 113  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FreeMesh@CMeshDesc@@QAEXXZ ENDP			; CMeshDesc::FreeMesh
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
tv86 = -20						; size = 4
tv78 = -16						; size = 4
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
?FinishMeshBuild@CMeshDesc@@QAE_NXZ PROC		; CMeshDesc::FinishMeshBuild
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	if( m_mesh.numfacets <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jg	SHORT $LN8@FinishMesh

; 325  : 	{
; 326  : 		FreeMesh();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMesh@CMeshDesc@@QAEXXZ		; CMeshDesc::FreeMesh

; 327  : 		ALERT( at_error, "FinishMeshBuild: failed to build triangle mesh (no sides)\n" );

	push	OFFSET $SG74545
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 328  : 		return false;

	xor	al, al
	jmp	$LN1@FinishMesh
$LN8@FinishMesh:

; 329  : 	}
; 330  : 
; 331  : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@FinishMesh
$LN2@FinishMesh:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@FinishMesh:
	cmp	DWORD PTR _i$2[ebp], 3
	jge	SHORT $LN3@FinishMesh

; 332  : 	{
; 333  : 		// spread the mins / maxs by a pixel
; 334  : 		m_mesh.mins[i] -= 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR tv78[ebp]
	movss	DWORD PTR [edx], xmm0

; 335  : 		m_mesh.maxs[i] += 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$2[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR tv86[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv86[ebp]
	movss	DWORD PTR [ecx], xmm0

; 336  : 	}

	jmp	SHORT $LN2@FinishMesh
$LN3@FinishMesh:

; 337  : 
; 338  : 	if( has_tree )

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1352]
	test	eax, eax
	je	SHORT $LN6@FinishMesh

; 339  : 	{
; 340  : 		// create tree
; 341  : 		CreateAreaNode( 0, m_mesh.mins, m_mesh.maxs );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateAreaNode@CMeshDesc@@QAEPAUareanode_s@@HABVVector@@0@Z ; CMeshDesc::CreateAreaNode

; 342  : 
; 343  : 		for( int i = 0; i < m_mesh.numfacets; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@FinishMesh
$LN5@FinishMesh:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN7@FinishMesh:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN6@FinishMesh

; 344  : 			RelinkFacet( &m_mesh.facets[i] );

	imul	eax, DWORD PTR _i$1[ebp], 40
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkFacet@CMeshDesc@@QAEXPAUmfacet_t@@@Z ; CMeshDesc::RelinkFacet
	jmp	SHORT $LN5@FinishMesh
$LN6@FinishMesh:

; 345  : 	}
; 346  : 
; 347  : #if 0
; 348  : 	size_t size = sizeof( m_mesh ) + ( m_mesh.numfacets * sizeof( mfacet_t )) + ( m_iTotalPlanes * sizeof( mplane_t ));
; 349  : 	ALERT( at_aiconsole, "FinishMeshBuild: %s %i k\n", m_debugName, ( size / 1024 ));
; 350  : #endif
; 351  : 	return true;

	mov	al, 1
$LN1@FinishMesh:

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FinishMeshBuild@CMeshDesc@@QAE_NXZ ENDP		; CMeshDesc::FinishMeshBuild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
$T2 = -840						; size = 12
$T3 = -828						; size = 12
$T4 = -816						; size = 12
_vec2$5 = -804						; size = 12
_k$6 = -792						; size = 4
$T7 = -788						; size = 4
_d$8 = -784						; size = 4
tv599 = -780						; size = 4
tv571 = -776						; size = 4
tv674 = -772						; size = 4
tv528 = -768						; size = 4
tv672 = -764						; size = 4
tv354 = -760						; size = 4
tv347 = -756						; size = 4
tv322 = -752						; size = 4
$T9 = -748						; size = 4
_vec$10 = -744						; size = 12
$T11 = -732						; size = 4
_axis$12 = -728						; size = 4
_dir$13 = -724						; size = 4
_dist$ = -720						; size = 4
_dir$14 = -716						; size = 4
_normal$ = -712						; size = 12
_axis$15 = -700						; size = 4
_this$ = -696						; size = 4
_facet$ = -692						; size = 4
_numplanes$ = -688					; size = 4
_j$16 = -684						; size = 4
_i$ = -680						; size = 4
_mainplane$ = -676					; size = 20
_planes$ = -656						; size = 640
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_triangle$ = 8						; size = 4
?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z PROC	; CMeshDesc::AddMeshTrinagle
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 828				; 0000033cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	int	i;
; 144  : 
; 145  : 	if( m_iNumTris <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jg	SHORT $LN41@AddMeshTri

; 146  : 		return false; // were not in a build mode!

	xor	al, al
	jmp	$LN1@AddMeshTri
$LN41@AddMeshTri:

; 147  : 
; 148  : 	if( m_mesh.numfacets >= m_iNumTris )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+40]
	jl	SHORT $LN42@AddMeshTri

; 149  : 	{
; 150  : 		ALERT( at_error, "AddMeshTriangle: %s overflow (%i >= %i)\n", m_debugName, m_mesh.numfacets, m_iNumTris );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	OFFSET $SG74501
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 151  : 		return false;

	xor	al, al
	jmp	$LN1@AddMeshTri
$LN42@AddMeshTri:

; 152  : 	}
; 153  : 
; 154  : 	// add triangle to bounds
; 155  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@AddMeshTri
$LN2@AddMeshTri:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@AddMeshTri:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@AddMeshTri

; 156  : 		AddPointToBounds( triangle[i], m_mesh.mins, m_mesh.maxs );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _triangle$[ebp]
	push	ecx
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@AddMeshTri
$LN3@AddMeshTri:

; 157  : 
; 158  : 	mfacet_t *facet = &m_mesh.facets[m_mesh.numfacets];

	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+24], 40
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _facet$[ebp], eax

; 159  : 	mplane_t mainplane;

	lea	ecx, DWORD PTR _mainplane$[ebp]
	call	??0mplane_s@@QAE@XZ

; 160  : 
; 161  : 	// calculate plane for this triangle
; 162  : 	PlaneFromPoints( triangle, &mainplane );

	lea	edx, DWORD PTR _mainplane$[ebp]
	push	edx
	mov	eax, DWORD PTR _triangle$[ebp]
	push	eax
	call	?PlaneFromPoints@@YA_NQBVVector@@PAUmplane_s@@@Z ; PlaneFromPoints

; 163  : 
; 164  : 	if( ComparePlanes( &mainplane, g_vecZero, 0.0f ))

	add	esp, 4
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _mainplane$[ebp]
	push	ecx
	call	?ComparePlanes@@YA_NPAUmplane_s@@ABVVector@@M@Z ; ComparePlanes
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN43@AddMeshTri

; 165  : 		return false; // bad plane

	xor	al, al
	jmp	$LN1@AddMeshTri
$LN43@AddMeshTri:

; 166  : 
; 167  : 	mplane_t planes[32];

	push	OFFSET ??0mplane_s@@QAE@XZ
	push	32					; 00000020H
	push	20					; 00000014H
	lea	eax, DWORD PTR _planes$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 168  : 	Vector normal;

	lea	ecx, DWORD PTR _normal$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 169  : 	int numplanes;
; 170  : 	float dist;
; 171  : 
; 172  : 	facet->numplanes = numplanes = 0;

	mov	DWORD PTR _numplanes$[ebp], 0
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR _numplanes$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 173  : 
; 174  : 	// add front plane
; 175  : 	SnapPlaneToGrid( &mainplane );

	lea	eax, DWORD PTR _mainplane$[ebp]
	push	eax
	call	?SnapPlaneToGrid@@YAXPAUmplane_s@@@Z	; SnapPlaneToGrid
	add	esp, 4

; 176  : 
; 177  : 	planes[numplanes].normal = mainplane.normal;

	imul	ecx, DWORD PTR _numplanes$[ebp], 20
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, DWORD PTR _mainplane$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _mainplane$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _mainplane$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 178  : 	planes[numplanes].dist = mainplane.dist;

	imul	ecx, DWORD PTR _numplanes$[ebp], 20
	movss	xmm0, DWORD PTR _mainplane$[ebp+12]
	movss	DWORD PTR _planes$[ebp+ecx+12], xmm0

; 179  : 	numplanes++;

	mov	edx, DWORD PTR _numplanes$[ebp]
	add	edx, 1
	mov	DWORD PTR _numplanes$[ebp], edx

; 180  : 
; 181  : 	// calculate mins & maxs
; 182  : 	ClearBounds( facet->mins, facet->maxs );

	mov	eax, DWORD PTR _facet$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _facet$[ebp]
	push	ecx
	call	?ClearBounds@@YAXAAVVector@@0@Z		; ClearBounds
	add	esp, 8

; 183  : 
; 184  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@AddMeshTri
$LN5@AddMeshTri:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@AddMeshTri:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@AddMeshTri

; 185  : 		AddPointToBounds( triangle[i], facet->mins, facet->maxs );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _facet$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _facet$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _triangle$[ebp]
	push	edx
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@AddMeshTri
$LN6@AddMeshTri:

; 186  : 
; 187  : 	// add the axial planes
; 188  : 	for( int axis = 0; axis < 3; axis++ )

	mov	DWORD PTR _axis$15[ebp], 0
	jmp	SHORT $LN10@AddMeshTri
$LN8@AddMeshTri:
	mov	eax, DWORD PTR _axis$15[ebp]
	add	eax, 1
	mov	DWORD PTR _axis$15[ebp], eax
$LN10@AddMeshTri:
	cmp	DWORD PTR _axis$15[ebp], 3
	jge	$LN9@AddMeshTri

; 189  : 	{
; 190  : 		for( int dir = -1; dir <= 1; dir += 2 )

	mov	DWORD PTR _dir$14[ebp], -1
	jmp	SHORT $LN13@AddMeshTri
$LN11@AddMeshTri:
	mov	ecx, DWORD PTR _dir$14[ebp]
	add	ecx, 2
	mov	DWORD PTR _dir$14[ebp], ecx
$LN13@AddMeshTri:
	cmp	DWORD PTR _dir$14[ebp], 1
	jg	$LN12@AddMeshTri

; 191  : 		{
; 192  : 			for( i = 0; i < numplanes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@AddMeshTri
$LN14@AddMeshTri:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN16@AddMeshTri:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jge	SHORT $LN15@AddMeshTri

; 193  : 			{
; 194  : 				if( planes[i].normal[axis] == dir )

	imul	ecx, DWORD PTR _i$[ebp], 20
	lea	ecx, DWORD PTR _planes$[ebp+ecx]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	cvtsi2ss xmm0, DWORD PTR _dir$14[ebp]
	mov	edx, DWORD PTR _axis$15[ebp]
	movss	xmm1, DWORD PTR [eax+edx*4]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN44@AddMeshTri

; 195  : 					break;

	jmp	SHORT $LN15@AddMeshTri
$LN44@AddMeshTri:

; 196  : 			}

	jmp	SHORT $LN14@AddMeshTri
$LN15@AddMeshTri:

; 197  : 
; 198  : 			if( i == numplanes )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jne	$LN45@AddMeshTri

; 199  : 			{
; 200  : 				normal = g_vecZero;

	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR _normal$[ebp], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR _normal$[ebp+4], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR _normal$[ebp+8], eax

; 201  : 				normal[axis] = dir;

	cvtsi2ss xmm0, DWORD PTR _dir$14[ebp]
	lea	ecx, DWORD PTR _normal$[ebp]
	movss	DWORD PTR tv672[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _axis$15[ebp]
	movss	xmm0, DWORD PTR tv672[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0

; 202  : 				if( dir == 1 )

	cmp	DWORD PTR _dir$14[ebp], 1
	jne	SHORT $LN46@AddMeshTri

; 203  : 					dist = facet->maxs[axis];

	mov	ecx, DWORD PTR _facet$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _axis$15[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _dist$[ebp], xmm0
	jmp	SHORT $LN47@AddMeshTri
$LN46@AddMeshTri:

; 204  : 				else dist = -facet->mins[axis];

	mov	ecx, DWORD PTR _facet$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _axis$15[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dist$[ebp], xmm0
$LN47@AddMeshTri:

; 205  : 
; 206  : 				planes[numplanes].normal = normal;

	imul	edx, DWORD PTR _numplanes$[ebp], 20
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, DWORD PTR _normal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _normal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _normal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 207  : 				planes[numplanes].dist = dist;

	imul	edx, DWORD PTR _numplanes$[ebp], 20
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _planes$[ebp+edx+12], xmm0

; 208  : 				numplanes++;

	mov	eax, DWORD PTR _numplanes$[ebp]
	add	eax, 1
	mov	DWORD PTR _numplanes$[ebp], eax
$LN45@AddMeshTri:

; 209  : 			}
; 210  : 		}

	jmp	$LN11@AddMeshTri
$LN12@AddMeshTri:

; 211  : 	}

	jmp	$LN8@AddMeshTri
$LN9@AddMeshTri:

; 212  : 
; 213  : 	// add the edge bevels
; 214  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@AddMeshTri
$LN17@AddMeshTri:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN19@AddMeshTri:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN18@AddMeshTri

; 215  : 	{
; 216  : 		int j = (i + 1) % 3;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _j$16[ebp], edx

; 217  : 		int k = (i + 2) % 3;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _k$6[ebp], edx

; 218  : 
; 219  : 		Vector vec = triangle[i] - triangle[j];

	imul	edx, DWORD PTR _j$16[ebp], 12
	add	edx, DWORD PTR _triangle$[ebp]
	push	edx
	lea	eax, DWORD PTR _vec$10[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _triangle$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 220  : 		if( vec.Length() < 0.5f ) continue;

	lea	ecx, DWORD PTR _vec$10[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR tv528[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR tv528[ebp]
	jbe	SHORT $LN48@AddMeshTri
	jmp	$LN17@AddMeshTri
$LN48@AddMeshTri:

; 221  : 
; 222  : 		vec = vec.Normalize();

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vec$10[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vec$10[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec$10[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vec$10[ebp+8], edx

; 223  : 		SnapVectorToGrid( vec );

	lea	eax, DWORD PTR _vec$10[ebp]
	push	eax
	call	?SnapVectorToGrid@@YAXAAVVector@@@Z	; SnapVectorToGrid
	add	esp, 4

; 224  : 
; 225  : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN22@AddMeshTri
$LN20@AddMeshTri:
	mov	ecx, DWORD PTR _j$16[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$16[ebp], ecx
$LN22@AddMeshTri:
	cmp	DWORD PTR _j$16[ebp], 3
	jge	SHORT $LN21@AddMeshTri

; 226  : 		{
; 227  : 			if( vec[j] == 1.0f || vec[j] == -1.0f )

	lea	ecx, DWORD PTR _vec$10[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _j$16[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN50@AddMeshTri
	lea	ecx, DWORD PTR _vec$10[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$16[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN49@AddMeshTri
$LN50@AddMeshTri:

; 228  : 				break; // axial

	jmp	SHORT $LN21@AddMeshTri
$LN49@AddMeshTri:

; 229  : 		}

	jmp	SHORT $LN20@AddMeshTri
$LN21@AddMeshTri:

; 230  : 
; 231  : 		if( j != 3 ) continue; // only test non-axial edges

	cmp	DWORD PTR _j$16[ebp], 3
	je	SHORT $LN51@AddMeshTri
	jmp	$LN17@AddMeshTri
$LN51@AddMeshTri:

; 232  : 
; 233  : 		// try the six possible slanted axials from this edge
; 234  : 		for( int axis = 0; axis < 3; axis++ )

	mov	DWORD PTR _axis$12[ebp], 0
	jmp	SHORT $LN25@AddMeshTri
$LN23@AddMeshTri:
	mov	edx, DWORD PTR _axis$12[ebp]
	add	edx, 1
	mov	DWORD PTR _axis$12[ebp], edx
$LN25@AddMeshTri:
	cmp	DWORD PTR _axis$12[ebp], 3
	jge	$LN24@AddMeshTri

; 235  : 		{
; 236  : 			for( int dir = -1; dir <= 1; dir += 2 )

	mov	DWORD PTR _dir$13[ebp], -1
	jmp	SHORT $LN28@AddMeshTri
$LN26@AddMeshTri:
	mov	eax, DWORD PTR _dir$13[ebp]
	add	eax, 2
	mov	DWORD PTR _dir$13[ebp], eax
$LN28@AddMeshTri:
	cmp	DWORD PTR _dir$13[ebp], 1
	jg	$LN27@AddMeshTri

; 237  : 			{
; 238  : 				// construct a plane
; 239  : 				Vector vec2 = g_vecZero;

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _vec2$5[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 240  : 				vec2[axis] = dir;

	cvtsi2ss xmm0, DWORD PTR _dir$13[ebp]
	lea	ecx, DWORD PTR _vec2$5[ebp]
	movss	DWORD PTR tv674[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _axis$12[ebp]
	movss	xmm0, DWORD PTR tv674[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0

; 241  : 				normal = CrossProduct( vec, vec2 );

	lea	edx, DWORD PTR _vec2$5[ebp]
	push	edx
	lea	eax, DWORD PTR _vec$10[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _normal$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _normal$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _normal$[ebp+8], edx

; 242  : 
; 243  : 				if( normal.Length() < 0.5f )

	lea	ecx, DWORD PTR _normal$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR tv571[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR tv571[ebp]
	jbe	SHORT $LN52@AddMeshTri

; 244  : 					continue;

	jmp	$LN26@AddMeshTri
$LN52@AddMeshTri:

; 245  : 
; 246  : 				normal = normal.Normalize();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _normal$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _normal$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _normal$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _normal$[ebp+8], eax

; 247  : 				dist = DotProduct( triangle[i], normal );

	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _triangle$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 248  : 
; 249  : 				for( j = 0; j < numplanes; j++ )

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN31@AddMeshTri
$LN29@AddMeshTri:
	mov	eax, DWORD PTR _j$16[ebp]
	add	eax, 1
	mov	DWORD PTR _j$16[ebp], eax
$LN31@AddMeshTri:
	mov	ecx, DWORD PTR _j$16[ebp]
	cmp	ecx, DWORD PTR _numplanes$[ebp]
	jge	SHORT $LN30@AddMeshTri

; 250  : 				{
; 251  : 					// if this plane has already been used, skip it
; 252  : 					if( ComparePlanes( &planes[j], normal, dist ))

	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	imul	eax, DWORD PTR _j$16[ebp], 20
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	push	ecx
	call	?ComparePlanes@@YA_NPAUmplane_s@@ABVVector@@M@Z ; ComparePlanes
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN53@AddMeshTri

; 253  : 						break;

	jmp	SHORT $LN30@AddMeshTri
$LN53@AddMeshTri:

; 254  : 				}

	jmp	SHORT $LN29@AddMeshTri
$LN30@AddMeshTri:

; 255  : 
; 256  : 				if( j != numplanes ) continue;

	mov	eax, DWORD PTR _j$16[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	je	SHORT $LN54@AddMeshTri
	jmp	$LN26@AddMeshTri
$LN54@AddMeshTri:

; 257  : 
; 258  : 				// if all other points are behind this plane, it is a proper edge bevel
; 259  : 				for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN34@AddMeshTri
$LN32@AddMeshTri:
	mov	ecx, DWORD PTR _j$16[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$16[ebp], ecx
$LN34@AddMeshTri:
	cmp	DWORD PTR _j$16[ebp], 3
	jge	SHORT $LN33@AddMeshTri

; 260  : 				{
; 261  : 					if( j != i )

	mov	edx, DWORD PTR _j$16[ebp]
	cmp	edx, DWORD PTR _i$[ebp]
	je	SHORT $LN56@AddMeshTri

; 262  : 					{
; 263  : 						float d = DotProduct( triangle[j], normal ) - dist;

	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	imul	ecx, DWORD PTR _j$16[ebp], 12
	add	ecx, DWORD PTR _triangle$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR tv599[ebp]
	movss	xmm0, DWORD PTR tv599[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _d$8[ebp], xmm0

; 264  : 						// point in front: this plane isn't part of the outer hull
; 265  : 						if( d > 0.1f ) break;

	movss	xmm0, DWORD PTR _d$8[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN56@AddMeshTri
	jmp	SHORT $LN33@AddMeshTri
$LN56@AddMeshTri:

; 266  : 					}
; 267  : 				}

	jmp	SHORT $LN32@AddMeshTri
$LN33@AddMeshTri:

; 268  : 
; 269  : 				if( j != 3 ) continue;

	cmp	DWORD PTR _j$16[ebp], 3
	je	SHORT $LN57@AddMeshTri
	jmp	$LN26@AddMeshTri
$LN57@AddMeshTri:

; 270  : 
; 271  : 				// add this plane
; 272  : 				planes[numplanes].normal = normal;

	imul	edx, DWORD PTR _numplanes$[ebp], 20
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, DWORD PTR _normal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _normal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _normal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 273  : 				planes[numplanes].dist = dist;

	imul	edx, DWORD PTR _numplanes$[ebp], 20
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _planes$[ebp+edx+12], xmm0

; 274  : 				numplanes++;

	mov	eax, DWORD PTR _numplanes$[ebp]
	add	eax, 1
	mov	DWORD PTR _numplanes$[ebp], eax

; 275  : 			}

	jmp	$LN26@AddMeshTri
$LN27@AddMeshTri:

; 276  : 		}

	jmp	$LN23@AddMeshTri
$LN24@AddMeshTri:

; 277  : 	}

	jmp	$LN17@AddMeshTri
$LN18@AddMeshTri:

; 278  : 
; 279  : 	facet->planes = new mplane_t[numplanes];

	mov	ecx, DWORD PTR _numplanes$[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T9[ebp]
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN59@AddMeshTri
	push	OFFSET ??0mplane_s@@QAE@XZ
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR $T11[ebp]
	push	ecx
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR tv322[ebp], edx
	jmp	SHORT $LN60@AddMeshTri
$LN59@AddMeshTri:
	mov	DWORD PTR tv322[ebp], 0
$LN60@AddMeshTri:
	mov	eax, DWORD PTR tv322[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [ecx+36], edx

; 280  : 	facet->numplanes = numplanes;

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR _numplanes$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 281  : 
; 282  : 	for( i = 0; i < facet->numplanes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN37@AddMeshTri
$LN35@AddMeshTri:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN37@AddMeshTri:
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN36@AddMeshTri

; 283  : 	{
; 284  : 		facet->planes[i] = planes[i];

	imul	edx, DWORD PTR _i$[ebp], 20
	lea	eax, DWORD PTR _planes$[ebp+edx]
	imul	ecx, DWORD PTR _i$[ebp], 20
	mov	edx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [edx+36]
	add	edx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], eax

; 285  : 		SnapPlaneToGrid( &facet->planes[i] );

	imul	ecx, DWORD PTR _i$[ebp], 20
	mov	edx, DWORD PTR _facet$[ebp]
	add	ecx, DWORD PTR [edx+36]
	push	ecx
	call	?SnapPlaneToGrid@@YAXPAUmplane_s@@@Z	; SnapPlaneToGrid
	add	esp, 4

; 286  : 		CategorizePlane( &facet->planes[i] );

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _facet$[ebp]
	add	eax, DWORD PTR [ecx+36]
	push	eax
	call	?CategorizePlane@@YAXPAUmplane_s@@@Z	; CategorizePlane
	add	esp, 4

; 287  : 	}

	jmp	$LN35@AddMeshTri
$LN36@AddMeshTri:

; 288  : 
; 289  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN40@AddMeshTri
$LN38@AddMeshTri:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN40@AddMeshTri:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN39@AddMeshTri

; 290  : 	{
; 291  : 		// spread the mins / maxs by a pixel
; 292  : 		facet->mins[i] -= 1.0f;

	mov	ecx, DWORD PTR _facet$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv347[ebp], edx
	mov	eax, DWORD PTR tv347[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv347[ebp]
	movss	DWORD PTR [ecx], xmm0

; 293  : 		facet->maxs[i] += 1.0f;

	mov	ecx, DWORD PTR _facet$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv354[ebp], eax
	mov	ecx, DWORD PTR tv354[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR tv354[ebp]
	movss	DWORD PTR [edx], xmm0

; 294  : 	}

	jmp	$LN38@AddMeshTri
$LN39@AddMeshTri:

; 295  : 
; 296  : 	// added
; 297  : 	m_mesh.numfacets++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 298  : 	m_iTotalPlanes += numplanes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _numplanes$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 299  : 
; 300  : 	return true;

	mov	al, 1
$LN1@AddMeshTri:

; 301  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z$0:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T9[ebp]
	mov	ecx, 20					; 00000014H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	push	ebx
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__ehhandler$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-836]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z ENDP	; CMeshDesc::AddMeshTrinagle
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_debug_name$ = 8					; size = 4
_numTriangles$ = 12					; size = 4
?InitMeshBuild@CMeshDesc@@QAE_NPBDH@Z PROC		; CMeshDesc::InitMeshBuild
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	if( numTriangles <= 0 )

	cmp	DWORD PTR _numTriangles$[ebp], 0
	jg	SHORT $LN2@InitMeshBu

; 118  : 		return false;

	xor	al, al
	jmp	$LN1@InitMeshBu
$LN2@InitMeshBu:

; 119  : 
; 120  : 	// perfomance warning
; 121  : 	if( numTriangles >= 16384 )

	cmp	DWORD PTR _numTriangles$[ebp], 16384	; 00004000H
	jl	SHORT $LN3@InitMeshBu

; 122  : 		ALERT( at_warning, "%s have too many triangles (%i)\n", debug_name, numTriangles );

	mov	eax, DWORD PTR _numTriangles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _debug_name$[ebp]
	push	ecx
	push	OFFSET $SG74428
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$LN3@InitMeshBu:

; 123  : 
; 124  : 	if( numTriangles >= 256 )

	cmp	DWORD PTR _numTriangles$[ebp], 256	; 00000100H
	jl	SHORT $LN4@InitMeshBu

; 125  : 		has_tree = true;	// too many triangles invoke to build AABB tree

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1352], 1
	jmp	SHORT $LN5@InitMeshBu
$LN4@InitMeshBu:

; 126  : 	else has_tree = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1352], 0
$LN5@InitMeshBu:

; 127  : 
; 128  : 	ClearBounds( m_mesh.mins, m_mesh.maxs );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?ClearBounds@@YAXAAVVector@@0@Z		; ClearBounds
	add	esp, 8

; 129  : 
; 130  : 	memset( areanodes, 0, sizeof( areanodes ));

	push	1280					; 00000500H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 131  : 	numareanodes = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1348], 0

; 132  : 
; 133  : 	m_debugName = debug_name;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _debug_name$[ebp]
	mov	DWORD PTR [edx+32], eax

; 134  : 	m_mesh.facets = (mfacet_t *)calloc( sizeof( mfacet_t ), numTriangles );

	mov	ecx, DWORD PTR _numTriangles$[ebp]
	push	ecx
	push	40					; 00000028H
	call	_calloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], eax

; 135  : 	m_iNumTris = numTriangles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _numTriangles$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 136  : 	m_iTotalPlanes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 137  : 
; 138  : 	return true;

	mov	al, 1
$LN1@InitMeshBu:

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?InitMeshBuild@CMeshDesc@@QAE_NPBDH@Z ENDP		; CMeshDesc::InitMeshBuild
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CMeshDesc@@QAE@XZ PROC				; CMeshDesc::~CMeshDesc
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CMeshDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 	FreeMesh ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMesh@CMeshDesc@@QAEXXZ		; CMeshDesc::FreeMesh

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1CMeshDesc@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CMeshDesc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CMeshDesc@@QAE@XZ ENDP				; CMeshDesc::~CMeshDesc
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\meshdesc.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMeshDesc@@QAE@XZ PROC				; CMeshDesc::CMeshDesc
; _this$ = ecx

; 24   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0mmesh_t@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 25   : 	m_origin = m_angles = g_vecZero;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 26   : 	m_mesh.numfacets = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 27   : 	m_mesh.facets = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 28   : 	m_debugName = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 29   : 	m_iNumTris = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 30   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CMeshDesc@@QAE@XZ ENDP				; CMeshDesc::CMeshDesc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0mmesh_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0mmesh_t@@QAE@XZ PROC					; mmesh_t::mmesh_t, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0mmesh_t@@QAE@XZ ENDP					; mmesh_t::mmesh_t
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0mplane_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0mplane_s@@QAE@XZ PROC				; mplane_s::mplane_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0mplane_s@@QAE@XZ ENDP				; mplane_s::mplane_s
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC		; CrossProduct, COMDAT

; 280  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
tv86 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?DotProduct@@YAMABVVector@@0@Z PROC			; DotProduct, COMDAT

; 278  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR tv86[ebp], xmm0
	fld	DWORD PTR tv86[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flLen$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Normalize@Vector@@QBE?AV1@XZ PROC			; Vector::Normalize, COMDAT
; _this$ = ecx

; 229  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 231  : 
; 232  : 		if( flLen )

	movss	xmm0, DWORD PTR _flLen$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 233  : 		{
; 234  : 			flLen = 1.0f / flLen;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _flLen$[ebp]
	movss	DWORD PTR _flLen$[ebp], xmm0

; 235  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Normalize
$LN2@Normalize:

; 236  : 		}
; 237  : 
; 238  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Normalize:

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QBEPBMXZ PROC				; Vector::operator float const *, COMDAT
; _this$ = ecx

; 226  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
?Length@Vector@@QBEMXZ PROC				; Vector::Length, COMDAT
; _this$ = ecx

; 223  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv91[ebp]
	fld	DWORD PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??8Vector@@QBEHABV0@@Z PROC				; Vector::operator==, COMDAT
; _this$ = ecx

; 144  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	ucomiss	xmm0, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	ucomiss	xmm0, DWORD PTR [edx+8]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv73[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
