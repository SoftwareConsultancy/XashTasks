; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\server\monsters\squadmonster.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?m_DataMap@CSquadMonster@@2Udatamap_s@@A	; CSquadMonster::m_DataMap
CONST	SEGMENT
$SG75239 DB	'CSquadMonster', 00H
	ORG $+2
$SG75308 DB	'm_hSquadLeader', 00H
	ORG $+1
$SG75309 DB	'm_hSquadMember', 00H
	ORG $+1
$SG75310 DB	'm_fEnemyEluded', 00H
	ORG $+1
$SG75311 DB	'm_flLastEnemySightTime', 00H
	ORG $+1
$SG75312 DB	'm_iMySlot', 00H
	ORG $+2
$SG75313 DB	'CSquadMonster', 00H
	ORG $+2
$SG75364 DB	'this->IsLeader()', 00H
	ORG $+3
$SG75361 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp', 00H
$SG75362 DB	'pRemove!=NULL', 00H
	ORG $+2
$SG75363 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp', 00H
$SG75365 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp', 00H
$SG75366 DB	'pRemove->m_hSquadLeader == this', 00H
$SG75380 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp', 00H
$SG75381 DB	'pAdd!=NULL', 00H
	ORG $+1
$SG75383 DB	'!pAdd->InSquad()', 00H
	ORG $+3
$SG75382 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp', 00H
$SG75384 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp', 00H
$SG75385 DB	'this->IsLeader()', 00H
	ORG $+3
$SG75411 DB	'ERROR: SquadMakeEnemy() - pEnemy is NULL!', 0aH, 00H
	ORG $+1
$SG75448 DB	'netname', 00H
$SG75452 DB	'netname', 00H
$SG75479 DB	'Squad of %d %s formed', 0aH, 00H
	ORG $+1
$SG75481 DB	'monster_human_grunt', 00H
$SG75781 DB	'0', 00H, 00H, 00H
$SG75611 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75612 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG75655 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75787 DB	'0', 00H, 00H, 00H
$SG75656 DB	'(', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '+', 00H, ' ', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '(', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG75778 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG75791 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG75657 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75793 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG75658 DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')'
	DB	00H, 00H, 00H
$SG75730 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+4
$SG75731 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
	ORG $+4
$SG75777 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75780 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75786 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75790 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75792 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
_DATA	SEGMENT
?m_DataMap@CSquadMonster@@2Udatamap_s@@A DD 00H		; CSquadMonster::m_DataMap
	DD	00H
	DD	FLAT:$SG75239
	DD	00H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
PUBLIC	?SetConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::SetConditions
PUBLIC	?HasConditions@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasConditions
PUBLIC	?CheckEnemy@CSquadMonster@@UAEHPAVCBaseEntity@@@Z ; CSquadMonster::CheckEnemy
PUBLIC	?StartMonster@CSquadMonster@@UAEXXZ		; CSquadMonster::StartMonster
PUBLIC	?VacateSlot@CSquadMonster@@QAEXXZ		; CSquadMonster::VacateSlot
PUBLIC	?ScheduleChange@CSquadMonster@@UAEXXZ		; CSquadMonster::ScheduleChange
PUBLIC	?Killed@CSquadMonster@@UAEXPAUentvars_s@@H@Z	; CSquadMonster::Killed
PUBLIC	?OccupySlot@CSquadMonster@@QAEHH@Z		; CSquadMonster::OccupySlot
PUBLIC	?NoFriendlyFire@CSquadMonster@@QAEHXZ		; CSquadMonster::NoFriendlyFire
PUBLIC	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ	; CSquadMonster::MySquadLeader
PUBLIC	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z	; CSquadMonster::MySquadMember
PUBLIC	?InSquad@CSquadMonster@@QAEHXZ			; CSquadMonster::InSquad
PUBLIC	?IsLeader@CSquadMonster@@QAEHXZ			; CSquadMonster::IsLeader
PUBLIC	?SquadRecruit@CSquadMonster@@QAEHHH@Z		; CSquadMonster::SquadRecruit
PUBLIC	?SquadCount@CSquadMonster@@QAEHXZ		; CSquadMonster::SquadCount
PUBLIC	?SquadRemove@CSquadMonster@@QAEXPAV1@@Z		; CSquadMonster::SquadRemove
PUBLIC	?SquadAdd@CSquadMonster@@QAEHPAV1@@Z		; CSquadMonster::SquadAdd
PUBLIC	?SquadMakeEnemy@CSquadMonster@@QAEXPAVCBaseEntity@@@Z ; CSquadMonster::SquadMakeEnemy
PUBLIC	?SquadPasteEnemyInfo@CSquadMonster@@QAEXXZ	; CSquadMonster::SquadPasteEnemyInfo
PUBLIC	?SquadCopyEnemyInfo@CSquadMonster@@QAEXXZ	; CSquadMonster::SquadCopyEnemyInfo
PUBLIC	?SquadEnemySplit@CSquadMonster@@QAEHXZ		; CSquadMonster::SquadEnemySplit
PUBLIC	?SquadMemberInRange@CSquadMonster@@QAEHABVVector@@M@Z ; CSquadMonster::SquadMemberInRange
PUBLIC	?GetBaseMap@CSquadMonster@@SAPAUdatamap_s@@XZ	; CSquadMonster::GetBaseMap
PUBLIC	?GetDataDescMap@CSquadMonster@@UAEPAUdatamap_s@@XZ ; CSquadMonster::GetDataDescMap
PUBLIC	?FValidateCover@CSquadMonster@@UAEHABVVector@@@Z ; CSquadMonster::FValidateCover
PUBLIC	?GetIdealState@CSquadMonster@@UAE?AW4MONSTERSTATE@@XZ ; CSquadMonster::GetIdealState
PUBLIC	?GetScheduleOfType@CSquadMonster@@UAEPAUSchedule_t@@H@Z ; CSquadMonster::GetScheduleOfType
PUBLIC	??$DataMapAccess@VCBaseMonster@@@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess<CBaseMonster>
PUBLIC	??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z ; DataMapInit<CSquadMonster>
PUBLIC	??$Destruct@PAD@@YAXPAPAD@Z			; Destruct<char *>
PUBLIC	??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@ ; `string'
PUBLIC	??_C@_0BF@DOONGEFO@Bad?5pev?5in?5OFFSET?$CI?$CJ?6@ ; `string'
PUBLIC	?g_DataMapHolder@CSquadMonster_DataDescInit@@3PAUdatamap_s@@A ; CSquadMonster_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ ; `string'
PUBLIC	??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@43000000
PUBLIC	__real@bf800000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_sqrt:PROC
EXTRN	?Q_strncmp@@YAHPBD0H@Z:PROC			; Q_strncmp
EXTRN	__wassert:PROC
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:PROC ; DBG_EntOfVars
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:PROC	; ENT
EXTRN	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z:PROC	; UTIL_VecToAngles
EXTRN	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z:PROC ; UTIL_FindEntityInSphere
EXTRN	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z:PROC ; UTIL_FindEntityByString
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:PROC	; UTIL_MakeVectors
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:PROC ; UTIL_TraceLine
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:PROC		; DBG_AssertFunction
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:PROC ; CBaseEntity::GetAbsOrigin
EXTRN	?SetBodygroup@CBaseAnimating@@QAEXHH@Z:PROC	; CBaseAnimating::SetBodygroup
EXTRN	?StartMonster@CBaseMonster@@UAEXXZ:PROC		; CBaseMonster::StartMonster
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:PROC ; CBaseMonster::GetScheduleOfType
EXTRN	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ:PROC ; CBaseMonster::GetIdealState
EXTRN	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:PROC ; CBaseMonster::CheckEnemy
EXTRN	?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z:PROC ; CBaseMonster::PushEnemy
EXTRN	?IScheduleFlags@CBaseMonster@@QAEHXZ:PROC	; CBaseMonster::IScheduleFlags
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:PROC ; CBaseMonster::Killed
EXTRN	??0CPlane@@QAE@XZ:PROC				; CPlane::CPlane
EXTRN	?InitializePlane@CPlane@@QAEXABVVector@@0@Z:PROC ; CPlane::InitializePlane
EXTRN	?PointInFront@CPlane@@QAEHABVVector@@@Z:PROC	; CPlane::PointInFront
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?m_DataMap@CBaseMonster@@2Udatamap_s@@A:BYTE	; CBaseMonster::m_DataMap
EXTRN	?slChaseEnemyFailed@@3PAUSchedule_t@@A:BYTE	; slChaseEnemyFailed
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?g_DataMapHolder@CSquadMonster_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CSquadMonster_DataDescInit::g_DataMapHolder
_BSS	ENDS
;	COMDAT ?nameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
_BSS	SEGMENT
?nameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?) ; `DataMapInit<CSquadMonster>'::`2'::nameHolder
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',VCSquadMonster::taMapInit>
_BSS	ENDS
CRT$XCU	SEGMENT
?g_DataMapHolder$initializer$@CSquadMonster_DataDescInit@@3P6AXXZA DD FLAT:??__Eg_DataMapHolder@CSquadMonster_DataDescInit@@YAXXZ ; CSquadMonster_DataDescInit::g_DataMapHolder$initializer$
CRT$XCU	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@ DB 'I'
	DB	00H, 's', 00H, 'I', 00H, 'd', 00H, 'x', 00H, 'V', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, '(', 00H, 'i', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@ DB '!'
	DB	00H, 'I', 00H, 's', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H
	DB	'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H, '(', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
CONST	SEGMENT
??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's'
	DB	00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H
	DB	'.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v'
	DB	00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H, '.'
	DB	00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\'
	DB	00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'u'
	DB	00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?dataDesc@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4PAUtypedescription_s@@A
_DATA	SEGMENT
?dataDesc@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4PAUtypedescription_s@@A DD 012H ; `DataMapInit<CSquadMonster>'::`2'::dataDesc
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:$SG75308
	DD	08ecH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:$SG75309
	DD	08f4H
	DW	04H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:$SG75310
	DD	091cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:$SG75311
	DD	0918H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:$SG75312
	DD	0920H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0BF@DOONGEFO@Bad?5pev?5in?5OFFSET?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BF@DOONGEFO@Bad?5pev?5in?5OFFSET?$CI?$CJ?6@ DB 'Bad pev in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z$0
__ehfuncinfo$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlMemory@PADH@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Destruct@PAD@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8						; size = 4
??$Destruct@PAD@@YAXPAPAD@Z PROC			; Destruct<char *>, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	ebp
	ret	0
??$Destruct@PAD@@YAXPAPAD@Z ENDP			; Destruct<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FnameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@YAXXZ
text$yd	SEGMENT
??__FnameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@YAXXZ PROC ; `DataMapInit<CSquadMonster>'::`2'::`dynamic atexit destructor for 'nameHolder'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?nameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	ebp
	ret	0
??__FnameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@YAXXZ ENDP ; `DataMapInit<CSquadMonster>'::`2'::`dynamic atexit destructor for 'nameHolder''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
;	COMDAT ??__Eg_DataMapHolder@CSquadMonster_DataDescInit@@YAXXZ
text$di	SEGMENT
??__Eg_DataMapHolder@CSquadMonster_DataDescInit@@YAXXZ PROC ; CSquadMonster_DataDescInit::`dynamic initializer for 'g_DataMapHolder'', COMDAT

; 31   : BEGIN_DATADESC( CSquadMonster )

	push	ebp
	mov	ebp, esp
	push	0
	call	??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z ; DataMapInit<CSquadMonster>
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CSquadMonster_DataDescInit@@3PAUdatamap_s@@A, eax ; CSquadMonster_DataDescInit::g_DataMapHolder
	pop	ebp
	ret	0
??__Eg_DataMapHolder@CSquadMonster_DataDescInit@@YAXXZ ENDP ; CSquadMonster_DataDescInit::`dynamic initializer for 'g_DataMapHolder''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z PROC ; DataMapInit<CSquadMonster>

; 31   : BEGIN_DATADESC( CSquadMonster )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[edx]
	jle	SHORT $LN2@DataMapIni
	push	OFFSET ?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA, -1
	jne	SHORT $LN2@DataMapIni
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET $SG75313
	mov	ecx, OFFSET ?nameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET ??__FnameHolder@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@YAXXZ ; `DataMapInit<CSquadMonster>'::`2'::`dynamic atexit destructor for 'nameHolder''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	OFFSET ?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA
	call	__Init_thread_footer
	add	esp, 4
$LN2@DataMapIni:
	call	?GetBaseMap@CSquadMonster@@SAPAUdatamap_s@@XZ ; CSquadMonster::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CSquadMonster@@2Udatamap_s@@A+12, eax

; 32   : 	DEFINE_FIELD( m_hSquadLeader, FIELD_EHANDLE ),
; 33   : 	DEFINE_ARRAY( m_hSquadMember, FIELD_EHANDLE, MAX_SQUAD_MEMBERS - 1 ),
; 34   : 	DEFINE_FIELD( m_fEnemyEluded, FIELD_BOOLEAN ),
; 35   : 	DEFINE_FIELD( m_flLastEnemySightTime, FIELD_TIME ),
; 36   : 	DEFINE_FIELD( m_iMySlot, FIELD_INTEGER ),
; 37   : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@DataMapIni
	mov	DWORD PTR ?m_DataMap@CSquadMonster@@2Udatamap_s@@A+4, 5
	mov	edx, 24					; 00000018H
	shl	edx, 0
	add	edx, OFFSET ?dataDesc@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4PAUtypedescription_s@@A
	mov	DWORD PTR ?m_DataMap@CSquadMonster@@2Udatamap_s@@A, edx
	jmp	SHORT $LN4@DataMapIni
$LN3@DataMapIni:
	mov	DWORD PTR ?m_DataMap@CSquadMonster@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CSquadMonster@@2Udatamap_s@@A, OFFSET ?dataDesc@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4PAUtypedescription_s@@A
$LN4@DataMapIni:
	mov	eax, OFFSET ?m_DataMap@CSquadMonster@@2Udatamap_s@@A ; CSquadMonster::m_DataMap
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z$0:
	push	OFFSET ?$TSS0@?1???$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$DataMapInit@VCSquadMonster@@@@YAPAUdatamap_s@@PAVCSquadMonster@@@Z ENDP ; DataMapInit<CSquadMonster>
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\common\datamap.h
;	COMDAT ??$DataMapAccess@VCBaseMonster@@@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_ignored$ = 8						; size = 4
_p$ = 12						; size = 4
??$DataMapAccess@VCBaseMonster@@@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z PROC ; DataMapAccess<CBaseMonster>, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET ?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap

; 184  : }

	pop	ebp
	ret	0
??$DataMapAccess@VCBaseMonster@@@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess<CBaseMonster>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv64 = -4						; size = 4
_iType$ = 8						; size = 4
?GetScheduleOfType@CSquadMonster@@UAEPAUSchedule_t@@H@Z PROC ; CSquadMonster::GetScheduleOfType
; _this$ = ecx

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 600  : 	switch ( iType )

	mov	eax, DWORD PTR _iType$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 13			; 0000000dH
	je	SHORT $LN4@GetSchedul
	jmp	SHORT $LN5@GetSchedul
$LN4@GetSchedul:

; 601  : 	{
; 602  : 
; 603  : 	case SCHED_CHASE_ENEMY_FAILED:
; 604  : 		{
; 605  : 			return &slChaseEnemyFailed[ 0 ];

	mov	ecx, 20					; 00000014H
	imul	eax, ecx, 0
	add	eax, OFFSET ?slChaseEnemyFailed@@3PAUSchedule_t@@A ; slChaseEnemyFailed
	jmp	SHORT $LN1@GetSchedul
$LN5@GetSchedul:

; 606  : 		}
; 607  : 	
; 608  : 	default:
; 609  : 		return CBaseMonster::GetScheduleOfType( iType );

	mov	edx, DWORD PTR _iType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z ; CBaseMonster::GetScheduleOfType
$LN1@GetSchedul:

; 610  : 	}
; 611  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetScheduleOfType@CSquadMonster@@UAEPAUSchedule_t@@H@Z ENDP ; CSquadMonster::GetScheduleOfType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_iConditions$ = -12					; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?GetIdealState@CSquadMonster@@UAE?AW4MONSTERSTATE@@XZ PROC ; CSquadMonster::GetIdealState
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	int	iConditions;
; 512  : 
; 513  : 	iConditions = IScheduleFlags();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IScheduleFlags@CBaseMonster@@QAEHXZ	; CBaseMonster::IScheduleFlags
	mov	DWORD PTR _iConditions$[ebp], eax

; 514  : 	
; 515  : 	// If no schedule conditions, the new ideal state is probably the reason we're in here.
; 516  : 	switch ( m_MonsterState )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1968]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN4@GetIdealSt
	cmp	DWORD PTR tv75[ebp], 3
	je	SHORT $LN4@GetIdealSt
	jmp	SHORT $LN2@GetIdealSt
$LN4@GetIdealSt:

; 517  : 	{
; 518  : 	case MONSTERSTATE_IDLE:
; 519  : 	case MONSTERSTATE_ALERT:
; 520  : 		if ( HasConditions ( bits_COND_NEW_ENEMY ) && InSquad() )

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $LN2@GetIdealSt
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $LN2@GetIdealSt

; 521  : 		{
; 522  : 			SquadMakeEnemy ( m_hEnemy );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadMakeEnemy@CSquadMonster@@QAEXPAVCBaseEntity@@@Z ; CSquadMonster::SquadMakeEnemy
$LN2@GetIdealSt:

; 523  : 		}
; 524  : 		break;
; 525  : 	}
; 526  : 
; 527  : 	return CBaseMonster :: GetIdealState();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ ; CBaseMonster::GetIdealState

; 528  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetIdealState@CSquadMonster@@UAE?AW4MONSTERSTATE@@XZ ENDP ; CSquadMonster::GetIdealState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vecCoverLocation$ = 8					; size = 4
?FValidateCover@CSquadMonster@@UAEHABVVector@@@Z PROC	; CSquadMonster::FValidateCover
; _this$ = ecx

; 536  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 537  : 	if ( !InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN2@FValidateC

; 538  : 	{
; 539  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@FValidateC
$LN2@FValidateC:

; 540  : 	}
; 541  : 
; 542  : 	if (SquadMemberInRange( vecCoverLocation, 128 ))

	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _vecCoverLocation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadMemberInRange@CSquadMonster@@QAEHABVVector@@M@Z ; CSquadMonster::SquadMemberInRange
	test	eax, eax
	je	SHORT $LN3@FValidateC

; 543  : 	{
; 544  : 		// another squad member is too close to this piece of cover.
; 545  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@FValidateC
$LN3@FValidateC:

; 546  : 	}
; 547  : 
; 548  : 	return TRUE;

	mov	eax, 1
$LN1@FValidateC:

; 549  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateCover@CSquadMonster@@UAEHABVVector@@@Z ENDP	; CSquadMonster::FValidateCover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDataDescMap@CSquadMonster@@UAEPAUdatamap_s@@XZ PROC	; CSquadMonster::GetDataDescMap
; _this$ = ecx

; 31   : BEGIN_DATADESC( CSquadMonster )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_DataMap@CSquadMonster@@2Udatamap_s@@A ; CSquadMonster::m_DataMap
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CSquadMonster@@UAEPAUdatamap_s@@XZ ENDP	; CSquadMonster::GetDataDescMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_pResult$ = -4						; size = 4
?GetBaseMap@CSquadMonster@@SAPAUdatamap_s@@XZ PROC	; CSquadMonster::GetBaseMap

; 31   : BEGIN_DATADESC( CSquadMonster )

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	??$DataMapAccess@VCBaseMonster@@@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess<CBaseMonster>
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CSquadMonster@@SAPAUdatamap_s@@XZ ENDP	; CSquadMonster::GetBaseMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 12
tv132 = -20						; size = 4
_pSquadLeader$ = -16					; size = 4
_pSquadMember$2 = -12					; size = 4
_this$ = -8						; size = 4
_i$3 = -4						; size = 4
_vecLocation$ = 8					; size = 4
_flDist$ = 12						; size = 4
?SquadMemberInRange@CSquadMonster@@QAEHABVVector@@M@Z PROC ; CSquadMonster::SquadMemberInRange
; _this$ = ecx

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 	if (!InSquad())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN5@SquadMembe

; 582  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@SquadMembe
$LN5@SquadMembe:

; 583  : 
; 584  : 	CSquadMonster *pSquadLeader = MySquadLeader();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 585  : 
; 586  : 	for (int i = 0; i < MAX_SQUAD_MEMBERS; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@SquadMembe
$LN2@SquadMembe:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@SquadMembe:
	cmp	DWORD PTR _i$3[ebp], 5
	jge	SHORT $LN3@SquadMembe

; 587  : 	{
; 588  : 		CSquadMonster *pSquadMember = pSquadLeader->MySquadMember(i);

	mov	ecx, DWORD PTR _i$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	call	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ; CSquadMonster::MySquadMember
	mov	DWORD PTR _pSquadMember$2[ebp], eax

; 589  : 		if (pSquadMember && (vecLocation - pSquadMember->GetAbsOrigin() ).Length2D() <= flDist)

	cmp	DWORD PTR _pSquadMember$2[ebp], 0
	je	SHORT $LN6@SquadMembe
	mov	ecx, DWORD PTR _pSquadMember$2[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecLocation$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR tv132[ebp]
	movss	xmm0, DWORD PTR _flDist$[ebp]
	comiss	xmm0, DWORD PTR tv132[ebp]
	jb	SHORT $LN6@SquadMembe

; 590  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@SquadMembe
$LN6@SquadMembe:

; 591  : 	}

	jmp	SHORT $LN2@SquadMembe
$LN3@SquadMembe:

; 592  : 	return FALSE;

	xor	eax, eax
$LN1@SquadMembe:

; 593  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SquadMemberInRange@CSquadMonster@@QAEHABVVector@@M@Z ENDP ; CSquadMonster::SquadMemberInRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_pEnemy$ = -20						; size = 4
_pSquadLeader$ = -16					; size = 4
_this$ = -12						; size = 4
_pMember$1 = -8						; size = 4
_i$2 = -4						; size = 4
?SquadEnemySplit@CSquadMonster@@QAEHXZ PROC		; CSquadMonster::SquadEnemySplit
; _this$ = ecx

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 	if (!InSquad())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN5@SquadEnemy

; 558  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@SquadEnemy
$LN5@SquadEnemy:

; 559  : 
; 560  : 	CSquadMonster	*pSquadLeader = MySquadLeader();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 561  : 	CBaseEntity		*pEnemy	= pSquadLeader->m_hEnemy;

	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pEnemy$[ebp], eax

; 562  : 
; 563  : 	for (int i = 0; i < MAX_SQUAD_MEMBERS; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SquadEnemy
$LN2@SquadEnemy:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SquadEnemy:
	cmp	DWORD PTR _i$2[ebp], 5
	jge	SHORT $LN3@SquadEnemy

; 564  : 	{
; 565  : 		CSquadMonster *pMember = pSquadLeader->MySquadMember(i);

	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	call	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ; CSquadMonster::MySquadMember
	mov	DWORD PTR _pMember$1[ebp], eax

; 566  : 		if (pMember != NULL && pMember->m_hEnemy != NULL && pMember->m_hEnemy != pEnemy)

	cmp	DWORD PTR _pMember$1[ebp], 0
	je	SHORT $LN6@SquadEnemy
	mov	ecx, DWORD PTR _pMember$1[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $LN6@SquadEnemy
	mov	ecx, DWORD PTR _pMember$1[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _pEnemy$[ebp]
	je	SHORT $LN6@SquadEnemy

; 567  : 		{
; 568  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@SquadEnemy
$LN6@SquadEnemy:

; 569  : 		}
; 570  : 	}

	jmp	SHORT $LN2@SquadEnemy
$LN3@SquadEnemy:

; 571  : 	return FALSE;

	xor	eax, eax
$LN1@SquadEnemy:

; 572  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SquadEnemySplit@CSquadMonster@@QAEHXZ ENDP		; CSquadMonster::SquadEnemySplit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSquadLeader$ = -4					; size = 4
?SquadCopyEnemyInfo@CSquadMonster@@QAEXXZ PROC		; CSquadMonster::SquadCopyEnemyInfo
; _this$ = ecx

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 	CSquadMonster *pSquadLeader = MySquadLeader( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 225  : 	if (pSquadLeader)

	cmp	DWORD PTR _pSquadLeader$[ebp], 0
	je	SHORT $LN1@SquadCopyE

; 226  : 		m_vecEnemyLKP = pSquadLeader->m_vecEnemyLKP;

	mov	eax, DWORD PTR _pSquadLeader$[ebp]
	add	eax, 2176				; 00000880H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2176				; 00000880H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN1@SquadCopyE:

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SquadCopyEnemyInfo@CSquadMonster@@QAEXXZ ENDP		; CSquadMonster::SquadCopyEnemyInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_pSquadLeader$ = -8					; size = 4
_this$ = -4						; size = 4
?SquadPasteEnemyInfo@CSquadMonster@@QAEXXZ PROC		; CSquadMonster::SquadPasteEnemyInfo
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 	CSquadMonster *pSquadLeader = MySquadLeader( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 210  : 	if (pSquadLeader)

	cmp	DWORD PTR _pSquadLeader$[ebp], 0
	je	SHORT $LN1@SquadPaste

; 211  : 		pSquadLeader->m_vecEnemyLKP = m_vecEnemyLKP;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2176				; 00000880H
	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	add	ecx, 2176				; 00000880H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN1@SquadPaste:

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SquadPasteEnemyInfo@CSquadMonster@@QAEXXZ ENDP		; CSquadMonster::SquadPasteEnemyInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_pSquadLeader$ = -16					; size = 4
_this$ = -12						; size = 4
_i$1 = -8						; size = 4
_pMember$2 = -4						; size = 4
_pEnemy$ = 8						; size = 4
?SquadMakeEnemy@CSquadMonster@@QAEXPAVCBaseEntity@@@Z PROC ; CSquadMonster::SquadMakeEnemy
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	if (!InSquad())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN5@SquadMakeE

; 238  : 		return;

	jmp	$LN1@SquadMakeE
$LN5@SquadMakeE:

; 239  : 
; 240  : 	if ( !pEnemy )

	cmp	DWORD PTR _pEnemy$[ebp], 0
	jne	SHORT $LN6@SquadMakeE

; 241  : 	{
; 242  : 		ALERT ( at_console, "ERROR: SquadMakeEnemy() - pEnemy is NULL!\n" );

	push	OFFSET $SG75411
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 243  : 		return;

	jmp	$LN1@SquadMakeE
$LN6@SquadMakeE:

; 244  : 	}
; 245  : 
; 246  : 	CSquadMonster *pSquadLeader = MySquadLeader( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 247  : 	for (int i = 0; i < MAX_SQUAD_MEMBERS; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SquadMakeE
$LN2@SquadMakeE:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@SquadMakeE:
	cmp	DWORD PTR _i$1[ebp], 5
	jge	$LN1@SquadMakeE

; 248  : 	{
; 249  : 		CSquadMonster *pMember = pSquadLeader->MySquadMember(i);

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	call	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ; CSquadMonster::MySquadMember
	mov	DWORD PTR _pMember$2[ebp], eax

; 250  : 		if (pMember)

	cmp	DWORD PTR _pMember$2[ebp], 0
	je	$LN7@SquadMakeE

; 251  : 		{
; 252  : 			// reset members who aren't activly engaged in fighting
; 253  : 			if (pMember->m_hEnemy != pEnemy && !pMember->HasConditions( bits_COND_SEE_ENEMY))

	mov	ecx, DWORD PTR _pMember$2[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _pEnemy$[ebp]
	je	$LN7@SquadMakeE
	push	16					; 00000010H
	mov	ecx, DWORD PTR _pMember$2[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $LN7@SquadMakeE

; 254  : 			{
; 255  : 				if ( pMember->m_hEnemy != NULL) 

	mov	ecx, DWORD PTR _pMember$2[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $LN9@SquadMakeE

; 256  : 				{
; 257  : 					// remember their current enemy
; 258  : 					pMember->PushEnemy( pMember->m_hEnemy, pMember->m_vecEnemyLKP );

	mov	edx, DWORD PTR _pMember$2[ebp]
	add	edx, 2176				; 00000880H
	push	edx
	mov	ecx, DWORD PTR _pMember$2[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _pMember$2[ebp]
	call	?PushEnemy@CBaseMonster@@QAEXPAVCBaseEntity@@AAVVector@@@Z ; CBaseMonster::PushEnemy
$LN9@SquadMakeE:

; 259  : 				}
; 260  : 				// give them a new enemy
; 261  : 				pMember->m_hEnemy = pEnemy;

	mov	eax, DWORD PTR _pEnemy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMember$2[ebp]
	add	ecx, 1848				; 00000738H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 262  : 				pMember->m_vecEnemyLKP = pEnemy->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEnemy$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _pMember$2[ebp]
	add	ecx, 2176				; 00000880H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 263  : 				pMember->SetConditions ( bits_COND_NEW_ENEMY );

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pMember$2[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$LN7@SquadMakeE:

; 264  : 			}
; 265  : 		}
; 266  : 	}

	jmp	$LN2@SquadMakeE
$LN1@SquadMakeE:

; 267  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SquadMakeEnemy@CSquadMonster@@QAEXPAVCBaseEntity@@@Z ENDP ; CSquadMonster::SquadMakeEnemy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
tv78 = -16						; size = 4
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_pAdd$ = 8						; size = 4
?SquadAdd@CSquadMonster@@QAEHPAV1@@Z PROC		; CSquadMonster::SquadAdd
; _this$ = ecx

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 	ASSERT( pAdd!=NULL );

	cmp	DWORD PTR _pAdd$[ebp], 0
	je	SHORT $LN7@SquadAdd
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN8@SquadAdd
$LN7@SquadAdd:
	mov	DWORD PTR tv69[ebp], 0
$LN8@SquadAdd:
	push	0
	push	182					; 000000b6H
	push	OFFSET $SG75380
	push	OFFSET $SG75381
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 183  : 	ASSERT( !pAdd->InSquad() );

	mov	ecx, DWORD PTR _pAdd$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN9@SquadAdd
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN10@SquadAdd
$LN9@SquadAdd:
	mov	DWORD PTR tv78[ebp], 0
$LN10@SquadAdd:
	push	0
	push	183					; 000000b7H
	push	OFFSET $SG75382
	push	OFFSET $SG75383
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 184  : 	ASSERT( this->IsLeader() );

	push	0
	push	184					; 000000b8H
	push	OFFSET $SG75384
	push	OFFSET $SG75385
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeader@CSquadMonster@@QAEHXZ		; CSquadMonster::IsLeader
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 185  : 
; 186  : 	for (int i = 0; i < MAX_SQUAD_MEMBERS-1; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SquadAdd
$LN2@SquadAdd:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@SquadAdd:
	cmp	DWORD PTR _i$1[ebp], 4
	jge	SHORT $LN3@SquadAdd

; 187  : 	{
; 188  : 		if (m_hSquadMember[i] == NULL)

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+2292]
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $LN5@SquadAdd

; 189  : 		{
; 190  : 			m_hSquadMember[i] = pAdd;

	mov	edx, DWORD PTR _pAdd$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+2292]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 191  : 			pAdd->m_hSquadLeader = this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAdd$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 192  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@SquadAdd
$LN5@SquadAdd:

; 193  : 		}
; 194  : 	}

	jmp	SHORT $LN2@SquadAdd
$LN3@SquadAdd:

; 195  : 	return FALSE;

	xor	eax, eax
$LN1@SquadAdd:

; 196  : 	// should complain here
; 197  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SquadAdd@CSquadMonster@@QAEHPAV1@@Z ENDP		; CSquadMonster::SquadAdd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_pMember$1 = -28					; size = 4
tv90 = -24						; size = 4
tv69 = -20						; size = 4
_pSquadLeader$2 = -16					; size = 4
_i$3 = -12						; size = 4
_i$4 = -8						; size = 4
_this$ = -4						; size = 4
_pRemove$ = 8						; size = 4
?SquadRemove@CSquadMonster@@QAEXPAV1@@Z PROC		; CSquadMonster::SquadRemove
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 	ASSERT( pRemove!=NULL );

	cmp	DWORD PTR _pRemove$[ebp], 0
	je	SHORT $LN14@SquadRemov
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN15@SquadRemov
$LN14@SquadRemov:
	mov	DWORD PTR tv69[ebp], 0
$LN15@SquadRemov:
	push	0
	push	139					; 0000008bH
	push	OFFSET $SG75361
	push	OFFSET $SG75362
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 140  : 	ASSERT( this->IsLeader() );

	push	0
	push	140					; 0000008cH
	push	OFFSET $SG75363
	push	OFFSET $SG75364
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeader@CSquadMonster@@QAEHXZ		; CSquadMonster::IsLeader
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 141  : 	ASSERT( pRemove->m_hSquadLeader == this );

	mov	ecx, DWORD PTR _pRemove$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN16@SquadRemov
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN17@SquadRemov
$LN16@SquadRemov:
	mov	DWORD PTR tv90[ebp], 0
$LN17@SquadRemov:
	push	0
	push	141					; 0000008dH
	push	OFFSET $SG75365
	push	OFFSET $SG75366
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 142  : 
; 143  : 	// If I'm the leader, get rid of my squad
; 144  : 	if (pRemove == MySquadLeader())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	cmp	DWORD PTR _pRemove$[ebp], eax
	jne	SHORT $LN8@SquadRemov

; 145  : 	{
; 146  : 		for (int i = 0; i < MAX_SQUAD_MEMBERS-1;i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@SquadRemov
$LN2@SquadRemov:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN4@SquadRemov:
	cmp	DWORD PTR _i$4[ebp], 4
	jge	SHORT $LN3@SquadRemov

; 147  : 		{
; 148  : 			CSquadMonster *pMember = MySquadMember(i);

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ; CSquadMonster::MySquadMember
	mov	DWORD PTR _pMember$1[ebp], eax

; 149  : 			if (pMember)

	cmp	DWORD PTR _pMember$1[ebp], 0
	je	SHORT $LN10@SquadRemov

; 150  : 			{
; 151  : 				pMember->m_hSquadLeader = NULL;

	push	0
	mov	ecx, DWORD PTR _pMember$1[ebp]
	add	ecx, 2284				; 000008ecH
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 152  : 				m_hSquadMember[i] = NULL;

	push	0
	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8+2292]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$LN10@SquadRemov:

; 153  : 			}
; 154  : 		}

	jmp	SHORT $LN2@SquadRemov
$LN3@SquadRemov:

; 155  : 	}
; 156  : 	else

	jmp	SHORT $LN9@SquadRemov
$LN8@SquadRemov:

; 157  : 	{
; 158  : 		CSquadMonster *pSquadLeader = MySquadLeader();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$2[ebp], eax

; 159  : 		if (pSquadLeader)

	cmp	DWORD PTR _pSquadLeader$2[ebp], 0
	je	SHORT $LN9@SquadRemov

; 160  : 		{
; 161  : 			for (int i = 0; i < MAX_SQUAD_MEMBERS-1;i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN7@SquadRemov
$LN5@SquadRemov:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SquadRemov:
	cmp	DWORD PTR _i$3[ebp], 4
	jge	SHORT $LN9@SquadRemov

; 162  : 			{
; 163  : 				if (pSquadLeader->m_hSquadMember[i] == this)

	mov	ecx, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _pSquadLeader$2[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8+2292]
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN12@SquadRemov

; 164  : 				{
; 165  : 					pSquadLeader->m_hSquadMember[i] = NULL;

	push	0
	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _pSquadLeader$2[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+2292]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 166  : 					break;

	jmp	SHORT $LN9@SquadRemov
$LN12@SquadRemov:

; 167  : 				}
; 168  : 			}

	jmp	SHORT $LN5@SquadRemov
$LN9@SquadRemov:

; 169  : 		}
; 170  : 	}
; 171  : 
; 172  : 	pRemove->m_hSquadLeader = NULL;

	push	0
	mov	ecx, DWORD PTR _pRemove$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 173  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SquadRemove@CSquadMonster@@QAEXPAV1@@Z ENDP		; CSquadMonster::SquadRemove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_pSquadLeader$ = -16					; size = 4
_this$ = -12						; size = 4
_squadCount$ = -8					; size = 4
_i$1 = -4						; size = 4
?SquadCount@CSquadMonster@@QAEHXZ PROC			; CSquadMonster::SquadCount
; _this$ = ecx

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	if (!InSquad())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN5@SquadCount

; 279  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SquadCount
$LN5@SquadCount:

; 280  : 
; 281  : 	CSquadMonster *pSquadLeader = MySquadLeader();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 282  : 	int squadCount = 0;

	mov	DWORD PTR _squadCount$[ebp], 0

; 283  : 	for (int i = 0; i < MAX_SQUAD_MEMBERS; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SquadCount
$LN2@SquadCount:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@SquadCount:
	cmp	DWORD PTR _i$1[ebp], 5
	jge	SHORT $LN3@SquadCount

; 284  : 	{
; 285  : 		if (pSquadLeader->MySquadMember(i) != NULL)

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	call	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ; CSquadMonster::MySquadMember
	test	eax, eax
	je	SHORT $LN6@SquadCount

; 286  : 			squadCount++;

	mov	edx, DWORD PTR _squadCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _squadCount$[ebp], edx
$LN6@SquadCount:

; 287  : 	}

	jmp	SHORT $LN2@SquadCount
$LN3@SquadCount:

; 288  : 
; 289  : 	return squadCount;

	mov	eax, DWORD PTR _squadCount$[ebp]
$LN1@SquadCount:

; 290  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SquadCount@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::SquadCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_tr$1 = -104						; size = 56
$T2 = -48						; size = 12
$T3 = -36						; size = 12
_iMyClass$ = -24					; size = 4
_squadCount$ = -20					; size = 4
_pRecruit$4 = -16					; size = 4
_pEntity$ = -12						; size = 4
_pRecruit$5 = -8					; size = 4
_this$ = -4						; size = 4
_searchRadius$ = 8					; size = 4
_maxMembers$ = 12					; size = 4
?SquadRecruit@CSquadMonster@@QAEHHH@Z PROC		; CSquadMonster::SquadRecruit
; _this$ = ecx

; 300  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	int squadCount;
; 302  : 	int iMyClass = Classify();// cache this monster's class

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	mov	DWORD PTR _iMyClass$[ebp], eax

; 303  : 
; 304  : 
; 305  : 	// Don't recruit if I'm already in a group
; 306  : 	if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $LN6@SquadRecru

; 307  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SquadRecru
$LN6@SquadRecru:

; 308  : 
; 309  : 	if ( maxMembers < 2 )

	cmp	DWORD PTR _maxMembers$[ebp], 2
	jge	SHORT $LN7@SquadRecru

; 310  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SquadRecru
$LN7@SquadRecru:

; 311  : 
; 312  : 	// I am my own leader
; 313  : 	m_hSquadLeader = this;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 314  : 	squadCount = 1;

	mov	DWORD PTR _squadCount$[ebp], 1

; 315  : 
; 316  : 	CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$[ebp], 0

; 317  : 
; 318  : 	if ( !FStringNull( pev->netname ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	$LN8@SquadRecru

; 319  : 	{
; 320  : 		// I have a netname, so unconditionally recruit everyone else with that name.
; 321  : 		pEntity = UTIL_FindEntityByString( pEntity, "netname", STRING( pev->netname ) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET $SG75448
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEntity$[ebp], eax
$LN2@SquadRecru:

; 322  : 		while ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	$LN3@SquadRecru

; 323  : 		{
; 324  : 			CSquadMonster *pRecruit = pEntity->MySquadMonsterPointer();

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	mov	DWORD PTR _pRecruit$4[ebp], eax

; 325  : 
; 326  : 			if ( pRecruit )

	cmp	DWORD PTR _pRecruit$4[ebp], 0
	je	SHORT $LN11@SquadRecru

; 327  : 			{
; 328  : 				if ( !pRecruit->InSquad() && pRecruit->Classify() == iMyClass && pRecruit != this )

	mov	ecx, DWORD PTR _pRecruit$4[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN11@SquadRecru
	mov	ecx, DWORD PTR _pRecruit$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pRecruit$4[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	cmp	eax, DWORD PTR _iMyClass$[ebp]
	jne	SHORT $LN11@SquadRecru
	mov	ecx, DWORD PTR _pRecruit$4[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN11@SquadRecru

; 329  : 				{
; 330  : 					// minimum protection here against user error.in worldcraft. 
; 331  : 					if (!SquadAdd( pRecruit ))

	mov	edx, DWORD PTR _pRecruit$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadAdd@CSquadMonster@@QAEHPAV1@@Z	; CSquadMonster::SquadAdd
	test	eax, eax
	jne	SHORT $LN12@SquadRecru

; 332  : 						break;

	jmp	SHORT $LN3@SquadRecru
$LN12@SquadRecru:

; 333  : 					squadCount++;

	mov	eax, DWORD PTR _squadCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _squadCount$[ebp], eax
$LN11@SquadRecru:

; 334  : 				}
; 335  : 			}
; 336  : 	
; 337  : 			pEntity = UTIL_FindEntityByString( pEntity, "netname", STRING( pev->netname ) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET $SG75452
	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	call	?UTIL_FindEntityByString@@YAPAVCBaseEntity@@PAV1@PBD1@Z ; UTIL_FindEntityByString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEntity$[ebp], eax

; 338  : 		}

	jmp	$LN2@SquadRecru
$LN3@SquadRecru:

; 339  : 	}
; 340  : 	else 

	jmp	$LN5@SquadRecru
$LN8@SquadRecru:

; 341  : 	{
; 342  : 		while ((pEntity = UTIL_FindEntityInSphere( pEntity, GetAbsOrigin(), searchRadius )) != NULL)

	cvtsi2ss xmm0, DWORD PTR _searchRadius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pEntity$[ebp], eax
	cmp	DWORD PTR _pEntity$[ebp], 0
	je	$LN5@SquadRecru

; 343  : 		{
; 344  : 			CSquadMonster *pRecruit = pEntity->MySquadMonsterPointer( );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
	mov	DWORD PTR _pRecruit$5[ebp], eax

; 345  : 
; 346  : 			if ( pRecruit && pRecruit != this && pRecruit->IsAlive() && !pRecruit->m_pCine )

	cmp	DWORD PTR _pRecruit$5[ebp], 0
	je	$LN16@SquadRecru
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	$LN16@SquadRecru
	mov	edx, DWORD PTR _pRecruit$5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	mov	edx, DWORD PTR [eax+196]
	call	edx
	test	eax, eax
	je	$LN16@SquadRecru
	mov	eax, DWORD PTR _pRecruit$5[ebp]
	cmp	DWORD PTR [eax+2272], 0
	jne	$LN16@SquadRecru

; 347  : 			{
; 348  : 				// Can we recruit this guy?
; 349  : 				if ( !pRecruit->InSquad() && pRecruit->Classify() == iMyClass &&
; 350  : 				   ( (iMyClass != CLASS_ALIEN_MONSTER) || FStrEq(STRING(pev->classname), STRING(pRecruit->pev->classname))) &&

	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	$LN16@SquadRecru
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	cmp	eax, DWORD PTR _iMyClass$[ebp]
	jne	$LN16@SquadRecru
	cmp	DWORD PTR _iMyClass$[ebp], 7
	jne	SHORT $LN15@SquadRecru
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$LN16@SquadRecru
$LN15@SquadRecru:
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@SquadRecru

; 351  : 				    FStringNull( pRecruit->pev->netname ) )
; 352  : 				{
; 353  : 					TraceResult tr;

	lea	ecx, DWORD PTR _tr$1[ebp]
	call	??0gametrace_s@@QAE@XZ

; 354  : 					UTIL_TraceLine( EyePosition(), pRecruit->EyePosition(), ignore_monsters, pRecruit->edict(), &tr );// try to hit recruit with a traceline.

	lea	ecx, DWORD PTR _tr$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _pRecruit$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pRecruit$5[ebp]
	mov	eax, DWORD PTR [edx+304]
	call	eax
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+304]
	call	edx
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 355  : 					if ( tr.flFraction == 1.0 )

	cvtss2sd xmm0, DWORD PTR _tr$1[ebp+16]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@SquadRecru

; 356  : 					{
; 357  : 						if (!SquadAdd( pRecruit ))

	mov	eax, DWORD PTR _pRecruit$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadAdd@CSquadMonster@@QAEHPAV1@@Z	; CSquadMonster::SquadAdd
	test	eax, eax
	jne	SHORT $LN17@SquadRecru

; 358  : 							break;

	jmp	SHORT $LN5@SquadRecru
$LN17@SquadRecru:

; 359  : 
; 360  : 						squadCount++;

	mov	ecx, DWORD PTR _squadCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _squadCount$[ebp], ecx
$LN16@SquadRecru:

; 361  : 					}
; 362  : 				}
; 363  : 			}
; 364  : 		}

	jmp	$LN8@SquadRecru
$LN5@SquadRecru:

; 365  : 	}
; 366  : 
; 367  : 	// no single member squads
; 368  : 	if (squadCount == 1)

	cmp	DWORD PTR _squadCount$[ebp], 1
	jne	SHORT $LN18@SquadRecru

; 369  : 	{
; 370  : 		m_hSquadLeader = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$LN18@SquadRecru:

; 371  : 	}
; 372  : 
; 373  : 	return squadCount;

	mov	eax, DWORD PTR _squadCount$[ebp]
$LN1@SquadRecru:

; 374  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SquadRecruit@CSquadMonster@@QAEHHH@Z ENDP		; CSquadMonster::SquadRecruit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.h
;	COMDAT ?IsLeader@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?IsLeader@CSquadMonster@@QAEHXZ PROC			; CSquadMonster::IsLeader, COMDAT
; _this$ = ecx

; 94   : 	int IsLeader ( void ) { return m_hSquadLeader == this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN3@IsLeader
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@IsLeader
$LN3@IsLeader:
	mov	DWORD PTR tv72[ebp], 0
$LN4@IsLeader:
	mov	eax, DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLeader@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::IsLeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.h
;	COMDAT ?InSquad@CSquadMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?InSquad@CSquadMonster@@QAEHXZ PROC			; CSquadMonster::InSquad, COMDAT
; _this$ = ecx

; 93   : 	int InSquad ( void ) { return m_hSquadLeader != NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $LN3@InSquad
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@InSquad
$LN3@InSquad:
	mov	DWORD PTR tv68[ebp], 0
$LN4@InSquad:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?InSquad@CSquadMonster@@QAEHXZ ENDP			; CSquadMonster::InSquad
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.h
;	COMDAT ?MySquadMember@CSquadMonster@@QAEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?MySquadMember@CSquadMonster@@QAEPAV1@H@Z PROC		; CSquadMonster::MySquadMember, COMDAT
; _this$ = ecx

; 87   : 	{ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		if (i >= MAX_SQUAD_MEMBERS-1)

	cmp	DWORD PTR _i$[ebp], 4
	jl	SHORT $LN2@MySquadMem

; 89   : 			return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@MySquadMem

; 90   : 		else

	jmp	SHORT $LN1@MySquadMem
$LN2@MySquadMem:

; 91   : 			return (CSquadMonster *)((CBaseEntity *)m_hSquadMember[i]); 

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+2292]
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
$LN1@MySquadMem:

; 92   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ENDP		; CSquadMonster::MySquadMember
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.h
;	COMDAT ?MySquadLeader@CSquadMonster@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSquadLeader$ = -4					; size = 4
?MySquadLeader@CSquadMonster@@QAEPAV1@XZ PROC		; CSquadMonster::MySquadLeader, COMDAT
; _this$ = ecx

; 80   : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		CSquadMonster *pSquadLeader = (CSquadMonster *)((CBaseEntity *)m_hSquadLeader); 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 82   : 		if (pSquadLeader != NULL)

	cmp	DWORD PTR _pSquadLeader$[ebp], 0
	je	SHORT $LN2@MySquadLea

; 83   : 			return pSquadLeader;

	mov	eax, DWORD PTR _pSquadLeader$[ebp]
	jmp	SHORT $LN1@MySquadLea
$LN2@MySquadLea:

; 84   : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
$LN1@MySquadLea:

; 85   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ENDP		; CSquadMonster::MySquadLeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
$T1 = -212						; size = 12
$T2 = -200						; size = 12
$T3 = -188						; size = 12
$T4 = -176						; size = 12
$T5 = -164						; size = 12
$T6 = -152						; size = 12
$T7 = -140						; size = 12
$T8 = -128						; size = 12
_rightPlane$ = -116					; size = 20
_leftPlane$ = -96					; size = 20
_backPlane$ = -76					; size = 20
_v_left$ = -56						; size = 12
_vecRightSide$ = -44					; size = 12
_vecLeftSide$ = -32					; size = 12
_pSquadLeader$ = -20					; size = 4
tv90 = -16						; size = 4
_i$9 = -12						; size = 4
_pMember$10 = -8					; size = 4
_this$ = -4						; size = 4
?NoFriendlyFire@CSquadMonster@@QAEHXZ PROC		; CSquadMonster::NoFriendlyFire
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	DWORD PTR _this$[ebp], ecx

; 446  : 	if ( !InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN5@NoFriendly

; 447  : 	{
; 448  : 		return TRUE;

	mov	eax, 1
	jmp	$LN1@NoFriendly
$LN5@NoFriendly:

; 449  : 	}
; 450  : 
; 451  : 	CPlane	backPlane;

	lea	ecx, DWORD PTR _backPlane$[ebp]
	call	??0CPlane@@QAE@XZ			; CPlane::CPlane

; 452  : 	CPlane  leftPlane;

	lea	ecx, DWORD PTR _leftPlane$[ebp]
	call	??0CPlane@@QAE@XZ			; CPlane::CPlane

; 453  : 	CPlane	rightPlane;

	lea	ecx, DWORD PTR _rightPlane$[ebp]
	call	??0CPlane@@QAE@XZ			; CPlane::CPlane

; 454  : 
; 455  : 	Vector	vecLeftSide;

	lea	ecx, DWORD PTR _vecLeftSide$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 456  : 	Vector	vecRightSide;

	lea	ecx, DWORD PTR _vecRightSide$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 457  : 	Vector	v_left;

	lea	ecx, DWORD PTR _v_left$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 458  : 
; 459  : 	//!!!BUGBUG - to fix this, the planes must be aligned to where the monster will be firing its gun, not the direction it is facing!!!
; 460  : 
; 461  : 	if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $LN6@NoFriendly

; 462  : 	{
; 463  : 		UTIL_MakeVectors ( UTIL_VecToAngles( m_hEnemy->Center() - GetAbsOrigin() ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1848				; 00000738H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR [eax+300]
	call	edx
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 464  : 	}
; 465  : 	else

	jmp	SHORT $LN7@NoFriendly
$LN6@NoFriendly:

; 466  : 	{
; 467  : 		// if there's no enemy, pretend there's a friendly in the way, so the grunt won't shoot.
; 468  : 		return FALSE;

	xor	eax, eax
	jmp	$LN1@NoFriendly
$LN7@NoFriendly:

; 469  : 	}
; 470  : 	
; 471  : 	vecLeftSide = GetAbsOrigin() - ( gpGlobals->v_right * ( pev->size.x * 1.5 ) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cvtss2sd xmm0, DWORD PTR [edx+244]
	mulsd	xmm0, QWORD PTR __real@3ff8000000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecLeftSide$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLeftSide$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLeftSide$[ebp+8], edx

; 472  : 	vecRightSide = GetAbsOrigin() + ( gpGlobals->v_right * ( pev->size.x * 1.5 ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cvtss2sd xmm0, DWORD PTR [ecx+244]
	mulsd	xmm0, QWORD PTR __real@3ff8000000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecRightSide$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecRightSide$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecRightSide$[ebp+8], eax

; 473  : 	v_left = gpGlobals->v_right * -1;

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _v_left$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _v_left$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _v_left$[ebp+8], edx

; 474  : 
; 475  : 	leftPlane.InitializePlane ( gpGlobals->v_right, vecLeftSide );

	lea	eax, DWORD PTR _vecLeftSide$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	push	ecx
	lea	ecx, DWORD PTR _leftPlane$[ebp]
	call	?InitializePlane@CPlane@@QAEXABVVector@@0@Z ; CPlane::InitializePlane

; 476  : 	rightPlane.InitializePlane ( v_left, vecRightSide );

	lea	edx, DWORD PTR _vecRightSide$[ebp]
	push	edx
	lea	eax, DWORD PTR _v_left$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rightPlane$[ebp]
	call	?InitializePlane@CPlane@@QAEXABVVector@@0@Z ; CPlane::InitializePlane

; 477  : 	backPlane.InitializePlane ( gpGlobals->v_forward, GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	push	ecx
	lea	ecx, DWORD PTR _backPlane$[ebp]
	call	?InitializePlane@CPlane@@QAEXABVVector@@0@Z ; CPlane::InitializePlane

; 478  : 
; 479  : /*
; 480  : 	ALERT ( at_console, "LeftPlane: %f %f %f : %f\n", leftPlane.m_vecNormal.x, leftPlane.m_vecNormal.y, leftPlane.m_vecNormal.z, leftPlane.m_flDist );
; 481  : 	ALERT ( at_console, "RightPlane: %f %f %f : %f\n", rightPlane.m_vecNormal.x, rightPlane.m_vecNormal.y, rightPlane.m_vecNormal.z, rightPlane.m_flDist );
; 482  : 	ALERT ( at_console, "BackPlane: %f %f %f : %f\n", backPlane.m_vecNormal.x, backPlane.m_vecNormal.y, backPlane.m_vecNormal.z, backPlane.m_flDist );
; 483  : */
; 484  : 
; 485  : 	CSquadMonster *pSquadLeader = MySquadLeader();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 486  : 	for (int i = 0; i < MAX_SQUAD_MEMBERS; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@NoFriendly
$LN2@NoFriendly:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN4@NoFriendly:
	cmp	DWORD PTR _i$9[ebp], 5
	jge	SHORT $LN3@NoFriendly

; 487  : 	{
; 488  : 		CSquadMonster *pMember = pSquadLeader->MySquadMember(i);

	mov	eax, DWORD PTR _i$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	call	?MySquadMember@CSquadMonster@@QAEPAV1@H@Z ; CSquadMonster::MySquadMember
	mov	DWORD PTR _pMember$10[ebp], eax

; 489  : 		if (pMember && pMember != this)

	cmp	DWORD PTR _pMember$10[ebp], 0
	je	SHORT $LN9@NoFriendly
	mov	ecx, DWORD PTR _pMember$10[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN9@NoFriendly

; 490  : 		{
; 491  : 
; 492  : 			if ( backPlane.PointInFront  ( pMember->GetAbsOrigin() ) &&
; 493  : 				 leftPlane.PointInFront  ( pMember->GetAbsOrigin() ) && 

	mov	ecx, DWORD PTR _pMember$10[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _backPlane$[ebp]
	call	?PointInFront@CPlane@@QAEHABVVector@@@Z	; CPlane::PointInFront
	test	eax, eax
	je	SHORT $LN9@NoFriendly
	mov	ecx, DWORD PTR _pMember$10[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _leftPlane$[ebp]
	call	?PointInFront@CPlane@@QAEHABVVector@@@Z	; CPlane::PointInFront
	test	eax, eax
	je	SHORT $LN9@NoFriendly
	mov	ecx, DWORD PTR _pMember$10[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _rightPlane$[ebp]
	call	?PointInFront@CPlane@@QAEHABVVector@@@Z	; CPlane::PointInFront
	test	eax, eax
	je	SHORT $LN9@NoFriendly

; 494  : 				 rightPlane.PointInFront ( pMember->GetAbsOrigin()) )
; 495  : 			{
; 496  : 				// this guy is in the check volume! Don't shoot!
; 497  : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@NoFriendly
$LN9@NoFriendly:

; 498  : 			}
; 499  : 		}
; 500  : 	}

	jmp	SHORT $LN2@NoFriendly
$LN3@NoFriendly:

; 501  : 
; 502  : 	return TRUE;

	mov	eax, 1
$LN1@NoFriendly:

; 503  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NoFriendlyFire@CSquadMonster@@QAEHXZ ENDP		; CSquadMonster::NoFriendlyFire
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_iSquadSlots$ = -20					; size = 4
_iMask$ = -16						; size = 4
_pSquadLeader$ = -12					; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_iDesiredSlots$ = 8					; size = 4
?OccupySlot@CSquadMonster@@QAEHH@Z PROC			; CSquadMonster::OccupySlot
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 	int i;
; 46   : 	int iMask;
; 47   : 	int iSquadSlots;
; 48   : 
; 49   : 	if ( !InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	SHORT $LN5@OccupySlot

; 50   : 	{
; 51   : 		return TRUE;

	mov	eax, 1
	jmp	$LN1@OccupySlot
$LN5@OccupySlot:

; 52   : 	}
; 53   : 
; 54   : 	if ( SquadEnemySplit() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadEnemySplit@CSquadMonster@@QAEHXZ	; CSquadMonster::SquadEnemySplit
	test	eax, eax
	je	SHORT $LN6@OccupySlot

; 55   : 	{
; 56   : 		// if the squad members aren't all fighting the same enemy, slots are disabled
; 57   : 		// so that a squad member doesn't get stranded unable to engage his enemy because
; 58   : 		// all of the attack slots are taken by squad members fighting other enemies.
; 59   : 		m_iMySlot = bits_SLOT_SQUAD_SPLIT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2336], 1024		; 00000400H

; 60   : 		return TRUE;

	mov	eax, 1
	jmp	$LN1@OccupySlot
$LN6@OccupySlot:

; 61   : 	}
; 62   : 
; 63   : 	CSquadMonster *pSquadLeader = MySquadLeader();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	DWORD PTR _pSquadLeader$[ebp], eax

; 64   : 
; 65   : 	if ( !( iDesiredSlots ^ pSquadLeader->m_afSquadSlots ) )

	mov	ecx, DWORD PTR _pSquadLeader$[ebp]
	mov	edx, DWORD PTR _iDesiredSlots$[ebp]
	xor	edx, DWORD PTR [ecx+2324]
	jne	SHORT $LN7@OccupySlot

; 66   : 	{
; 67   : 		// none of the desired slots are available. 
; 68   : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@OccupySlot
$LN7@OccupySlot:

; 69   : 	}
; 70   : 
; 71   : 	iSquadSlots = pSquadLeader->m_afSquadSlots;

	mov	eax, DWORD PTR _pSquadLeader$[ebp]
	mov	ecx, DWORD PTR [eax+2324]
	mov	DWORD PTR _iSquadSlots$[ebp], ecx

; 72   : 
; 73   : 	for ( i = 0; i < NUM_SLOTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@OccupySlot
$LN2@OccupySlot:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@OccupySlot:
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jge	SHORT $LN3@OccupySlot

; 74   : 	{
; 75   : 		iMask = 1<<i;

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	mov	DWORD PTR _iMask$[ebp], eax

; 76   : 		if ( iDesiredSlots & iMask ) // am I looking for this bit?

	mov	ecx, DWORD PTR _iDesiredSlots$[ebp]
	and	ecx, DWORD PTR _iMask$[ebp]
	je	SHORT $LN8@OccupySlot

; 77   : 		{
; 78   : 			if ( !(iSquadSlots & iMask) )	// Is it already taken?

	mov	edx, DWORD PTR _iSquadSlots$[ebp]
	and	edx, DWORD PTR _iMask$[ebp]
	jne	SHORT $LN8@OccupySlot

; 79   : 			{
; 80   : 				// No, use this bit
; 81   : 				pSquadLeader->m_afSquadSlots |= iMask;

	mov	eax, DWORD PTR _pSquadLeader$[ebp]
	mov	ecx, DWORD PTR [eax+2324]
	or	ecx, DWORD PTR _iMask$[ebp]
	mov	edx, DWORD PTR _pSquadLeader$[ebp]
	mov	DWORD PTR [edx+2324], ecx

; 82   : 				m_iMySlot = iMask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iMask$[ebp]
	mov	DWORD PTR [eax+2336], ecx

; 83   : //				ALERT ( at_aiconsole, "Took slot %d - %d\n", i, m_hSquadLeader->m_afSquadSlots );
; 84   : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@OccupySlot
$LN8@OccupySlot:

; 85   : 			}
; 86   : 		}
; 87   : 	}

	jmp	SHORT $LN2@OccupySlot
$LN3@OccupySlot:

; 88   : 
; 89   : 	return FALSE;

	xor	eax, eax
$LN1@OccupySlot:

; 90   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?OccupySlot@CSquadMonster@@QAEHH@Z ENDP			; CSquadMonster::OccupySlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pevAttacker$ = 8					; size = 4
_iGib$ = 12						; size = 4
?Killed@CSquadMonster@@UAEXPAUentvars_s@@H@Z PROC	; CSquadMonster::Killed
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	VacateSlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?VacateSlot@CSquadMonster@@QAEXXZ	; CSquadMonster::VacateSlot

; 119  : 
; 120  : 	if ( InSquad() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $LN2@Killed

; 121  : 	{
; 122  : 		MySquadLeader()->SquadRemove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	mov	ecx, eax
	call	?SquadRemove@CSquadMonster@@QAEXPAV1@@Z	; CSquadMonster::SquadRemove
$LN2@Killed:

; 123  : 	}
; 124  : 
; 125  : 	CBaseMonster :: Killed ( pevAttacker, iGib );

	mov	ecx, DWORD PTR _iGib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z ; CBaseMonster::Killed

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Killed@CSquadMonster@@UAEXPAUentvars_s@@H@Z ENDP	; CSquadMonster::Killed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ScheduleChange@CSquadMonster@@UAEXXZ PROC		; CSquadMonster::ScheduleChange
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 	VacateSlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?VacateSlot@CSquadMonster@@QAEXXZ	; CSquadMonster::VacateSlot

; 111  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScheduleChange@CSquadMonster@@UAEXXZ ENDP		; CSquadMonster::ScheduleChange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
?VacateSlot@CSquadMonster@@QAEXXZ PROC			; CSquadMonster::VacateSlot
; _this$ = ecx

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 	if ( m_iMySlot != bits_NO_SLOT && InSquad() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2336], 0
	je	SHORT $LN1@VacateSlot
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $LN1@VacateSlot

; 98   : 	{
; 99   : //		ALERT ( at_aiconsole, "Vacated Slot %d - %d\n", m_iMySlot, m_hSquadLeader->m_afSquadSlots );
; 100  : 		MySquadLeader()->m_afSquadSlots &= ~m_iMySlot;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	add	eax, 2324				; 00000914H
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2336]
	not	edx
	mov	eax, DWORD PTR tv74[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR [ecx], edx

; 101  : 		m_iMySlot = bits_NO_SLOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2336], 0
$LN1@VacateSlot:

; 102  : 	}
; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VacateSlot@CSquadMonster@@QAEXXZ ENDP			; CSquadMonster::VacateSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_iSquadSize$1 = -8					; size = 4
_this$ = -4						; size = 4
?StartMonster@CSquadMonster@@UAEXXZ PROC		; CSquadMonster::StartMonster
; _this$ = ecx

; 407  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 408  : 	CBaseMonster :: StartMonster();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartMonster@CBaseMonster@@UAEXXZ	; CBaseMonster::StartMonster

; 409  : 
; 410  : 	if ( ( m_afCapability & bits_CAP_SQUAD ) && !InSquad() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2192]
	and	ecx, 8
	je	$LN1@StartMonst
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	jne	$LN1@StartMonst

; 411  : 	{
; 412  : 		if ( !FStringNull( pev->netname ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@StartMonst

; 413  : 		{
; 414  : 			// if I have a groupname, I can only recruit if I'm flagged as leader
; 415  : 			if ( !( pev->spawnflags & SF_SQUADMONSTER_LEADER ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 32					; 00000020H
	jne	SHORT $LN3@StartMonst

; 416  : 			{
; 417  : 				return;

	jmp	SHORT $LN1@StartMonst
$LN3@StartMonst:

; 418  : 			}
; 419  : 		}
; 420  : 
; 421  : 		// try to form squads now.
; 422  : 		int iSquadSize = SquadRecruit( 1024, 4 );

	push	4
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadRecruit@CSquadMonster@@QAEHHH@Z	; CSquadMonster::SquadRecruit
	mov	DWORD PTR _iSquadSize$1[ebp], eax

; 423  : 
; 424  : 		if ( iSquadSize )

	cmp	DWORD PTR _iSquadSize$1[ebp], 0
	je	SHORT $LN5@StartMonst

; 425  : 		{
; 426  : 		  ALERT ( at_aiconsole, "Squad of %d %s formed\n", iSquadSize, STRING( pev->classname ) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _iSquadSize$1[ebp]
	push	edx
	push	OFFSET $SG75479
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$LN5@StartMonst:

; 427  : 		}
; 428  : 
; 429  : 		if ( IsLeader() && FClassnameIs ( pev, "monster_human_grunt" ) )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLeader@CSquadMonster@@QAEHXZ		; CSquadMonster::IsLeader
	test	eax, eax
	je	SHORT $LN1@StartMonst
	push	OFFSET $SG75481
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@StartMonst

; 430  : 		{
; 431  : 			SetBodygroup( 1, 1 ); // UNDONE: truly ugly hack

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBodygroup@CBaseAnimating@@QAEXHH@Z	; CBaseAnimating::SetBodygroup

; 432  : 			pev->skin = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+272], 0
$LN1@StartMonst:

; 433  : 		}
; 434  : 
; 435  : 	}
; 436  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartMonster@CSquadMonster@@UAEXXZ ENDP		; CSquadMonster::StartMonster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\squadmonster.cpp
_TEXT	SEGMENT
_iUpdatedLKP$ = -8					; size = 4
_this$ = -4						; size = 4
_pEnemy$ = 8						; size = 4
?CheckEnemy@CSquadMonster@@UAEHPAVCBaseEntity@@@Z PROC	; CSquadMonster::CheckEnemy
; _this$ = ecx

; 380  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 	int iUpdatedLKP;
; 382  : 
; 383  : 	iUpdatedLKP = CBaseMonster :: CheckEnemy ( m_hEnemy );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ; CBaseMonster::CheckEnemy
	mov	DWORD PTR _iUpdatedLKP$[ebp], eax

; 384  : 	
; 385  : 	// communicate with squad members about the enemy IF this individual has the same enemy as the squad leader.
; 386  : 	if ( InSquad() && (CBaseEntity *)m_hEnemy == MySquadLeader()->m_hEnemy )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InSquad@CSquadMonster@@QAEHXZ		; CSquadMonster::InSquad
	test	eax, eax
	je	SHORT $LN2@CheckEnemy
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1848				; 00000738H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MySquadLeader@CSquadMonster@@QAEPAV1@XZ ; CSquadMonster::MySquadLeader
	add	eax, 1848				; 00000738H
	mov	ecx, eax
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	esi, eax
	jne	SHORT $LN2@CheckEnemy

; 387  : 	{
; 388  : 		if ( iUpdatedLKP )

	cmp	DWORD PTR _iUpdatedLKP$[ebp], 0
	je	SHORT $LN3@CheckEnemy

; 389  : 		{
; 390  : 			// have new enemy information, so paste to the squad.
; 391  : 			SquadPasteEnemyInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadPasteEnemyInfo@CSquadMonster@@QAEXXZ ; CSquadMonster::SquadPasteEnemyInfo

; 392  : 		}
; 393  : 		else

	jmp	SHORT $LN2@CheckEnemy
$LN3@CheckEnemy:

; 394  : 		{
; 395  : 			// enemy unseen, copy from the squad knowledge.
; 396  : 			SquadCopyEnemyInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SquadCopyEnemyInfo@CSquadMonster@@QAEXXZ ; CSquadMonster::SquadCopyEnemyInfo
$LN2@CheckEnemy:

; 397  : 		}
; 398  : 	}
; 399  : 
; 400  : 	return iUpdatedLKP;

	mov	eax, DWORD PTR _iUpdatedLKP$[ebp]

; 401  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckEnemy@CSquadMonster@@UAEHPAVCBaseEntity@@@Z ENDP	; CSquadMonster::CheckEnemy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\basemonster.h
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iConditions$ = 8					; size = 4
?HasConditions@CBaseMonster@@QAEHH@Z PROC		; CBaseMonster::HasConditions, COMDAT
; _this$ = ecx

; 258  : 		inline BOOL HasConditions( int iConditions ) { if ( m_afConditions & iConditions ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1844]
	and	ecx, DWORD PTR _iConditions$[ebp]
	je	SHORT $LN2@HasConditi
	mov	eax, 1
	jmp	SHORT $LN1@HasConditi
$LN2@HasConditi:
	xor	eax, eax
$LN1@HasConditi:
	mov	esp, ebp
	pop	ebp
	ret	4
?HasConditions@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::HasConditions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\monsters\basemonster.h
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iConditions$ = 8					; size = 4
?SetConditions@CBaseMonster@@QAEXH@Z PROC		; CBaseMonster::SetConditions, COMDAT
; _this$ = ecx

; 256  : 		inline void	SetConditions( int iConditions ) { m_afConditions |= iConditions; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1844]
	or	ecx, DWORD PTR _iConditions$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1844], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::SetConditions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC		; CBaseEntity::edict, COMDAT
; _this$ = ecx

; 696  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC			; EHANDLE::operator->, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pEntity$ = 8						; size = 4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC		; EHANDLE::operator=, COMDAT
; _this$ = ecx

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $LN2@operator

; 71   : 	{
; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@operator

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN4@operator:

; 75   : 	}
; 76   : 	else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 77   : 	{
; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN3@operator:

; 80   : 	}
; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC			; EHANDLE::operator CBaseEntity *, COMDAT
; _this$ = ecx

; 64   : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
??BEHANDLE@@QAEHXZ PROC					; EHANDLE::operator int, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	test	eax, eax
	je	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 87   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC			; EHANDLE::Get, COMDAT
; _this$ = ecx

; 40   : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Get

; 42   : 	{
; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN2@Get

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN1@Get
$LN2@Get:

; 50   : 	}
; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$LN1@Get:

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8						; size = 4
_szClassname$ = 12					; size = 4
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@FClassname
	xor	eax, eax
	jmp	SHORT $LN1@FClassname
$LN2@FClassname:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$LN1@FClassname:

; 297  : }

	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
_sz1$ = 8						; size = 4
_sz2$ = 12						; size = 4
?FStrEq@@YAHPBD0@Z PROC					; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@FStrEq
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@FStrEq
$LN3@FStrEq:
	mov	DWORD PTR tv69[ebp], 0
$LN4@FStrEq:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_iString$ = 8						; size = 4
?FStringNull@@YAHH@Z PROC				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	push	ecx
	cmp	DWORD PTR _iString$[ebp], 0
	jne	SHORT $LN3@FStringNul
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@FStringNul
$LN3@FStringNul:
	mov	DWORD PTR tv65[ebp], 0
$LN4@FStringNul:
	mov	eax, DWORD PTR tv65[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
tv70 = -4						; size = 4
_pev$ = 8						; size = 4
?FNullEnt@@YAHPAUentvars_s@@@Z PROC			; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $LN3@FNullEnt
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@FNullEnt
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@FNullEnt
$LN3@FNullEnt:
	mov	DWORD PTR tv70[ebp], 1
$LN4@FNullEnt:
	mov	eax, DWORD PTR tv70[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_eoffset$ = 8						; size = 4
?FNullEnt@@YAHH@Z PROC					; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	cmp	DWORD PTR _eoffset$[ebp], 0
	jne	SHORT $LN3@FNullEnt
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@FNullEnt
$LN3@FNullEnt:
	mov	DWORD PTR tv65[ebp], 0
$LN4@FNullEnt:
	mov	eax, DWORD PTR tv65[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8						; size = 4
?OFFSET@@YAHPAUentvars_s@@@Z PROC			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $LN2@OFFSET

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET ??_C@_0BF@DOONGEFO@Bad?5pev?5in?5OFFSET?$CI?$CJ?6@
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN2@OFFSET:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8						; size = 4
?OFFSET@@YAHPBUedict_s@@@Z PROC				; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $LN2@OFFSET

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET ??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN2@OFFSET:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8						; size = 4
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT
; _this$ = ecx

; 148  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC		; CUtlMemory<char *,int>::IsReadOnly, COMDAT
; _this$ = ecx

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	jne	SHORT $LN3@IsReadOnly
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsReadOnly
$LN3@IsReadOnly:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsReadOnly:
	mov	al, BYTE PTR tv66[ebp]

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC	; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jge	SHORT $LN3@IsExternal
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsExternal
$LN3@IsExternal:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsExternal:
	mov	al, BYTE PTR tv66[ebp]

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC			; CUtlMemory<char *,int>::Purge, COMDAT
; _this$ = ecx

; 645  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@Purge

; 647  : 	{
; 648  : 		if (m_pMemory)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Purge

; 649  : 		{
; 650  : 			free( (void*)m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@Purge:

; 652  : 		}
; 653  : 		m_nAllocationCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN1@Purge:

; 654  : 	}
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC		; CUtlMemory<char *,int>::Base, COMDAT
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Base
	push	488					; 000001e8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Base:

; 489  : 	return m_pMemory;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 490  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC		; CUtlMemory<char *,int>::IsIdxValid, COMDAT
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsIdxValid
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN3@IsIdxValid
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsIdxValid
$LN3@IsIdxValid:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsIdxValid:
	mov	al, BYTE PTR tv67[ebp]

; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC			; CUtlMemory<char *,int>::operator[], COMDAT
; _this$ = ecx

; 423  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	push	424					; 000001a8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 425  : 	assert( IsIdxValid(i) );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	push	425					; 000001a9H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@operator:

; 426  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlMemory@PADH@@QAE@XZ PROC			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT
; _this$ = ecx

; 322  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlMemory@PADH@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlMemory@PADH@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlMemory@PADH@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nGrowSize$ = 8						; size = 4
_nInitAllocationCount$ = 12				; size = 4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC			; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 293  : CUtlMemory<T,I>::CUtlMemory( int nGrowSize, int nInitAllocationCount ) : m_pMemory(0), 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 294  : 	m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $LN4@CUtlMemory
	push	297					; 00000129H
	push	OFFSET $SG75611
	push	OFFSET $SG75612
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@CUtlMemory:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@CUtlMemory

; 299  : 	{
; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@CUtlMemory:

; 301  : 	}
; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
	mov	edx, DWORD PTR _i$1[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
	js	SHORT $LN3@RemoveAll

; 728  : 	{
; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	??$Destruct@PAD@@YAXPAPAD@Z		; Destruct<char *>
	add	esp, 4

; 730  : 	}

	jmp	SHORT $LN4@RemoveAll
$LN3@RemoveAll:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC	; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT
; _this$ = ecx

; 344  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT
; _this$ = ecx

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_growSize$ = 8						; size = 4
_initSize$ = 12						; size = 4
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	m_Memory(growSize, initSize), m_Size(0)

	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\common\datamap.h
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_i$3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT
; _this$ = ecx

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@CDatadescG
$LN2@CDatadescG:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@CDatadescG:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$3[ebp], eax
	jge	SHORT $LN1@CDatadescG

; 199  : 		{
; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], edx
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 201  : 		}

	jmp	SHORT $LN2@CDatadescG
$LN1@CDatadescG:

; 202  : 	}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\common\datamap.h
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszBase$ = 8						; size = 4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT
; _this$ = ecx

; 192  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 	CDatadescGeneratedNameHolder( const char *pszBase ) : m_pszBase(pszBase)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx

; 192  : 	{

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\enginecallback.h
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8						; size = 4
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC			; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN2@GET_PRIVAT

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $LN1@GET_PRIVAT
$LN2@GET_PRIVAT:

; 104  : 	return NULL;

	xor	eax, eax
$LN1@GET_PRIVAT:

; 105  : }

	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0gametrace_s@@QAE@XZ PROC				; gametrace_s::gametrace_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
tv84 = -8						; size = 4
_this$ = -4						; size = 4
?Length2D@Vector@@QBEMXZ PROC				; Vector::Length2D, COMDAT
; _this$ = ecx

; 271  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv84[ebp]
	fld	DWORD PTR tv84[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
??DVector@@QBE?AV0@M@Z PROC				; Vector::operator*, COMDAT
; _this$ = ecx

; 150  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator+, COMDAT
; _this$ = ecx

; 146  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
