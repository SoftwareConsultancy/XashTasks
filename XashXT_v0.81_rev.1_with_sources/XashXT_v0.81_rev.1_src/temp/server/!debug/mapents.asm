; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\server\mapents.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG74470 DB	',', 00H
	ORG $+2
$SG74472 DB	'Entity %s[%d] has multiple parent [%s]:', 00H
$SG74473 DB	' %s[%d],', 00H
	ORG $+3
$SG74474 DB	' %s[%d]', 00H
$SG74476 DB	0aH, 00H
	ORG $+2
$SG74491 DB	'LEVEL DESIGN ERROR: Entity %s is parented to itself!', 0aH
	DB	00H
	ORG $+2
$SG74534 DB	'ED_ParseEdict: EOF without closing brace', 0aH, 00H
	ORG $+2
$SG74537 DB	'ED_ParseEdict: EOF without closing brace', 0aH, 00H
	ORG $+2
$SG74539 DB	'ED_ParseEdict: closing brace without data', 0aH, 00H
	ORG $+1
$SG74542 DB	'wad', 00H
$SG74545 DB	'classname', 00H
	ORG $+2
$SG74550 DB	'Can''t initialize world!', 0aH, 00H
	ORG $+3
$SG74554 DB	'angle', 00H
	ORG $+2
$SG74555 DB	'angles', 00H
	ORG $+1
$SG74558 DB	'%g %g %g', 00H
	ORG $+3
$SG74561 DB	'-90 0 0', 00H
$SG74564 DB	'90 0 0', 00H
	ORG $+1
$SG74565 DB	'0 0 0', 00H
	ORG $+2
$SG74567 DB	'light', 00H
	ORG $+2
$SG74568 DB	'light_level', 00H
$SG74607 DB	'ED_LoadFromFile: found %s when expecting {', 0aH, 00H
$SG74614 DB	'can''t spawn the world', 0aH, 00H
	ORG $+1
$SG74620 DB	'%s linked with %s', 0aH, 00H
	ORG $+1
$SG74624 DB	'%s attached with %s', 0aH, 00H
	ORG $+3
$SG74625 DB	0aH, '%i entities inhibited', 0aH, 00H
$SG74844 DB	'0', 00H, 00H, 00H
$SG74674 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74675 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG74718 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG74850 DB	'0', 00H, 00H, 00H
$SG74719 DB	'(', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '+', 00H, ' ', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '(', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG74841 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG74854 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG74720 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG74856 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG74721 DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')'
	DB	00H, 00H, 00H
$SG74793 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+4
$SG74794 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
	ORG $+4
$SG74840 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74843 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74849 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74853 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG74855 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
PUBLIC	?INDEXENT@@YAPAUedict_s@@H@Z			; INDEXENT
PUBLIC	?CheckForMultipleParents@@YAXPAVCBaseEntity@@0@Z ; CheckForMultipleParents
PUBLIC	?DispatchSpawnEntities@@YAHPBDPAD@Z		; DispatchSpawnEntities
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
PUBLIC	?GetTargetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTargetname
PUBLIC	?GetDebugName@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetDebugName
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
PUBLIC	?entindex@CBaseEntity@@QAEHXZ			; CBaseEntity::entindex
PUBLIC	?ED_ParseEdict@@YAPAVCBaseEntity@@PAPADPAUedict_s@@@Z ; ED_ParseEdict
PUBLIC	?ED_SpawnEdict@@YAHPAUedict_s@@@Z		; ED_SpawnEdict
PUBLIC	??_C@_04MLLLIHIP@null@				; `string'
PUBLIC	__real@00000000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_qsort:PROC
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:PROC			; Q_strncpy
EXTRN	?copystring@@YAPADPBD@Z:PROC			; copystring
EXTRN	?Q_atof@@YAMPBD@Z:PROC				; Q_atof
EXTRN	?Q_strncmp@@YAHPBD0H@Z:PROC			; Q_strncmp
EXTRN	?va@@YAPADPBDZZ:PROC				; va
EXTRN	?COM_ParseFileExt@@YAPADPAD0J_N@Z:PROC		; COM_ParseFileExt
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:PROC ; EntityFactoryDictionary
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:PROC ; DBG_EntOfVars
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:PROC	; ENT
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:PROC ; UTIL_FindEntityByTargetname
EXTRN	?DispatchSpawn@@YAHPAUedict_s@@@Z:PROC		; DispatchSpawn
EXTRN	?DispatchKeyValue@@YAXPAUedict_s@@PAUKeyValueData_s@@@Z:PROC ; DispatchKeyValue
EXTRN	?SetParent@CBaseEntity@@QAEXHH@Z:PROC		; CBaseEntity::SetParent
EXTRN	?SetParent@CBaseEntity@@QAEXPAV1@H@Z:PROC	; CBaseEntity::SetParent
EXTRN	?HasAttachment@CBaseEntity@@QAEHXZ:PROC		; CBaseEntity::HasAttachment
EXTRN	?IsDormant@CBaseEntity@@QAEHXZ:PROC		; CBaseEntity::IsDormant
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null@
CONST	SEGMENT
??_C@_04MLLLIHIP@null@ DB 'null', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
_ent$ = 8						; size = 4
?ED_SpawnEdict@@YAHPAUedict_s@@@Z PROC			; ED_SpawnEdict

; 222  : {

	push	ebp
	mov	ebp, esp

; 223  : 	if( DispatchSpawn( ent ) < 0 )

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?DispatchSpawn@@YAHPAUedict_s@@@Z	; DispatchSpawn
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN2@ED_SpawnEd

; 224  : 	{
; 225  : 		// game rejected the spawn and not marked for delete
; 226  : 		if( !FBitSet( ent->v.flags, FL_KILLME ))

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 1073741824				; 40000000H
	jne	SHORT $LN2@ED_SpawnEd

; 227  : 		{
; 228  : 			REMOVE_ENTITY( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4

; 229  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ED_SpawnEd
$LN2@ED_SpawnEd:

; 230  : 		}
; 231  : 	}
; 232  : 	return 1;

	mov	eax, 1
$LN1@ED_SpawnEd:

; 233  : }

	pop	ebp
	ret	0
?ED_SpawnEdict@@YAHPAUedict_s@@@Z ENDP			; ED_SpawnEdict
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
$T1 = -6456						; size = 4
$T2 = -6452						; size = 4
$T3 = -6448						; size = 4
$T4 = -6444						; size = 4
$T5 = -6440						; size = 4
$T6 = -6436						; size = 4
$T7 = -6432						; size = 4
_iszClassName$ = -6428					; size = 4
_flYawAngle$8 = -6424					; size = 4
_classname$ = -6420					; size = 4
_pEntity$ = -6416					; size = 4
_numpairs$ = -6412					; size = 4
_i$ = -6408						; size = 4
_pkvd$ = -6404						; size = 4096
_token$ = -2308						; size = 2048
_keyname$9 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_pfile$ = 8						; size = 4
_ent$ = 12						; size = 4
?ED_ParseEdict@@YAPAVCBaseEntity@@PAPADPAUedict_s@@@Z PROC ; ED_ParseEdict

; 106  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 6456				; 00001938H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 107  : 	KeyValueData	pkvd[256]; // per one entity
; 108  : 	int		i, numpairs = 0;

	mov	DWORD PTR _numpairs$[ebp], 0

; 109  : 	const char	*classname = NULL;

	mov	DWORD PTR _classname$[ebp], 0
$LN36@ED_ParseEd:

; 110  : 	char		token[2048];
; 111  : 
; 112  : 	// go through all the dictionary pairs
; 113  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@ED_ParseEd

; 114  : 	{	
; 115  : 		char	keyname[256];
; 116  : 
; 117  : 		// parse key
; 118  : 		if(( *pfile = COM_ParseFile( *pfile, token )) == NULL )

	push	1
	push	2048					; 00000800H
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN10@ED_ParseEd

; 119  : 			HOST_ERROR( "ED_ParseEdict: EOF without closing brace\n" );

	push	OFFSET $SG74534
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 4
$LN10@ED_ParseEd:

; 120  : 
; 121  : 		if( token[0] == '}' ) break; // end of desc

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN11@ED_ParseEd
	jmp	$LN3@ED_ParseEd
$LN11@ED_ParseEd:

; 122  : 
; 123  : 		Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyname$9[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 124  : 
; 125  : 		// parse value	
; 126  : 		if(( *pfile = COM_ParseFile( *pfile, token )) == NULL ) 

	push	1
	push	2048					; 00000800H
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN12@ED_ParseEd

; 127  : 			HOST_ERROR( "ED_ParseEdict: EOF without closing brace\n" );

	push	OFFSET $SG74537
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 4
$LN12@ED_ParseEd:

; 128  : 
; 129  : 		if( token[0] == '}' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _token$[ebp+edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN13@ED_ParseEd

; 130  : 			HOST_ERROR( "ED_ParseEdict: closing brace without data\n" );

	push	OFFSET $SG74539
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 4
$LN13@ED_ParseEd:

; 131  : 
; 132  : 		// ignore attempts to set key ""
; 133  : 		if( !keyname[0] ) continue;

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _keyname$9[ebp+edx]
	test	eax, eax
	jne	SHORT $LN14@ED_ParseEd
	jmp	$LN36@ED_ParseEd
$LN14@ED_ParseEd:

; 134  : 
; 135  : 		// "wad" field is completely ignored in XashXT
; 136  : 		if( !Q_strcmp( keyname, "wad" ))

	push	99999					; 0001869fH
	push	OFFSET $SG74542
	lea	ecx, DWORD PTR _keyname$9[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@ED_ParseEd

; 137  : 			continue;

	jmp	$LN36@ED_ParseEd
$LN15@ED_ParseEd:

; 138  : 
; 139  : 		// ignore attempts to set value ""
; 140  : 		if( !token[0] ) continue;

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _token$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN16@ED_ParseEd
	jmp	$LN36@ED_ParseEd
$LN16@ED_ParseEd:

; 141  : 
; 142  : 		// create keyvalue strings
; 143  : 		pkvd[numpairs].szClassName = (char *)classname;	// unknown at this moment

	mov	edx, DWORD PTR _numpairs$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _classname$[ebp]
	mov	DWORD PTR _pkvd$[ebp+edx], eax

; 144  : 		pkvd[numpairs].szKeyName = copystring( keyname );

	lea	ecx, DWORD PTR _keyname$9[ebp]
	push	ecx
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	edx, DWORD PTR _numpairs$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+4], eax

; 145  : 		pkvd[numpairs].szValue = copystring( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax

; 146  : 		pkvd[numpairs].fHandled = false;		

	mov	edx, DWORD PTR _numpairs$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+12], 0

; 147  : 
; 148  : 		if( !Q_strcmp( keyname, "classname" ) && classname == NULL )

	push	99999					; 0001869fH
	push	OFFSET $SG74545
	lea	eax, DWORD PTR _keyname$9[ebp]
	push	eax
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@ED_ParseEd
	cmp	DWORD PTR _classname$[ebp], 0
	jne	SHORT $LN17@ED_ParseEd

; 149  : 			classname = pkvd[numpairs].szValue;

	mov	ecx, DWORD PTR _numpairs$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	mov	DWORD PTR _classname$[ebp], edx
$LN17@ED_ParseEd:

; 150  : 		if( ++numpairs >= 256 ) break;

	mov	eax, DWORD PTR _numpairs$[ebp]
	add	eax, 1
	mov	DWORD PTR _numpairs$[ebp], eax
	cmp	DWORD PTR _numpairs$[ebp], 256		; 00000100H
	jl	SHORT $LN18@ED_ParseEd
	jmp	SHORT $LN3@ED_ParseEd
$LN18@ED_ParseEd:

; 151  : 	}

	jmp	$LN36@ED_ParseEd
$LN3@ED_ParseEd:

; 152  : 
; 153  : 	CBaseEntity *pEntity;
; 154  : 	string_t iszClassName = ALLOC_STRING( classname ); // need to have a valid copy of this string

	mov	ecx, DWORD PTR _classname$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	DWORD PTR _iszClassName$[ebp], eax

; 155  : 
; 156  : 	if( ent )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN19@ED_ParseEd

; 157  : 	{
; 158  : 		// initialize world
; 159  : 		pEntity = CreateEntityByName( STRING( iszClassName ), VARS( ent ));

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _iszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax

; 160  : 
; 161  : 		// make sure what world is really initailized
; 162  : 		if( !pEntity ) HOST_ERROR( "Can't initialize world!\n" );

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $LN21@ED_ParseEd
	push	OFFSET $SG74550
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 4
$LN21@ED_ParseEd:

; 163  : 		pEntity->m_iParent = NULL_STRING; // don't allow a parent on the first entity (worldspawn)

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+172], 0

; 164  : 	}
; 165  : 	else

	jmp	SHORT $LN20@ED_ParseEd
$LN19@ED_ParseEd:

; 166  : 	{
; 167  : 		// any other entity
; 168  : 		pEntity = CreateEntityByName( STRING( iszClassName ));

	push	0
	mov	edx, DWORD PTR _iszClassName$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax
$LN20@ED_ParseEd:

; 169  : 	}
; 170  : 
; 171  : 	if( !pEntity || ENT( pEntity )->free || FBitSet( pEntity->pev->flags, FL_KILLME ))

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $LN23@ED_ParseEd
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN23@ED_ParseEd
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN22@ED_ParseEd
$LN23@ED_ParseEd:

; 172  : 	{
; 173  : 		// release allocated strings
; 174  : 		for( i = 0; i < numpairs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@ED_ParseEd
$LN4@ED_ParseEd:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@ED_ParseEd:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numpairs$[ebp]
	jge	SHORT $LN5@ED_ParseEd

; 175  : 		{
; 176  : 			freestring( pkvd[i].szKeyName );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 177  : 			freestring( pkvd[i].szValue );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+8]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 178  : 		}

	jmp	SHORT $LN4@ED_ParseEd
$LN5@ED_ParseEd:

; 179  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@ED_ParseEd
$LN22@ED_ParseEd:

; 180  : 	}
; 181  : 
; 182  : 	for( i = 0; i < numpairs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@ED_ParseEd
$LN7@ED_ParseEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@ED_ParseEd:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numpairs$[ebp]
	jge	$LN8@ED_ParseEd

; 183  : 	{
; 184  : 		if( !Q_strcmp( pkvd[i].szKeyName, "angle" ))

	push	99999					; 0001869fH
	push	OFFSET $SG74554
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	push	eax
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN30@ED_ParseEd

; 185  : 		{
; 186  : 			float	flYawAngle = Q_atof( pkvd[i].szValue );

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pkvd$[ebp+ecx+8]
	push	edx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fstp	DWORD PTR _flYawAngle$8[ebp]

; 187  : 
; 188  : 			freestring( pkvd[i].szKeyName ); // will be replace with 'angles'

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 189  : 			freestring( pkvd[i].szValue ); // release old value, so we don't need these

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+8]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 190  : 			pkvd[i].szKeyName = copystring( "angles" );

	push	OFFSET $SG74555
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+4], eax

; 191  : 
; 192  : 			if( flYawAngle >= 0.0f )

	movss	xmm0, DWORD PTR _flYawAngle$8[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN25@ED_ParseEd

; 193  : 				pkvd[i].szValue = copystring( va( "%g %g %g", pEntity->pev->angles.x, flYawAngle, pEntity->pev->angles.z ));

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cvtss2sd xmm0, DWORD PTR [eax+88]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _flYawAngle$8[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cvtss2sd xmm0, DWORD PTR [edx+80]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG74558
	call	?va@@YAPADPBDZZ				; va
	add	esp, 28					; 0000001cH
	push	eax
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
	jmp	$LN30@ED_ParseEd
$LN25@ED_ParseEd:

; 194  : 			else if( flYawAngle == -1.0f )

	movss	xmm0, DWORD PTR _flYawAngle$8[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN27@ED_ParseEd

; 195  : 				pkvd[i].szValue = copystring( "-90 0 0" );

	push	OFFSET $SG74561
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax
	jmp	SHORT $LN30@ED_ParseEd
$LN27@ED_ParseEd:

; 196  : 			else if( flYawAngle == -2.0f )

	movss	xmm0, DWORD PTR _flYawAngle$8[ebp]
	ucomiss	xmm0, DWORD PTR __real@c0000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@ED_ParseEd

; 197  : 				pkvd[i].szValue = copystring( "90 0 0" );

	push	OFFSET $SG74564
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	DWORD PTR _pkvd$[ebp+ecx+8], eax
	jmp	SHORT $LN30@ED_ParseEd
$LN29@ED_ParseEd:

; 198  : 			else pkvd[i].szValue = copystring( "0 0 0" ); // technically an error

	push	OFFSET $SG74565
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+8], eax
$LN30@ED_ParseEd:

; 199  : 		}
; 200  : 
; 201  : 		if( !Q_strcmp( pkvd[i].szKeyName, "light" ))

	push	99999					; 0001869fH
	push	OFFSET $SG74567
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _pkvd$[ebp+eax+4]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@ED_ParseEd

; 202  : 		{
; 203  : 			freestring( pkvd[i].szKeyName );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 204  : 			pkvd[i].szKeyName = copystring( "light_level" );

	push	OFFSET $SG74568
	call	?copystring@@YAPADPBD@Z			; copystring
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	DWORD PTR _pkvd$[ebp+edx+4], eax
$LN31@ED_ParseEd:

; 205  : 		}
; 206  : 
; 207  : 		if( !pkvd[i].fHandled )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	cmp	DWORD PTR _pkvd$[ebp+eax+12], 0
	jne	SHORT $LN32@ED_ParseEd

; 208  : 		{
; 209  : 			pkvd[i].szClassName = (char *)classname;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _classname$[ebp]
	mov	DWORD PTR _pkvd$[ebp+ecx], edx

; 210  : 			DispatchKeyValue( pEntity->edict(), &pkvd[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _pkvd$[ebp+eax]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchKeyValue@@YAXPAUedict_s@@PAUKeyValueData_s@@@Z ; DispatchKeyValue
	add	esp, 8
$LN32@ED_ParseEd:

; 211  : 		}
; 212  : 
; 213  : 		// no reason to keep this data
; 214  : 		freestring( pkvd[i].szKeyName );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+4]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 215  : 		freestring( pkvd[i].szValue );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _pkvd$[ebp+edx+8]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 216  : 	}

	jmp	$LN7@ED_ParseEd
$LN8@ED_ParseEd:

; 217  : 
; 218  : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]
$LN1@ED_ParseEd:

; 219  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ED_ParseEdict@@YAPAVCBaseEntity@@PAPADPAUedict_s@@@Z ENDP ; ED_ParseEdict
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
_pEntity$1 = -8						; size = 4
_nEntity$2 = -4						; size = 4
_pSpawnList$ = 8					; size = 4
_nEntities$ = 12					; size = 4
?ED_ComputeSpawnHierarchyDepth@@YAXPAUCSpawnEntry@@H@Z PROC ; ED_ComputeSpawnHierarchyDepth

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 83   : 	// NOTE: This isn't particularly efficient, but so what? It's at the beginning of time
; 84   : 	// I did it this way because it simplified the parent setting in hierarchy (basically
; 85   : 	// eliminated questions about whether you should transform origin from global to local or not)
; 86   : 	for( int nEntity = 0; nEntity < nEntities; nEntity++ )

	mov	DWORD PTR _nEntity$2[ebp], 0
	jmp	SHORT $LN4@ED_Compute
$LN2@ED_Compute:
	mov	eax, DWORD PTR _nEntity$2[ebp]
	add	eax, 1
	mov	DWORD PTR _nEntity$2[ebp], eax
$LN4@ED_Compute:
	mov	ecx, DWORD PTR _nEntity$2[ebp]
	cmp	ecx, DWORD PTR _nEntities$[ebp]
	jge	SHORT $LN1@ED_Compute

; 87   : 	{
; 88   : 		CBaseEntity *pEntity = pSpawnList[nEntity].m_pEntity;

	mov	edx, DWORD PTR _nEntity$2[ebp]
	mov	eax, DWORD PTR _pSpawnList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _pEntity$1[ebp], ecx

; 89   : 
; 90   : 		if( pEntity && !pEntity->IsDormant( ))

	cmp	DWORD PTR _pEntity$1[ebp], 0
	je	SHORT $LN5@ED_Compute
	mov	ecx, DWORD PTR _pEntity$1[ebp]
	call	?IsDormant@CBaseEntity@@QAEHXZ		; CBaseEntity::IsDormant
	test	eax, eax
	jne	SHORT $LN5@ED_Compute

; 91   : 			pSpawnList[nEntity].m_nDepth = ED_ComputeSpawnHierarchyDepth_r( pEntity );

	mov	edx, DWORD PTR _pEntity$1[ebp]
	push	edx
	call	?ED_ComputeSpawnHierarchyDepth_r@@YAHPAVCBaseEntity@@@Z ; ED_ComputeSpawnHierarchyDepth_r
	add	esp, 4
	mov	ecx, DWORD PTR _nEntity$2[ebp]
	mov	edx, DWORD PTR _pSpawnList$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 92   : 		else

	jmp	SHORT $LN6@ED_Compute
$LN5@ED_Compute:

; 93   : 			pSpawnList[nEntity].m_nDepth = 1;

	mov	eax, DWORD PTR _nEntity$2[ebp]
	mov	ecx, DWORD PTR _pSpawnList$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], 1
$LN6@ED_Compute:

; 94   : 	}

	jmp	SHORT $LN2@ED_Compute
$LN1@ED_Compute:

; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ED_ComputeSpawnHierarchyDepth@@YAXPAUCSpawnEntry@@H@Z ENDP ; ED_ComputeSpawnHierarchyDepth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
_pParent$ = -4						; size = 4
_pEntity$ = 8						; size = 4
?ED_ComputeSpawnHierarchyDepth_r@@YAHPAVCBaseEntity@@@Z PROC ; ED_ComputeSpawnHierarchyDepth_r

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 61   : 	if( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $LN2@ED_Compute

; 62   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ED_Compute
$LN2@ED_Compute:

; 63   : 
; 64   : 	if( pEntity->m_iParent == NULL_STRING )

	mov	eax, DWORD PTR _pEntity$[ebp]
	cmp	DWORD PTR [eax+172], 0
	jne	SHORT $LN3@ED_Compute

; 65   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ED_Compute
$LN3@ED_Compute:

; 66   : 
; 67   : 	CBaseEntity *pParent = UTIL_FindEntityByTargetname( NULL, STRING( pEntity->m_iParent ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pParent$[ebp], eax

; 68   : 
; 69   : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $LN4@ED_Compute

; 70   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ED_Compute
$LN4@ED_Compute:

; 71   : 
; 72   : 	if( pParent == pEntity )

	mov	eax, DWORD PTR _pParent$[ebp]
	cmp	eax, DWORD PTR _pEntity$[ebp]
	jne	SHORT $LN5@ED_Compute

; 73   : 	{
; 74   : 		ALERT( at_warning, "LEVEL DESIGN ERROR: Entity %s is parented to itself!\n", pEntity->GetTargetname());

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET $SG74491
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 75   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ED_Compute
$LN5@ED_Compute:

; 76   : 	}
; 77   : 
; 78   : 	return 1 + ED_ComputeSpawnHierarchyDepth_r( pParent );

	mov	ecx, DWORD PTR _pParent$[ebp]
	push	ecx
	call	?ED_ComputeSpawnHierarchyDepth_r@@YAHPAVCBaseEntity@@@Z ; ED_ComputeSpawnHierarchyDepth_r
	add	esp, 4
	add	eax, 1
$LN1@ED_Compute:

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ED_ComputeSpawnHierarchyDepth_r@@YAHPAVCBaseEntity@@@Z ENDP ; ED_ComputeSpawnHierarchyDepth_r
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
_pEnt1$ = 8						; size = 4
_pEnt2$ = 12						; size = 4
?ED_CompareByHierarchyDepth@@YAHPAUCSpawnEntry@@0@Z PROC ; ED_CompareByHierarchyDepth

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	if( pEnt1->m_nDepth == pEnt2->m_nDepth )

	mov	eax, DWORD PTR _pEnt1$[ebp]
	mov	ecx, DWORD PTR _pEnt2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@ED_Compare

; 51   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ED_Compare
$LN2@ED_Compare:

; 52   : 
; 53   : 	if( pEnt1->m_nDepth > pEnt2->m_nDepth )

	mov	eax, DWORD PTR _pEnt1$[ebp]
	mov	ecx, DWORD PTR _pEnt2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN3@ED_Compare

; 54   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ED_Compare
$LN3@ED_Compare:

; 55   : 
; 56   : 	return -1;

	or	eax, -1
$LN1@ED_Compare:

; 57   : }

	pop	ebp
	ret	0
?ED_CompareByHierarchyDepth@@YAHPAUCSpawnEntry@@0@Z ENDP ; ED_CompareByHierarchyDepth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?entindex@CBaseEntity@@QAEHXZ PROC			; CBaseEntity::entindex, COMDAT
; _this$ = ecx

; 698  : 	int entindex( ) { return ENTINDEX( edict() ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?entindex@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::entindex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC		; CBaseEntity::edict, COMDAT
; _this$ = ecx

; 696  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?GetDebugName@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDebugName@CBaseEntity@@QAEPBDXZ PROC		; CBaseEntity::GetDebugName, COMDAT
; _this$ = ecx

; 285  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 286  : 		if( this == NULL || pev == NULL )

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $LN3@GetDebugNa
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@GetDebugNa
$LN3@GetDebugNa:

; 287  : 			return "null";

	mov	eax, OFFSET ??_C@_04MLLLIHIP@null@
	jmp	SHORT $LN1@GetDebugNa
$LN2@GetDebugNa:

; 288  : 
; 289  : 		if( pev->targetname != NULL_STRING ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+460], 0
	je	SHORT $LN4@GetDebugNa

; 290  : 			return GetTargetname();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	jmp	SHORT $LN1@GetDebugNa
$LN4@GetDebugNa:

; 291  : 		return GetClassname();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
$LN1@GetDebugNa:

; 292  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDebugName@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetDebugName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTargetname@CBaseEntity@@QAEPBDXZ PROC		; CBaseEntity::GetTargetname, COMDAT
; _this$ = ecx

; 277  : 	const char*	GetTargetname() { return STRING( pev->targetname ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetTargetname
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC		; CBaseEntity::GetClassname, COMDAT
; _this$ = ecx

; 275  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
_pEntity$1 = -34860					; size = 4
_create_world$ = -34856					; size = 4
_ent$2 = -34852						; size = 4
_inhibited$ = -34848					; size = 4
_pParent$3 = -34844					; size = 4
_pEntity$4 = -34840					; size = 4
_pEntity$5 = -34836					; size = 4
_pEntity$6 = -34832					; size = 4
_nEntities$ = -34828					; size = 4
_nEntity$ = -34824					; size = 4
_pSpawnList$ = -34820					; size = 32768
_token$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_mapname$ = 8						; size = 4
_entities$ = 12						; size = 4
?DispatchSpawnEntities@@YAHPBDPAD@Z PROC		; DispatchSpawnEntities

; 236  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 34860				; 0000882cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 237  : 	if( !entities ) return 0; // probably this never happens

	cmp	DWORD PTR _entities$[ebp], 0
	jne	SHORT $LN13@DispatchSp
	xor	eax, eax
	jmp	$LN1@DispatchSp
$LN13@DispatchSp:

; 238  : 
; 239  : 	char token[2048];
; 240  : 	int inhibited = 0;

	mov	DWORD PTR _inhibited$[ebp], 0

; 241  : 	CSpawnEntry pSpawnList[4096];	// max XashXT edicts
; 242  : 	int nEntity, nEntities = 0;

	mov	DWORD PTR _nEntities$[ebp], 0

; 243  : 	BOOL create_world = TRUE;

	mov	DWORD PTR _create_world$[ebp], 1
$LN2@DispatchSp:

; 244  : 
; 245  : 	// parse ents
; 246  : 	while(( entities = COM_ParseFile( entities, token )) != NULL )

	push	1
	push	2048					; 00000800H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _entities$[ebp], eax
	cmp	DWORD PTR _entities$[ebp], 0
	je	$LN3@DispatchSp

; 247  : 	{
; 248  : 		if( token[0] != '{' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _token$[ebp+eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN14@DispatchSp

; 249  : 			HOST_ERROR( "ED_LoadFromFile: found %s when expecting {\n", token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	push	OFFSET $SG74607
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 8
$LN14@DispatchSp:

; 250  : 
; 251  : 		edict_t *ent = NULL;

	mov	DWORD PTR _ent$2[ebp], 0

; 252  : 
; 253  : 		if( create_world )

	cmp	DWORD PTR _create_world$[ebp], 0
	je	SHORT $LN15@DispatchSp

; 254  : 			ent = INDEXENT( 0 ); // already initialized by engine

	push	0
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _ent$2[ebp], eax
$LN15@DispatchSp:

; 255  : 
; 256  : 		CBaseEntity *pEntity = ED_ParseEdict( &entities, ent );

	mov	eax, DWORD PTR _ent$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _entities$[ebp]
	push	ecx
	call	?ED_ParseEdict@@YAPAVCBaseEntity@@PAPADPAUedict_s@@@Z ; ED_ParseEdict
	add	esp, 8
	mov	DWORD PTR _pEntity$6[ebp], eax

; 257  : 		if( !pEntity ) continue;

	cmp	DWORD PTR _pEntity$6[ebp], 0
	jne	SHORT $LN16@DispatchSp
	jmp	$LN2@DispatchSp
$LN16@DispatchSp:

; 258  : 
; 259  : 		if( pEntity->ObjectCaps() & FCAP_IGNORE_PARENT )

	mov	edx, DWORD PTR _pEntity$6[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$6[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	and	eax, 4096				; 00001000H
	je	SHORT $LN17@DispatchSp

; 260  : 			pEntity->m_iParent = NULL_STRING; // clear parent for this entity

	mov	eax, DWORD PTR _pEntity$6[ebp]
	mov	DWORD PTR [eax+172], 0
$LN17@DispatchSp:

; 261  : 
; 262  : 		if( create_world )

	cmp	DWORD PTR _create_world$[ebp], 0
	je	SHORT $LN18@DispatchSp

; 263  : 		{
; 264  : 			if( DispatchSpawn( ent ) < 0 )

	mov	ecx, DWORD PTR _ent$2[ebp]
	push	ecx
	call	?DispatchSpawn@@YAHPAUedict_s@@@Z	; DispatchSpawn
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN20@DispatchSp

; 265  : 				HOST_ERROR( "can't spawn the world\n" );

	push	OFFSET $SG74614
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+24
	add	esp, 4
$LN20@DispatchSp:

; 266  : 			create_world = false;

	mov	DWORD PTR _create_world$[ebp], 0
	jmp	SHORT $LN19@DispatchSp
$LN18@DispatchSp:

; 267  : 		}
; 268  : 		else if( pEntity->m_iParent == NULL_STRING && pEntity->pev->targetname == NULL_STRING )

	mov	edx, DWORD PTR _pEntity$6[ebp]
	cmp	DWORD PTR [edx+172], 0
	jne	SHORT $LN21@DispatchSp
	mov	eax, DWORD PTR _pEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+460], 0
	jne	SHORT $LN21@DispatchSp

; 269  : 		{
; 270  : 			// it's doesn't have parent and can't be parent himself
; 271  : 			// so we can spawn this immediately
; 272  : 			if( !ED_SpawnEdict( pEntity->edict( )))

	mov	ecx, DWORD PTR _pEntity$6[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ED_SpawnEdict@@YAHPAUedict_s@@@Z	; ED_SpawnEdict
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@DispatchSp

; 273  : 				inhibited++;

	mov	edx, DWORD PTR _inhibited$[ebp]
	add	edx, 1
	mov	DWORD PTR _inhibited$[ebp], edx
$LN23@DispatchSp:

; 274  : 		}
; 275  : 		else

	jmp	SHORT $LN19@DispatchSp
$LN21@DispatchSp:

; 276  : 		{
; 277  : 			// queue up this entity for spawning
; 278  : 			pSpawnList[nEntities].m_pEntity = pEntity;

	mov	eax, DWORD PTR _nEntities$[ebp]
	mov	ecx, DWORD PTR _pEntity$6[ebp]
	mov	DWORD PTR _pSpawnList$[ebp+eax*8], ecx

; 279  : 			pSpawnList[nEntities].m_nDepth = 0;

	mov	edx, DWORD PTR _nEntities$[ebp]
	mov	DWORD PTR _pSpawnList$[ebp+edx*8+4], 0

; 280  : 			nEntities++;

	mov	eax, DWORD PTR _nEntities$[ebp]
	add	eax, 1
	mov	DWORD PTR _nEntities$[ebp], eax
$LN19@DispatchSp:

; 281  : 		}
; 282  : 	}

	jmp	$LN2@DispatchSp
$LN3@DispatchSp:

; 283  : 
; 284  : 	ED_ComputeSpawnHierarchyDepth( pSpawnList, nEntities );

	mov	ecx, DWORD PTR _nEntities$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pSpawnList$[ebp]
	push	edx
	call	?ED_ComputeSpawnHierarchyDepth@@YAXPAUCSpawnEntry@@H@Z ; ED_ComputeSpawnHierarchyDepth
	add	esp, 8

; 285  : 
; 286  : 	// Sort the entities (other than the world) by hierarchy depth, in order to spawn them in
; 287  : 	// that order. This insures that each entity's parent spawns before it does so that
; 288  : 	// it can properly set up anything that relies on hierarchy.
; 289  : 	qsort( &pSpawnList[0], nEntities, sizeof( pSpawnList[0] ), (int (__cdecl *)(const void *, const void *))ED_CompareByHierarchyDepth );

	push	OFFSET ?ED_CompareByHierarchyDepth@@YAHPAUCSpawnEntry@@0@Z ; ED_CompareByHierarchyDepth
	push	8
	mov	eax, DWORD PTR _nEntities$[ebp]
	push	eax
	mov	ecx, 8
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _pSpawnList$[ebp+edx]
	push	eax
	call	_qsort
	add	esp, 16					; 00000010H

; 290  : 
; 291  : 	// Set up entity movement hierarchy in reverse hierarchy depth order. This allows each entity
; 292  : 	// to use its parent's world spawn origin to calculate its local origin.
; 293  : 	for( nEntity = nEntities - 1; nEntity >= 0; nEntity--)

	mov	ecx, DWORD PTR _nEntities$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nEntity$[ebp], ecx
	jmp	SHORT $LN6@DispatchSp
$LN4@DispatchSp:
	mov	edx, DWORD PTR _nEntity$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nEntity$[ebp], edx
$LN6@DispatchSp:
	cmp	DWORD PTR _nEntity$[ebp], 0
	jl	$LN5@DispatchSp

; 294  : 	{
; 295  : 		CBaseEntity *pEntity = pSpawnList[nEntity].m_pEntity;

	mov	eax, DWORD PTR _nEntity$[ebp]
	mov	ecx, DWORD PTR _pSpawnList$[ebp+eax*8]
	mov	DWORD PTR _pEntity$5[ebp], ecx

; 296  : 
; 297  : 		if( pEntity && !pEntity->HasAttachment( ))

	cmp	DWORD PTR _pEntity$5[ebp], 0
	je	$LN24@DispatchSp
	mov	ecx, DWORD PTR _pEntity$5[ebp]
	call	?HasAttachment@CBaseEntity@@QAEHXZ	; CBaseEntity::HasAttachment
	test	eax, eax
	jne	$LN24@DispatchSp

; 298  : 		{
; 299  : 			CBaseEntity *pParent = UTIL_FindEntityByTargetname( NULL, STRING( pEntity->m_iParent ));

	mov	edx, DWORD PTR _pEntity$5[ebp]
	mov	eax, DWORD PTR [edx+172]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pParent$3[ebp], eax

; 300  : 
; 301  : 			if( pParent && pParent->edict( ))

	cmp	DWORD PTR _pParent$3[ebp], 0
	je	SHORT $LN24@DispatchSp
	mov	ecx, DWORD PTR _pParent$3[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	test	eax, eax
	je	SHORT $LN24@DispatchSp

; 302  : 			{
; 303  : 				ALERT( at_aiconsole, "%s linked with %s\n", pEntity->GetClassname(), pParent->GetClassname());

	mov	ecx, DWORD PTR _pParent$3[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _pEntity$5[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET $SG74620
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 304  : 				pEntity->SetParent( pParent ); 

	push	0
	mov	ecx, DWORD PTR _pParent$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$5[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent

; 305  : 				CheckForMultipleParents( pEntity, pParent );

	mov	edx, DWORD PTR _pParent$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$5[ebp]
	push	eax
	call	?CheckForMultipleParents@@YAXPAVCBaseEntity@@0@Z ; CheckForMultipleParents
	add	esp, 8
$LN24@DispatchSp:

; 306  : 			}
; 307  : 		}
; 308  : 	}

	jmp	$LN4@DispatchSp
$LN5@DispatchSp:

; 309  : 
; 310  : 	// Spawn all the entities in hierarchy depth order so that parents spawn before their children.
; 311  : 	for( nEntity = 0; nEntity < nEntities; nEntity++ )

	mov	DWORD PTR _nEntity$[ebp], 0
	jmp	SHORT $LN9@DispatchSp
$LN7@DispatchSp:
	mov	ecx, DWORD PTR _nEntity$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nEntity$[ebp], ecx
$LN9@DispatchSp:
	mov	edx, DWORD PTR _nEntity$[ebp]
	cmp	edx, DWORD PTR _nEntities$[ebp]
	jge	SHORT $LN8@DispatchSp

; 312  : 	{
; 313  : 		CBaseEntity *pEntity = pSpawnList[nEntity].m_pEntity;

	mov	eax, DWORD PTR _nEntity$[ebp]
	mov	ecx, DWORD PTR _pSpawnList$[ebp+eax*8]
	mov	DWORD PTR _pEntity$1[ebp], ecx

; 314  : 
; 315  : 		if( pEntity )

	cmp	DWORD PTR _pEntity$1[ebp], 0
	je	SHORT $LN26@DispatchSp

; 316  : 		{
; 317  : 			if( !ED_SpawnEdict( pEntity->edict( )))

	mov	ecx, DWORD PTR _pEntity$1[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ED_SpawnEdict@@YAHPAUedict_s@@@Z	; ED_SpawnEdict
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@DispatchSp

; 318  : 				inhibited++;

	mov	edx, DWORD PTR _inhibited$[ebp]
	add	edx, 1
	mov	DWORD PTR _inhibited$[ebp], edx
$LN26@DispatchSp:

; 319  : 		}
; 320  : 	}

	jmp	SHORT $LN7@DispatchSp
$LN8@DispatchSp:

; 321  : 
; 322  : 	// Set up last remaining entities that linked with model attachments
; 323  : 	for( nEntity = nEntities - 1; nEntity >= 0; nEntity--)

	mov	eax, DWORD PTR _nEntities$[ebp]
	sub	eax, 1
	mov	DWORD PTR _nEntity$[ebp], eax
	jmp	SHORT $LN12@DispatchSp
$LN10@DispatchSp:
	mov	ecx, DWORD PTR _nEntity$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nEntity$[ebp], ecx
$LN12@DispatchSp:
	cmp	DWORD PTR _nEntity$[ebp], 0
	jl	SHORT $LN11@DispatchSp

; 324  : 	{
; 325  : 		CBaseEntity *pEntity = pSpawnList[nEntity].m_pEntity;

	mov	edx, DWORD PTR _nEntity$[ebp]
	mov	eax, DWORD PTR _pSpawnList$[ebp+edx*8]
	mov	DWORD PTR _pEntity$4[ebp], eax

; 326  : 
; 327  : 		// make sure this entity is really want attachement
; 328  : 		if( pEntity && pEntity->HasAttachment( ))

	cmp	DWORD PTR _pEntity$4[ebp], 0
	je	SHORT $LN28@DispatchSp
	mov	ecx, DWORD PTR _pEntity$4[ebp]
	call	?HasAttachment@CBaseEntity@@QAEHXZ	; CBaseEntity::HasAttachment
	test	eax, eax
	je	SHORT $LN28@DispatchSp

; 329  : 		{
; 330  : 			ALERT( at_aiconsole, "%s attached with %s\n", pEntity->GetClassname(), STRING( pEntity->m_iParent ));

	mov	ecx, DWORD PTR _pEntity$4[ebp]
	mov	edx, DWORD PTR [ecx+172]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pEntity$4[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET $SG74624
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 331  : 			pEntity->SetParent( pEntity->m_iParent, 0 ); 

	push	0
	mov	eax, DWORD PTR _pEntity$4[ebp]
	mov	ecx, DWORD PTR [eax+172]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$4[ebp]
	call	?SetParent@CBaseEntity@@QAEXHH@Z	; CBaseEntity::SetParent
$LN28@DispatchSp:

; 332  : 		}
; 333  : 	}

	jmp	$LN10@DispatchSp
$LN11@DispatchSp:

; 334  : 
; 335  : 
; 336  : 	ALERT( at_console, "\n%i entities inhibited\n", inhibited );

	mov	edx, DWORD PTR _inhibited$[ebp]
	push	edx
	push	OFFSET $SG74625
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 337  : 
; 338  : 	return 1;	// we done

	mov	eax, 1
$LN1@DispatchSp:

; 339  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DispatchSpawnEntities@@YAHPBDPAD@Z ENDP		; DispatchSpawnEntities
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
_pSrcParent$ = -8					; size = 4
_fShownMessage$ = -4					; size = 4
_pEntity$ = 8						; size = 4
_pParent$ = 12						; size = 4
?CheckForMultipleParents@@YAXPAVCBaseEntity@@0@Z PROC	; CheckForMultipleParents

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 27   : 	BOOL fShownMessage = FALSE;

	mov	DWORD PTR _fShownMessage$[ebp], 0

; 28   : 	CBaseEntity *pSrcParent = pParent;

	mov	eax, DWORD PTR _pParent$[ebp]
	mov	DWORD PTR _pSrcParent$[ebp], eax
$LN2@CheckForMu:

; 29   : 
; 30   : 	while(( pParent = UTIL_FindEntityByTargetname( pParent, STRING( pEntity->m_iParent ))) != NULL )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pParent$[ebp]
	push	eax
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pParent$[ebp], eax
	cmp	DWORD PTR _pParent$[ebp], 0
	je	$LN3@CheckForMu

; 31   : 	{
; 32   : 		if( fShownMessage )

	cmp	DWORD PTR _fShownMessage$[ebp], 0
	je	SHORT $LN4@CheckForMu

; 33   : 			ALERT( at_console, "," );

	push	OFFSET $SG74470
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN4@CheckForMu:

; 34   : 
; 35   : 		if( !fShownMessage )

	cmp	DWORD PTR _fShownMessage$[ebp], 0
	jne	SHORT $LN5@CheckForMu

; 36   : 		{
; 37   : 			ALERT( at_warning, "Entity %s[%d] has multiple parent [%s]:", pEntity->GetClassname( ), pEntity->entindex(), pSrcParent->GetDebugName()); 

	mov	ecx, DWORD PTR _pSrcParent$[ebp]
	call	?GetDebugName@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetDebugName
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET $SG74472
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 38   : 			ALERT( at_console, " %s[%d],", pSrcParent->GetClassname(), pSrcParent->entindex());

	mov	ecx, DWORD PTR _pSrcParent$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _pSrcParent$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET $SG74473
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 39   : 			fShownMessage = TRUE;

	mov	DWORD PTR _fShownMessage$[ebp], 1
$LN5@CheckForMu:

; 40   : 		}
; 41   : 		ALERT( at_console, " %s[%d]", pParent->GetClassname(), pParent->entindex());

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET $SG74474
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 42   : 	}

	jmp	$LN2@CheckForMu
$LN3@CheckForMu:

; 43   : 
; 44   : 	if( fShownMessage )

	cmp	DWORD PTR _fShownMessage$[ebp], 0
	je	SHORT $LN1@CheckForMu

; 45   : 		ALERT( at_console, "\n" );

	push	OFFSET $SG74476
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN1@CheckForMu:

; 46   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForMultipleParents@@YAXPAVCBaseEntity@@0@Z ENDP	; CheckForMultipleParents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_iEdictNum$ = 8						; size = 4
?INDEXENT@@YAPAUedict_s@@H@Z PROC			; INDEXENT, COMDAT

; 187  : inline edict_t* INDEXENT( int iEdictNum )		{ return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _iEdictNum$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+288
	add	esp, 4
	pop	ebp
	ret	0
?INDEXENT@@YAPAUedict_s@@H@Z ENDP			; INDEXENT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8						; size = 4
?ENTINDEX@@YAHPAUedict_s@@@Z PROC			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8						; size = 4
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $LN2@VARS

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@VARS
$LN2@VARS:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$LN1@VARS:

; 183  : }

	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8						; size = 4
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\mapents.cpp
_TEXT	SEGMENT
tv66 = -4						; size = 4
_className$ = 8						; size = 4
_pev$ = 12						; size = 4
?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC ; CreateEntityByName

; 21   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 22   : 	return EntityFactoryDictionary()->Create( className, pev );

	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv66[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv66[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 23   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CreateEntityByName
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
