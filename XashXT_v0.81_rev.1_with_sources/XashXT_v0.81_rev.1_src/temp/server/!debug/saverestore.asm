; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\server\saverestore.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gEntvarsDescription@@3PAUtypedescription_s@@A	; gEntvarsDescription
CONST	SEGMENT
$SG74414 DB	'classname', 00H
	ORG $+2
$SG74415 DB	'classname', 00H
	ORG $+2
$SG74416 DB	'globalname', 00H
	ORG $+1
$SG74417 DB	'globalname', 00H
	ORG $+1
$SG74418 DB	'origin', 00H
	ORG $+1
$SG74419 DB	'origin', 00H
	ORG $+1
$SG74420 DB	'oldorigin', 00H
	ORG $+2
$SG74421 DB	'oldorigin', 00H
	ORG $+2
$SG74422 DB	'velocity', 00H
	ORG $+3
$SG74423 DB	'velocity', 00H
	ORG $+3
$SG74424 DB	'basevelocity', 00H
	ORG $+3
$SG74425 DB	'basevelocity', 00H
	ORG $+3
$SG74426 DB	'movedir', 00H
$SG74427 DB	'movedir', 00H
$SG74428 DB	'angles', 00H
	ORG $+1
$SG74429 DB	'angles', 00H
	ORG $+1
$SG74430 DB	'avelocity', 00H
	ORG $+2
$SG74431 DB	'avelocity', 00H
	ORG $+2
$SG74432 DB	'punchangle', 00H
	ORG $+1
$SG74433 DB	'punchangle', 00H
	ORG $+1
$SG74434 DB	'v_angle', 00H
$SG74435 DB	'v_angle', 00H
$SG74436 DB	'fixangle', 00H
	ORG $+3
$SG74437 DB	'fixangle', 00H
	ORG $+3
$SG74438 DB	'idealpitch', 00H
	ORG $+1
$SG74439 DB	'idealpitch', 00H
	ORG $+1
$SG74440 DB	'pitch_speed', 00H
$SG74441 DB	'pitch_speed', 00H
$SG74442 DB	'ideal_yaw', 00H
	ORG $+2
$SG74443 DB	'ideal_yaw', 00H
	ORG $+2
$SG74444 DB	'yaw_speed', 00H
	ORG $+2
$SG74445 DB	'yaw_speed', 00H
	ORG $+2
$SG74446 DB	'modelindex', 00H
	ORG $+1
$SG74447 DB	'modelindex', 00H
	ORG $+1
$SG74448 DB	'model', 00H
	ORG $+2
$SG74449 DB	'model', 00H
	ORG $+2
$SG74450 DB	'viewmodel', 00H
	ORG $+2
$SG74451 DB	'viewmodel', 00H
	ORG $+2
$SG74452 DB	'weaponmodel', 00H
$SG74453 DB	'weaponmodel', 00H
$SG74454 DB	'absmin', 00H
	ORG $+1
$SG74455 DB	'absmin', 00H
	ORG $+1
$SG74456 DB	'absmax', 00H
	ORG $+1
$SG74457 DB	'absmax', 00H
	ORG $+1
$SG74458 DB	'mins', 00H
	ORG $+3
$SG74459 DB	'mins', 00H
	ORG $+3
$SG74460 DB	'maxs', 00H
	ORG $+3
$SG74461 DB	'maxs', 00H
	ORG $+3
$SG74462 DB	'size', 00H
	ORG $+3
$SG74463 DB	'size', 00H
	ORG $+3
$SG74464 DB	'ltime', 00H
	ORG $+2
$SG74465 DB	'ltime', 00H
	ORG $+2
$SG74466 DB	'nextthink', 00H
	ORG $+2
$SG74467 DB	'nextthink', 00H
	ORG $+2
$SG74468 DB	'solid', 00H
	ORG $+2
$SG74469 DB	'solid', 00H
	ORG $+2
$SG74470 DB	'movetype', 00H
	ORG $+3
$SG74471 DB	'movetype', 00H
	ORG $+3
$SG74472 DB	'skin', 00H
	ORG $+3
$SG74473 DB	'skin', 00H
	ORG $+3
$SG74474 DB	'body', 00H
	ORG $+3
$SG74475 DB	'body', 00H
	ORG $+3
$SG74476 DB	'effects', 00H
$SG74477 DB	'effects', 00H
$SG74478 DB	'gravity', 00H
$SG74479 DB	'gravity', 00H
$SG74480 DB	'friction', 00H
	ORG $+3
$SG74481 DB	'friction', 00H
	ORG $+3
$SG74482 DB	'light_level', 00H
$SG74483 DB	'light_level', 00H
$SG74484 DB	'frame', 00H
	ORG $+2
$SG74485 DB	'frame', 00H
	ORG $+2
$SG74486 DB	'scale', 00H
	ORG $+2
$SG74487 DB	'scale', 00H
	ORG $+2
$SG74488 DB	'sequence', 00H
	ORG $+3
$SG74489 DB	'sequence', 00H
	ORG $+3
$SG74490 DB	'animtime', 00H
	ORG $+3
$SG74491 DB	'animtime', 00H
	ORG $+3
$SG74492 DB	'framerate', 00H
	ORG $+2
$SG74493 DB	'framerate', 00H
	ORG $+2
$SG74494 DB	'controller', 00H
	ORG $+1
$SG74495 DB	'controller', 00H
	ORG $+1
$SG74496 DB	'blending', 00H
	ORG $+3
$SG74497 DB	'blending', 00H
	ORG $+3
$SG74498 DB	'rendermode', 00H
	ORG $+1
$SG74499 DB	'rendermode', 00H
	ORG $+1
$SG74500 DB	'renderamt', 00H
	ORG $+2
$SG74501 DB	'renderamt', 00H
	ORG $+2
$SG74502 DB	'rendercolor', 00H
$SG74503 DB	'rendercolor', 00H
$SG74504 DB	'renderfx', 00H
	ORG $+3
$SG74505 DB	'renderfx', 00H
	ORG $+3
$SG74506 DB	'health', 00H
	ORG $+1
$SG74507 DB	'health', 00H
	ORG $+1
$SG74508 DB	'frags', 00H
	ORG $+2
$SG74509 DB	'frags', 00H
	ORG $+2
$SG74510 DB	'takedamage', 00H
	ORG $+1
$SG74511 DB	'takedamage', 00H
	ORG $+1
$SG74512 DB	'deadflag', 00H
	ORG $+3
$SG74513 DB	'deadflag', 00H
	ORG $+3
$SG74514 DB	'view_ofs', 00H
	ORG $+3
$SG74515 DB	'view_ofs', 00H
	ORG $+3
$SG74516 DB	'button', 00H
	ORG $+1
$SG74517 DB	'button', 00H
	ORG $+1
$SG74518 DB	'impulse', 00H
$SG74519 DB	'impulse', 00H
$SG74520 DB	'chain', 00H
	ORG $+2
$SG74521 DB	'chain', 00H
	ORG $+2
$SG74522 DB	'dmg_inflictor', 00H
	ORG $+2
$SG74523 DB	'dmg_inflictor', 00H
	ORG $+2
$SG74524 DB	'enemy', 00H
	ORG $+2
$SG74525 DB	'enemy', 00H
	ORG $+2
$SG74526 DB	'aiment', 00H
	ORG $+1
$SG74527 DB	'aiment', 00H
	ORG $+1
$SG74528 DB	'owner', 00H
	ORG $+2
$SG74529 DB	'owner', 00H
	ORG $+2
$SG74530 DB	'groundentity', 00H
	ORG $+3
$SG74531 DB	'groundentity', 00H
	ORG $+3
$SG74532 DB	'spawnflags', 00H
	ORG $+1
$SG74533 DB	'spawnflags', 00H
	ORG $+1
$SG74534 DB	'flags', 00H
	ORG $+2
$SG74535 DB	'flags', 00H
	ORG $+2
$SG74536 DB	'colormap', 00H
	ORG $+3
$SG74537 DB	'colormap', 00H
	ORG $+3
$SG74538 DB	'team', 00H
	ORG $+3
$SG74539 DB	'team', 00H
	ORG $+3
$SG74540 DB	'max_health', 00H
	ORG $+1
$SG74541 DB	'max_health', 00H
	ORG $+1
$SG74542 DB	'teleport_time', 00H
	ORG $+2
$SG74543 DB	'teleport_time', 00H
	ORG $+2
$SG74544 DB	'armortype', 00H
	ORG $+2
$SG74545 DB	'armortype', 00H
	ORG $+2
$SG74546 DB	'armorvalue', 00H
	ORG $+1
$SG74547 DB	'armorvalue', 00H
	ORG $+1
$SG74548 DB	'waterlevel', 00H
	ORG $+1
$SG74549 DB	'waterlevel', 00H
	ORG $+1
$SG74550 DB	'watertype', 00H
	ORG $+2
$SG74551 DB	'watertype', 00H
	ORG $+2
$SG74552 DB	'target', 00H
	ORG $+1
$SG74553 DB	'target', 00H
	ORG $+1
$SG74554 DB	'targetname', 00H
	ORG $+1
$SG74555 DB	'targetname', 00H
	ORG $+1
$SG74556 DB	'netname', 00H
$SG74557 DB	'netname', 00H
$SG74558 DB	'message', 00H
$SG74559 DB	'message', 00H
$SG74560 DB	'dmg_take', 00H
	ORG $+3
$SG74561 DB	'dmg_take', 00H
	ORG $+3
$SG74562 DB	'dmg_save', 00H
	ORG $+3
$SG74563 DB	'dmg_save', 00H
	ORG $+3
$SG74564 DB	'dmg', 00H
$SG74565 DB	'dmg', 00H
$SG74566 DB	'dmgtime', 00H
$SG74567 DB	'dmgtime', 00H
$SG74568 DB	'noise', 00H
	ORG $+2
$SG74569 DB	'noise', 00H
	ORG $+2
$SG74570 DB	'noise1', 00H
	ORG $+1
$SG74571 DB	'noise1', 00H
	ORG $+1
$SG74572 DB	'noise2', 00H
	ORG $+1
$SG74573 DB	'noise2', 00H
	ORG $+1
$SG74574 DB	'noise3', 00H
	ORG $+1
$SG74575 DB	'noise3', 00H
	ORG $+1
$SG74576 DB	'speed', 00H
	ORG $+2
$SG74577 DB	'speed', 00H
	ORG $+2
$SG74578 DB	'air_finished', 00H
	ORG $+3
$SG74579 DB	'air_finished', 00H
	ORG $+3
$SG74580 DB	'pain_finished', 00H
	ORG $+2
$SG74581 DB	'pain_finished', 00H
	ORG $+2
$SG74582 DB	'radsuit_finished', 00H
	ORG $+3
$SG74583 DB	'radsuit_finished', 00H
	ORG $+3
$SG74584 DB	'vuser1', 00H
	ORG $+1
$SG74585 DB	'vuser1', 00H
	ORG $+1
$SG74586 DB	'vuser2', 00H
	ORG $+1
$SG74587 DB	'vuser2', 00H
	ORG $+1
$SG74588 DB	'iuser1', 00H
	ORG $+1
$SG74589 DB	'iuser1', 00H
	ORG $+1
$SG74590 DB	'iuser2', 00H
	ORG $+1
$SG74591 DB	'iuser2', 00H
	ORG $+1
$SG74592 DB	'iuser3', 00H
	ORG $+1
$SG74593 DB	'iuser3', 00H
	ORG $+1
$SG74594 DB	'fuser1', 00H
	ORG $+1
$SG74595 DB	'fuser1', 00H
	ORG $+1
$SG74596 DB	'fuser2', 00H
	ORG $+1
$SG74597 DB	'fuser2', 00H
	ORG $+1
$SG74598 DB	'fuser3', 00H
	ORG $+1
$SG74599 DB	'fuser3', 00H
	ORG $+1
$SG74600 DB	'fuser4', 00H
	ORG $+1
$SG74601 DB	'fuser4', 00H
	ORG $+1
$SG74708 DB	'No token table array in TokenHash()!', 00H
	ORG $+3
$SG74710 DB	'CSaveRestoreBuffer :: TokenHash() is getting too full!', 00H
	ORG $+1
$SG74714 DB	'CSaveRestoreBuffer :: TokenHash() is COMPLETELY FULL!', 00H
	ORG $+2
$SG74761 DB	'%s->%s ', 00H
$SG74763 DB	'%d', 00H
	ORG $+1
$SG74765 DB	'%f', 00H
	ORG $+1
$SG74767 DB	'%d', 00H
	ORG $+1
$SG74769 DB	'%d', 00H
	ORG $+1
$SG74771 DB	'%s', 00H
	ORG $+1
$SG74773 DB	'(%f %f %f)', 00H
	ORG $+1
$SG74776 DB	'%d', 00H
	ORG $+1
$SG74778 DB	'%s', 00H
	ORG $+1
$SG74782 DB	' ', 00H
	ORG $+2
$SG74783 DB	0aH, 00H
	ORG $+2
$SG74902 DB	'Invalid function pointer in class %s!', 0aH, 00H
	ORG $+1
$SG74930 DB	'Bad field in entity!!', 0aH, 00H
	ORG $+1
$SG74933 DB	'origin', 00H
	ORG $+1
$SG74936 DB	'angles', 00H
	ORG $+1
$SG75014 DB	'Can''t save more than %d entities in an array!!!', 0aH, 00H
	ORG $+3
$SG75028 DB	'Bad field type', 0aH, 00H
$SG75063 DB	'CSave :: BufferHeader() size parameter exceeds ''short'''
	DB	'!', 00H
$SG75071 DB	'Save/Restore overflow!', 00H
	ORG $+1
$SG75197 DB	'Bad field type', 0aH, 00H
$SG75227 DB	'i == sizeof(int)', 00H
	ORG $+3
$SG75226 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\saverestore.cpp', 00H
	ORG $+2
$SG75244 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\saverestore.cpp', 00H
	ORG $+2
$SG75245 DB	'pheader!=NULL', 00H
	ORG $+2
$SG75282 DB	'c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\'
	DB	'xashxt_v0.81_rev.1_src\server\saverestore.cpp', 00H
	ORG $+2
$SG75283 DB	'm_pdata !=NULL', 00H
	ORG $+1
$SG75287 DB	'Restore overflow!', 00H
	ORG $+2
$SG75517 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG75520 DB	'0', 00H, 00H, 00H
$SG75350 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75351 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG75394 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75526 DB	'0', 00H, 00H, 00H
$SG75395 DB	'(', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '+', 00H, ' ', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '(', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG75530 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG75396 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75532 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG75397 DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')'
	DB	00H, 00H, 00H
$SG75469 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+4
$SG75470 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
	ORG $+4
$SG75516 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75519 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75525 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75529 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75531 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
_DATA	SEGMENT
?gEntvarsDescription@@3PAUtypedescription_s@@A DD 01H	; gEntvarsDescription
	DD	FLAT:$SG74414
	DD	00H
	DW	01H
	DW	06H
	DD	FLAT:$SG74415
	DD	00H
	DD	01H
	DD	FLAT:$SG74416
	DD	04H
	DW	01H
	DW	07H
	DD	FLAT:$SG74417
	DD	00H
	DD	08H
	DD	FLAT:$SG74418
	DD	08H
	DW	01H
	DW	06H
	DD	FLAT:$SG74419
	DD	00H
	DD	08H
	DD	FLAT:$SG74420
	DD	014H
	DW	01H
	DW	06H
	DD	FLAT:$SG74421
	DD	00H
	DD	07H
	DD	FLAT:$SG74422
	DD	020H
	DW	01H
	DW	06H
	DD	FLAT:$SG74423
	DD	00H
	DD	07H
	DD	FLAT:$SG74424
	DD	02cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74425
	DD	00H
	DD	07H
	DD	FLAT:$SG74426
	DD	044H
	DW	01H
	DW	06H
	DD	FLAT:$SG74427
	DD	00H
	DD	07H
	DD	FLAT:$SG74428
	DD	050H
	DW	01H
	DW	06H
	DD	FLAT:$SG74429
	DD	00H
	DD	07H
	DD	FLAT:$SG74430
	DD	05cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74431
	DD	00H
	DD	07H
	DD	FLAT:$SG74432
	DD	068H
	DW	01H
	DW	06H
	DD	FLAT:$SG74433
	DD	00H
	DD	07H
	DD	FLAT:$SG74434
	DD	074H
	DW	01H
	DW	06H
	DD	FLAT:$SG74435
	DD	00H
	DD	00H
	DD	FLAT:$SG74436
	DD	0a0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74437
	DD	00H
	DD	00H
	DD	FLAT:$SG74438
	DD	0a4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74439
	DD	00H
	DD	00H
	DD	FLAT:$SG74440
	DD	0a8H
	DW	01H
	DW	06H
	DD	FLAT:$SG74441
	DD	00H
	DD	00H
	DD	FLAT:$SG74442
	DD	0acH
	DW	01H
	DW	06H
	DD	FLAT:$SG74443
	DD	00H
	DD	00H
	DD	FLAT:$SG74444
	DD	0b0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74445
	DD	00H
	DD	0aH
	DD	FLAT:$SG74446
	DD	0b4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74447
	DD	00H
	DD	010H
	DD	FLAT:$SG74448
	DD	0b8H
	DW	01H
	DW	07H
	DD	FLAT:$SG74449
	DD	00H
	DD	010H
	DD	FLAT:$SG74450
	DD	0bcH
	DW	01H
	DW	06H
	DD	FLAT:$SG74451
	DD	00H
	DD	010H
	DD	FLAT:$SG74452
	DD	0c0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74453
	DD	00H
	DD	08H
	DD	FLAT:$SG74454
	DD	0c4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74455
	DD	00H
	DD	08H
	DD	FLAT:$SG74456
	DD	0d0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74457
	DD	00H
	DD	07H
	DD	FLAT:$SG74458
	DD	0dcH
	DW	01H
	DW	07H
	DD	FLAT:$SG74459
	DD	00H
	DD	07H
	DD	FLAT:$SG74460
	DD	0e8H
	DW	01H
	DW	07H
	DD	FLAT:$SG74461
	DD	00H
	DD	07H
	DD	FLAT:$SG74462
	DD	0f4H
	DW	01H
	DW	07H
	DD	FLAT:$SG74463
	DD	00H
	DD	00H
	DD	FLAT:$SG74464
	DD	0100H
	DW	01H
	DW	06H
	DD	FLAT:$SG74465
	DD	00H
	DD	0fH
	DD	FLAT:$SG74466
	DD	0104H
	DW	01H
	DW	06H
	DD	FLAT:$SG74467
	DD	00H
	DD	0aH
	DD	FLAT:$SG74468
	DD	010cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74469
	DD	00H
	DD	0aH
	DD	FLAT:$SG74470
	DD	0108H
	DW	01H
	DW	06H
	DD	FLAT:$SG74471
	DD	00H
	DD	0aH
	DD	FLAT:$SG74472
	DD	0110H
	DW	01H
	DW	06H
	DD	FLAT:$SG74473
	DD	00H
	DD	0aH
	DD	FLAT:$SG74474
	DD	0114H
	DW	01H
	DW	06H
	DD	FLAT:$SG74475
	DD	00H
	DD	0aH
	DD	FLAT:$SG74476
	DD	0118H
	DW	01H
	DW	06H
	DD	FLAT:$SG74477
	DD	00H
	DD	00H
	DD	FLAT:$SG74478
	DD	011cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74479
	DD	00H
	DD	00H
	DD	FLAT:$SG74480
	DD	0120H
	DW	01H
	DW	06H
	DD	FLAT:$SG74481
	DD	00H
	DD	00H
	DD	FLAT:$SG74482
	DD	0124H
	DW	01H
	DW	06H
	DD	FLAT:$SG74483
	DD	00H
	DD	00H
	DD	FLAT:$SG74484
	DD	0130H
	DW	01H
	DW	06H
	DD	FLAT:$SG74485
	DD	00H
	DD	00H
	DD	FLAT:$SG74486
	DD	0144H
	DW	01H
	DW	06H
	DD	FLAT:$SG74487
	DD	00H
	DD	0aH
	DD	FLAT:$SG74488
	DD	0128H
	DW	01H
	DW	06H
	DD	FLAT:$SG74489
	DD	00H
	DD	0fH
	DD	FLAT:$SG74490
	DD	0134H
	DW	01H
	DW	06H
	DD	FLAT:$SG74491
	DD	00H
	DD	00H
	DD	FLAT:$SG74492
	DD	0138H
	DW	01H
	DW	06H
	DD	FLAT:$SG74493
	DD	00H
	DD	0aH
	DD	FLAT:$SG74494
	DD	013cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74495
	DD	00H
	DD	0dH
	DD	FLAT:$SG74496
	DD	0140H
	DW	01H
	DW	06H
	DD	FLAT:$SG74497
	DD	00H
	DD	0aH
	DD	FLAT:$SG74498
	DD	0148H
	DW	01H
	DW	06H
	DD	FLAT:$SG74499
	DD	00H
	DD	00H
	DD	FLAT:$SG74500
	DD	014cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74501
	DD	00H
	DD	07H
	DD	FLAT:$SG74502
	DD	0150H
	DW	01H
	DW	06H
	DD	FLAT:$SG74503
	DD	00H
	DD	0aH
	DD	FLAT:$SG74504
	DD	015cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74505
	DD	00H
	DD	00H
	DD	FLAT:$SG74506
	DD	0160H
	DW	01H
	DW	06H
	DD	FLAT:$SG74507
	DD	00H
	DD	00H
	DD	FLAT:$SG74508
	DD	0164H
	DW	01H
	DW	06H
	DD	FLAT:$SG74509
	DD	00H
	DD	00H
	DD	FLAT:$SG74510
	DD	016cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74511
	DD	00H
	DD	00H
	DD	FLAT:$SG74512
	DD	0170H
	DW	01H
	DW	06H
	DD	FLAT:$SG74513
	DD	00H
	DD	07H
	DD	FLAT:$SG74514
	DD	0174H
	DW	01H
	DW	06H
	DD	FLAT:$SG74515
	DD	00H
	DD	0aH
	DD	FLAT:$SG74516
	DD	0180H
	DW	01H
	DW	06H
	DD	FLAT:$SG74517
	DD	00H
	DD	0aH
	DD	FLAT:$SG74518
	DD	0184H
	DW	01H
	DW	06H
	DD	FLAT:$SG74519
	DD	00H
	DD	06H
	DD	FLAT:$SG74520
	DD	0188H
	DW	01H
	DW	06H
	DD	FLAT:$SG74521
	DD	00H
	DD	06H
	DD	FLAT:$SG74522
	DD	018cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74523
	DD	00H
	DD	06H
	DD	FLAT:$SG74524
	DD	0190H
	DW	01H
	DW	06H
	DD	FLAT:$SG74525
	DD	00H
	DD	06H
	DD	FLAT:$SG74526
	DD	0194H
	DW	01H
	DW	06H
	DD	FLAT:$SG74527
	DD	00H
	DD	06H
	DD	FLAT:$SG74528
	DD	0198H
	DW	01H
	DW	06H
	DD	FLAT:$SG74529
	DD	00H
	DD	06H
	DD	FLAT:$SG74530
	DD	019cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74531
	DD	00H
	DD	0aH
	DD	FLAT:$SG74532
	DD	01a0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74533
	DD	00H
	DD	00H
	DD	FLAT:$SG74534
	DD	01a4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74535
	DD	00H
	DD	0aH
	DD	FLAT:$SG74536
	DD	01a8H
	DW	01H
	DW	06H
	DD	FLAT:$SG74537
	DD	00H
	DD	0aH
	DD	FLAT:$SG74538
	DD	01acH
	DW	01H
	DW	06H
	DD	FLAT:$SG74539
	DD	00H
	DD	00H
	DD	FLAT:$SG74540
	DD	01b0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74541
	DD	00H
	DD	0fH
	DD	FLAT:$SG74542
	DD	01b4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74543
	DD	00H
	DD	00H
	DD	FLAT:$SG74544
	DD	01b8H
	DW	01H
	DW	06H
	DD	FLAT:$SG74545
	DD	00H
	DD	00H
	DD	FLAT:$SG74546
	DD	01bcH
	DW	01H
	DW	06H
	DD	FLAT:$SG74547
	DD	00H
	DD	0aH
	DD	FLAT:$SG74548
	DD	01c0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74549
	DD	00H
	DD	0aH
	DD	FLAT:$SG74550
	DD	01c4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74551
	DD	00H
	DD	01H
	DD	FLAT:$SG74552
	DD	01c8H
	DW	01H
	DW	07H
	DD	FLAT:$SG74553
	DD	00H
	DD	01H
	DD	FLAT:$SG74554
	DD	01ccH
	DW	01H
	DW	07H
	DD	FLAT:$SG74555
	DD	00H
	DD	01H
	DD	FLAT:$SG74556
	DD	01d0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74557
	DD	00H
	DD	01H
	DD	FLAT:$SG74558
	DD	01d4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74559
	DD	00H
	DD	00H
	DD	FLAT:$SG74560
	DD	01d8H
	DW	01H
	DW	06H
	DD	FLAT:$SG74561
	DD	00H
	DD	00H
	DD	FLAT:$SG74562
	DD	01dcH
	DW	01H
	DW	06H
	DD	FLAT:$SG74563
	DD	00H
	DD	00H
	DD	FLAT:$SG74564
	DD	01e0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74565
	DD	00H
	DD	0fH
	DD	FLAT:$SG74566
	DD	01e4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74567
	DD	00H
	DD	011H
	DD	FLAT:$SG74568
	DD	01e8H
	DW	01H
	DW	06H
	DD	FLAT:$SG74569
	DD	00H
	DD	011H
	DD	FLAT:$SG74570
	DD	01ecH
	DW	01H
	DW	06H
	DD	FLAT:$SG74571
	DD	00H
	DD	011H
	DD	FLAT:$SG74572
	DD	01f0H
	DW	01H
	DW	06H
	DD	FLAT:$SG74573
	DD	00H
	DD	011H
	DD	FLAT:$SG74574
	DD	01f4H
	DW	01H
	DW	06H
	DD	FLAT:$SG74575
	DD	00H
	DD	00H
	DD	FLAT:$SG74576
	DD	01f8H
	DW	01H
	DW	06H
	DD	FLAT:$SG74577
	DD	00H
	DD	0fH
	DD	FLAT:$SG74578
	DD	01fcH
	DW	01H
	DW	06H
	DD	FLAT:$SG74579
	DD	00H
	DD	0fH
	DD	FLAT:$SG74580
	DD	0200H
	DW	01H
	DW	06H
	DD	FLAT:$SG74581
	DD	00H
	DD	0fH
	DD	FLAT:$SG74582
	DD	0204H
	DW	01H
	DW	06H
	DD	FLAT:$SG74583
	DD	00H
	DD	07H
	DD	FLAT:$SG74584
	DD	0264H
	DW	01H
	DW	07H
	DD	FLAT:$SG74585
	DD	00H
	DD	07H
	DD	FLAT:$SG74586
	DD	0270H
	DW	01H
	DW	06H
	DD	FLAT:$SG74587
	DD	00H
	DD	0aH
	DD	FLAT:$SG74588
	DD	0244H
	DW	01H
	DW	06H
	DD	FLAT:$SG74589
	DD	00H
	DD	0aH
	DD	FLAT:$SG74590
	DD	0248H
	DW	01H
	DW	06H
	DD	FLAT:$SG74591
	DD	00H
	DD	0aH
	DD	FLAT:$SG74592
	DD	024cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74593
	DD	00H
	DD	00H
	DD	FLAT:$SG74594
	DD	0254H
	DW	01H
	DW	06H
	DD	FLAT:$SG74595
	DD	00H
	DD	00H
	DD	FLAT:$SG74596
	DD	0258H
	DW	01H
	DW	06H
	DD	FLAT:$SG74597
	DD	00H
	DD	00H
	DD	FLAT:$SG74598
	DD	025cH
	DW	01H
	DW	06H
	DD	FLAT:$SG74599
	DD	00H
	DD	00H
	DD	FLAT:$SG74600
	DD	0260H
	DW	01H
	DW	06H
	DD	FLAT:$SG74601
	DD	00H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
PUBLIC	??0CSaveRestoreBuffer@@QAE@XZ			; CSaveRestoreBuffer::CSaveRestoreBuffer
PUBLIC	??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z	; CSaveRestoreBuffer::CSaveRestoreBuffer
PUBLIC	??1CSaveRestoreBuffer@@QAE@XZ			; CSaveRestoreBuffer::~CSaveRestoreBuffer
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ; CSaveRestoreBuffer::EntityIndex
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z	; CSaveRestoreBuffer::EntityIndex
PUBLIC	?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ; CSaveRestoreBuffer::EntityIndex
PUBLIC	?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z	; CSaveRestoreBuffer::EntityFlagsSet
PUBLIC	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
PUBLIC	?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z	; CSaveRestoreBuffer::TokenHash
PUBLIC	?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z	; CSaveRestoreBuffer::BufferRewind
PUBLIC	?HashString@CSaveRestoreBuffer@@IAEIPBD@Z	; CSaveRestoreBuffer::HashString
PUBLIC	?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z	; CSave::DoWriteAll
PUBLIC	?WriteShort@CSave@@QAEXPBDPBFH@Z		; CSave::WriteShort
PUBLIC	?WriteInt@CSave@@QAEXPBDPBHH@Z			; CSave::WriteInt
PUBLIC	?WriteFloat@CSave@@QAEXPBDPBMH@Z		; CSave::WriteFloat
PUBLIC	?WriteTime@CSave@@QAEXPBDPBMH@Z			; CSave::WriteTime
PUBLIC	?WriteData@CSave@@QAEXPBDH0@Z			; CSave::WriteData
PUBLIC	?WriteString@CSave@@QAEXPBD0@Z			; CSave::WriteString
PUBLIC	?WriteString@CSave@@QAEXPBDPBHH@Z		; CSave::WriteString
PUBLIC	?WriteVector@CSave@@QAEXPBDABVVector@@@Z	; CSave::WriteVector
PUBLIC	?WriteVector@CSave@@QAEXPBDPBMH@Z		; CSave::WriteVector
PUBLIC	?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z ; CSave::WritePositionVector
PUBLIC	?WritePositionVector@CSave@@QAEXPBDPBMH@Z	; CSave::WritePositionVector
PUBLIC	?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z ; CSave::WriteFunction
PUBLIC	?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ; CSave::WriteEntVars
PUBLIC	?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CSave::WriteFields
PUBLIC	?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z ; CSave::Log
PUBLIC	?DataEmpty@CSave@@AAEHPBDH@Z			; CSave::DataEmpty
PUBLIC	?BufferField@CSave@@AAEXPBDH0@Z			; CSave::BufferField
PUBLIC	?BufferString@CSave@@AAEXPADH@Z			; CSave::BufferString
PUBLIC	?BufferData@CSave@@AAEXPBDH@Z			; CSave::BufferData
PUBLIC	?BufferHeader@CSave@@AAEXPBDH@Z			; CSave::BufferHeader
PUBLIC	?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z	; CRestore::DoReadAll
PUBLIC	?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ; CRestore::ReadEntVars
PUBLIC	?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CRestore::ReadFields
PUBLIC	?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z ; CRestore::ReadField
PUBLIC	?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z ; CRestore::ReadFunction
PUBLIC	?ReadInt@CRestore@@QAEHXZ			; CRestore::ReadInt
PUBLIC	?ReadShort@CRestore@@QAEFXZ			; CRestore::ReadShort
PUBLIC	?ReadNamedInt@CRestore@@QAEHPBD@Z		; CRestore::ReadNamedInt
PUBLIC	?ReadNamedString@CRestore@@QAEPADPBD@Z		; CRestore::ReadNamedString
PUBLIC	?Empty@CRestore@@QAEHXZ				; CRestore::Empty
PUBLIC	?BufferPointer@CRestore@@AAEPADXZ		; CRestore::BufferPointer
PUBLIC	?BufferReadBytes@CRestore@@AAEXPADH@Z		; CRestore::BufferReadBytes
PUBLIC	?BufferSkipBytes@CRestore@@AAEXH@Z		; CRestore::BufferSkipBytes
PUBLIC	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z	; CRestore::BufferReadHeader
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
PUBLIC	?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z ; EntvarsKeyvalue
PUBLIC	??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_stricmp:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	?Q_strncat@@YAIPADPBDI@Z:PROC			; Q_strncat
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:PROC			; Q_strncpy
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:PROC			; Q_strnicmp
EXTRN	?Q_strncmp@@YAHPBD0H@Z:PROC			; Q_strncmp
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:PROC			; Q_snprintf
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:PROC ; DBG_EntOfVars
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:PROC	; ENT
EXTRN	?UTIL_StringToVector@@YAXPAMPBD@Z:PROC		; UTIL_StringToVector
EXTRN	?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z:PROC	; UTIL_SetMovedir
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:PROC		; DBG_AssertFunction
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:PROC ; UTIL_FunctionToName
EXTRN	?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z:PROC ; UTIL_FunctionFromName
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:PROC ; CBaseEntity::SetAbsOrigin
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:PROC ; CBaseEntity::SetAbsAngles
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA
_BSS	SEGMENT
?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA DD 01H DUP (?) ; `CSaveRestoreBuffer::TokenHash'::`2'::tokensparsed
_BSS	ENDS
;	COMDAT ?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA
_BSS	SEGMENT
?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA DD 01H DUP (?) ; `CSaveRestoreBuffer::TokenHash'::`6'::beentheredonethat
_BSS	ENDS
;	COMDAT ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
_BSS	SEGMENT
?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA DB 0400H DUP (?) ; `CSave::Log'::`2'::szBuf
_BSS	ENDS
;	COMDAT ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
_BSS	SEGMENT
?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA DB 0100H DUP (?) ; `CSave::Log'::`2'::szTempBuf
_BSS	ENDS
_DATA	SEGMENT
?gSizes@@3PAHA DD 04H					; gSizes
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	0cH
	DD	0cH
	DD	04H
	DD	04H
	DD	04H
	DD	01H
	DD	02H
	DD	01H
	DD	04H
	DD	04H
	DD	04H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
tv199 = -24						; size = 4
_pEntity$1 = -20					; size = 4
tv76 = -16						; size = 4
_i$2 = -12						; size = 4
_pField$ = -8						; size = 4
_pEntity$3 = -4						; size = 4
_pev$ = 8						; size = 4
_pkvd$ = 12						; size = 4
?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z PROC ; EntvarsKeyvalue

; 565  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 566  : 	TYPEDESCRIPTION *pField;
; 567  : 
; 568  : 	for ( int i = 0; i < ENTVARS_COUNT; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@EntvarsKey
$LN2@EntvarsKey:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@EntvarsKey:
	cmp	DWORD PTR _i$2[ebp], 94			; 0000005eH
	jae	$LN3@EntvarsKey

; 569  : 	{
; 570  : 		pField = &gEntvarsDescription[i];

	imul	ecx, DWORD PTR _i$2[ebp], 24
	add	ecx, OFFSET ?gEntvarsDescription@@3PAUtypedescription_s@@A ; gEntvarsDescription
	mov	DWORD PTR _pField$[ebp], ecx

; 571  : 
; 572  : 		if ( !Q_stricmp( pField->fieldName, pkvd->szKeyName ) )

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@EntvarsKey

; 573  : 		{
; 574  : 			switch( pField->fieldType )

	mov	eax, DWORD PTR _pField$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 17			; 00000011H
	ja	$LN12@EntvarsKey
	mov	edx, DWORD PTR tv76[ebp]
	movzx	eax, BYTE PTR $LN22@EntvarsKey[edx]
	jmp	DWORD PTR $LN23@EntvarsKey[eax*4]
$LN8@EntvarsKey:

; 575  : 			{
; 576  : 			case FIELD_MODELNAME:
; 577  : 			case FIELD_SOUNDNAME:
; 578  : 			case FIELD_STRING:
; 579  : 				(*(int *)((char *)pev + pField->fieldOffset)) = ALLOC_STRING( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 580  : 				break;

	jmp	SHORT $LN5@EntvarsKey
$LN9@EntvarsKey:

; 581  : 
; 582  : 			case FIELD_TIME:
; 583  : 			case FIELD_FLOAT:
; 584  : 				(*(float *)((char *)pev + pField->fieldOffset)) = atof( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	fstp	DWORD PTR tv199[ebp]
	fld	DWORD PTR tv199[ebp]
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _pev$[ebp]
	fstp	DWORD PTR [eax+edx]

; 585  : 				break;

	jmp	SHORT $LN5@EntvarsKey
$LN10@EntvarsKey:

; 586  : 
; 587  : 			case FIELD_INTEGER:
; 588  : 				(*(int *)((char *)pev + pField->fieldOffset)) = atoi( pkvd->szValue );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 589  : 				break;

	jmp	SHORT $LN5@EntvarsKey
$LN11@EntvarsKey:

; 590  : 
; 591  : 			case FIELD_POSITION_VECTOR:
; 592  : 			case FIELD_VECTOR:
; 593  : 				UTIL_StringToVector( (float *)((char *)pev + pField->fieldOffset), pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR _pev$[ebp]
	add	edx, DWORD PTR [ecx+8]
	push	edx
	call	?UTIL_StringToVector@@YAXPAMPBD@Z	; UTIL_StringToVector
	add	esp, 8

; 594  : 				break;

	jmp	SHORT $LN5@EntvarsKey
$LN12@EntvarsKey:

; 595  : 			case FIELD_EVARS:
; 596  : 			case FIELD_CLASSPTR:
; 597  : 			case FIELD_EDICT:
; 598  : 			case FIELD_ENTITY:
; 599  : 			case FIELD_POINTER:
; 600  : 			default:	ALERT( at_error, "Bad field in entity!!\n" );

	push	OFFSET $SG74930
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN5@EntvarsKey:

; 601  : 				break;
; 602  : 			}
; 603  : 
; 604  : 			// g-cont. HACKHACK to set origin and angles properly
; 605  : 			if( FStrEq( pField->fieldName, "origin" ))

	push	OFFSET $SG74933
	mov	eax, DWORD PTR _pField$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@EntvarsKey

; 606  : 			{
; 607  : 				CBaseEntity *pEntity = CBaseEntity::Instance( pev );

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$1[ebp], eax

; 608  : 				if( pEntity ) pEntity->SetAbsOrigin( pev->origin );

	cmp	DWORD PTR _pEntity$1[ebp], 0
	je	SHORT $LN15@EntvarsKey
	mov	eax, DWORD PTR _pev$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pEntity$1[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin
$LN15@EntvarsKey:

; 609  : 			}

	jmp	$LN17@EntvarsKey
$LN13@EntvarsKey:

; 610  : 			else if( FStrEq( pField->fieldName, "angles" ))

	push	OFFSET $SG74936
	mov	ecx, DWORD PTR _pField$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$LN17@EntvarsKey

; 611  : 			{
; 612  : 				CBaseEntity *pEntity = CBaseEntity::Instance( pev );

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$3[ebp], eax

; 613  : 				if( pEntity )

	cmp	DWORD PTR _pEntity$3[ebp], 0
	je	$LN17@EntvarsKey

; 614  : 				{
; 615  : 					if( pEntity->ObjectCaps() & FCAP_SET_MOVEDIR )

	mov	ecx, DWORD PTR _pEntity$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$3[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	and	eax, 1
	je	SHORT $LN18@EntvarsKey

; 616  : 					{
; 617  : 						UTIL_SetMovedir( pEntity );

	mov	ecx, DWORD PTR _pEntity$3[ebp]
	push	ecx
	call	?UTIL_SetMovedir@@YAXPAVCBaseEntity@@@Z	; UTIL_SetMovedir
	add	esp, 4
	jmp	SHORT $LN20@EntvarsKey
$LN18@EntvarsKey:

; 618  : 					}
; 619  : 					else if( pEntity->ObjectCaps() & FCAP_HOLD_ANGLES )

	mov	edx, DWORD PTR _pEntity$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$3[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	and	eax, 1024				; 00000400H
	je	SHORT $LN20@EntvarsKey

; 620  : 					{
; 621  : 						pEntity->m_vecTempAngles = pev->angles;

	mov	eax, DWORD PTR _pev$[ebp]
	add	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _pEntity$3[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 622  : 						pev->angles = g_vecZero;

	mov	ecx, DWORD PTR _pev$[ebp]
	add	ecx, 80					; 00000050H
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx
$LN20@EntvarsKey:

; 623  : 					}
; 624  : 					pEntity->SetAbsAngles( pev->angles );

	mov	eax, DWORD PTR _pev$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _pEntity$3[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 625  : 					pEntity->m_fSetAngles = TRUE;

	mov	ecx, DWORD PTR _pEntity$3[ebp]
	mov	DWORD PTR [ecx+72], 1
$LN17@EntvarsKey:

; 626  : 				}
; 627  : 			}
; 628  : 
; 629  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 630  : 			return;

	jmp	SHORT $LN1@EntvarsKey
$LN7@EntvarsKey:

; 631  : 		}
; 632  : 	}

	jmp	$LN2@EntvarsKey
$LN3@EntvarsKey:
$LN1@EntvarsKey:

; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@EntvarsKey:
	DD	$LN9@EntvarsKey
	DD	$LN8@EntvarsKey
	DD	$LN11@EntvarsKey
	DD	$LN10@EntvarsKey
	DD	$LN12@EntvarsKey
$LN22@EntvarsKey:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	1
	DB	1
?EntvarsKeyvalue@@YAXPAUentvars_s@@PAUKeyValueData_s@@@Z ENDP ; EntvarsKeyvalue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8						; size = 4
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC	; CBaseEntity::Instance, COMDAT

; 519  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\cbase.h
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4						; size = 4
_pent$ = 8						; size = 4
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC	; CBaseEntity::Instance, COMDAT

; 512  : 	{ 

	push	ebp
	mov	ebp, esp
	push	ecx

; 513  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $LN2@Instance

; 514  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$LN2@Instance:

; 515  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 516  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 517  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pEntity$ = 8						; size = 4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC		; EHANDLE::operator=, COMDAT
; _this$ = ecx

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $LN2@operator

; 71   : 	{
; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@operator

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN4@operator:

; 75   : 	}
; 76   : 	else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 77   : 	{
; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN3@operator:

; 80   : 	}
; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC			; EHANDLE::operator CBaseEntity *, COMDAT
; _this$ = ecx

; 64   : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\ehandle.h
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC			; EHANDLE::Get, COMDAT
; _this$ = ecx

; 40   : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Get

; 42   : 	{
; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN2@Get

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN1@Get
$LN2@Get:

; 50   : 	}
; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$LN1@Get:

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_pheader$ = 8						; size = 4
?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z PROC	; CRestore::BufferReadHeader
; _this$ = ecx

; 1038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 	ASSERT( pheader!=NULL );

	cmp	DWORD PTR _pheader$[ebp], 0
	je	SHORT $LN3@BufferRead
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@BufferRead
$LN3@BufferRead:
	mov	DWORD PTR tv69[ebp], 0
$LN4@BufferRead:
	push	0
	push	1039					; 0000040fH
	push	OFFSET $SG75244
	push	OFFSET $SG75245
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1040 : 	pheader->size = ReadShort();				// Read field size

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	ecx, DWORD PTR _pheader$[ebp]
	mov	WORD PTR [ecx], ax

; 1041 : 	pheader->token = ReadShort();				// Read field name token

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	edx, DWORD PTR _pheader$[ebp]
	mov	WORD PTR [edx+2], ax

; 1042 : 	pheader->pData = BufferPointer();			// Field Data is next

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferPointer@CRestore@@AAEPADXZ	; CRestore::BufferPointer
	mov	ecx, DWORD PTR _pheader$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1043 : 	BufferSkipBytes( pheader->size );			// Advance to next field

	mov	edx, DWORD PTR _pheader$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferSkipBytes@CRestore@@AAEXH@Z	; CRestore::BufferSkipBytes

; 1044 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ENDP	; CRestore::BufferReadHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bytes$ = 8						; size = 4
?BufferSkipBytes@CRestore@@AAEXH@Z PROC			; CRestore::BufferSkipBytes
; _this$ = ecx

; 1123 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 	BufferReadBytes( NULL, bytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadBytes@CRestore@@AAEXPADH@Z	; CRestore::BufferReadBytes

; 1125 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BufferSkipBytes@CRestore@@AAEXH@Z ENDP			; CRestore::BufferSkipBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
_pOutput$ = 8						; size = 4
_size$ = 12						; size = 4
?BufferReadBytes@CRestore@@AAEXPADH@Z PROC		; CRestore::BufferReadBytes
; _this$ = ecx

; 1093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 	ASSERT( m_pdata !=NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN7@BufferRead
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN8@BufferRead
$LN7@BufferRead:
	mov	DWORD PTR tv74[ebp], 0
$LN8@BufferRead:
	push	0
	push	1094					; 00000446H
	push	OFFSET $SG75282
	push	OFFSET $SG75283
	mov	ecx, DWORD PTR tv74[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1095 : 
; 1096 : 	if ( !m_pdata || Empty() )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN3@BufferRead
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Empty@CRestore@@QAEHXZ			; CRestore::Empty
	test	eax, eax
	je	SHORT $LN2@BufferRead
$LN3@BufferRead:

; 1097 : 		return;

	jmp	$LN1@BufferRead
$LN2@BufferRead:

; 1098 : 
; 1099 : 	if ( (m_pdata->size + size) > m_pdata->bufferSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN4@BufferRead

; 1100 : 	{
; 1101 : 		ALERT( at_error, "Restore overflow!" );

	push	OFFSET $SG75287
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1102 : 		m_pdata->size = m_pdata->bufferSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+8], eax

; 1103 : 		return;

	jmp	SHORT $LN1@BufferRead
$LN4@BufferRead:

; 1104 : 	}
; 1105 : 
; 1106 : 	if ( pOutput )

	cmp	DWORD PTR _pOutput$[ebp], 0
	je	SHORT $LN5@BufferRead

; 1107 : 		memcpy( pOutput, m_pdata->pCurrentData, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pOutput$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@BufferRead:

; 1108 : 	m_pdata->pCurrentData += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+4], edx

; 1109 : 	m_pdata->size += size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [eax+8], ecx
$LN1@BufferRead:

; 1110 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BufferReadBytes@CRestore@@AAEXPADH@Z ENDP		; CRestore::BufferReadBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BufferPointer@CRestore@@AAEPADXZ PROC			; CRestore::BufferPointer
; _this$ = ecx

; 1085 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 	if ( !m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN2@BufferPoin

; 1087 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@BufferPoin
$LN2@BufferPoin:

; 1088 : 
; 1089 : 	return m_pdata->pCurrentData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
$LN1@BufferPoin:

; 1090 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BufferPointer@CRestore@@AAEPADXZ ENDP			; CRestore::BufferPointer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.h
;	COMDAT ?Empty@CRestore@@QAEHXZ
_TEXT	SEGMENT
tv90 = -8						; size = 4
_this$ = -4						; size = 4
?Empty@CRestore@@QAEHXZ PROC				; CRestore::Empty, COMDAT
; _this$ = ecx

; 102  : 	int	Empty( void ) { return (m_pdata == NULL) || ((m_pdata->pCurrentData-m_pdata->pBaseData)>=m_pdata->bufferSize); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@Empty
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx+4]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN3@Empty
	mov	DWORD PTR tv90[ebp], 0
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv90[ebp], 1
$LN4@Empty:
	mov	eax, DWORD PTR tv90[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Empty@CRestore@@QAEHXZ ENDP				; CRestore::Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_header$ = -12						; size = 8
_this$ = -4						; size = 4
_pName$ = 8						; size = 4
?ReadNamedString@CRestore@@QAEPADPBD@Z PROC		; CRestore::ReadNamedString
; _this$ = ecx

; 1073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1074 : 	HEADER header;
; 1075 : 
; 1076 : 	BufferReadHeader( &header );

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ; CRestore::BufferReadHeader

; 1077 : #ifdef TOKENIZE
; 1078 : 	return (char *)(m_pdata->pTokens[*(short *)header.pData]);
; 1079 : #else
; 1080 : 	return (char *)header.pData;

	mov	eax, DWORD PTR _header$[ebp+4]

; 1081 : #endif
; 1082 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ReadNamedString@CRestore@@QAEPADPBD@Z ENDP		; CRestore::ReadNamedString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_header$ = -12						; size = 8
_this$ = -4						; size = 4
_pName$ = 8						; size = 4
?ReadNamedInt@CRestore@@QAEHPBD@Z PROC			; CRestore::ReadNamedInt
; _this$ = ecx

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1066 : 	HEADER header;
; 1067 : 
; 1068 : 	BufferReadHeader( &header );

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ; CRestore::BufferReadHeader

; 1069 : 	return ((int *)header.pData)[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _header$[ebp+4]
	mov	eax, DWORD PTR [eax+edx]

; 1070 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ReadNamedInt@CRestore@@QAEHPBD@Z ENDP			; CRestore::ReadNamedInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_tmp$ = -4						; size = 2
?ReadShort@CRestore@@QAEFXZ PROC			; CRestore::ReadShort
; _this$ = ecx

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1048 : 	short tmp = 0;

	xor	eax, eax
	mov	WORD PTR _tmp$[ebp], ax

; 1049 : 
; 1050 : 	BufferReadBytes( (char *)&tmp, sizeof(short) );

	push	2
	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadBytes@CRestore@@AAEXPADH@Z	; CRestore::BufferReadBytes

; 1051 : 
; 1052 : 	return tmp;

	mov	ax, WORD PTR _tmp$[ebp]

; 1053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadShort@CRestore@@QAEFXZ ENDP			; CRestore::ReadShort
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_tmp$ = -4						; size = 4
?ReadInt@CRestore@@QAEHXZ PROC				; CRestore::ReadInt
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1057 : 	int tmp = 0;

	mov	DWORD PTR _tmp$[ebp], 0

; 1058 : 
; 1059 : 	BufferReadBytes( (char *)&tmp, sizeof(int) );

	push	4
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadBytes@CRestore@@AAEXPADH@Z	; CRestore::BufferReadBytes

; 1060 : 
; 1061 : 	return tmp;

	mov	eax, DWORD PTR _tmp$[ebp]

; 1062 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadInt@CRestore@@QAEHXZ ENDP				; CRestore::ReadInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMap$ = 8						; size = 4
_pValue$ = 12						; size = 4
_pszFunctionName$ = 16					; size = 4
?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z PROC ; CRestore::ReadFunction
; _this$ = ecx

; 1113 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 	if ( strlen( (char *)pszFunctionName ) == 0 )

	mov	eax, DWORD PTR _pszFunctionName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@ReadFuncti

; 1115 : 		*pValue = NULL;

	mov	ecx, DWORD PTR _pValue$[ebp]
	mov	DWORD PTR [ecx], 0

; 1116 : 	else

	jmp	SHORT $LN3@ReadFuncti
$LN2@ReadFuncti:

; 1117 : 		*pValue = UTIL_FunctionFromName( pMap, pszFunctionName );

	mov	edx, DWORD PTR _pszFunctionName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	call	?UTIL_FunctionFromName@@YAPAXPAUdatamap_s@@PBD@Z ; UTIL_FunctionFromName
	add	esp, 8
	mov	ecx, DWORD PTR _pValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@ReadFuncti:

; 1118 : 
; 1119 : 	return 0;

	xor	eax, eax

; 1120 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z ENDP ; CRestore::ReadFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 12
_position$ = -72					; size = 12
_fieldNumber$ = -60					; size = 4
_time$ = -56						; size = 4
tv163 = -52						; size = 4
_stringCount$ = -48					; size = 4
_timeData$ = -44					; size = 4
_string$2 = -40						; size = 4
_i$ = -36						; size = 4
_pString$ = -32						; size = 4
_j$ = -28						; size = 4
_entityIndex$ = -24					; size = 4
_pTest$ = -20						; size = 4
_this$ = -16						; size = 4
_pent$ = -12						; size = 4
_pInputData$3 = -8					; size = 4
_pOutputData$4 = -4					; size = 4
_pBaseData$ = 8						; size = 4
_pMap$ = 12						; size = 4
_pFields$ = 16						; size = 4
_fieldCount$ = 20					; size = 4
_startField$ = 24					; size = 4
_size$ = 28						; size = 4
_pName$ = 32						; size = 4
_pData$ = 36						; size = 4
?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z PROC ; CRestore::ReadField
; _this$ = ecx

; 823  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 824  : 	int i, j, stringCount, fieldNumber, entityIndex;
; 825  : 	TYPEDESCRIPTION *pTest;
; 826  : 	float	time, timeData;
; 827  : 	Vector	position;

	lea	ecx, DWORD PTR _position$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 828  : 	edict_t	*pent;
; 829  : 	char	*pString;
; 830  : 
; 831  : 	time = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _time$[ebp], xmm0

; 832  : 	position = Vector(0,0,0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _position$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _position$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _position$[ebp+8], eax

; 833  : 
; 834  : 	if ( m_pdata )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN16@ReadField

; 835  : 	{
; 836  : 		time = m_pdata->time;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	movss	xmm0, DWORD PTR [eax+1360]
	movss	DWORD PTR _time$[ebp], xmm0

; 837  : 		if ( m_pdata->fUseLandmark )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+1324], 0
	je	SHORT $LN16@ReadField

; 838  : 			position = m_pdata->vecLandmarkOffset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1348				; 00000544H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _position$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _position$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _position$[ebp+8], ecx
$LN16@ReadField:

; 839  : 	}
; 840  : 
; 841  : 	for ( i = 0; i < fieldCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ReadField
$LN2@ReadField:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ReadField:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fieldCount$[ebp]
	jge	$LN3@ReadField

; 842  : 	{
; 843  : 		fieldNumber = (i+startField)%fieldCount;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _startField$[ebp]
	cdq
	idiv	DWORD PTR _fieldCount$[ebp]
	mov	DWORD PTR _fieldNumber$[ebp], edx

; 844  : 		pTest = &pFields[ fieldNumber ];

	imul	ecx, DWORD PTR _fieldNumber$[ebp], 24
	add	ecx, DWORD PTR _pFields$[ebp]
	mov	DWORD PTR _pTest$[ebp], ecx

; 845  : 		if ( !stricmp( pTest->fieldName, pName ) )

	mov	edx, DWORD PTR _pName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN17@ReadField

; 846  : 		{
; 847  : 			if ( !m_global || !(pTest->flags & FTYPEDESC_GLOBAL) )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN19@ReadField
	mov	eax, DWORD PTR _pTest$[ebp]
	movsx	ecx, WORD PTR [eax+14]
	and	ecx, 1
	jne	$LN6@ReadField
$LN19@ReadField:

; 848  : 			{
; 849  : 				for ( j = 0; j < pTest->fieldSize; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@ReadField
$LN5@ReadField:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@ReadField:
	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN6@ReadField

; 850  : 				{
; 851  : 					void *pOutputData = ((char *)pBaseData + pTest->fieldOffset + (j*gSizes[pTest->fieldType]) );

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR _pBaseData$[ebp]
	add	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, DWORD PTR ?gSizes@@3PAHA[edx*4]
	add	eax, ecx
	mov	DWORD PTR _pOutputData$4[ebp], eax

; 852  : 					void *pInputData = (char *)pData + j * gSizes[pTest->fieldType];

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, DWORD PTR ?gSizes@@3PAHA[eax*4]
	add	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pInputData$3[ebp], ecx

; 853  : 
; 854  : 					switch( pTest->fieldType )

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv163[ebp], eax
	cmp	DWORD PTR tv163[ebp], 17		; 00000011H
	ja	$LN49@ReadField
	mov	ecx, DWORD PTR tv163[ebp]
	jmp	DWORD PTR $LN51@ReadField[ecx*4]
$LN20@ReadField:

; 855  : 					{
; 856  : 					case FIELD_TIME:
; 857  : 						timeData = *(float *)pInputData;

	mov	edx, DWORD PTR _pInputData$3[ebp]
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _timeData$[ebp], xmm0

; 858  : 						// Re-base time variables
; 859  : 						timeData += time;

	movss	xmm0, DWORD PTR _timeData$[ebp]
	addss	xmm0, DWORD PTR _time$[ebp]
	movss	DWORD PTR _timeData$[ebp], xmm0

; 860  : 						*((float *)pOutputData) = timeData;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	movss	xmm0, DWORD PTR _timeData$[ebp]
	movss	DWORD PTR [eax], xmm0

; 861  : 						break;

	jmp	$LN8@ReadField
$LN21@ReadField:

; 862  : 					case FIELD_FLOAT:
; 863  : 						*((float *)pOutputData) = *(float *)pInputData;

	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	edx, DWORD PTR _pInputData$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 864  : 						break;

	jmp	$LN8@ReadField
$LN22@ReadField:

; 865  : 					case FIELD_MODELNAME:
; 866  : 					case FIELD_SOUNDNAME:
; 867  : 					case FIELD_STRING:
; 868  : 						// Skip over j strings
; 869  : 						pString = (char *)pData;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pString$[ebp], ecx

; 870  : 						for ( stringCount = 0; stringCount < j; stringCount++ )

	mov	DWORD PTR _stringCount$[ebp], 0
	jmp	SHORT $LN12@ReadField
$LN10@ReadField:
	mov	edx, DWORD PTR _stringCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _stringCount$[ebp], edx
$LN12@ReadField:
	mov	eax, DWORD PTR _stringCount$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	jge	SHORT $LN11@ReadField
$LN13@ReadField:

; 871  : 						{
; 872  : 							while (*pString)

	mov	ecx, DWORD PTR _pString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN14@ReadField

; 873  : 								pString++;

	mov	eax, DWORD PTR _pString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pString$[ebp], eax
	jmp	SHORT $LN13@ReadField
$LN14@ReadField:

; 874  : 							pString++;

	mov	ecx, DWORD PTR _pString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pString$[ebp], ecx

; 875  : 						}

	jmp	SHORT $LN10@ReadField
$LN11@ReadField:

; 876  : 						pInputData = pString;

	mov	edx, DWORD PTR _pString$[ebp]
	mov	DWORD PTR _pInputData$3[ebp], edx

; 877  : 						if ( strlen( (char *)pInputData ) == 0 )

	mov	eax, DWORD PTR _pInputData$3[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@ReadField

; 878  : 							*((int *)pOutputData) = 0;

	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [ecx], 0

; 879  : 						else

	jmp	SHORT $LN28@ReadField
$LN23@ReadField:

; 880  : 						{
; 881  : 							int string;
; 882  : 
; 883  : 							string = ALLOC_STRING( (char *)pInputData );

	mov	edx, DWORD PTR _pInputData$3[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	DWORD PTR _string$2[ebp], eax

; 884  : 							
; 885  : 							*((int *)pOutputData) = string;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	mov	ecx, DWORD PTR _string$2[ebp]
	mov	DWORD PTR [eax], ecx

; 886  : 
; 887  : 							if ( !FStringNull( string ) && m_precache )

	mov	edx, DWORD PTR _string$2[ebp]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN28@ReadField
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN28@ReadField

; 888  : 							{
; 889  : 								if ( pTest->fieldType == FIELD_MODELNAME )

	mov	ecx, DWORD PTR _pTest$[ebp]
	cmp	DWORD PTR [ecx], 16			; 00000010H
	jne	SHORT $LN26@ReadField

; 890  : 									PRECACHE_MODEL( (char *)STRING( string ) );

	mov	edx, DWORD PTR _string$2[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	jmp	SHORT $LN28@ReadField
$LN26@ReadField:

; 891  : 								else if ( pTest->fieldType == FIELD_SOUNDNAME )

	mov	eax, DWORD PTR _pTest$[ebp]
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN28@ReadField

; 892  : 									PRECACHE_SOUND( (char *)STRING( string ) );

	mov	ecx, DWORD PTR _string$2[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4
$LN28@ReadField:

; 893  : 							}
; 894  : 						}
; 895  : 						break;

	jmp	$LN8@ReadField
$LN29@ReadField:

; 896  : 					case FIELD_EVARS:
; 897  : 						entityIndex = *( int *)pInputData;

	mov	edx, DWORD PTR _pInputData$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _entityIndex$[ebp], eax

; 898  : 						pent = EntityFromIndex( entityIndex );

	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 899  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN30@ReadField

; 900  : 							*((entvars_t **)pOutputData) = VARS(pent);

	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [ecx], eax

; 901  : 						else

	jmp	SHORT $LN31@ReadField
$LN30@ReadField:

; 902  : 							*((entvars_t **)pOutputData) = NULL;

	mov	edx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [edx], 0
$LN31@ReadField:

; 903  : 						break;

	jmp	$LN8@ReadField
$LN32@ReadField:

; 904  : 					case FIELD_CLASSPTR:
; 905  : 						entityIndex = *( int *)pInputData;

	mov	eax, DWORD PTR _pInputData$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entityIndex$[ebp], ecx

; 906  : 						pent = EntityFromIndex( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 907  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN33@ReadField

; 908  : 							*((CBaseEntity **)pOutputData) = CBaseEntity::Instance(pent);

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [ecx], eax

; 909  : 						else

	jmp	SHORT $LN34@ReadField
$LN33@ReadField:

; 910  : 							*((CBaseEntity **)pOutputData) = NULL;

	mov	edx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [edx], 0
$LN34@ReadField:

; 911  : 						break;

	jmp	$LN8@ReadField
$LN35@ReadField:

; 912  : 					case FIELD_EDICT:
; 913  : 						entityIndex = *( int *)pInputData;

	mov	eax, DWORD PTR _pInputData$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entityIndex$[ebp], ecx

; 914  : 						pent = EntityFromIndex( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 915  : 						*((edict_t **)pOutputData) = pent;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax], ecx

; 916  : 						break;

	jmp	$LN8@ReadField
$LN36@ReadField:

; 917  : 					case FIELD_EHANDLE:
; 918  : 						// Input and Output sizes are different!
; 919  : 						pOutputData = (char *)pOutputData + j*(sizeof(EHANDLE) - gSizes[pTest->fieldType]);

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, 8
	sub	ecx, DWORD PTR ?gSizes@@3PAHA[eax*4]
	imul	ecx, DWORD PTR _j$[ebp]
	add	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR _pOutputData$4[ebp], ecx

; 920  : 						entityIndex = *( int *)pInputData;

	mov	edx, DWORD PTR _pInputData$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _entityIndex$[ebp], eax

; 921  : 						pent = EntityFromIndex( entityIndex );

	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 922  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN37@ReadField

; 923  : 							*((EHANDLE *)pOutputData) = CBaseEntity::Instance(pent);

	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 924  : 						else

	jmp	SHORT $LN38@ReadField
$LN37@ReadField:

; 925  : 							*((EHANDLE *)pOutputData) = NULL;

	push	0
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$LN38@ReadField:

; 926  : 						break;

	jmp	$LN8@ReadField
$LN39@ReadField:

; 927  : 					case FIELD_ENTITY:
; 928  : 						entityIndex = *( int *)pInputData;

	mov	eax, DWORD PTR _pInputData$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entityIndex$[ebp], ecx

; 929  : 						pent = EntityFromIndex( entityIndex );

	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ; CSaveRestoreBuffer::EntityFromIndex
	mov	DWORD PTR _pent$[ebp], eax

; 930  : 						if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN40@ReadField

; 931  : 							*((EOFFSET *)pOutputData) = OFFSET(pent);

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [ecx], eax

; 932  : 						else

	jmp	SHORT $LN41@ReadField
$LN40@ReadField:

; 933  : 							*((EOFFSET *)pOutputData) = 0;

	mov	edx, DWORD PTR _pOutputData$4[ebp]
	mov	DWORD PTR [edx], 0
$LN41@ReadField:

; 934  : 						break;

	jmp	$LN8@ReadField
$LN42@ReadField:

; 935  : 					case FIELD_VECTOR:
; 936  : 						((float *)pOutputData)[0] = ((float *)pInputData)[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pOutputData$4[ebp]
	mov	esi, DWORD PTR _pInputData$3[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 937  : 						((float *)pOutputData)[1] = ((float *)pInputData)[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	mov	esi, DWORD PTR _pInputData$3[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx

; 938  : 						((float *)pOutputData)[2] = ((float *)pInputData)[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pOutputData$4[ebp]
	mov	esi, DWORD PTR _pInputData$3[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 939  : 						break;

	jmp	$LN8@ReadField
$LN43@ReadField:

; 940  : 					case FIELD_POSITION_VECTOR:
; 941  : 						((float *)pOutputData)[0] = ((float *)pInputData)[0] + position.x;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pInputData$3[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _position$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pOutputData$4[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 942  : 						((float *)pOutputData)[1] = ((float *)pInputData)[1] + position.y;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pInputData$3[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _position$[ebp+4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 943  : 						((float *)pOutputData)[2] = ((float *)pInputData)[2] + position.z;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pInputData$3[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _position$[ebp+8]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pOutputData$4[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 944  : 						break;

	jmp	SHORT $LN8@ReadField
$LN44@ReadField:

; 945  : 					case FIELD_BOOLEAN:
; 946  : 					case FIELD_INTEGER:
; 947  : 						*((int *)pOutputData) = *( int *)pInputData;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	mov	ecx, DWORD PTR _pInputData$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 948  : 						break;

	jmp	SHORT $LN8@ReadField
$LN45@ReadField:

; 949  : 					case FIELD_SHORT:
; 950  : 						*((short *)pOutputData) = *( short *)pInputData;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	mov	ecx, DWORD PTR _pInputData$3[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 951  : 						break;

	jmp	SHORT $LN8@ReadField
$LN46@ReadField:

; 952  : 					case FIELD_CHARACTER:
; 953  : 						*((char *)pOutputData) = *( char *)pInputData;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	mov	ecx, DWORD PTR _pInputData$3[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 954  : 						break;

	jmp	SHORT $LN8@ReadField
$LN47@ReadField:

; 955  : 					case FIELD_POINTER:
; 956  : 						*((int *)pOutputData) = *( int *)pInputData;

	mov	eax, DWORD PTR _pOutputData$4[ebp]
	mov	ecx, DWORD PTR _pInputData$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 957  : 						break;

	jmp	SHORT $LN8@ReadField
$LN48@ReadField:

; 958  : 					case FIELD_FUNCTION:
; 959  : 						ReadFunction( pMap, (void **)pOutputData, (const char *)pInputData );

	mov	eax, DWORD PTR _pInputData$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadFunction@CRestore@@QAEHPAUdatamap_s@@PAPAXPBD@Z ; CRestore::ReadFunction

; 960  : 						break;

	jmp	SHORT $LN8@ReadField
$LN49@ReadField:

; 961  : 					default:
; 962  : 						ALERT( at_error, "Bad field type\n" );

	push	OFFSET $SG75197
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN8@ReadField:

; 963  : 					}
; 964  : 				}

	jmp	$LN5@ReadField
$LN6@ReadField:

; 965  : 			}
; 966  : 			return fieldNumber;

	mov	eax, DWORD PTR _fieldNumber$[ebp]
	jmp	SHORT $LN1@ReadField
$LN17@ReadField:

; 967  : 		}
; 968  : 	}

	jmp	$LN2@ReadField
$LN3@ReadField:

; 969  : 
; 970  : 	return -1;

	or	eax, -1
$LN1@ReadField:

; 971  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	2
$LN51@ReadField:
	DD	$LN21@ReadField
	DD	$LN22@ReadField
	DD	$LN39@ReadField
	DD	$LN32@ReadField
	DD	$LN36@ReadField
	DD	$LN29@ReadField
	DD	$LN35@ReadField
	DD	$LN42@ReadField
	DD	$LN43@ReadField
	DD	$LN47@ReadField
	DD	$LN44@ReadField
	DD	$LN48@ReadField
	DD	$LN44@ReadField
	DD	$LN45@ReadField
	DD	$LN46@ReadField
	DD	$LN20@ReadField
	DD	$LN22@ReadField
	DD	$LN22@ReadField
?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z ENDP ; CRestore::ReadField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_header$ = -32						; size = 8
_fileCount$ = -24					; size = 4
tv72 = -20						; size = 4
_lastField$ = -16					; size = 4
_this$ = -12						; size = 4
_token$ = -8						; size = 2
_i$ = -4						; size = 2
_pname$ = 8						; size = 4
_pBaseData$ = 12					; size = 4
_pMap$ = 16						; size = 4
_pFields$ = 20						; size = 4
_fieldCount$ = 24					; size = 4
?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z PROC ; CRestore::ReadFields
; _this$ = ecx

; 979  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 	unsigned short	i, token;
; 981  : 	int		lastField, fileCount;
; 982  : 	HEADER	header;
; 983  : 
; 984  : 	i = ReadShort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	WORD PTR _i$[ebp], ax

; 985  : 	ASSERT( i == sizeof(int) );			// First entry should be an int

	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, 4
	jne	SHORT $LN12@ReadFields
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN13@ReadFields
$LN12@ReadFields:
	mov	DWORD PTR tv72[ebp], 0
$LN13@ReadFields:
	push	0
	push	985					; 000003d9H
	push	OFFSET $SG75226
	push	OFFSET $SG75227
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 986  : 
; 987  : 	token = ReadShort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadShort@CRestore@@QAEFXZ		; CRestore::ReadShort
	mov	WORD PTR _token$[ebp], ax

; 988  : 
; 989  : 	// Check the struct name
; 990  : 	if ( token != TokenHash(pname) )			// Field Set marker

	movzx	esi, WORD PTR _token$[ebp]
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z ; CSaveRestoreBuffer::TokenHash
	movzx	eax, ax
	cmp	esi, eax
	je	SHORT $LN8@ReadFields

; 991  : 	{
; 992  : //		ALERT( at_error, "Expected %s found %s!\n", pname, BufferPointer() );
; 993  : 		BufferRewind( 2*sizeof(short) );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z ; CSaveRestoreBuffer::BufferRewind

; 994  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadFields
$LN8@ReadFields:

; 995  : 	}
; 996  : 
; 997  : 	// Skip over the struct name
; 998  : 	fileCount = ReadInt();						// Read field count

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadInt@CRestore@@QAEHXZ		; CRestore::ReadInt
	mov	DWORD PTR _fileCount$[ebp], eax

; 999  : 
; 1000 : 	lastField = 0;								// Make searches faster, most data is read/written in the same order

	mov	DWORD PTR _lastField$[ebp], 0

; 1001 : 
; 1002 : 	// Clear out base data
; 1003 : 	for ( i = 0; i < fieldCount; i++ )

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN4@ReadFields
$LN2@ReadFields:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN4@ReadFields:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fieldCount$[ebp]
	jge	SHORT $LN3@ReadFields

; 1004 : 	{
; 1005 : 		// Don't clear global fields
; 1006 : 		if ( !m_global || !(pFields[i].flags & FTYPEDESC_GLOBAL) )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN10@ReadFields
	movzx	edx, WORD PTR _i$[ebp]
	imul	eax, edx, 24
	mov	ecx, DWORD PTR _pFields$[ebp]
	movsx	edx, WORD PTR [ecx+eax+14]
	and	edx, 1
	jne	SHORT $LN9@ReadFields
$LN10@ReadFields:

; 1007 : 			memset( ((char *)pBaseData + pFields[i].fieldOffset), 0, pFields[i].fieldSize * gSizes[pFields[i].fieldType] );

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _pFields$[ebp]
	movzx	eax, WORD PTR [edx+ecx+12]
	movzx	ecx, WORD PTR _i$[ebp]
	imul	edx, ecx, 24
	mov	ecx, DWORD PTR _pFields$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	imul	eax, DWORD PTR ?gSizes@@3PAHA[edx*4]
	push	eax
	push	0
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _pFields$[ebp]
	mov	eax, DWORD PTR _pBaseData$[ebp]
	add	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@ReadFields:

; 1008 : 	}

	jmp	SHORT $LN2@ReadFields
$LN3@ReadFields:

; 1009 : 
; 1010 : 	for ( i = 0; i < fileCount; i++ )

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN7@ReadFields
$LN5@ReadFields:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN7@ReadFields:
	movzx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fileCount$[ebp]
	jge	SHORT $LN6@ReadFields

; 1011 : 	{
; 1012 : 		BufferReadHeader( &header );

	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferReadHeader@CRestore@@AAEXPAUHEADER@@@Z ; CRestore::BufferReadHeader

; 1013 : 		lastField = ReadField( pBaseData, pMap, pFields, fieldCount, lastField, header.size, m_pdata->pTokens[header.token], header.pData );

	mov	edx, DWORD PTR _header$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	movzx	edx, WORD PTR _header$[ebp+2]
	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	movzx	edx, WORD PTR _header$[ebp]
	push	edx
	mov	eax, DWORD PTR _lastField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fieldCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFields$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBaseData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadField@CRestore@@QAEHPBXPAUdatamap_s@@PAUtypedescription_s@@HHHPADPAX@Z ; CRestore::ReadField
	mov	DWORD PTR _lastField$[ebp], eax

; 1014 : 		lastField++;

	mov	edx, DWORD PTR _lastField$[ebp]
	add	edx, 1
	mov	DWORD PTR _lastField$[ebp], edx

; 1015 : 	}

	jmp	SHORT $LN5@ReadFields
$LN6@ReadFields:

; 1016 : 	
; 1017 : 	return 1;

	mov	eax, 1
$LN1@ReadFields:

; 1018 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ENDP ; CRestore::ReadFields
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_pMap$ = 12						; size = 4
_pev$ = 16						; size = 4
?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z PROC ; CRestore::ReadEntVars
; _this$ = ecx

; 974  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 975  : 	return ReadFields( pname, pev, pMap, gEntvarsDescription, ENTVARS_COUNT );

	push	94					; 0000005eH
	push	OFFSET ?gEntvarsDescription@@3PAUtypedescription_s@@A ; gEntvarsDescription
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CRestore::ReadFields

; 976  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ENDP ; CRestore::ReadEntVars
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_status$1 = -4						; size = 4
_pLeafObject$ = 8					; size = 4
_pLeafMap$ = 12						; size = 4
_pCurMap$ = 16						; size = 4
?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z PROC	; CRestore::DoReadAll
; _this$ = ecx

; 1025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1026 : 	// restore base classes first
; 1027 : 	if ( pCurMap->baseMap )

	mov	eax, DWORD PTR _pCurMap$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN2@DoReadAll

; 1028 : 	{
; 1029 : 		int status = DoReadAll( pLeafObject, pLeafMap, pCurMap->baseMap );

	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z ; CRestore::DoReadAll
	mov	DWORD PTR _status$1[ebp], eax

; 1030 : 		if ( !status )

	cmp	DWORD PTR _status$1[ebp], 0
	jne	SHORT $LN2@DoReadAll

; 1031 : 			return status;

	mov	eax, DWORD PTR _status$1[ebp]
	jmp	SHORT $LN1@DoReadAll
$LN2@DoReadAll:

; 1032 : 	}
; 1033 : 
; 1034 : 	return ReadFields( pCurMap->dataClassName, pLeafObject, pLeafMap, pCurMap->dataDesc, pCurMap->dataNumFields );

	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadFields@CRestore@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CRestore::ReadFields
$LN1@DoReadAll:

; 1035 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z ENDP	; CRestore::DoReadAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hashvalue$ = -4					; size = 2
_pname$ = 8						; size = 4
_size$ = 12						; size = 4
?BufferHeader@CSave@@AAEXPBDH@Z PROC			; CSave::BufferHeader
; _this$ = ecx

; 790  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 791  : 	short	hashvalue = TokenHash( pname );

	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z ; CSaveRestoreBuffer::TokenHash
	mov	WORD PTR _hashvalue$[ebp], ax

; 792  : 	if ( size > 1<<(sizeof(short)*8) )

	cmp	DWORD PTR _size$[ebp], 65536		; 00010000H
	jle	SHORT $LN2@BufferHead

; 793  : 		ALERT( at_error, "CSave :: BufferHeader() size parameter exceeds 'short'!" );

	push	OFFSET $SG75063
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN2@BufferHead:

; 794  : 	BufferData( (const char *)&size, sizeof(short) );

	push	2
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 795  : 	BufferData( (const char *)&hashvalue, sizeof(short) );

	push	2
	lea	edx, DWORD PTR _hashvalue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 796  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BufferHeader@CSave@@AAEXPBDH@Z ENDP			; CSave::BufferHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pdata$ = 8						; size = 4
_size$ = 12						; size = 4
?BufferData@CSave@@AAEXPBDH@Z PROC			; CSave::BufferData
; _this$ = ecx

; 799  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 	if ( !m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN2@BufferData

; 801  : 		return;

	jmp	SHORT $LN1@BufferData
$LN2@BufferData:

; 802  : 
; 803  : 	if ( m_pdata->size + size > m_pdata->bufferSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+12]
	jle	SHORT $LN3@BufferData

; 804  : 	{
; 805  : 		ALERT( at_error, "Save/Restore overflow!" );

	push	OFFSET $SG75071
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 806  : 		m_pdata->size = m_pdata->bufferSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], ecx

; 807  : 		return;

	jmp	SHORT $LN1@BufferData
$LN3@BufferData:

; 808  : 	}
; 809  : 
; 810  : 	memcpy( m_pdata->pCurrentData, pdata, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 811  : 	m_pdata->pCurrentData += size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax

; 812  : 	m_pdata->size += size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], edx
$LN1@BufferData:

; 813  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BufferData@CSave@@AAEXPBDH@Z ENDP			; CSave::BufferData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$ = -1						; size = 1
_pdata$ = 8						; size = 4
_len$ = 12						; size = 4
?BufferString@CSave@@AAEXPADH@Z PROC			; CSave::BufferString
; _this$ = ecx

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 767  : 	char c = 0;

	mov	BYTE PTR _c$[ebp], 0

; 768  : 
; 769  : 	BufferData( pdata, len );		// Write the string

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 770  : 	BufferData( &c, 1 );			// Write a null terminator

	push	1
	lea	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 771  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BufferString@CSave@@AAEXPADH@Z ENDP			; CSave::BufferString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_size$ = 12						; size = 4
_pdata$ = 16						; size = 4
?BufferField@CSave@@AAEXPBDH0@Z PROC			; CSave::BufferField
; _this$ = ecx

; 784  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 785  : 	BufferHeader( pname, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 786  : 	BufferData( pdata, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 787  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BufferField@CSave@@AAEXPBDH0@Z ENDP			; CSave::BufferField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_pdata$ = 8						; size = 4
_size$ = 12						; size = 4
?DataEmpty@CSave@@AAEHPBDH@Z PROC			; CSave::DataEmpty
; _this$ = ecx

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 	for ( int i = 0; i < size; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@DataEmpty
$LN2@DataEmpty:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@DataEmpty:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	SHORT $LN3@DataEmpty

; 776  : 	{
; 777  : 		if ( pdata[i] )

	mov	edx, DWORD PTR _pdata$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@DataEmpty

; 778  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@DataEmpty
$LN5@DataEmpty:

; 779  : 	}

	jmp	SHORT $LN2@DataEmpty
$LN3@DataEmpty:

; 780  : 	return 1;

	mov	eax, 1
$LN1@DataEmpty:

; 781  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DataEmpty@CSave@@AAEHPBDH@Z ENDP			; CSave::DataEmpty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_vecValue$1 = -80					; size = 12
_this$ = -68						; size = 4
_funcName$2 = -64					; size = 4
_pValue$3 = -60						; size = 4
_pValue$4 = -56						; size = 4
_pValue$5 = -52						; size = 4
_sValue$6 = -48						; size = 4
_pValue$7 = -44						; size = 4
_nValue$8 = -40						; size = 4
_pValue$9 = -36						; size = 4
_pValue$10 = -32					; size = 4
_flValue$11 = -28					; size = 4
_pValue$12 = -24					; size = 4
_pValue$13 = -20					; size = 4
tv71 = -16						; size = 4
_iCount$14 = -12					; size = 4
_nValue$15 = -8						; size = 2
_chValue$16 = -2					; size = 1
_bValue$17 = -1						; size = 1
_pMap$ = 8						; size = 4
_pName$ = 12						; size = 4
_pFieldName$ = 16					; size = 4
_fieldType$ = 20					; size = 4
_value$ = 24						; size = 4
_count$ = 28						; size = 4
?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z PROC ; CSave::Log
; _this$ = ecx

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 343  : 	// Check to see if we are logging.
; 344  : 	static char szBuf[1024];
; 345  : 	static char szTempBuf[256];
; 346  : 
; 347  : 	// Save the name.
; 348  : 	Q_snprintf( szBuf, sizeof( szBuf ), "%s->%s ", pName, pFieldName );

	mov	eax, DWORD PTR _pFieldName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET $SG74761
	push	1024					; 00000400H
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 349  : 
; 350  : 	for ( int iCount = 0; iCount < count; iCount++ )

	mov	DWORD PTR _iCount$14[ebp], 0
	jmp	SHORT $LN4@Log
$LN2@Log:
	mov	edx, DWORD PTR _iCount$14[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$14[ebp], edx
$LN4@Log:
	mov	eax, DWORD PTR _iCount$14[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@Log

; 351  : 	{
; 352  : 		switch ( fieldType )

	mov	ecx, DWORD PTR _fieldType$[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 17			; 00000011H
	ja	$LN16@Log
	mov	edx, DWORD PTR tv71[ebp]
	movzx	eax, BYTE PTR $LN20@Log[edx]
	jmp	DWORD PTR $LN21@Log[eax*4]
$LN7@Log:

; 353  : 		{
; 354  : 		case FIELD_SHORT:
; 355  : 			{
; 356  : 				short *pValue = ( short* )( value );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$13[ebp], ecx

; 357  : 				short nValue = pValue[iCount];

	mov	edx, DWORD PTR _iCount$14[ebp]
	mov	eax, DWORD PTR _pValue$13[ebp]
	mov	cx, WORD PTR [eax+edx*2]
	mov	WORD PTR _nValue$15[ebp], cx

; 358  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", nValue );

	movsx	edx, WORD PTR _nValue$15[ebp]
	push	edx
	push	OFFSET $SG74763
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 359  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 360  : 				break;

	jmp	$LN5@Log
$LN8@Log:

; 361  : 			}
; 362  : 		case FIELD_FLOAT:
; 363  : 		case FIELD_TIME:
; 364  : 			{
; 365  : 				float *pValue = ( float* )( value );

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$12[ebp], eax

; 366  : 				float flValue = pValue[iCount];

	mov	ecx, DWORD PTR _iCount$14[ebp]
	mov	edx, DWORD PTR _pValue$12[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _flValue$11[ebp], xmm0

; 367  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%f", flValue );

	cvtss2sd xmm0, DWORD PTR _flValue$11[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG74765
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 368  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 369  : 				break;

	jmp	$LN5@Log
$LN9@Log:

; 370  : 			}
; 371  : 		case FIELD_BOOLEAN:
; 372  : 			{
; 373  : 				bool *pValue = ( bool* )( value );

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$10[ebp], eax

; 374  : 				bool bValue = pValue[iCount];

	mov	ecx, DWORD PTR _pValue$10[ebp]
	add	ecx, DWORD PTR _iCount$14[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _bValue$17[ebp], dl

; 375  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", ( int )( bValue ) );

	movzx	eax, BYTE PTR _bValue$17[ebp]
	push	eax
	push	OFFSET $SG74767
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 376  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 377  : 				break;

	jmp	$LN5@Log
$LN10@Log:

; 378  : 			}
; 379  : 		case FIELD_INTEGER:
; 380  : 			{
; 381  : 				int *pValue = ( int* )( value );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$9[ebp], ecx

; 382  : 				int nValue = pValue[iCount];

	mov	edx, DWORD PTR _iCount$14[ebp]
	mov	eax, DWORD PTR _pValue$9[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _nValue$8[ebp], ecx

; 383  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", nValue );

	mov	edx, DWORD PTR _nValue$8[ebp]
	push	edx
	push	OFFSET $SG74769
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 384  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 385  : 				break;

	jmp	$LN5@Log
$LN11@Log:

; 386  : 			}
; 387  : 		case FIELD_STRING:
; 388  : 		case FIELD_MODELNAME:
; 389  : 		case FIELD_SOUNDNAME:
; 390  : 			{
; 391  : 				string_t *pValue = ( string_t* )( value );

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$7[ebp], eax

; 392  : 				string_t sValue = pValue[iCount];

	mov	ecx, DWORD PTR _iCount$14[ebp]
	mov	edx, DWORD PTR _pValue$7[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _sValue$6[ebp], eax

; 393  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%s", ( char* )STRING( sValue ) );

	mov	ecx, DWORD PTR _sValue$6[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET $SG74771
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 394  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 395  : 				break;					

	jmp	$LN5@Log
$LN12@Log:

; 396  : 			}
; 397  : 		case FIELD_VECTOR:
; 398  : 		case FIELD_POSITION_VECTOR:
; 399  : 			{
; 400  : 				Vector *pValue = ( Vector* )( value );

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$5[ebp], edx

; 401  : 				Vector vecValue = pValue[iCount];

	imul	eax, DWORD PTR _iCount$14[ebp], 12
	add	eax, DWORD PTR _pValue$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecValue$1[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 402  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "(%f %f %f)", vecValue.x, vecValue.y, vecValue.z );

	cvtss2sd xmm0, DWORD PTR _vecValue$1[ebp+8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _vecValue$1[ebp+4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _vecValue$1[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG74773
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 36					; 00000024H

; 403  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 404  : 				break;

	jmp	$LN5@Log
$LN13@Log:

; 405  : 			}
; 406  : 		case FIELD_CHARACTER:
; 407  : 			{
; 408  : 				if( count != 1 ) break;

	cmp	DWORD PTR _count$[ebp], 1
	je	SHORT $LN14@Log
	jmp	$LN5@Log
$LN14@Log:

; 409  : 				char *pValue = ( char* )( value );

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$4[ebp], ecx

; 410  : 				char chValue = pValue[iCount];

	mov	edx, DWORD PTR _pValue$4[ebp]
	add	edx, DWORD PTR _iCount$14[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _chValue$16[ebp], al

; 411  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%d", chValue );

	movsx	ecx, BYTE PTR _chValue$16[ebp]
	push	ecx
	push	OFFSET $SG74776
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 412  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 413  : 				break;

	jmp	SHORT $LN5@Log
$LN15@Log:

; 414  : 			}
; 415  : 		case FIELD_FUNCTION:
; 416  : 			{
; 417  : 				const int *pValue = (int *)value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _pValue$3[ebp], edx

; 418  : 				const char *funcName = UTIL_FunctionToName( pMap, (void *)( *pValue ));

	mov	eax, DWORD PTR _pValue$3[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pMap$[ebp]
	push	edx
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	mov	DWORD PTR _funcName$2[ebp], eax

; 419  : 				Q_snprintf( szTempBuf, sizeof( szTempBuf ), "%s", funcName );

	mov	eax, DWORD PTR _funcName$2[ebp]
	push	eax
	push	OFFSET $SG74778
	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 420  : 				Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$LN16@Log:
$LN5@Log:

; 421  : 				break;
; 422  : 			}
; 423  : 		default:
; 424  : 			break;
; 425  : 		}
; 426  : 
; 427  : 		// Add space data.
; 428  : 		if ( ( iCount + 1 ) != count )

	mov	ecx, DWORD PTR _iCount$14[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _count$[ebp]
	je	SHORT $LN17@Log

; 429  : 		{
; 430  : 			Q_strncpy( szTempBuf, " ", sizeof( szTempBuf ) );

	push	256					; 00000100H
	push	OFFSET $SG74782
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 431  : 			Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH

; 432  : 		}
; 433  : 		else

	jmp	SHORT $LN18@Log
$LN17@Log:

; 434  : 		{
; 435  : 			Q_strncpy( szTempBuf, "\n", sizeof( szTempBuf ) );

	push	256					; 00000100H
	push	OFFSET $SG74783
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 436  : 			Q_strncat( szBuf, szTempBuf, sizeof( szTempBuf ));

	push	256					; 00000100H
	push	OFFSET ?szTempBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$LN18@Log:

; 437  : 		}
; 438  : 	}

	jmp	$LN2@Log
$LN3@Log:

; 439  : 
; 440  : 	ALERT( at_console, szBuf );

	push	OFFSET ?szBuf@?1??Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z@4PADA
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 441  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN21@Log:
	DD	$LN8@Log
	DD	$LN11@Log
	DD	$LN12@Log
	DD	$LN10@Log
	DD	$LN15@Log
	DD	$LN9@Log
	DD	$LN7@Log
	DD	$LN13@Log
	DD	$LN16@Log
$LN20@Log:
	DB	0
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	2
	DB	8
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	0
	DB	1
	DB	1
?Log@CSave@@AAEXPAUdatamap_s@@PBD1W4_fieldtypes@@PAXH@Z ENDP ; CSave::Log
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_actualCount$ = -300					; size = 4
_pOutputData$1 = -296					; size = 4
tv141 = -292						; size = 4
_emptyCount$ = -288					; size = 4
tv174 = -284						; size = 4
_i$ = -280						; size = 4
_j$ = -276						; size = 4
_pOutputData$2 = -272					; size = 4
_this$ = -268						; size = 4
_pTest$ = -264						; size = 4
_entityArray$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_pname$ = 8						; size = 4
_pBaseData$ = 12					; size = 4
_pMap$ = 16						; size = 4
_pFields$ = 20						; size = 4
_fieldCount$ = 24					; size = 4
?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z PROC ; CSave::WriteFields
; _this$ = ecx

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 659  : 	int i, j, actualCount, emptyCount;
; 660  : 	int entityArray[MAX_ENTITYARRAY];
; 661  : 	TYPEDESCRIPTION *pTest;
; 662  : 
; 663  : 	// Precalculate the number of empty fields
; 664  : 	emptyCount = 0;

	mov	DWORD PTR _emptyCount$[ebp], 0

; 665  : 	for ( i = 0; i < fieldCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@WriteField
$LN2@WriteField:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@WriteField:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _fieldCount$[ebp]
	jge	SHORT $LN3@WriteField

; 666  : 	{
; 667  : 		void *pOutputData;
; 668  : 		pOutputData = ((char *)pBaseData + pFields[i].fieldOffset );

	imul	edx, DWORD PTR _i$[ebp], 24
	mov	eax, DWORD PTR _pFields$[ebp]
	mov	ecx, DWORD PTR _pBaseData$[ebp]
	add	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _pOutputData$1[ebp], ecx

; 669  : 		if ( DataEmpty( (const char *)pOutputData, pFields[i].fieldSize * gSizes[pFields[i].fieldType] ) )

	imul	edx, DWORD PTR _i$[ebp], 24
	mov	eax, DWORD PTR _pFields$[ebp]
	movzx	ecx, WORD PTR [eax+edx+12]
	imul	edx, DWORD PTR _i$[ebp], 24
	mov	eax, DWORD PTR _pFields$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	imul	ecx, DWORD PTR ?gSizes@@3PAHA[edx*4]
	push	ecx
	mov	eax, DWORD PTR _pOutputData$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DataEmpty@CSave@@AAEHPBDH@Z		; CSave::DataEmpty
	test	eax, eax
	je	SHORT $LN15@WriteField

; 670  : 			emptyCount++;

	mov	ecx, DWORD PTR _emptyCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _emptyCount$[ebp], ecx
$LN15@WriteField:

; 671  : 	}

	jmp	SHORT $LN2@WriteField
$LN3@WriteField:

; 672  : 
; 673  : 	// Empty fields will not be written, write out the actual number of fields to be written
; 674  : 	actualCount = fieldCount - emptyCount;

	mov	edx, DWORD PTR _fieldCount$[ebp]
	sub	edx, DWORD PTR _emptyCount$[ebp]
	mov	DWORD PTR _actualCount$[ebp], edx

; 675  : 	WriteInt( pname, &actualCount, 1 );

	push	1
	lea	eax, DWORD PTR _actualCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 676  : 
; 677  : 	for ( i = 0; i < fieldCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@WriteField
$LN5@WriteField:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@WriteField:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fieldCount$[ebp]
	jge	$LN6@WriteField

; 678  : 	{
; 679  : 		void *pOutputData;
; 680  : 		pTest = &pFields[ i ];

	imul	ecx, DWORD PTR _i$[ebp], 24
	add	ecx, DWORD PTR _pFields$[ebp]
	mov	DWORD PTR _pTest$[ebp], ecx

; 681  : 		pOutputData = ((char *)pBaseData + pTest->fieldOffset );

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR _pBaseData$[ebp]
	add	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _pOutputData$2[ebp], eax

; 682  : 
; 683  : 		// UNDONE: Must we do this twice?
; 684  : 		if ( DataEmpty( (const char *)pOutputData, pTest->fieldSize * gSizes[pTest->fieldType] ) )

	mov	ecx, DWORD PTR _pTest$[ebp]
	movzx	edx, WORD PTR [ecx+12]
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR ?gSizes@@3PAHA[ecx*4]
	push	edx
	mov	edx, DWORD PTR _pOutputData$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DataEmpty@CSave@@AAEHPBDH@Z		; CSave::DataEmpty
	test	eax, eax
	je	SHORT $LN16@WriteField

; 685  : 			continue;

	jmp	SHORT $LN5@WriteField
$LN16@WriteField:

; 686  : 
; 687  : #ifdef _DEBUG
; 688  : 		// Log( pMap, pname, pTest->fieldName, pTest->fieldType, pOutputData, pTest->fieldSize );
; 689  : #endif
; 690  : 		switch( pTest->fieldType )

	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv141[ebp], ecx
	cmp	DWORD PTR tv141[ebp], 17		; 00000011H
	ja	$LN34@WriteField
	mov	edx, DWORD PTR tv141[ebp]
	jmp	DWORD PTR $LN36@WriteField[edx*4]
$LN17@WriteField:

; 691  : 		{
; 692  : 		case FIELD_FLOAT:
; 693  : 			WriteFloat( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pOutputData$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFloat@CSave@@QAEXPBDPBMH@Z	; CSave::WriteFloat

; 694  : 			break;

	jmp	$LN8@WriteField
$LN18@WriteField:

; 695  : 		case FIELD_TIME:
; 696  : 			WriteTime( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	edx, DWORD PTR _pTest$[ebp]
	movzx	eax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteTime@CSave@@QAEXPBDPBMH@Z		; CSave::WriteTime

; 697  : 			break;

	jmp	$LN8@WriteField
$LN19@WriteField:

; 698  : 		case FIELD_MODELNAME:
; 699  : 		case FIELD_SOUNDNAME:
; 700  : 		case FIELD_STRING:
; 701  : 			WriteString( pTest->fieldName, (int *)pOutputData, pTest->fieldSize );

	mov	ecx, DWORD PTR _pTest$[ebp]
	movzx	edx, WORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pOutputData$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteString@CSave@@QAEXPBDPBHH@Z	; CSave::WriteString

; 702  : 			break;

	jmp	$LN8@WriteField
$LN20@WriteField:

; 703  : 		case FIELD_CLASSPTR:
; 704  : 		case FIELD_EVARS:
; 705  : 		case FIELD_EDICT:
; 706  : 		case FIELD_ENTITY:
; 707  : 		case FIELD_EHANDLE:
; 708  : 			if ( pTest->fieldSize > MAX_ENTITYARRAY )

	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	cmp	ecx, 64					; 00000040H
	jle	SHORT $LN21@WriteField

; 709  : 				ALERT( at_error, "Can't save more than %d entities in an array!!!\n", MAX_ENTITYARRAY );

	push	64					; 00000040H
	push	OFFSET $SG75014
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$LN21@WriteField:

; 710  : 			for ( j = 0; j < pTest->fieldSize; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN12@WriteField
$LN10@WriteField:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN12@WriteField:
	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	cmp	DWORD PTR _j$[ebp], ecx
	jge	$LN11@WriteField

; 711  : 			{
; 712  : 				switch( pTest->fieldType )

	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv174[ebp], eax
	mov	ecx, DWORD PTR tv174[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv174[ebp], ecx
	cmp	DWORD PTR tv174[ebp], 4
	ja	$LN13@WriteField
	mov	edx, DWORD PTR tv174[ebp]
	jmp	DWORD PTR $LN37@WriteField[edx*4]
$LN22@WriteField:

; 713  : 				{
; 714  : 					case FIELD_EVARS:
; 715  : 						entityArray[j] = EntityIndex( ((entvars_t **)pOutputData)[j] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+ecx*4], eax

; 716  : 					break;

	jmp	$LN13@WriteField
$LN23@WriteField:

; 717  : 					case FIELD_CLASSPTR:
; 718  : 						entityArray[j] = EntityIndex( ((CBaseEntity **)pOutputData)[j] );

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pOutputData$2[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+edx*4], eax

; 719  : 					break;

	jmp	$LN13@WriteField
$LN24@WriteField:

; 720  : 					case FIELD_EDICT:
; 721  : 						entityArray[j] = EntityIndex( ((edict_t **)pOutputData)[j] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+ecx*4], eax

; 722  : 					break;

	jmp	SHORT $LN13@WriteField
$LN25@WriteField:

; 723  : 					case FIELD_ENTITY:
; 724  : 						entityArray[j] = EntityIndex( ((EOFFSET *)pOutputData)[j] );

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pOutputData$2[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z ; CSaveRestoreBuffer::EntityIndex
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+edx*4], eax

; 725  : 					break;

	jmp	SHORT $LN13@WriteField
$LN26@WriteField:

; 726  : 					case FIELD_EHANDLE:
; 727  : 						entityArray[j] = EntityIndex( (CBaseEntity *)(((EHANDLE *)pOutputData)[j]) );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8]
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ; CSaveRestoreBuffer::EntityIndex
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _entityArray$[ebp+edx*4], eax
$LN13@WriteField:

; 728  : 					break;
; 729  : 				}
; 730  : 			}

	jmp	$LN10@WriteField
$LN11@WriteField:

; 731  : 			WriteInt( pTest->fieldName, entityArray, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _entityArray$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 732  : 			break;

	jmp	$LN8@WriteField
$LN27@WriteField:

; 733  : 		case FIELD_POSITION_VECTOR:
; 734  : 			WritePositionVector( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	edx, DWORD PTR _pTest$[ebp]
	movzx	eax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WritePositionVector@CSave@@QAEXPBDPBMH@Z ; CSave::WritePositionVector

; 735  : 			break;

	jmp	$LN8@WriteField
$LN28@WriteField:

; 736  : 		case FIELD_VECTOR:
; 737  : 			WriteVector( pTest->fieldName, (float *)pOutputData, pTest->fieldSize );

	mov	ecx, DWORD PTR _pTest$[ebp]
	movzx	edx, WORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pOutputData$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDPBMH@Z	; CSave::WriteVector

; 738  : 			break;

	jmp	$LN8@WriteField
$LN29@WriteField:

; 739  : 		case FIELD_BOOLEAN:
; 740  : 		case FIELD_INTEGER:
; 741  : 			WriteInt( pTest->fieldName, (int *)pOutputData, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pOutputData$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 742  : 			break;

	jmp	$LN8@WriteField
$LN30@WriteField:

; 743  : 		case FIELD_SHORT:
; 744  : 			WriteData( pTest->fieldName, 2 * pTest->fieldSize, ((char *)pOutputData) );

	mov	edx, DWORD PTR _pOutputData$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteData@CSave@@QAEXPBDH0@Z		; CSave::WriteData

; 745  : 			break;

	jmp	$LN8@WriteField
$LN31@WriteField:

; 746  : 		case FIELD_CHARACTER:
; 747  : 			WriteData( pTest->fieldName, pTest->fieldSize, ((char *)pOutputData) );

	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	movzx	eax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pTest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteData@CSave@@QAEXPBDH0@Z		; CSave::WriteData

; 748  : 			break;

	jmp	SHORT $LN8@WriteField
$LN32@WriteField:

; 749  : 		// For now, just write the address out, we're not going to change memory while doing this yet!
; 750  : 		case FIELD_POINTER:
; 751  : 			WriteInt( pTest->fieldName, (int *)(char *)pOutputData, pTest->fieldSize );

	mov	eax, DWORD PTR _pTest$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pOutputData$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pTest$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteInt@CSave@@QAEXPBDPBHH@Z		; CSave::WriteInt

; 752  : 			break;

	jmp	SHORT $LN8@WriteField
$LN33@WriteField:

; 753  : 		case FIELD_FUNCTION:
; 754  : 			WriteFunction( pMap, pTest->fieldName, (int *)(char *)pOutputData, pTest->fieldSize );

	mov	edx, DWORD PTR _pTest$[ebp]
	movzx	eax, WORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pOutputData$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTest$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pMap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z ; CSave::WriteFunction

; 755  : 			break;

	jmp	SHORT $LN8@WriteField
$LN34@WriteField:

; 756  : 		default:
; 757  : 			ALERT( at_error, "Bad field type\n" );

	push	OFFSET $SG75028
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN8@WriteField:

; 758  : 			break;
; 759  : 		}
; 760  : 	}

	jmp	$LN5@WriteField
$LN6@WriteField:

; 761  : 
; 762  : 	return 1;

	mov	eax, 1

; 763  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN36@WriteField:
	DD	$LN17@WriteField
	DD	$LN19@WriteField
	DD	$LN20@WriteField
	DD	$LN20@WriteField
	DD	$LN20@WriteField
	DD	$LN20@WriteField
	DD	$LN20@WriteField
	DD	$LN28@WriteField
	DD	$LN27@WriteField
	DD	$LN32@WriteField
	DD	$LN29@WriteField
	DD	$LN33@WriteField
	DD	$LN29@WriteField
	DD	$LN30@WriteField
	DD	$LN31@WriteField
	DD	$LN18@WriteField
	DD	$LN19@WriteField
	DD	$LN19@WriteField
$LN37@WriteField:
	DD	$LN25@WriteField
	DD	$LN23@WriteField
	DD	$LN26@WriteField
	DD	$LN22@WriteField
	DD	$LN24@WriteField
?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ENDP ; CSave::WriteFields
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_pMap$ = 12						; size = 4
_pev$ = 16						; size = 4
?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z PROC ; CSave::WriteEntVars
; _this$ = ecx

; 636  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	return WriteFields( pname, pev, pMap, gEntvarsDescription, ENTVARS_COUNT );

	push	94					; 0000005eH
	push	OFFSET ?gEntvarsDescription@@3PAUtypedescription_s@@A ; gEntvarsDescription
	mov	eax, DWORD PTR _pMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CSave::WriteFields

; 638  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ENDP ; CSave::WriteEntVars
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_functionName$ = -4					; size = 4
_pRootMap$ = 8						; size = 4
_pname$ = 12						; size = 4
_data$ = 16						; size = 4
_count$ = 20						; size = 4
?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z PROC	; CSave::WriteFunction
; _this$ = ecx

; 555  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 	const char *functionName = UTIL_FunctionToName( pRootMap, (void *)(*data) );

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pRootMap$[ebp]
	push	edx
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	mov	DWORD PTR _functionName$[ebp], eax

; 557  : 
; 558  : 	if ( functionName )

	cmp	DWORD PTR _functionName$[ebp], 0
	je	SHORT $LN2@WriteFunct

; 559  : 		BufferField( pname, strlen(functionName) + 1, functionName );

	mov	eax, DWORD PTR _functionName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _functionName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 560  : 	else

	jmp	SHORT $LN1@WriteFunct
$LN2@WriteFunct:

; 561  : 		ALERT( at_error, "Invalid function pointer in class %s!\n", pRootMap->dataClassName );

	mov	eax, DWORD PTR _pRootMap$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET $SG74902
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$LN1@WriteFunct:

; 562  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?WriteFunction@CSave@@QAEXPAUdatamap_s@@PBDPBHH@Z ENDP	; CSave::WriteFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
$T1 = -56						; size = 12
_input$ = -44						; size = 12
_tmp$ = -32						; size = 12
_tmp$2 = -20						; size = 12
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_value$ = 12						; size = 4
_count$ = 16						; size = 4
?WritePositionVector@CSave@@QAEXPBDPBMH@Z PROC		; CSave::WritePositionVector
; _this$ = ecx

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 538  : 	int i;
; 539  : 	Vector tmp, input;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _input$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 540  : 
; 541  : 	BufferHeader( pname, sizeof(float) * 3 * count );

	imul	eax, DWORD PTR _count$[ebp], 12
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 542  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@WritePosit
$LN2@WritePosit:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@WritePosit:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@WritePosit

; 543  : 	{
; 544  : 		Vector tmp( value[0], value[1], value[2] );

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _value$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _tmp$2[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 545  : 
; 546  : 		if ( m_pdata && m_pdata->fUseLandmark )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN5@WritePosit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+1324], 0
	je	SHORT $LN5@WritePosit

; 547  : 			tmp = tmp - m_pdata->vecLandmarkOffset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1348				; 00000544H
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmp$2[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$2[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$2[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _tmp$2[ebp+8], edx
$LN5@WritePosit:

; 548  : 
; 549  : 		BufferData( (const char *)&tmp.x, sizeof(float) * 3 );

	push	12					; 0000000cH
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 550  : 		value += 3;

	mov	ecx, DWORD PTR _value$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _value$[ebp], ecx

; 551  : 	}

	jmp	$LN2@WritePosit
$LN3@WritePosit:

; 552  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WritePositionVector@CSave@@QAEXPBDPBMH@Z ENDP		; CSave::WritePositionVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_tmp$1 = -16						; size = 12
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_value$ = 12						; size = 4
?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z PROC	; CSave::WritePositionVector
; _this$ = ecx

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 527  : 	if ( m_pdata && m_pdata->fUseLandmark )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN2@WritePosit
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+1324], 0
	je	SHORT $LN2@WritePosit

; 528  : 	{
; 529  : 		Vector tmp = value - m_pdata->vecLandmarkOffset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1348				; 00000544H
	push	ecx
	lea	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 530  : 		WriteVector( pname, tmp );

	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDABVVector@@@Z ; CSave::WriteVector
$LN2@WritePosit:

; 531  : 	}
; 532  : 
; 533  : 	WriteVector( pname, value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDABVVector@@@Z ; CSave::WriteVector

; 534  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?WritePositionVector@CSave@@QAEXPBDABVVector@@@Z ENDP	; CSave::WritePositionVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_value$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteVector@CSave@@QAEXPBDPBMH@Z PROC			; CSave::WriteVector
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	BufferHeader( pname, sizeof(float) * 3 * count );

	imul	eax, DWORD PTR _count$[ebp], 12
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 522  : 	BufferData( (const char *)value, sizeof(float) * 3 * count );

	imul	edx, DWORD PTR _count$[ebp], 12
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteVector@CSave@@QAEXPBDPBMH@Z ENDP			; CSave::WriteVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_value$ = 12						; size = 4
?WriteVector@CSave@@QAEXPBDABVVector@@@Z PROC		; CSave::WriteVector
; _this$ = ecx

; 515  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 	WriteVector( pname, &value.x, 1 );

	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteVector@CSave@@QAEXPBDPBMH@Z	; CSave::WriteVector

; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?WriteVector@CSave@@QAEXPBDABVVector@@@Z ENDP		; CSave::WriteVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pString$1 = -12					; size = 4
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_pname$ = 8						; size = 4
_stringId$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteString@CSave@@QAEXPBDPBHH@Z PROC			; CSave::WriteString
; _this$ = ecx

; 494  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 495  : 	int i, size;
; 496  : 
; 497  : #ifdef TOKENIZE
; 498  : 	short	token = (short)TokenHash( STRING( *stringId ) );
; 499  : 	WriteShort( pname, &token, 1 );
; 500  : #else
; 501  : 	size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 502  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@WriteStrin
$LN2@WriteStrin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@WriteStrin:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@WriteStrin

; 503  : 		size += strlen( STRING( stringId[i] ) ) + 1;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _stringId$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _size$[ebp], eax
	jmp	SHORT $LN2@WriteStrin
$LN3@WriteStrin:

; 504  : 
; 505  : 	BufferHeader( pname, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 506  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@WriteStrin
$LN5@WriteStrin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@WriteStrin:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@WriteStrin

; 507  : 	{
; 508  : 		const char *pString = STRING(stringId[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _stringId$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _pString$1[ebp], eax

; 509  : 		BufferData( pString, strlen(pString)+1 );

	mov	edx, DWORD PTR _pString$1[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	eax, DWORD PTR _pString$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 510  : 	}

	jmp	SHORT $LN5@WriteStrin
$LN1@WriteStrin:

; 511  : #endif
; 512  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteString@CSave@@QAEXPBDPBHH@Z ENDP			; CSave::WriteString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_pdata$ = 12						; size = 4
?WriteString@CSave@@QAEXPBD0@Z PROC			; CSave::WriteString
; _this$ = ecx

; 484  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 485  : #ifdef TOKENIZE
; 486  : 	short	token = (short)TokenHash( pdata );
; 487  : 	WriteShort( pname, &token, 1 );
; 488  : #else
; 489  : 	BufferField( pname, strlen(pdata) + 1, pdata );

	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 490  : #endif
; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?WriteString@CSave@@QAEXPBD0@Z ENDP			; CSave::WriteString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_size$ = 12						; size = 4
_pdata$ = 16						; size = 4
?WriteData@CSave@@QAEXPBDH0@Z PROC			; CSave::WriteData
; _this$ = ecx

; 444  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 	BufferField( pname, size, pdata );

	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 446  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteData@CSave@@QAEXPBDH0@Z ENDP			; CSave::WriteData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_input$ = -36						; size = 12
_tmp$ = -24						; size = 12
_tmp$1 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_data$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteTime@CSave@@QAEXPBDPBMH@Z PROC			; CSave::WriteTime
; _this$ = ecx

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 	int i;
; 466  : 	Vector tmp, input;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _input$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 467  : 
; 468  : 	BufferHeader( pname, sizeof(float) * count );

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferHeader@CSave@@AAEXPBDH@Z		; CSave::BufferHeader

; 469  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@WriteTime
$LN2@WriteTime:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@WriteTime:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@WriteTime

; 470  : 	{
; 471  : 		float tmp = data[0];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _tmp$1[ebp], xmm0

; 472  : 
; 473  : 		// Always encode time as a delta from the current time so it can be re-based if loaded in a new level
; 474  : 		// Times of 0 are never written to the file, so they will be restored as 0, not a relative time
; 475  : 		if ( m_pdata )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN5@WriteTime

; 476  : 			tmp -= m_pdata->time;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	movss	xmm0, DWORD PTR _tmp$1[ebp]
	subss	xmm0, DWORD PTR [eax+1360]
	movss	DWORD PTR _tmp$1[ebp], xmm0
$LN5@WriteTime:

; 477  : 
; 478  : 		BufferData( (const char *)&tmp, sizeof(float) );

	push	4
	lea	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferData@CSave@@AAEXPBDH@Z		; CSave::BufferData

; 479  : 		data ++;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 4
	mov	DWORD PTR _data$[ebp], edx

; 480  : 	}

	jmp	SHORT $LN2@WriteTime
$LN3@WriteTime:

; 481  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteTime@CSave@@QAEXPBDPBMH@Z ENDP			; CSave::WriteTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_data$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteFloat@CSave@@QAEXPBDPBMH@Z PROC			; CSave::WriteFloat
; _this$ = ecx

; 459  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 460  : 	BufferField( pname, sizeof(float) * count, (const char *)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 461  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteFloat@CSave@@QAEXPBDPBMH@Z ENDP			; CSave::WriteFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_data$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteInt@CSave@@QAEXPBDPBHH@Z PROC			; CSave::WriteInt
; _this$ = ecx

; 454  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 455  : 	BufferField( pname, sizeof(int) * count, (const char *)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteInt@CSave@@QAEXPBDPBHH@Z ENDP			; CSave::WriteInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_data$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteShort@CSave@@QAEXPBDPBFH@Z PROC			; CSave::WriteShort
; _this$ = ecx

; 449  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 	BufferField( pname, sizeof(short) * count, (const char *)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BufferField@CSave@@AAEXPBDH0@Z		; CSave::BufferField

; 451  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteShort@CSave@@QAEXPBDPBFH@Z ENDP			; CSave::WriteShort
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_status$1 = -4						; size = 4
_pLeafObject$ = 8					; size = 4
_pLeafMap$ = 12						; size = 4
_pCurMap$ = 16						; size = 4
?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z PROC	; CSave::DoWriteAll
; _this$ = ecx

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	// save base classes first
; 647  : 	if ( pCurMap->baseMap )

	mov	eax, DWORD PTR _pCurMap$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN2@DoWriteAll

; 648  : 	{
; 649  : 		int status = DoWriteAll( pLeafObject, pLeafMap, pCurMap->baseMap );

	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z ; CSave::DoWriteAll
	mov	DWORD PTR _status$1[ebp], eax

; 650  : 		if( !status )

	cmp	DWORD PTR _status$1[ebp], 0
	jne	SHORT $LN2@DoWriteAll

; 651  : 			return status;

	mov	eax, DWORD PTR _status$1[ebp]
	jmp	SHORT $LN1@DoWriteAll
$LN2@DoWriteAll:

; 652  : 	}
; 653  : 
; 654  : 	return WriteFields( pCurMap->dataClassName, pLeafObject, pLeafMap, pCurMap->dataDesc, pCurMap->dataNumFields );

	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pCurMap$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCurMap$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteFields@CSave@@QAEHPBDPBXPAUdatamap_s@@PAUtypedescription_s@@H@Z ; CSave::WriteFields
$LN1@DoWriteAll:

; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z ENDP	; CSave::DoWriteAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hash$ = -4						; size = 4
_pszToken$ = 8						; size = 4
?HashString@CSaveRestoreBuffer@@IAEIPBD@Z PROC		; CSaveRestoreBuffer::HashString
; _this$ = ecx

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 	unsigned int	hash = 0;

	mov	DWORD PTR _hash$[ebp], 0
$LN2@HashString:

; 295  : 
; 296  : 	while ( *pszToken )

	mov	eax, DWORD PTR _pszToken$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@HashString

; 297  : 		hash = _rotr( hash, 4 ) ^ *pszToken++;

	mov	edx, DWORD PTR _hash$[ebp]
	ror	edx, 4
	mov	eax, DWORD PTR _pszToken$[ebp]
	movsx	ecx, BYTE PTR [eax]
	xor	edx, ecx
	mov	DWORD PTR _hash$[ebp], edx
	mov	edx, DWORD PTR _pszToken$[ebp]
	add	edx, 1
	mov	DWORD PTR _pszToken$[ebp], edx
	jmp	SHORT $LN2@HashString
$LN3@HashString:

; 298  : 
; 299  : 	return hash;

	mov	eax, DWORD PTR _hash$[ebp]

; 300  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HashString@CSaveRestoreBuffer@@IAEIPBD@Z ENDP		; CSaveRestoreBuffer::HashString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z PROC		; CSaveRestoreBuffer::BufferRewind
; _this$ = ecx

; 259  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 	if ( !m_pdata )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN2@BufferRewi

; 261  : 		return;

	jmp	SHORT $LN1@BufferRewi
$LN2@BufferRewi:

; 262  : 
; 263  : 	if ( m_pdata->size < size )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN3@BufferRewi

; 264  : 		size = m_pdata->size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _size$[ebp], eax
$LN3@BufferRewi:

; 265  : 
; 266  : 	m_pdata->pCurrentData -= size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], eax

; 267  : 	m_pdata->size -= size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], edx
$LN1@BufferRewi:

; 268  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BufferRewind@CSaveRestoreBuffer@@IAEXH@Z ENDP		; CSaveRestoreBuffer::BufferRewind
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_i$1 = -16						; size = 4
_index$2 = -12						; size = 4
_this$ = -8						; size = 4
_hash$ = -4						; size = 2
_pszToken$ = 8						; size = 4
?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z PROC		; CSaveRestoreBuffer::TokenHash
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	unsigned short	hash = (unsigned short)(HashString( pszToken ) % (unsigned)m_pdata->tokenCount );

	mov	eax, DWORD PTR _pszToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HashString@CSaveRestoreBuffer@@IAEIPBD@Z ; CSaveRestoreBuffer::HashString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	xor	edx, edx
	div	DWORD PTR [ecx+20]
	mov	WORD PTR _hash$[ebp], dx

; 305  : 	
; 306  : #if _DEBUG
; 307  : 	static int tokensparsed = 0;
; 308  : 	tokensparsed++;

	mov	edx, DWORD PTR ?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA
	add	edx, 1
	mov	DWORD PTR ?tokensparsed@?1??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA, edx

; 309  : 	if ( !m_pdata->tokenCount || !m_pdata->pTokens )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN6@TokenHash
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@TokenHash
$LN6@TokenHash:

; 310  : 		ALERT( at_error, "No token table array in TokenHash()!" );

	push	OFFSET $SG74708
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN5@TokenHash:

; 311  : #endif
; 312  : 
; 313  : 	for ( int i=0; i<m_pdata->tokenCount; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@TokenHash
$LN2@TokenHash:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@TokenHash:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	$LN3@TokenHash

; 314  : 	{
; 315  : #if _DEBUG
; 316  : 		static qboolean beentheredonethat = FALSE;
; 317  : 		if ( i > 50 && !beentheredonethat )

	cmp	DWORD PTR _i$1[ebp], 50			; 00000032H
	jle	SHORT $LN7@TokenHash
	cmp	DWORD PTR ?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA, 0
	jne	SHORT $LN7@TokenHash

; 318  : 		{
; 319  : 			beentheredonethat = TRUE;

	mov	DWORD PTR ?beentheredonethat@?5??TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z@4HA, 1

; 320  : 			ALERT( at_error, "CSaveRestoreBuffer :: TokenHash() is getting too full!" );

	push	OFFSET $SG74710
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN7@TokenHash:

; 321  : 		}
; 322  : #endif
; 323  : 
; 324  : 		int	index = hash + i;

	movzx	edx, WORD PTR _hash$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _index$2[ebp], edx

; 325  : 		if ( index >= m_pdata->tokenCount )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$2[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jl	SHORT $LN8@TokenHash

; 326  : 			index -= m_pdata->tokenCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$2[ebp]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _index$2[ebp], edx
$LN8@TokenHash:

; 327  : 
; 328  : 		if ( !m_pdata->pTokens[index] || strcmp( pszToken, m_pdata->pTokens[index] ) == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _index$2[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN10@TokenHash
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _index$2[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _pszToken$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@TokenHash
$LN10@TokenHash:

; 329  : 		{
; 330  : 			m_pdata->pTokens[index] = (char *)pszToken;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _index$2[ebp]
	mov	edx, DWORD PTR _pszToken$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 331  : 			return index;

	mov	ax, WORD PTR _index$2[ebp]
	jmp	SHORT $LN1@TokenHash
$LN9@TokenHash:

; 332  : 		}
; 333  : 	}

	jmp	$LN2@TokenHash
$LN3@TokenHash:

; 334  : 		
; 335  : 	// Token hash table full!!! 
; 336  : 	// [Consider doing overflow table(s) after the main table & limiting linear hash table search]
; 337  : 	ALERT( at_error, "CSaveRestoreBuffer :: TokenHash() is COMPLETELY FULL!" );

	push	OFFSET $SG74714
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 338  : 	return 0;

	xor	eax, eax
$LN1@TokenHash:

; 339  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TokenHash@CSaveRestoreBuffer@@QAEGPBD@Z ENDP		; CSaveRestoreBuffer::TokenHash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_pTable$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_entityIndex$ = 8					; size = 4
?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z PROC ; CSaveRestoreBuffer::EntityFromIndex
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	if ( !m_pdata || entityIndex < 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@EntityFrom
	cmp	DWORD PTR _entityIndex$[ebp], 0
	jge	SHORT $LN5@EntityFrom
$LN6@EntityFrom:

; 232  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@EntityFrom
$LN5@EntityFrom:

; 233  : 
; 234  : 	int i;
; 235  : 	ENTITYTABLE *pTable;
; 236  : 
; 237  : 	for ( i = 0; i < m_pdata->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@EntityFrom
$LN2@EntityFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@EntityFrom:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN3@EntityFrom

; 238  : 	{
; 239  : 		pTable = m_pdata->pTable + i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	ecx, DWORD PTR _i$[ebp], 24
	add	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pTable$[ebp], ecx

; 240  : 		if ( pTable->id == entityIndex )

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _entityIndex$[ebp]
	jne	SHORT $LN7@EntityFrom

; 241  : 			return pTable->pent;

	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN1@EntityFrom
$LN7@EntityFrom:

; 242  : 	}

	jmp	SHORT $LN2@EntityFrom
$LN3@EntityFrom:

; 243  : 	return NULL;

	xor	eax, eax
$LN1@EntityFrom:

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EntityFromIndex@CSaveRestoreBuffer@@QAEPAUedict_s@@H@Z ENDP ; CSaveRestoreBuffer::EntityFromIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_entityIndex$ = 8					; size = 4
_flags$ = 12						; size = 4
?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z PROC	; CSaveRestoreBuffer::EntityFlagsSet
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 	if ( !m_pdata || entityIndex < 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@EntityFlag
	cmp	DWORD PTR _entityIndex$[ebp], 0
	jge	SHORT $LN2@EntityFlag
$LN3@EntityFlag:

; 249  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@EntityFlag
$LN2@EntityFlag:

; 250  : 	if ( entityIndex > m_pdata->tableCount )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _entityIndex$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jle	SHORT $LN4@EntityFlag

; 251  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@EntityFlag
$LN4@EntityFlag:

; 252  : 
; 253  : 	m_pdata->pTable[ entityIndex ].flags |= flags;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	eax, DWORD PTR _entityIndex$[ebp], 24
	mov	ecx, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [ecx+eax+16]
	or	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	eax, DWORD PTR _entityIndex$[ebp], 24
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [ecx+eax+16], edx

; 254  : 
; 255  : 	return m_pdata->pTable[ entityIndex ].flags;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	ecx, DWORD PTR _entityIndex$[ebp], 24
	mov	edx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx+ecx+16]
$LN1@EntityFlag:

; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?EntityFlagsSet@CSaveRestoreBuffer@@QAEHHH@Z ENDP	; CSaveRestoreBuffer::EntityFlagsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pEntity$ = 8						; size = 4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z PROC ; CSaveRestoreBuffer::EntityIndex
; _this$ = ecx

; 194  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 	if ( pEntity == NULL )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $LN2@EntityInde

; 196  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@EntityInde
$LN2@EntityInde:

; 197  : 	return EntityIndex( pEntity->pev );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ; CSaveRestoreBuffer::EntityIndex
$LN1@EntityInde:

; 198  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAVCBaseEntity@@@Z ENDP ; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eoLookup$ = 8						; size = 4
?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z PROC		; CSaveRestoreBuffer::EntityIndex
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 	return EntityIndex( ENT( eoLookup ) );

	mov	eax, DWORD PTR _eoLookup$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex

; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHH@Z ENDP		; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_pTable$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_pentLookup$ = 8					; size = 4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z PROC ; CSaveRestoreBuffer::EntityIndex
; _this$ = ecx

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	if ( !m_pdata || pentLookup == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@EntityInde
	cmp	DWORD PTR _pentLookup$[ebp], 0
	jne	SHORT $LN5@EntityInde
$LN6@EntityInde:

; 215  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@EntityInde
$LN5@EntityInde:

; 216  : 
; 217  : 	int i;
; 218  : 	ENTITYTABLE *pTable;
; 219  : 
; 220  : 	for ( i = 0; i < m_pdata->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@EntityInde
$LN2@EntityInde:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@EntityInde:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN3@EntityInde

; 221  : 	{
; 222  : 		pTable = m_pdata->pTable + i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	ecx, DWORD PTR _i$[ebp], 24
	add	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pTable$[ebp], ecx

; 223  : 		if ( pTable->pent == pentLookup )

	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _pentLookup$[ebp]
	jne	SHORT $LN7@EntityInde

; 224  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@EntityInde
$LN7@EntityInde:

; 225  : 	}

	jmp	SHORT $LN2@EntityInde
$LN3@EntityInde:

; 226  : 	return -1;

	or	eax, -1
$LN1@EntityInde:

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ENDP ; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pevLookup$ = 8						; size = 4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z PROC ; CSaveRestoreBuffer::EntityIndex
; _this$ = ecx

; 201  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	if ( pevLookup == NULL )

	cmp	DWORD PTR _pevLookup$[ebp], 0
	jne	SHORT $LN2@EntityInde

; 203  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@EntityInde
$LN2@EntityInde:

; 204  : 	return EntityIndex( ENT( pevLookup ) );

	mov	eax, DWORD PTR _pevLookup$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityIndex@CSaveRestoreBuffer@@QAEHPAUedict_s@@@Z ; CSaveRestoreBuffer::EntityIndex
$LN1@EntityInde:

; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EntityIndex@CSaveRestoreBuffer@@QAEHPAUentvars_s@@@Z ENDP ; CSaveRestoreBuffer::EntityIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSaveRestoreBuffer@@QAE@XZ PROC			; CSaveRestoreBuffer::~CSaveRestoreBuffer
; _this$ = ecx

; 190  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CSaveRestoreBuffer@@QAE@XZ ENDP			; CSaveRestoreBuffer::~CSaveRestoreBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pdata$ = 8						; size = 4
??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z PROC	; CSaveRestoreBuffer::CSaveRestoreBuffer
; _this$ = ecx

; 185  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 186  : 	m_pdata = pdata;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pdata$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 187  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CSaveRestoreBuffer@@QAE@PAUsaverestore_s@@@Z ENDP	; CSaveRestoreBuffer::CSaveRestoreBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\saverestore.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSaveRestoreBuffer@@QAE@XZ PROC			; CSaveRestoreBuffer::CSaveRestoreBuffer
; _this$ = ecx

; 180  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 181  : 	m_pdata = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 182  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSaveRestoreBuffer@@QAE@XZ ENDP			; CSaveRestoreBuffer::CSaveRestoreBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
_sz1$ = 8						; size = 4
_sz2$ = 12						; size = 4
?FStrEq@@YAHPBD0@Z PROC					; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@FStrEq
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@FStrEq
$LN3@FStrEq:
	mov	DWORD PTR tv69[ebp], 0
$LN4@FStrEq:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_iString$ = 8						; size = 4
?FStringNull@@YAHH@Z PROC				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	push	ecx
	cmp	DWORD PTR _iString$[ebp], 0
	jne	SHORT $LN3@FStringNul
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@FStringNul
$LN3@FStringNul:
	mov	DWORD PTR tv65[ebp], 0
$LN4@FStringNul:
	mov	eax, DWORD PTR tv65[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8						; size = 4
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $LN2@VARS

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@VARS
$LN2@VARS:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$LN1@VARS:

; 183  : }

	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8						; size = 4
?OFFSET@@YAHPBUedict_s@@@Z PROC				; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $LN2@OFFSET

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET ??_C@_0BF@CPEPILID@Bad?5ent?5in?5OFFSET?$CI?$CJ?6@
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$LN2@OFFSET:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8						; size = 4
?ENT@@YAPAUedict_s@@H@Z PROC				; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\util.h
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8						; size = 4
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\enginecallback.h
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8						; size = 4
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC			; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN2@GET_PRIVAT

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $LN1@GET_PRIVAT
$LN2@GET_PRIVAT:

; 104  : 	return NULL;

	xor	eax, eax
$LN1@GET_PRIVAT:

; 105  : }

	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
