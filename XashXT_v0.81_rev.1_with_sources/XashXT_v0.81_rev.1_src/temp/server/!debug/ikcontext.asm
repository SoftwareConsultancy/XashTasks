; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\game_shared\ikcontext.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG17308 DB	'^2Warning:^7 AutoIKRelease (%s) out of range bone %d (%d'
	DB	')', 0aH, 00H
	ORG $+1
$SG17309 DB	'^2Warning:^7 AutoIKRelease (%s) got a NULL pchain %d', 0aH
	DB	00H
	ORG $+2
$SG18092 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG18095 DB	'0', 00H, 00H, 00H
$SG17310 DB	'^2Warning:^7 AutoIKRelease (%s) got an out of range chai'
	DB	'n %d (%d)', 0aH, 00H
	ORG $+1
$SG18101 DB	'0', 00H, 00H, 00H
$SG17790 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG17791 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG17828 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG18105 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG17829 DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')'
	DB	00H, 00H, 00H
$SG17867 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG17868 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG17984 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG18107 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG17985 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
$SG18293 DB	'0', 00H, 00H, 00H
$SG18091 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18094 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18100 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18104 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18106 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18168 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG18299 DB	'0', 00H, 00H, 00H
$SG18169 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
$SG18303 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG18206 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG18305 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG18207 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
	ORG $+4
$SG18289 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18290 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG18292 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18298 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18302 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG18304 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	?Init@Vector@@QAEXMMM@Z				; Vector::Init
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??ZVector@@QAEAAV0@ABV0@@Z			; Vector::operator-=
PUBLIC	??XVector@@QAEAAV0@M@Z				; Vector::operator*=
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?LengthSqr@Vector@@QBEMXZ			; Vector::LengthSqr
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	?Init@Vector4D@@QAEXMMMM@Z			; Vector4D::Init
PUBLIC	??0matrix3x4@@QAE@ABVVector@@0M@Z		; matrix3x4::matrix3x4
PUBLIC	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z	; matrix3x4::matrix3x4
PUBLIC	??Amatrix3x4@@QAEPAMH@Z				; matrix3x4::operator[]
PUBLIC	?GetRight@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetRight
PUBLIC	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetOrigin
PUBLIC	?SetForward@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetForward
PUBLIC	?SetRight@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetRight
PUBLIC	?SetUp@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetUp
PUBLIC	??0matrix3x4@@QAE@ABV0@@Z			; matrix3x4::matrix3x4
PUBLIC	?SimpleSpline@@YAMM@Z				; SimpleSpline
PUBLIC	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
PUBLIC	?pIKAutoplayLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@H@Z ; CStudioBoneSetup::pIKAutoplayLock
PUBLIC	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
PUBLIC	?pIKLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@PBUmstudioseqdesc_t@@H@Z ; CStudioBoneSetup::pIKLock
PUBLIC	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ	; CStudioBoneSetup::GetNumIKChains
PUBLIC	?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ	; CStudioBoneSetup::GetNumIKAutoplayLocks
PUBLIC	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z		; CStudioBoneSetup::IsBoneUsed
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	?SetOwner@CIKTarget@@QAEXHABVVector@@0@Z	; CIKTarget::SetOwner
PUBLIC	?ClearOwner@CIKTarget@@QAEXXZ			; CIKTarget::ClearOwner
PUBLIC	?GetOwner@CIKTarget@@QAEHXZ			; CIKTarget::GetOwner
PUBLIC	?UpdateOwner@CIKTarget@@QAEXHABVVector@@0@Z	; CIKTarget::UpdateOwner
PUBLIC	?SetPos@CIKTarget@@QAEXABVVector@@@Z		; CIKTarget::SetPos
PUBLIC	?SetAngles@CIKTarget@@QAEXABVVector@@@Z		; CIKTarget::SetAngles
PUBLIC	?SetQuaternion@CIKTarget@@QAEXABVVector4D@@@Z	; CIKTarget::SetQuaternion
PUBLIC	?SetNormal@CIKTarget@@QAEXABVVector@@@Z		; CIKTarget::SetNormal
PUBLIC	?SetPosWithNormalOffset@CIKTarget@@QAEXABVVector@@0@Z ; CIKTarget::SetPosWithNormalOffset
PUBLIC	?SetOnWorld@CIKTarget@@QAEX_N@Z			; CIKTarget::SetOnWorld
PUBLIC	?IsActive@CIKTarget@@QAE_NXZ			; CIKTarget::IsActive
PUBLIC	?IKFailed@CIKTarget@@QAEXXZ			; CIKTarget::IKFailed
PUBLIC	?MoveReferenceFrame@CIKTarget@@QAEXAAVVector@@0@Z ; CIKTarget::MoveReferenceFrame
PUBLIC	??0x2@CIKTarget@@QAE@XZ				; CIKTarget::x2::x2
PUBLIC	??0x3@CIKTarget@@QAE@XZ				; CIKTarget::x3::x3
PUBLIC	??0x4@CIKTarget@@QAE@XZ				; CIKTarget::x4::x4
PUBLIC	??0x5@CIKTarget@@QAE@XZ				; CIKTarget::x5::x5
PUBLIC	??0x1@CIKTarget@@QAE@XZ				; CIKTarget::x1::x1
PUBLIC	??0CIKTarget@@QAE@XZ				; CIKTarget::CIKTarget
PUBLIC	??0ikchainresult_t@@QAE@XZ			; ikchainresult_t::ikchainresult_t
PUBLIC	??0ikcontextikrule_t@@QAE@XZ			; ikcontextikrule_t::ikcontextikrule_t
PUBLIC	??0CIKContext@@QAE@XZ				; CIKContext::CIKContext
PUBLIC	?Init@CIKContext@@QAEXPBVCStudioBoneSetup@@ABVVector@@1MH@Z ; CIKContext::Init
PUBLIC	?AddDependencies@CIKContext@@QAEXPAUmstudioseqdesc_t@@HMM@Z ; CIKContext::AddDependencies
PUBLIC	?ClearTargets@CIKContext@@QAEXXZ		; CIKContext::ClearTargets
PUBLIC	?UpdateTargets@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::UpdateTargets
PUBLIC	?AutoIKRelease@CIKContext@@QAEXXZ		; CIKContext::AutoIKRelease
PUBLIC	?SolveDependencies@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::SolveDependencies
PUBLIC	?AddAutoplayLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ; CIKContext::AddAutoplayLocks
PUBLIC	?SolveAutoplayLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ; CIKContext::SolveAutoplayLocks
PUBLIC	?AddSequenceLocks@CIKContext@@QAEXPAUmstudioseqdesc_t@@QAVVector@@QAVVector4D@@@Z ; CIKContext::AddSequenceLocks
PUBLIC	?SolveSequenceLocks@CIKContext@@QAEXPAUmstudioseqdesc_t@@QAVVector@@QAVVector4D@@@Z ; CIKContext::SolveSequenceLocks
PUBLIC	?AddAllLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ; CIKContext::AddAllLocks
PUBLIC	?SolveAllLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ; CIKContext::SolveAllLocks
PUBLIC	?SolveLock@CIKContext@@QAEXPBUmstudioiklock_t@@HQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::SolveLock
PUBLIC	??0?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@HH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
PUBLIC	??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
PUBLIC	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
PUBLIC	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
PUBLIC	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
PUBLIC	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
PUBLIC	?IsValidIndex@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBE_NH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::IsValidIndex
PUBLIC	?AddMultipleToTail@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHPBVCIKTarget@@@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::AddMultipleToTail
PUBLIC	?InsertMultipleBefore@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHHPBVCIKTarget@@@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::InsertMultipleBefore
PUBLIC	?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize
PUBLIC	?SetCount@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetCount
PUBLIC	?EnsureCapacity@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::EnsureCapacity
PUBLIC	?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll
PUBLIC	?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge
PUBLIC	?GrowVector@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXHH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ShiftElementsRight
PUBLIC	??0?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAE@HH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::CUtlMemoryFixed<CIKTarget,12,0>
PUBLIC	?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid
PUBLIC	?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ; CUtlMemoryFixed<CIKTarget,12,0>::Base
PUBLIC	??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]
PUBLIC	?NumAllocated@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBEHXZ ; CUtlMemoryFixed<CIKTarget,12,0>::NumAllocated
PUBLIC	?Grow@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::Grow
PUBLIC	?EnsureCapacity@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::EnsureCapacity
PUBLIC	?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ ; CUtlMemoryFixed<CIKTarget,12,0>::Purge
PUBLIC	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo
PUBLIC	??0?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@HH@Z	; CUtlArrayFixed<CIKTarget,12>::CUtlArrayFixed<CIKTarget,12>
PUBLIC	??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ	; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>
PUBLIC	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain
PUBLIC	??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
PUBLIC	??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
PUBLIC	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
PUBLIC	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
PUBLIC	?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count
PUBLIC	?IsValidIndex@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBE_NH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::IsValidIndex
PUBLIC	?AddMultipleToTail@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::AddMultipleToTail
PUBLIC	?InsertMultipleBefore@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::InsertMultipleBefore
PUBLIC	?SetSize@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetSize
PUBLIC	?SetCount@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetCount
PUBLIC	?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge
PUBLIC	?GrowVector@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXHH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ShiftElementsRight
PUBLIC	??0?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@HH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
PUBLIC	??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
PUBLIC	??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[]
PUBLIC	?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid
PUBLIC	?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base
PUBLIC	?NumAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBEHXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Grow
PUBLIC	?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
PUBLIC	?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
PUBLIC	?ValidateGrowSize@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@IAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::ValidateGrowSize
PUBLIC	?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo
PUBLIC	??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
PUBLIC	??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
PUBLIC	??4?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAV0@ABV0@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator=
PUBLIC	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
PUBLIC	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEABUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
PUBLIC	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
PUBLIC	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
PUBLIC	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
PUBLIC	?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::IsValidIndex
PUBLIC	?AddToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddToTail
PUBLIC	?InsertBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertBefore
PUBLIC	?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail
PUBLIC	?InsertMultipleBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertMultipleBefore
PUBLIC	?SetSize@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetSize
PUBLIC	?SetCount@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetCount
PUBLIC	?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge
PUBLIC	?GrowVector@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXHH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ShiftElementsRight
PUBLIC	??0?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@HH@Z	; CUtlMemory<ikcontextikrule_t,int>::CUtlMemory<ikcontextikrule_t,int>
PUBLIC	??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ	; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
PUBLIC	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]
PUBLIC	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QBEABUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]
PUBLIC	?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
PUBLIC	?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ ; CUtlMemory<ikcontextikrule_t,int>::Base
PUBLIC	?NumAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBEHXZ ; CUtlMemory<ikcontextikrule_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXH@Z ; CUtlMemory<ikcontextikrule_t,int>::Grow
PUBLIC	?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::Purge
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
PUBLIC	?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
PUBLIC	?ValidateGrowSize@?$CUtlMemory@Uikcontextikrule_t@@H@@IAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::ValidateGrowSize
PUBLIC	?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo
PUBLIC	??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor'
PUBLIC	??$Lerp@VVector@@@@YA?AVVector@@MABV0@0@Z	; Lerp<Vector>
PUBLIC	??$Lerp@M@@YAMMABM0@Z				; Lerp<float>
PUBLIC	??$AlignValue@PAD@@YAPADPADI@Z			; AlignValue<char *>
PUBLIC	??$Destruct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ; Destruct<ikcontextikrule_t>
PUBLIC	??$Destruct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; Destruct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >
PUBLIC	??$Construct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ; Construct<ikcontextikrule_t>
PUBLIC	??$Destruct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z	; Destruct<CIKTarget>
PUBLIC	??$Construct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z	; Construct<CIKTarget>
PUBLIC	??$Construct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; Construct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >
PUBLIC	?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A	; CIKContext::m_boneToWorld
PUBLIC	??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ ; `string'
PUBLIC	??_C@_1LK@CNNNCGDG@?$AA?$CI?$AAB?$AAa?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ ; `string'
PUBLIC	??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ ; `string'
PUBLIC	??_C@_1BI@LFLBADNE@?$AAn?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE@ ; `string'
PUBLIC	??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EI@DONNOGGM@?$AAn?$AAI?$AAn?$AAi?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5@ ; `string'
PUBLIC	??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1FA@BPFBJKPF@?$AA?$CI?$AAe?$AAl?$AAe?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f34fdf4
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f733333
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f7fbe77
PUBLIC	__real@3f7ff972
PUBLIC	__real@3f800000
PUBLIC	__real@3f91df46a2529d39
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fe69fbe76c8b439
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff028f5c0000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	??0matrix3x4@@QAE@XZ:PROC			; matrix3x4::matrix3x4
EXTRN	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ:PROC ; matrix3x4::GetQuaternion
EXTRN	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z:PROC ; matrix3x4::VectorRotate
EXTRN	?Invert@matrix3x4@@QBE?AV1@XZ:PROC		; matrix3x4::Invert
EXTRN	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z:PROC	; matrix3x4::ConcatTransforms
EXTRN	?AngleQuaternion@@YAXABVVector@@AAVVector4D@@@Z:PROC ; AngleQuaternion
EXTRN	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z:PROC ; QuaternionSlerp
EXTRN	?QuaternionSM@@YAXMABVVector4D@@0AAV1@@Z:PROC	; QuaternionSM
EXTRN	?QuaternionMA@@YAXABVVector4D@@M0AAV1@@Z:PROC	; QuaternionMA
EXTRN	?QuaternionScale@@YAXABVVector4D@@MAAV1@@Z:PROC	; QuaternionScale
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	?BuildBoneChain@CStudioBoneSetup@@AAEXABVmatrix3x4@@QBVVector@@QBVVector4D@@HPAV2@PAE@Z:PROC ; CStudioBoneSetup::BuildBoneChain
EXTRN	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z:PROC ; CStudioBoneSetup::SolveBone
EXTRN	?SolveIK@CStudioBoneSetup@@AAE_NPBUmstudioikchain_t@@AAVVector@@PAVmatrix3x4@@@Z:PROC ; CStudioBoneSetup::SolveIK
EXTRN	?SolveIK@CStudioBoneSetup@@AAE_NHHHAAVVector@@00PAVmatrix3x4@@@Z:PROC ; CStudioBoneSetup::SolveIK
EXTRN	?IKSequenceError@CStudioBoneSetup@@AAE_NHMHQAPAUmstudioanimdesc_t@@QAMPAUikcontextikrule_t@@@Z:PROC ; CStudioBoneSetup::IKSequenceError
EXTRN	?LocalSeqAnims@CStudioBoneSetup@@QAEXHQAPAUmstudioanimdesc_t@@PAM@Z:PROC ; CStudioBoneSetup::LocalSeqAnims
EXTRN	?LocalCPS@CStudioBoneSetup@@QAEMH@Z:PROC	; CStudioBoneSetup::LocalCPS
EXTRN	__wassert:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A DB 01800H DUP (?) ; CIKContext::m_boneToWorld
_BSS	ENDS
CRT$XCU	SEGMENT
??m_boneToWorld$initializer$@CIKContext@@0P6AXXZA@@3P6AXXZA DD FLAT:??__E?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A@@YAXXZ ; ??m_boneToWorld$initializer$@CIKContext@@0P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff028f5c0000000
CONST	SEGMENT
__real@3ff028f5c0000000 DQ 03ff028f5c0000000r	; 1.01
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe69fbe76c8b439
CONST	SEGMENT
__real@3fe69fbe76c8b439 DQ 03fe69fbe76c8b439r	; 0.707
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3f91df46a2529d39
CONST	SEGMENT
__real@3f91df46a2529d39 DQ 03f91df46a2529d39r	; 0.0174533
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
CONST	ENDS
;	COMDAT __real@3f7fbe77
CONST	SEGMENT
__real@3f7fbe77 DD 03f7fbe77r			; 0.999
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f34fdf4
CONST	SEGMENT
__real@3f34fdf4 DD 03f34fdf4r			; 0.707
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@BPFBJKPF@?$AA?$CI?$AAe?$AAl?$AAe?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI@
CONST	SEGMENT
??_C@_1FA@BPFBJKPF@?$AA?$CI?$AAe?$AAl?$AAe?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI@ DB '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't'
	DB	00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H
	DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@ DB '!'
	DB	00H, 'I', 00H, 's', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H
	DB	'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H, '(', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@DONNOGGM@?$AAn?$AAI?$AAn?$AAi?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5@
CONST	SEGMENT
??_C@_1EI@DONNOGGM@?$AAn?$AAI?$AAn?$AAi?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'S', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'n', 00H, 'I', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'I', 00H
	DB	'Z', 00H, 'E', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@ DB 'I'
	DB	00H, 's', 00H, 'I', 00H, 'd', 00H, 'x', 00H, 'V', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, '(', 00H, 'i', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@LFLBADNE@?$AAn?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE@
CONST	SEGMENT
??_C@_1BI@LFLBADNE@?$AAn?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
CONST	SEGMENT
??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's'
	DB	00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H
	DB	'.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v'
	DB	00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H, '.'
	DB	00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\'
	DB	00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'u'
	DB	00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LK@CNNNCGDG@?$AA?$CI?$AAB?$AAa?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
CONST	SEGMENT
??_C@_1LK@CNNNCGDG@?$AA?$CI?$AAB?$AAa?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ DB '('
	DB	00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H
	DB	'!', 00H, 'p', 00H, 'T', 00H, 'o', 00H, 'C', 00H, 'o', 00H, 'p'
	DB	00H, 'y', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '(', 00H
	DB	'p', 00H, 'T', 00H, 'o', 00H, 'C', 00H, 'o', 00H, 'p', 00H, 'y'
	DB	00H, ' ', 00H, '+', 00H, ' ', 00H, 'n', 00H, 'u', 00H, 'm', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, 'p', 00H, 'T', 00H, 'o', 00H, 'C', 00H, 'o'
	DB	00H, 'p', 00H, 'y', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'(', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, '+', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H
	DB	'n', 00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
CONST	SEGMENT
??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's'
	DB	00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H
	DB	'.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v'
	DB	00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H, '.'
	DB	00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\'
	DB	00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'u'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'a', 00H
	DB	'y', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z$0
__ehfuncinfo$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z$0
__ehfuncinfo$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$??0CIKContext@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CIKContext@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CIKContext@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CIKContext@@QAE@XZ$2
__ehfuncinfo$??0CIKContext@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CIKContext@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Construct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pMemory$ = 8						; size = 4
??$Construct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z PROC ; Construct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	20					; 00000014H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >

; 39   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Construct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ENDP ; Construct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Construct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pMemory$ = 8						; size = 4
??$Construct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z PROC	; Construct<CIKTarget>, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	336					; 00000150H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0CIKTarget@@QAE@XZ

; 39   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Construct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z ENDP	; Construct<CIKTarget>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Destruct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z
_TEXT	SEGMENT
_pMemory$ = 8						; size = 4
??$Destruct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z PROC	; Destruct<CIKTarget>, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	336					; 00000150H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	ebp
	ret	0
??$Destruct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z ENDP	; Destruct<CIKTarget>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Construct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pMemory$ = 8						; size = 4
??$Construct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z PROC ; Construct<ikcontextikrule_t>, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 38   : 	new( pMemory ) T;

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	132					; 00000084H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0ikcontextikrule_t@@QAE@XZ		; ikcontextikrule_t::ikcontextikrule_t

; 39   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Construct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ENDP ; Construct<ikcontextikrule_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Destruct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z
_TEXT	SEGMENT
_pMemory$ = 8						; size = 4
??$Destruct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z PROC ; Destruct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	pMemory->~T();

	push	0
	mov	ecx, DWORD PTR _pMemory$[ebp]
	call	??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z

; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	20					; 00000014H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	ebp
	ret	0
??$Destruct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ENDP ; Destruct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$Destruct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z
_TEXT	SEGMENT
_pMemory$ = 8						; size = 4
??$Destruct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z PROC ; Destruct<ikcontextikrule_t>, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	132					; 00000084H
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	ebp
	ret	0
??$Destruct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ENDP ; Destruct<ikcontextikrule_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$AlignValue@PAD@@YAPADPADI@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
_alignment$ = 12					; size = 4
??$AlignValue@PAD@@YAPADPADI@Z PROC			; AlignValue<char *>, COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp

; 28   : 	return (T)( ( (unsigned int)val + alignment - 1 ) & ~( alignment - 1 ) );

	mov	eax, DWORD PTR _alignment$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	edx, DWORD PTR _alignment$[ebp]
	sub	edx, 1
	not	edx
	and	eax, edx

; 29   : }

	pop	ebp
	ret	0
??$AlignValue@PAD@@YAPADPADI@Z ENDP			; AlignValue<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\mathlib.h
;	COMDAT ??$Lerp@M@@YAMMABM0@Z
_TEXT	SEGMENT
tv73 = -4						; size = 4
_flPercent$ = 8						; size = 4
_A$ = 12						; size = 4
_B$ = 16						; size = 4
??$Lerp@M@@YAMMABM0@Z PROC				; Lerp<float>, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 110  : 	return A + (B - A) * flPercent;

	mov	eax, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _A$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _flPercent$[ebp]
	mov	edx, DWORD PTR _A$[ebp]
	addss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]

; 111  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Lerp@M@@YAMMABM0@Z ENDP				; Lerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\mathlib.h
;	COMDAT ??$Lerp@VVector@@@@YA?AVVector@@MABV0@0@Z
_TEXT	SEGMENT
$T1 = -24						; size = 12
$T2 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_flPercent$ = 12					; size = 4
_A$ = 16						; size = 4
_B$ = 20						; size = 4
??$Lerp@VVector@@@@YA?AVVector@@MABV0@0@Z PROC		; Lerp<Vector>, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 110  : 	return A + (B - A) * flPercent;

	push	ecx
	movss	xmm0, DWORD PTR _flPercent$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _A$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _B$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _A$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Lerp@VVector@@@@YA?AVVector@@MABV0@0@Z ENDP		; Lerp<Vector>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
;	COMDAT ??__E?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A@@YAXXZ
text$di	SEGMENT
??__E?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A@@YAXXZ PROC ; `dynamic initializer for 'CIKContext::m_boneToWorld'', COMDAT

; 25   : matrix3x4 CIKContext :: m_boneToWorld[MAXSTUDIOBONES];

	push	ebp
	mov	ebp, esp
	push	OFFSET ??0matrix3x4@@QAE@XZ		; matrix3x4::matrix3x4
	push	128					; 00000080H
	push	48					; 00000030H
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	pop	ebp
	ret	0
??__E?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A@@YAXXZ ENDP ; `dynamic initializer for 'CIKContext::m_boneToWorld''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAXI@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@Uikcontextikrule_t@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ValidateGrowSize@?$CUtlMemory@Uikcontextikrule_t@@H@@IAEXXZ PROC ; CUtlMemory<ikcontextikrule_t,int>::ValidateGrowSize, COMDAT
; _this$ = ecx

; 148  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@Uikcontextikrule_t@@H@@IAEXXZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::ValidateGrowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ PROC ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly, COMDAT
; _this$ = ecx

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	jne	SHORT $LN3@IsReadOnly
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsReadOnly
$LN3@IsReadOnly:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsReadOnly:
	mov	al, BYTE PTR tv66[ebp]

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ PROC ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jge	SHORT $LN3@IsExternal
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsExternal
$LN3@IsExternal:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsExternal:
	mov	al, BYTE PTR tv66[ebp]

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ PROC	; CUtlMemory<ikcontextikrule_t,int>::Purge, COMDAT
; _this$ = ecx

; 645  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@Purge

; 647  : 	{
; 648  : 		if (m_pMemory)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Purge

; 649  : 		{
; 650  : 			free( (void*)m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@Purge:

; 652  : 		}
; 653  : 		m_nAllocationCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN1@Purge:

; 654  : 	}
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ENDP	; CUtlMemory<ikcontextikrule_t,int>::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Grow@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXH@Z
_TEXT	SEGMENT
_nAllocationRequested$ = -8				; size = 4
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?Grow@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXH@Z PROC	; CUtlMemory<ikcontextikrule_t,int>::Grow, COMDAT
; _this$ = ecx

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $LN12@Grow
	push	561					; 00000231H
	push	OFFSET $SG18091
	push	OFFSET $SG18092
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@Grow:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsExternallyAllocated
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Grow

; 564  : 	{
; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	edx, edx
	jne	SHORT $LN13@Grow
	push	566					; 00000236H
	push	OFFSET $SG18094
	push	OFFSET $SG18095
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@Grow:

; 567  : 		return;

	jmp	$LN1@Grow
$LN4@Grow:

; 568  : 	}
; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], edx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	132					; 00000084H
	mov	eax, DWORD PTR _nAllocationRequested$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $LN5@Grow

; 578  : 	{
; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN6@Grow
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $LN6@Grow

; 580  : 		{
; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 582  : 		}
; 583  : 		else

	jmp	SHORT $LN5@Grow
$LN6@Grow:

; 584  : 		{
; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $LN2@Grow

; 586  : 			{
; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	eax, eax
	jne	SHORT $LN14@Grow
	push	588					; 0000024cH
	push	OFFSET $SG18100
	push	OFFSET $SG18101
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Grow:

; 589  : 				return;

	jmp	$LN1@Grow
$LN2@Grow:

; 590  : 			}
; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $LN5@Grow

; 592  : 			{
; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 594  : 			}

	jmp	SHORT $LN2@Grow
$LN5@Grow:

; 595  : 		}
; 596  : 	}
; 597  : 
; 598  : 	if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@Grow

; 599  : 	{
; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [ecx+4], 132
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 601  : 		assert( m_pMemory );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN15@Grow
	push	601					; 00000259H
	push	OFFSET $SG18104
	push	OFFSET $SG18105
	call	__wassert
	add	esp, 12					; 0000000cH
$LN15@Grow:

; 602  : 	}
; 603  : 	else

	jmp	SHORT $LN1@Grow
$LN9@Grow:

; 604  : 	{
; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+4], 132
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@Grow
	push	606					; 0000025eH
	push	OFFSET $SG18106
	push	OFFSET $SG18107
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@Grow:

; 607  : 	}
; 608  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXH@Z ENDP	; CUtlMemory<ikcontextikrule_t,int>::Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?NumAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBEHXZ PROC ; CUtlMemory<ikcontextikrule_t,int>::NumAllocated, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBEHXZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::NumAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ PROC ; CUtlMemory<ikcontextikrule_t,int>::Base, COMDAT
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Base
	push	488					; 000001e8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Base:

; 489  : 	return m_pMemory;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 490  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ ENDP ; CUtlMemory<ikcontextikrule_t,int>::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z PROC ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid, COMDAT
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsIdxValid
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN3@IsIdxValid
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsIdxValid
$LN3@IsIdxValid:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsIdxValid:
	mov	al, BYTE PTR tv67[ebp]

; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ENDP ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemory@Uikcontextikrule_t@@H@@QBEABUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemory@Uikcontextikrule_t@@H@@QBEABUikcontextikrule_t@@H@Z PROC ; CUtlMemory<ikcontextikrule_t,int>::operator[], COMDAT
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	push	432					; 000001b0H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 433  : 	return m_pMemory[i];

	imul	eax, DWORD PTR _i$[ebp], 132
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@Uikcontextikrule_t@@H@@QBEABUikcontextikrule_t@@H@Z ENDP ; CUtlMemory<ikcontextikrule_t,int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z PROC ; CUtlMemory<ikcontextikrule_t,int>::operator[], COMDAT
; _this$ = ecx

; 423  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NXZ ; CUtlMemory<ikcontextikrule_t,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	push	424					; 000001a8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 425  : 	assert( IsIdxValid(i) );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@Uikcontextikrule_t@@H@@QBE_NH@Z ; CUtlMemory<ikcontextikrule_t,int>::IsIdxValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	push	425					; 000001a9H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@operator:

; 426  : 	return m_pMemory[i];

	imul	eax, DWORD PTR _i$[ebp], 132
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ENDP ; CUtlMemory<ikcontextikrule_t,int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ PROC	; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>, COMDAT
; _this$ = ecx

; 322  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::Purge

; 324  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ ENDP	; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??0?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nGrowSize$ = 8						; size = 4
_nInitAllocationCount$ = 12				; size = 4
??0?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@HH@Z PROC	; CUtlMemory<ikcontextikrule_t,int>::CUtlMemory<ikcontextikrule_t,int>, COMDAT
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 293  : CUtlMemory<T,I>::CUtlMemory( int nGrowSize, int nInitAllocationCount ) : m_pMemory(0), 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 294  : 	m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@Uikcontextikrule_t@@H@@IAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $LN4@CUtlMemory
	push	297					; 00000129H
	push	OFFSET $SG17790
	push	OFFSET $SG17791
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@CUtlMemory:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@CUtlMemory

; 299  : 	{
; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [ecx+4], 132
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@CUtlMemory:

; 301  : 	}
; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@HH@Z ENDP	; CUtlMemory<ikcontextikrule_t,int>::CUtlMemory<ikcontextikrule_t,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ShiftElementsRight@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_numToMove$ = -8					; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_num$ = 12						; size = 4
?ShiftElementsRight@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXHH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ShiftElementsRight, COMDAT
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@ShiftEleme
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN4@ShiftEleme
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $LN4@ShiftEleme
	push	448					; 000001c0H
	push	OFFSET $SG17984
	push	OFFSET $SG17985
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ShiftEleme:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR _elem$[ebp]
	sub	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], edx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $LN1@ShiftEleme
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $LN1@ShiftEleme

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	imul	eax, DWORD PTR _numToMove$[ebp], 132
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	push	eax
	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$LN1@ShiftEleme:

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXHH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ShiftElementsRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?GrowVector@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?GrowVector@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::GrowVector, COMDAT
; _this$ = ecx

; 374  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBEHXZ ; CUtlMemory<ikcontextikrule_t,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $LN2@GrowVector

; 376  : 	{
; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@Uikcontextikrule_t@@H@@QBEHXZ ; CUtlMemory<ikcontextikrule_t,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXH@Z ; CUtlMemory<ikcontextikrule_t,int>::Grow
$LN2@GrowVector:

; 378  : 	}
; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo

; 382  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::GrowVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEXXZ ; CUtlMemory<ikcontextikrule_t,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
	mov	edx, DWORD PTR _i$1[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
	js	SHORT $LN3@RemoveAll

; 728  : 	{
; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	push	eax
	call	??$Destruct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ; Destruct<ikcontextikrule_t>
	add	esp, 4

; 730  : 	}

	jmp	SHORT $LN4@RemoveAll
$LN3@RemoveAll:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?SetCount@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?SetCount@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetCount, COMDAT
; _this$ = ecx

; 574  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll

; 576  : 	AddMultipleToTail( count );

	push	0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail

; 577  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCount@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?SetSize@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetSize@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetSize, COMDAT
; _this$ = ecx

; 581  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 	SetCount( size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCount@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetCount

; 583  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?InsertMultipleBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHHPBUikcontextikrule_t@@@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_num$ = 12						; size = 4
_pToInsert$ = 16					; size = 4
?InsertMultipleBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHHPBUikcontextikrule_t@@@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertMultipleBefore, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	if( num == 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jne	SHORT $LN8@InsertMult

; 629  : 		return elem;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	$LN1@InsertMult
$LN8@InsertMult:

; 630  : 	
; 631  : 	// Can insert at the end
; 632  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $LN11@InsertMult
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@InsertMult
	push	632					; 00000278H
	push	OFFSET ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1FA@BPFBJKPF@?$AA?$CI?$AAe?$AAl?$AAe?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@InsertMult:

; 633  : 
; 634  : 	GrowVector(num);

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::GrowVector

; 635  : 	ShiftElementsRight(elem, num);

	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXHH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ShiftElementsRight

; 636  : 
; 637  : 	// Invoke default constructors
; 638  : 	for (int i = 0; i < num; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@InsertMult
$LN2@InsertMult:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@InsertMult:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jge	SHORT $LN3@InsertMult

; 639  : 		Construct( &Element(elem+i) );

	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	push	eax
	call	??$Construct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ; Construct<ikcontextikrule_t>
	add	esp, 4
	jmp	SHORT $LN2@InsertMult
$LN3@InsertMult:

; 640  : 
; 641  : 	// Copy stuff in?
; 642  : 	if ( pToInsert )

	cmp	DWORD PTR _pToInsert$[ebp], 0
	je	SHORT $LN9@InsertMult

; 643  : 	{
; 644  : 		for ( int i=0; i < num; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@InsertMult
$LN5@InsertMult:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@InsertMult:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jge	SHORT $LN9@InsertMult

; 645  : 		{
; 646  : 			Element( elem+i ) = pToInsert[i];

	imul	esi, DWORD PTR _i$2[ebp], 132
	add	esi, DWORD PTR _pToInsert$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	mov	ecx, 33					; 00000021H
	mov	edi, eax
	rep movsd

; 647  : 		}

	jmp	SHORT $LN5@InsertMult
$LN9@InsertMult:

; 648  : 	}
; 649  : 
; 650  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]
$LN1@InsertMult:

; 651  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsertMultipleBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHHPBUikcontextikrule_t@@@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertMultipleBefore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_pToCopy$ = 12						; size = 4
?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail, COMDAT
; _this$ = ecx

; 558  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 	// Can't insert something that's in the list... reallocation may hose us
; 560  : 	assert( (Base() == NULL) || !pToCopy || (pToCopy + num < Base()) || (pToCopy >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
	test	eax, eax
	je	SHORT $LN3@AddMultipl
	cmp	DWORD PTR _pToCopy$[ebp], 0
	je	SHORT $LN3@AddMultipl
	imul	esi, DWORD PTR _num$[ebp], 132
	add	esi, DWORD PTR _pToCopy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
	cmp	esi, eax
	jb	SHORT $LN3@AddMultipl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	imul	eax, eax, 132
	add	esi, eax
	cmp	DWORD PTR _pToCopy$[ebp], esi
	jae	SHORT $LN3@AddMultipl
	push	560					; 00000230H
	push	OFFSET ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1LK@CNNNCGDG@?$AA?$CI?$AAB?$AAa?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@AddMultipl:

; 561  : 
; 562  : 	return InsertMultipleBefore( m_Size, num, pToCopy );

	mov	edx, DWORD PTR _pToCopy$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertMultipleBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertMultipleBefore

; 563  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?InsertBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?InsertBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertBefore, COMDAT
; _this$ = ecx

; 493  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 494  : 	// Can insert at the end
; 495  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $LN3@InsertBefo
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@InsertBefo
	push	495					; 000001efH
	push	OFFSET $SG17828
	push	OFFSET $SG17829
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@InsertBefo:

; 496  : 
; 497  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::GrowVector

; 498  : 	ShiftElementsRight(elem);

	push	1
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXHH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ShiftElementsRight

; 499  : 	Construct( &Element(elem) );

	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	push	eax
	call	??$Construct@Uikcontextikrule_t@@@@YAXPAUikcontextikrule_t@@@Z ; Construct<ikcontextikrule_t>
	add	esp, 4

; 500  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 501  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?InsertBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertBefore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?AddToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AddToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHXZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddToTail, COMDAT
; _this$ = ecx

; 481  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	return InsertBefore( m_Size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::InsertBefore

; 483  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddToTail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::IsValidIndex, COMDAT
; _this$ = ecx

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsValidInd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN3@IsValidInd
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsValidInd
$LN3@IsValidInd:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsValidInd:
	mov	al, BYTE PTR tv67[ebp]

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBE_NH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::IsValidIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count, COMDAT
; _this$ = ecx

; 344  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base, COMDAT
; _this$ = ecx

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@Uikcontextikrule_t@@H@@QAEPAUikcontextikrule_t@@XZ ; CUtlMemory<ikcontextikrule_t,int>::Base
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEPAUikcontextikrule_t@@XZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEABUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEABUikcontextikrule_t@@H@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[], COMDAT
; _this$ = ecx

; 288  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 289  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QBEABUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]

; 290  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEABUikcontextikrule_t@@H@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[], COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@Uikcontextikrule_t@@H@@QAEAAUikcontextikrule_t@@H@Z ; CUtlMemory<ikcontextikrule_t,int>::operator[]

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??4?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_nCount$ = -12						; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_other$ = 8						; size = 4
??4?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAV0@ABV0@@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator=, COMDAT
; _this$ = ecx

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 	int nCount = other.Count();

	mov	ecx, DWORD PTR _other$[ebp]
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	mov	DWORD PTR _nCount$[ebp], eax

; 268  : 	SetSize( nCount );

	mov	eax, DWORD PTR _nCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::SetSize

; 269  : 	for ( int i = 0; i < nCount; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@operator:
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR _nCount$[ebp]
	jge	SHORT $LN3@operator

; 270  : 	{
; 271  : 		(*this)[ i ] = other[ i ];

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _other$[ebp]
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEABUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	mov	ecx, 33					; 00000021H
	mov	edi, eax
	rep movsd

; 272  : 	}

	jmp	SHORT $LN2@operator
$LN3@operator:

; 273  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAV0@ABV0@@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Purge

; 262  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ ; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_growSize$ = 8						; size = 4
_initSize$ = 12						; size = 4
??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z PROC ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	m_Memory(growSize, initSize), m_Size(0)

	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@HH@Z ; CUtlMemory<ikcontextikrule_t,int>::CUtlMemory<ikcontextikrule_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@IAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CUtlMemory@Uikcontextikrule_t@@H@@QAE@XZ ; CUtlMemory<ikcontextikrule_t,int>::~CUtlMemory<ikcontextikrule_t,int>
__ehhandler$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z ENDP ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ValidateGrowSize@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@IAEXXZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::ValidateGrowSize, COMDAT
; _this$ = ecx

; 148  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@IAEXXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::ValidateGrowSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly, COMDAT
; _this$ = ecx

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	jne	SHORT $LN3@IsReadOnly
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsReadOnly
$LN3@IsReadOnly:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsReadOnly:
	mov	al, BYTE PTR tv66[ebp]

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jge	SHORT $LN3@IsExternal
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsExternal
$LN3@IsExternal:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsExternal:
	mov	al, BYTE PTR tv66[ebp]

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge, COMDAT
; _this$ = ecx

; 645  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@Purge

; 647  : 	{
; 648  : 		if (m_pMemory)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Purge

; 649  : 		{
; 650  : 			free( (void*)m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@Purge:

; 652  : 		}
; 653  : 		m_nAllocationCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN1@Purge:

; 654  : 	}
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Grow@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXH@Z
_TEXT	SEGMENT
_nAllocationRequested$ = -8				; size = 4
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?Grow@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXH@Z PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Grow, COMDAT
; _this$ = ecx

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $LN12@Grow
	push	561					; 00000231H
	push	OFFSET $SG18289
	push	OFFSET $SG18290
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@Grow:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsExternallyAllocated
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Grow

; 564  : 	{
; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	edx, edx
	jne	SHORT $LN13@Grow
	push	566					; 00000236H
	push	OFFSET $SG18292
	push	OFFSET $SG18293
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@Grow:

; 567  : 		return;

	jmp	$LN1@Grow
$LN4@Grow:

; 568  : 	}
; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], edx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	20					; 00000014H
	mov	eax, DWORD PTR _nAllocationRequested$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $LN5@Grow

; 578  : 	{
; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN6@Grow
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $LN6@Grow

; 580  : 		{
; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 582  : 		}
; 583  : 		else

	jmp	SHORT $LN5@Grow
$LN6@Grow:

; 584  : 		{
; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $LN2@Grow

; 586  : 			{
; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	eax, eax
	jne	SHORT $LN14@Grow
	push	588					; 0000024cH
	push	OFFSET $SG18298
	push	OFFSET $SG18299
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Grow:

; 589  : 				return;

	jmp	$LN1@Grow
$LN2@Grow:

; 590  : 			}
; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $LN5@Grow

; 592  : 			{
; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 594  : 			}

	jmp	SHORT $LN2@Grow
$LN5@Grow:

; 595  : 		}
; 596  : 	}
; 597  : 
; 598  : 	if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@Grow

; 599  : 	{
; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [ecx+4], 20
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 601  : 		assert( m_pMemory );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN15@Grow
	push	601					; 00000259H
	push	OFFSET $SG18302
	push	OFFSET $SG18303
	call	__wassert
	add	esp, 12					; 0000000cH
$LN15@Grow:

; 602  : 	}
; 603  : 	else

	jmp	SHORT $LN1@Grow
$LN9@Grow:

; 604  : 	{
; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+4], 20
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@Grow
	push	606					; 0000025eH
	push	OFFSET $SG18304
	push	OFFSET $SG18305
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@Grow:

; 607  : 	}
; 608  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?NumAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBEHXZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::NumAllocated, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::NumAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base, COMDAT
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Base
	push	488					; 000001e8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Base:

; 489  : 	return m_pMemory;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 490  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid, COMDAT
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsIdxValid
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN3@IsIdxValid
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsIdxValid
$LN3@IsIdxValid:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsIdxValid:
	mov	al, BYTE PTR tv67[ebp]

; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[], COMDAT
; _this$ = ecx

; 423  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	push	424					; 000001a8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 425  : 	assert( IsIdxValid(i) );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBE_NH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::IsIdxValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	push	425					; 000001a9H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@operator:

; 426  : 	return m_pMemory[i];

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>, COMDAT
; _this$ = ecx

; 322  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge

; 324  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??0?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nGrowSize$ = 8						; size = 4
_nInitAllocationCount$ = 12				; size = 4
??0?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@HH@Z PROC ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>, COMDAT
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 293  : CUtlMemory<T,I>::CUtlMemory( int nGrowSize, int nInitAllocationCount ) : m_pMemory(0), 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 294  : 	m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@IAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $LN4@CUtlMemory
	push	297					; 00000129H
	push	OFFSET $SG17867
	push	OFFSET $SG17868
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@CUtlMemory:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@CUtlMemory

; 299  : 	{
; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [ecx+4], 20
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@CUtlMemory:

; 301  : 	}
; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@HH@Z ENDP ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ShiftElementsRight@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_numToMove$ = -8					; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_num$ = 12						; size = 4
?ShiftElementsRight@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXHH@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ShiftElementsRight, COMDAT
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBE_NH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@ShiftEleme
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN4@ShiftEleme
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $LN4@ShiftEleme
	push	448					; 000001c0H
	push	OFFSET $SG18206
	push	OFFSET $SG18207
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ShiftEleme:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR _elem$[ebp]
	sub	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], edx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $LN1@ShiftEleme
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $LN1@ShiftEleme

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	imul	eax, DWORD PTR _numToMove$[ebp], 20
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	push	eax
	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$LN1@ShiftEleme:

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXHH@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ShiftElementsRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?GrowVector@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?GrowVector@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXH@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::GrowVector, COMDAT
; _this$ = ecx

; 374  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBEHXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $LN2@GrowVector

; 376  : 	{
; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QBEHXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Grow
$LN2@GrowVector:

; 378  : 	}
; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo

; 382  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXH@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::GrowVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEXXZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
	mov	edx, DWORD PTR _i$1[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
	js	SHORT $LN3@RemoveAll

; 728  : 	{
; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	push	eax
	call	??$Destruct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; Destruct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >
	add	esp, 4

; 730  : 	}

	jmp	SHORT $LN4@RemoveAll
$LN3@RemoveAll:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?SetCount@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?SetCount@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetCount, COMDAT
; _this$ = ecx

; 574  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll

; 576  : 	AddMultipleToTail( count );

	push	0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMultipleToTail@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::AddMultipleToTail

; 577  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCount@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?SetSize@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetSize@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetSize, COMDAT
; _this$ = ecx

; 581  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 	SetCount( size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCount@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetCount

; 583  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?InsertMultipleBefore@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_num$ = 12						; size = 4
_pToInsert$ = 16					; size = 4
?InsertMultipleBefore@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::InsertMultipleBefore, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	if( num == 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jne	SHORT $LN8@InsertMult

; 629  : 		return elem;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	$LN1@InsertMult
$LN8@InsertMult:

; 630  : 	
; 631  : 	// Can insert at the end
; 632  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $LN11@InsertMult
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBE_NH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@InsertMult
	push	632					; 00000278H
	push	OFFSET ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1FA@BPFBJKPF@?$AA?$CI?$AAe?$AAl?$AAe?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@InsertMult:

; 633  : 
; 634  : 	GrowVector(num);

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::GrowVector

; 635  : 	ShiftElementsRight(elem, num);

	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXHH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ShiftElementsRight

; 636  : 
; 637  : 	// Invoke default constructors
; 638  : 	for (int i = 0; i < num; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@InsertMult
$LN2@InsertMult:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@InsertMult:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jge	SHORT $LN3@InsertMult

; 639  : 		Construct( &Element(elem+i) );

	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	push	eax
	call	??$Construct@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@@YAXPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; Construct<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> > >
	add	esp, 4
	jmp	SHORT $LN2@InsertMult
$LN3@InsertMult:

; 640  : 
; 641  : 	// Copy stuff in?
; 642  : 	if ( pToInsert )

	cmp	DWORD PTR _pToInsert$[ebp], 0
	je	SHORT $LN9@InsertMult

; 643  : 	{
; 644  : 		for ( int i=0; i < num; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@InsertMult
$LN5@InsertMult:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@InsertMult:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jge	SHORT $LN9@InsertMult

; 645  : 		{
; 646  : 			Element( elem+i ) = pToInsert[i];

	imul	edx, DWORD PTR _i$2[ebp], 20
	add	edx, DWORD PTR _pToInsert$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	add	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	??4?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAV0@ABV0@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator=

; 647  : 		}

	jmp	SHORT $LN5@InsertMult
$LN9@InsertMult:

; 648  : 	}
; 649  : 
; 650  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]
$LN1@InsertMult:

; 651  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsertMultipleBefore@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::InsertMultipleBefore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?AddMultipleToTail@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_pToCopy$ = 12						; size = 4
?AddMultipleToTail@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::AddMultipleToTail, COMDAT
; _this$ = ecx

; 558  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 	// Can't insert something that's in the list... reallocation may hose us
; 560  : 	assert( (Base() == NULL) || !pToCopy || (pToCopy + num < Base()) || (pToCopy >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
	test	eax, eax
	je	SHORT $LN3@AddMultipl
	cmp	DWORD PTR _pToCopy$[ebp], 0
	je	SHORT $LN3@AddMultipl
	imul	esi, DWORD PTR _num$[ebp], 20
	add	esi, DWORD PTR _pToCopy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
	cmp	esi, eax
	jb	SHORT $LN3@AddMultipl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count
	imul	eax, eax, 20
	add	esi, eax
	cmp	DWORD PTR _pToCopy$[ebp], esi
	jae	SHORT $LN3@AddMultipl
	push	560					; 00000230H
	push	OFFSET ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1LK@CNNNCGDG@?$AA?$CI?$AAB?$AAa?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@AddMultipl:

; 561  : 
; 562  : 	return InsertMultipleBefore( m_Size, num, pToCopy );

	mov	edx, DWORD PTR _pToCopy$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertMultipleBefore@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::InsertMultipleBefore

; 563  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddMultipleToTail@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEHHPBV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::AddMultipleToTail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?IsValidIndex@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsValidIndex@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBE_NH@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::IsValidIndex, COMDAT
; _this$ = ecx

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsValidInd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN3@IsValidInd
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsValidInd
$LN3@IsValidInd:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsValidInd:
	mov	al, BYTE PTR tv67[ebp]

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBE_NH@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::IsValidIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count, COMDAT
; _this$ = ecx

; 344  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base, COMDAT
; _this$ = ecx

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::Base
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEPAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@XZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::operator[]

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Purge

; 262  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_growSize$ = 8						; size = 4
_initSize$ = 12						; size = 4
??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z PROC ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	m_Memory(growSize, initSize), m_Size(0)

	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@HH@Z ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@IAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@QAE@XZ ; CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>::~CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int>
__ehhandler$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z ENDP ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
_iBone$ = 16						; size = 4
_pBoneToWorld$ = 20					; size = 4
_pBoneSet$ = 24						; size = 4
?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z PROC ; CIKContext::BuildBoneChain
; _this$ = ecx

; 257  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 258  : 	m_pBoneSetup->BuildBoneChain( m_rootxform, pos, q, iBone, pBoneToWorld, pBoneSet );

	mov	eax, DWORD PTR _pBoneSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBone$[ebp]
	push	edx
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4084				; 00000ff4H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?BuildBoneChain@CStudioBoneSetup@@AAEXABVmatrix3x4@@QBVVector@@QBVVector4D@@HPAV2@PAE@Z ; CStudioBoneSetup::BuildBoneChain

; 259  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ENDP ; CIKContext::BuildBoneChain
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ PROC	; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ ENDP	; CUtlArrayFixed<CIKTarget,12>::~CUtlArrayFixed<CIKTarget,12>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??0?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_growSize$ = 8						; size = 4
_initSize$ = 12						; size = 4
??0?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@HH@Z PROC	; CUtlArrayFixed<CIKTarget,12>::CUtlArrayFixed<CIKTarget,12>, COMDAT
; _this$ = ecx

; 204  : 	CUtlArrayFixed( int growSize = 0, int initSize = 0 ) : BaseClass( growSize, initSize ) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@HH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@HH@Z ENDP	; CUtlArrayFixed<CIKTarget,12>::CUtlArrayFixed<CIKTarget,12>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4036], eax

; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ PROC ; CUtlMemoryFixed<CIKTarget,12,0>::Purge, COMDAT
; _this$ = ecx

; 258  : 	void Purge()											{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?EnsureCapacity@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?EnsureCapacity@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z PROC ; CUtlMemoryFixed<CIKTarget,12,0>::EnsureCapacity, COMDAT
; _this$ = ecx

; 255  : 	void EnsureCapacity( int num )							{ assert( num <= SIZE ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _num$[ebp], 12		; 0000000cH
	jbe	SHORT $LN1@EnsureCapa
	push	255					; 000000ffH
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BI@LFLBADNE@?$AAn?$AAu?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAI?$AAZ?$AAE@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@EnsureCapa:
	mov	esp, ebp
	pop	ebp
	ret	4
?EnsureCapacity@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::EnsureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Grow@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?Grow@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z PROC ; CUtlMemoryFixed<CIKTarget,12,0>::Grow, COMDAT
; _this$ = ecx

; 252  : 	void Grow( int num = 1 )								{ assert( 0 ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	jne	SHORT $LN1@Grow
	push	252					; 000000fcH
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_13COJANIEC@?$AA0@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@Grow:
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?NumAllocated@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumAllocated@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBEHXZ PROC ; CUtlMemoryFixed<CIKTarget,12,0>::NumAllocated, COMDAT
; _this$ = ecx

; 248  : 	int NumAllocated() const								{ return SIZE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBEHXZ ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::NumAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z PROC ; CUtlMemoryFixed<CIKTarget,12,0>::operator[], COMDAT
; _this$ = ecx

; 239  : 	T& operator[]( int i )									{ assert( IsIdxValid(i) ); return Base()[i];	}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	push	239					; 000000efH
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ; CUtlMemoryFixed<CIKTarget,12,0>::Base
	imul	ecx, DWORD PTR _i$[ebp], 336
	add	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ PROC ; CUtlMemoryFixed<CIKTarget,12,0>::Base, COMDAT
; _this$ = ecx

; 235  : 	T* Base()												{ if ( nAlignment == 0 ) return (T*)(&m_Memory[0]); else return (T*)AlignValue( &m_Memory[0], nAlignment ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Base
	mov	ecx, 1
	imul	eax, ecx, 0
	add	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@Base
	jmp	SHORT $LN1@Base
$LN2@Base:
	push	0
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$AlignValue@PAD@@YAPADPADI@Z		; AlignValue<char *>
	add	esp, 8
$LN1@Base:
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_i$ = 8							; size = 4
?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z PROC ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid, COMDAT
; _this$ = ecx

; 231  : 	bool IsIdxValid( int i ) const							{ return (i >= 0) && (i < SIZE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsIdxValid
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jae	SHORT $LN3@IsIdxValid
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsIdxValid
$LN3@IsIdxValid:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsIdxValid:
	mov	al, BYTE PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBE_NH@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::IsIdxValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??0?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nGrowSize$ = 8						; size = 4
_nInitSize$ = 12					; size = 4
??0?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAE@HH@Z PROC ; CUtlMemoryFixed<CIKTarget,12,0>::CUtlMemoryFixed<CIKTarget,12,0>, COMDAT
; _this$ = ecx

; 227  : 	CUtlMemoryFixed( int nGrowSize = 0, int nInitSize = 0 )	{ assert( nInitSize == 0 || nInitSize == SIZE ); 	}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nInitSize$[ebp], 0
	je	SHORT $LN1@CUtlMemory
	cmp	DWORD PTR _nInitSize$[ebp], 12		; 0000000cH
	je	SHORT $LN1@CUtlMemory
	push	227					; 000000e3H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1EI@DONNOGGM@?$AAn?$AAI?$AAn?$AAi?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@CUtlMemory:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAE@HH@Z ENDP ; CUtlMemoryFixed<CIKTarget,12,0>::CUtlMemoryFixed<CIKTarget,12,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?ShiftElementsRight@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXHH@Z
_TEXT	SEGMENT
_numToMove$ = -8					; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_num$ = 12						; size = 4
?ShiftElementsRight@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXHH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ShiftElementsRight, COMDAT
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBE_NH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@ShiftEleme
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4032], 0
	je	SHORT $LN4@ShiftEleme
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $LN4@ShiftEleme
	push	448					; 000001c0H
	push	OFFSET $SG18168
	push	OFFSET $SG18169
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ShiftEleme:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4032]
	sub	edx, DWORD PTR _elem$[ebp]
	sub	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], edx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $LN1@ShiftEleme
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $LN1@ShiftEleme

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	imul	eax, DWORD PTR _numToMove$[ebp], 336
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
	push	eax
	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$LN1@ShiftEleme:

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXHH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ShiftElementsRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?GrowVector@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?GrowVector@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::GrowVector, COMDAT
; _this$ = ecx

; 374  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4032]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBEHXZ ; CUtlMemoryFixed<CIKTarget,12,0>::NumAllocated
	cmp	esi, eax
	jle	SHORT $LN2@GrowVector

; 376  : 	{
; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+4032]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QBEHXZ ; CUtlMemoryFixed<CIKTarget,12,0>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::Grow
$LN2@GrowVector:

; 378  : 	}
; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4032]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4032], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo

; 382  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::GrowVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXXZ ; CUtlMemoryFixed<CIKTarget,12,0>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo

; 746  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4032]
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
	mov	edx, DWORD PTR _i$1[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
	js	SHORT $LN3@RemoveAll

; 728  : 	{
; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
	push	eax
	call	??$Destruct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z ; Destruct<CIKTarget>
	add	esp, 4

; 730  : 	}

	jmp	SHORT $LN4@RemoveAll
$LN3@RemoveAll:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4032], 0

; 733  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?EnsureCapacity@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?EnsureCapacity@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::EnsureCapacity, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 426  : 	m_Memory.EnsureCapacity(num);

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnsureCapacity@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEXH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::EnsureCapacity

; 427  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo

; 428  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EnsureCapacity@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::EnsureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?SetCount@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?SetCount@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetCount, COMDAT
; _this$ = ecx

; 574  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::RemoveAll

; 576  : 	AddMultipleToTail( count );

	push	0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMultipleToTail@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHPBVCIKTarget@@@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::AddMultipleToTail

; 577  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCount@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize, COMDAT
; _this$ = ecx

; 581  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 	SetCount( size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCount@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetCount

; 583  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?InsertMultipleBefore@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHHPBVCIKTarget@@@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_num$ = 12						; size = 4
_pToInsert$ = 16					; size = 4
?InsertMultipleBefore@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHHPBVCIKTarget@@@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::InsertMultipleBefore, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	if( num == 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jne	SHORT $LN8@InsertMult

; 629  : 		return elem;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	$LN1@InsertMult
$LN8@InsertMult:

; 630  : 	
; 631  : 	// Can insert at the end
; 632  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $LN11@InsertMult
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBE_NH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@InsertMult
	push	632					; 00000278H
	push	OFFSET ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1FA@BPFBJKPF@?$AA?$CI?$AAe?$AAl?$AAe?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$CI@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@InsertMult:

; 633  : 
; 634  : 	GrowVector(num);

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::GrowVector

; 635  : 	ShiftElementsRight(elem, num);

	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXHH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ShiftElementsRight

; 636  : 
; 637  : 	// Invoke default constructors
; 638  : 	for (int i = 0; i < num; ++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@InsertMult
$LN2@InsertMult:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@InsertMult:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jge	SHORT $LN3@InsertMult

; 639  : 		Construct( &Element(elem+i) );

	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
	push	eax
	call	??$Construct@VCIKTarget@@@@YAXPAVCIKTarget@@@Z ; Construct<CIKTarget>
	add	esp, 4
	jmp	SHORT $LN2@InsertMult
$LN3@InsertMult:

; 640  : 
; 641  : 	// Copy stuff in?
; 642  : 	if ( pToInsert )

	cmp	DWORD PTR _pToInsert$[ebp], 0
	je	SHORT $LN9@InsertMult

; 643  : 	{
; 644  : 		for ( int i=0; i < num; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@InsertMult
$LN5@InsertMult:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@InsertMult:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jge	SHORT $LN9@InsertMult

; 645  : 		{
; 646  : 			Element( elem+i ) = pToInsert[i];

	imul	esi, DWORD PTR _i$2[ebp], 336
	add	esi, DWORD PTR _pToInsert$[ebp]
	mov	edx, DWORD PTR _elem$[ebp]
	add	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
	mov	ecx, 84					; 00000054H
	mov	edi, eax
	rep movsd

; 647  : 		}

	jmp	SHORT $LN5@InsertMult
$LN9@InsertMult:

; 648  : 	}
; 649  : 
; 650  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]
$LN1@InsertMult:

; 651  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsertMultipleBefore@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHHPBVCIKTarget@@@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::InsertMultipleBefore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?AddMultipleToTail@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHPBVCIKTarget@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_pToCopy$ = 12						; size = 4
?AddMultipleToTail@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHPBVCIKTarget@@@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::AddMultipleToTail, COMDAT
; _this$ = ecx

; 558  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 	// Can't insert something that's in the list... reallocation may hose us
; 560  : 	assert( (Base() == NULL) || !pToCopy || (pToCopy + num < Base()) || (pToCopy >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	test	eax, eax
	je	SHORT $LN3@AddMultipl
	cmp	DWORD PTR _pToCopy$[ebp], 0
	je	SHORT $LN3@AddMultipl
	imul	esi, DWORD PTR _num$[ebp], 336
	add	esi, DWORD PTR _pToCopy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	cmp	esi, eax
	jb	SHORT $LN3@AddMultipl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	imul	eax, eax, 336
	add	esi, eax
	cmp	DWORD PTR _pToCopy$[ebp], esi
	jae	SHORT $LN3@AddMultipl
	push	560					; 00000230H
	push	OFFSET ??_C@_1MM@POBCBGGF@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1LK@CNNNCGDG@?$AA?$CI?$AAB?$AAa?$AAs?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@AddMultipl:

; 561  : 
; 562  : 	return InsertMultipleBefore( m_Size, num, pToCopy );

	mov	edx, DWORD PTR _pToCopy$[ebp]
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4032]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertMultipleBefore@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHHPBVCIKTarget@@@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::InsertMultipleBefore

; 563  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?AddMultipleToTail@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEHHPBVCIKTarget@@@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::AddMultipleToTail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?IsValidIndex@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsValidIndex@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBE_NH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::IsValidIndex, COMDAT
; _this$ = ecx

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsValidInd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4032]
	jge	SHORT $LN3@IsValidInd
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsValidInd
$LN3@IsValidInd:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsValidInd:
	mov	al, BYTE PTR tv67[ebp]

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBE_NH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::IsValidIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count, COMDAT
; _this$ = ecx

; 344  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4032]

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base, COMDAT
; _this$ = ecx

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEPAVCIKTarget@@XZ ; CUtlMemoryFixed<CIKTarget,12,0>::Base
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Element
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[], COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAEAAVCIKTarget@@H@Z ; CUtlMemoryFixed<CIKTarget,12,0>::operator[]

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Purge

; 262  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@XZ ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::~CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlarray.h
;	COMDAT ??0?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_growSize$ = 8						; size = 4
_initSize$ = 12						; size = 4
??0?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@HH@Z PROC ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	m_Memory(growSize, initSize), m_Size(0)

	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@QAE@HH@Z ; CUtlMemoryFixed<CIKTarget,12,0>::CUtlMemoryFixed<CIKTarget,12,0>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4032], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@IAEXXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::ResetDbgInfo

; 249  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAE@HH@Z ENDP ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_q3$ = -204						; size = 16
$T1 = -188						; size = 12
$T2 = -176						; size = 12
$T3 = -164						; size = 12
$T4 = -152						; size = 12
$T5 = -140						; size = 12
_p2$ = -128						; size = 12
_q2$ = -116						; size = 16
_p1$ = -100						; size = 12
tv309 = -88						; size = 4
_bone0$ = -84						; size = 4
_bone1$ = -80						; size = 4
_p3$ = -76						; size = 12
_pchain$ = -64						; size = 4
_bone2$ = -60						; size = 4
_this$ = -56						; size = 4
$T6 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_plock$ = 8						; size = 4
_i$ = 12						; size = 4
_pos$ = 16						; size = 4
_q$ = 20						; size = 4
_boneToWorld$ = 24					; size = 4
_pBoneSet$ = 28						; size = 4
?SolveLock@CIKContext@@QAEXPBUmstudioiklock_t@@HQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z PROC ; CIKContext::SolveLock
; _this$ = ecx

; 863  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 864  : 	const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( plock->chain );

	mov	eax, DWORD PTR _plock$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$[ebp], eax

; 865  : 	int bone0 = m_pBoneSetup->pIKLink( pchain, 0 )->bone;

	push	0
	mov	eax, DWORD PTR _pchain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone0$[ebp], edx

; 866  : 	int bone1 = m_pBoneSetup->pIKLink( pchain, 1 )->bone;

	push	1
	mov	eax, DWORD PTR _pchain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone1$[ebp], edx

; 867  : 	int bone2 = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	eax, DWORD PTR _pchain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone2$[ebp], edx

; 868  : 
; 869  : 	// don't bother with iklock if the bone isn't going to be calculated
; 870  : 	if( !m_pBoneSetup->IsBoneUsed( bone2 ))

	mov	eax, DWORD PTR _bone2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@SolveLock

; 871  : 		return;

	jmp	$LN1@SolveLock
$LN2@SolveLock:

; 872  : 
; 873  : 	// eval current ik'd bone
; 874  : 	BuildBoneChain( pos, q, bone2, boneToWorld, pBoneSet );

	mov	eax, DWORD PTR _pBoneSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone2$[ebp]
	push	edx
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 875  : 
; 876  : 	Vector	p1, p2, p3;

	lea	ecx, DWORD PTR _p1$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _p2$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _p3$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 877  : 	Vector4D	q2, q3;

	lea	ecx, DWORD PTR _q2$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	lea	ecx, DWORD PTR _q3$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 878  : 
; 879  : 	// current p and q
; 880  : 	p1 = boneToWorld[bone2].GetOrigin();

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	imul	ecx, DWORD PTR _bone2$[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p1$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p1$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p1$[ebp+8], eax

; 881  : 
; 882  : 	// blend in position
; 883  : 	p3 = p1 * (1.0 - plock->flPosWeight ) + m_ikLock[i].pos * plock->flPosWeight;

	mov	ecx, DWORD PTR _plock$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	add	eax, 32					; 00000020H
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _plock$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+4]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _p1$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p3$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p3$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p3$[ebp+8], eax

; 884  : 
; 885  : 	// do exact IK solution
; 886  : 	if( m_ikLock[i].kneeDir.LengthSqr() > 0.0f )

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	add	eax, 108				; 0000006cH
	mov	ecx, eax
	call	?LengthSqr@Vector@@QBEMXZ		; Vector::LengthSqr
	fstp	DWORD PTR tv309[ebp]
	movss	xmm0, DWORD PTR tv309[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@SolveLock

; 887  : 		m_pBoneSetup->SolveIK( bone0, bone1, bone2, p3, m_ikLock[i].kneePos, m_ikLock[i].kneeDir, boneToWorld );

	mov	edx, DWORD PTR _boneToWorld$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	add	eax, 120				; 00000078H
	push	eax
	lea	edx, DWORD PTR _p3$[ebp]
	push	edx
	mov	eax, DWORD PTR _bone2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bone1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone0$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?SolveIK@CStudioBoneSetup@@AAE_NHHHAAVVector@@00PAVmatrix3x4@@@Z ; CStudioBoneSetup::SolveIK
	jmp	SHORT $LN4@SolveLock
$LN3@SolveLock:

; 888  : 	else m_pBoneSetup->SolveIK(pchain, p3, boneToWorld );

	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	lea	edx, DWORD PTR _p3$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?SolveIK@CStudioBoneSetup@@AAE_NPBUmstudioikchain_t@@AAVVector@@PAVmatrix3x4@@@Z ; CStudioBoneSetup::SolveIK
$LN4@SolveLock:

; 889  : 
; 890  : 	// slam orientation
; 891  : 	p3 = boneToWorld[bone2].GetOrigin();

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	imul	ecx, DWORD PTR _bone2$[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p3$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p3$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p3$[ebp+8], eax

; 892  : 	boneToWorld[bone2] = matrix3x4( p3, m_ikLock[i].q );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	add	eax, 44					; 0000002cH
	push	eax
	lea	edx, DWORD PTR _p3$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	imul	edi, DWORD PTR _bone2$[ebp], 48
	add	edi, DWORD PTR _boneToWorld$[ebp]
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	rep movsd

; 893  : 
; 894  : 	// rebuild chain
; 895  : 	q2 = q[bone2];

	mov	eax, DWORD PTR _bone2$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q2$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _q2$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _q2$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _q2$[ebp+12], edx

; 896  : 	m_pBoneSetup->SolveBone( bone2, boneToWorld, pos, q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _boneToWorld$[ebp]
	push	edx
	mov	eax, DWORD PTR _bone2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::SolveBone

; 897  : 	QuaternionSlerp( q[bone2], q2, plock->flLocalQWeight, q[bone2] );

	mov	edx, DWORD PTR _bone2$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _plock$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone2$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _q$[ebp]
	push	edx
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H

; 898  : 	m_pBoneSetup->SolveBone( bone1, boneToWorld, pos, q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _boneToWorld$[ebp]
	push	edx
	mov	eax, DWORD PTR _bone1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::SolveBone

; 899  : 	m_pBoneSetup->SolveBone( bone0, boneToWorld, pos, q );

	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone0$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::SolveBone
$LN1@SolveLock:

; 900  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?SolveLock@CIKContext@@QAEXPBUmstudioiklock_t@@HQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ENDP ; CIKContext::SolveLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
_i$1 = -40						; size = 4
_lock$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
?SolveAllLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z PROC ; CIKContext::SolveAllLocks
; _this$ = ecx

; 845  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 846  : 	mstudioiklock_t	lock;
; 847  : 
; 848  : 	for( int i = 0; i < m_ikLock.Count(); i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SolveAllLo
$LN2@SolveAllLo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@SolveAllLo:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN3@SolveAllLo

; 849  : 	{
; 850  : 		lock.chain = i;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _lock$[ebp], ecx

; 851  : 		lock.flPosWeight = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lock$[ebp+4], xmm0

; 852  : 		lock.flLocalQWeight = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lock$[ebp+8], xmm0

; 853  : 		lock.flags = 0;

	mov	DWORD PTR _lock$[ebp+12], 0

; 854  : 
; 855  : 		SolveLock( &lock, i, pos, q, m_boneToWorld );

	push	0
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _lock$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SolveLock@CIKContext@@QAEXPBUmstudioiklock_t@@HQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::SolveLock

; 856  : 	}

	jmp	SHORT $LN2@SolveAllLo
$LN3@SolveAllLo:

; 857  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?SolveAllLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ENDP ; CIKContext::SolveAllLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 16
$T2 = -68						; size = 12
$T3 = -56						; size = 12
$T4 = -44						; size = 12
tv275 = -32						; size = 4
_ikOffset$ = -28					; size = 4
_link0$5 = -24						; size = 4
_pchain$6 = -20						; size = 4
_bone$7 = -16						; size = 4
_i$8 = -12						; size = 4
_ikrule$9 = -8						; size = 4
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
?AddAllLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z PROC ; CIKContext::AddAllLocks
; _this$ = ecx

; 795  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 796  : 	// skip all array access if no autoplay locks.
; 797  : 	if( m_pBoneSetup->GetNumIKChains() == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	test	eax, eax
	jne	SHORT $LN5@AddAllLock

; 798  : 	{
; 799  : 		return;

	jmp	$LN1@AddAllLock
$LN5@AddAllLock:

; 800  : 	}
; 801  : 
; 802  : 	int ikOffset = m_ikLock.AddMultipleToTail( m_pBoneSetup->GetNumIKChains() );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail
	mov	DWORD PTR _ikOffset$[ebp], eax

; 803  : 	memset( &m_ikLock[ikOffset], 0, sizeof( ikcontextikrule_t ) * m_pBoneSetup->GetNumIKChains() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	imul	eax, eax, 132
	push	eax
	push	0
	mov	ecx, DWORD PTR _ikOffset$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 804  : 
; 805  : 	for( int i = 0; i < m_pBoneSetup->GetNumIKChains(); i++ )

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN4@AddAllLock
$LN2@AddAllLock:
	mov	edx, DWORD PTR _i$8[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8[ebp], edx
$LN4@AddAllLock:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	cmp	DWORD PTR _i$8[ebp], eax
	jge	$LN3@AddAllLock

; 806  : 	{
; 807  : 		const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( i );

	mov	ecx, DWORD PTR _i$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$6[ebp], eax

; 808  : 		int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	eax, DWORD PTR _pchain$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone$7[ebp], edx

; 809  : 
; 810  : 		// don't bother with iklock if the bone isn't going to be calculated
; 811  : 		if( !m_pBoneSetup->IsBoneUsed( bone ))

	mov	eax, DWORD PTR _bone$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@AddAllLock

; 812  : 			continue;

	jmp	SHORT $LN2@AddAllLock
$LN6@AddAllLock:

; 813  : 
; 814  : 		// eval current ik'd bone
; 815  : 		BuildBoneChain( pos, q, bone, m_boneToWorld );

	push	0
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	mov	eax, DWORD PTR _bone$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 816  : 
; 817  : 		ikcontextikrule_t *ikrule = &m_ikLock[ikOffset + i];

	mov	eax, DWORD PTR _ikOffset$[ebp]
	add	eax, DWORD PTR _i$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	mov	DWORD PTR _ikrule$9[ebp], eax

; 818  : 
; 819  : 		ikrule->type = IK_WORLD;

	mov	ecx, DWORD PTR _ikrule$9[ebp]
	mov	DWORD PTR [ecx+4], 2

; 820  : 		ikrule->chain = i;

	mov	edx, DWORD PTR _ikrule$9[ebp]
	mov	eax, DWORD PTR _i$8[ebp]
	mov	DWORD PTR [edx+8], eax

; 821  : 		ikrule->slot = i;

	mov	ecx, DWORD PTR _ikrule$9[ebp]
	mov	edx, DWORD PTR _i$8[ebp]
	mov	DWORD PTR [ecx+16], edx

; 822  : 
; 823  : 		ikrule->q = m_boneToWorld[bone].GetQuaternion();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	imul	ecx, DWORD PTR _bone$7[ebp], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _ikrule$9[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 824  : 		ikrule->pos = m_boneToWorld[bone].GetOrigin();

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	imul	ecx, DWORD PTR _bone$7[ebp], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _ikrule$9[ebp]
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 825  : 
; 826  : 		// save off current knee direction
; 827  : 		if( m_pBoneSetup->pIKLink( pchain, 0 )->kneeDir.LengthSqr() > 0.0f )

	push	0
	mov	ecx, DWORD PTR _pchain$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	add	eax, 4
	mov	ecx, eax
	call	?LengthSqr@Vector@@QBEMXZ		; Vector::LengthSqr
	fstp	DWORD PTR tv275[ebp]
	movss	xmm0, DWORD PTR tv275[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@AddAllLock

; 828  : 		{
; 829  : 			const mstudioiklink_t *link0 = m_pBoneSetup->pIKLink( pchain, 0 );

	push	0
	mov	eax, DWORD PTR _pchain$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	DWORD PTR _link0$5[ebp], eax

; 830  : 			ikrule->kneeDir = m_boneToWorld[link0->bone].VectorRotate( link0->kneeDir );

	mov	edx, DWORD PTR _link0$5[ebp]
	add	edx, 4
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _link0$5[ebp]
	imul	ecx, DWORD PTR [ecx], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorRotate
	mov	edx, DWORD PTR _ikrule$9[ebp]
	add	edx, 108				; 0000006cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 831  : 			ikrule->kneePos = m_boneToWorld[link0->bone].GetOrigin();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _link0$5[ebp]
	imul	ecx, DWORD PTR [edx], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR _ikrule$9[ebp]
	add	ecx, 120				; 00000078H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 832  : 
; 833  : 		}
; 834  : 		else

	jmp	SHORT $LN8@AddAllLock
$LN7@AddAllLock:

; 835  : 		{
; 836  : 			ikrule->kneeDir.Init( );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ikrule$9[ebp]
	add	ecx, 108				; 0000006cH
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init
$LN8@AddAllLock:

; 837  : 		}
; 838  : 	}

	jmp	$LN2@AddAllLock
$LN3@AddAllLock:
$LN1@AddAllLock:

; 839  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddAllLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ENDP ; CIKContext::AddAllLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_plock$1 = -12						; size = 4
_this$ = -8						; size = 4
_i$2 = -4						; size = 4
_pseqdesc$ = 8						; size = 4
_pos$ = 12						; size = 4
_q$ = 16						; size = 4
?SolveSequenceLocks@CIKContext@@QAEXPAUmstudioseqdesc_t@@QAVVector@@QAVVector4D@@@Z PROC ; CIKContext::SolveSequenceLocks
; _this$ = ecx

; 783  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 784  : 	for( int i = 0; i < m_ikLock.Count(); i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SolveSeque
$LN2@SolveSeque:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SolveSeque:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _i$2[ebp], eax
	jge	SHORT $LN1@SolveSeque

; 785  : 	{
; 786  : 		const mstudioiklock_t *plock = m_pBoneSetup->pIKLock( pseqdesc, i );

	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@PBUmstudioseqdesc_t@@H@Z ; CStudioBoneSetup::pIKLock
	mov	DWORD PTR _plock$1[ebp], eax

; 787  : 		SolveLock( plock, i, pos, q, m_boneToWorld );

	push	0
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _plock$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SolveLock@CIKContext@@QAEXPBUmstudioiklock_t@@HQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::SolveLock

; 788  : 	}

	jmp	SHORT $LN2@SolveSeque
$LN1@SolveSeque:

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SolveSequenceLocks@CIKContext@@QAEXPAUmstudioseqdesc_t@@QAVVector@@QAVVector4D@@@Z ENDP ; CIKContext::SolveSequenceLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -76						; size = 16
$T2 = -60						; size = 12
$T3 = -48						; size = 12
tv276 = -36						; size = 4
_plock$4 = -32						; size = 4
_link0$5 = -28						; size = 4
_ikOffset$ = -24					; size = 4
_pchain$6 = -20						; size = 4
_bone$7 = -16						; size = 4
_ikrule$8 = -12						; size = 4
_i$9 = -8						; size = 4
_this$ = -4						; size = 4
_pseqdesc$ = 8						; size = 4
_pos$ = 12						; size = 4
_q$ = 16						; size = 4
?AddSequenceLocks@CIKContext@@QAEXPAUmstudioseqdesc_t@@QAVVector@@QAVVector4D@@@Z PROC ; CIKContext::AddSequenceLocks
; _this$ = ecx

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 	if( m_pBoneSetup->GetNumIKChains() == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	test	eax, eax
	jne	SHORT $LN5@AddSequenc

; 207  : 	{
; 208  : 		return;

	jmp	$LN1@AddSequenc
$LN5@AddSequenc:

; 209  : 	}
; 210  : 
; 211  : 	if( pseqdesc->numiklocks == 0 )

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	movzx	edx, BYTE PTR [ecx+155]
	test	edx, edx
	jne	SHORT $LN6@AddSequenc

; 212  : 	{
; 213  : 		return;

	jmp	$LN1@AddSequenc
$LN6@AddSequenc:

; 214  : 	}
; 215  : 
; 216  : 	int ikOffset = m_ikLock.AddMultipleToTail( pseqdesc->numiklocks );

	push	0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	movzx	ecx, BYTE PTR [eax+155]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail
	mov	DWORD PTR _ikOffset$[ebp], eax

; 217  : 	memset( &m_ikLock[ikOffset], 0, sizeof( ikcontextikrule_t ) * pseqdesc->numiklocks );

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movzx	eax, BYTE PTR [edx+155]
	imul	ecx, eax, 132
	push	ecx
	push	0
	mov	edx, DWORD PTR _ikOffset$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 	for( int i = 0; i < pseqdesc->numiklocks; i++ )

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@AddSequenc
$LN2@AddSequenc:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN4@AddSequenc:
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	movzx	edx, BYTE PTR [ecx+155]
	cmp	DWORD PTR _i$9[ebp], edx
	jge	$LN3@AddSequenc

; 220  : 	{
; 221  : 		const mstudioiklock_t *plock = m_pBoneSetup->pIKLock( pseqdesc, i );

	mov	eax, DWORD PTR _i$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@PBUmstudioseqdesc_t@@H@Z ; CStudioBoneSetup::pIKLock
	mov	DWORD PTR _plock$4[ebp], eax

; 222  : 		const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( plock->chain );

	mov	eax, DWORD PTR _plock$4[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$6[ebp], eax

; 223  : 		int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	eax, DWORD PTR _pchain$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone$7[ebp], edx

; 224  : 
; 225  : 		// don't bother with iklock if the bone isn't going to be calculated
; 226  : 		if( !m_pBoneSetup->IsBoneUsed( bone ))

	mov	eax, DWORD PTR _bone$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@AddSequenc

; 227  : 			continue;

	jmp	SHORT $LN2@AddSequenc
$LN7@AddSequenc:

; 228  : 
; 229  : 		// eval current ik'd bone
; 230  : 		BuildBoneChain( pos, q, bone, m_boneToWorld );

	push	0
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	mov	eax, DWORD PTR _bone$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 231  : 
; 232  : 		ikcontextikrule_t *ikrule = &m_ikLock[ikOffset+i];

	mov	eax, DWORD PTR _ikOffset$[ebp]
	add	eax, DWORD PTR _i$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	mov	DWORD PTR _ikrule$8[ebp], eax

; 233  : 		ikrule->chain = i;

	mov	ecx, DWORD PTR _ikrule$8[ebp]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	DWORD PTR [ecx+8], edx

; 234  : 		ikrule->slot = i;

	mov	eax, DWORD PTR _ikrule$8[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	DWORD PTR [eax+16], ecx

; 235  : 		ikrule->type = IK_WORLD;

	mov	edx, DWORD PTR _ikrule$8[ebp]
	mov	DWORD PTR [edx+4], 2

; 236  : 
; 237  : 		ikrule->q = m_boneToWorld[bone].GetQuaternion();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	imul	ecx, DWORD PTR _bone$7[ebp], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _ikrule$8[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 238  : 		ikrule->pos = m_boneToWorld[bone].GetOrigin();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	imul	ecx, DWORD PTR _bone$7[ebp], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _ikrule$8[ebp]
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 239  : 
; 240  : 		// save off current knee direction
; 241  : 		if( m_pBoneSetup->pIKLink( pchain, 0 )->kneeDir.LengthSqr() > 0.0f )

	push	0
	mov	ecx, DWORD PTR _pchain$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	add	eax, 4
	mov	ecx, eax
	call	?LengthSqr@Vector@@QBEMXZ		; Vector::LengthSqr
	fstp	DWORD PTR tv276[ebp]
	movss	xmm0, DWORD PTR tv276[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@AddSequenc

; 242  : 		{
; 243  : 			const mstudioiklink_t *link0 = m_pBoneSetup->pIKLink( pchain, 0 );

	push	0
	mov	eax, DWORD PTR _pchain$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	DWORD PTR _link0$5[ebp], eax

; 244  : 			ikrule->kneeDir = m_boneToWorld[link0->bone].VectorRotate( link0->kneeDir );

	mov	edx, DWORD PTR _link0$5[ebp]
	add	edx, 4
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _link0$5[ebp]
	imul	ecx, DWORD PTR [ecx], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorRotate
	mov	edx, DWORD PTR _ikrule$8[ebp]
	add	edx, 108				; 0000006cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 245  : 		}
; 246  : 		else

	jmp	SHORT $LN9@AddSequenc
$LN8@AddSequenc:

; 247  : 		{
; 248  : 			ikrule->kneeDir.Init( );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ikrule$8[ebp]
	add	ecx, 108				; 0000006cH
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init
$LN9@AddSequenc:

; 249  : 		}
; 250  : 	}

	jmp	$LN2@AddSequenc
$LN3@AddSequenc:
$LN1@AddSequenc:

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddSequenceLocks@CIKContext@@QAEXPAUmstudioseqdesc_t@@QAVVector@@QAVVector4D@@@Z ENDP ; CIKContext::AddSequenceLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_lock$1 = -12						; size = 4
_this$ = -8						; size = 4
_i$2 = -4						; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
?SolveAutoplayLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z PROC ; CIKContext::SolveAutoplayLocks
; _this$ = ecx

; 771  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 772  : 	for( int i = 0; i < m_ikLock.Count(); i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SolveAutop
$LN2@SolveAutop:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SolveAutop:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _i$2[ebp], eax
	jge	SHORT $LN1@SolveAutop

; 773  : 	{
; 774  : 		const mstudioiklock_t *lock = m_pBoneSetup->pIKAutoplayLock( i );

	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKAutoplayLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@H@Z ; CStudioBoneSetup::pIKAutoplayLock
	mov	DWORD PTR _lock$1[ebp], eax

; 775  : 		SolveLock( lock, i, pos, q, m_boneToWorld );

	push	0
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lock$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SolveLock@CIKContext@@QAEXPBUmstudioiklock_t@@HQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ; CIKContext::SolveLock

; 776  : 	}

	jmp	SHORT $LN2@SolveAutop
$LN1@SolveAutop:

; 777  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SolveAutoplayLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ENDP ; CIKContext::SolveAutoplayLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -92						; size = 16
$T2 = -76						; size = 12
$T3 = -64						; size = 12
$T4 = -52						; size = 12
_link1$5 = -40						; size = 4
tv291 = -36						; size = 4
_link0$6 = -32						; size = 4
_lock$7 = -28						; size = 4
_ikOffset$ = -24					; size = 4
_pchain$8 = -20						; size = 4
_bone$9 = -16						; size = 4
_i$10 = -12						; size = 4
_ikrule$11 = -8						; size = 4
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
?AddAutoplayLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z PROC ; CIKContext::AddAutoplayLocks
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	// skip all array access if no autoplay locks.
; 155  : 	if( m_pBoneSetup->GetNumIKAutoplayLocks() == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKAutoplayLocks
	test	eax, eax
	jne	SHORT $LN5@AddAutopla

; 156  : 	{
; 157  : 		return;

	jmp	$LN1@AddAutopla
$LN5@AddAutopla:

; 158  : 	}
; 159  : 
; 160  : 	int ikOffset = m_ikLock.AddMultipleToTail( m_pBoneSetup->GetNumIKAutoplayLocks() );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKAutoplayLocks
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	?AddMultipleToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHHPBUikcontextikrule_t@@@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddMultipleToTail
	mov	DWORD PTR _ikOffset$[ebp], eax

; 161  : 	memset( &m_ikLock[ikOffset], 0, sizeof( ikcontextikrule_t ) * m_pBoneSetup->GetNumIKAutoplayLocks() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKAutoplayLocks
	imul	eax, eax, 132
	push	eax
	push	0
	mov	ecx, DWORD PTR _ikOffset$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 162  : 
; 163  : 	for( int i = 0; i < m_pBoneSetup->GetNumIKAutoplayLocks(); i++ )

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN4@AddAutopla
$LN2@AddAutopla:
	mov	edx, DWORD PTR _i$10[ebp]
	add	edx, 1
	mov	DWORD PTR _i$10[ebp], edx
$LN4@AddAutopla:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKAutoplayLocks
	cmp	DWORD PTR _i$10[ebp], eax
	jge	$LN3@AddAutopla

; 164  : 	{
; 165  : 		const mstudioiklock_t *lock = m_pBoneSetup->pIKAutoplayLock( i );

	mov	ecx, DWORD PTR _i$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKAutoplayLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@H@Z ; CStudioBoneSetup::pIKAutoplayLock
	mov	DWORD PTR _lock$7[ebp], eax

; 166  : 		const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( lock->chain );

	mov	eax, DWORD PTR _lock$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$8[ebp], eax

; 167  : 		int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	eax, DWORD PTR _pchain$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone$9[ebp], edx

; 168  : 
; 169  : 		// don't bother with iklock if the bone isn't going to be calculated
; 170  : 		if( !m_pBoneSetup->IsBoneUsed( bone ))

	mov	eax, DWORD PTR _bone$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@AddAutopla

; 171  : 			continue;

	jmp	SHORT $LN2@AddAutopla
$LN6@AddAutopla:

; 172  : 
; 173  : 		// eval current ik'd bone
; 174  : 		BuildBoneChain( pos, q, bone, m_boneToWorld );

	push	0
	push	OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	mov	eax, DWORD PTR _bone$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 175  : 
; 176  : 		ikcontextikrule_t *ikrule = &m_ikLock[ikOffset + i];

	mov	eax, DWORD PTR _ikOffset$[ebp]
	add	eax, DWORD PTR _i$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??A?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::operator[]
	mov	DWORD PTR _ikrule$11[ebp], eax

; 177  : 
; 178  : 		ikrule->chain = lock->chain;

	mov	ecx, DWORD PTR _ikrule$11[ebp]
	mov	edx, DWORD PTR _lock$7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 179  : 		ikrule->type = IK_WORLD;

	mov	ecx, DWORD PTR _ikrule$11[ebp]
	mov	DWORD PTR [ecx+4], 2

; 180  : 		ikrule->slot = i;

	mov	edx, DWORD PTR _ikrule$11[ebp]
	mov	eax, DWORD PTR _i$10[ebp]
	mov	DWORD PTR [edx+16], eax

; 181  : 
; 182  : 		ikrule->q = m_boneToWorld[bone].GetQuaternion();

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	imul	ecx, DWORD PTR _bone$9[ebp], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	edx, DWORD PTR _ikrule$11[ebp]
	add	edx, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 183  : 		ikrule->pos = m_boneToWorld[bone].GetOrigin();

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	imul	ecx, DWORD PTR _bone$9[ebp], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _ikrule$11[ebp]
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 184  : 
; 185  : 		// save off current knee direction
; 186  : 		if( m_pBoneSetup->pIKLink( pchain, 0 )->kneeDir.LengthSqr() > 0.0f )

	push	0
	mov	ecx, DWORD PTR _pchain$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	add	eax, 4
	mov	ecx, eax
	call	?LengthSqr@Vector@@QBEMXZ		; Vector::LengthSqr
	fstp	DWORD PTR tv291[ebp]
	movss	xmm0, DWORD PTR tv291[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN7@AddAutopla

; 187  : 		{
; 188  : 			const mstudioiklink_t *link0 = m_pBoneSetup->pIKLink( pchain, 0 );

	push	0
	mov	eax, DWORD PTR _pchain$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	DWORD PTR _link0$6[ebp], eax

; 189  : 			const mstudioiklink_t *link1 = m_pBoneSetup->pIKLink( pchain, 1 );

	push	1
	mov	edx, DWORD PTR _pchain$8[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	DWORD PTR _link1$5[ebp], eax

; 190  : 
; 191  : 			ikrule->kneeDir = m_boneToWorld[link0->bone].VectorRotate( link0->kneeDir );

	mov	ecx, DWORD PTR _link0$6[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _link0$6[ebp]
	imul	ecx, DWORD PTR [eax], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorRotate
	mov	ecx, DWORD PTR _ikrule$11[ebp]
	add	ecx, 108				; 0000006cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 192  : 			ikrule->kneePos = m_boneToWorld[link1->bone].GetOrigin(); 

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR _link1$5[ebp]
	imul	ecx, DWORD PTR [edx], 48
	add	ecx, OFFSET ?m_boneToWorld@CIKContext@@0PAVmatrix3x4@@A ; CIKContext::m_boneToWorld
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR _ikrule$11[ebp]
	add	ecx, 120				; 00000078H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 193  : 		}
; 194  : 		else

	jmp	SHORT $LN8@AddAutopla
$LN7@AddAutopla:

; 195  : 		{
; 196  : 			ikrule->kneeDir.Init( );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ikrule$11[ebp]
	add	ecx, 108				; 0000006cH
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init
$LN8@AddAutopla:

; 197  : 		}
; 198  : 	}

	jmp	$LN2@AddAutopla
$LN3@AddAutopla:
$LN1@AddAutopla:

; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddAutoplayLocks@CIKContext@@QAEXQAVVector@@QAVVector4D@@@Z ENDP ; CIKContext::AddAutoplayLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -1952						; size = 16
$T2 = -1936						; size = 16
$T3 = -1920						; size = 16
$T4 = -1904						; size = 16
$T5 = -1888						; size = 12
$T6 = -1876						; size = 12
$T7 = -1864						; size = 12
$T8 = -1852						; size = 12
$T9 = -1840						; size = 12
$T10 = -1828						; size = 12
$T11 = -1816						; size = 12
$T12 = -1804						; size = 12
$T13 = -1792						; size = 12
$T14 = -1780						; size = 12
$T15 = -1768						; size = 12
$T16 = -1756						; size = 12
_tmp$17 = -1744						; size = 12
$T18 = -1732						; size = 12
_p3$19 = -1720						; size = 12
_q2$20 = -1708						; size = 16
_q2$21 = -1692						; size = 16
_q2$22 = -1676						; size = 16
_p2$23 = -1660						; size = 12
_p2$24 = -1648						; size = 12
_p2$25 = -1636						; size = 12
_bone1$26 = -1624					; size = 4
_bone0$27 = -1620					; size = 4
_pchain$28 = -1616					; size = 4
_pchain$29 = -1612					; size = 4
tv171 = -1608						; size = 4
_pTarget$30 = -1604					; size = 4
_flWeight$31 = -1600					; size = 4
_bone$32 = -1596					; size = 4
_bone2$33 = -1592					; size = 4
_pchain$34 = -1588					; size = 4
_pChainResult$35 = -1584				; size = 4
_bone$36 = -1580					; size = 4
_j$ = -1576						; size = 4
_pChainResult$37 = -1572				; size = 4
_flWeight$38 = -1568					; size = 4
_pChainResult$39 = -1564				; size = 4
_pChainResult$40 = -1560				; size = 4
_pTarget$41 = -1556					; size = 4
_pRule$42 = -1552					; size = 4
_i$ = -1548						; size = 4
_this$ = -1544						; size = 4
$T43 = -1540						; size = 48
$T44 = -1492						; size = 48
$T45 = -1444						; size = 48
$T46 = -1396						; size = 48
_worldFootpad$47 = -1348				; size = 48
_local$48 = -1300					; size = 48
_local$49 = -1252					; size = 48
_worldTarget$ = -1204					; size = 48
_chainResult$ = -1156					; size = 1152
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
_boneToWorld$ = 16					; size = 4
_pBoneSet$ = 20						; size = 4
?SolveDependencies@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z PROC ; CIKContext::SolveDependencies
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1952				; 000007a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 584  : 	matrix3x4	worldTarget;

	lea	ecx, DWORD PTR _worldTarget$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 585  : 	int i, j;
; 586  : 
; 587  : 	ikchainresult_t chainResult[32]; // allocate!!!

	push	OFFSET ??0ikchainresult_t@@QAE@XZ
	push	32					; 00000020H
	push	36					; 00000024H
	lea	eax, DWORD PTR _chainResult$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 588  : 
; 589  : 	// init chain rules
; 590  : 	for( i = 0; i < m_pBoneSetup->GetNumIKChains(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SolveDepen
$LN2@SolveDepen:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@SolveDepen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@SolveDepen

; 591  : 	{
; 592  : 		const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$29[ebp], eax

; 593  : 		ikchainresult_t *pChainResult = &chainResult[i];

	imul	edx, DWORD PTR _i$[ebp], 36
	lea	eax, DWORD PTR _chainResult$[ebp+edx]
	mov	DWORD PTR _pChainResult$35[ebp], eax

; 594  : 		int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	ecx, DWORD PTR _pchain$29[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _bone$36[ebp], eax

; 595  : 
; 596  : 		pChainResult->target = -1;

	mov	ecx, DWORD PTR _pChainResult$35[ebp]
	mov	DWORD PTR [ecx], -1

; 597  : 		pChainResult->flWeight = 0.0;

	mov	edx, DWORD PTR _pChainResult$35[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+32], xmm0

; 598  : 
; 599  : 		// don't bother with chain if the bone isn't going to be calculated
; 600  : 		if( !m_pBoneSetup->IsBoneUsed( bone ))

	mov	eax, DWORD PTR _bone$36[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN19@SolveDepen

; 601  : 			continue;

	jmp	$LN2@SolveDepen
$LN19@SolveDepen:

; 602  : 
; 603  : 		// eval current ik'd bone
; 604  : 		BuildBoneChain( pos, q, bone, boneToWorld, pBoneSet );

	mov	eax, DWORD PTR _pBoneSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone$36[ebp]
	push	edx
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 605  : 
; 606  : 		pChainResult->q = boneToWorld[bone].GetQuaternion();

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	imul	ecx, DWORD PTR _bone$36[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR _pChainResult$35[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 607  : 		pChainResult->pos = boneToWorld[bone].GetOrigin();

	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	imul	ecx, DWORD PTR _bone$36[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _pChainResult$35[ebp]
	add	edx, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 608  : 	}

	jmp	$LN2@SolveDepen
$LN3@SolveDepen:

; 609  : 
; 610  : 	for( j = 0; j < m_ikChainRule.Count(); j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@SolveDepen
$LN5@SolveDepen:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@SolveDepen:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count
	cmp	DWORD PTR _j$[ebp], eax
	jge	$LN6@SolveDepen

; 611  : 	{
; 612  : 		for( i = 0; i < m_ikChainRule.Element( j ).Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SolveDepen
$LN8@SolveDepen:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@SolveDepen:
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN9@SolveDepen

; 613  : 		{
; 614  : 			ikcontextikrule_t *pRule = &m_ikChainRule.Element( j ).Element( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	mov	DWORD PTR _pRule$42[ebp], eax

; 615  : 			ikchainresult_t *pChainResult = &chainResult[pRule->chain];

	mov	eax, DWORD PTR _pRule$42[ebp]
	imul	ecx, DWORD PTR [eax+8], 36
	lea	edx, DWORD PTR _chainResult$[ebp+ecx]
	mov	DWORD PTR _pChainResult$40[ebp], edx

; 616  : 			pChainResult->target = -1;

	mov	eax, DWORD PTR _pChainResult$40[ebp]
	mov	DWORD PTR [eax], -1

; 617  : 
; 618  : 			switch( pRule->type )

	mov	ecx, DWORD PTR _pRule$42[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv171[ebp], edx
	cmp	DWORD PTR tv171[ebp], 1
	je	SHORT $LN20@SolveDepen
	cmp	DWORD PTR tv171[ebp], 4
	je	$LN26@SolveDepen
	jmp	$LN11@SolveDepen
$LN20@SolveDepen:

; 619  : 			{
; 620  : 			case IK_SELF:
; 621  : 				{
; 622  : 					// xform IK target error into world space
; 623  : 					matrix3x4	local = matrix3x4( pRule->pos, pRule->q );

	mov	eax, DWORD PTR _pRule$42[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _pRule$42[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	lea	ecx, DWORD PTR _local$49[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4

; 624  : 
; 625  : 					// eval target bone space
; 626  : 					if( pRule->bone != -1 )

	mov	edx, DWORD PTR _pRule$42[ebp]
	cmp	DWORD PTR [edx+12], -1
	je	SHORT $LN21@SolveDepen

; 627  : 					{
; 628  : 						BuildBoneChain( pos, q, pRule->bone, boneToWorld, pBoneSet );

	mov	eax, DWORD PTR _pBoneSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRule$42[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 629  : 						worldTarget = boneToWorld[pRule->bone].ConcatTransforms( local );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _local$49[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR $T43[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRule$42[ebp]
	imul	ecx, DWORD PTR [edx+12], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _worldTarget$[ebp]
	rep movsd

; 630  : 					}
; 631  : 					else

	jmp	SHORT $LN22@SolveDepen
$LN21@SolveDepen:

; 632  : 					{
; 633  : 						worldTarget = m_rootxform.ConcatTransforms( local );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _local$49[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR $T44[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4084				; 00000ff4H
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _worldTarget$[ebp]
	rep movsd
$LN22@SolveDepen:

; 634  : 					}
; 635  : 			
; 636  : 					float flWeight = pRule->flWeight * pRule->flRuleWeight;

	mov	edx, DWORD PTR _pRule$42[ebp]
	mov	eax, DWORD PTR _pRule$42[ebp]
	movss	xmm0, DWORD PTR [edx+92]
	mulss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR _flWeight$38[ebp], xmm0

; 637  : 					pChainResult->flWeight = pChainResult->flWeight * (1 - flWeight) + flWeight;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _flWeight$38[ebp]
	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm0, DWORD PTR _flWeight$38[ebp]
	mov	edx, DWORD PTR _pChainResult$40[ebp]
	movss	DWORD PTR [edx+32], xmm0

; 638  : 
; 639  : 					Vector	p2;

	lea	ecx, DWORD PTR _p2$23[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 640  : 					Vector4D	q2;

	lea	ecx, DWORD PTR _q2$22[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 641  : 					
; 642  : 					// target p and q
; 643  : 					q2 = worldTarget.GetQuaternion();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _worldTarget$[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q2$22[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _q2$22[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _q2$22[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _q2$22[ebp+12], edx

; 644  : 					p2 = worldTarget.GetOrigin();

	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	lea	ecx, DWORD PTR _worldTarget$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p2$23[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p2$23[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p2$23[ebp+8], eax

; 645  : 
; 646  : 					// m_pBoneSetup->debugLine( pChainResult->pos, p2, 0, 0, 255, true, 0.1 );
; 647  : 
; 648  : 					// blend in position and angles
; 649  : 					pChainResult->pos = pChainResult->pos * (1.0f - flWeight) + p2 * flWeight;

	push	ecx
	movss	xmm0, DWORD PTR _flWeight$38[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	push	ecx
	lea	ecx, DWORD PTR _p2$23[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T16[ebp]
	push	edx
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _flWeight$38[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	add	ecx, 4
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 650  : 					QuaternionSlerp( pChainResult->q, q2, flWeight, pChainResult->q );

	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _flWeight$38[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _q2$22[ebp]
	push	edx
	mov	eax, DWORD PTR _pChainResult$40[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H

; 651  : 				}
; 652  : 				break;

	jmp	$LN11@SolveDepen

; 653  : 			case IK_WORLD:
; 654  : 				break;

	jmp	$LN11@SolveDepen

; 655  : 			case IK_ATTACHMENT:
; 656  : 				break;

	jmp	$LN11@SolveDepen

; 657  : 			case IK_GROUND:
; 658  : 				break;

	jmp	$LN11@SolveDepen
$LN26@SolveDepen:

; 659  : 			case IK_RELEASE:
; 660  : 				{
; 661  : 					// move target back towards original location
; 662  : 					float flWeight = pRule->flWeight * pRule->flRuleWeight;

	mov	ecx, DWORD PTR _pRule$42[ebp]
	mov	edx, DWORD PTR _pRule$42[ebp]
	movss	xmm0, DWORD PTR [ecx+92]
	mulss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR _flWeight$31[ebp], xmm0

; 663  : 					const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( pRule->chain );

	mov	eax, DWORD PTR _pRule$42[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$28[ebp], eax

; 664  : 					int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	eax, DWORD PTR _pchain$28[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone$32[ebp], edx

; 665  : 
; 666  : 					Vector	p2;

	lea	ecx, DWORD PTR _p2$24[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 667  : 					Vector4D	q2;

	lea	ecx, DWORD PTR _q2$21[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 668  : 					
; 669  : 					BuildBoneChain( pos, q, bone, boneToWorld, pBoneSet );

	mov	eax, DWORD PTR _pBoneSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone$32[ebp]
	push	edx
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 670  : 					q2 = boneToWorld[bone].GetQuaternion();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	imul	ecx, DWORD PTR _bone$32[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q2$21[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _q2$21[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _q2$21[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _q2$21[ebp+12], edx

; 671  : 					p2 = boneToWorld[bone].GetOrigin();

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	imul	ecx, DWORD PTR _bone$32[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p2$24[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p2$24[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p2$24[ebp+8], eax

; 672  : 
; 673  : 					// blend in position and angles
; 674  : 					pChainResult->pos = pChainResult->pos * (1.0 - flWeight) + p2 * flWeight;

	push	ecx
	movss	xmm0, DWORD PTR _flWeight$31[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR _p2$24[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	cvtss2sd xmm0, DWORD PTR _flWeight$31[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	add	ecx, 4
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 675  : 					QuaternionSlerp( pChainResult->q, q2, flWeight, pChainResult->q );

	mov	ecx, DWORD PTR _pChainResult$40[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _flWeight$31[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _q2$21[ebp]
	push	edx
	mov	eax, DWORD PTR _pChainResult$40[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H
$LN11@SolveDepen:

; 676  : 				}
; 677  : 				break;
; 678  : 			case IK_UNLATCH:
; 679  : 				{
; 680  : 					/*
; 681  : 					pChainResult->flWeight = pChainResult->flWeight * (1 - pRule->flWeight) + pRule->flWeight;
; 682  : 
; 683  : 					pChainResult->pos = pChainResult->pos * (1.0 - pRule->flWeight ) + pChainResult->local.pos * pRule->flWeight;
; 684  : 					QuaternionSlerp( pChainResult->q, pChainResult->local.q, pRule->flWeight, pChainResult->q );
; 685  : 					*/
; 686  : 				}
; 687  : 				break;
; 688  : 			}
; 689  : 		}

	jmp	$LN8@SolveDepen
$LN9@SolveDepen:

; 690  : 	}

	jmp	$LN5@SolveDepen
$LN6@SolveDepen:

; 691  : 
; 692  : 	for (i = 0; i < m_target.Count(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@SolveDepen
$LN13@SolveDepen:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN15@SolveDepen:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN14@SolveDepen

; 693  : 	{
; 694  : 		CIKTarget *pTarget = &m_target[i];

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$41[ebp], eax

; 695  : 
; 696  : 		if( m_target[i].est.flWeight > 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	movss	xmm0, DWORD PTR [eax+88]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN28@SolveDepen

; 697  : 		{
; 698  : 			ikchainresult_t *pChainResult = &chainResult[ pTarget->chain ];

	mov	ecx, DWORD PTR _pTarget$41[ebp]
	imul	edx, DWORD PTR [ecx], 36
	lea	eax, DWORD PTR _chainResult$[ebp+edx]
	mov	DWORD PTR _pChainResult$39[ebp], eax

; 699  : 			matrix3x4 local = matrix3x4( pTarget->offset.pos, pTarget->offset.q );

	mov	ecx, DWORD PTR _pTarget$41[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _pTarget$41[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	lea	ecx, DWORD PTR _local$48[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4

; 700  : 			matrix3x4	worldFootpad = matrix3x4( pTarget->est.pos, pTarget->est.q );

	mov	eax, DWORD PTR _pTarget$41[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _pTarget$41[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	lea	ecx, DWORD PTR _worldFootpad$47[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4

; 701  : 			worldTarget = worldFootpad.ConcatTransforms( local );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _local$48[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T45[ebp]
	push	eax
	lea	ecx, DWORD PTR _worldFootpad$47[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _worldTarget$[ebp]
	rep movsd

; 702  : 
; 703  : 			Vector	p2;

	lea	ecx, DWORD PTR _p2$25[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 704  : 			Vector4D	q2;

	lea	ecx, DWORD PTR _q2$20[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 705  : 
; 706  : 			// target p and q
; 707  : 			q2 = worldTarget.GetQuaternion();

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	lea	ecx, DWORD PTR _worldTarget$[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _q2$20[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _q2$20[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _q2$20[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _q2$20[ebp+12], eax

; 708  : 			p2 = worldTarget.GetOrigin();

	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	lea	ecx, DWORD PTR _worldTarget$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _p2$25[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p2$25[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _p2$25[ebp+8], edx

; 709  : 
; 710  : 			// blend in position and angles
; 711  : 			pChainResult->flWeight = pTarget->est.flWeight;

	mov	eax, DWORD PTR _pChainResult$39[ebp]
	mov	ecx, DWORD PTR _pTarget$41[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+32], edx

; 712  : 			pChainResult->pos = pChainResult->pos * (1.0 - pChainResult->flWeight ) + p2 * pChainResult->flWeight;

	mov	eax, DWORD PTR _pChainResult$39[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	lea	ecx, DWORD PTR _p2$25[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	eax, DWORD PTR _pChainResult$39[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+32]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T18[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pChainResult$39[ebp]
	add	ecx, 4
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _pChainResult$39[ebp]
	add	edx, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 713  : 			QuaternionSlerp( pChainResult->q, q2, pChainResult->flWeight, pChainResult->q );

	mov	ecx, DWORD PTR _pChainResult$39[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pChainResult$39[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _q2$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChainResult$39[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H
$LN28@SolveDepen:

; 714  : 		}
; 715  : 
; 716  : 		if( pTarget->latched.bNeedsLatch )

	mov	edx, DWORD PTR _pTarget$41[ebp]
	movzx	eax, BYTE PTR [edx+196]
	test	eax, eax
	je	SHORT $LN29@SolveDepen

; 717  : 		{
; 718  : 			// keep track of latch position
; 719  : 			pTarget->latched.bHasLatch = true;

	mov	ecx, DWORD PTR _pTarget$41[ebp]
	mov	BYTE PTR [ecx+197], 1

; 720  : 			pTarget->latched.q = pTarget->est.q;

	mov	edx, DWORD PTR _pTarget$41[ebp]
	add	edx, 104				; 00000068H
	mov	eax, DWORD PTR _pTarget$41[ebp]
	add	eax, 248				; 000000f8H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 721  : 			pTarget->latched.pos = pTarget->est.pos;

	mov	eax, DWORD PTR _pTarget$41[ebp]
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _pTarget$41[ebp]
	add	ecx, 236				; 000000ecH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN29@SolveDepen:

; 722  : 		}
; 723  : 	}

	jmp	$LN13@SolveDepen
$LN14@SolveDepen:

; 724  : 
; 725  : 	for( i = 0; i < m_pBoneSetup->GetNumIKChains(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@SolveDepen
$LN16@SolveDepen:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN18@SolveDepen:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN17@SolveDepen

; 726  : 	{
; 727  : 		ikchainresult_t *pChainResult = &chainResult[ i ];

	imul	eax, DWORD PTR _i$[ebp], 36
	lea	ecx, DWORD PTR _chainResult$[ebp+eax]
	mov	DWORD PTR _pChainResult$37[ebp], ecx

; 728  : 		const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$34[ebp], eax

; 729  : 
; 730  : 		if( pChainResult->flWeight > 0.0f )

	mov	ecx, DWORD PTR _pChainResult$37[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN33@SolveDepen

; 731  : 		{
; 732  : 			int bone0 = m_pBoneSetup->pIKLink( pchain, 0 )->bone;

	push	0
	mov	edx, DWORD PTR _pchain$34[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bone0$27[ebp], ecx

; 733  : 			int bone1 = m_pBoneSetup->pIKLink( pchain, 1 )->bone;

	push	1
	mov	edx, DWORD PTR _pchain$34[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bone1$26[ebp], ecx

; 734  : 			int bone2 = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	edx, DWORD PTR _pchain$34[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bone2$33[ebp], ecx

; 735  : 
; 736  : 			Vector tmp = boneToWorld[bone2].GetOrigin();

	lea	edx, DWORD PTR _tmp$17[ebp]
	push	edx
	imul	ecx, DWORD PTR _bone2$33[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin

; 737  : 			// m_pBoneSetup->debugLine( pChainResult->pos, tmp, 255, 255, 255, true, 0.1 );
; 738  : 
; 739  : 			// do exact IK solution
; 740  : 			// FIXME: once per link!
; 741  : 			if( m_pBoneSetup->SolveIK( pchain, pChainResult->pos, boneToWorld ))

	mov	eax, DWORD PTR _boneToWorld$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChainResult$37[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _pchain$34[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?SolveIK@CStudioBoneSetup@@AAE_NPBUmstudioikchain_t@@AAVVector@@PAVmatrix3x4@@@Z ; CStudioBoneSetup::SolveIK
	movzx	ecx, al
	test	ecx, ecx
	je	$LN31@SolveDepen

; 742  : 			{
; 743  : 				Vector p3 = boneToWorld[bone2].GetOrigin();

	lea	edx, DWORD PTR _p3$19[ebp]
	push	edx
	imul	ecx, DWORD PTR _bone2$33[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin

; 744  : 				// replace rotational component with IK result
; 745  : 				boneToWorld[bone2] = matrix3x4( p3, pChainResult->q );

	mov	eax, DWORD PTR _pChainResult$37[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _p3$19[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T46[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	imul	edi, DWORD PTR _bone2$33[ebp], 48
	add	edi, DWORD PTR _boneToWorld$[ebp]
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	rep movsd

; 746  : 
; 747  : 				// rebuild chain
; 748  : 				// FIXME: is this needed if everyone past this uses the boneToWorld array?
; 749  : 				m_pBoneSetup->SolveBone( bone2, boneToWorld, pos, q );

	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneToWorld$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bone2$33[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::SolveBone

; 750  : 				m_pBoneSetup->SolveBone( bone1, boneToWorld, pos, q );

	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _boneToWorld$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bone1$26[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::SolveBone

; 751  : 				m_pBoneSetup->SolveBone( bone0, boneToWorld, pos, q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _boneToWorld$[ebp]
	push	edx
	mov	eax, DWORD PTR _bone0$27[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?SolveBone@CStudioBoneSetup@@AAEXHPAVmatrix3x4@@QAVVector@@QAVVector4D@@@Z ; CStudioBoneSetup::SolveBone

; 752  : 			}
; 753  : 			else

	jmp	SHORT $LN33@SolveDepen
$LN31@SolveDepen:

; 754  : 			{
; 755  : 				// FIXME: need to invalidate the targets that forced this...
; 756  : 				if( pChainResult->target != -1 )

	mov	edx, DWORD PTR _pChainResult$37[ebp]
	cmp	DWORD PTR [edx], -1
	je	SHORT $LN33@SolveDepen

; 757  : 				{
; 758  : 					CIKTarget *pTarget = &m_target[pChainResult->target];

	mov	eax, DWORD PTR _pChainResult$37[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$30[ebp], eax

; 759  : 					QuaternionScale( pTarget->latched.deltaQ, 0.8f, pTarget->latched.deltaQ );

	mov	edx, DWORD PTR _pTarget$30[ebp]
	add	edx, 276				; 00000114H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pTarget$30[ebp]
	add	eax, 276				; 00000114H
	push	eax
	call	?QuaternionScale@@YAXABVVector4D@@MAAV1@@Z ; QuaternionScale

; 760  : 					pTarget->latched.deltaPos *= 0.8f;

	add	esp, 8
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pTarget$30[ebp]
	add	ecx, 264				; 00000108H
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$LN33@SolveDepen:

; 761  : 				}
; 762  : 			}
; 763  : 		}
; 764  : 	}

	jmp	$LN16@SolveDepen
$LN17@SolveDepen:

; 765  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SolveDependencies@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ENDP ; CIKContext::SolveDependencies
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_ikrule$1 = -180					; size = 132
tv175 = -48						; size = 8
_nIndex$2 = -40						; size = 4
_pchain$3 = -36						; size = 4
tv162 = -32						; size = 4
tv150 = -28						; size = 4
_dt$4 = -24						; size = 4
_bone$5 = -20						; size = 4
_ft$6 = -16						; size = 4
_i$ = -12						; size = 4
_this$ = -8						; size = 4
_pTarget$7 = -4						; size = 4
?AutoIKRelease@CIKContext@@QAEXXZ PROC			; CIKContext::AutoIKRelease
; _this$ = ecx

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 494  : 	int i;
; 495  : 
; 496  : 	for( i = 0; i < m_target.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@AutoIKRele
$LN2@AutoIKRele:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@AutoIKRele:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@AutoIKRele

; 497  : 	{
; 498  : 		CIKTarget *pTarget = &m_target[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$7[ebp], eax

; 499  : 
; 500  : 		float dt = m_flTime - pTarget->error.flTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTarget$7[ebp]
	movss	xmm0, DWORD PTR [edx+4136]
	subss	xmm0, DWORD PTR [eax+320]
	movss	DWORD PTR _dt$4[ebp], xmm0

; 501  : 
; 502  : 		if( pTarget->error.bInError || dt < 0.5f )

	mov	ecx, DWORD PTR _pTarget$7[ebp]
	movzx	edx, BYTE PTR [ecx+332]
	test	edx, edx
	jne	SHORT $LN6@AutoIKRele
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR _dt$4[ebp]
	jbe	$LN5@AutoIKRele
$LN6@AutoIKRele:

; 503  : 		{
; 504  : 			if( !pTarget->error.bInError )

	mov	eax, DWORD PTR _pTarget$7[ebp]
	movzx	ecx, BYTE PTR [eax+332]
	test	ecx, ecx
	jne	SHORT $LN7@AutoIKRele

; 505  : 			{
; 506  : 				pTarget->error.ramp = 0.0; 

	mov	edx, DWORD PTR _pTarget$7[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+328], xmm0

; 507  : 				pTarget->error.flErrorTime = pTarget->error.flTime;

	mov	eax, DWORD PTR _pTarget$7[ebp]
	mov	ecx, DWORD PTR _pTarget$7[ebp]
	mov	edx, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+324], edx

; 508  : 				pTarget->error.bInError = true;

	mov	eax, DWORD PTR _pTarget$7[ebp]
	mov	BYTE PTR [eax+332], 1
$LN7@AutoIKRele:

; 509  : 			}
; 510  : 
; 511  : 			float ft = m_flTime - pTarget->error.flErrorTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTarget$7[ebp]
	movss	xmm0, DWORD PTR [ecx+4136]
	subss	xmm0, DWORD PTR [edx+324]
	movss	DWORD PTR _ft$6[ebp], xmm0

; 512  : 
; 513  : 			if( dt < 0.25f )

	movss	xmm0, DWORD PTR __real@3e800000
	comiss	xmm0, DWORD PTR _dt$4[ebp]
	jbe	SHORT $LN8@AutoIKRele

; 514  : 			{
; 515  : 				pTarget->error.ramp = Q_min( pTarget->error.ramp + ft * 4.0f, 1.0f );

	movss	xmm0, DWORD PTR _ft$6[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	eax, DWORD PTR _pTarget$7[ebp]
	addss	xmm0, DWORD PTR [eax+328]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@AutoIKRele
	movss	xmm0, DWORD PTR _ft$6[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	ecx, DWORD PTR _pTarget$7[ebp]
	addss	xmm0, DWORD PTR [ecx+328]
	movss	DWORD PTR tv150[ebp], xmm0
	jmp	SHORT $LN21@AutoIKRele
$LN20@AutoIKRele:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv150[ebp], xmm0
$LN21@AutoIKRele:
	mov	edx, DWORD PTR _pTarget$7[ebp]
	movss	xmm0, DWORD PTR tv150[ebp]
	movss	DWORD PTR [edx+328], xmm0

; 516  : 			}
; 517  : 			else

	jmp	SHORT $LN9@AutoIKRele
$LN8@AutoIKRele:

; 518  : 			{
; 519  : 				pTarget->error.ramp = Q_max( pTarget->error.ramp - ft * 4.0f, 0.0f );

	movss	xmm0, DWORD PTR _ft$6[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	eax, DWORD PTR _pTarget$7[ebp]
	movss	xmm1, DWORD PTR [eax+328]
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@00000000
	jbe	SHORT $LN22@AutoIKRele
	movss	xmm0, DWORD PTR _ft$6[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	ecx, DWORD PTR _pTarget$7[ebp]
	movss	xmm1, DWORD PTR [ecx+328]
	subss	xmm1, xmm0
	movss	DWORD PTR tv162[ebp], xmm1
	jmp	SHORT $LN23@AutoIKRele
$LN22@AutoIKRele:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv162[ebp], xmm0
$LN23@AutoIKRele:
	mov	edx, DWORD PTR _pTarget$7[ebp]
	movss	xmm0, DWORD PTR tv162[ebp]
	movss	DWORD PTR [edx+328], xmm0
$LN9@AutoIKRele:

; 520  : 			}
; 521  : 
; 522  : 			if( pTarget->error.ramp > 0.0f )

	mov	eax, DWORD PTR _pTarget$7[ebp]
	movss	xmm0, DWORD PTR [eax+328]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN10@AutoIKRele

; 523  : 			{
; 524  : 				ikcontextikrule_t ikrule;

	lea	ecx, DWORD PTR _ikrule$1[ebp]
	call	??0ikcontextikrule_t@@QAE@XZ		; ikcontextikrule_t::ikcontextikrule_t

; 525  : 
; 526  : 				ikrule.chain = pTarget->chain;

	mov	ecx, DWORD PTR _pTarget$7[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ikrule$1[ebp+8], edx

; 527  : 				ikrule.bone = 0;

	mov	DWORD PTR _ikrule$1[ebp+12], 0

; 528  : 				ikrule.type = IK_RELEASE;

	mov	DWORD PTR _ikrule$1[ebp+4], 4

; 529  : 				ikrule.slot = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _ikrule$1[ebp+16], eax

; 530  : 				ikrule.flWeight = SimpleSpline( pTarget->error.ramp );

	mov	ecx, DWORD PTR _pTarget$7[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+328]
	movss	DWORD PTR [esp], xmm0
	call	?SimpleSpline@@YAMM@Z			; SimpleSpline
	add	esp, 4
	fstp	DWORD PTR _ikrule$1[ebp+92]

; 531  : 				ikrule.flRuleWeight = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ikrule$1[ebp+96], xmm0

; 532  : 				ikrule.latched = dt < 0.25 ? 0.0 : ikrule.flWeight;

	cvtss2sd xmm0, DWORD PTR _dt$4[ebp]
	movsd	xmm1, QWORD PTR __real@3fd0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN24@AutoIKRele
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv175[ebp], xmm0
	jmp	SHORT $LN25@AutoIKRele
$LN24@AutoIKRele:
	cvtss2sd xmm0, DWORD PTR _ikrule$1[ebp+92]
	movsd	QWORD PTR tv175[ebp], xmm0
$LN25@AutoIKRele:
	cvtsd2ss xmm0, QWORD PTR tv175[ebp]
	movss	DWORD PTR _ikrule$1[ebp+100], xmm0

; 533  : 
; 534  : 				// don't bother with AutoIKRelease if the bone isn't going to be calculated
; 535  : 				// this code is crashing for some unknown reason.
; 536  : 				if( pTarget->chain >= 0 && pTarget->chain < m_pBoneSetup->GetNumIKChains( ))

	mov	edx, DWORD PTR _pTarget$7[ebp]
	cmp	DWORD PTR [edx], 0
	jl	$LN12@AutoIKRele
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	mov	ecx, DWORD PTR _pTarget$7[ebp]
	cmp	DWORD PTR [ecx], eax
	jge	$LN12@AutoIKRele

; 537  : 				{
; 538  : 					const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( pTarget->chain );

	mov	edx, DWORD PTR _pTarget$7[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$3[ebp], eax

; 539  : 
; 540  : 					if( pchain != NULL )

	cmp	DWORD PTR _pchain$3[ebp], 0
	je	$LN14@AutoIKRele

; 541  : 					{
; 542  : 						int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	edx, DWORD PTR _pchain$3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bone$5[ebp], ecx

; 543  : 						if( bone >= 0 && bone < m_pBoneSetup->m_pStudioHeader->numbones )

	cmp	DWORD PTR _bone$5[ebp], 0
	jl	$LN16@AutoIKRele
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4040]
	mov	ecx, DWORD PTR [eax+18968]
	mov	edx, DWORD PTR _bone$5[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	SHORT $LN16@AutoIKRele

; 544  : 						{
; 545  : 							if( !m_pBoneSetup->IsBoneUsed( bone ))

	mov	eax, DWORD PTR _bone$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN18@AutoIKRele

; 546  : 							{
; 547  : 								pTarget->error.bInError = false;

	mov	eax, DWORD PTR _pTarget$7[ebp]
	mov	BYTE PTR [eax+332], 0

; 548  : 								continue;

	jmp	$LN2@AutoIKRele
$LN18@AutoIKRele:

; 549  : 							}
; 550  : 
; 551  : 							int nIndex = m_ikChainRule.Element( ikrule.chain ).AddToTail( );

	mov	ecx, DWORD PTR _ikrule$1[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?AddToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddToTail
	mov	DWORD PTR _nIndex$2[ebp], eax

; 552  : 							m_ikChainRule.Element( ikrule.chain ).Element( nIndex ) = ikrule;

	mov	edx, DWORD PTR _nIndex$2[ebp]
	push	edx
	mov	eax, DWORD PTR _ikrule$1[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	mov	ecx, 33					; 00000021H
	lea	esi, DWORD PTR _ikrule$1[ebp]
	mov	edi, eax
	rep movsd

; 553  : 						}
; 554  : 						else

	jmp	SHORT $LN17@AutoIKRele
$LN16@AutoIKRele:

; 555  : 						{
; 556  : 							m_pBoneSetup->debugMsg( "^2Warning:^7 AutoIKRelease (%s) out of range bone %d (%d)\n",

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4040]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _bone$5[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	mov	edx, DWORD PTR [ecx+18968]
	add	edx, 8
	push	edx
	push	OFFSET $SG17308
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4040]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 20					; 00000014H
$LN17@AutoIKRele:

; 557  : 							m_pBoneSetup->m_pStudioHeader->name, bone, m_pBoneSetup->m_pStudioHeader->numbones );
; 558  : 						}
; 559  : 					}
; 560  : 					else

	jmp	SHORT $LN15@AutoIKRele
$LN14@AutoIKRele:

; 561  : 					{
; 562  : 						m_pBoneSetup->debugMsg( "^2Warning:^7 AutoIKRelease (%s) got a NULL pchain %d\n",

	mov	eax, DWORD PTR _pTarget$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4040]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG17309
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4040]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4040]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
$LN15@AutoIKRele:

; 563  : 						m_pBoneSetup->m_pStudioHeader->name, pTarget->chain );
; 564  : 					}
; 565  : 				}
; 566  : 				else

	jmp	SHORT $LN13@AutoIKRele
$LN12@AutoIKRele:

; 567  : 				{
; 568  : 					m_pBoneSetup->debugMsg( "^2Warning:^7 AutoIKRelease (%s) got an out of range chain %d (%d)\n",

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	push	eax
	mov	eax, DWORD PTR _pTarget$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4040]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, 8
	push	ecx
	push	OFFSET $SG17310
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4040]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4040]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 20					; 00000014H
$LN13@AutoIKRele:

; 569  : 					m_pBoneSetup->m_pStudioHeader->name, pTarget->chain, m_pBoneSetup->GetNumIKChains( ));
; 570  : 				}
; 571  : 			}
; 572  : 			else

	jmp	SHORT $LN11@AutoIKRele
$LN10@AutoIKRele:

; 573  : 			{
; 574  : 				pTarget->error.bInError = false;

	mov	edx, DWORD PTR _pTarget$7[ebp]
	mov	BYTE PTR [edx+332], 0
$LN11@AutoIKRele:

; 575  : 			}
; 576  : 
; 577  : 			pTarget->error.flErrorTime = m_flTime;

	mov	eax, DWORD PTR _pTarget$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4136]
	mov	DWORD PTR [eax+324], edx
$LN5@AutoIKRele:

; 578  : 		}
; 579  : 	}

	jmp	$LN2@AutoIKRele
$LN3@AutoIKRele:

; 580  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?AutoIKRelease@CIKContext@@QAEXXZ ENDP			; CIKContext::AutoIKRelease
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -624						; size = 16
$T2 = -608						; size = 12
$T3 = -596						; size = 12
$T4 = -584						; size = 12
$T5 = -572						; size = 12
$T6 = -560						; size = 12
$T7 = -548						; size = 12
$T8 = -536						; size = 12
$T9 = -524						; size = 12
$T10 = -512						; size = 12
$T11 = -500						; size = 12
$T12 = -488						; size = 12
$T13 = -476						; size = 12
$T14 = -464						; size = 12
$T15 = -452						; size = 12
$T16 = -440						; size = 12
$T17 = -428						; size = 12
$T18 = -416						; size = 12
$T19 = -404						; size = 12
$T20 = -392						; size = 12
$T21 = -380						; size = 12
$T22 = -368						; size = 12
tv1623 = -356						; size = 8
tv1555 = -348						; size = 8
tv1507 = -340						; size = 8
tv1492 = -332						; size = 8
_p3$23 = -324						; size = 12
_d$24 = -312						; size = 4
_dt$25 = -308						; size = 12
_p2$26 = -296						; size = 12
_d4$27 = -284						; size = 4
_bone$28 = -280						; size = 4
tv422 = -276						; size = 4
tv397 = -272						; size = 4
tv334 = -268						; size = 4
_p1$29 = -264						; size = 12
_pchain$30 = -252					; size = 4
_latched$31 = -248					; size = 4
_dt$32 = -244						; size = 4
_pTarget$33 = -240					; size = 4
tv216 = -236						; size = 4
_j$ = -232						; size = 4
_d2$34 = -228						; size = 4
_d1$35 = -224						; size = 4
_pTarget$36 = -220					; size = 4
_i$ = -216						; size = 4
_this$ = -212						; size = 4
_pTarget$37 = -208					; size = 4
_pRule$38 = -204					; size = 4
_pTarget$39 = -200					; size = 4
_footTarget$40 = -196					; size = 48
$T41 = -148						; size = 48
_local$42 = -100					; size = 48
_worldFootpad$43 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_q$ = 12						; size = 4
_boneToWorld$ = 16					; size = 4
_pBoneSet$ = 20						; size = 4
?UpdateTargets@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z PROC ; CIKContext::UpdateTargets
; _this$ = ecx

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 624				; 00000270H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	int i, j;
; 279  : 
; 280  : 	for( i = 0; i < m_target.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@UpdateTarg
$LN2@UpdateTarg:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@UpdateTarg:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@UpdateTarg

; 281  : 	{
; 282  : 		m_target[i].est.flWeight = 0.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+88], xmm0

; 283  : 		m_target[i].est.latched = 1.0f;

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+68], xmm0

; 284  : 		m_target[i].est.release = 1.0f;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+72], xmm0

; 285  : 		m_target[i].est.height = 0.0f;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+76], xmm0

; 286  : 		m_target[i].est.floor = 0.0f;

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+80], xmm0

; 287  : 		m_target[i].est.radius = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+84], xmm0

; 288  : 		m_target[i].offset.pos.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	add	eax, 12					; 0000000cH
	mov	ecx, eax
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 289  : 		m_target[i].offset.q.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	add	eax, 24					; 00000018H
	mov	ecx, eax
	call	?Init@Vector4D@@QAEXMMMM@Z		; Vector4D::Init

; 290  : 	}

	jmp	$LN2@UpdateTarg
$LN3@UpdateTarg:

; 291  : 
; 292  : 	AutoIKRelease( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AutoIKRelease@CIKContext@@QAEXXZ	; CIKContext::AutoIKRelease

; 293  : 
; 294  : 	for( j = 0; j < m_ikChainRule.Count(); j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@UpdateTarg
$LN5@UpdateTarg:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@UpdateTarg:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Count@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QBEHXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Count
	cmp	DWORD PTR _j$[ebp], eax
	jge	$LN6@UpdateTarg

; 295  : 	{
; 296  : 		for( i = 0; i < m_ikChainRule.Element( j ).Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@UpdateTarg
$LN8@UpdateTarg:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@UpdateTarg:
	mov	edx, DWORD PTR _j$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?Count@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QBEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN9@UpdateTarg

; 297  : 		{
; 298  : 			ikcontextikrule_t *pRule = &m_ikChainRule.Element( j ).Element( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	mov	DWORD PTR _pRule$38[ebp], eax

; 299  : 
; 300  : 			switch( pRule->type )

	mov	edx, DWORD PTR _pRule$38[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR tv216[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv216[ebp], ecx
	cmp	DWORD PTR tv216[ebp], 3
	ja	$LN11@UpdateTarg
	mov	edx, DWORD PTR tv216[ebp]
	jmp	DWORD PTR $LN53@UpdateTarg[edx*4]
$LN16@UpdateTarg:

; 301  : 			{
; 302  : 			case IK_ATTACHMENT:
; 303  : 			case IK_GROUND:
; 304  : 				{
; 305  : 					matrix3x4	footTarget;

	lea	ecx, DWORD PTR _footTarget$40[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 306  : 					CIKTarget *pTarget = &m_target[pRule->slot];

	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$37[ebp], eax

; 307  : 					pTarget->chain = pRule->chain;

	mov	edx, DWORD PTR _pTarget$37[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 308  : 					pTarget->type = pRule->type;

	mov	edx, DWORD PTR _pTarget$37[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 309  : 
; 310  : 					if( pRule->type == IK_ATTACHMENT )

	mov	edx, DWORD PTR _pRule$38[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN17@UpdateTarg

; 311  : 						pTarget->offset.attachmentIndex = pRule->iAttachment;

	mov	eax, DWORD PTR _pTarget$37[ebp]
	mov	ecx, DWORD PTR _pRule$38[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN18@UpdateTarg
$LN17@UpdateTarg:

; 312  : 					else pTarget->offset.attachmentIndex = 0;

	mov	eax, DWORD PTR _pTarget$37[ebp]
	mov	DWORD PTR [eax+8], 0
$LN18@UpdateTarg:

; 313  : 
; 314  : 					if( pRule->flRuleWeight == 1.0f || pTarget->est.flWeight == 0.0f )

	mov	ecx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR [ecx+96]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@UpdateTarg
	mov	edx, DWORD PTR _pTarget$37[ebp]
	movss	xmm0, DWORD PTR [edx+88]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@UpdateTarg
$LN21@UpdateTarg:

; 315  : 					{
; 316  : 						pTarget->offset.q = pRule->q;

	mov	eax, DWORD PTR _pRule$38[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 317  : 						pTarget->offset.pos = pRule->pos;

	mov	ecx, DWORD PTR _pRule$38[ebp]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _pTarget$37[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 318  : 						pTarget->est.height = pRule->height;

	mov	edx, DWORD PTR _pTarget$37[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+76], ecx

; 319  : 						pTarget->est.floor = pRule->floor;

	mov	edx, DWORD PTR _pTarget$37[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+80], ecx

; 320  : 						pTarget->est.radius = pRule->radius;

	mov	edx, DWORD PTR _pTarget$37[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+84], ecx

; 321  : 						pTarget->est.latched = pRule->latched * pRule->flRuleWeight;

	mov	edx, DWORD PTR _pRule$38[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	movss	DWORD PTR [ecx+68], xmm0

; 322  : 						pTarget->est.release = pRule->release;

	mov	edx, DWORD PTR _pTarget$37[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR [edx+72], ecx

; 323  : 						pTarget->est.flWeight = pRule->flWeight * pRule->flRuleWeight;

	mov	edx, DWORD PTR _pRule$38[ebp]
	mov	eax, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR [edx+92]
	mulss	xmm0, DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	movss	DWORD PTR [ecx+88], xmm0

; 324  : 					}
; 325  : 					else

	jmp	$LN20@UpdateTarg
$LN19@UpdateTarg:

; 326  : 					{
; 327  : 						QuaternionSlerp( pTarget->offset.q, pRule->q, pRule->flRuleWeight, pTarget->offset.q );

	mov	edx, DWORD PTR _pTarget$37[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pRule$38[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _pTarget$37[ebp]
	add	edx, 24					; 00000018H
	push	edx
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H

; 328  : 						pTarget->offset.pos = Lerp( pRule->flRuleWeight, pTarget->offset.pos, pRule->pos );

	mov	eax, DWORD PTR _pRule$38[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??$Lerp@VVector@@@@YA?AVVector@@MABV0@0@Z ; Lerp<Vector>
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 329  : 						pTarget->est.height = Lerp( pRule->flRuleWeight, pTarget->est.height, pRule->height );

	mov	ecx, DWORD PTR _pRule$38[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _pTarget$37[ebp]
	add	edx, 76					; 0000004cH
	push	edx
	mov	eax, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR [esp], xmm0
	call	??$Lerp@M@@YAMMABM0@Z			; Lerp<float>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	fstp	DWORD PTR [ecx+76]

; 330  : 						pTarget->est.floor = Lerp( pRule->flRuleWeight, pTarget->est.floor, pRule->floor );

	mov	edx, DWORD PTR _pRule$38[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _pTarget$37[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+96]
	movss	DWORD PTR [esp], xmm0
	call	??$Lerp@M@@YAMMABM0@Z			; Lerp<float>
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _pTarget$37[ebp]
	fstp	DWORD PTR [edx+80]

; 331  : 						pTarget->est.radius = Lerp( pRule->flRuleWeight, pTarget->est.radius, pRule->radius );

	mov	eax, DWORD PTR _pRule$38[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [esp], xmm0
	call	??$Lerp@M@@YAMMABM0@Z			; Lerp<float>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _pTarget$37[ebp]
	fstp	DWORD PTR [eax+84]

; 332  : 						//pTarget->est.latched = Lerp( pRule->flRuleWeight, pTarget->est.latched, pRule->latched );
; 333  : 						pTarget->est.latched = Q_min( pTarget->est.latched, pRule->latched );

	mov	ecx, DWORD PTR _pRule$38[ebp]
	mov	edx, DWORD PTR _pTarget$37[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	comiss	xmm0, DWORD PTR [edx+68]
	jbe	SHORT $LN47@UpdateTarg
	mov	eax, DWORD PTR _pTarget$37[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	movss	DWORD PTR tv334[ebp], xmm0
	jmp	SHORT $LN48@UpdateTarg
$LN47@UpdateTarg:
	mov	ecx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR tv334[ebp], xmm0
$LN48@UpdateTarg:
	mov	edx, DWORD PTR _pTarget$37[ebp]
	movss	xmm0, DWORD PTR tv334[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 334  : 						pTarget->est.release = Lerp( pRule->flRuleWeight, pTarget->est.release, pRule->release );

	mov	eax, DWORD PTR _pRule$38[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	edx, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [esp], xmm0
	call	??$Lerp@M@@YAMMABM0@Z			; Lerp<float>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _pTarget$37[ebp]
	fstp	DWORD PTR [eax+72]

; 335  : 						pTarget->est.flWeight = Lerp( pRule->flRuleWeight, pTarget->est.flWeight, pRule->flWeight );

	mov	ecx, DWORD PTR _pRule$38[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	edx, DWORD PTR _pTarget$37[ebp]
	add	edx, 88					; 00000058H
	push	edx
	mov	eax, DWORD PTR _pRule$38[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR [esp], xmm0
	call	??$Lerp@M@@YAMMABM0@Z			; Lerp<float>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pTarget$37[ebp]
	fstp	DWORD PTR [ecx+88]
$LN20@UpdateTarg:

; 336  : 					}
; 337  : 
; 338  : 					if( pRule->type == IK_GROUND )

	mov	edx, DWORD PTR _pRule$38[ebp]
	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN22@UpdateTarg

; 339  : 					{
; 340  : 						pTarget->latched.deltaPos.z = 0.0f;

	mov	eax, DWORD PTR _pTarget$37[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+272], xmm0

; 341  : 						pTarget->est.pos.z = pTarget->est.floor + m_rootxform[3][2];

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4084				; 00000ff4H
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTarget$37[ebp]
	movss	xmm0, DWORD PTR [edx+80]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _pTarget$37[ebp]
	movss	DWORD PTR [eax+100], xmm0
$LN22@UpdateTarg:

; 342  : 					}
; 343  : 				}
; 344  : 			break;

	jmp	$LN11@UpdateTarg
$LN23@UpdateTarg:

; 345  : 			case IK_UNLATCH:
; 346  : 				{
; 347  : 					CIKTarget *pTarget = &m_target[pRule->slot];

	mov	ecx, DWORD PTR _pRule$38[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$33[ebp], eax

; 348  : 					if( pRule->latched > 0.0 ) pTarget->est.latched = 0.0f;

	mov	eax, DWORD PTR _pRule$38[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+100]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN24@UpdateTarg
	mov	ecx, DWORD PTR _pTarget$33[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+68], xmm0
	jmp	SHORT $LN25@UpdateTarg
$LN24@UpdateTarg:

; 349  : 					else pTarget->est.latched = Q_min( pTarget->est.latched, 1.0f - pRule->flWeight );

	mov	edx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+92]
	mov	eax, DWORD PTR _pTarget$33[ebp]
	comiss	xmm0, DWORD PTR [eax+68]
	jbe	SHORT $LN49@UpdateTarg
	mov	ecx, DWORD PTR _pTarget$33[ebp]
	movss	xmm0, DWORD PTR [ecx+68]
	movss	DWORD PTR tv397[ebp], xmm0
	jmp	SHORT $LN50@UpdateTarg
$LN49@UpdateTarg:
	mov	edx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+92]
	movss	DWORD PTR tv397[ebp], xmm0
$LN50@UpdateTarg:
	mov	eax, DWORD PTR _pTarget$33[ebp]
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR [eax+68], xmm0
$LN25@UpdateTarg:

; 350  : 				}
; 351  : 				break;

	jmp	$LN11@UpdateTarg
$LN26@UpdateTarg:

; 352  : 			case IK_RELEASE:
; 353  : 				{
; 354  : 					CIKTarget *pTarget = &m_target[pRule->slot];

	mov	ecx, DWORD PTR _pRule$38[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$36[ebp], eax

; 355  : 					if( pRule->latched > 0.0f ) pTarget->est.latched = 0.0f;

	mov	eax, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN27@UpdateTarg
	mov	ecx, DWORD PTR _pTarget$36[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+68], xmm0
	jmp	SHORT $LN28@UpdateTarg
$LN27@UpdateTarg:

; 356  : 					else pTarget->est.latched = Q_min( pTarget->est.latched, 1.0f - pRule->flWeight );

	mov	edx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+92]
	mov	eax, DWORD PTR _pTarget$36[ebp]
	comiss	xmm0, DWORD PTR [eax+68]
	jbe	SHORT $LN51@UpdateTarg
	mov	ecx, DWORD PTR _pTarget$36[ebp]
	movss	xmm0, DWORD PTR [ecx+68]
	movss	DWORD PTR tv422[ebp], xmm0
	jmp	SHORT $LN52@UpdateTarg
$LN51@UpdateTarg:
	mov	edx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+92]
	movss	DWORD PTR tv422[ebp], xmm0
$LN52@UpdateTarg:
	mov	eax, DWORD PTR _pTarget$36[ebp]
	movss	xmm0, DWORD PTR tv422[ebp]
	movss	DWORD PTR [eax+68], xmm0
$LN28@UpdateTarg:

; 357  : 					pTarget->est.flWeight = (pTarget->est.flWeight) * (1.0f - pRule->flWeight * pRule->flRuleWeight);

	mov	ecx, DWORD PTR _pRule$38[ebp]
	mov	edx, DWORD PTR _pRule$38[ebp]
	movss	xmm0, DWORD PTR [ecx+92]
	mulss	xmm0, DWORD PTR [edx+96]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _pTarget$36[ebp]
	mulss	xmm1, DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _pTarget$36[ebp]
	movss	DWORD PTR [ecx+88], xmm1
$LN11@UpdateTarg:

; 358  : 				}
; 359  : 				break;
; 360  : 			}
; 361  : 		}

	jmp	$LN8@UpdateTarg
$LN9@UpdateTarg:

; 362  : 	}

	jmp	$LN5@UpdateTarg
$LN6@UpdateTarg:

; 363  : 
; 364  : 	for( i = 0; i < m_target.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@UpdateTarg
$LN13@UpdateTarg:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN15@UpdateTarg:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN14@UpdateTarg

; 365  : 	{
; 366  : 		CIKTarget *pTarget = &m_target[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR _pTarget$39[ebp], eax

; 367  : 
; 368  : 		if( pTarget->est.flWeight > 0.0 )

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+88]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN29@UpdateTarg

; 369  : 		{
; 370  : 			const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( pTarget->chain );

	mov	edx, DWORD PTR _pTarget$39[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$30[ebp], eax

; 371  : 			int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	edx, DWORD PTR _pchain$30[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bone$28[ebp], ecx

; 372  : 
; 373  : 			// eval current ik'd bone
; 374  : 			BuildBoneChain( pos, q, bone, boneToWorld, pBoneSet );

	mov	edx, DWORD PTR _pBoneSet$[ebp]
	push	edx
	mov	eax, DWORD PTR _boneToWorld$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bone$28[ebp]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildBoneChain@CIKContext@@AAEXQBVVector@@QBVVector4D@@HPAVmatrix3x4@@PAE@Z ; CIKContext::BuildBoneChain

; 375  : 
; 376  : 			// xform IK target error into world space
; 377  : 			matrix3x4	local = matrix3x4( pTarget->offset.pos, pTarget->offset.q ).Invert();

	lea	ecx, DWORD PTR _local$42[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T41[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	ecx, eax
	call	?Invert@matrix3x4@@QBE?AV1@XZ		; matrix3x4::Invert

; 378  : 			matrix3x4	worldFootpad = boneToWorld[bone].ConcatTransforms( local );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _local$42[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR _worldFootpad$43[ebp]
	push	eax
	imul	ecx, DWORD PTR _bone$28[ebp], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms

; 379  : 
; 380  : 			if( pTarget->est.latched == 1.0f )

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [ecx+68]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@UpdateTarg

; 381  : 				pTarget->latched.bNeedsLatch = true;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	mov	BYTE PTR [edx+196], 1
	jmp	SHORT $LN31@UpdateTarg
$LN30@UpdateTarg:

; 382  : 			else pTarget->latched.bNeedsLatch = false;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	mov	BYTE PTR [eax+196], 0
$LN31@UpdateTarg:

; 383  : 
; 384  : 			// disable latched position if it looks invalid
; 385  : 			if( m_iFramecounter < 0 || pTarget->latched.iFramecounter < m_iFramecounter - 1
; 386  : 			|| pTarget->latched.iFramecounter > m_iFramecounter )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4132], 0
	jl	SHORT $LN33@UpdateTarg
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4132]
	sub	eax, 1
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	cmp	DWORD PTR [ecx+204], eax
	jl	SHORT $LN33@UpdateTarg
	mov	edx, DWORD PTR _pTarget$39[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+204]
	cmp	ecx, DWORD PTR [eax+4132]
	jle	SHORT $LN32@UpdateTarg
$LN33@UpdateTarg:

; 387  : 			{
; 388  : 				pTarget->latched.bHasLatch = false;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	mov	BYTE PTR [edx+197], 0

; 389  : 				pTarget->latched.influence = 0.0;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+200], xmm0
$LN32@UpdateTarg:

; 390  : 			}
; 391  : 
; 392  : 			pTarget->latched.iFramecounter = m_iFramecounter;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4132]
	mov	DWORD PTR [ecx+204], eax

; 393  : 
; 394  : 			// find ideal contact position
; 395  : 			pTarget->est.q = pTarget->ideal.q = worldFootpad.GetQuaternion();

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _worldFootpad$43[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 52					; 00000034H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 104				; 00000068H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 396  : 			pTarget->est.pos = pTarget->ideal.pos = worldFootpad.GetOrigin();

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	lea	ecx, DWORD PTR _worldFootpad$43[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 397  : 
; 398  : 			float latched = pTarget->est.latched;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _latched$31[ebp], xmm0

; 399  : 
; 400  : 			if( pTarget->latched.bHasLatch )

	mov	eax, DWORD PTR _pTarget$39[ebp]
	movzx	ecx, BYTE PTR [eax+197]
	test	ecx, ecx
	je	$LN34@UpdateTarg

; 401  : 			{
; 402  : 				if( pTarget->est.latched == 1.0f )

	mov	edx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN35@UpdateTarg

; 403  : 				{
; 404  : 					// keep track of latch position error from ideal contact position
; 405  : 					pTarget->latched.deltaPos = pTarget->latched.pos - pTarget->est.pos;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 92					; 0000005cH
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 236				; 000000ecH
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 264				; 00000108H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 406  : 					QuaternionSM( -1.0f, pTarget->est.q, pTarget->latched.q, pTarget->latched.deltaQ );

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 276				; 00000114H
	push	ecx
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 104				; 00000068H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	?QuaternionSM@@YAXMABVVector4D@@0AAV1@@Z ; QuaternionSM
	add	esp, 16					; 00000010H

; 407  : 					pTarget->est.q = pTarget->latched.q;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 248				; 000000f8H
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 104				; 00000068H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 408  : 					pTarget->est.pos = pTarget->latched.pos;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 236				; 000000ecH
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	$LN38@UpdateTarg
$LN35@UpdateTarg:

; 409  : 				}
; 410  : 				else if( pTarget->est.latched > 0.0f )

	mov	eax, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN37@UpdateTarg

; 411  : 				{
; 412  : 					// ramp out latch differences during decay phase of rule
; 413  : 					if( latched > 0 && latched < pTarget->latched.influence )

	movss	xmm0, DWORD PTR _latched$31[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN39@UpdateTarg
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	comiss	xmm0, DWORD PTR _latched$31[ebp]
	jbe	$LN39@UpdateTarg

; 414  : 					{
; 415  : 						// latching has decreased
; 416  : 						float dt = pTarget->latched.influence - latched;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	subss	xmm0, DWORD PTR _latched$31[ebp]
	movss	DWORD PTR _dt$32[ebp], xmm0

; 417  : 						if( pTarget->latched.influence > 0.0 )

	mov	eax, DWORD PTR _pTarget$39[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+200]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN40@UpdateTarg

; 418  : 							dt = dt / pTarget->latched.influence;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR _dt$32[ebp]
	divss	xmm0, DWORD PTR [ecx+200]
	movss	DWORD PTR _dt$32[ebp], xmm0
$LN40@UpdateTarg:

; 419  : 
; 420  : 						QuaternionScale( pTarget->latched.deltaQ, (1.0f - dt), pTarget->latched.deltaQ );

	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 276				; 00000114H
	push	edx
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dt$32[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 276				; 00000114H
	push	eax
	call	?QuaternionScale@@YAXABVVector4D@@MAAV1@@Z ; QuaternionScale
	add	esp, 12					; 0000000cH

; 421  : 						pTarget->latched.deltaPos *= (1.0f - dt);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dt$32[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 264				; 00000108H
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$LN39@UpdateTarg:

; 422  : 					}
; 423  : 
; 424  : 					// move ideal contact position by latched error factor
; 425  : 					pTarget->est.pos = pTarget->est.pos + pTarget->latched.deltaPos;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 264				; 00000108H
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 92					; 0000005cH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 426  : 					QuaternionMA( pTarget->est.q, 1, pTarget->latched.deltaQ, pTarget->est.q );

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 276				; 00000114H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 104				; 00000068H
	push	eax
	call	?QuaternionMA@@YAXABVVector4D@@M0AAV1@@Z ; QuaternionMA
	add	esp, 16					; 00000010H

; 427  : 					pTarget->latched.q = pTarget->est.q;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 248				; 000000f8H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 428  : 					pTarget->latched.pos = pTarget->est.pos;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 236				; 000000ecH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 429  : 				}
; 430  : 				else

	jmp	$LN38@UpdateTarg
$LN37@UpdateTarg:

; 431  : 				{
; 432  : 					pTarget->latched.bHasLatch = false;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	mov	BYTE PTR [eax+197], 0

; 433  : 					pTarget->latched.q = pTarget->est.q;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 248				; 000000f8H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 434  : 					pTarget->latched.pos = pTarget->est.pos;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 236				; 000000ecH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 435  : 					pTarget->latched.deltaPos.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 264				; 00000108H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 436  : 					pTarget->latched.deltaQ.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 276				; 00000114H
	call	?Init@Vector4D@@QAEXMMMM@Z		; Vector4D::Init
$LN38@UpdateTarg:

; 437  : 				}
; 438  : 				pTarget->latched.influence = latched;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR _latched$31[ebp]
	movss	DWORD PTR [eax+200], xmm0
$LN34@UpdateTarg:

; 439  : 			}
; 440  : 
; 441  : 			// check for illegal requests
; 442  : 			Vector p1, p2, p3;

	lea	ecx, DWORD PTR _p1$29[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _p2$26[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _p3$23[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 443  : 
; 444  : 			p1 = boneToWorld[m_pBoneSetup->pIKLink( pchain, 0 )->bone].GetOrigin(); // hip

	lea	ecx, DWORD PTR $T22[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pchain$30[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	imul	ecx, DWORD PTR [eax], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p1$29[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p1$29[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p1$29[ebp+8], eax

; 445  : 			p2 = boneToWorld[m_pBoneSetup->pIKLink( pchain, 1 )->bone].GetOrigin(); // knee

	lea	ecx, DWORD PTR $T21[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _pchain$30[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	imul	ecx, DWORD PTR [eax], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p2$26[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p2$26[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p2$26[ebp+8], eax

; 446  : 			p3 = boneToWorld[m_pBoneSetup->pIKLink( pchain, 2 )->bone].GetOrigin(); // foot

	lea	ecx, DWORD PTR $T20[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _pchain$30[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	imul	ecx, DWORD PTR [eax], 48
	add	ecx, DWORD PTR _boneToWorld$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p3$23[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p3$23[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _p3$23[ebp+8], eax

; 447  : 
; 448  : 			float d1 = (p2 - p1).Length();

	lea	ecx, DWORD PTR _p1$29[ebp]
	push	ecx
	lea	edx, DWORD PTR $T19[ebp]
	push	edx
	lea	ecx, DWORD PTR _p2$26[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _d1$35[ebp]

; 449  : 			float d2 = (p3 - p2).Length();

	lea	eax, DWORD PTR _p2$26[ebp]
	push	eax
	lea	ecx, DWORD PTR $T18[ebp]
	push	ecx
	lea	ecx, DWORD PTR _p3$23[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _d2$34[ebp]

; 450  : 
; 451  : 			if( pTarget->latched.bHasLatch )

	mov	edx, DWORD PTR _pTarget$39[ebp]
	movzx	eax, BYTE PTR [edx+197]
	test	eax, eax
	je	$LN45@UpdateTarg

; 452  : 			{
; 453  : 				float d4 = (p3 + pTarget->latched.deltaPos - p1).Length();

	lea	ecx, DWORD PTR _p1$29[ebp]
	push	ecx
	lea	edx, DWORD PTR $T17[ebp]
	push	edx
	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 264				; 00000108H
	push	eax
	lea	ecx, DWORD PTR $T16[ebp]
	push	ecx
	lea	ecx, DWORD PTR _p3$23[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _d4$27[ebp]

; 454  : 
; 455  : 				// unstick feet when distance is too great
; 456  : 				if(( d4 < fabs( d1 - d2 ) || d4 * 0.95f > d1 + d2 ) && pTarget->est.latched > 0.2f )

	cvtss2sd xmm0, DWORD PTR _d4$27[ebp]
	movss	xmm1, DWORD PTR _d1$35[ebp]
	subss	xmm1, DWORD PTR _d2$34[ebp]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv1623[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv1492[ebp]
	movsd	xmm0, QWORD PTR tv1492[ebp]
	movsd	xmm1, QWORD PTR tv1623[ebp]
	comisd	xmm0, xmm1
	ja	SHORT $LN43@UpdateTarg
	movss	xmm0, DWORD PTR _d4$27[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	movss	xmm1, DWORD PTR _d1$35[ebp]
	addss	xmm1, DWORD PTR _d2$34[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN42@UpdateTarg
$LN43@UpdateTarg:
	mov	edx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jbe	SHORT $LN42@UpdateTarg

; 457  : 				{
; 458  : 					pTarget->error.flTime = m_flTime;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4136]
	mov	DWORD PTR [eax+320], edx
$LN42@UpdateTarg:

; 459  : 				}
; 460  : 
; 461  : 				// unstick feet when angle is too great
; 462  : 				if( pTarget->est.latched > 0.2f )

	mov	eax, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jbe	SHORT $LN45@UpdateTarg

; 463  : 				{
; 464  : 					float d = fabs( pTarget->latched.deltaQ.w ) * 2.0f - 1.0f;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+288]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv1507[ebp]
	movsd	xmm0, QWORD PTR tv1507[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	subsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _d$24[ebp], xmm0

; 465  : 
; 466  : 					// FIXME: cos(45), make property of chain
; 467  : 					if( d < 0.707f )

	movss	xmm0, DWORD PTR __real@3f34fdf4
	comiss	xmm0, DWORD PTR _d$24[ebp]
	jbe	SHORT $LN45@UpdateTarg

; 468  : 					{
; 469  : 						pTarget->error.flTime = m_flTime;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4136]
	mov	DWORD PTR [edx+320], ecx
$LN45@UpdateTarg:

; 470  : 					}
; 471  : 				}
; 472  : 			}
; 473  : 
; 474  : 			Vector dt = pTarget->est.pos - p1;

	lea	edx, DWORD PTR _p1$29[ebp]
	push	edx
	lea	eax, DWORD PTR _dt$25[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 92					; 0000005cH
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 475  : 			pTarget->trace.hipToFoot = dt.Length();

	lea	ecx, DWORD PTR _dt$25[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	fstp	DWORD PTR [ecx+124]

; 476  : 			pTarget->trace.hipToKnee = d1;

	mov	edx, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR _d1$35[ebp]
	movss	DWORD PTR [edx+128], xmm0

; 477  : 			pTarget->trace.kneeToFoot = d2;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	movss	xmm0, DWORD PTR _d2$34[ebp]
	movss	DWORD PTR [eax+132], xmm0

; 478  : 			pTarget->trace.hip = p1;

	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 136				; 00000088H
	mov	edx, DWORD PTR _p1$29[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _p1$29[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _p1$29[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 479  : 			pTarget->trace.knee = p2;

	mov	eax, DWORD PTR _pTarget$39[ebp]
	add	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR _p2$26[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _p2$26[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p2$26[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 480  : 			dt = dt.Normalize();

	lea	edx, DWORD PTR $T15[ebp]
	push	edx
	lea	ecx, DWORD PTR _dt$25[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dt$25[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dt$25[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dt$25[ebp+8], eax

; 481  : 			pTarget->trace.closest = p1 + dt * ( fabs( d1 - d2 ) * 1.01f);

	movss	xmm0, DWORD PTR _d1$35[ebp]
	subss	xmm0, DWORD PTR _d2$34[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv1555[ebp]
	movsd	xmm0, QWORD PTR tv1555[ebp]
	mulsd	xmm0, QWORD PTR __real@3ff028f5c0000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T14[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dt$25[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	lea	ecx, DWORD PTR _p1$29[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 148				; 00000094H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 482  : 			pTarget->trace.farthest = p1 + dt * (d1 + d2) * 0.99;

	push	ecx
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _d1$35[ebp]
	addss	xmm0, DWORD PTR _d2$34[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	lea	ecx, DWORD PTR _dt$25[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	ecx, DWORD PTR _p1$29[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 172				; 000000acH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 483  : 			pTarget->trace.lowest = p1 + Vector( 0, 0, -1.0f ) * (d1 + d2) * 0.99f;

	push	ecx
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _d1$35[ebp]
	addss	xmm0, DWORD PTR _d2$34[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _p1$29[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pTarget$39[ebp]
	add	ecx, 184				; 000000b8H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN29@UpdateTarg:

; 484  : 			// pTarget->trace.endpos = pTarget->est.pos;
; 485  : 		}
; 486  : 	}

	jmp	$LN13@UpdateTarg
$LN14@UpdateTarg:

; 487  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN53@UpdateTarg:
	DD	$LN16@UpdateTarg
	DD	$LN26@UpdateTarg
	DD	$LN16@UpdateTarg
	DD	$LN23@UpdateTarg
?UpdateTargets@CIKContext@@QAEXQAVVector@@QAVVector4D@@QAVmatrix3x4@@PAE@Z ENDP ; CIKContext::UpdateTargets
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?ClearTargets@CIKContext@@QAEXXZ PROC			; CIKContext::ClearTargets
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	for( int i = 0; i < m_target.Count(); i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@ClearTarge
$LN2@ClearTarge:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@ClearTarge:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN1@ClearTarge

; 267  : 	{
; 268  : 		m_target[i].latched.iFramecounter = -9999;

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEAAVCIKTarget@@H@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::operator[]
	mov	DWORD PTR [eax+204], -9999		; ffffd8f1H

; 269  : 	}

	jmp	SHORT $LN2@ClearTarge
$LN1@ClearTarge:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearTargets@CIKContext@@QAEXXZ ENDP			; CIKContext::ClearTargets
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_ikrule$ = -208						; size = 132
_nIndex$1 = -76						; size = 4
_bone$2 = -72						; size = 4
_pchain$3 = -68						; size = 4
_cps$4 = -64						; size = 4
tv133 = -60						; size = 4
tv132 = -56						; size = 4
tv75 = -52						; size = 4
tv74 = -48						; size = 4
_i$ = -44						; size = 4
_this$ = -40						; size = 4
_weight$ = -36						; size = 16
_panim$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pseqdesc$ = 8						; size = 4
_iSequence$ = 12					; size = 4
_flCycle$ = 16						; size = 4
_flWeight$ = 20						; size = 4
?AddDependencies@CIKContext@@QAEXPAUmstudioseqdesc_t@@HMM@Z PROC ; CIKContext::AddDependencies
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 	int i;
; 69   : 
; 70   : 	if( m_pBoneSetup->GetNumIKChains() == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	test	eax, eax
	jne	SHORT $LN5@AddDepende

; 71   : 		return;

	jmp	$LN1@AddDepende
$LN5@AddDepende:

; 72   : 
; 73   : 	if( !FBitSet( pseqdesc->flags, STUDIO_IKRULES ))

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 2048				; 00000800H
	jne	SHORT $LN6@AddDepende

; 74   : 		return;

	jmp	$LN1@AddDepende
$LN6@AddDepende:

; 75   : 
; 76   : 	ikcontextikrule_t ikrule;

	lea	ecx, DWORD PTR _ikrule$[ebp]
	call	??0ikcontextikrule_t@@QAE@XZ		; ikcontextikrule_t::ikcontextikrule_t

; 77   : 
; 78   : 	// this shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
; 79   : 	flWeight = bound( 0.0f, flWeight, 1.0f );

	movss	xmm0, DWORD PTR _flWeight$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN24@AddDepende
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _flWeight$[ebp]
	jbe	SHORT $LN22@AddDepende
	movss	xmm0, DWORD PTR _flWeight$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN23@AddDepende
$LN22@AddDepende:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv74[ebp], xmm0
$LN23@AddDepende:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN25@AddDepende
$LN24@AddDepende:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
$LN25@AddDepende:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _flWeight$[ebp], xmm0

; 80   : 
; 81   : 	// unify this
; 82   : 	if( FBitSet( pseqdesc->flags, STUDIO_REALTIME ))

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 256				; 00000100H
	je	SHORT $LN7@AddDepende

; 83   : 	{
; 84   : 		float cps = m_pBoneSetup->LocalCPS( iSequence );

	mov	edx, DWORD PTR _iSequence$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?LocalCPS@CStudioBoneSetup@@QAEMH@Z	; CStudioBoneSetup::LocalCPS
	fstp	DWORD PTR _cps$4[ebp]

; 85   : 		flCycle = m_flTime * cps;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4136]
	mulss	xmm0, DWORD PTR _cps$4[ebp]
	movss	DWORD PTR _flCycle$[ebp], xmm0

; 86   : 		flCycle = flCycle - (int)flCycle;

	cvttss2si edx, DWORD PTR _flCycle$[ebp]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _flCycle$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _flCycle$[ebp], xmm1
	jmp	$LN12@AddDepende
$LN7@AddDepende:

; 87   : 	}
; 88   : 	else if( flCycle < 0 || flCycle >= 1 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _flCycle$[ebp]
	ja	SHORT $LN10@AddDepende
	movss	xmm0, DWORD PTR _flCycle$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	$LN12@AddDepende
$LN10@AddDepende:

; 89   : 	{
; 90   : 		if( FBitSet( pseqdesc->flags, STUDIO_LOOPING ))

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	SHORT $LN11@AddDepende

; 91   : 		{
; 92   : 			flCycle = flCycle - (int)flCycle;

	cvttss2si edx, DWORD PTR _flCycle$[ebp]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _flCycle$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _flCycle$[ebp], xmm1

; 93   : 			if( flCycle < 0.0f ) flCycle += 1.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _flCycle$[ebp]
	jbe	SHORT $LN13@AddDepende
	movss	xmm0, DWORD PTR _flCycle$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _flCycle$[ebp], xmm0
$LN13@AddDepende:

; 94   : 		}
; 95   : 		else

	jmp	SHORT $LN12@AddDepende
$LN11@AddDepende:

; 96   : 		{
; 97   : 			flCycle = bound( 0.0f, flCycle, 0.9999f );

	movss	xmm0, DWORD PTR _flCycle$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN28@AddDepende
	movss	xmm0, DWORD PTR __real@3f7ff972
	comiss	xmm0, DWORD PTR _flCycle$[ebp]
	jbe	SHORT $LN26@AddDepende
	movss	xmm0, DWORD PTR _flCycle$[ebp]
	movss	DWORD PTR tv132[ebp], xmm0
	jmp	SHORT $LN27@AddDepende
$LN26@AddDepende:
	movss	xmm0, DWORD PTR __real@3f7ff972
	movss	DWORD PTR tv132[ebp], xmm0
$LN27@AddDepende:
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN29@AddDepende
$LN28@AddDepende:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv133[ebp], xmm0
$LN29@AddDepende:
	movss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR _flCycle$[ebp], xmm0
$LN12@AddDepende:

; 98   : 		}
; 99   : 	}
; 100  : 
; 101  : 	mstudioanimdesc_t	*panim[4];
; 102  : 	float		weight[4];
; 103  : 
; 104  : 	m_pBoneSetup->LocalSeqAnims( iSequence, panim, weight );

	lea	eax, DWORD PTR _weight$[ebp]
	push	eax
	lea	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSequence$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?LocalSeqAnims@CStudioBoneSetup@@QAEXHQAPAUmstudioanimdesc_t@@PAM@Z ; CStudioBoneSetup::LocalSeqAnims

; 105  : 
; 106  : 	// g-cont. all the animations of current blend has equal set of ikrules and chains. see studiomdl->simplify.cpp for details
; 107  : 	for( i = 0; i < panim[0]->numikrules; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@AddDepende
$LN2@AddDepende:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@AddDepende:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _panim$[ebp+eax]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jge	$LN3@AddDepende

; 108  : 	{
; 109  : 		if( !m_pBoneSetup->IKSequenceError( iSequence, flCycle, i, panim, weight, &ikrule ))

	lea	eax, DWORD PTR _ikrule$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weight$[ebp]
	push	ecx
	lea	edx, DWORD PTR _panim$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _flCycle$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _iSequence$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?IKSequenceError@CStudioBoneSetup@@AAE_NHMHQAPAUmstudioanimdesc_t@@QAMPAUikcontextikrule_t@@@Z ; CStudioBoneSetup::IKSequenceError
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@AddDepende

; 110  : 			continue;

	jmp	SHORT $LN2@AddDepende
$LN14@AddDepende:

; 111  : 
; 112  : 		// don't add rule if the bone isn't going to be calculated
; 113  : 		const mstudioikchain_t *pchain = m_pBoneSetup->pIKChain( ikrule.chain );

	mov	ecx, DWORD PTR _ikrule$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKChain
	mov	DWORD PTR _pchain$3[ebp], eax

; 114  : 		int bone = m_pBoneSetup->pIKLink( pchain, 2 )->bone;

	push	2
	mov	eax, DWORD PTR _pchain$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ; CStudioBoneSetup::pIKLink
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _bone$2[ebp], edx

; 115  : 
; 116  : 		if( !m_pBoneSetup->IsBoneUsed( bone ))

	mov	eax, DWORD PTR _bone$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN15@AddDepende

; 117  : 			continue;

	jmp	$LN2@AddDepende
$LN15@AddDepende:

; 118  : 
; 119  : 		// or if its relative bone isn't going to be calculated
; 120  : 		if( ikrule.bone >= 0 && !m_pBoneSetup->IsBoneUsed( ikrule.bone ))

	cmp	DWORD PTR _ikrule$[ebp+12], 0
	jl	SHORT $LN16@AddDepende
	mov	eax, DWORD PTR _ikrule$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4040]
	call	?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z	; CStudioBoneSetup::IsBoneUsed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@AddDepende

; 121  : 			continue;

	jmp	$LN2@AddDepende
$LN16@AddDepende:

; 122  : 
; 123  : 		// FIXME: Brutal hackery to prevent a crash
; 124  : 		if( m_target.Count() == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	test	eax, eax
	jne	SHORT $LN17@AddDepende

; 125  : 		{
; 126  : 			m_target.SetSize( 12 );

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize

; 127  : 			memset( m_target.Base(), 0, sizeof( m_target[0] ) * m_target.Count());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	imul	eax, eax, 336
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 128  : 			ClearTargets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTargets@CIKContext@@QAEXXZ	; CIKContext::ClearTargets
$LN17@AddDepende:

; 129  : 		}
; 130  : 
; 131  : 		ikrule.flRuleWeight = flWeight;

	movss	xmm0, DWORD PTR _flWeight$[ebp]
	movss	DWORD PTR _ikrule$[ebp+96], xmm0

; 132  : 
; 133  : 		if( ikrule.flRuleWeight * ikrule.flWeight > 0.999f )

	movss	xmm0, DWORD PTR _ikrule$[ebp+96]
	mulss	xmm0, DWORD PTR _ikrule$[ebp+92]
	comiss	xmm0, DWORD PTR __real@3f7fbe77
	jbe	SHORT $LN20@AddDepende

; 134  : 		{
; 135  : 			if( ikrule.type != IK_UNLATCH )

	cmp	DWORD PTR _ikrule$[ebp+4], 6
	je	SHORT $LN20@AddDepende

; 136  : 			{
; 137  : 				// clear out chain if rule is 100%
; 138  : 				m_ikChainRule.Element( ikrule.chain ).RemoveAll( );

	mov	ecx, DWORD PTR _ikrule$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?RemoveAll@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEXXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::RemoveAll

; 139  : 				if( ikrule.type == IK_RELEASE )

	cmp	DWORD PTR _ikrule$[ebp+4], 4
	jne	SHORT $LN20@AddDepende

; 140  : 					continue;

	jmp	$LN2@AddDepende
$LN20@AddDepende:

; 141  : 			}
; 142  : 		}
; 143  : 
; 144  :  		int nIndex = m_ikChainRule.Element( ikrule.chain ).AddToTail( );

	mov	edx, DWORD PTR _ikrule$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?AddToTail@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEHXZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::AddToTail
	mov	DWORD PTR _nIndex$1[ebp], eax

; 145  :   		m_ikChainRule.Element( ikrule.chain ).Element( nIndex ) = ikrule;

	mov	eax, DWORD PTR _nIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ikrule$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?Element@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEAAV?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::Element
	mov	ecx, eax
	call	?Element@?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAEAAUikcontextikrule_t@@H@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::Element
	mov	ecx, 33					; 00000021H
	lea	esi, DWORD PTR _ikrule$[ebp]
	mov	edi, eax
	rep movsd

; 146  : 	}

	jmp	$LN2@AddDepende
$LN3@AddDepende:
$LN1@AddDepende:

; 147  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddDependencies@CIKContext@@QAEXPAUmstudioseqdesc_t@@HMM@Z ENDP ; CIKContext::AddDependencies
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T1 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_pBoneSetup$ = 8					; size = 4
_angles$ = 12						; size = 4
_pos$ = 16						; size = 4
_flTime$ = 20						; size = 4
_iFramecounter$ = 24					; size = 4
?Init@CIKContext@@QAEXPBVCStudioBoneSetup@@ABVVector@@1MH@Z PROC ; CIKContext::Init
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	m_ikChainRule.RemoveAll(); // m_numikrules = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?RemoveAll@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXXZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::RemoveAll

; 42   : 	m_pBoneSetup = (CStudioBoneSetup *)pBoneSetup;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pBoneSetup$[ebp]
	mov	DWORD PTR [eax+4040], ecx

; 43   : 
; 44   : 	if( m_pBoneSetup->GetNumIKChains( ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	test	eax, eax
	je	SHORT $LN2@Init

; 45   : 	{
; 46   : 		m_ikChainRule.SetSize( m_pBoneSetup->GetNumIKChains() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4040]
	call	?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ; CStudioBoneSetup::GetNumIKChains
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	?SetSize@?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAEXH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::SetSize

; 47   : 
; 48   : 		// FIXME: Brutal hackery to prevent a crash
; 49   : 		if( m_target.Count() == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	test	eax, eax
	jne	SHORT $LN4@Init

; 50   : 		{
; 51   : 			m_target.SetSize( 12 );

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize

; 52   : 			memset( m_target.Base(), 0, sizeof( m_target[0] ) * m_target.Count() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QBEHXZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Count
	imul	ecx, eax, 336
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEPAVCIKTarget@@XZ ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::Base
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 			ClearTargets();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTargets@CIKContext@@QAEXXZ	; CIKContext::ClearTargets
$LN4@Init:

; 54   : 		}
; 55   : 	}
; 56   : 	else

	jmp	SHORT $LN3@Init
$LN2@Init:

; 57   : 	{
; 58   : 		m_target.SetSize( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize
$LN3@Init:

; 59   : 	}
; 60   : 
; 61   : 	m_rootxform = matrix3x4( pos, angles );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 4084				; 00000ff4H
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	rep movsd

; 62   : 	m_iFramecounter = iFramecounter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iFramecounter$[ebp]
	mov	DWORD PTR [ecx+4132], edx

; 63   : 	m_flTime = flTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _flTime$[ebp]
	movss	DWORD PTR [eax+4136], xmm0

; 64   : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Init@CIKContext@@QAEXPBVCStudioBoneSetup@@ABVVector@@1MH@Z ENDP ; CIKContext::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CIKContext@@QAE@XZ PROC				; CIKContext::CIKContext
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CIKContext@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@HH@Z ; CUtlArrayFixed<CIKTarget,12>::CUtlArrayFixed<CIKTarget,12>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	call	??0?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@HH@Z ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	call	??0?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@HH@Z ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4084				; 00000ff4H
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 32   : 	m_target.EnsureCapacity( 12 ); // FIXME: this sucks, shouldn't it be grown?

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnsureCapacity@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::EnsureCapacity

; 33   : 	m_iFramecounter = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4132], -1

; 34   : 	m_pBoneSetup = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4040], 0

; 35   : 	m_flTime = -1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+4136], xmm0

; 36   : 	m_target.SetSize( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CUtlArray@VCIKTarget@@V?$CUtlMemoryFixed@VCIKTarget@@$0M@$0A@@@@@QAEXH@Z ; CUtlArray<CIKTarget,CUtlMemoryFixed<CIKTarget,12,0> >::SetSize

; 37   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CIKContext@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CUtlArrayFixed@VCIKTarget@@$0M@@@QAE@XZ
__unwindfunclet$??0CIKContext@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	jmp	??1?$CUtlArray@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@V?$CUtlMemory@V?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@H@@@@QAE@XZ ; CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >::~CUtlArray<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,CUtlMemory<CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >,int> >
__unwindfunclet$??0CIKContext@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4064				; 00000fe0H
	jmp	??1?$CUtlArray@Uikcontextikrule_t@@V?$CUtlMemory@Uikcontextikrule_t@@H@@@@QAE@XZ ; CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >::~CUtlArray<ikcontextikrule_t,CUtlMemory<ikcontextikrule_t,int> >
__ehhandler$??0CIKContext@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CIKContext@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CIKContext@@QAE@XZ ENDP				; CIKContext::CIKContext
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.h
;	COMDAT ??0ikcontextikrule_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ikcontextikrule_t@@QAE@XZ PROC			; ikcontextikrule_t::ikcontextikrule_t, COMDAT
; _this$ = ecx

; 160  : 	ikcontextikrule_t() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ikcontextikrule_t@@QAE@XZ ENDP			; ikcontextikrule_t::ikcontextikrule_t
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ikchainresult_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ikchainresult_t@@QAE@XZ PROC				; ikchainresult_t::ikchainresult_t, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ikchainresult_t@@QAE@XZ ENDP				; ikchainresult_t::ikchainresult_t
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0CIKTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CIKTarget@@QAE@XZ PROC				; CIKTarget::CIKTarget, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0x2@CIKTarget@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0x3@CIKTarget@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??0x4@CIKTarget@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0x5@CIKTarget@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196				; 000000c4H
	call	??0x1@CIKTarget@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CIKTarget@@QAE@XZ ENDP				; CIKTarget::CIKTarget
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0x1@CIKTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0x1@CIKTarget@@QAE@XZ PROC				; CIKTarget::x1::x1, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0x1@CIKTarget@@QAE@XZ ENDP				; CIKTarget::x1::x1
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0x5@CIKTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0x5@CIKTarget@@QAE@XZ PROC				; CIKTarget::x5::x5, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0x5@CIKTarget@@QAE@XZ ENDP				; CIKTarget::x5::x5
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0x4@CIKTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0x4@CIKTarget@@QAE@XZ PROC				; CIKTarget::x4::x4, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0x4@CIKTarget@@QAE@XZ ENDP				; CIKTarget::x4::x4
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0x3@CIKTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0x3@CIKTarget@@QAE@XZ PROC				; CIKTarget::x3::x3, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0x3@CIKTarget@@QAE@XZ ENDP				; CIKTarget::x3::x3
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0x2@CIKTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0x2@CIKTarget@@QAE@XZ PROC				; CIKTarget::x2::x2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0x2@CIKTarget@@QAE@XZ ENDP				; CIKTarget::x2::x2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_deltaPos$ = 8						; size = 4
_deltaAngles$ = 12					; size = 4
?MoveReferenceFrame@CIKTarget@@QAEXAAVVector@@0@Z PROC	; CIKTarget::MoveReferenceFrame
; _this$ = ecx

; 1052 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1053 : 	est.pos -= deltaPos;

	mov	eax, DWORD PTR _deltaPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 1054 : 	latched.pos -= deltaPos;

	mov	ecx, DWORD PTR _deltaPos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 1055 : 	offset.pos -= deltaPos;

	mov	edx, DWORD PTR _deltaPos$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 1056 : 	ideal.pos -= deltaPos;

	mov	eax, DWORD PTR _deltaPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 1057 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MoveReferenceFrame@CIKTarget@@QAEXAAVVector@@0@Z ENDP	; CIKTarget::MoveReferenceFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IKFailed@CIKTarget@@QAEXXZ PROC			; CIKTarget::IKFailed
; _this$ = ecx

; 1038 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 	latched.deltaPos.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 1040 : 	latched.deltaQ.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 276				; 00000114H
	call	?Init@Vector4D@@QAEXMMMM@Z		; Vector4D::Init

; 1041 : 	latched.pos = ideal.pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1042 : 	latched.q = ideal.q;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 248				; 000000f8H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 1043 : 	est.latched = 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+68], xmm0

; 1044 : 	est.flWeight = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+88], xmm0

; 1045 : 	est.onWorld = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+120], 0

; 1046 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IKFailed@CIKTarget@@QAEXXZ ENDP			; CIKTarget::IKFailed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsActive@CIKTarget@@QAE_NXZ PROC			; CIKTarget::IsActive
; _this$ = ecx

; 1030 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1031 : 	return (est.flWeight > 0.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@IsActive
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsActive
$LN3@IsActive:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsActive:
	mov	al, BYTE PTR tv67[ebp]

; 1032 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsActive@CIKTarget@@QAE_NXZ ENDP			; CIKTarget::IsActive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bOnWorld$ = 8						; size = 1
?SetOnWorld@CIKTarget@@QAEX_N@Z PROC			; CIKTarget::SetOnWorld
; _this$ = ecx

; 1022 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1023 : 	est.onWorld = bOnWorld;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bOnWorld$[ebp]
	mov	BYTE PTR [eax+120], cl

; 1024 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetOnWorld@CIKTarget@@QAEX_N@Z ENDP			; CIKTarget::SetOnWorld
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
tv157 = -16						; size = 8
_tan$1 = -8						; size = 4
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
_normal$ = 12						; size = 4
?SetPosWithNormalOffset@CIKTarget@@QAEXABVVector@@0@Z PROC ; CIKTarget::SetPosWithNormalOffset
; _this$ = ecx

; 997  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 	// assume it's a disc edge intersecting with the floor, so try to estimate the z location of the center
; 999  : 	est.pos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 1000 : 
; 1001 : 	if( normal.z > 0.9999f )

	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR __real@3f7ff972
	jbe	SHORT $LN2@SetPosWith

; 1002 : 	{
; 1003 : 		return;

	jmp	$LN1@SetPosWith
	jmp	$LN5@SetPosWith
$LN2@SetPosWith:

; 1004 : 	}
; 1005 : 	else if( normal.z > 0.707 )

	mov	eax, DWORD PTR _normal$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+8]
	comisd	xmm0, QWORD PTR __real@3fe69fbe76c8b439
	jbe	SHORT $LN4@SetPosWith

; 1006 : 	{
; 1007 : 		// clamp at 45 degrees
; 1008 : 		// tan == sin / cos
; 1009 : 		float tan = sqrt( 1.0f - normal.z * normal.z ) / normal.z;

	mov	ecx, DWORD PTR _normal$[ebp]
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx+8]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR tv157[ebp]
	mov	eax, DWORD PTR _normal$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+8]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _tan$1[ebp], xmm0

; 1010 : 		est.pos.z = est.pos.z - est.radius * tan;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+84]
	mulss	xmm0, DWORD PTR _tan$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+100]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+100], xmm1

; 1011 : 	}
; 1012 : 	else

	jmp	SHORT $LN5@SetPosWith
$LN4@SetPosWith:

; 1013 : 	{
; 1014 : 		est.pos.z = est.pos.z - est.radius;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	subss	xmm0, DWORD PTR [edx+84]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+100], xmm0
$LN5@SetPosWith:
$LN1@SetPosWith:

; 1015 : 	}
; 1016 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetPosWithNormalOffset@CIKTarget@@QAEXABVVector@@0@Z ENDP ; CIKTarget::SetPosWithNormalOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -132						; size = 16
$T2 = -116						; size = 12
$T3 = -104						; size = 12
$T4 = -92						; size = 12
_forward$ = -80						; size = 12
_right$ = -68						; size = 12
_this$ = -56						; size = 4
_m1$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_normal$ = 8						; size = 4
?SetNormal@CIKTarget@@QAEXABVVector@@@Z PROC		; CIKTarget::SetNormal
; _this$ = ecx

; 976  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 977  : 	// recalculate foot angle based on slope of surface
; 978  : 	matrix3x4 m1 = matrix3x4( g_vecZero, est.q );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _m1$[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4

; 979  : 	Vector forward, right;

	lea	ecx, DWORD PTR _forward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 980  : 
; 981  : 	right = m1.GetRight();

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m1$[ebp]
	call	?GetRight@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetRight
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _right$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _right$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _right$[ebp+8], edx

; 982  : 	forward = CrossProduct( right, normal );

	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _forward$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _forward$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _forward$[ebp+8], eax

; 983  : 	right = CrossProduct( normal, forward );

	lea	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	mov	edx, DWORD PTR _normal$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _right$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _right$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _right$[ebp+8], eax

; 984  : 
; 985  : 	m1.SetForward( forward );

	lea	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m1$[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 986  : 	m1.SetRight( right );

	lea	edx, DWORD PTR _right$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m1$[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 987  : 	m1.SetUp( normal );

	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m1$[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 988  : 
; 989  : 	est.q = m1.GetQuaternion();

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m1$[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 104				; 00000068H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 990  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNormal@CIKTarget@@QAEXABVVector@@@Z ENDP		; CIKTarget::SetNormal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_q$ = 8							; size = 4
?SetQuaternion@CIKTarget@@QAEXABVVector4D@@@Z PROC	; CIKTarget::SetQuaternion
; _this$ = ecx

; 967  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 	est.q = q;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetQuaternion@CIKTarget@@QAEXABVVector4D@@@Z ENDP	; CIKTarget::SetQuaternion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_angles$ = 8						; size = 4
?SetAngles@CIKTarget@@QAEXABVVector@@@Z PROC		; CIKTarget::SetAngles
; _this$ = ecx

; 959  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 960  : 	AngleQuaternion( angles, est.q );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	call	?AngleQuaternion@@YAXABVVector@@AAVVector4D@@@Z ; AngleQuaternion
	add	esp, 8

; 961  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetAngles@CIKTarget@@QAEXABVVector@@@Z ENDP		; CIKTarget::SetAngles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?SetPos@CIKTarget@@QAEXABVVector@@@Z PROC		; CIKTarget::SetPos
; _this$ = ecx

; 951  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 952  : 	est.pos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 953  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPos@CIKTarget@@QAEXABVVector@@@Z ENDP		; CIKTarget::SetPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
$T1 = -324						; size = 16
$T2 = -308						; size = 12
_this$ = -296						; size = 4
$T3 = -292						; size = 48
$T4 = -244						; size = 48
_in$ = -196						; size = 48
_tmp2$ = -148						; size = 48
_out$ = -100						; size = 48
_tmp1$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_entindex$ = 8						; size = 4
_pos$ = 12						; size = 4
_angles$ = 16						; size = 4
?UpdateOwner@CIKTarget@@QAEXHABVVector@@0@Z PROC	; CIKTarget::UpdateOwner
; _this$ = ecx

; 932  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 933  : 	if( pos == latched.absOrigin && angles == latched.absAngles )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN2@UpdateOwne
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	push	ecx
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN2@UpdateOwne

; 934  : 		return;

	jmp	$LN1@UpdateOwne
$LN2@UpdateOwne:

; 935  : 
; 936  : 	matrix3x4	in = matrix3x4( pos, angles );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4

; 937  : 	matrix3x4	out = matrix3x4( latched.absOrigin, latched.absAngles ).Invert();

	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@0M@Z	; matrix3x4::matrix3x4
	mov	ecx, eax
	call	?Invert@matrix3x4@@QBE?AV1@XZ		; matrix3x4::Invert

; 938  : 
; 939  : 	matrix3x4	tmp1 = matrix3x4( latched.pos, latched.q );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 236				; 000000ecH
	push	edx
	lea	ecx, DWORD PTR _tmp1$[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4

; 940  : 	matrix3x4 tmp2 = out.ConcatTransforms( tmp1 );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _tmp1$[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _tmp2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _out$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms

; 941  : 	tmp1 = in.ConcatTransforms( tmp2 );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _tmp2$[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _tmp1$[ebp]
	rep movsd

; 942  : 
; 943  : 	latched.q = tmp1.GetQuaternion(); 

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmp1$[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 248				; 000000f8H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 944  : 	latched.pos = tmp1.GetOrigin();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmp1$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 236				; 000000ecH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$LN1@UpdateOwne:

; 945  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?UpdateOwner@CIKTarget@@QAEXHABVVector@@0@Z ENDP	; CIKTarget::UpdateOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CIKTarget@@QAEHXZ PROC			; CIKTarget::GetOwner
; _this$ = ecx

; 924  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 925  : 	return latched.owner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+208]

; 926  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CIKTarget@@QAEHXZ ENDP			; CIKTarget::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearOwner@CIKTarget@@QAEXXZ PROC			; CIKTarget::ClearOwner
; _this$ = ecx

; 916  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 917  : 	latched.owner = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+208], -1

; 918  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearOwner@CIKTarget@@QAEXXZ ENDP			; CIKTarget::ClearOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\ikcontext.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_entindex$ = 8						; size = 4
_pos$ = 12						; size = 4
_angles$ = 16						; size = 4
?SetOwner@CIKTarget@@QAEXHABVVector@@0@Z PROC		; CIKTarget::SetOwner
; _this$ = ecx

; 906  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 907  : 	latched.owner = entindex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _entindex$[ebp]
	mov	DWORD PTR [eax+208], ecx

; 908  : 	latched.absOrigin = pos;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 212				; 000000d4H
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 909  : 	latched.absAngles = angles;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 910  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetOwner@CIKTarget@@QAEXHABVVector@@0@Z ENDP		; CIKTarget::SetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8					; size = 4
_nGrowSize$ = 12					; size = 4
_nNewSize$ = 16						; size = 4
_nBytesItem$ = 20					; size = 4
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $LN4@UtlMemory_

; 530  : 	{ 
; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 532  : 	}
; 533  : 	else 

	jmp	SHORT $LN5@UtlMemory_
$LN4@UtlMemory_:

; 534  : 	{
; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $LN2@UtlMemory_

; 536  : 		{
; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$LN2@UtlMemory_:

; 539  : 		}
; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $LN5@UtlMemory_

; 542  : 		{
; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $LN2@UtlMemory_
$LN5@UtlMemory_:

; 553  : 	}
; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

	push	ebp
	mov	ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 188  :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z
_TEXT	SEGMENT
_pbone$ = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -1						; size = 1
_iBone$ = 8						; size = 4
?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z PROC		; CStudioBoneSetup::IsBoneUsed, COMDAT
; _this$ = ecx

; 208  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 		mstudiobone_t *pbone = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	add	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _pbone$[ebp], eax

; 210  : 
; 211  : 		if( iBone != -1 && m_iBoneMask != 0 )

	cmp	DWORD PTR _iBone$[ebp], -1
	je	SHORT $LN2@IsBoneUsed
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+528], 0
	je	SHORT $LN2@IsBoneUsed

; 212  : 			return (FBitSet( pbone[iBone].flags, m_iBoneMask )) ? true : false;

	imul	edx, DWORD PTR _iBone$[ebp], 112
	mov	eax, DWORD PTR _pbone$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx+36]
	and	edx, DWORD PTR [ecx+528]
	je	SHORT $LN4@IsBoneUsed
	mov	BYTE PTR tv77[ebp], 1
	jmp	SHORT $LN5@IsBoneUsed
$LN4@IsBoneUsed:
	mov	BYTE PTR tv77[ebp], 0
$LN5@IsBoneUsed:
	mov	al, BYTE PTR tv77[ebp]
	jmp	SHORT $LN1@IsBoneUsed
$LN2@IsBoneUsed:

; 213  : 		return true;

	mov	al, 1
$LN1@IsBoneUsed:

; 214  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsBoneUsed@CStudioBoneSetup@@QAE_NH@Z ENDP		; CStudioBoneSetup::IsBoneUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ
_TEXT	SEGMENT
_phdr2$ = -8						; size = 4
_this$ = -4						; size = 4
?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ PROC	; CStudioBoneSetup::GetNumIKAutoplayLocks, COMDAT
; _this$ = ecx

; 172  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 174  : 
; 175  : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $LN2@GetNumIKAu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $LN2@GetNumIKAu

; 176  : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$LN2@GetNumIKAu:

; 177  : 
; 178  : 		if( phdr2 && phdr2->numikautoplaylocks > 0 )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $LN3@GetNumIKAu
	mov	edx, DWORD PTR _phdr2$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jle	SHORT $LN3@GetNumIKAu

; 179  : 			return phdr2->numikautoplaylocks;

	mov	eax, DWORD PTR _phdr2$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN1@GetNumIKAu
$LN3@GetNumIKAu:

; 180  : 		return 0; // no IK autoplay locks

	xor	eax, eax
$LN1@GetNumIKAu:

; 181  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumIKAutoplayLocks@CStudioBoneSetup@@QAEHXZ ENDP	; CStudioBoneSetup::GetNumIKAutoplayLocks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?GetNumIKChains@CStudioBoneSetup@@QAEHXZ
_TEXT	SEGMENT
_phdr2$ = -8						; size = 4
_this$ = -4						; size = 4
?GetNumIKChains@CStudioBoneSetup@@QAEHXZ PROC		; CStudioBoneSetup::GetNumIKChains, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 162  : 
; 163  : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $LN2@GetNumIKCh
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $LN2@GetNumIKCh

; 164  : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$LN2@GetNumIKCh:

; 165  : 
; 166  : 		if( phdr2 && phdr2->numikchains > 0 )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $LN3@GetNumIKCh
	mov	edx, DWORD PTR _phdr2$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN3@GetNumIKCh

; 167  : 			return phdr2->numikchains;

	mov	eax, DWORD PTR _phdr2$[ebp]
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN1@GetNumIKCh
$LN3@GetNumIKCh:

; 168  : 		return 0; // no IK chains

	xor	eax, eax
$LN1@GetNumIKCh:

; 169  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumIKChains@CStudioBoneSetup@@QAEHXZ ENDP		; CStudioBoneSetup::GetNumIKChains
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?pIKLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@PBUmstudioseqdesc_t@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pseqdesc$ = 8						; size = 4
_lock$ = 12						; size = 4
?pIKLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@PBUmstudioseqdesc_t@@H@Z PROC ; CStudioBoneSetup::pIKLock, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		if( !pseqdesc || pseqdesc->iklockindex <= 0 )

	cmp	DWORD PTR _pseqdesc$[ebp], 0
	je	SHORT $LN3@pIKLock
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jg	SHORT $LN2@pIKLock
$LN3@pIKLock:

; 112  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pIKLock
$LN2@pIKLock:

; 113  : 		return (mstudioiklock_t *)((byte *)m_pStudioHeader + pseqdesc->iklockindex) + lock;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+18968]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _lock$[ebp]
	shl	ecx, 5
	add	eax, ecx
$LN1@pIKLock:

; 114  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?pIKLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@PBUmstudioseqdesc_t@@H@Z ENDP ; CStudioBoneSetup::pIKLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z
_TEXT	SEGMENT
_phdr2$ = -8						; size = 4
_this$ = -4						; size = 4
_pchain$ = 8						; size = 4
_link$ = 12						; size = 4
?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z PROC ; CStudioBoneSetup::pIKLink, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 99   : 
; 100  : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $LN2@pIKLink
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $LN2@pIKLink

; 101  : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$LN2@pIKLink:

; 102  : 
; 103  : 		if( phdr2 && link >= 0 && link < pchain->numlinks )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $LN3@pIKLink
	cmp	DWORD PTR _link$[ebp], 0
	jl	SHORT $LN3@pIKLink
	mov	edx, DWORD PTR _pchain$[ebp]
	mov	eax, DWORD PTR _link$[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jge	SHORT $LN3@pIKLink

; 104  : 			return (mstudioiklink_t *)((byte *)m_pStudioHeader + pchain->linkindex) + link;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+18968]
	mov	edx, DWORD PTR _pchain$[ebp]
	add	eax, DWORD PTR [edx+40]
	imul	ecx, DWORD PTR _link$[ebp], 28
	add	eax, ecx
	jmp	SHORT $LN1@pIKLink
$LN3@pIKLink:

; 105  : 
; 106  : 		return NULL;

	xor	eax, eax
$LN1@pIKLink:

; 107  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?pIKLink@CStudioBoneSetup@@QAEPBUmstudioiklink_t@@PBUmstudioikchain_t@@H@Z ENDP ; CStudioBoneSetup::pIKLink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?pIKAutoplayLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@H@Z
_TEXT	SEGMENT
_phdr2$ = -8						; size = 4
_this$ = -4						; size = 4
_lock$ = 8						; size = 4
?pIKAutoplayLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@H@Z PROC ; CStudioBoneSetup::pIKAutoplayLock, COMDAT
; _this$ = ecx

; 84   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 86   : 
; 87   : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $LN2@pIKAutopla
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $LN2@pIKAutopla

; 88   : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$LN2@pIKAutopla:

; 89   : 
; 90   : 		if( phdr2 && lock >= 0 && lock < phdr2->numikautoplaylocks )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $LN3@pIKAutopla
	cmp	DWORD PTR _lock$[ebp], 0
	jl	SHORT $LN3@pIKAutopla
	mov	edx, DWORD PTR _phdr2$[ebp]
	mov	eax, DWORD PTR _lock$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	SHORT $LN3@pIKAutopla

; 91   : 			return (mstudioiklock_t *)((byte *)m_pStudioHeader + phdr2->ikautoplaylockindex) + lock;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+18968]
	mov	edx, DWORD PTR _phdr2$[ebp]
	add	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _lock$[ebp]
	shl	ecx, 5
	add	eax, ecx
	jmp	SHORT $LN1@pIKAutopla
$LN3@pIKAutopla:

; 92   : 
; 93   : 		return NULL;

	xor	eax, eax
$LN1@pIKAutopla:

; 94   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?pIKAutoplayLock@CStudioBoneSetup@@QAEPBUmstudioiklock_t@@H@Z ENDP ; CStudioBoneSetup::pIKAutoplayLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\bs_defs.h
;	COMDAT ?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z
_TEXT	SEGMENT
_phdr2$ = -8						; size = 4
_this$ = -4						; size = 4
_chain$ = 8						; size = 4
?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z PROC ; CStudioBoneSetup::pIKChain, COMDAT
; _this$ = ecx

; 71   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 		studiohdr2_t *phdr2 = NULL;

	mov	DWORD PTR _phdr2$[ebp], 0

; 73   : 
; 74   : 		if( m_pStudioHeader->studiohdr2index > 0 && m_pStudioHeader->studiohdr2index < m_pStudioHeader->length )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	cmp	DWORD PTR [ecx+220], 0
	jle	SHORT $LN2@pIKChain
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18968]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR [eax+220]
	cmp	eax, DWORD PTR [edx+72]
	jge	SHORT $LN2@pIKChain

; 75   : 			phdr2 = (studiohdr2_t *)((byte *)m_pStudioHeader + m_pStudioHeader->studiohdr2index);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18968]
	add	ecx, DWORD PTR [edx+220]
	mov	DWORD PTR _phdr2$[ebp], ecx
$LN2@pIKChain:

; 76   : 
; 77   : 		if( phdr2 && chain >= 0 && chain < phdr2->numikchains )

	cmp	DWORD PTR _phdr2$[ebp], 0
	je	SHORT $LN3@pIKChain
	cmp	DWORD PTR _chain$[ebp], 0
	jl	SHORT $LN3@pIKChain
	mov	edx, DWORD PTR _phdr2$[ebp]
	mov	eax, DWORD PTR _chain$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	SHORT $LN3@pIKChain

; 78   : 			return (mstudioikchain_t *)((byte *)m_pStudioHeader + phdr2->ikchainindex) + chain;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+18968]
	mov	edx, DWORD PTR _phdr2$[ebp]
	add	eax, DWORD PTR [edx+20]
	imul	ecx, DWORD PTR _chain$[ebp], 44
	add	eax, ecx
	jmp	SHORT $LN1@pIKChain
$LN3@pIKChain:

; 79   : 
; 80   : 		return NULL;

	xor	eax, eax
$LN1@pIKChain:

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?pIKChain@CStudioBoneSetup@@QAEPBUmstudioikchain_t@@H@Z ENDP ; CStudioBoneSetup::pIKChain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\mathlib.h
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
_valueSquared$ = -4					; size = 4
_value$ = 8						; size = 4
?SimpleSpline@@YAMM@Z PROC				; SimpleSpline, COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 228  : 	float valueSquared = value * value;

	movss	xmm0, DWORD PTR _value$[ebp]
	mulss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR _valueSquared$[ebp], xmm0

; 229  : 
; 230  : 	// Nice little ease-in, ease-out spline-like curve
; 231  : 	return (3 * valueSquared - 2 * valueSquared * value);

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _valueSquared$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _valueSquared$[ebp]
	mulss	xmm1, DWORD PTR _value$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 232  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimpleSpline@@YAMM@Z ENDP				; SimpleSpline
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0matrix3x4@@QAE@ABV0@@Z PROC				; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@ABV0@@Z		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??__G@YGXPAX0IIP6EPAX00@Z@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x4@@QAE@ABV0@@Z ENDP				; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetUp@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vUp$ = 8						; size = 4
?SetUp@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetUp, COMDAT
; _this$ = ecx

; 517  : 	void	SetUp( const Vector &vUp ) { mat[2] = vUp; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vUp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUp@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetRight@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vRight$ = 8						; size = 4
?SetRight@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetRight, COMDAT
; _this$ = ecx

; 516  : 	void	SetRight( const Vector &vRight ) { mat[1] = vRight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vRight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRight@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetForward@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vForward$ = 8						; size = 4
?SetForward@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetForward, COMDAT
; _this$ = ecx

; 515  : 	void	SetForward( const Vector &vForward ) { mat[0] = vForward; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vForward$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetForward@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetForward
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?GetOrigin@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOrigin@matrix3x4@@QBE?AVVector@@XZ PROC		; matrix3x4::GetOrigin, COMDAT
; _this$ = ecx

; 513  : 	Vector	GetOrigin() const { return mat[3]; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix3x4@@QBE?AVVector@@XZ ENDP		; matrix3x4::GetOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?GetRight@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRight@matrix3x4@@QBE?AVVector@@XZ PROC		; matrix3x4::GetRight, COMDAT
; _this$ = ecx

; 510  : 	Vector	GetRight() const { return mat[1]; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRight@matrix3x4@@QBE?AVVector@@XZ ENDP		; matrix3x4::GetRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??Amatrix3x4@@QAEPAMH@Z PROC				; matrix3x4::operator[], COMDAT
; _this$ = ecx

; 486  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QAEPAMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z
_TEXT	SEGMENT
tv401 = -40						; size = 4
tv399 = -36						; size = 4
tv397 = -32						; size = 4
tv395 = -28						; size = 4
tv393 = -24						; size = 4
tv391 = -20						; size = 4
tv389 = -16						; size = 4
tv387 = -12						; size = 4
tv385 = -8						; size = 4
_this$ = -4						; size = 4
_origin$ = 8						; size = 4
_quaternion$ = 12					; size = 4
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z PROC	; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx

; 450  : 	_forceinline matrix3x4( const Vector &origin, const Vector4D &quaternion )

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 451  : 	{
; 452  : 		mat[0][0] = 1.0f - 2.0f * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);

	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv385[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv385[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 453  : 		mat[1][0] = 2.0f * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+12]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv387[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv387[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 454  : 		mat[2][0] = 2.0f * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv389[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv389[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 455  : 		mat[3][0] = origin[0];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 456  : 		mat[0][1] = 2.0f * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv391[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv391[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 457  : 		mat[1][1] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv393[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv393[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 458  : 		mat[2][1] = 2.0f * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	mulss	xmm1, DWORD PTR [edx+12]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv395[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv395[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 459  : 		mat[3][1] = origin[1];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 460  : 		mat[0][2] = 2.0f * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+12]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv397[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 461  : 		mat[1][2] = 2.0f * (quaternion.y * quaternion.z + quaternion.x * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv399[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv399[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 462  : 		mat[2][2] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv401[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv401[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 463  : 		mat[3][2] = origin[2];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 464  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ENDP	; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
tv880 = -116						; size = 4
tv878 = -112						; size = 4
tv876 = -108						; size = 4
tv874 = -104						; size = 4
tv872 = -100						; size = 4
tv870 = -96						; size = 4
tv868 = -92						; size = 4
tv866 = -88						; size = 4
tv864 = -84						; size = 4
tv862 = -80						; size = 4
tv860 = -76						; size = 4
tv858 = -72						; size = 4
tv856 = -68						; size = 4
tv854 = -64						; size = 4
tv852 = -60						; size = 4
tv850 = -56						; size = 4
tv848 = -52						; size = 4
tv846 = -48						; size = 4
tv844 = -44						; size = 4
tv842 = -40						; size = 4
tv840 = -36						; size = 4
_cr$ = -32						; size = 4
_sr$ = -28						; size = 4
_cp$ = -24						; size = 4
_sp$ = -20						; size = 4
_angle$ = -16						; size = 4
_cy$ = -12						; size = 4
_sy$ = -8						; size = 4
_this$ = -4						; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
_scale$ = 16						; size = 4
??0matrix3x4@@QAE@ABVVector@@0M@Z PROC			; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx

; 343  : 	_forceinline matrix3x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 344  : 	{
; 345  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 346  : 
; 347  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@matrix3x4

; 348  : 		{
; 349  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 350  : 			SinCos( angle, &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 351  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	imul	ecx, edx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 352  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 353  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 354  : 			SinCos( angle, &sr, &cr );

	lea	edx, DWORD PTR _cr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sr$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 355  : 
; 356  : 			mat[0][0] = (cp*cy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv840[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv840[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 357  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sy$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR _cr$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv842[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv842[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 358  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm2, DWORD PTR _sy$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv844[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv844[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 359  : 			mat[3][0] = origin.x;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 360  : 			mat[0][1] = (cp*sy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv846[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv846[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 361  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR _cr$[ebp]
	mulss	xmm1, DWORD PTR _cy$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv848[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv848[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 362  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR _cy$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv850[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv850[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 363  : 			mat[3][1] = origin.y;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 364  : 			mat[0][2] = (-sp) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv852[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv852[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 365  : 			mat[1][2] = (sr*cp) * scale;

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv854[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv854[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 366  : 			mat[2][2] = (cr*cp) * scale;

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv856[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv856[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 367  : 			mat[3][2] = origin.z;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx
	jmp	$LN7@matrix3x4
$LN2@matrix3x4:

; 368  : 		}
; 369  : 		else if( angles[PITCH] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@matrix3x4

; 370  : 		{
; 371  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 372  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 373  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 374  : 			SinCos( angle, &sp, &cp );

	lea	eax, DWORD PTR _cp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sp$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 375  : 
; 376  : 			mat[0][0] = (cp*cy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv858[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv858[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 377  : 			mat[1][0] = (-sy) * scale;

	movss	xmm0, DWORD PTR _sy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv860[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv860[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 378  : 			mat[2][0] = (sp*cy) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv862[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv862[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 379  : 			mat[3][0] = origin.x;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 380  : 			mat[0][1] = (cp*sy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv864[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv864[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 381  : 			mat[1][1] = (cy) * scale;

	movss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv866[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv866[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 382  : 			mat[2][1] = (sp*sy) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv868[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv868[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 383  : 			mat[3][1] = origin.y;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 384  : 			mat[0][2] = (-sp) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv870[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv870[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 385  : 			mat[1][2] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 386  : 			mat[2][2] = (cp) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv872[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv872[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 387  : 			mat[3][2] = origin.z;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx
	jmp	$LN7@matrix3x4
$LN4@matrix3x4:

; 388  : 		}
; 389  : 		else if( angles[YAW] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@matrix3x4

; 390  : 		{
; 391  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 392  : 			SinCos( angle, &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 393  : 
; 394  : 			mat[0][0] = (cy) * scale;

	movss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv874[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv874[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 395  : 			mat[1][0] = (-sy) * scale;

	movss	xmm0, DWORD PTR _sy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv876[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv876[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 396  : 			mat[2][0] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 397  : 			mat[3][0] = origin.x;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 398  : 			mat[0][1] = (sy) * scale;

	movss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv878[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv878[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 399  : 			mat[1][1] = (cy) * scale;

	movss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv880[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv880[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 400  : 			mat[2][1] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 401  : 			mat[3][1] = origin.y;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 402  : 			mat[0][2] = 0;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 403  : 			mat[1][2] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 404  : 			mat[2][2] = scale;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 405  : 			mat[3][2] = origin.z;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx

; 406  : 		}
; 407  : 		else

	jmp	$LN7@matrix3x4
$LN6@matrix3x4:

; 408  : 		{
; 409  : 			mat[0][0] = scale;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 410  : 			mat[1][0] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 411  : 			mat[2][0] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 412  : 			mat[3][0] = origin.x;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 413  : 			mat[0][1] = 0;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 414  : 			mat[1][1] = scale;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 415  : 			mat[2][1] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 416  : 			mat[3][1] = origin.y;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 417  : 			mat[0][2] = 0;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 418  : 			mat[1][2] = 0;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 419  : 			mat[2][2] = scale;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 420  : 			mat[3][2] = origin.z;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx
$LN7@matrix3x4:

; 421  : 		}
; 422  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix3x4@@QAE@ABVVector@@0M@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Init@Vector4D@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_iz$ = 16						; size = 4
_iw$ = 20						; size = 4
?Init@Vector4D@@QAEXMMMM@Z PROC				; Vector4D::Init, COMDAT
; _this$ = ecx

; 309  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 310  : 		x = ix; y = iy; z = iz; w = iw;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ix$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iz$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iw$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 311  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Init@Vector4D@@QAEXMMMM@Z ENDP				; Vector4D::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector4D@@QAE@XZ PROC				; Vector4D::Vector4D, COMDAT
; _this$ = ecx

; 300  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC		; CrossProduct, COMDAT

; 280  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flLen$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Normalize@Vector@@QBE?AV1@XZ PROC			; Vector::Normalize, COMDAT
; _this$ = ecx

; 229  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 231  : 
; 232  : 		if( flLen )

	movss	xmm0, DWORD PTR _flLen$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 233  : 		{
; 234  : 			flLen = 1.0f / flLen;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _flLen$[ebp]
	movss	DWORD PTR _flLen$[ebp], xmm0

; 235  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Normalize
$LN2@Normalize:

; 236  : 		}
; 237  : 
; 238  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Normalize:

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QBEPBMXZ PROC				; Vector::operator float const *, COMDAT
; _this$ = ecx

; 226  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?LengthSqr@Vector@@QBEMXZ
_TEXT	SEGMENT
tv86 = -8						; size = 4
_this$ = -4						; size = 4
?LengthSqr@Vector@@QBEMXZ PROC				; Vector::LengthSqr, COMDAT
; _this$ = ecx

; 224  : 	inline float LengthSqr(void) const		{ return (x*x + y*y + z*z); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR tv86[ebp], xmm0
	fld	DWORD PTR tv86[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?LengthSqr@Vector@@QBEMXZ ENDP				; Vector::LengthSqr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
?Length@Vector@@QBEMXZ PROC				; Vector::Length, COMDAT
; _this$ = ecx

; 223  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv91[ebp]
	fld	DWORD PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??XVector@@QAEAAV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector@@QAEAAV0@M@Z PROC				; Vector::operator*=, COMDAT
; _this$ = ecx

; 171  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 		x *= s; y *= s; z *= s;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 173  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 174  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector@@QAEAAV0@M@Z ENDP				; Vector::operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??ZVector@@QAEAAV0@ABV0@@Z PROC				; Vector::operator-=, COMDAT
; _this$ = ecx

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 		x-=v.x; y-=v.y; z -= v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 163  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 164  : 	}		

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
??DVector@@QBE?AV0@M@Z PROC				; Vector::operator*, COMDAT
; _this$ = ecx

; 150  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator+, COMDAT
; _this$ = ecx

; 146  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??8Vector@@QBEHABV0@@Z PROC				; Vector::operator==, COMDAT
; _this$ = ecx

; 144  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	ucomiss	xmm0, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	ucomiss	xmm0, DWORD PTR [edx+8]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv73[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_iz$ = 16						; size = 4
?Init@Vector@@QAEXMMM@Z PROC				; Vector::Init, COMDAT
; _this$ = ecx

; 140  : 	void Init(float ix=0.0f, float iy=0.0f, float iz=0.0f){ x = ix; y = iy; z = iz; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ix$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iz$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@Vector@@QAEXMMM@Z ENDP				; Vector::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
_sine$ = 12						; size = 4
_cosine$ = 16						; size = 4
?SinCos@@YAXMPAM0@Z PROC				; SinCos, COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp

; 34   : 	__asm
; 35   : 	{
; 36   : 		push	ecx

	push	ecx

; 37   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 38   : 		fsincos

	fsincos

; 39   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 40   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 41   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 42   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 43   : 		pop	ecx

	pop	ecx

; 44   : 	}
; 45   : }

	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
