; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\server\physics\trace.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG75674 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75675 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG75718 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75844 DB	'0', 00H, 00H, 00H
$SG75719 DB	'(', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, '(', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, '(', 00H, '&', 00H, 's', 00H, 'r', 00H, 'c', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'a', 00H, 's'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '+', 00H, ' ', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '(', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG75841 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG75850 DB	'0', 00H, 00H, 00H
$SG75720 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75854 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG75721 DB	'(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, '(', 00H, ')', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')'
	DB	00H, 00H, 00H
$SG75793 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
$SG75856 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG75794 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'm', 00H, '_'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, ')', 00H, 00H, 00H
	ORG $+4
$SG75840 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75843 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75849 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75853 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG75855 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?VectorLerp@@YAXABVVector@@M0AAV1@@Z		; VectorLerp
PUBLIC	?SetupTrace@TraceMesh@@QAEXABVVector@@000PAUtrace_s@@@Z ; TraceMesh::SetupTrace
PUBLIC	?ClipBoxToFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z	; TraceMesh::ClipBoxToFacet
PUBLIC	?TestBoxInFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z	; TraceMesh::TestBoxInFacet
PUBLIC	?ClipToLinks@TraceMesh@@QAEXPAUareanode_s@@@Z	; TraceMesh::ClipToLinks
PUBLIC	?DoTrace@TraceMesh@@QAE_NXZ			; TraceMesh::DoTrace
PUBLIC	__real@00000000
PUBLIC	__real@3d000000
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
EXTRN	_memset:PROC
EXTRN	?ClearBounds@@YAXAAVVector@@0@Z:PROC		; ClearBounds
EXTRN	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z:PROC	; AddPointToBounds
EXTRN	?BoundsIntersect@@YA_NABVVector@@000@Z:PROC	; BoundsIntersect
EXTRN	__fltused:DWORD
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3d000000
CONST	SEGMENT
__real@3d000000 DD 03d000000r			; 0.03125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\trace.cpp
_TEXT	SEGMENT
tv165 = -24						; size = 4
tv144 = -20						; size = 4
tv143 = -16						; size = 4
_i$1 = -12						; size = 4
_facet$2 = -8						; size = 4
_this$ = -4						; size = 4
?DoTrace@TraceMesh@@QAE_NXZ PROC			; TraceMesh::DoTrace
; _this$ = ecx

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 	if( !mesh || !BoundsIntersect( mesh->mins, mesh->maxs, m_vecAbsMins, m_vecAbsMaxs ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $LN6@DoTrace
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	call	?BoundsIntersect@@YA_NABVVector@@000@Z	; BoundsIntersect
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@DoTrace
$LN6@DoTrace:

; 293  : 		return false; // invalid mesh or no intersection

	xor	al, al
	jmp	$LN1@DoTrace
$LN5@DoTrace:

; 294  : 
; 295  : 	checkcount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0

; 296  : 
; 297  : 	if( areanodes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN7@DoTrace

; 298  : 	{
; 299  : 		ClipToLinks( areanodes );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToLinks@TraceMesh@@QAEXPAUareanode_s@@@Z ; TraceMesh::ClipToLinks

; 300  : 	}
; 301  : 	else

	jmp	SHORT $LN3@DoTrace
$LN7@DoTrace:

; 302  : 	{
; 303  : 		mfacet_t *facet = mesh->facets;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _facet$2[ebp], edx

; 304  : 		for( int i = 0; i < mesh->numfacets; i++, facet++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@DoTrace
$LN2@DoTrace:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
	mov	ecx, DWORD PTR _facet$2[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _facet$2[ebp], ecx
$LN4@DoTrace:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $LN3@DoTrace

; 305  : 		{
; 306  : 			if( bIsTestPosition )

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+100]
	test	eax, eax
	je	SHORT $LN9@DoTrace

; 307  : 				TestBoxInFacet( facet );

	mov	ecx, DWORD PTR _facet$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TestBoxInFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z ; TraceMesh::TestBoxInFacet
	jmp	SHORT $LN10@DoTrace
$LN9@DoTrace:

; 308  : 			else ClipBoxToFacet( facet );

	mov	edx, DWORD PTR _facet$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipBoxToFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z ; TraceMesh::ClipBoxToFacet
$LN10@DoTrace:

; 309  : 
; 310  : 			if( !m_flRealFraction )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@DoTrace

; 311  : 				break;

	jmp	SHORT $LN3@DoTrace
$LN11@DoTrace:

; 312  : 		}

	jmp	SHORT $LN2@DoTrace
$LN3@DoTrace:

; 313  : 	}
; 314  : 
; 315  : //	ALERT( at_aiconsole, "total %i checks for %s\n", checkcount, areanodes ? "tree" : "brute force" );
; 316  : 
; 317  : 	trace->fraction = bound( 0.0f, trace->fraction, 1.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN17@DoTrace
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+16]
	jbe	SHORT $LN15@DoTrace
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN16@DoTrace
$LN15@DoTrace:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv143[ebp], xmm0
$LN16@DoTrace:
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR tv144[ebp], xmm0
	jmp	SHORT $LN18@DoTrace
$LN17@DoTrace:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv144[ebp], xmm0
$LN18@DoTrace:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	movss	xmm0, DWORD PTR tv144[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 318  : 	if( trace->fraction == 1.0f ) trace->endpos = m_vecEnd;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	movss	xmm0, DWORD PTR [ecx+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@DoTrace
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	add	ecx, 20					; 00000014H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN13@DoTrace
$LN12@DoTrace:

; 319  : 	else VectorLerp( m_vecStart, trace->fraction, m_vecEnd, trace->endpos );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?VectorLerp@@YAXABVVector@@M0AAV1@@Z	; VectorLerp
	add	esp, 16					; 00000010H
$LN13@DoTrace:

; 320  : 
; 321  : 	return (trace->fraction != 1.0f);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	movss	xmm0, DWORD PTR [ecx+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@DoTrace
	mov	DWORD PTR tv165[ebp], 1
	jmp	SHORT $LN20@DoTrace
$LN19@DoTrace:
	mov	DWORD PTR tv165[ebp], 0
$LN20@DoTrace:
	mov	al, BYTE PTR tv165[ebp]
$LN1@DoTrace:

; 322  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTrace@TraceMesh@@QAE_NXZ ENDP			; TraceMesh::DoTrace
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\trace.cpp
_TEXT	SEGMENT
_next$ = -16						; size = 4
_facet$ = -12						; size = 4
_l$ = -8						; size = 4
_this$ = -4						; size = 4
_node$ = 8						; size = 4
?ClipToLinks@TraceMesh@@QAEXPAUareanode_s@@@Z PROC	; TraceMesh::ClipToLinks
; _this$ = ecx

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 	link_t	*l, *next;
; 261  : 	mfacet_t	*facet;
; 262  : 
; 263  : 	// touch linked edicts
; 264  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@ClipToLink
$LN2@ClipToLink:
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], edx
$LN4@ClipToLink:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@ClipToLink

; 265  : 	{
; 266  : 		next = l->next;

	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _next$[ebp], edx

; 267  : 
; 268  : 		facet = FACET_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR _facet$[ebp], eax

; 269  : 
; 270  : 		if( !BoundsIntersect( m_vecAbsMins, m_vecAbsMaxs, facet->mins, facet->maxs ))

	mov	ecx, DWORD PTR _facet$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _facet$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	call	?BoundsIntersect@@YA_NABVVector@@000@Z	; BoundsIntersect
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@ClipToLink

; 271  : 			continue;

	jmp	SHORT $LN2@ClipToLink
$LN5@ClipToLink:

; 272  : 
; 273  : 		// might intersect, so do an exact clip
; 274  : 		if( !m_flRealFraction ) return;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@ClipToLink
	jmp	$LN1@ClipToLink
$LN6@ClipToLink:

; 275  : 
; 276  : 		if( bIsTestPosition )

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+100]
	test	edx, edx
	je	SHORT $LN7@ClipToLink

; 277  : 			TestBoxInFacet( facet );

	mov	eax, DWORD PTR _facet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TestBoxInFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z ; TraceMesh::TestBoxInFacet
	jmp	SHORT $LN8@ClipToLink
$LN7@ClipToLink:

; 278  : 		else ClipBoxToFacet( facet );

	mov	ecx, DWORD PTR _facet$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipBoxToFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z ; TraceMesh::ClipBoxToFacet
$LN8@ClipToLink:

; 279  : 	}

	jmp	$LN2@ClipToLink
$LN3@ClipToLink:

; 280  : 	
; 281  : 	// recurse down both sides
; 282  : 	if( node->axis == -1 ) return;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN9@ClipToLink
	jmp	SHORT $LN1@ClipToLink
$LN9@ClipToLink:

; 283  : 
; 284  : 	if( m_vecAbsMaxs[node->axis] > node->dist )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	comiss	xmm0, DWORD PTR [ecx+4]
	jbe	SHORT $LN10@ClipToLink

; 285  : 		ClipToLinks( node->children[0] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToLinks@TraceMesh@@QAEXPAUareanode_s@@@Z ; TraceMesh::ClipToLinks
$LN10@ClipToLink:

; 286  : 	if( m_vecAbsMins[node->axis] < node->dist )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, DWORD PTR [eax+edx*4]
	jbe	SHORT $LN11@ClipToLink

; 287  : 		ClipToLinks( node->children[1] );

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToLinks@TraceMesh@@QAEXPAUareanode_s@@@Z ; TraceMesh::ClipToLinks
$LN11@ClipToLink:
$LN1@ClipToLink:

; 288  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClipToLinks@TraceMesh@@QAEXPAUareanode_s@@@Z ENDP	; TraceMesh::ClipToLinks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\trace.cpp
_TEXT	SEGMENT
tv89 = -20						; size = 4
_planes$ = -16						; size = 4
_i$1 = -12						; size = 4
_this$ = -8						; size = 4
_p$ = -4						; size = 4
_facet$ = 8						; size = 4
?TestBoxInFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z PROC	; TraceMesh::TestBoxInFacet
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 	mplane_t	*p, *planes;
; 191  : 
; 192  : 	if( !facet->numplanes )

	mov	eax, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN7@TestBoxInF

; 193  : 		return;

	jmp	$LN1@TestBoxInF
$LN7@TestBoxInF:

; 194  : 
; 195  : 	planes = facet->planes;

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _planes$[ebp], edx

; 196  : 	checkcount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], ecx

; 197  : 
; 198  : 	for( int i = 0; i < facet->numplanes; i++, planes++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@TestBoxInF
$LN2@TestBoxInF:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
	mov	ecx, DWORD PTR _planes$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _planes$[ebp], ecx
$LN4@TestBoxInF:
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN3@TestBoxInF

; 199  : 	{
; 200  : 		p = planes;

	mov	ecx, DWORD PTR _planes$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 201  : 
; 202  : 		// push the plane out apropriately for mins/maxs
; 203  : 		// if completely in front of face, no intersection
; 204  : 		if( p->type < 3 )

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	cmp	eax, 3
	jge	SHORT $LN8@TestBoxInF

; 205  : 		{
; 206  : 			if( m_vecStartMins[p->type] > p->dist )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN10@TestBoxInF

; 207  : 				return;

	jmp	$LN1@TestBoxInF
$LN10@TestBoxInF:

; 208  : 		}
; 209  : 		else

	jmp	$LN5@TestBoxInF
$LN8@TestBoxInF:

; 210  : 		{
; 211  : 			switch( p->signbits )

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	mov	DWORD PTR tv89[ebp], eax
	cmp	DWORD PTR tv89[ebp], 7
	ja	$LN27@TestBoxInF
	mov	ecx, DWORD PTR tv89[ebp]
	jmp	DWORD PTR $LN29@TestBoxInF[ecx*4]
$LN11@TestBoxInF:

; 212  : 			{
; 213  : 			case 0:
; 214  : 				if( p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMins.z > p->dist )

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+28]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+32]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN12@TestBoxInF

; 215  : 					return;

	jmp	$LN1@TestBoxInF
$LN12@TestBoxInF:

; 216  : 				break;

	jmp	$LN5@TestBoxInF
$LN13@TestBoxInF:

; 217  : 			case 1:
; 218  : 				if( p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMins.z > p->dist )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+28]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+32]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN14@TestBoxInF

; 219  : 					return;

	jmp	$LN1@TestBoxInF
$LN14@TestBoxInF:

; 220  : 				break;

	jmp	$LN5@TestBoxInF
$LN15@TestBoxInF:

; 221  : 			case 2:
; 222  : 				if( p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMins.z > p->dist )

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+52]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+32]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN16@TestBoxInF

; 223  : 					return;

	jmp	$LN1@TestBoxInF
$LN16@TestBoxInF:

; 224  : 				break;

	jmp	$LN5@TestBoxInF
$LN17@TestBoxInF:

; 225  : 			case 3:
; 226  : 				if( p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMins.z > p->dist )

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+52]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+32]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN18@TestBoxInF

; 227  : 					return;

	jmp	$LN1@TestBoxInF
$LN18@TestBoxInF:

; 228  : 				break;

	jmp	$LN5@TestBoxInF
$LN19@TestBoxInF:

; 229  : 			case 4:
; 230  : 				if( p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMaxs.z > p->dist )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+28]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+56]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN20@TestBoxInF

; 231  : 					return;

	jmp	$LN1@TestBoxInF
$LN20@TestBoxInF:

; 232  : 				break;

	jmp	$LN5@TestBoxInF
$LN21@TestBoxInF:

; 233  : 			case 5:
; 234  : 				if( p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMaxs.z > p->dist )

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+48]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+28]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+56]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN22@TestBoxInF

; 235  : 					return;

	jmp	$LN1@TestBoxInF
$LN22@TestBoxInF:

; 236  : 				break;

	jmp	$LN5@TestBoxInF
$LN23@TestBoxInF:

; 237  : 			case 6:
; 238  : 				if( p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMaxs.z > p->dist )

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+52]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+56]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN24@TestBoxInF

; 239  : 					return;

	jmp	SHORT $LN1@TestBoxInF
$LN24@TestBoxInF:

; 240  : 				break;

	jmp	SHORT $LN5@TestBoxInF
$LN25@TestBoxInF:

; 241  : 			case 7:
; 242  : 				if( p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMaxs.z > p->dist )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+52]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+56]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN26@TestBoxInF

; 243  : 					return;

	jmp	SHORT $LN1@TestBoxInF
$LN26@TestBoxInF:

; 244  : 				break;

	jmp	SHORT $LN5@TestBoxInF
$LN27@TestBoxInF:

; 245  : 			default:
; 246  : 				// signbits not initialized
; 247  : 				return;

	jmp	SHORT $LN1@TestBoxInF
$LN5@TestBoxInF:

; 248  : 			}
; 249  : 		}
; 250  : 	}

	jmp	$LN2@TestBoxInF
$LN3@TestBoxInF:

; 251  : 
; 252  : 	// inside this brush
; 253  : 	m_flRealFraction = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+96], xmm0

; 254  : 	trace->startsolid = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [eax+4], 1

; 255  : 	trace->allsolid = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [edx], 1
$LN1@TestBoxInF:

; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN29@TestBoxInF:
	DD	$LN11@TestBoxInF
	DD	$LN13@TestBoxInF
	DD	$LN15@TestBoxInF
	DD	$LN17@TestBoxInF
	DD	$LN19@TestBoxInF
	DD	$LN21@TestBoxInF
	DD	$LN23@TestBoxInF
	DD	$LN25@TestBoxInF
?TestBoxInFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z ENDP	; TraceMesh::TestBoxInFacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\trace.cpp
_TEXT	SEGMENT
_distfrac$ = -56					; size = 4
tv130 = -52						; size = 4
_clipplane$ = -48					; size = 4
_leavefrac$ = -44					; size = 4
_planes$ = -40						; size = 4
_i$1 = -36						; size = 4
_f$ = -32						; size = 4
_d$ = -28						; size = 4
_enterfrac$ = -24					; size = 4
_d2$ = -20						; size = 4
_d1$ = -16						; size = 4
_this$ = -12						; size = 4
_p$ = -8						; size = 4
_getout$ = -2						; size = 1
_startout$ = -1						; size = 1
_facet$ = 8						; size = 4
?ClipBoxToFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z PROC	; TraceMesh::ClipBoxToFacet
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	mplane_t	*p, *clipplane, *planes;
; 67   : 	float	enterfrac, leavefrac, distfrac;
; 68   : 	bool	getout, startout;
; 69   : 	float	d, d1, d2, f;
; 70   : 
; 71   : 	if( !facet->numplanes )

	mov	eax, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN7@ClipBoxToF

; 72   : 		return;

	jmp	$LN1@ClipBoxToF
$LN7@ClipBoxToF:

; 73   : 
; 74   : 	enterfrac = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _enterfrac$[ebp], xmm0

; 75   : 	leavefrac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _leavefrac$[ebp], xmm0

; 76   : 	clipplane = NULL;

	mov	DWORD PTR _clipplane$[ebp], 0

; 77   : 	checkcount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], edx

; 78   : 
; 79   : 	getout = false;

	mov	BYTE PTR _getout$[ebp], 0

; 80   : 	startout = false;

	mov	BYTE PTR _startout$[ebp], 0

; 81   : 	planes = facet->planes;

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _planes$[ebp], edx

; 82   : 
; 83   : 	for( int i = 0; i < facet->numplanes; i++, planes++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@ClipBoxToF
$LN2@ClipBoxToF:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
	mov	ecx, DWORD PTR _planes$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _planes$[ebp], ecx
$LN4@ClipBoxToF:
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN3@ClipBoxToF

; 84   : 	{
; 85   : 		p = planes;

	mov	ecx, DWORD PTR _planes$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 86   : 
; 87   : 		// push the plane out apropriately for mins/maxs
; 88   : 		if( p->type < 3 )

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	cmp	eax, 3
	jge	SHORT $LN8@ClipBoxToF

; 89   : 		{
; 90   : 			d1 = m_vecStartMins[p->type] - p->dist;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 91   : 			d2 = m_vecEndMins[p->type] - p->dist;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [edx+16]
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 92   : 		}
; 93   : 		else

	jmp	$LN5@ClipBoxToF
$LN8@ClipBoxToF:

; 94   : 		{
; 95   : 			switch( p->signbits )

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv130[ebp], ecx
	cmp	DWORD PTR tv130[ebp], 7
	ja	$LN18@ClipBoxToF
	mov	edx, DWORD PTR tv130[ebp]
	jmp	DWORD PTR $LN34@ClipBoxToF[edx*4]
$LN10@ClipBoxToF:

; 96   : 			{
; 97   : 			case 0:
; 98   : 				d1 = p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMins.z - p->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+28]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+32]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 99   : 				d2 = p->normal.x * m_vecEndMins.x + p->normal.y * m_vecEndMins.y + p->normal.z * m_vecEndMins.z - p->dist;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+40]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+44]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 100  : 				break;

	jmp	$LN5@ClipBoxToF
$LN11@ClipBoxToF:

; 101  : 			case 1:
; 102  : 				d1 = p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMins.z - p->dist;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+28]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+32]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 103  : 				d2 = p->normal.x * m_vecEndMaxs.x + p->normal.y * m_vecEndMins.y + p->normal.z * m_vecEndMins.z - p->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+40]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+44]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 104  : 				break;

	jmp	$LN5@ClipBoxToF
$LN12@ClipBoxToF:

; 105  : 			case 2:
; 106  : 				d1 = p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMins.z - p->dist;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+52]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+32]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 107  : 				d2 = p->normal.x * m_vecEndMins.x + p->normal.y * m_vecEndMaxs.y + p->normal.z * m_vecEndMins.z - p->dist;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+64]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+44]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 108  : 				break;

	jmp	$LN5@ClipBoxToF
$LN13@ClipBoxToF:

; 109  : 			case 3:
; 110  : 				d1 = p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMins.z - p->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+52]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+32]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 111  : 				d2 = p->normal.x * m_vecEndMaxs.x + p->normal.y * m_vecEndMaxs.y + p->normal.z * m_vecEndMins.z - p->dist;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+64]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+44]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 112  : 				break;

	jmp	$LN5@ClipBoxToF
$LN14@ClipBoxToF:

; 113  : 			case 4:
; 114  : 				d1 = p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMaxs.z - p->dist;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+28]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+56]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 115  : 				d2 = p->normal.x * m_vecEndMins.x + p->normal.y * m_vecEndMins.y + p->normal.z * m_vecEndMaxs.z - p->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+40]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+68]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 116  : 				break;

	jmp	$LN5@ClipBoxToF
$LN15@ClipBoxToF:

; 117  : 			case 5:
; 118  : 				d1 = p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMins.y + p->normal.z * m_vecStartMaxs.z - p->dist;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+48]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+28]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+56]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 119  : 				d2 = p->normal.x * m_vecEndMaxs.x + p->normal.y * m_vecEndMins.y + p->normal.z * m_vecEndMaxs.z - p->dist;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+40]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+68]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 120  : 				break;

	jmp	$LN5@ClipBoxToF
$LN16@ClipBoxToF:

; 121  : 			case 6:
; 122  : 				d1 = p->normal.x * m_vecStartMins.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMaxs.z - p->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+52]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+56]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 123  : 				d2 = p->normal.x * m_vecEndMins.x + p->normal.y * m_vecEndMaxs.y + p->normal.z * m_vecEndMaxs.z - p->dist;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+64]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+68]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 124  : 				break;

	jmp	$LN5@ClipBoxToF
$LN17@ClipBoxToF:

; 125  : 			case 7:
; 126  : 				d1 = p->normal.x * m_vecStartMaxs.x + p->normal.y * m_vecStartMaxs.y + p->normal.z * m_vecStartMaxs.z - p->dist;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+52]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+56]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _d1$[ebp], xmm0

; 127  : 				d2 = p->normal.x * m_vecEndMaxs.x + p->normal.y * m_vecEndMaxs.y + p->normal.z * m_vecEndMaxs.z - p->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+64]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+68]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d2$[ebp], xmm0

; 128  : 				break;

	jmp	SHORT $LN5@ClipBoxToF
$LN18@ClipBoxToF:

; 129  : 			default:
; 130  : 				d1 = d2 = 0.0f; // shut up compiler

	xorps	xmm0, xmm0
	movss	DWORD PTR _d2$[ebp], xmm0
	movss	xmm0, DWORD PTR _d2$[ebp]
	movss	DWORD PTR _d1$[ebp], xmm0
$LN5@ClipBoxToF:

; 131  : 				break;
; 132  : 			}
; 133  : 		}
; 134  : 
; 135  : 		if( d2 > 0.0f ) getout = true;	// endpoint is not in solid

	movss	xmm0, DWORD PTR _d2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@ClipBoxToF
	mov	BYTE PTR _getout$[ebp], 1
$LN19@ClipBoxToF:

; 136  : 		if( d1 > 0.0f ) startout = true;

	movss	xmm0, DWORD PTR _d1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN20@ClipBoxToF
	mov	BYTE PTR _startout$[ebp], 1
$LN20@ClipBoxToF:

; 137  : 
; 138  : 		// if completely in front of face, no intersection
; 139  : 		if( d1 > 0 && d2 >= d1 )

	movss	xmm0, DWORD PTR _d1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN21@ClipBoxToF
	movss	xmm0, DWORD PTR _d2$[ebp]
	comiss	xmm0, DWORD PTR _d1$[ebp]
	jb	SHORT $LN21@ClipBoxToF

; 140  : 			return;

	jmp	$LN1@ClipBoxToF
$LN21@ClipBoxToF:

; 141  : 
; 142  : 		if( d1 <= 0 && d2 <= 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _d1$[ebp]
	jb	SHORT $LN22@ClipBoxToF
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _d2$[ebp]
	jb	SHORT $LN22@ClipBoxToF

; 143  : 			continue;

	jmp	$LN2@ClipBoxToF
$LN22@ClipBoxToF:

; 144  : 
; 145  : 		// crosses face
; 146  : 		d = 1 / (d1 - d2);

	movss	xmm0, DWORD PTR _d1$[ebp]
	subss	xmm0, DWORD PTR _d2$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _d$[ebp], xmm1

; 147  : 		f = d1 * d;

	movss	xmm0, DWORD PTR _d1$[ebp]
	mulss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _f$[ebp], xmm0

; 148  : 
; 149  : 		if( d > 0.0f )

	movss	xmm0, DWORD PTR _d$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN23@ClipBoxToF

; 150  : 		{	
; 151  : 			// enter
; 152  : 			if( f > enterfrac )

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR _enterfrac$[ebp]
	jbe	SHORT $LN25@ClipBoxToF

; 153  : 			{
; 154  : 				distfrac = d;

	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR _distfrac$[ebp], xmm0

; 155  : 				enterfrac = f;

	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _enterfrac$[ebp], xmm0

; 156  : 				clipplane = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _clipplane$[ebp], ecx
$LN25@ClipBoxToF:

; 157  : 			}
; 158  : 		}

	jmp	SHORT $LN27@ClipBoxToF
$LN23@ClipBoxToF:

; 159  : 		else if( d < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _d$[ebp]
	jbe	SHORT $LN27@ClipBoxToF

; 160  : 		{	
; 161  : 			// leave
; 162  : 			if( f < leavefrac )

	movss	xmm0, DWORD PTR _leavefrac$[ebp]
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN27@ClipBoxToF

; 163  : 				leavefrac = f;

	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _leavefrac$[ebp], xmm0
$LN27@ClipBoxToF:

; 164  : 		}
; 165  : 	}

	jmp	$LN2@ClipBoxToF
$LN3@ClipBoxToF:

; 166  : 
; 167  : 	if( !startout )

	movzx	edx, BYTE PTR _startout$[ebp]
	test	edx, edx
	jne	SHORT $LN28@ClipBoxToF

; 168  : 	{
; 169  : 		// original point was inside brush
; 170  : 		trace->startsolid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [ecx+4], 1

; 171  : 		if( !getout ) trace->allsolid = true;

	movzx	edx, BYTE PTR _getout$[ebp]
	test	edx, edx
	jne	SHORT $LN29@ClipBoxToF
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [ecx], 1
$LN29@ClipBoxToF:

; 172  : 		return;

	jmp	$LN1@ClipBoxToF
$LN28@ClipBoxToF:

; 173  : 	}
; 174  : 
; 175  : 	if( enterfrac - FRAC_EPSILON <= leavefrac )

	movss	xmm0, DWORD PTR _enterfrac$[ebp]
	subss	xmm0, DWORD PTR __real@3d000000
	movss	xmm1, DWORD PTR _leavefrac$[ebp]
	comiss	xmm1, xmm0
	jb	$LN31@ClipBoxToF

; 176  : 	{
; 177  : 		if( enterfrac > -1 && enterfrac < m_flRealFraction )

	movss	xmm0, DWORD PTR _enterfrac$[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN31@ClipBoxToF
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+96]
	comiss	xmm0, DWORD PTR _enterfrac$[ebp]
	jbe	SHORT $LN31@ClipBoxToF

; 178  : 		{
; 179  : 			if( enterfrac < 0 ) enterfrac = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _enterfrac$[ebp]
	jbe	SHORT $LN32@ClipBoxToF
	xorps	xmm0, xmm0
	movss	DWORD PTR _enterfrac$[ebp], xmm0
$LN32@ClipBoxToF:

; 180  : 			m_flRealFraction = enterfrac;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _enterfrac$[ebp]
	movss	DWORD PTR [eax+96], xmm0

; 181  : 			trace->plane.normal = clipplane->normal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	add	edx, 32					; 00000020H
	mov	eax, DWORD PTR _clipplane$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 182  : 			trace->plane.dist = clipplane->dist;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _clipplane$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+44], ecx

; 183  : 			trace->fraction = enterfrac - DIST_EPSILON * distfrac;

	movss	xmm0, DWORD PTR __real@3d000000
	mulss	xmm0, DWORD PTR _distfrac$[ebp]
	movss	xmm1, DWORD PTR _enterfrac$[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	movss	DWORD PTR [eax+16], xmm1
$LN31@ClipBoxToF:
$LN1@ClipBoxToF:

; 184  : 		}
; 185  : 	}
; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN34@ClipBoxToF:
	DD	$LN10@ClipBoxToF
	DD	$LN11@ClipBoxToF
	DD	$LN12@ClipBoxToF
	DD	$LN13@ClipBoxToF
	DD	$LN14@ClipBoxToF
	DD	$LN15@ClipBoxToF
	DD	$LN16@ClipBoxToF
	DD	$LN17@ClipBoxToF
?ClipBoxToFacet@TraceMesh@@QAEXPAUmfacet_t@@@Z ENDP	; TraceMesh::ClipBoxToFacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\server\physics\trace.cpp
_TEXT	SEGMENT
$T1 = -64						; size = 12
$T2 = -52						; size = 12
$T3 = -40						; size = 12
$T4 = -28						; size = 12
tv182 = -16						; size = 4
tv175 = -12						; size = 4
_i$5 = -8						; size = 4
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_end$ = 20						; size = 4
_tr$ = 24						; size = 4
?SetupTrace@TraceMesh@@QAEXABVVector@@000PAUtrace_s@@@Z PROC ; TraceMesh::SetupTrace
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 30   : 	trace = tr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax+112], ecx

; 31   : 	memset( trace, 0, sizeof( *trace ));

	push	56					; 00000038H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 32   : 	trace->fraction = m_flRealFraction = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+96], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+16], xmm0

; 33   : 
; 34   : 	m_vecStart = start;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 35   : 	m_vecEnd = end;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 36   : 
; 37   : 	// build a bounding box of the entire move
; 38   : 	ClearBounds( m_vecAbsMins, m_vecAbsMaxs );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	call	?ClearBounds@@YAXAAVVector@@0@Z		; ClearBounds
	add	esp, 8

; 39   : 
; 40   : 	m_vecStartMins = m_vecStart + mins;

	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 41   : 	AddPointToBounds( m_vecStartMins, m_vecAbsMins, m_vecAbsMaxs );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H

; 42   : 
; 43   : 	m_vecStartMaxs = m_vecStart + maxs;

	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 44   : 	AddPointToBounds( m_vecStartMaxs, m_vecAbsMins, m_vecAbsMaxs );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H

; 45   : 
; 46   : 	m_vecEndMins = m_vecEnd + mins;

	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 47   : 	AddPointToBounds( m_vecEndMins, m_vecAbsMins, m_vecAbsMaxs );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H

; 48   : 
; 49   : 	m_vecEndMaxs = m_vecEnd + maxs;

	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 50   : 	AddPointToBounds( m_vecEndMaxs, m_vecAbsMins, m_vecAbsMaxs );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H

; 51   : 
; 52   : 	// spread min\max by a pixel
; 53   : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN4@SetupTrace
$LN2@SetupTrace:
	mov	ecx, DWORD PTR _i$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$5[ebp], ecx
$LN4@SetupTrace:
	cmp	DWORD PTR _i$5[ebp], 3
	jge	SHORT $LN3@SetupTrace

; 54   : 	{
; 55   : 		m_vecAbsMins[i] -= 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$5[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv175[ebp], eax
	mov	ecx, DWORD PTR tv175[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR tv175[ebp]
	movss	DWORD PTR [edx], xmm0

; 56   : 		m_vecAbsMaxs[i] += 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$5[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv182[ebp], edx
	mov	eax, DWORD PTR tv182[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv182[ebp]
	movss	DWORD PTR [ecx], xmm0

; 57   : 	}

	jmp	SHORT $LN2@SetupTrace
$LN3@SetupTrace:

; 58   : 
; 59   : 	if( start == end )

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _start$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN5@SetupTrace

; 60   : 		bIsTestPosition = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+100], 1
	jmp	SHORT $LN6@SetupTrace
$LN5@SetupTrace:

; 61   : 	else bIsTestPosition = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+100], 0
$LN6@SetupTrace:

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SetupTrace@TraceMesh@@QAEXABVVector@@000PAUtrace_s@@@Z ENDP ; TraceMesh::SetupTrace
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?VectorLerp@@YAXABVVector@@M0AAV1@@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_t$ = 12						; size = 4
_src2$ = 16						; size = 4
_dest$ = 20						; size = 4
?VectorLerp@@YAXABVVector@@M0AAV1@@Z PROC		; VectorLerp, COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp

; 283  : 	dest.x = src1.x + (src2.x - src1.x) * t;

	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _dest$[ebp]
	movss	DWORD PTR [eax], xmm0

; 284  : 	dest.y = src1.y + (src2.y - src1.y) * t;

	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _src1$[ebp]
	addss	xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _dest$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 285  : 	dest.z = src1.z + (src2.z - src1.z) * t;

	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	subss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _dest$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 286  : }

	pop	ebp
	ret	0
?VectorLerp@@YAXABVVector@@M0AAV1@@Z ENDP		; VectorLerp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator+, COMDAT
; _this$ = ecx

; 146  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??8Vector@@QBEHABV0@@Z PROC				; Vector::operator==, COMDAT
; _this$ = ecx

; 144  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	ucomiss	xmm0, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	ucomiss	xmm0, DWORD PTR [edx+8]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv73[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
