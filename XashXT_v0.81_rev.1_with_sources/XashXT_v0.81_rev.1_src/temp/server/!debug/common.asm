; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\game_shared\common.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG124276 DB	00H
$SG124370 DB	00H
CONST	ENDS
PUBLIC	?COM_FileBase@@YAXPBDPAD@Z			; COM_FileBase
PUBLIC	?COM_ExtractFilePath@@YAXPBDPAD@Z		; COM_ExtractFilePath
PUBLIC	?COM_StripExtension@@YAXPAD@Z			; COM_StripExtension
PUBLIC	?COM_StripExtension@@YAXPBDPADH@Z		; COM_StripExtension
PUBLIC	?COM_DefaultExtension@@YAXPADPBD@Z		; COM_DefaultExtension
PUBLIC	?COM_FileExtension@@YAPBDPBD@Z			; COM_FileExtension
PUBLIC	?COM_ParseFileExt@@YAPADPAD0J_N@Z		; COM_ParseFileExt
PUBLIC	?COM_HashKey@@YAIPBDI@Z				; COM_HashKey
PUBLIC	?COM_TokenWaiting@@YAHPAD@Z			; COM_TokenWaiting
PUBLIC	?COM_SkipBracedSection@@YAPADPAD@Z		; COM_SkipBracedSection
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memcpy:PROC
EXTRN	?Q_strlen@@YAHPBD@Z:PROC			; Q_strlen
EXTRN	?Q_tolower@@YADD@Z:PROC				; Q_tolower
EXTRN	?Q_strncat@@YAIPADPBDI@Z:PROC			; Q_strncat
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:PROC			; Q_strncpy
EXTRN	?Q_strrchr@@YAPADPBDD@Z:PROC			; Q_strrchr
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_depth$ = -264						; size = 4
_token$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pfile$ = 8						; size = 4
?COM_SkipBracedSection@@YAPADPAD@Z PROC			; COM_SkipBracedSection

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 249  : 	char	token[256];
; 250  : 	int	depth = 0;

	mov	DWORD PTR _depth$[ebp], 0
$LN4@COM_SkipBr:

; 251  : 
; 252  : 	do {
; 253  : 		pfile = COM_ParseFile( pfile, token );

	push	1
	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pfile$[ebp], eax

; 254  : 
; 255  : 		if( token[1] == 0 )

	mov	edx, 1
	shl	edx, 0
	movsx	eax, BYTE PTR _token$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN2@COM_SkipBr

; 256  : 		{
; 257  : 			if( token[0] == '{' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _token$[ebp+edx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN6@COM_SkipBr

; 258  : 				depth++;

	mov	ecx, DWORD PTR _depth$[ebp]
	add	ecx, 1
	mov	DWORD PTR _depth$[ebp], ecx
	jmp	SHORT $LN2@COM_SkipBr
$LN6@COM_SkipBr:

; 259  : 			else if( token[0] == '}' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _token$[ebp+eax]
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN2@COM_SkipBr

; 260  : 				depth--;

	mov	edx, DWORD PTR _depth$[ebp]
	sub	edx, 1
	mov	DWORD PTR _depth$[ebp], edx
$LN2@COM_SkipBr:

; 261  : 		}
; 262  : 	} while( depth && pfile != NULL );

	cmp	DWORD PTR _depth$[ebp], 0
	je	SHORT $LN3@COM_SkipBr
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	$LN4@COM_SkipBr
$LN3@COM_SkipBr:

; 263  : 
; 264  : 	return pfile;

	mov	eax, DWORD PTR _pfile$[ebp]

; 265  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?COM_SkipBracedSection@@YAPADPAD@Z ENDP			; COM_SkipBracedSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_p$ = -4						; size = 4
_buffer$ = 8						; size = 4
?COM_TokenWaiting@@YAHPAD@Z PROC			; COM_TokenWaiting

; 303  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 304  : 	char *p = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@COM_TokenW:

; 305  : 
; 306  : 	while( *p && *p!='\n')

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@COM_TokenW
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN3@COM_TokenW

; 307  : 	{
; 308  : 		if( !isspace( *p ) || isalnum( *p ))

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@COM_TokenW
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	_isalnum
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@COM_TokenW
$LN5@COM_TokenW:

; 309  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@COM_TokenW
$LN4@COM_TokenW:

; 310  : 		p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 311  : 	}

	jmp	SHORT $LN2@COM_TokenW
$LN3@COM_TokenW:

; 312  : 
; 313  : 	return 0;

	xor	eax, eax
$LN1@COM_TokenW:

; 314  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_TokenWaiting@@YAHPAD@Z ENDP			; COM_TokenWaiting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_hashKey$ = -8						; size = 4
_i$1 = -4						; size = 4
_string$ = 8						; size = 4
_hashSize$ = 12						; size = 4
?COM_HashKey@@YAIPBDI@Z PROC				; COM_HashKey

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 325  : 	unsigned int	hashKey = 0;

	mov	DWORD PTR _hashKey$[ebp], 0

; 326  : 
; 327  : 	for( int i = 0; string[i]; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@COM_HashKe
$LN2@COM_HashKe:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@COM_HashKe:
	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@COM_HashKe

; 328  : 		hashKey = (hashKey + i) * 37 + Q_tolower( string[i] );

	mov	eax, DWORD PTR _hashKey$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	imul	esi, eax, 37
	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?Q_tolower@@YADD@Z			; Q_tolower
	add	esp, 4
	movsx	eax, al
	add	esi, eax
	mov	DWORD PTR _hashKey$[ebp], esi
	jmp	SHORT $LN2@COM_HashKe
$LN3@COM_HashKe:

; 329  : 
; 330  : 	return (hashKey % hashSize);

	mov	eax, DWORD PTR _hashKey$[ebp]
	xor	edx, edx
	div	DWORD PTR _hashSize$[ebp]
	mov	eax, edx

; 331  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?COM_HashKey@@YAIPBDI@Z ENDP				; COM_HashKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_len$ = -12						; size = 4
_c$ = -8						; size = 4
_newline$ = -1						; size = 1
_data$ = 8						; size = 4
_token$ = 12						; size = 4
_token_size$ = 16					; size = 4
_allowNewLines$ = 20					; size = 1
?COM_ParseFileExt@@YAPADPAD0J_N@Z PROC			; COM_ParseFileExt

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 148  : 	bool newline = false;

	mov	BYTE PTR _newline$[ebp], 0

; 149  : 	int c, len;
; 150  : 
; 151  : 	if( !token || !token_size )

	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN12@COM_ParseF
	cmp	DWORD PTR _token_size$[ebp], 0
	jne	SHORT $LN11@COM_ParseF
$LN12@COM_ParseF:

; 152  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_ParseF
$LN11@COM_ParseF:

; 153  : 	
; 154  : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 155  : 	token[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _token$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 156  : 	
; 157  : 	if( !data )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $skipwhite$34

; 158  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_ParseF
$skipwhite$34:

; 159  : 		
; 160  : // skip whitespace
; 161  : skipwhite:
; 162  : 	while(( c = ((byte)*data)) <= ' ' )

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN3@COM_ParseF

; 163  : 	{
; 164  : 		if( c == 0 )

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN14@COM_ParseF

; 165  : 			return NULL;	// end of file;

	xor	eax, eax
	jmp	$LN1@COM_ParseF
$LN14@COM_ParseF:

; 166  : 		if( c == '\n' )

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jne	SHORT $LN15@COM_ParseF

; 167  : 			newline = true;

	mov	BYTE PTR _newline$[ebp], 1
$LN15@COM_ParseF:

; 168  : 		data++;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 1
	mov	DWORD PTR _data$[ebp], edx

; 169  : 	}

	jmp	SHORT $skipwhite$34
$LN3@COM_ParseF:

; 170  : 
; 171  : 	if( newline && !allowNewLines )

	movzx	eax, BYTE PTR _newline$[ebp]
	test	eax, eax
	je	SHORT $LN16@COM_ParseF
	movzx	ecx, BYTE PTR _allowNewLines$[ebp]
	test	ecx, ecx
	jne	SHORT $LN16@COM_ParseF

; 172  : 		return data;

	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN1@COM_ParseF
$LN16@COM_ParseF:

; 173  : 
; 174  : 	newline = false;

	mov	BYTE PTR _newline$[ebp], 0

; 175  : 	
; 176  : 	// skip // comments
; 177  : 	if( c == '/' && data[1] == '/' )

	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	jne	SHORT $LN17@COM_ParseF
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _data$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN17@COM_ParseF
$LN4@COM_ParseF:

; 178  : 	{
; 179  : 		while( *data && *data != '\n' )

	mov	edx, DWORD PTR _data$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@COM_ParseF
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN5@COM_ParseF

; 180  : 			data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax
	jmp	SHORT $LN4@COM_ParseF
$LN5@COM_ParseF:

; 181  : 		goto skipwhite;

	jmp	$skipwhite$34
$LN17@COM_ParseF:

; 182  : 	}
; 183  : 
; 184  : 	// handle quoted strings specially
; 185  : 	if( c == '\"' )

	cmp	DWORD PTR _c$[ebp], 34			; 00000022H
	jne	SHORT $LN18@COM_ParseF

; 186  : 	{
; 187  : 		data++;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 1
	mov	DWORD PTR _data$[ebp], ecx
$LN6@COM_ParseF:

; 188  : 		while( 1 )

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN18@COM_ParseF

; 189  : 		{
; 190  : 			c = (byte)*data++;

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 1
	mov	DWORD PTR _data$[ebp], edx

; 191  : 			if( c == '\"' || !c )

	cmp	DWORD PTR _c$[ebp], 34			; 00000022H
	je	SHORT $LN20@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN19@COM_ParseF
$LN20@COM_ParseF:

; 192  : 			{
; 193  : 				if( len < token_size )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _token_size$[ebp]
	jge	SHORT $LN21@COM_ParseF

; 194  : 					token[len] = 0;

	mov	ecx, DWORD PTR _token$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0
$LN21@COM_ParseF:

; 195  : 				return data;

	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN1@COM_ParseF
$LN19@COM_ParseF:

; 196  : 			}
; 197  : 
; 198  : 			if( len < token_size )

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _token_size$[ebp]
	jge	SHORT $LN22@COM_ParseF

; 199  : 				token[len] = c;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
$LN22@COM_ParseF:

; 200  : 			len++;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 201  : 		}

	jmp	SHORT $LN6@COM_ParseF
$LN18@COM_ParseF:

; 202  : 	}
; 203  : 
; 204  : 	// parse single characters
; 205  : 	if( c == '{' || c == '}' || c == ')' || c == '(' || c == '\'' || c == ',' || c == '|' )

	cmp	DWORD PTR _c$[ebp], 123			; 0000007bH
	je	SHORT $LN24@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 125			; 0000007dH
	je	SHORT $LN24@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN24@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN24@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 39			; 00000027H
	je	SHORT $LN24@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN24@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 124			; 0000007cH
	jne	SHORT $LN10@COM_ParseF
$LN24@COM_ParseF:

; 206  : 	{
; 207  : 		if( len < token_size )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _token_size$[ebp]
	jge	SHORT $LN25@COM_ParseF

; 208  : 			token[len] = c;

	mov	ecx, DWORD PTR _token$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
$LN25@COM_ParseF:

; 209  : 		len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 210  : 
; 211  : 		if( len < token_size )

	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _token_size$[ebp]
	jge	SHORT $LN26@COM_ParseF

; 212  : 			token[len] = 0;

	mov	edx, DWORD PTR _token$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0
	jmp	SHORT $LN27@COM_ParseF
$LN26@COM_ParseF:

; 213  : 		else token[0] = 0;	// string is too long

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _token$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN27@COM_ParseF:

; 214  : 
; 215  : 		return data + 1;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	jmp	$LN1@COM_ParseF
$LN10@COM_ParseF:

; 216  : 	}
; 217  : 
; 218  : 	// parse a regular word
; 219  : 	do
; 220  : 	{
; 221  : 		if( len < token_size )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _token_size$[ebp]
	jge	SHORT $LN28@COM_ParseF

; 222  : 			token[len] = c;

	mov	ecx, DWORD PTR _token$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
$LN28@COM_ParseF:

; 223  : 		data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax

; 224  : 		len++;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 225  : 		c = ((byte)*data);

	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _c$[ebp], eax

; 226  : 
; 227  : 		if( c == '{' || c == '}' || c == ')' || c == '(' || c == '\'' || c == ',' || c == '|' )

	cmp	DWORD PTR _c$[ebp], 123			; 0000007bH
	je	SHORT $LN30@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 125			; 0000007dH
	je	SHORT $LN30@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN30@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN30@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 39			; 00000027H
	je	SHORT $LN30@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN30@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 124			; 0000007cH
	jne	SHORT $LN8@COM_ParseF
$LN30@COM_ParseF:

; 228  : 			break;

	jmp	SHORT $LN9@COM_ParseF
$LN8@COM_ParseF:

; 229  : 	} while( c > 32 );

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN10@COM_ParseF
$LN9@COM_ParseF:

; 230  : 	
; 231  : 	if( len < token_size )

	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _token_size$[ebp]
	jge	SHORT $LN31@COM_ParseF

; 232  : 		token[len] = 0;

	mov	edx, DWORD PTR _token$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0
	jmp	SHORT $LN32@COM_ParseF
$LN31@COM_ParseF:

; 233  : 	else token[0] = 0;	// string is too long

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _token$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN32@COM_ParseF:

; 234  : 
; 235  : 	return data;

	mov	eax, DWORD PTR _data$[ebp]
$LN1@COM_ParseF:

; 236  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_ParseFileExt@@YAPADPAD0J_N@Z ENDP			; COM_ParseFileExt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_colon$ = -16						; size = 4
_backslash$ = -12					; size = 4
_dot$ = -8						; size = 4
_separator$ = -4					; size = 4
_in$ = 8						; size = 4
?COM_FileExtension@@YAPBDPBD@Z PROC			; COM_FileExtension

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 274  : 	const char *separator, *backslash, *colon, *dot;
; 275  : 
; 276  : 	separator = Q_strrchr( in, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _separator$[ebp], eax

; 277  : 	backslash = Q_strrchr( in, '\\' );

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 278  : 
; 279  : 	if( !separator || separator < backslash )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN3@COM_FileEx
	mov	edx, DWORD PTR _separator$[ebp]
	cmp	edx, DWORD PTR _backslash$[ebp]
	jae	SHORT $LN2@COM_FileEx
$LN3@COM_FileEx:

; 280  : 		separator = backslash;

	mov	eax, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN2@COM_FileEx:

; 281  : 
; 282  : 	colon = Q_strrchr( in, ':' );

	push	58					; 0000003aH
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 283  : 
; 284  : 	if( !separator || separator < colon )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN5@COM_FileEx
	mov	edx, DWORD PTR _separator$[ebp]
	cmp	edx, DWORD PTR _colon$[ebp]
	jae	SHORT $LN4@COM_FileEx
$LN5@COM_FileEx:

; 285  : 		separator = colon;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN4@COM_FileEx:

; 286  : 
; 287  : 	dot = Q_strrchr( in, '.' );

	push	46					; 0000002eH
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax

; 288  : 
; 289  : 	if( dot == NULL || ( separator && ( dot < separator )))

	cmp	DWORD PTR _dot$[ebp], 0
	je	SHORT $LN7@COM_FileEx
	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN6@COM_FileEx
	mov	edx, DWORD PTR _dot$[ebp]
	cmp	edx, DWORD PTR _separator$[ebp]
	jae	SHORT $LN6@COM_FileEx
$LN7@COM_FileEx:

; 290  : 		return "";

	mov	eax, OFFSET $SG124370
	jmp	SHORT $LN1@COM_FileEx
$LN6@COM_FileEx:

; 291  : 
; 292  : 	return dot + 1;

	mov	eax, DWORD PTR _dot$[ebp]
	add	eax, 1
$LN1@COM_FileEx:

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_FileExtension@@YAPBDPBD@Z ENDP			; COM_FileExtension
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_src$ = -4						; size = 4
_path$ = 8						; size = 4
_extension$ = 12					; size = 4
?COM_DefaultExtension@@YAXPADPBD@Z PROC			; COM_DefaultExtension

; 123  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 124  : 	const char *src;
; 125  : 
; 126  : 	// if path doesn't have a .EXT, append extension
; 127  : 	// (extension should include the .)
; 128  : 	src = path + Q_strlen( path ) - 1;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _path$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _src$[ebp], edx
$LN2@COM_Defaul:

; 129  : 
; 130  : 	while( *src != '/' && src != path )

	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN3@COM_Defaul
	mov	edx, DWORD PTR _src$[ebp]
	cmp	edx, DWORD PTR _path$[ebp]
	je	SHORT $LN3@COM_Defaul

; 131  : 	{
; 132  : 		// it has an extension
; 133  : 		if( *src == '.' ) return;                 

	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN4@COM_Defaul
	jmp	SHORT $LN1@COM_Defaul
$LN4@COM_Defaul:

; 134  : 		src--;

	mov	edx, DWORD PTR _src$[ebp]
	sub	edx, 1
	mov	DWORD PTR _src$[ebp], edx

; 135  : 	}

	jmp	SHORT $LN2@COM_Defaul
$LN3@COM_Defaul:

; 136  : 	Q_strcat( path, extension );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?Q_strncat@@YAIPADPBDI@Z		; Q_strncat
	add	esp, 12					; 0000000cH
$LN1@COM_Defaul:

; 137  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_DefaultExtension@@YAXPADPBD@Z ENDP			; COM_DefaultExtension
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_destsize$ = 16						; size = 4
?COM_StripExtension@@YAXPBDPADH@Z PROC			; COM_StripExtension

; 113  : {

	push	ebp
	mov	ebp, esp

; 114  : 	Q_strncpy( out, in, destsize );

	mov	eax, DWORD PTR _destsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 115  : 	COM_StripExtension( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?COM_StripExtension@@YAXPAD@Z		; COM_StripExtension
	add	esp, 4

; 116  : }

	pop	ebp
	ret	0
?COM_StripExtension@@YAXPBDPADH@Z ENDP			; COM_StripExtension
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_length$ = -4						; size = 4
_path$ = 8						; size = 4
?COM_StripExtension@@YAXPAD@Z PROC			; COM_StripExtension

; 93   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 94   : 	size_t	length;
; 95   : 
; 96   : 	length = Q_strlen( path ) - 1;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _length$[ebp], eax
$LN2@COM_StripE:

; 97   : 	while( length > 0 && path[length] != '.' )

	cmp	DWORD PTR _length$[ebp], 0
	jbe	SHORT $LN3@COM_StripE
	mov	ecx, DWORD PTR _path$[ebp]
	add	ecx, DWORD PTR _length$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN3@COM_StripE

; 98   : 	{
; 99   : 		length--;

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 100  : 		if( path[length] == '/' || path[length] == '\\' || path[length] == ':' )

	mov	ecx, DWORD PTR _path$[ebp]
	add	ecx, DWORD PTR _length$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN5@COM_StripE
	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@COM_StripE
	mov	edx, DWORD PTR _path$[ebp]
	add	edx, DWORD PTR _length$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN4@COM_StripE
$LN5@COM_StripE:

; 101  : 			return; // no extension

	jmp	SHORT $LN1@COM_StripE
$LN4@COM_StripE:

; 102  : 	}

	jmp	SHORT $LN2@COM_StripE
$LN3@COM_StripE:

; 103  : 
; 104  : 	if( length ) path[length] = 0;

	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN1@COM_StripE
	mov	ecx, DWORD PTR _path$[ebp]
	add	ecx, DWORD PTR _length$[ebp]
	mov	BYTE PTR [ecx], 0
$LN1@COM_StripE:

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_StripExtension@@YAXPAD@Z ENDP			; COM_StripExtension
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_src$ = -4						; size = 4
_path$ = 8						; size = 4
_dest$ = 12						; size = 4
?COM_ExtractFilePath@@YAXPBDPAD@Z PROC			; COM_ExtractFilePath

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 72   : 	const char	*src;
; 73   : 	src = path + Q_strlen( path ) - 1;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _path$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _src$[ebp], edx
$LN2@COM_Extrac:

; 74   : 
; 75   : 	// back up until a \ or the start
; 76   : 	while( src != path && !(*(src - 1) == '\\' || *(src - 1) == '/' ))

	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	je	SHORT $LN3@COM_Extrac
	mov	ecx, DWORD PTR _src$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN3@COM_Extrac
	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN3@COM_Extrac

; 77   : 		src--;

	mov	edx, DWORD PTR _src$[ebp]
	sub	edx, 1
	mov	DWORD PTR _src$[ebp], edx
	jmp	SHORT $LN2@COM_Extrac
$LN3@COM_Extrac:

; 78   : 
; 79   : 	if( src != path )

	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	je	SHORT $LN4@COM_Extrac

; 80   : 	{
; 81   : 		memcpy( dest, path, src - path );

	mov	ecx, DWORD PTR _src$[ebp]
	sub	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 82   : 		dest[src - path - 1] = 0; // cutoff backslash

	mov	ecx, DWORD PTR _src$[ebp]
	sub	ecx, DWORD PTR _path$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [edx+ecx-1], 0
	jmp	SHORT $LN1@COM_Extrac
$LN4@COM_Extrac:

; 83   : 	}
; 84   : 	else Q_strcpy( dest, "" ); // file without path

	push	99999					; 0001869fH
	push	OFFSET $SG124276
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@COM_Extrac:

; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_ExtractFilePath@@YAXPBDPAD@Z ENDP			; COM_ExtractFilePath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\common.cpp
_TEXT	SEGMENT
_len$ = -12						; size = 4
_end$ = -8						; size = 4
_start$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?COM_FileBase@@YAXPBDPAD@Z PROC				; COM_FileBase

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 31   : 	int len, start, end;
; 32   : 
; 33   : 	len = Q_strlen( in );

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 34   : 	if( !len ) return;

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN6@COM_FileBa
	jmp	$LN1@COM_FileBa
$LN6@COM_FileBa:

; 35   : 	
; 36   : 	// scan backward for '.'
; 37   : 	end = len - 1;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx
$LN2@COM_FileBa:

; 38   : 
; 39   : 	while( end && in[end] != '.' && in[end] != '/' && in[end] != '\\' )

	cmp	DWORD PTR _end$[ebp], 0
	je	SHORT $LN3@COM_FileBa
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _end$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN3@COM_FileBa
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR _end$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN3@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN3@COM_FileBa

; 40   : 		end--;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, 1
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN2@COM_FileBa
$LN3@COM_FileBa:

; 41   : 	
; 42   : 	if( in[end] != '.' )

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN7@COM_FileBa

; 43   : 		end = len-1; // no '.', copy to end

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN8@COM_FileBa
$LN7@COM_FileBa:

; 44   : 	else end--; // found ',', copy to left of '.'

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN8@COM_FileBa:

; 45   : 
; 46   : 
; 47   : 	// scan backward for '/'
; 48   : 	start = len - 1;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx
$LN4@COM_FileBa:

; 49   : 
; 50   : 	while( start >= 0 && in[start] != '/' && in[start] != '\\' )

	cmp	DWORD PTR _start$[ebp], 0
	jl	SHORT $LN5@COM_FileBa
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _start$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN5@COM_FileBa
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR _start$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN5@COM_FileBa

; 51   : 		start--;

	mov	eax, DWORD PTR _start$[ebp]
	sub	eax, 1
	mov	DWORD PTR _start$[ebp], eax
	jmp	SHORT $LN4@COM_FileBa
$LN5@COM_FileBa:

; 52   : 
; 53   : 	if( start < 0 || ( in[start] != '/' && in[start] != '\\' ))

	cmp	DWORD PTR _start$[ebp], 0
	jl	SHORT $LN11@COM_FileBa
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR _start$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN9@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN9@COM_FileBa
$LN11@COM_FileBa:

; 54   : 		start = 0;

	mov	DWORD PTR _start$[ebp], 0
	jmp	SHORT $LN10@COM_FileBa
$LN9@COM_FileBa:

; 55   : 	else start++;

	mov	edx, DWORD PTR _start$[ebp]
	add	edx, 1
	mov	DWORD PTR _start$[ebp], edx
$LN10@COM_FileBa:

; 56   : 
; 57   : 	// length of new sting
; 58   : 	len = end - start + 1;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 59   : 
; 60   : 	// Copy partial string
; 61   : 	Q_strncpy( out, &in[start], len + 1 );

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 62   : 	out[len] = 0;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0
$LN1@COM_FileBa:

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?COM_FileBase@@YAXPBDPAD@Z ENDP				; COM_FileBase
_TEXT	ENDS
END
