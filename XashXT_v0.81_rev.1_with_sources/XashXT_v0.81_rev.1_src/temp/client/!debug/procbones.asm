; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\game_shared\procbones.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	_acosf
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@QAM@Z				; Vector::Vector
PUBLIC	?Init@Vector@@QAEXMMM@Z				; Vector::Init
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??0Vector4D@@QAE@MMMM@Z				; Vector4D::Vector4D
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
PUBLIC	?Init@Vector4D@@QAEXMMMM@Z			; Vector4D::Init
PUBLIC	?Length@Vector4D@@QBEMXZ			; Vector4D::Length
PUBLIC	?Normalize@Vector4D@@QBE?AV1@XZ			; Vector4D::Normalize
PUBLIC	?DotProduct@@YAMABVVector4D@@0@Z		; DotProduct
PUBLIC	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z	; matrix3x4::matrix3x4
PUBLIC	??Amatrix3x4@@QAEPAMH@Z				; matrix3x4::operator[]
PUBLIC	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ		; matrix3x4::GetOrigin
PUBLIC	??0matrix3x4@@QAE@ABV0@@Z			; matrix3x4::matrix3x4
PUBLIC	?DoAxisInterpBone@@YA_NPAUmstudioaxisinterpbone_t@@PAUmstudiobone_t@@HPAVmatrix3x4@@@Z ; DoAxisInterpBone
PUBLIC	?DoQuatInterpBone@@YA_NPAUmstudioquatinterpbone_t@@PAUmstudiobone_t@@PAUmstudioquatinterpinfo_t@@HPAVmatrix3x4@@@Z ; DoQuatInterpBone
PUBLIC	?DoAimAtBone@@YAXPAUmstudioaimatbone_t@@AAVVector4D@@PAUmstudiobone_t@@HPAVmatrix3x4@@PBUstudiohdr_t@@@Z ; DoAimAtBone
PUBLIC	?CalcProceduralBone@@YA_NPBUstudiohdr_t@@HPAVmatrix3x4@@@Z ; CalcProceduralBone
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3e80000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@42652ee1
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_acos:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	??0matrix3x4@@QAE@XZ:PROC			; matrix3x4::matrix3x4
EXTRN	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ:PROC ; matrix3x4::GetQuaternion
EXTRN	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z:PROC ; matrix3x4::VectorTransform
EXTRN	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z:PROC ; matrix3x4::VectorRotate
EXTRN	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z:PROC ; matrix3x4::VectorIRotate
EXTRN	?Invert@matrix3x4@@QBE?AV1@XZ:PROC		; matrix3x4::Invert
EXTRN	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z:PROC	; matrix3x4::ConcatTransforms
EXTRN	?AxisAngleQuaternion@@YAXABVVector@@MAAVVector4D@@@Z:PROC ; AxisAngleQuaternion
EXTRN	?QuaternionAlign@@YAXABVVector4D@@0AAV1@@Z:PROC	; QuaternionAlign
EXTRN	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z:PROC ; QuaternionSlerp
EXTRN	?QuaternionMult@@YAXABVVector4D@@0AAV1@@Z:PROC	; QuaternionMult
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e80000000000000
CONST	SEGMENT
__real@3e80000000000000 DQ 03e80000000000000r	; 1.19209e-07
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\procbones.cpp
_TEXT	SEGMENT
_quat$1 = -44						; size = 16
_pTrigger$ = -28					; size = 4
_pProcAxis$ = -24					; size = 4
_pProcQuat$ = -20					; size = 4
_pProcAimAt$ = -16					; size = 4
tv89 = -12						; size = 4
_pbones$ = -8						; size = 4
_pinfo$ = -4						; size = 4
_pStudioHdr$ = 8					; size = 4
_iBone$ = 12						; size = 4
_bonetransform$ = 16					; size = 4
?CalcProceduralBone@@YA_NPBUstudiohdr_t@@HPAVmatrix3x4@@@Z PROC ; CalcProceduralBone

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 262  : 	if( !FBitSet( pStudioHdr->flags, STUDIO_HAS_BONEINFO ))

	mov	eax, DWORD PTR _pStudioHdr$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	and	ecx, 1073741824				; 40000000H
	jne	SHORT $LN4@CalcProced

; 263  : 		return false; // info about procedural bones is absent

	xor	al, al
	jmp	$LN1@CalcProced
$LN4@CalcProced:

; 264  : 
; 265  : 	mstudiobone_t *pbones = (mstudiobone_t *)((byte *)pStudioHdr + pStudioHdr->boneindex);

	mov	edx, DWORD PTR _pStudioHdr$[ebp]
	mov	eax, DWORD PTR _pStudioHdr$[ebp]
	add	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _pbones$[ebp], eax

; 266  : 	mstudioboneinfo_t *pinfo = (mstudioboneinfo_t *)((byte *)pbones + pStudioHdr->numbones * sizeof( mstudiobone_t ));

	mov	ecx, DWORD PTR _pStudioHdr$[ebp]
	imul	edx, DWORD PTR [ecx+140], 112
	add	edx, DWORD PTR _pbones$[ebp]
	mov	DWORD PTR _pinfo$[ebp], edx

; 267  : 	mstudioaxisinterpbone_t *pProcAxis;
; 268  : 	mstudioquatinterpbone_t *pProcQuat;
; 269  : 	mstudioquatinterpinfo_t *pTrigger;
; 270  : 	mstudioaimatbone_t *pProcAimAt;
; 271  : 
; 272  : 	if( FBitSet( pbones[iBone].flags, BONE_ALWAYS_PROCEDURAL ) && pinfo[iBone].procindex )

	imul	eax, DWORD PTR _iBone$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	mov	edx, DWORD PTR [ecx+eax+36]
	and	edx, 1
	je	$LN5@CalcProced
	mov	eax, DWORD PTR _iBone$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _pinfo$[ebp]
	cmp	DWORD PTR [ecx+eax+68], 0
	je	$LN5@CalcProced

; 273  : 	{
; 274  : 		Vector4D	quat = pinfo[iBone].quat;

	mov	edx, DWORD PTR _iBone$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _pinfo$[ebp]
	lea	ecx, DWORD PTR [eax+edx+72]
	push	ecx
	lea	ecx, DWORD PTR _quat$1[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D

; 275  : 
; 276  : 		switch( pinfo[iBone].proctype )

	mov	edx, DWORD PTR _iBone$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR [eax+edx+64]
	mov	DWORD PTR tv89[ebp], ecx
	mov	edx, DWORD PTR tv89[ebp]
	sub	edx, 1
	mov	DWORD PTR tv89[ebp], edx
	cmp	DWORD PTR tv89[ebp], 3
	ja	$LN12@CalcProced
	mov	eax, DWORD PTR tv89[ebp]
	jmp	DWORD PTR $LN14@CalcProced[eax*4]
$LN6@CalcProced:

; 277  : 		{
; 278  : 		case STUDIO_PROC_AXISINTERP:
; 279  : 			pProcAxis = (mstudioaxisinterpbone_t *)((byte *)pStudioHdr + pinfo[iBone].procindex);

	mov	ecx, DWORD PTR _iBone$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _pinfo$[ebp]
	mov	eax, DWORD PTR _pStudioHdr$[ebp]
	add	eax, DWORD PTR [edx+ecx+68]
	mov	DWORD PTR _pProcAxis$[ebp], eax

; 280  : 			if( DoAxisInterpBone( pProcAxis, pbones, iBone, bonetransform ))

	mov	ecx, DWORD PTR _bonetransform$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBone$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbones$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pProcAxis$[ebp]
	push	ecx
	call	?DoAxisInterpBone@@YA_NPAUmstudioaxisinterpbone_t@@PAUmstudiobone_t@@HPAVmatrix3x4@@@Z ; DoAxisInterpBone
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@CalcProced

; 281  : 				return true;

	mov	al, 1
	jmp	$LN1@CalcProced
$LN7@CalcProced:

; 282  : 			break;

	jmp	$LN5@CalcProced
$LN8@CalcProced:

; 283  : 		case STUDIO_PROC_QUATINTERP:
; 284  : 			pProcQuat = (mstudioquatinterpbone_t *)((byte *)pStudioHdr + pinfo[iBone].procindex);

	mov	eax, DWORD PTR _iBone$[ebp]
	shl	eax, 7
	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	edx, DWORD PTR _pStudioHdr$[ebp]
	add	edx, DWORD PTR [ecx+eax+68]
	mov	DWORD PTR _pProcQuat$[ebp], edx

; 285  : 			pTrigger = (mstudioquatinterpinfo_t *)((byte *)pStudioHdr + pProcQuat->triggerindex);

	mov	eax, DWORD PTR _pProcQuat$[ebp]
	mov	ecx, DWORD PTR _pStudioHdr$[ebp]
	add	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pTrigger$[ebp], ecx

; 286  : 			if( DoQuatInterpBone( pProcQuat, pbones, pTrigger, iBone, bonetransform ))

	mov	edx, DWORD PTR _bonetransform$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrigger$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbones$[ebp]
	push	edx
	mov	eax, DWORD PTR _pProcQuat$[ebp]
	push	eax
	call	?DoQuatInterpBone@@YA_NPAUmstudioquatinterpbone_t@@PAUmstudiobone_t@@PAUmstudioquatinterpinfo_t@@HPAVmatrix3x4@@@Z ; DoQuatInterpBone
	add	esp, 20					; 00000014H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@CalcProced

; 287  : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@CalcProced
$LN9@CalcProced:

; 288  : 			break;

	jmp	SHORT $LN5@CalcProced
$LN10@CalcProced:

; 289  : 		case STUDIO_PROC_AIMATBONE:
; 290  : 			pProcAimAt = (mstudioaimatbone_t *)((byte *)pStudioHdr + pinfo[iBone].procindex);

	mov	edx, DWORD PTR _iBone$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR _pStudioHdr$[ebp]
	add	ecx, DWORD PTR [eax+edx+68]
	mov	DWORD PTR _pProcAimAt$[ebp], ecx

; 291  : 			DoAimAtBone( pProcAimAt, quat, pbones, iBone, bonetransform, NULL );

	push	0
	mov	edx, DWORD PTR _bonetransform$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbones$[ebp]
	push	ecx
	lea	edx, DWORD PTR _quat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pProcAimAt$[ebp]
	push	eax
	call	?DoAimAtBone@@YAXPAUmstudioaimatbone_t@@AAVVector4D@@PAUmstudiobone_t@@HPAVmatrix3x4@@PBUstudiohdr_t@@@Z ; DoAimAtBone
	add	esp, 24					; 00000018H

; 292  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@CalcProced
$LN11@CalcProced:

; 293  : 		case STUDIO_PROC_AIMATATTACH:
; 294  : 			pProcAimAt = (mstudioaimatbone_t *)((byte *)pStudioHdr + pinfo[iBone].procindex);

	mov	ecx, DWORD PTR _iBone$[ebp]
	shl	ecx, 7
	mov	edx, DWORD PTR _pinfo$[ebp]
	mov	eax, DWORD PTR _pStudioHdr$[ebp]
	add	eax, DWORD PTR [edx+ecx+68]
	mov	DWORD PTR _pProcAimAt$[ebp], eax

; 295  : 			DoAimAtBone( pProcAimAt, quat, pbones, iBone, bonetransform, pStudioHdr );

	mov	ecx, DWORD PTR _pStudioHdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bonetransform$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbones$[ebp]
	push	ecx
	lea	edx, DWORD PTR _quat$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pProcAimAt$[ebp]
	push	eax
	call	?DoAimAtBone@@YAXPAUmstudioaimatbone_t@@AAVVector4D@@PAUmstudiobone_t@@HPAVmatrix3x4@@PBUstudiohdr_t@@@Z ; DoAimAtBone
	add	esp, 24					; 00000018H

; 296  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@CalcProced
$LN12@CalcProced:

; 297  : 		default:
; 298  : 			return false;

	xor	al, al
	jmp	SHORT $LN1@CalcProced
$LN5@CalcProced:

; 299  : 		}
; 300  : 	}
; 301  : 
; 302  : 	return false;

	xor	al, al
$LN1@CalcProced:

; 303  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@CalcProced:
	DD	$LN6@CalcProced
	DD	$LN8@CalcProced
	DD	$LN10@CalcProced
	DD	$LN11@CalcProced
?CalcProceduralBone@@YA_NPBUstudiohdr_t@@HPAVmatrix3x4@@@Z ENDP ; CalcProceduralBone
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\procbones.cpp
_TEXT	SEGMENT
$T1 = -732						; size = 12
$T2 = -720						; size = 12
$T3 = -708						; size = 12
$T4 = -696						; size = 12
$T5 = -684						; size = 12
$T6 = -672						; size = 12
$T7 = -660						; size = 12
$T8 = -648						; size = 12
$T9 = -636						; size = 12
_boneRotation$10 = -624					; size = 16
_upRotation$11 = -608					; size = 16
_tmp_pUp$12 = -592					; size = 12
_tmp_pParentUp$13 = -580				; size = 12
tv426 = -568						; size = 8
tv378 = -560						; size = 8
_aimRotation$ = -552					; size = 16
_pParentUp$14 = -536					; size = 12
_aimWorldPosition$ = -524				; size = 12
_tmpV$15 = -512						; size = 12
_pUp$16 = -500						; size = 12
_aimVector$ = -488					; size = 12
_aimAtWorldPosition$ = -476				; size = 12
_pattachment$17 = -464					; size = 4
_userUpVector$ = -460					; size = 4
_userAimVector$ = -456					; size = 4
_axis$ = -452						; size = 12
_angle$ = -440						; size = 4
$T18 = -436						; size = 48
$T19 = -388						; size = 48
$T20 = -340						; size = 48
$T21 = -292						; size = 48
_parentSpace$ = -244					; size = 48
_aimRotationMatrix$22 = -196				; size = 48
_bonematrix$ = -148					; size = 48
_boneLocalToWorld$ = -100				; size = 48
_boneMatrix$ = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_pProc$ = 8						; size = 4
_q1$ = 12						; size = 4
_pbones$ = 16						; size = 4
_iBone$ = 20						; size = 4
_bonetransform$ = 24					; size = 4
_pStudioHdr$ = 28					; size = 4
?DoAimAtBone@@YAXPAUmstudioaimatbone_t@@AAVVector4D@@PAUmstudiobone_t@@HPAVmatrix3x4@@PBUstudiohdr_t@@@Z PROC ; DoAimAtBone

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 732				; 000002dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 176  : 	// The world matrix of the bone to change
; 177  : 	matrix3x4 boneMatrix;

	lea	ecx, DWORD PTR _boneMatrix$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 178  : 
; 179  : 	// Guaranteed to be unit length
; 180  : 	const Vector &userAimVector = pProc->aimvector;

	mov	eax, DWORD PTR _pProc$[ebp]
	add	eax, 8
	mov	DWORD PTR _userAimVector$[ebp], eax

; 181  : 
; 182  : 	// Guaranteed to be unit length
; 183  : 	const Vector &userUpVector = pProc->upvector;

	mov	ecx, DWORD PTR _pProc$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _userUpVector$[ebp], ecx

; 184  : 
; 185  : 	// Get to get position of bone but also for up reference
; 186  : 	matrix3x4 parentSpace = bonetransform[pProc->parent];

	mov	edx, DWORD PTR _pProc$[ebp]
	imul	eax, DWORD PTR [edx], 48
	add	eax, DWORD PTR _bonetransform$[ebp]
	push	eax
	lea	ecx, DWORD PTR _parentSpace$[ebp]
	call	??0matrix3x4@@QAE@ABV0@@Z

; 187  : 
; 188  : 	// World space position of the bone to aim
; 189  : 	Vector aimWorldPosition = parentSpace.VectorTransform( pProc->basepos );

	mov	ecx, DWORD PTR _pProc$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	lea	edx, DWORD PTR _aimWorldPosition$[ebp]
	push	edx
	lea	ecx, DWORD PTR _parentSpace$[ebp]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform

; 190  : 
; 191  : 	// The worldspace pos to aim at
; 192  : 	Vector aimAtWorldPosition;

	lea	ecx, DWORD PTR _aimAtWorldPosition$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 193  : 
; 194  : 	if( pStudioHdr )

	cmp	DWORD PTR _pStudioHdr$[ebp], 0
	je	SHORT $LN2@DoAimAtBon

; 195  : 	{
; 196  : 		// This means it's AIMATATTACH
; 197  : 		mstudioattachment_t *pattachment = (mstudioattachment_t *) ((byte *)pStudioHdr + pStudioHdr->attachmentindex) + pProc->aim;

	mov	eax, DWORD PTR _pStudioHdr$[ebp]
	mov	ecx, DWORD PTR _pStudioHdr$[ebp]
	add	ecx, DWORD PTR [eax+216]
	mov	edx, DWORD PTR _pProc$[ebp]
	imul	eax, DWORD PTR [edx+4], 88
	add	ecx, eax
	mov	DWORD PTR _pattachment$17[ebp], ecx

; 198  : 		aimAtWorldPosition = bonetransform[pattachment->bone].VectorTransform( pattachment->org );

	mov	ecx, DWORD PTR _pattachment$17[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _pattachment$17[ebp]
	imul	ecx, DWORD PTR [eax+36], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?VectorTransform@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorTransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _aimAtWorldPosition$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _aimAtWorldPosition$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _aimAtWorldPosition$[ebp+8], eax

; 199  : 	}
; 200  : 	else

	jmp	SHORT $LN3@DoAimAtBon
$LN2@DoAimAtBon:

; 201  : 	{
; 202  : 		aimAtWorldPosition = bonetransform[pProc->aim].GetOrigin();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pProc$[ebp]
	imul	ecx, DWORD PTR [edx+4], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?GetOrigin@matrix3x4@@QBE?AVVector@@XZ	; matrix3x4::GetOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _aimAtWorldPosition$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _aimAtWorldPosition$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _aimAtWorldPosition$[ebp+8], eax
$LN3@DoAimAtBon:

; 203  : 	}
; 204  : 
; 205  : 	// The aim and up data is relative to this bone, not the parent bone
; 206  : 	matrix3x4 bonematrix, boneLocalToWorld;

	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR _boneLocalToWorld$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 207  : 
; 208  : 	bonematrix = matrix3x4( pProc->basepos, q1 );

	mov	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pProc$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	lea	ecx, DWORD PTR $T18[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _bonematrix$[ebp]
	rep movsd

; 209  : 	boneLocalToWorld = bonetransform[pProc->parent].ConcatTransforms( bonematrix );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR $T19[ebp]
	push	ecx
	mov	edx, DWORD PTR _pProc$[ebp]
	imul	ecx, DWORD PTR [edx], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _boneLocalToWorld$[ebp]
	rep movsd

; 210  : 
; 211  : 	Vector aimVector = (aimAtWorldPosition - aimWorldPosition).Normalize();

	lea	eax, DWORD PTR _aimVector$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimWorldPosition$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	ecx, DWORD PTR _aimAtWorldPosition$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 212  : 
; 213  : 	Vector axis = CrossProduct( userAimVector, aimVector ).Normalize();

	lea	eax, DWORD PTR _axis$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimVector$[ebp]
	push	ecx
	mov	edx, DWORD PTR _userAimVector$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 214  : 	float angle( acosf( DotProduct( userAimVector, aimVector )));

	lea	ecx, DWORD PTR _aimVector$[ebp]
	push	ecx
	mov	edx, DWORD PTR _userAimVector$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	_acosf
	add	esp, 4
	fstp	DWORD PTR _angle$[ebp]

; 215  : 	Vector4D aimRotation;

	lea	ecx, DWORD PTR _aimRotation$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 216  : 
; 217  : 	AxisAngleQuaternion( axis, RAD2DEG( angle ), aimRotation );

	lea	eax, DWORD PTR _aimRotation$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _angle$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _axis$[ebp]
	push	ecx
	call	?AxisAngleQuaternion@@YAXABVVector@@MAAVVector4D@@@Z ; AxisAngleQuaternion
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 	if(( 1.0f - fabs( DotProduct( userUpVector, userAimVector ))) > FLT_EPSILON )

	mov	edx, DWORD PTR _userAimVector$[ebp]
	push	edx
	mov	eax, DWORD PTR _userUpVector$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv378[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR tv378[ebp]
	comisd	xmm0, QWORD PTR __real@3e80000000000000
	jbe	$LN4@DoAimAtBon

; 220  : 	{
; 221  : 		matrix3x4	aimRotationMatrix = matrix3x4( g_vecZero, aimRotation );

	lea	ecx, DWORD PTR _aimRotation$[ebp]
	push	ecx
	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _aimRotationMatrix$22[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4

; 222  : 		Vector tmp_pUp = aimRotationMatrix.VectorRotate( userUpVector );

	mov	edx, DWORD PTR _userUpVector$[ebp]
	push	edx
	lea	eax, DWORD PTR _tmp_pUp$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimRotationMatrix$22[ebp]
	call	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorRotate

; 223  : 		Vector tmpV = aimVector * DotProduct( aimVector, tmp_pUp );

	lea	ecx, DWORD PTR _tmp_pUp$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _aimVector$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _tmpV$15[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimVector$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*

; 224  : 		Vector pUp = (tmp_pUp - tmpV).Normalize();

	lea	ecx, DWORD PTR _pUp$16[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpV$15[ebp]
	push	edx
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp_pUp$12[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 225  : 
; 226  : 		Vector tmp_pParentUp = boneLocalToWorld.VectorRotate( userUpVector );

	mov	ecx, DWORD PTR _userUpVector$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmp_pParentUp$13[ebp]
	push	edx
	lea	ecx, DWORD PTR _boneLocalToWorld$[ebp]
	call	?VectorRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorRotate

; 227  : 		tmpV = aimVector * DotProduct( aimVector, tmp_pParentUp );

	lea	eax, DWORD PTR _tmp_pParentUp$13[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimVector$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	lea	ecx, DWORD PTR _aimVector$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmpV$15[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmpV$15[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _tmpV$15[ebp+8], eax

; 228  : 		Vector pParentUp = (tmp_pParentUp - tmpV).Normalize();

	lea	ecx, DWORD PTR _pParentUp$14[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpV$15[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp_pParentUp$13[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 229  : 		Vector4D upRotation;

	lea	ecx, DWORD PTR _upRotation$11[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 230  : 
; 231  : 		if( 1.0f - fabs( DotProduct( pUp, pParentUp )) > FLT_EPSILON )

	lea	ecx, DWORD PTR _pParentUp$14[ebp]
	push	ecx
	lea	edx, DWORD PTR _pUp$16[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv426[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR tv426[ebp]
	comisd	xmm0, QWORD PTR __real@3e80000000000000
	jbe	SHORT $LN6@DoAimAtBon

; 232  : 		{
; 233  : 			angle = acos( DotProduct( pUp, pParentUp ));

	lea	eax, DWORD PTR _pParentUp$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _pUp$16[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	QWORD PTR [esp]
	call	_acos
	add	esp, 8
	fstp	DWORD PTR _angle$[ebp]

; 234  : 			axis = CrossProduct( pUp, pParentUp );			

	lea	edx, DWORD PTR _pParentUp$14[ebp]
	push	edx
	lea	eax, DWORD PTR _pUp$16[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _axis$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _axis$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _axis$[ebp+8], edx

; 235  : 		}
; 236  : 		else

	jmp	SHORT $LN7@DoAimAtBon
$LN6@DoAimAtBon:

; 237  : 		{
; 238  : 			angle = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 239  : 			axis = pUp;

	mov	eax, DWORD PTR _pUp$16[ebp]
	mov	DWORD PTR _axis$[ebp], eax
	mov	ecx, DWORD PTR _pUp$16[ebp+4]
	mov	DWORD PTR _axis$[ebp+4], ecx
	mov	edx, DWORD PTR _pUp$16[ebp+8]
	mov	DWORD PTR _axis$[ebp+8], edx
$LN7@DoAimAtBon:

; 240  : 		}
; 241  : 
; 242  : 		axis = axis.Normalize();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _axis$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _axis$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _axis$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _axis$[ebp+8], eax

; 243  : 		AxisAngleQuaternion( axis, RAD2DEG( angle ), upRotation );

	lea	ecx, DWORD PTR _upRotation$11[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _axis$[ebp]
	push	edx
	call	?AxisAngleQuaternion@@YAXABVVector@@MAAVVector4D@@@Z ; AxisAngleQuaternion
	add	esp, 12					; 0000000cH

; 244  : 		Vector4D	boneRotation;

	lea	ecx, DWORD PTR _boneRotation$10[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 245  : 
; 246  : 		QuaternionMult( upRotation, aimRotation, boneRotation );

	lea	eax, DWORD PTR _boneRotation$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimRotation$[ebp]
	push	ecx
	lea	edx, DWORD PTR _upRotation$11[ebp]
	push	edx
	call	?QuaternionMult@@YAXABVVector4D@@0AAV1@@Z ; QuaternionMult
	add	esp, 12					; 0000000cH

; 247  : 		boneMatrix = matrix3x4( aimWorldPosition, boneRotation );

	lea	eax, DWORD PTR _boneRotation$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _aimWorldPosition$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T20[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _boneMatrix$[ebp]
	rep movsd

; 248  : 	}
; 249  : 	else

	jmp	SHORT $LN5@DoAimAtBon
$LN4@DoAimAtBon:

; 250  : 	{
; 251  : 		boneMatrix = matrix3x4( aimWorldPosition, aimRotation );

	lea	edx, DWORD PTR _aimRotation$[ebp]
	push	edx
	lea	eax, DWORD PTR _aimWorldPosition$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _boneMatrix$[ebp]
	rep movsd
$LN5@DoAimAtBon:

; 252  : 	}
; 253  : 
; 254  : 	bonetransform[iBone] = boneMatrix;

	imul	edi, DWORD PTR _iBone$[ebp], 48
	add	edi, DWORD PTR _bonetransform$[ebp]
	mov	ecx, 12					; 0000000cH
	lea	esi, DWORD PTR _boneMatrix$[ebp]
	rep movsd

; 255  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DoAimAtBone@@YAXPAUmstudioaimatbone_t@@AAVVector4D@@PAUmstudiobone_t@@HPAVmatrix3x4@@PBUstudiohdr_t@@@Z ENDP ; DoAimAtBone
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\procbones.cpp
_TEXT	SEGMENT
$T1 = -484						; size = 16
$T2 = -468						; size = 16
tv359 = -452						; size = 8
_src$3 = -444						; size = 16
_pos$4 = -428						; size = 12
tv169 = -416						; size = 4
tv148 = -412						; size = 4
tv147 = -408						; size = 4
_quat$5 = -404						; size = 16
_dot$6 = -388						; size = 4
_scale$7 = -384						; size = 4
_s$8 = -380						; size = 4
_i$9 = -376						; size = 4
$T10 = -372						; size = 48
$T11 = -324						; size = 48
_controlmatrix$12 = -276				; size = 48
_tmpmatrix$13 = -228					; size = 48
_bonematrix$ = -180					; size = 48
_weight$14 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_pProc$ = 8						; size = 4
_pbones$ = 12						; size = 4
_pTrigger$ = 16						; size = 4
_iBone$ = 20						; size = 4
_bonetransform$ = 24					; size = 4
?DoQuatInterpBone@@YA_NPAUmstudioquatinterpbone_t@@PAUmstudiobone_t@@PAUmstudioquatinterpinfo_t@@HPAVmatrix3x4@@@Z PROC ; DoQuatInterpBone

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 97   : 	matrix3x4	bonematrix;

	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 98   : 
; 99   : 	if( pbones[pProc->control].parent != -1 )

	mov	eax, DWORD PTR _pProc$[ebp]
	imul	ecx, DWORD PTR [eax], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [edx+ecx+32], -1
	je	$LN11@DoQuatInte

; 100  : 	{
; 101  : 		Vector4D	src;

	lea	ecx, DWORD PTR _src$3[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 102  : 		float	weight[32];	// !!! MAXSTUDIOBONETRIGGERS
; 103  : 		float	scale = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _scale$7[ebp], xmm0

; 104  : 		Vector4D	quat;

	lea	ecx, DWORD PTR _quat$5[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 105  : 		Vector	pos;

	lea	ecx, DWORD PTR _pos$4[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 106  : 		int	i;
; 107  : 
; 108  : 		matrix3x4	tmpmatrix = bonetransform[pbones[pProc->control].parent].Invert();

	lea	eax, DWORD PTR _tmpmatrix$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _pProc$[ebp]
	imul	edx, DWORD PTR [ecx], 112
	mov	eax, DWORD PTR _pbones$[ebp]
	imul	ecx, DWORD PTR [eax+edx+32], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?Invert@matrix3x4@@QBE?AV1@XZ		; matrix3x4::Invert

; 109  : 		matrix3x4	controlmatrix = tmpmatrix.ConcatTransforms( bonetransform[pProc->control] );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	mov	edx, DWORD PTR _pProc$[ebp]
	imul	eax, DWORD PTR [edx], 48
	add	eax, DWORD PTR _bonetransform$[ebp]
	push	eax
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _controlmatrix$12[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmpmatrix$13[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms

; 110  : 
; 111  : 		src = controlmatrix.GetQuaternion();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _controlmatrix$12[ebp]
	call	?GetQuaternion@matrix3x4@@QAE?AVVector4D@@XZ ; matrix3x4::GetQuaternion
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _src$3[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _src$3[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src$3[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _src$3[ebp+12], edx

; 112  : 
; 113  : 		for( i = 0; i < pProc->numtriggers; i++ )

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@DoQuatInte
$LN2@DoQuatInte:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN4@DoQuatInte:
	mov	ecx, DWORD PTR _pProc$[ebp]
	mov	edx, DWORD PTR _i$9[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	$LN3@DoQuatInte

; 114  : 		{
; 115  : 			float dot = fabs( DotProduct( pTrigger[i].trigger, src ));

	lea	eax, DWORD PTR _src$3[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$9[ebp], 48
	mov	edx, DWORD PTR _pTrigger$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	call	?DotProduct@@YAMABVVector4D@@0@Z	; DotProduct
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _dot$6[ebp]

; 116  : 
; 117  : 			// FIXME: a fast acos should be acceptable
; 118  : 			dot = bound( -1.0f, dot, 1.0f );

	movss	xmm0, DWORD PTR _dot$6[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jb	SHORT $LN19@DoQuatInte
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _dot$6[ebp]
	jbe	SHORT $LN17@DoQuatInte
	movss	xmm0, DWORD PTR _dot$6[ebp]
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN18@DoQuatInte
$LN17@DoQuatInte:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv147[ebp], xmm0
$LN18@DoQuatInte:
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR tv148[ebp], xmm0
	jmp	SHORT $LN20@DoQuatInte
$LN19@DoQuatInte:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv148[ebp], xmm0
$LN20@DoQuatInte:
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _dot$6[ebp], xmm0

; 119  : 			weight[i] = 1.0f - ( 2.0f * acos( dot ) * pTrigger[i].inv_tolerance );

	cvtss2sd xmm0, DWORD PTR _dot$6[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	QWORD PTR tv359[ebp]
	movsd	xmm0, QWORD PTR tv359[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	imul	ecx, DWORD PTR _i$9[ebp], 48
	mov	edx, DWORD PTR _pTrigger$[ebp]
	cvtss2sd xmm1, DWORD PTR [edx+ecx]
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	eax, DWORD PTR _i$9[ebp]
	movss	DWORD PTR _weight$14[ebp+eax*4], xmm0

; 120  : 			weight[i] = Q_max( 0.0f, weight[i] );

	mov	ecx, DWORD PTR _i$9[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _weight$14[ebp+ecx*4]
	jbe	SHORT $LN21@DoQuatInte
	xorps	xmm0, xmm0
	movss	DWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN22@DoQuatInte
$LN21@DoQuatInte:
	mov	edx, DWORD PTR _i$9[ebp]
	movss	xmm0, DWORD PTR _weight$14[ebp+edx*4]
	movss	DWORD PTR tv169[ebp], xmm0
$LN22@DoQuatInte:
	mov	eax, DWORD PTR _i$9[ebp]
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR _weight$14[ebp+eax*4], xmm0

; 121  : 			scale += weight[i];

	mov	ecx, DWORD PTR _i$9[ebp]
	movss	xmm0, DWORD PTR _scale$7[ebp]
	addss	xmm0, DWORD PTR _weight$14[ebp+ecx*4]
	movss	DWORD PTR _scale$7[ebp], xmm0

; 122  : 		}

	jmp	$LN2@DoQuatInte
$LN3@DoQuatInte:

; 123  : 
; 124  : 		if( scale <= 0.001f )  // EPSILON?

	movss	xmm0, DWORD PTR __real@3a83126f
	comiss	xmm0, DWORD PTR _scale$7[ebp]
	jb	SHORT $LN12@DoQuatInte

; 125  : 			return false;

	xor	al, al
	jmp	$LN1@DoQuatInte
$LN12@DoQuatInte:

; 126  : 
; 127  : 		for( i = 0; i < pProc->numtriggers; i++ )

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN7@DoQuatInte
$LN5@DoQuatInte:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN7@DoQuatInte:
	mov	eax, DWORD PTR _pProc$[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN6@DoQuatInte

; 128  : 		{
; 129  : 			if( weight[i] != 0.0f )

	mov	edx, DWORD PTR _i$9[ebp]
	movss	xmm0, DWORD PTR _weight$14[ebp+edx*4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@DoQuatInte

; 130  : 				break;

	jmp	SHORT $LN6@DoQuatInte
$LN13@DoQuatInte:

; 131  : 		}

	jmp	SHORT $LN5@DoQuatInte
$LN6@DoQuatInte:

; 132  : 
; 133  : 		// triggers are not triggered
; 134  : 		if( i == pProc->numtriggers )

	mov	eax, DWORD PTR _pProc$[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN14@DoQuatInte

; 135  : 			return false;

	xor	al, al
	jmp	$LN1@DoQuatInte
$LN14@DoQuatInte:

; 136  : 
; 137  : 		scale = 1.0f / scale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _scale$7[ebp]
	movss	DWORD PTR _scale$7[ebp], xmm0

; 138  : 		quat.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _quat$5[ebp]
	call	?Init@Vector4D@@QAEXMMMM@Z		; Vector4D::Init

; 139  : 		pos.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos$4[ebp]
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 140  : 
; 141  : 		for( i = 0; i < pProc->numtriggers; i++ )

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN10@DoQuatInte
$LN8@DoQuatInte:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN10@DoQuatInte:
	mov	eax, DWORD PTR _pProc$[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN9@DoQuatInte

; 142  : 		{
; 143  : 			if( weight[i] == 0.0f )

	mov	edx, DWORD PTR _i$9[ebp]
	movss	xmm0, DWORD PTR _weight$14[ebp+edx*4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@DoQuatInte

; 144  : 				continue;

	jmp	SHORT $LN8@DoQuatInte
$LN15@DoQuatInte:

; 145  : 
; 146  : 			float s = weight[i] * scale;

	mov	eax, DWORD PTR _i$9[ebp]
	movss	xmm0, DWORD PTR _weight$14[ebp+eax*4]
	mulss	xmm0, DWORD PTR _scale$7[ebp]
	movss	DWORD PTR _s$8[ebp], xmm0

; 147  : 
; 148  : 			QuaternionAlign( pTrigger[i].quat, quat, quat );

	lea	ecx, DWORD PTR _quat$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _quat$5[ebp]
	push	edx
	imul	eax, DWORD PTR _i$9[ebp], 48
	mov	ecx, DWORD PTR _pTrigger$[ebp]
	lea	edx, DWORD PTR [ecx+eax+32]
	push	edx
	call	?QuaternionAlign@@YAXABVVector4D@@0AAV1@@Z ; QuaternionAlign
	add	esp, 12					; 0000000cH

; 149  : 
; 150  : 			// g-cont. why valve don't use slerp here?..
; 151  : 			quat.x = quat.x + s * pTrigger[i].quat.x;

	imul	eax, DWORD PTR _i$9[ebp], 48
	mov	ecx, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+32]
	addss	xmm0, DWORD PTR _quat$5[ebp]
	movss	DWORD PTR _quat$5[ebp], xmm0

; 152  : 			quat.y = quat.y + s * pTrigger[i].quat.y;

	imul	edx, DWORD PTR _i$9[ebp], 48
	mov	eax, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+36]
	addss	xmm0, DWORD PTR _quat$5[ebp+4]
	movss	DWORD PTR _quat$5[ebp+4], xmm0

; 153  : 			quat.z = quat.z + s * pTrigger[i].quat.z;

	imul	ecx, DWORD PTR _i$9[ebp], 48
	mov	edx, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+40]
	addss	xmm0, DWORD PTR _quat$5[ebp+8]
	movss	DWORD PTR _quat$5[ebp+8], xmm0

; 154  : 			quat.w = quat.w + s * pTrigger[i].quat.w;

	imul	eax, DWORD PTR _i$9[ebp], 48
	mov	ecx, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+44]
	addss	xmm0, DWORD PTR _quat$5[ebp+12]
	movss	DWORD PTR _quat$5[ebp+12], xmm0

; 155  : 			pos.x = pos.x + s * pTrigger[i].pos.x;

	imul	edx, DWORD PTR _i$9[ebp], 48
	mov	eax, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+20]
	addss	xmm0, DWORD PTR _pos$4[ebp]
	movss	DWORD PTR _pos$4[ebp], xmm0

; 156  : 			pos.y = pos.y + s * pTrigger[i].pos.y;

	imul	ecx, DWORD PTR _i$9[ebp], 48
	mov	edx, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+24]
	addss	xmm0, DWORD PTR _pos$4[ebp+4]
	movss	DWORD PTR _pos$4[ebp+4], xmm0

; 157  : 			pos.z = pos.z + s * pTrigger[i].pos.z;

	imul	eax, DWORD PTR _i$9[ebp], 48
	mov	ecx, DWORD PTR _pTrigger$[ebp]
	movss	xmm0, DWORD PTR _s$8[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+28]
	addss	xmm0, DWORD PTR _pos$4[ebp+8]
	movss	DWORD PTR _pos$4[ebp+8], xmm0

; 158  : 		}

	jmp	$LN8@DoQuatInte
$LN9@DoQuatInte:

; 159  : 
; 160  : 		quat = quat.Normalize();	// g-cont. is this really needs?

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _quat$5[ebp]
	call	?Normalize@Vector4D@@QBE?AV1@XZ		; Vector4D::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _quat$5[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _quat$5[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _quat$5[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _quat$5[ebp+12], edx

; 161  : 		bonematrix = matrix3x4( pos, quat );

	lea	eax, DWORD PTR _quat$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$4[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _bonematrix$[ebp]
	rep movsd

; 162  : 		bonetransform[iBone] = bonetransform[pbones[iBone].parent].ConcatTransforms( bonematrix );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	imul	ecx, DWORD PTR _iBone$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	ecx, DWORD PTR [edx+ecx+32], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	imul	edi, DWORD PTR _iBone$[ebp], 48
	add	edi, DWORD PTR _bonetransform$[ebp]
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	rep movsd

; 163  : 
; 164  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@DoQuatInte
$LN11@DoQuatInte:

; 165  : 	}
; 166  : 
; 167  : 	return false;

	xor	al, al
$LN1@DoQuatInte:

; 168  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DoQuatInterpBone@@YA_NPAUmstudioquatinterpbone_t@@PAUmstudiobone_t@@PAUmstudioquatinterpinfo_t@@HPAVmatrix3x4@@@Z ENDP ; DoQuatInterpBone
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\procbones.cpp
_TEXT	SEGMENT
$T1 = -220						; size = 12
$T2 = -208						; size = 12
$T3 = -196						; size = 12
$T4 = -184						; size = 12
$T5 = -172						; size = 12
_v$ = -160						; size = 16
_tmp$ = -144						; size = 16
$T6 = -128						; size = 12
_p$ = -116						; size = 12
_p3$ = -104						; size = 4
_p2$ = -100						; size = 4
_p1$ = -96						; size = 4
_q3$ = -92						; size = 4
_q2$ = -88						; size = 4
_q1$ = -84						; size = 4
_control$ = -80						; size = 12
_t$7 = -68						; size = 4
_a3$ = -64						; size = 4
_a2$ = -60						; size = 4
_a1$ = -56						; size = 4
$T8 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_pProc$ = 8						; size = 4
_pbones$ = 12						; size = 4
_iBone$ = 16						; size = 4
_bonetransform$ = 20					; size = 4
?DoAxisInterpBone@@YA_NPAUmstudioaxisinterpbone_t@@PAUmstudiobone_t@@HPAVmatrix3x4@@@Z PROC ; DoAxisInterpBone

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 18   : 	Vector	control;

	lea	ecx, DWORD PTR _control$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 19   : 
; 20   : 	if( pbones[pProc->control].parent != -1 ) // invert it back into parent's space.

	mov	eax, DWORD PTR _pProc$[ebp]
	imul	ecx, DWORD PTR [eax], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [edx+ecx+32], -1
	je	SHORT $LN2@DoAxisInte

; 21   : 		control = bonetransform[pbones[pProc->control].parent].VectorIRotate( bonetransform[iBone][pProc->axis] );

	mov	eax, DWORD PTR _pProc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	imul	ecx, DWORD PTR _iBone$[ebp], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _pProc$[ebp]
	imul	edx, DWORD PTR [ecx], 112
	mov	eax, DWORD PTR _pbones$[ebp]
	imul	ecx, DWORD PTR [eax+edx+32], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?VectorIRotate@matrix3x4@@QBE?AVVector@@ABV2@@Z ; matrix3x4::VectorIRotate
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _control$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _control$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _control$[ebp+8], eax
	jmp	SHORT $LN3@DoAxisInte
$LN2@DoAxisInte:

; 22   : 	else control = bonetransform[iBone][pProc->axis];

	mov	ecx, DWORD PTR _pProc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	imul	ecx, DWORD PTR _iBone$[ebp], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _control$[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _control$[ebp+4], ecx
	mov	edx, DWORD PTR $T6[ebp+8]
	mov	DWORD PTR _control$[ebp+8], edx
$LN3@DoAxisInte:

; 23   : 
; 24   : 	Vector4D	*q1, *q2, *q3;
; 25   : 	Vector	*p1, *p2, *p3;
; 26   : 
; 27   : 	// find axial control inputs
; 28   : 	float a1 = control.x;

	movss	xmm0, DWORD PTR _control$[ebp]
	movss	DWORD PTR _a1$[ebp], xmm0

; 29   : 	float a2 = control.y;

	movss	xmm0, DWORD PTR _control$[ebp+4]
	movss	DWORD PTR _a2$[ebp], xmm0

; 30   : 	float a3 = control.z;

	movss	xmm0, DWORD PTR _control$[ebp+8]
	movss	DWORD PTR _a3$[ebp], xmm0

; 31   : 
; 32   : 	if( a1 >= 0.0f ) 

	movss	xmm0, DWORD PTR _a1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN4@DoAxisInte

; 33   : 	{ 
; 34   : 		q1 = &pProc->quat[0];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pProc$[ebp]
	lea	eax, DWORD PTR [edx+ecx+80]
	mov	DWORD PTR _q1$[ebp], eax

; 35   : 		p1 = &pProc->pos[0];

	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pProc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _p1$[ebp], ecx

; 36   : 	} 
; 37   : 	else 

	jmp	SHORT $LN5@DoAxisInte
$LN4@DoAxisInte:

; 38   : 	{ 
; 39   : 		a1 = -a1; 

	movss	xmm0, DWORD PTR _a1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _a1$[ebp], xmm0

; 40   : 		q1 = &pProc->quat[1];

	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _pProc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+80]
	mov	DWORD PTR _q1$[ebp], ecx

; 41   : 		p1 = &pProc->pos[1];

	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _pProc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _p1$[ebp], ecx
$LN5@DoAxisInte:

; 42   : 	}
; 43   : 
; 44   : 	if( a2 >= 0.0f ) 

	movss	xmm0, DWORD PTR _a2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@DoAxisInte

; 45   : 	{ 
; 46   : 		q2 = &pProc->quat[2]; 

	mov	edx, 16					; 00000010H
	shl	edx, 1
	mov	eax, DWORD PTR _pProc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+80]
	mov	DWORD PTR _q2$[ebp], ecx

; 47   : 		p2 = &pProc->pos[2];

	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _pProc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _p2$[ebp], ecx

; 48   : 	} 
; 49   : 	else 

	jmp	SHORT $LN7@DoAxisInte
$LN6@DoAxisInte:

; 50   : 	{ 
; 51   : 		a2 = -a2; 

	movss	xmm0, DWORD PTR _a2$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _a2$[ebp], xmm0

; 52   : 		q2 = &pProc->quat[3]; 

	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _pProc$[ebp]
	lea	edx, DWORD PTR [ecx+eax+80]
	mov	DWORD PTR _q2$[ebp], edx

; 53   : 		p2 = &pProc->pos[3];

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pProc$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _p2$[ebp], eax
$LN7@DoAxisInte:

; 54   : 	}
; 55   : 
; 56   : 	if( a3 >= 0.0f ) 

	movss	xmm0, DWORD PTR _a3$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@DoAxisInte

; 57   : 	{ 
; 58   : 		q3 = &pProc->quat[4]; 

	mov	ecx, 16					; 00000010H
	shl	ecx, 2
	mov	edx, DWORD PTR _pProc$[ebp]
	lea	eax, DWORD PTR [edx+ecx+80]
	mov	DWORD PTR _q3$[ebp], eax

; 59   : 		p3 = &pProc->pos[4];

	mov	ecx, 12					; 0000000cH
	shl	ecx, 2
	mov	edx, DWORD PTR _pProc$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _p3$[ebp], eax

; 60   : 	} 
; 61   : 	else 

	jmp	SHORT $LN9@DoAxisInte
$LN8@DoAxisInte:

; 62   : 	{ 
; 63   : 		a3 = -a3; 

	movss	xmm0, DWORD PTR _a3$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _a3$[ebp], xmm0

; 64   : 		q3 = &pProc->quat[5]; 

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _pProc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+80]
	mov	DWORD PTR _q3$[ebp], ecx

; 65   : 		p3 = &pProc->pos[5];

	mov	edx, 12					; 0000000cH
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _pProc$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _p3$[ebp], edx
$LN9@DoAxisInte:

; 66   : 	}
; 67   : 
; 68   : 	Vector4D	v, tmp;

	lea	ecx, DWORD PTR _v$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector4D@@QAE@XZ			; Vector4D::Vector4D

; 69   : 	Vector	p = g_vecZero;

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _p$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 70   : 
; 71   : 	// do a three-way blend
; 72   : 	if( a1 + a2 > 0.0f )

	movss	xmm0, DWORD PTR _a1$[ebp]
	addss	xmm0, DWORD PTR _a2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN10@DoAxisInte

; 73   : 	{
; 74   : 		float t = 1.0 / (a1 + a2 + a3);

	movss	xmm0, DWORD PTR _a1$[ebp]
	addss	xmm0, DWORD PTR _a2$[ebp]
	addss	xmm0, DWORD PTR _a3$[ebp]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _t$7[ebp], xmm0

; 75   : 
; 76   : 		// FIXME: do a proper 3-way Quat blend!
; 77   : 		QuaternionSlerp( *q2, *q1, a1 / (a1 + a2), tmp );

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _a1$[ebp]
	addss	xmm0, DWORD PTR _a2$[ebp]
	movss	xmm1, DWORD PTR _a1$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q2$[ebp]
	push	edx
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H

; 78   : 		QuaternionSlerp( tmp, *q3, a3 * t, v );

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _a3$[ebp]
	mulss	xmm0, DWORD PTR _t$7[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _q3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	?QuaternionSlerp@@YAXABVVector4D@@0MAAV1@@Z ; QuaternionSlerp
	add	esp, 16					; 00000010H

; 79   : 		p += *p1 * ( a1 * t );

	movss	xmm0, DWORD PTR _a1$[ebp]
	mulss	xmm0, DWORD PTR _t$7[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _p1$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _p$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 80   : 		p += *p2 * ( a2 * t );

	movss	xmm0, DWORD PTR _a2$[ebp]
	mulss	xmm0, DWORD PTR _t$7[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _p2$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _p$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 81   : 		p += *p3 * ( a3 * t );

	movss	xmm0, DWORD PTR _a3$[ebp]
	mulss	xmm0, DWORD PTR _t$7[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _p3$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _p$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 82   : 
; 83   : 		bonetransform[iBone] = bonetransform[pbones[iBone].parent].ConcatTransforms( matrix3x4( p, v ));

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	lea	edx, DWORD PTR _p$[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	imul	ecx, DWORD PTR _iBone$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	ecx, DWORD PTR [edx+ecx+32], 48
	add	ecx, DWORD PTR _bonetransform$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	imul	edi, DWORD PTR _iBone$[ebp], 48
	add	edi, DWORD PTR _bonetransform$[ebp]
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	rep movsd

; 84   : 
; 85   : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@DoAxisInte
$LN10@DoAxisInte:

; 86   : 	}
; 87   : 
; 88   : 	return false;

	xor	al, al
$LN1@DoAxisInte:

; 89   : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DoAxisInterpBone@@YA_NPAUmstudioaxisinterpbone_t@@PAUmstudiobone_t@@HPAVmatrix3x4@@@Z ENDP ; DoAxisInterpBone
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0matrix3x4@@QAE@ABV0@@Z PROC				; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@ABV0@@Z		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??__G@YGXPAX0IIP6EPAX00@Z@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x4@@QAE@ABV0@@Z ENDP				; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?GetOrigin@matrix3x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOrigin@matrix3x4@@QBE?AVVector@@XZ PROC		; matrix3x4::GetOrigin, COMDAT
; _this$ = ecx

; 513  : 	Vector	GetOrigin() const { return mat[3]; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix3x4@@QBE?AVVector@@XZ ENDP		; matrix3x4::GetOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??Amatrix3x4@@QAEPAMH@Z PROC				; matrix3x4::operator[], COMDAT
; _this$ = ecx

; 486  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QAEPAMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z
_TEXT	SEGMENT
tv401 = -40						; size = 4
tv399 = -36						; size = 4
tv397 = -32						; size = 4
tv395 = -28						; size = 4
tv393 = -24						; size = 4
tv391 = -20						; size = 4
tv389 = -16						; size = 4
tv387 = -12						; size = 4
tv385 = -8						; size = 4
_this$ = -4						; size = 4
_origin$ = 8						; size = 4
_quaternion$ = 12					; size = 4
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z PROC	; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx

; 450  : 	_forceinline matrix3x4( const Vector &origin, const Vector4D &quaternion )

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 451  : 	{
; 452  : 		mat[0][0] = 1.0f - 2.0f * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);

	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv385[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv385[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 453  : 		mat[1][0] = 2.0f * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+12]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv387[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv387[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 454  : 		mat[2][0] = 2.0f * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv389[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv389[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 455  : 		mat[3][0] = origin[0];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 456  : 		mat[0][1] = 2.0f * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv391[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv391[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 457  : 		mat[1][1] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv393[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv393[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 458  : 		mat[2][1] = 2.0f * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	mulss	xmm1, DWORD PTR [edx+12]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv395[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv395[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 459  : 		mat[3][1] = origin[1];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 460  : 		mat[0][2] = 2.0f * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+12]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv397[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 461  : 		mat[1][2] = 2.0f * (quaternion.y * quaternion.z + quaternion.x * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+12]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv399[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv399[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 462  : 		mat[2][2] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv401[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv401[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 463  : 		mat[3][2] = origin[2];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 464  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ENDP	; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?DotProduct@@YAMABVVector4D@@0@Z
_TEXT	SEGMENT
tv93 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?DotProduct@@YAMABVVector4D@@0@Z PROC			; DotProduct, COMDAT

; 344  : inline float DotProduct( const Vector4D& a, const Vector4D& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	mulss	xmm1, DWORD PTR [ecx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR tv93[ebp], xmm0
	fld	DWORD PTR tv93[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector4D@@0@Z ENDP			; DotProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Normalize@Vector4D@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flLen$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Normalize@Vector4D@@QBE?AV1@XZ PROC			; Vector4D::Normalize, COMDAT
; _this$ = ecx

; 325  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector4D@@QBEMXZ		; Vector4D::Length
	fstp	DWORD PTR _flLen$[ebp]

; 327  : 
; 328  : 		if( flLen )

	movss	xmm0, DWORD PTR _flLen$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 329  : 		{
; 330  : 			flLen = 1.0f / flLen;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _flLen$[ebp]
	movss	DWORD PTR _flLen$[ebp], xmm0

; 331  : 			return Vector4D( x * flLen, y * flLen, z * flLen, w * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector4D@@QAE@MMMM@Z			; Vector4D::Vector4D
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Normalize
$LN2@Normalize:

; 332  : 		}
; 333  : 
; 334  : 		return *this; // can't normalize

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Normalize:

; 335  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector4D@@QBE?AV1@XZ ENDP			; Vector4D::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT
tv130 = -8						; size = 4
_this$ = -4						; size = 4
?Length@Vector4D@@QBEMXZ PROC				; Vector4D::Length, COMDAT
; _this$ = ecx

; 321  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z + w*w); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	mulss	xmm1, DWORD PTR [ecx+12]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv130[ebp]
	fld	DWORD PTR tv130[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector4D@@QBEMXZ ENDP				; Vector4D::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Init@Vector4D@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_iz$ = 16						; size = 4
_iw$ = 20						; size = 4
?Init@Vector4D@@QAEXMMMM@Z PROC				; Vector4D::Init, COMDAT
; _this$ = ecx

; 309  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 310  : 		x = ix; y = iy; z = iz; w = iw;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ix$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iz$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iw$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 311  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Init@Vector4D@@QAEXMMMM@Z ENDP				; Vector4D::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector4D@@QAE@ABV0@@Z PROC				; Vector4D::Vector4D, COMDAT
; _this$ = ecx

; 302  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
_W$ = 20						; size = 4
??0Vector4D@@QAE@MMMM@Z PROC				; Vector4D::Vector4D, COMDAT
; _this$ = ecx

; 301  : 	inline Vector4D( float X, float Y, float Z, float W ) { x = X; y = Y; z = Z; w = W; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _W$[ebp]
	movss	DWORD PTR [eax+12], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Vector4D@@QAE@MMMM@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector4D@@QAE@XZ PROC				; Vector4D::Vector4D, COMDAT
; _this$ = ecx

; 300  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC		; CrossProduct, COMDAT

; 280  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
tv86 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?DotProduct@@YAMABVVector@@0@Z PROC			; DotProduct, COMDAT

; 278  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR tv86[ebp], xmm0
	fld	DWORD PTR tv86[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flLen$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Normalize@Vector@@QBE?AV1@XZ PROC			; Vector::Normalize, COMDAT
; _this$ = ecx

; 229  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 231  : 
; 232  : 		if( flLen )

	movss	xmm0, DWORD PTR _flLen$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 233  : 		{
; 234  : 			flLen = 1.0f / flLen;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _flLen$[ebp]
	movss	DWORD PTR _flLen$[ebp], xmm0

; 235  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Normalize
$LN2@Normalize:

; 236  : 		}
; 237  : 
; 238  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Normalize:

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QBEPBMXZ PROC				; Vector::operator float const *, COMDAT
; _this$ = ecx

; 226  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
?Length@Vector@@QBEMXZ PROC				; Vector::Length, COMDAT
; _this$ = ecx

; 223  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv91[ebp]
	fld	DWORD PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??YVector@@QAEAAV0@ABV0@@Z PROC				; Vector::operator+=, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 158  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 159  : 	}			

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
??DVector@@QBE?AV0@M@Z PROC				; Vector::operator*, COMDAT
; _this$ = ecx

; 150  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_iz$ = 16						; size = 4
?Init@Vector@@QAEXMMM@Z PROC				; Vector::Init, COMDAT
; _this$ = ecx

; 140  : 	void Init(float ix=0.0f, float iy=0.0f, float iz=0.0f){ x = ix; y = iy; z = iz; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ix$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iz$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@Vector@@QAEXMMM@Z ENDP				; Vector::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rgfl$ = 8						; size = 4
??0Vector@@QAE@QAM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 135  : 	inline Vector(float rgfl[3])			{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgfl$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@QAM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 623  :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 624  :             return (float)acos(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 625  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_acosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
