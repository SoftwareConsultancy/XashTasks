; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\game_shared\playermove.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?pmove@@3PAUplayermove_s@@A			; pmove
PUBLIC	?g_onladder@@3HA				; g_onladder
_BSS	SEGMENT
?pmove@@3PAUplayermove_s@@A DD 01H DUP (?)		; pmove
?g_onladder@@3HA DD 01H DUP (?)				; g_onladder
_BSS	ENDS
CONST	SEGMENT
$SG14979 DB	'sound/materials.txt', 00H
$SG14980 DB	'sound/materials.txt', 00H
$SG14998 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'p'
	DB	00H, 'p', 00H, 00H, 00H
$SG14999 DB	'p', 00H, 'm', 00H, '_', 00H, 's', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, '_', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'd', 00H, 00H, 00H
$SG15099 DB	'lsnd', 00H
	ORG $+3
$SG15102 DB	'psnd', 00H
	ORG $+3
$SG15105 DB	'wsnd', 00H
	ORG $+3
$SG15110 DB	'ssnd', 00H
	ORG $+3
$SG15112 DB	'stype', 00H
	ORG $+2
$SG15118 DB	'player/pl_step1.wav', 00H
$SG15120 DB	'player/pl_step3.wav', 00H
$SG15122 DB	'player/pl_step2.wav', 00H
$SG15124 DB	'player/pl_step4.wav', 00H
$SG15127 DB	'player/pl_metal1.wav', 00H
	ORG $+3
$SG15129 DB	'player/pl_metal3.wav', 00H
	ORG $+3
$SG15131 DB	'player/pl_metal2.wav', 00H
	ORG $+3
$SG15133 DB	'player/pl_metal4.wav', 00H
	ORG $+3
$SG15136 DB	'player/pl_dirt1.wav', 00H
$SG15138 DB	'player/pl_dirt3.wav', 00H
$SG15140 DB	'player/pl_dirt2.wav', 00H
$SG15142 DB	'player/pl_dirt4.wav', 00H
$SG15145 DB	'player/pl_duct1.wav', 00H
$SG15147 DB	'player/pl_duct3.wav', 00H
$SG15149 DB	'player/pl_duct2.wav', 00H
$SG15151 DB	'player/pl_duct4.wav', 00H
$SG15154 DB	'player/pl_grate1.wav', 00H
	ORG $+3
$SG15156 DB	'player/pl_grate3.wav', 00H
	ORG $+3
$SG15158 DB	'player/pl_grate2.wav', 00H
	ORG $+3
$SG15160 DB	'player/pl_grate4.wav', 00H
	ORG $+3
$SG15164 DB	'player/pl_tile1.wav', 00H
$SG15166 DB	'player/pl_tile3.wav', 00H
$SG15168 DB	'player/pl_tile2.wav', 00H
$SG15170 DB	'player/pl_tile4.wav', 00H
$SG15172 DB	'player/pl_tile5.wav', 00H
$SG15175 DB	'player/pl_slosh1.wav', 00H
	ORG $+3
$SG15177 DB	'player/pl_slosh3.wav', 00H
	ORG $+3
$SG15179 DB	'player/pl_slosh2.wav', 00H
	ORG $+3
$SG15181 DB	'player/pl_slosh4.wav', 00H
	ORG $+3
$SG15186 DB	'player/pl_wade1.wav', 00H
$SG15188 DB	'player/pl_wade2.wav', 00H
$SG15190 DB	'player/pl_wade3.wav', 00H
$SG15192 DB	'player/pl_wade4.wav', 00H
$SG15195 DB	'player/pl_ladder1.wav', 00H
	ORG $+2
$SG15197 DB	'player/pl_ladder3.wav', 00H
	ORG $+2
$SG15199 DB	'player/pl_ladder2.wav', 00H
	ORG $+2
$SG15201 DB	'player/pl_ladder4.wav', 00H
	ORG $+2
$SG15278 DB	'Too many entities were touched!', 0aH, 00H
	ORG $+3
$SG15288 DB	'PM  Got a NaN velocity %i', 0aH, 00H
	ORG $+1
$SG15290 DB	'PM  Got a NaN origin on %i', 0aH, 00H
$SG15293 DB	'PM  Got a velocity too high on %i', 0aH, 00H
	ORG $+1
$SG15295 DB	'PM  Got a velocity too low on %i', 0aH, 00H
	ORG $+2
$SG15930 DB	'tfc', 00H
$SG15941 DB	'player/pl_wade1.wav', 00H
$SG15943 DB	'player/pl_wade2.wav', 00H
$SG15945 DB	'player/pl_wade3.wav', 00H
$SG15947 DB	'player/pl_wade4.wav', 00H
$SG15952 DB	'player/plyrjmp8.wav', 00H
$SG15953 DB	'slj', 00H
$SG15997 DB	'player/pl_fallpain3.wav', 00H
$SG16000 DB	'tfc', 00H
$SG16002 DB	'player/pl_fallpain3.wav', 00H
$SG16020 DB	'player/pl_wade1.wav', 00H
$SG16022 DB	'player/pl_wade2.wav', 00H
$SG16024 DB	'player/pl_wade3.wav', 00H
$SG16026 DB	'player/pl_wade4.wav', 00H
$SG16094 DB	'Bogus pmove player movetype %i on (%i) 0=cl 1=sv', 0aH, 00H
	ORG $+2
$SG16175 DB	'p', 00H, 'm', 00H, '_', 00H, 's', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, '_', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'd', 00H, 00H, 00H
$SG16166 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'p'
	DB	00H, 'p', 00H, 00H, 00H
	ORG $+4
$SG16167 DB	'i', 00H, 'd', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '('
	DB	00H, ' ', 00H, 'r', 00H, 'g', 00H, 'v', 00H, '3', 00H, 't', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'c', 00H, 'k', 00H, 'T', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, ')', 00H, ' ', 00H
	DB	'/', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o'
	DB	00H, 'f', 00H, '(', 00H, ' ', 00H, 'r', 00H, 'g', 00H, 'v', 00H
	DB	'3', 00H, 't', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'c', 00H, 'k'
	DB	00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ' ', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG16174 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'p'
	DB	00H, 'p', 00H, 00H, 00H
	ORG $+4
$SG16192 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'p'
	DB	00H, 'p', 00H, 00H, 00H
$SG16193 DB	'!', 00H, 'p', 00H, 'm', 00H, '_', 00H, 's', 00H, 'h', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '_', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'd', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	??ZVector@@QAEAAV0@ABV0@@Z			; Vector::operator-=
PUBLIC	??XVector@@QAEAAV0@M@Z				; Vector::operator*=
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
PUBLIC	??0plane_s@@QAE@XZ				; plane_s::plane_s
PUBLIC	??0trace_s@@QAE@XZ				; trace_s::trace_s
PUBLIC	??0pmplane_t@@QAE@XZ				; pmplane_t::pmplane_t
PUBLIC	??0pmplane_t@@QAE@ABU0@@Z			; pmplane_t::pmplane_t
PUBLIC	??0pmplane_t@@QAE@$$QAU0@@Z			; pmplane_t::pmplane_t
PUBLIC	??0pmtrace_s@@QAE@XZ				; pmtrace_s::pmtrace_s
PUBLIC	??0pmtrace_s@@QAE@ABU0@@Z			; pmtrace_s::pmtrace_s
PUBLIC	??0pmtrace_s@@QAE@$$QAU0@@Z			; pmtrace_s::pmtrace_s
PUBLIC	?PM_SwapTextures@@YAXHH@Z			; PM_SwapTextures
PUBLIC	?PM_SortTextures@@YAXXZ				; PM_SortTextures
PUBLIC	?PM_ParticleLine@@YAXVVector@@0H@Z		; PM_ParticleLine
PUBLIC	?PM_InitTextureTypes@@YAXXZ			; PM_InitTextureTypes
PUBLIC	?PM_FindTextureType@@YADPAD@Z			; PM_FindTextureType
PUBLIC	?PM_PlayGroupSound@@YAXPBDHM@Z			; PM_PlayGroupSound
PUBLIC	?PM_PlayStepSound@@YAXHM@Z			; PM_PlayStepSound
PUBLIC	?PM_MapTextureTypeStepType@@YAHD@Z		; PM_MapTextureTypeStepType
PUBLIC	?PM_CatagorizeTextureType@@YAXXZ		; PM_CatagorizeTextureType
PUBLIC	?PM_UpdateStepSound@@YAXXZ			; PM_UpdateStepSound
PUBLIC	?PM_AddToTouched@@YAHUpmtrace_s@@VVector@@@Z	; PM_AddToTouched
PUBLIC	?PM_CheckVelocity@@YAXXZ			; PM_CheckVelocity
PUBLIC	?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z		; PM_ClipVelocity
PUBLIC	?PM_AddCorrectGravity@@YAXXZ			; PM_AddCorrectGravity
PUBLIC	?PM_FixupGravityVelocity@@YAXXZ			; PM_FixupGravityVelocity
PUBLIC	?PM_FlyMove@@YAHXZ				; PM_FlyMove
PUBLIC	?PM_Accelerate@@YAXVVector@@MM@Z		; PM_Accelerate
PUBLIC	?PM_WalkMove@@YAXXZ				; PM_WalkMove
PUBLIC	?PM_Friction@@YAXXZ				; PM_Friction
PUBLIC	?PM_AirAccelerate@@YAXVVector@@MM@Z		; PM_AirAccelerate
PUBLIC	?PM_WaterMove@@YAXXZ				; PM_WaterMove
PUBLIC	?PM_AirMove@@YAXXZ				; PM_AirMove
PUBLIC	?PM_InWater@@YAHXZ				; PM_InWater
PUBLIC	?PM_CheckWater@@YAHXZ				; PM_CheckWater
PUBLIC	?PM_CatagorizePosition@@YAXXZ			; PM_CatagorizePosition
PUBLIC	?PM_GetRandomStuckOffsets@@YAHHHAAVVector@@@Z	; PM_GetRandomStuckOffsets
PUBLIC	?PM_ResetStuckOffsets@@YAXHH@Z			; PM_ResetStuckOffsets
PUBLIC	?PM_CheckStuck@@YAHXZ				; PM_CheckStuck
PUBLIC	?PM_SpectatorMove@@YAXXZ			; PM_SpectatorMove
PUBLIC	?PM_SplineFraction@@YAMMM@Z			; PM_SplineFraction
PUBLIC	?PM_FixPlayerCrouchStuck@@YAXH@Z		; PM_FixPlayerCrouchStuck
PUBLIC	?PM_UnDuck@@YAXXZ				; PM_UnDuck
PUBLIC	?PM_Duck@@YAXXZ					; PM_Duck
PUBLIC	?PM_LadderMove@@YAXPAUphysent_s@@@Z		; PM_LadderMove
PUBLIC	?PM_Ladder@@YAPAUphysent_s@@XZ			; PM_Ladder
PUBLIC	?PM_WaterJump@@YAXXZ				; PM_WaterJump
PUBLIC	?PM_AddGravity@@YAXXZ				; PM_AddGravity
PUBLIC	?PM_PushEntity@@YA?AUpmtrace_s@@ABVVector@@@Z	; PM_PushEntity
PUBLIC	?PM_Physics_Toss@@YAXXZ				; PM_Physics_Toss
PUBLIC	?PM_NoClip@@YAXXZ				; PM_NoClip
PUBLIC	?PM_PreventMegaBunnyJumping@@YAXXZ		; PM_PreventMegaBunnyJumping
PUBLIC	?PM_Jump@@YAXXZ					; PM_Jump
PUBLIC	?PM_CheckWaterJump@@YAXXZ			; PM_CheckWaterJump
PUBLIC	?PM_CheckFalling@@YAXXZ				; PM_CheckFalling
PUBLIC	?PM_PlayWaterSounds@@YAXXZ			; PM_PlayWaterSounds
PUBLIC	?PM_CalcRoll@@YAMVVector@@0MM@Z			; PM_CalcRoll
PUBLIC	?PM_DropPunchAngle@@YAXAAVVector@@@Z		; PM_DropPunchAngle
PUBLIC	?PM_CheckParamters@@YAXXZ			; PM_CheckParamters
PUBLIC	?PM_ReduceTimers@@YAXXZ				; PM_ReduceTimers
PUBLIC	?PM_PlayerMove@@YAXH@Z				; PM_PlayerMove
PUBLIC	?PM_CreateStuckTable@@YAXXZ			; PM_CreateStuckTable
PUBLIC	?PM_Move@@YAXPAUplayermove_s@@H@Z		; PM_Move
PUBLIC	?PM_GetVisEntInfo@@YAHH@Z			; PM_GetVisEntInfo
PUBLIC	?PM_GetPhysEntInfo@@YAHH@Z			; PM_GetPhysEntInfo
PUBLIC	?PM_Init@@YAXPAUplayermove_s@@@Z		; PM_Init
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3eb33333
PUBLIC	__real@3f000000
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f59999a
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3f8a9fbe76c8b439
PUBLIC	__real@3f8c28f6
PUBLIC	__real@3f91df46a2529d39
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fc0000000000000
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fd54fdf3b645a1d
PUBLIC	__real@3fd6666666666666
PUBLIC	__real@3fd999999999999a
PUBLIC	__real@3fd9999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe199999999999a
PUBLIC	__real@3fe3333333333333
PUBLIC	__real@3fe4cccccccccccd
PUBLIC	__real@3fe6666666666666
PUBLIC	__real@3fe999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@3ff999999999999a
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40200000
PUBLIC	__real@4024000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40f1940000000000
PUBLIC	__real@40f5e00000000000
PUBLIC	__real@41000000
PUBLIC	__real@41400000
PUBLIC	__real@41800000
PUBLIC	__real@41900000
PUBLIC	__real@41c00000
PUBLIC	__real@41e00000
PUBLIC	__real@41f00000
PUBLIC	__real@42080000
PUBLIC	__real@42480000
PUBLIC	__real@42700000
PUBLIC	__real@42800000
PUBLIC	__real@42a00000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@43520000
PUBLIC	__real@435c0000
PUBLIC	__real@43610000
PUBLIC	__real@43870000
PUBLIC	__real@43910000
PUBLIC	__real@43af0000
PUBLIC	__real@43b40000
PUBLIC	__real@44110000
PUBLIC	__real@44610000
PUBLIC	__real@447a0000
PUBLIC	__real@44fa0000
PUBLIC	__real@461c4000
PUBLIC	__real@bdcccccd
PUBLIC	__real@be000000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c0a00000
PUBLIC	__real@c1000000
PUBLIC	__real@c2480000
PUBLIC	__real@c3340000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__wassert:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_atoi:PROC
EXTRN	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:PROC ; matrix4x4::VectorITransform
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strnicmp:PROC
EXTRN	_isalpha:PROC
EXTRN	_isspace:PROC
EXTRN	_toupper:PROC
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:PROC			; Q_strnicmp
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?gEngfuncs@@3Ucl_enginefuncs_s@@A:BYTE		; gEngfuncs
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?pm_shared_initialized@@3HA DD 01H DUP (?)		; pm_shared_initialized
?rgv3tStuckTable@@3PAVVector@@A DB 0288H DUP (?)	; rgv3tStuckTable
?rgStuckLast@@3PAY01HA DD 040H DUP (?)			; rgStuckLast
?rgStuckCheckTime@@3PAY01MA DD 040H DUP (?)		; rgStuckCheckTime
?gcTextures@@3HA DD 01H DUP (?)				; gcTextures
?grgszTextureName@@3PAY0N@DA DB 01a00H DUP (?)		; grgszTextureName
?grgchTextureType@@3PADA DB 0200H DUP (?)		; grgchTextureType
_BSS	ENDS
;	COMDAT ?bTextureTypeInit@?1??PM_InitTextureTypes@@YAXXZ@4HA
_BSS	SEGMENT
?bTextureTypeInit@?1??PM_InitTextureTypes@@YAXXZ@4HA DD 01H DUP (?) ; `PM_InitTextureTypes'::`2'::bTextureTypeInit
_BSS	ENDS
;	COMDAT ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA
_BSS	SEGMENT
?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA DB 080H DUP (?) ; `PM_PlayGroupSound'::`2'::szBuf
_BSS	ENDS
;	COMDAT ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
_BSS	SEGMENT
?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA DD 01H DUP (?) ; `PM_PlayStepSound'::`2'::iSkipStep
_BSS	ENDS
;	COMDAT ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A
_BSS	SEGMENT
?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A DB 048H DUP (?) ; `PM_CheckWater'::`13'::current_table
_BSS	ENDS
;	COMDAT ?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA
_BSS	SEGMENT
?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA DD 01H DUP (?)	; TSS0<`template-parameter-13',UNKNOWN,eckWater,int, ?? &>
_BSS	ENDS
CRT$XCU	SEGMENT
?rgv3tStuckTable$initializer$@@3P6AXXZA DD FLAT:??__Ergv3tStuckTable@@YAXXZ ; rgv3tStuckTable$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c2480000
CONST	SEGMENT
__real@c2480000 DD 0c2480000r			; -50
CONST	ENDS
;	COMDAT __real@c1000000
CONST	SEGMENT
__real@c1000000 DD 0c1000000r			; -8
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@be000000
CONST	SEGMENT
__real@be000000 DD 0be000000r			; -0.125
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44610000
CONST	SEGMENT
__real@44610000 DD 044610000r			; 900
CONST	ENDS
;	COMDAT __real@44110000
CONST	SEGMENT
__real@44110000 DD 044110000r			; 580
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43af0000
CONST	SEGMENT
__real@43af0000 DD 043af0000r			; 350
CONST	ENDS
;	COMDAT __real@43910000
CONST	SEGMENT
__real@43910000 DD 043910000r			; 290
CONST	ENDS
;	COMDAT __real@43870000
CONST	SEGMENT
__real@43870000 DD 043870000r			; 270
CONST	ENDS
;	COMDAT __real@43610000
CONST	SEGMENT
__real@43610000 DD 043610000r			; 225
CONST	ENDS
;	COMDAT __real@435c0000
CONST	SEGMENT
__real@435c0000 DD 0435c0000r			; 220
CONST	ENDS
;	COMDAT __real@43520000
CONST	SEGMENT
__real@43520000 DD 043520000r			; 210
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42080000
CONST	SEGMENT
__real@42080000 DD 042080000r			; 34
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41e00000
CONST	SEGMENT
__real@41e00000 DD 041e00000r			; 28
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40f5e00000000000
CONST	SEGMENT
__real@40f5e00000000000 DQ 040f5e00000000000r	; 89600
CONST	ENDS
;	COMDAT __real@40f1940000000000
CONST	SEGMENT
__real@40f1940000000000 DQ 040f1940000000000r	; 72000
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff999999999999a
CONST	SEGMENT
__real@3ff999999999999a DQ 03ff999999999999ar	; 1.6
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe999999999999a
CONST	SEGMENT
__real@3fe999999999999a DQ 03fe999999999999ar	; 0.8
CONST	ENDS
;	COMDAT __real@3fe6666666666666
CONST	SEGMENT
__real@3fe6666666666666 DQ 03fe6666666666666r	; 0.7
CONST	ENDS
;	COMDAT __real@3fe4cccccccccccd
CONST	SEGMENT
__real@3fe4cccccccccccd DQ 03fe4cccccccccccdr	; 0.65
CONST	ENDS
;	COMDAT __real@3fe3333333333333
CONST	SEGMENT
__real@3fe3333333333333 DQ 03fe3333333333333r	; 0.6
CONST	ENDS
;	COMDAT __real@3fe199999999999a
CONST	SEGMENT
__real@3fe199999999999a DQ 03fe199999999999ar	; 0.55
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd9999a
CONST	SEGMENT
__real@3fd9999a DD 03fd9999ar			; 1.7
CONST	ENDS
;	COMDAT __real@3fd999999999999a
CONST	SEGMENT
__real@3fd999999999999a DQ 03fd999999999999ar	; 0.4
CONST	ENDS
;	COMDAT __real@3fd6666666666666
CONST	SEGMENT
__real@3fd6666666666666 DQ 03fd6666666666666r	; 0.35
CONST	ENDS
;	COMDAT __real@3fd54fdf3b645a1d
CONST	SEGMENT
__real@3fd54fdf3b645a1d DQ 03fd54fdf3b645a1dr	; 0.333
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fc0000000000000
CONST	SEGMENT
__real@3fc0000000000000 DQ 03fc0000000000000r	; 0.125
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f91df46a2529d39
CONST	SEGMENT
__real@3f91df46a2529d39 DQ 03f91df46a2529d39r	; 0.0174533
CONST	ENDS
;	COMDAT __real@3f8c28f6
CONST	SEGMENT
__real@3f8c28f6 DD 03f8c28f6r			; 1.095
CONST	ENDS
;	COMDAT __real@3f8a9fbe76c8b439
CONST	SEGMENT
__real@3f8a9fbe76c8b439 DQ 03f8a9fbe76c8b439r	; 0.013
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?PM_CheckWater@@YAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PM_CheckWater@@YAHXZ$0
__ehfuncinfo$?PM_CheckWater@@YAHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PM_CheckWater@@YAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_ppmove$ = 8						; size = 4
?PM_Init@@YAXPAUplayermove_s@@@Z PROC			; PM_Init

; 3385 : {

	push	ebp
	mov	ebp, esp

; 3386 : 	assert( !pm_shared_initialized );

	cmp	DWORD PTR ?pm_shared_initialized@@3HA, 0
	je	SHORT $LN3@PM_Init
	push	3386					; 00000d3aH
	push	OFFSET $SG16192
	push	OFFSET $SG16193
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@PM_Init:

; 3387 : 
; 3388 : 	pmove = ppmove;

	mov	ecx, DWORD PTR _ppmove$[ebp]
	mov	DWORD PTR ?pmove@@3PAUplayermove_s@@A, ecx ; pmove

; 3389 : 
; 3390 : 	PM_CreateStuckTable();

	call	?PM_CreateStuckTable@@YAXXZ		; PM_CreateStuckTable

; 3391 : 	PM_InitTextureTypes();

	call	?PM_InitTextureTypes@@YAXXZ		; PM_InitTextureTypes

; 3392 : 
; 3393 : 	pm_shared_initialized = 1;

	mov	DWORD PTR ?pm_shared_initialized@@3HA, 1

; 3394 : }

	pop	ebp
	ret	0
?PM_Init@@YAXPAUplayermove_s@@@Z ENDP			; PM_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_ent$ = 8						; size = 4
?PM_GetPhysEntInfo@@YAHH@Z PROC				; PM_GetPhysEntInfo

; 3376 : {

	push	ebp
	mov	ebp, esp

; 3377 : 	if ( ent >= 0 && ent <= pmove->numphysent)

	cmp	DWORD PTR _ent$[ebp], 0
	jl	SHORT $LN2@PM_GetPhys
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jg	SHORT $LN2@PM_GetPhys

; 3378 : 	{
; 3379 : 		return pmove->physents[ ent ].info;

	imul	edx, DWORD PTR _ent$[ebp], 224
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [eax+edx+672]
	jmp	SHORT $LN1@PM_GetPhys
$LN2@PM_GetPhys:

; 3380 : 	}
; 3381 : 	return -1;

	or	eax, -1
$LN1@PM_GetPhys:

; 3382 : }

	pop	ebp
	ret	0
?PM_GetPhysEntInfo@@YAHH@Z ENDP				; PM_GetPhysEntInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_ent$ = 8						; size = 4
?PM_GetVisEntInfo@@YAHH@Z PROC				; PM_GetVisEntInfo

; 3367 : {

	push	ebp
	mov	ebp, esp

; 3368 : 	if ( ent >= 0 && ent <= pmove->numvisent )

	cmp	DWORD PTR _ent$[ebp], 0
	jl	SHORT $LN2@PM_GetVisE
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	ecx, DWORD PTR [eax+149332]
	jg	SHORT $LN2@PM_GetVisE

; 3369 : 	{
; 3370 : 		return pmove->visents[ ent ].info;

	imul	edx, DWORD PTR _ent$[ebp], 224
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [eax+edx+149416]
	jmp	SHORT $LN1@PM_GetVisE
$LN2@PM_GetVisE:

; 3371 : 	}
; 3372 : 	return -1;

	or	eax, -1
$LN1@PM_GetVisE:

; 3373 : }

	pop	ebp
	ret	0
?PM_GetVisEntInfo@@YAHH@Z ENDP				; PM_GetVisEntInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv70 = -1						; size = 1
_ppmove$ = 8						; size = 4
_server$ = 12						; size = 4
?PM_Move@@YAXPAUplayermove_s@@H@Z PROC			; PM_Move

; 3343 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3344 : 	assert( pm_shared_initialized );

	cmp	DWORD PTR ?pm_shared_initialized@@3HA, 0
	jne	SHORT $LN6@PM_Move
	push	3344					; 00000d10H
	push	OFFSET $SG16174
	push	OFFSET $SG16175
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@PM_Move:

; 3345 : 
; 3346 : 	pmove = ppmove;

	mov	ecx, DWORD PTR _ppmove$[ebp]
	mov	DWORD PTR ?pmove@@3PAUplayermove_s@@A, ecx ; pmove

; 3347 : 	
; 3348 : 	PM_PlayerMove( ( server != 0 ) ? true : false );

	cmp	DWORD PTR _server$[ebp], 0
	je	SHORT $LN7@PM_Move
	mov	BYTE PTR tv70[ebp], 1
	jmp	SHORT $LN8@PM_Move
$LN7@PM_Move:
	mov	BYTE PTR tv70[ebp], 0
$LN8@PM_Move:
	movzx	edx, BYTE PTR tv70[ebp]
	push	edx
	call	?PM_PlayerMove@@YAXH@Z			; PM_PlayerMove
	add	esp, 4

; 3349 : 
; 3350 : 	if ( pmove->onground != -1 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	je	SHORT $LN2@PM_Move

; 3351 : 	{
; 3352 : 		pmove->flags |= FL_ONGROUND;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+184], edx

; 3353 : 	}
; 3354 : 	else

	jmp	SHORT $LN3@PM_Move
$LN2@PM_Move:

; 3355 : 	{
; 3356 : 		pmove->flags &= ~FL_ONGROUND;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+184], edx
$LN3@PM_Move:

; 3357 : 	}
; 3358 : 
; 3359 : 	// In single player, reset friction after each movement to FrictionModifier Triggers work still.
; 3360 : 	if ( !pmove->multiplayer && ( pmove->movetype == MOVETYPE_WALK  ) )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN4@PM_Move
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+220], 3
	jne	SHORT $LN4@PM_Move

; 3361 : 	{
; 3362 : 		pmove->friction = 1.0f;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+196], xmm0
$LN4@PM_Move:

; 3363 : 	}
; 3364 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_Move@@YAXPAUplayermove_s@@H@Z ENDP			; PM_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_i$ = -36						; size = 4
_z$ = -32						; size = 4
_x$ = -28						; size = 4
_y$ = -24						; size = 4
_idx$ = -20						; size = 4
_zi$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?PM_CreateStuckTable@@YAXXZ PROC			; PM_CreateStuckTable

; 3227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3228 : 	float x, y, z;
; 3229 : 	int idx;
; 3230 : 	int i;
; 3231 : 	float zi[3];
; 3232 : 
; 3233 : 	memset( rgv3tStuckTable, 0, sizeof( rgv3tStuckTable ));

	push	648					; 00000288H
	push	0
	push	OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	_memset
	add	esp, 12					; 0000000cH

; 3234 : 
; 3235 : 	idx = 0;

	mov	DWORD PTR _idx$[ebp], 0

; 3236 : 	// Little Moves.
; 3237 : 	x = y = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 3238 : 	// Z moves
; 3239 : 	for (z = -0.125 ; z <= 0.125 ; z += 0.125)

	movss	xmm0, DWORD PTR __real@be000000
	movss	DWORD PTR _z$[ebp], xmm0
	jmp	SHORT $LN4@PM_CreateS
$LN2@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _z$[ebp], xmm0
$LN4@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _z$[ebp]
	movsd	xmm1, QWORD PTR __real@3fc0000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN3@PM_CreateS

; 3240 : 	{
; 3241 : 		rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3242 : 		rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3243 : 		rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3244 : 		idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3245 : 	}

	jmp	$LN2@PM_CreateS
$LN3@PM_CreateS:

; 3246 : 	x = z = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _z$[ebp], xmm0
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 3247 : 	// Y moves
; 3248 : 	for (y = -0.125 ; y <= 0.125 ; y += 0.125)

	movss	xmm0, DWORD PTR __real@be000000
	movss	DWORD PTR _y$[ebp], xmm0
	jmp	SHORT $LN7@PM_CreateS
$LN5@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	addsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm0
$LN7@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	movsd	xmm1, QWORD PTR __real@3fc0000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN6@PM_CreateS

; 3249 : 	{
; 3250 : 		rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3251 : 		rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3252 : 		rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3253 : 		idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3254 : 	}

	jmp	$LN5@PM_CreateS
$LN6@PM_CreateS:

; 3255 : 	y = z = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _z$[ebp], xmm0
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 3256 : 	// X moves
; 3257 : 	for (x = -0.125 ; x <= 0.125 ; x += 0.125)

	movss	xmm0, DWORD PTR __real@be000000
	movss	DWORD PTR _x$[ebp], xmm0
	jmp	SHORT $LN10@PM_CreateS
$LN8@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _x$[ebp]
	addsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _x$[ebp], xmm0
$LN10@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _x$[ebp]
	movsd	xmm1, QWORD PTR __real@3fc0000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN9@PM_CreateS

; 3258 : 	{
; 3259 : 		rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3260 : 		rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3261 : 		rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3262 : 		idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3263 : 	}

	jmp	$LN8@PM_CreateS
$LN9@PM_CreateS:

; 3264 : 
; 3265 : 	// Remaining multi axis nudges.
; 3266 : 	for ( x = - 0.125; x <= 0.125; x += 0.250 )

	movss	xmm0, DWORD PTR __real@be000000
	movss	DWORD PTR _x$[ebp], xmm0
	jmp	SHORT $LN13@PM_CreateS
$LN11@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _x$[ebp]
	addsd	xmm0, QWORD PTR __real@3fd0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _x$[ebp], xmm0
$LN13@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _x$[ebp]
	movsd	xmm1, QWORD PTR __real@3fc0000000000000
	comisd	xmm1, xmm0
	jb	$LN12@PM_CreateS

; 3267 : 	{
; 3268 : 		for ( y = - 0.125; y <= 0.125; y += 0.250 )

	movss	xmm0, DWORD PTR __real@be000000
	movss	DWORD PTR _y$[ebp], xmm0
	jmp	SHORT $LN16@PM_CreateS
$LN14@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	addsd	xmm0, QWORD PTR __real@3fd0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm0
$LN16@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	movsd	xmm1, QWORD PTR __real@3fc0000000000000
	comisd	xmm1, xmm0
	jb	$LN15@PM_CreateS

; 3269 : 		{
; 3270 : 			for ( z = - 0.125; z <= 0.125; z += 0.250 )

	movss	xmm0, DWORD PTR __real@be000000
	movss	DWORD PTR _z$[ebp], xmm0
	jmp	SHORT $LN19@PM_CreateS
$LN17@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@3fd0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _z$[ebp], xmm0
$LN19@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _z$[ebp]
	movsd	xmm1, QWORD PTR __real@3fc0000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN18@PM_CreateS

; 3271 : 			{
; 3272 : 				rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3273 : 				rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3274 : 				rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3275 : 				idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3276 : 			}

	jmp	$LN17@PM_CreateS
$LN18@PM_CreateS:

; 3277 : 		}

	jmp	$LN14@PM_CreateS
$LN15@PM_CreateS:

; 3278 : 	}

	jmp	$LN11@PM_CreateS
$LN12@PM_CreateS:

; 3279 : 
; 3280 : 	// Big Moves.
; 3281 : 	x = y = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 3282 : 	zi[0] = 0.0f;

	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _zi$[ebp+edx], xmm0

; 3283 : 	zi[1] = 1.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _zi$[ebp+eax], xmm0

; 3284 : 	zi[2] = 6.0f;

	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR _zi$[ebp+ecx], xmm0

; 3285 : 
; 3286 : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@PM_CreateS
$LN20@PM_CreateS:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN22@PM_CreateS:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN21@PM_CreateS

; 3287 : 	{
; 3288 : 		// Z moves
; 3289 : 		z = zi[i];

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _zi$[ebp+eax*4]
	movss	DWORD PTR _z$[ebp], xmm0

; 3290 : 		rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3291 : 		rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3292 : 		rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3293 : 		idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3294 : 	}

	jmp	$LN20@PM_CreateS
$LN21@PM_CreateS:

; 3295 : 
; 3296 : 	x = z = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _z$[ebp], xmm0
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 3297 : 
; 3298 : 	// Y moves
; 3299 : 	for (y = -2.0f ; y <= 2.0f ; y += 2.0)

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _y$[ebp], xmm0
	jmp	SHORT $LN25@PM_CreateS
$LN23@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	addsd	xmm0, QWORD PTR __real@4000000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm0
$LN25@PM_CreateS:
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _y$[ebp]
	jb	SHORT $LN24@PM_CreateS

; 3300 : 	{
; 3301 : 		rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3302 : 		rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3303 : 		rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3304 : 		idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3305 : 	}

	jmp	$LN23@PM_CreateS
$LN24@PM_CreateS:

; 3306 : 	y = z = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _z$[ebp], xmm0
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 3307 : 	// X moves
; 3308 : 	for (x = -2.0f ; x <= 2.0f ; x += 2.0f)

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _x$[ebp], xmm0
	jmp	SHORT $LN28@PM_CreateS
$LN26@PM_CreateS:
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _x$[ebp], xmm0
$LN28@PM_CreateS:
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _x$[ebp]
	jb	SHORT $LN27@PM_CreateS

; 3309 : 	{
; 3310 : 		rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3311 : 		rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3312 : 		rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3313 : 		idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3314 : 	}

	jmp	$LN26@PM_CreateS
$LN27@PM_CreateS:

; 3315 : 
; 3316 : 	// Remaining multi axis nudges.
; 3317 : 	for (i = 0 ; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@PM_CreateS
$LN29@PM_CreateS:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN31@PM_CreateS:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN30@PM_CreateS

; 3318 : 	{
; 3319 : 		z = zi[i];

	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _zi$[ebp+edx*4]
	movss	DWORD PTR _z$[ebp], xmm0

; 3320 : 		
; 3321 : 		for (x = -2.0f ; x <= 2.0f ; x += 2.0f)

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _x$[ebp], xmm0
	jmp	SHORT $LN34@PM_CreateS
$LN32@PM_CreateS:
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _x$[ebp], xmm0
$LN34@PM_CreateS:
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _x$[ebp]
	jb	$LN33@PM_CreateS

; 3322 : 		{
; 3323 : 			for (y = -2.0f ; y <= 2.0f ; y += 2.0)

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _y$[ebp], xmm0
	jmp	SHORT $LN37@PM_CreateS
$LN35@PM_CreateS:
	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	addsd	xmm0, QWORD PTR __real@4000000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm0
$LN37@PM_CreateS:
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _y$[ebp]
	jb	SHORT $LN36@PM_CreateS

; 3324 : 			{
; 3325 : 				rgv3tStuckTable[idx][0] = x;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3326 : 				rgv3tStuckTable[idx][1] = y;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 3327 : 				rgv3tStuckTable[idx][2] = z;

	imul	ecx, DWORD PTR _idx$[ebp], 12
	add	ecx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3328 : 				idx++;

	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$[ebp], eax

; 3329 : 			}

	jmp	$LN35@PM_CreateS
$LN36@PM_CreateS:

; 3330 : 		}

	jmp	$LN32@PM_CreateS
$LN33@PM_CreateS:

; 3331 : 	}

	jmp	$LN29@PM_CreateS
$LN30@PM_CreateS:

; 3332 : 
; 3333 : 	assert( idx < sizeof( rgv3tStuckTable ) / sizeof( rgv3tStuckTable[0] ));

	cmp	DWORD PTR _idx$[ebp], 54		; 00000036H
	jb	SHORT $LN39@PM_CreateS
	push	3333					; 00000d05H
	push	OFFSET $SG16166
	push	OFFSET $SG16167
	call	__wassert
	add	esp, 12					; 0000000cH
$LN39@PM_CreateS:

; 3334 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CreateStuckTable@@YAXXZ ENDP			; PM_CreateStuckTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv177 = -8						; size = 4
_pLadder$ = -4						; size = 4
_server$ = 8						; size = 4
?PM_PlayerMove@@YAXH@Z PROC				; PM_PlayerMove

; 2968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2969 : 	physent_t *pLadder = NULL;

	mov	DWORD PTR _pLadder$[ebp], 0

; 2970 : 
; 2971 : 	// Are we running server code?
; 2972 : 	pmove->server = server;                

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _server$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2973 : 
; 2974 : 	// Adjust speeds etc.
; 2975 : 	PM_CheckParamters();

	call	?PM_CheckParamters@@YAXXZ		; PM_CheckParamters

; 2976 : 
; 2977 : 	// Assume we don't touch anything
; 2978 : 	pmove->numtouch = 0;                    

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+283788], 0

; 2979 : 
; 2980 : 	// # of msec to apply movement
; 2981 : 	pmove->frametime = pmove->cmd.msec * 0.001;    

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, BYTE PTR [eax+283738]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [edx+16], xmm0

; 2982 : 
; 2983 : 	PM_ReduceTimers();

	call	?PM_ReduceTimers@@YAXXZ			; PM_ReduceTimers

; 2984 : 
; 2985 : 	// Convert view angles to vectors
; 2986 : 	AngleVectors( pmove->angles, pmove->forward, pmove->right, pmove->up );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 44					; 0000002cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 2987 : 
; 2988 : 	// Special handling for spectator and observers. (iuser1 is set if the player's in observer mode)
; 2989 : 	if ( pmove->spectator || pmove->iuser1 > 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+216], 0
	jne	SHORT $LN5@PM_PlayerM
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+508], 0
	jle	SHORT $LN4@PM_PlayerM
$LN5@PM_PlayerM:

; 2990 : 	{
; 2991 : 		PM_SpectatorMove();

	call	?PM_SpectatorMove@@YAXXZ		; PM_SpectatorMove

; 2992 : 		PM_CatagorizePosition();

	call	?PM_CatagorizePosition@@YAXXZ		; PM_CatagorizePosition

; 2993 : 		return;

	jmp	$LN1@PM_PlayerM
$LN4@PM_PlayerM:

; 2994 : 	}
; 2995 : 
; 2996 : 	// Always try and unstick us unless we are in NOCLIP mode
; 2997 : 	if( pmove->movetype != MOVETYPE_NOCLIP && pmove->movetype != MOVETYPE_NONE )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+220], 8
	je	SHORT $LN7@PM_PlayerM
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+220], 0
	je	SHORT $LN7@PM_PlayerM

; 2998 : 	{
; 2999 : 		if( PM_CheckStuck() )

	call	?PM_CheckStuck@@YAHXZ			; PM_CheckStuck
	test	eax, eax
	je	SHORT $LN7@PM_PlayerM

; 3000 : 		{
; 3001 : 			return;  // Can't move, we're stuck

	jmp	$LN1@PM_PlayerM
$LN7@PM_PlayerM:

; 3002 : 		}
; 3003 : 	}
; 3004 : 
; 3005 : 	// Now that we are "unstuck", see where we are ( waterlevel and type, pmove->onground ).
; 3006 : 	PM_CatagorizePosition();

	call	?PM_CatagorizePosition@@YAXXZ		; PM_CatagorizePosition

; 3007 : 
; 3008 : 	// Store off the starting water level
; 3009 : 	pmove->oldwaterlevel = pmove->waterlevel;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+228]
	mov	DWORD PTR [ecx+236], eax

; 3010 : 	if (pmove->watertype > CONTENT_FLYFIELD)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+232], -17		; ffffffefH
	jle	SHORT $LN8@PM_PlayerM

; 3011 : 		pmove->oldwaterlevel = pmove->waterlevel;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR [edx+236], ecx

; 3012 : 	else

	jmp	SHORT $LN9@PM_PlayerM
$LN8@PM_PlayerM:

; 3013 : 		pmove->oldwaterlevel = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+236], 0
$LN9@PM_PlayerM:

; 3014 : 
; 3015 : 	// If we are not on ground, store off how fast we are moving down
; 3016 : 	if ( pmove->onground == -1 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	jne	SHORT $LN10@PM_PlayerM

; 3017 : 	{
; 3018 : 		pmove->flFallVelocity = -pmove->velocity[2];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [edx+156], xmm0
$LN10@PM_PlayerM:

; 3019 : 	}
; 3020 : 
; 3021 : 	g_onladder = 0;

	mov	DWORD PTR ?g_onladder@@3HA, 0		; g_onladder

; 3022 : 	// Don't run ladder code if dead or on a train
; 3023 : 	if ( !pmove->dead && !(pmove->flags & FL_ONTRAIN) )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	jne	SHORT $LN12@PM_PlayerM
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, 16777216				; 01000000H
	jne	SHORT $LN12@PM_PlayerM

; 3024 : 	{
; 3025 : 		pLadder = PM_Ladder();

	call	?PM_Ladder@@YAPAUphysent_s@@XZ		; PM_Ladder
	mov	DWORD PTR _pLadder$[ebp], eax

; 3026 : 		if ( pLadder )

	cmp	DWORD PTR _pLadder$[ebp], 0
	je	SHORT $LN12@PM_PlayerM

; 3027 : 		{
; 3028 : 			g_onladder = 1;

	mov	DWORD PTR ?g_onladder@@3HA, 1		; g_onladder
$LN12@PM_PlayerM:

; 3029 : 		}
; 3030 : 	}
; 3031 : 
; 3032 : 	PM_UpdateStepSound();

	call	?PM_UpdateStepSound@@YAXXZ		; PM_UpdateStepSound

; 3033 : 
; 3034 : 	PM_Duck();

	call	?PM_Duck@@YAXXZ				; PM_Duck

; 3035 : 	
; 3036 : 	// Don't run ladder code if dead or on a train
; 3037 : 	if ( !pmove->dead && !(pmove->flags & FL_ONTRAIN) )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	jne	SHORT $LN16@PM_PlayerM
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, 16777216				; 01000000H
	jne	SHORT $LN16@PM_PlayerM

; 3038 : 	{
; 3039 : 		if ( pLadder )

	cmp	DWORD PTR _pLadder$[ebp], 0
	je	SHORT $LN14@PM_PlayerM

; 3040 : 		{
; 3041 : 			PM_LadderMove( pLadder );

	mov	eax, DWORD PTR _pLadder$[ebp]
	push	eax
	call	?PM_LadderMove@@YAXPAUphysent_s@@@Z	; PM_LadderMove
	add	esp, 4
	jmp	SHORT $LN16@PM_PlayerM
$LN14@PM_PlayerM:

; 3042 : 		}
; 3043 : 		else if ( pmove->movetype != MOVETYPE_WALK &&

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+220], 3
	je	SHORT $LN16@PM_PlayerM
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+220], 8
	je	SHORT $LN16@PM_PlayerM

; 3044 : 			      pmove->movetype != MOVETYPE_NOCLIP )
; 3045 : 		{
; 3046 : 			// Clear ladder stuff unless player is noclipping
; 3047 : 			//  it will be set immediately again next frame if necessary
; 3048 : 			pmove->movetype = MOVETYPE_WALK;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+220], 3
$LN16@PM_PlayerM:

; 3049 : 		}
; 3050 : 	}
; 3051 : 
; 3052 : 	// Slow down, I'm pulling it! (a box maybe) but only when I'm standing on ground
; 3053 : 	if ( ( pmove->onground != -1 ) && ( pmove->cmd.buttons & IN_USE) )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+224], -1
	je	SHORT $LN17@PM_PlayerM
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	eax, WORD PTR [edx+283766]
	and	eax, 32					; 00000020H
	je	SHORT $LN17@PM_PlayerM

; 3054 : 	{
; 3055 : 		pmove->velocity *= 0.3f;

	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$LN17@PM_PlayerM:

; 3056 : 	}
; 3057 : 
; 3058 : 	// Handle movement
; 3059 : 	switch ( pmove->movetype )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+220]
	mov	DWORD PTR tv177[ebp], edx
	cmp	DWORD PTR tv177[ebp], 10		; 0000000aH
	ja	SHORT $LN18@PM_PlayerM
	mov	eax, DWORD PTR tv177[ebp]
	movzx	ecx, BYTE PTR $LN44@PM_PlayerM[eax]
	jmp	DWORD PTR $LN45@PM_PlayerM[ecx*4]
$LN18@PM_PlayerM:

; 3060 : 	{
; 3061 : 	default:
; 3062 : 		pmove->Con_DPrintf("Bogus pmove player movetype %i on (%i) 0=cl 1=sv\n", pmove->movetype, pmove->server);

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+220]
	push	edx
	push	OFFSET $SG16094
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324964]
	call	ecx
	add	esp, 12					; 0000000cH

; 3063 : 		break;

	jmp	$LN2@PM_PlayerM
$LN19@PM_PlayerM:

; 3064 : 
; 3065 : 	case MOVETYPE_NONE:
; 3066 : 		break;

	jmp	$LN2@PM_PlayerM
$LN20@PM_PlayerM:

; 3067 : 
; 3068 : 	case MOVETYPE_NOCLIP:
; 3069 : 		PM_NoClip();

	call	?PM_NoClip@@YAXXZ			; PM_NoClip

; 3070 : 		break;

	jmp	$LN2@PM_PlayerM
$LN21@PM_PlayerM:

; 3071 : 
; 3072 : 	case MOVETYPE_TOSS:
; 3073 : 	case MOVETYPE_BOUNCE:
; 3074 : 		PM_Physics_Toss();

	call	?PM_Physics_Toss@@YAXXZ			; PM_Physics_Toss

; 3075 : 		break;

	jmp	$LN2@PM_PlayerM
$LN22@PM_PlayerM:

; 3076 : 
; 3077 : 	case MOVETYPE_FLY:
; 3078 : 	
; 3079 : 		PM_CheckWater();

	call	?PM_CheckWater@@YAHXZ			; PM_CheckWater

; 3080 : 
; 3081 : 		// Was jump button pressed?
; 3082 : 		// If so, set velocity to 270 away from ladder.  This is currently wrong.
; 3083 : 		// Also, set MOVE_TYPE to walk, too.
; 3084 : 		if ( pmove->cmd.buttons & IN_JUMP )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	eax, WORD PTR [edx+283766]
	and	eax, 2
	je	SHORT $LN23@PM_PlayerM

; 3085 : 		{
; 3086 : 			if ( !pLadder )

	cmp	DWORD PTR _pLadder$[ebp], 0
	jne	SHORT $LN25@PM_PlayerM

; 3087 : 			{
; 3088 : 				PM_Jump ();

	call	?PM_Jump@@YAXXZ				; PM_Jump
$LN25@PM_PlayerM:

; 3089 : 			}
; 3090 : 		}
; 3091 : 		else

	jmp	SHORT $LN24@PM_PlayerM
$LN23@PM_PlayerM:

; 3092 : 		{
; 3093 : 			pmove->oldbuttons &= ~IN_JUMP;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+200]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+200], edx
$LN24@PM_PlayerM:

; 3094 : 		}
; 3095 : 		
; 3096 : 		// perform the move accounting for any base velocity.
; 3097 : 		pmove->velocity += pmove->basevelocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 3098 : 
; 3099 : 		PM_FlyMove();

	call	?PM_FlyMove@@YAHXZ			; PM_FlyMove

; 3100 : 
; 3101 : 		pmove->velocity -= pmove->basevelocity;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 3102 : 		break;

	jmp	$LN2@PM_PlayerM
$LN26@PM_PlayerM:

; 3103 : 
; 3104 : 	case MOVETYPE_WALK:
; 3105 : 		if ( !PM_InWater() )

	call	?PM_InWater@@YAHXZ			; PM_InWater
	test	eax, eax
	jne	SHORT $LN27@PM_PlayerM

; 3106 : 		{
; 3107 : 			PM_AddCorrectGravity();

	call	?PM_AddCorrectGravity@@YAXXZ		; PM_AddCorrectGravity
$LN27@PM_PlayerM:

; 3108 : 		}
; 3109 : 
; 3110 : 		// If we are leaping out of the water, just update the counters.
; 3111 : 		if ( pmove->waterjumptime )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@PM_PlayerM

; 3112 : 		{
; 3113 : 			PM_WaterJump();

	call	?PM_WaterJump@@YAXXZ			; PM_WaterJump

; 3114 : 			PM_FlyMove();

	call	?PM_FlyMove@@YAHXZ			; PM_FlyMove

; 3115 : 
; 3116 : 			// Make sure waterlevel is set correctly
; 3117 : 			PM_CheckWater();

	call	?PM_CheckWater@@YAHXZ			; PM_CheckWater

; 3118 : 			return;

	jmp	$LN1@PM_PlayerM
$LN28@PM_PlayerM:

; 3119 : 		}
; 3120 : 
; 3121 : 		// If we are swimming in the water, see if we are nudging against a place we can jump up out
; 3122 : 		//  of, and, if so, start out jump.  Otherwise, if we are not moving up, then reset jump timer to 0
; 3123 : 		if ( pmove->waterlevel >= 2 && pmove->watertype != CONTENT_FOG) 

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 2
	jl	$LN29@PM_PlayerM
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+232], -19		; ffffffedH
	je	$LN29@PM_PlayerM

; 3124 : 		{
; 3125 : 			if ( pmove->waterlevel == 2 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+228], 2
	jne	SHORT $LN31@PM_PlayerM

; 3126 : 			{
; 3127 : 				PM_CheckWaterJump();

	call	?PM_CheckWaterJump@@YAXXZ		; PM_CheckWaterJump
$LN31@PM_PlayerM:

; 3128 : 			}
; 3129 : 
; 3130 : 			// If we are falling again, then we must not trying to jump out of water any more.
; 3131 : 			if ( pmove->velocity[2] < 0 && pmove->waterjumptime )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+ecx]
	jbe	SHORT $LN32@PM_PlayerM
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN32@PM_PlayerM

; 3132 : 			{
; 3133 : 				pmove->waterjumptime = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+204], xmm0
$LN32@PM_PlayerM:

; 3134 : 			}
; 3135 : 
; 3136 : 			// Was jump button pressed?
; 3137 : 			if (pmove->cmd.buttons & IN_JUMP)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, WORD PTR [ecx+283766]
	and	edx, 2
	je	SHORT $LN33@PM_PlayerM

; 3138 : 			{
; 3139 : 				PM_Jump ();

	call	?PM_Jump@@YAXXZ				; PM_Jump

; 3140 : 			}
; 3141 : 			else

	jmp	SHORT $LN34@PM_PlayerM
$LN33@PM_PlayerM:

; 3142 : 			{
; 3143 : 				pmove->oldbuttons &= ~IN_JUMP;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+200]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+200], ecx
$LN34@PM_PlayerM:

; 3144 : 			}
; 3145 : 
; 3146 : 			// Perform regular water movement
; 3147 : 			PM_WaterMove();

	call	?PM_WaterMove@@YAXXZ			; PM_WaterMove

; 3148 : 			
; 3149 : 			pmove->velocity -= pmove->basevelocity;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 3150 : 
; 3151 : 			// Get a final position
; 3152 : 			PM_CatagorizePosition();

	call	?PM_CatagorizePosition@@YAXXZ		; PM_CatagorizePosition

; 3153 : 		}
; 3154 : 		else

	jmp	$LN30@PM_PlayerM
$LN29@PM_PlayerM:

; 3155 : 
; 3156 : 		// Not underwater
; 3157 : 		{
; 3158 : 			// Was jump button pressed?
; 3159 : 			if ( pmove->cmd.buttons & IN_JUMP )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, WORD PTR [ecx+283766]
	and	edx, 2
	je	SHORT $LN35@PM_PlayerM

; 3160 : 			{
; 3161 : 				if ( !pLadder )

	cmp	DWORD PTR _pLadder$[ebp], 0
	jne	SHORT $LN37@PM_PlayerM

; 3162 : 				{
; 3163 : 					PM_Jump ();

	call	?PM_Jump@@YAXXZ				; PM_Jump
$LN37@PM_PlayerM:

; 3164 : 				}
; 3165 : 			}
; 3166 : 			else

	jmp	SHORT $LN36@PM_PlayerM
$LN35@PM_PlayerM:

; 3167 : 			{
; 3168 : 				pmove->oldbuttons &= ~IN_JUMP;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+200]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+200], ecx
$LN36@PM_PlayerM:

; 3169 : 			}
; 3170 : 
; 3171 : 			// Fricion is handled before we add in any base velocity. That way, if we are on a conveyor, 
; 3172 : 			//  we don't slow when standing still, relative to the conveyor.
; 3173 : 			if ( pmove->onground != -1 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	je	SHORT $LN38@PM_PlayerM

; 3174 : 			{
; 3175 : 				pmove->velocity[2] = 0.0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 3176 : 				PM_Friction();

	call	?PM_Friction@@YAXXZ			; PM_Friction
$LN38@PM_PlayerM:

; 3177 : 			}
; 3178 : 
; 3179 : 			// Make sure velocity is valid.
; 3180 : 			PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity

; 3181 : 
; 3182 : 			// Are we on ground now
; 3183 : 			if ( pmove->onground != -1 )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+224], -1
	je	SHORT $LN39@PM_PlayerM

; 3184 : 			{
; 3185 : 				PM_WalkMove();

	call	?PM_WalkMove@@YAXXZ			; PM_WalkMove

; 3186 : 			}
; 3187 : 			else

	jmp	SHORT $LN40@PM_PlayerM
$LN39@PM_PlayerM:

; 3188 : 			{
; 3189 : 				PM_AirMove();  // Take into account movement when in air.

	call	?PM_AirMove@@YAXXZ			; PM_AirMove
$LN40@PM_PlayerM:

; 3190 : 			}
; 3191 : 
; 3192 : 			// Set final flags.
; 3193 : 			PM_CatagorizePosition();

	call	?PM_CatagorizePosition@@YAXXZ		; PM_CatagorizePosition

; 3194 : 
; 3195 : 			// Now pull the base velocity back out.
; 3196 : 			// Base velocity is set if you are on a moving object, like
; 3197 : 			//  a conveyor (or maybe another monster?)
; 3198 : 			pmove->velocity -= pmove->basevelocity;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 3199 : 				
; 3200 : 			// Make sure velocity is valid.
; 3201 : 			PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity

; 3202 : 
; 3203 : 			// Add any remaining gravitational component.
; 3204 : 			if ( !PM_InWater() )

	call	?PM_InWater@@YAHXZ			; PM_InWater
	test	eax, eax
	jne	SHORT $LN41@PM_PlayerM

; 3205 : 			{
; 3206 : 				PM_FixupGravityVelocity();

	call	?PM_FixupGravityVelocity@@YAXXZ		; PM_FixupGravityVelocity
$LN41@PM_PlayerM:

; 3207 : 			}
; 3208 : 
; 3209 : 			// If we are on ground, no downward velocity.
; 3210 : 			if ( pmove->onground != -1 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+224], -1
	je	SHORT $LN42@PM_PlayerM

; 3211 : 			{
; 3212 : 				pmove->velocity[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN42@PM_PlayerM:

; 3213 : 			}
; 3214 : 
; 3215 : 			// See if we landed on the ground with enough force to play
; 3216 : 			//  a landing sound.
; 3217 : 			PM_CheckFalling();

	call	?PM_CheckFalling@@YAXXZ			; PM_CheckFalling
$LN30@PM_PlayerM:

; 3218 : 		}
; 3219 : 
; 3220 : 		// Did we enter or leave the water?
; 3221 : 		PM_PlayWaterSounds();

	call	?PM_PlayWaterSounds@@YAXXZ		; PM_PlayWaterSounds
$LN2@PM_PlayerM:
$LN1@PM_PlayerM:

; 3222 : 		break;
; 3223 : 	}
; 3224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN45@PM_PlayerM:
	DD	$LN19@PM_PlayerM
	DD	$LN26@PM_PlayerM
	DD	$LN22@PM_PlayerM
	DD	$LN21@PM_PlayerM
	DD	$LN20@PM_PlayerM
	DD	$LN18@PM_PlayerM
$LN44@PM_PlayerM:
	DB	0
	DB	5
	DB	5
	DB	1
	DB	5
	DB	2
	DB	3
	DB	5
	DB	4
	DB	5
	DB	3
?PM_PlayerMove@@YAXH@Z ENDP				; PM_PlayerMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
?PM_ReduceTimers@@YAXXZ PROC				; PM_ReduceTimers

; 2930 : {

	push	ebp
	mov	ebp, esp

; 2931 : 	if ( pmove->flTimeStepSound > 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+148], 0
	jle	SHORT $LN3@PM_ReduceT

; 2932 : 	{
; 2933 : 		pmove->flTimeStepSound -= pmove->cmd.msec;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, BYTE PTR [ecx+283738]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+148]
	sub	ecx, edx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+148], ecx

; 2934 : 		if ( pmove->flTimeStepSound < 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+148], 0
	jge	SHORT $LN3@PM_ReduceT

; 2935 : 		{
; 2936 : 			pmove->flTimeStepSound = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+148], 0
$LN3@PM_ReduceT:

; 2937 : 		}
; 2938 : 	}
; 2939 : 	if ( pmove->flDuckTime > 0 )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+140]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@PM_ReduceT

; 2940 : 	{
; 2941 : 		pmove->flDuckTime -= pmove->cmd.msec;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, BYTE PTR [eax+283738]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm1, DWORD PTR [edx+140]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [eax+140], xmm1

; 2942 : 		if ( pmove->flDuckTime < 0 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+140]
	jbe	SHORT $LN5@PM_ReduceT

; 2943 : 		{
; 2944 : 			pmove->flDuckTime = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+140], xmm0
$LN5@PM_ReduceT:

; 2945 : 		}
; 2946 : 	}
; 2947 : 	if ( pmove->flSwimTime > 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+172]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@PM_ReduceT

; 2948 : 	{
; 2949 : 		pmove->flSwimTime -= pmove->cmd.msec;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, BYTE PTR [ecx+283738]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm1, DWORD PTR [eax+172]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [ecx+172], xmm1

; 2950 : 		if ( pmove->flSwimTime < 0 )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+172]
	jbe	SHORT $LN7@PM_ReduceT

; 2951 : 		{
; 2952 : 			pmove->flSwimTime = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+172], xmm0
$LN7@PM_ReduceT:

; 2953 : 		}
; 2954 : 	}
; 2955 : }

	pop	ebp
	ret	0
?PM_ReduceTimers@@YAXXZ ENDP				; PM_ReduceTimers
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_v_angle$ = -40						; size = 12
tv391 = -28						; size = 4
tv359 = -24						; size = 4
tv255 = -20						; size = 4
tv128 = -16						; size = 4
_fRatio$1 = -12						; size = 4
_maxspeed$ = -8						; size = 4
_spd$ = -4						; size = 4
?PM_CheckParamters@@YAXXZ PROC				; PM_CheckParamters

; 2854 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi

; 2855 : 	float spd;
; 2856 : 	float maxspeed;
; 2857 : 	Vector	v_angle;

	lea	ecx, DWORD PTR _v_angle$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2858 : 
; 2859 : 	// clear stuck flag for each frame
; 2860 : 	pmove->flags &= ~FL_STUCKED;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	and	ecx, -134217729				; f7ffffffH
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+184], ecx

; 2861 : 
; 2862 : 	spd = ( pmove->cmd.forwardmove * pmove->cmd.forwardmove ) +

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+283752]
	mulss	xmm0, DWORD PTR [ecx+283752]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm1, DWORD PTR [edx+283756]
	mulss	xmm1, DWORD PTR [eax+283756]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm1, DWORD PTR [ecx+283760]
	mulss	xmm1, DWORD PTR [edx+283760]
	addss	xmm0, xmm1
	movss	DWORD PTR _spd$[ebp], xmm0

; 2863 : 		  ( pmove->cmd.sidemove * pmove->cmd.sidemove ) +
; 2864 : 		  ( pmove->cmd.upmove * pmove->cmd.upmove );
; 2865 : 	spd = sqrt( spd );

	cvtss2sd xmm0, DWORD PTR _spd$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _spd$[ebp]

; 2866 : 
; 2867 : 	maxspeed = pmove->clientmaxspeed; //atof( pmove->PM_Info_ValueForKey( pmove->physinfo, "maxspd" ) );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+504]
	movss	DWORD PTR _maxspeed$[ebp], xmm0

; 2868 : 	if ( maxspeed != 0.0 )

	cvtss2sd xmm0, DWORD PTR _maxspeed$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PM_CheckPa

; 2869 : 	{
; 2870 : 		pmove->maxspeed = min( maxspeed, pmove->maxspeed );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+500]
	comiss	xmm0, DWORD PTR _maxspeed$[ebp]
	jbe	SHORT $LN12@PM_CheckPa
	movss	xmm0, DWORD PTR _maxspeed$[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN13@PM_CheckPa
$LN12@PM_CheckPa:
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+500]
	movss	DWORD PTR tv128[ebp], xmm0
$LN13@PM_CheckPa:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR [eax+500], xmm0
$LN2@PM_CheckPa:

; 2871 : 	}
; 2872 : 
; 2873 : 	if ( ( spd != 0.0 ) &&

	cvtss2sd xmm0, DWORD PTR _spd$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@PM_CheckPa
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _spd$[ebp]
	comiss	xmm0, DWORD PTR [ecx+500]
	jbe	SHORT $LN3@PM_CheckPa

; 2874 : 		 ( spd > pmove->maxspeed ) )
; 2875 : 	{
; 2876 : 		float fRatio = pmove->maxspeed / spd;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+500]
	divss	xmm0, DWORD PTR _spd$[ebp]
	movss	DWORD PTR _fRatio$1[ebp], xmm0

; 2877 : 		pmove->cmd.forwardmove *= fRatio;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+283752]
	mulss	xmm0, DWORD PTR _fRatio$1[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [ecx+283752], xmm0

; 2878 : 		pmove->cmd.sidemove    *= fRatio;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+283756]
	mulss	xmm0, DWORD PTR _fRatio$1[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [eax+283756], xmm0

; 2879 : 		pmove->cmd.upmove      *= fRatio;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+283760]
	mulss	xmm0, DWORD PTR _fRatio$1[ebp]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [edx+283760], xmm0
$LN3@PM_CheckPa:

; 2880 : 	}
; 2881 : 
; 2882 : 	if ( pmove->flags & FL_FROZEN || pmove->dead )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN5@PM_CheckPa
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+208], 0
	je	SHORT $LN4@PM_CheckPa
$LN5@PM_CheckPa:

; 2883 : 	{
; 2884 : 		pmove->cmd.forwardmove = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+283752], xmm0

; 2885 : 		pmove->cmd.sidemove    = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+283756], xmm0

; 2886 : 		pmove->cmd.upmove      = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+283760], xmm0

; 2887 : 		pmove->cmd.buttons     = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	WORD PTR [ecx+283766], ax
$LN4@PM_CheckPa:

; 2888 : 	}
; 2889 : 
; 2890 : 	if ( pmove->flags & FL_ONTRAIN )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN6@PM_CheckPa

; 2891 : 	{
; 2892 : 		pmove->cmd.forwardmove = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+283752], xmm0

; 2893 : 		pmove->cmd.sidemove    = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+283756], xmm0

; 2894 : 		pmove->cmd.upmove      = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+283760], xmm0
$LN6@PM_CheckPa:

; 2895 : 	}
; 2896 : 
; 2897 : 	PM_DropPunchAngle( pmove->punchangle );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 160				; 000000a0H
	push	ecx
	call	?PM_DropPunchAngle@@YAXAAVVector@@@Z	; PM_DropPunchAngle
	add	esp, 4

; 2898 : 
; 2899 : 	// Take angles from command.
; 2900 : 	if ( !pmove->dead )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+208], 0
	jne	$LN7@PM_CheckPa

; 2901 : 	{
; 2902 : 		v_angle = pmove->cmd.viewangles;          

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 283740				; 0004545cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v_angle$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _v_angle$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _v_angle$[ebp+8], eax

; 2903 : 		v_angle += pmove->punchangle;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 160				; 000000a0H
	push	ecx
	lea	ecx, DWORD PTR _v_angle$[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2904 : 
; 2905 : 		// set up view angles.
; 2906 : 		pmove->angles[PITCH] = v_angle[PITCH];

	lea	ecx, DWORD PTR _v_angle$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edx, 4
	imul	edi, edx, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 2907 : 		pmove->angles[YAW] = v_angle[YAW];

	lea	ecx, DWORD PTR _v_angle$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 2908 : 		pmove->angles[ROLL]	= PM_CalcRoll( v_angle, pmove->velocity, pmove->movevars->rollangle, pmove->movevars->rollspeed ) * 4;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	push	ecx
	movss	xmm0, DWORD PTR [edx+100]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _v_angle$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_CalcRoll@@YAMVVector@@0MM@Z		; PM_CalcRoll
	add	esp, 32					; 00000020H
	fstp	DWORD PTR tv359[ebp]
	movss	xmm0, DWORD PTR tv359[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	movss	DWORD PTR tv391[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv391[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 2909 : 	}
; 2910 : 	else

	jmp	SHORT $LN8@PM_CheckPa
$LN7@PM_CheckPa:

; 2911 : 	{
; 2912 : 		pmove->angles = pmove->oldangles;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 80					; 00000050H
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
$LN8@PM_CheckPa:

; 2913 : 	}
; 2914 : 
; 2915 : 	// Set dead player view_offset
; 2916 : 	if ( pmove->dead )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	je	SHORT $LN9@PM_CheckPa

; 2917 : 	{
; 2918 : 		pmove->view_ofs[2] = PM_DEAD_VIEWHEIGHT;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@c1000000
	movss	DWORD PTR [eax+ecx], xmm0
$LN9@PM_CheckPa:

; 2919 : 	}
; 2920 : 
; 2921 : 	// Adjust client view angles to match values used on server.
; 2922 : 	if (pmove->angles[YAW] > 180.0f)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN10@PM_CheckPa

; 2923 : 	{
; 2924 : 		pmove->angles[YAW] -= 360.0f;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	add	eax, ecx
	mov	DWORD PTR tv255[ebp], eax
	mov	edx, DWORD PTR tv255[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR __real@43b40000
	mov	eax, DWORD PTR tv255[ebp]
	movss	DWORD PTR [eax], xmm0
$LN10@PM_CheckPa:

; 2925 : 	}
; 2926 : 
; 2927 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CheckParamters@@YAXXZ ENDP				; PM_CheckParamters
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 12
tv82 = -12						; size = 8
_len$ = -4						; size = 4
_punchangle$ = 8					; size = 4
?PM_DropPunchAngle@@YAXAAVVector@@@Z PROC		; PM_DropPunchAngle

; 2836 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2837 : 	float	len;
; 2838 : 
; 2839 : 	len = punchangle.Length();

	mov	ecx, DWORD PTR _punchangle$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _len$[ebp]

; 2840 : 	punchangle = punchangle.Normalize();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _punchangle$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR _punchangle$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2841 : 
; 2842 : 	len -= (10.0 + len * 0.5) * pmove->frametime;

	cvtss2sd xmm0, DWORD PTR _len$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm0, QWORD PTR __real@4024000000000000
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm1, DWORD PTR [ecx+16]
	mulsd	xmm0, xmm1
	cvtss2sd xmm1, DWORD PTR _len$[ebp]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _len$[ebp], xmm0

; 2843 : 	len = max( len, 0.0 );

	cvtss2sd xmm0, DWORD PTR _len$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN3@PM_DropPun
	cvtss2sd xmm0, DWORD PTR _len$[ebp]
	movsd	QWORD PTR tv82[ebp], xmm0
	jmp	SHORT $LN4@PM_DropPun
$LN3@PM_DropPun:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv82[ebp], xmm0
$LN4@PM_DropPun:
	cvtsd2ss xmm0, QWORD PTR tv82[ebp]
	movss	DWORD PTR _len$[ebp], xmm0

; 2844 : 	punchangle *= len;

	push	ecx
	movss	xmm0, DWORD PTR _len$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _punchangle$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 2845 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_DropPunchAngle@@YAXAAVVector@@@Z ENDP		; PM_DropPunchAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_forward$ = -56						; size = 12
_up$ = -44						; size = 12
_right$ = -32						; size = 12
tv144 = -20						; size = 4
_sign$ = -16						; size = 4
_value$ = -12						; size = 4
tv83 = -8						; size = 4
_side$ = -4						; size = 4
_angles$ = 8						; size = 12
_velocity$ = 20						; size = 12
_rollangle$ = 32					; size = 4
_rollspeed$ = 36					; size = 4
?PM_CalcRoll@@YAMVVector@@0MM@Z PROC			; PM_CalcRoll

; 2801 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2802 : 	float   sign;
; 2803 : 	float   side;
; 2804 : 	float   value;
; 2805 : 	Vector  forward, right, up;

	lea	ecx, DWORD PTR _forward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _right$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _up$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2806 :     
; 2807 : 	AngleVectors (angles, forward, right, up);

	lea	ecx, DWORD PTR _up$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 2808 :     
; 2809 : 	side = DotProduct (velocity, right);

	lea	eax, DWORD PTR _right$[ebp]
	push	eax
	lea	ecx, DWORD PTR _velocity$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _side$[ebp]

; 2810 :     
; 2811 : 	sign = side < 0 ? -1 : 1;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _side$[ebp]
	jbe	SHORT $LN5@PM_CalcRol
	mov	DWORD PTR tv83[ebp], -1
	jmp	SHORT $LN6@PM_CalcRol
$LN5@PM_CalcRol:
	mov	DWORD PTR tv83[ebp], 1
$LN6@PM_CalcRol:
	cvtsi2ss xmm0, DWORD PTR tv83[ebp]
	movss	DWORD PTR _sign$[ebp], xmm0

; 2812 :     
; 2813 : 	side = fabs(side);

	cvtss2sd xmm0, DWORD PTR _side$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _side$[ebp]

; 2814 :     
; 2815 : 	value = rollangle;

	movss	xmm0, DWORD PTR _rollangle$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 2816 :     
; 2817 : 	if (side < rollspeed)

	movss	xmm0, DWORD PTR _rollspeed$[ebp]
	comiss	xmm0, DWORD PTR _side$[ebp]
	jbe	SHORT $LN2@PM_CalcRol

; 2818 : 	{
; 2819 : 		side = side * value / rollspeed;

	movss	xmm0, DWORD PTR _side$[ebp]
	mulss	xmm0, DWORD PTR _value$[ebp]
	divss	xmm0, DWORD PTR _rollspeed$[ebp]
	movss	DWORD PTR _side$[ebp], xmm0

; 2820 : 	}
; 2821 : 	else

	jmp	SHORT $LN3@PM_CalcRol
$LN2@PM_CalcRol:

; 2822 : 	{
; 2823 : 		side = value;

	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR _side$[ebp], xmm0
$LN3@PM_CalcRol:

; 2824 : 	}
; 2825 :   
; 2826 : 	return side * sign;

	movss	xmm0, DWORD PTR _side$[ebp]
	mulss	xmm0, DWORD PTR _sign$[ebp]
	movss	DWORD PTR tv144[ebp], xmm0
	fld	DWORD PTR tv144[ebp]

; 2827 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CalcRoll@@YAMVVector@@0MM@Z ENDP			; PM_CalcRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv78 = -4						; size = 4
?PM_PlayWaterSounds@@YAXXZ PROC				; PM_PlayWaterSounds

; 2771 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2772 : 	// Did we enter or leave water?
; 2773 : 	if  ( ( pmove->oldwaterlevel == 0 && pmove->waterlevel != 0 && pmove->watertype > CONTENT_FLYFIELD) ||

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+236], 0
	jne	SHORT $LN6@PM_PlayWat
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 0
	je	SHORT $LN6@PM_PlayWat
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+232], -17		; ffffffefH
	jg	SHORT $LN5@PM_PlayWat
$LN6@PM_PlayWat:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+236], 0
	je	$LN2@PM_PlayWat
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 0
	jne	$LN2@PM_PlayWat
$LN5@PM_PlayWat:

; 2774 : 		  ( pmove->oldwaterlevel != 0 && pmove->waterlevel == 0 ))
; 2775 : 	{
; 2776 : 		switch ( pmove->RandomLong(0,3) )

	push	3
	push	0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325000]
	call	eax
	add	esp, 8
	mov	DWORD PTR tv78[ebp], eax
	cmp	DWORD PTR tv78[ebp], 3
	ja	$LN2@PM_PlayWat
	mov	ecx, DWORD PTR tv78[ebp]
	jmp	DWORD PTR $LN12@PM_PlayWat[ecx*4]
$LN7@PM_PlayWat:

; 2777 : 		{
; 2778 : 		case 0:
; 2779 : 			pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade1.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG16020
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H

; 2780 : 			break;

	jmp	$LN2@PM_PlayWat
$LN8@PM_PlayWat:

; 2781 : 		case 1:
; 2782 : 			pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade2.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG16022
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H

; 2783 : 			break;

	jmp	SHORT $LN2@PM_PlayWat
$LN9@PM_PlayWat:

; 2784 : 		case 2:
; 2785 : 			pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade3.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG16024
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H

; 2786 : 			break;

	jmp	SHORT $LN2@PM_PlayWat
$LN10@PM_PlayWat:

; 2787 : 		case 3:
; 2788 : 			pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade4.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG16026
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
$LN2@PM_PlayWat:

; 2789 : 			break;
; 2790 : 		}
; 2791 : 	}
; 2792 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@PM_PlayWat:
	DD	$LN7@PM_PlayWat
	DD	$LN8@PM_PlayWat
	DD	$LN9@PM_PlayWat
	DD	$LN10@PM_PlayWat
?PM_PlayWaterSounds@@YAXXZ ENDP				; PM_PlayWaterSounds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv220 = -16						; size = 4
_tfc$1 = -12						; size = 4
_fvol$2 = -8						; size = 4
tv91 = -1						; size = 1
?PM_CheckFalling@@YAXXZ PROC				; PM_CheckFalling

; 2696 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2697 : 	if ( pmove->onground != -1 &&
; 2698 : 		 !pmove->dead &&

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	je	$LN12@PM_CheckFa
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+208], 0
	jne	$LN12@PM_CheckFa
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+156]
	comiss	xmm0, DWORD PTR __real@43af0000
	jb	$LN12@PM_CheckFa

; 2699 : 		 pmove->flFallVelocity >= PLAYER_FALL_PUNCH_THRESHHOLD )
; 2700 : 	{
; 2701 : 		float fvol = 0.5;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _fvol$2[ebp], xmm0

; 2702 : 
; 2703 : 		if ( pmove->waterlevel > 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+228], 0
	jle	SHORT $LN3@PM_CheckFa
	jmp	$LN10@PM_CheckFa
$LN3@PM_CheckFa:

; 2704 : 		{
; 2705 : 		}
; 2706 : 		else if ( pmove->flFallVelocity > PLAYER_MAX_SAFE_FALL_SPEED )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+156]
	comiss	xmm0, DWORD PTR __real@44110000
	jbe	SHORT $LN5@PM_CheckFa

; 2707 : 		{
; 2708 : 			// NOTE:  In the original game dll , there were no breaks after these cases, causing the first one to 
; 2709 : 			// cascade into the second
; 2710 : 			//switch ( RandomLong(0,1) )
; 2711 : 			//{
; 2712 : 			//case 0:
; 2713 : 				//pmove->PM_PlaySound( CHAN_VOICE, "player/pl_fallpain2.wav", 1, ATTN_NORM, 0, PITCH_NORM );
; 2714 : 				//break;
; 2715 : 			//case 1:
; 2716 : 				pmove->PM_PlaySound( CHAN_VOICE, "player/pl_fallpain3.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15997
	push	2
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H

; 2717 : 			//	break;
; 2718 : 			//}
; 2719 : 			fvol = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fvol$2[ebp], xmm0
	jmp	$LN10@PM_CheckFa
$LN5@PM_CheckFa:

; 2720 : 		}
; 2721 : 		else if ( pmove->flFallVelocity > PLAYER_MAX_SAFE_FALL_SPEED / 2 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+156]
	comiss	xmm0, DWORD PTR __real@43910000
	jbe	$LN7@PM_CheckFa

; 2722 : 		{
; 2723 : 			qboolean tfc = false;

	mov	DWORD PTR _tfc$1[ebp], 0

; 2724 : 			tfc = atoi( pmove->PM_Info_ValueForKey( pmove->physinfo, "tfc" ) ) == 1 ? true : false;

	push	OFFSET $SG16000
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 324592				; 0004f3f0H
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324948]
	call	ecx
	add	esp, 8
	push	eax
	call	_atoi
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN15@PM_CheckFa
	mov	BYTE PTR tv91[ebp], 1
	jmp	SHORT $LN16@PM_CheckFa
$LN15@PM_CheckFa:
	mov	BYTE PTR tv91[ebp], 0
$LN16@PM_CheckFa:
	movzx	edx, BYTE PTR tv91[ebp]
	mov	DWORD PTR _tfc$1[ebp], edx

; 2725 : 
; 2726 : 			if ( tfc )

	cmp	DWORD PTR _tfc$1[ebp], 0
	je	SHORT $LN9@PM_CheckFa

; 2727 : 			{
; 2728 : 				pmove->PM_PlaySound( CHAN_VOICE, "player/pl_fallpain3.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG16002
	push	2
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
$LN9@PM_CheckFa:

; 2729 : 			}
; 2730 : 
; 2731 : 			fvol = 0.85;

	movss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR _fvol$2[ebp], xmm0
	jmp	SHORT $LN10@PM_CheckFa
$LN7@PM_CheckFa:

; 2732 : 		}
; 2733 : 		else if ( pmove->flFallVelocity < PLAYER_MIN_BOUNCE_SPEED )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR [edx+156]
	jbe	SHORT $LN10@PM_CheckFa

; 2734 : 		{
; 2735 : 			fvol = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _fvol$2[ebp], xmm0
$LN10@PM_CheckFa:

; 2736 : 		}
; 2737 : 
; 2738 : 		if ( fvol > 0.0 )

	cvtss2sd xmm0, DWORD PTR _fvol$2[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN12@PM_CheckFa

; 2739 : 		{
; 2740 : 			// Play landing step right away
; 2741 : 			pmove->flTimeStepSound = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+148], 0

; 2742 : 			
; 2743 : 			PM_UpdateStepSound();

	call	?PM_UpdateStepSound@@YAXXZ		; PM_UpdateStepSound

; 2744 : 			
; 2745 : 			// play step sound for current texture
; 2746 : 			PM_PlayStepSound( PM_MapTextureTypeStepType( pmove->chtexturetype ), fvol );

	push	ecx
	movss	xmm0, DWORD PTR _fvol$2[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, BYTE PTR [ecx+496]
	push	edx
	call	?PM_MapTextureTypeStepType@@YAHD@Z	; PM_MapTextureTypeStepType
	add	esp, 4
	push	eax
	call	?PM_PlayStepSound@@YAXHM@Z		; PM_PlayStepSound
	add	esp, 8

; 2747 : 
; 2748 : 			// Knock the screen around a little bit, temporary effect
; 2749 : 			pmove->punchangle[ 2 ] = pmove->flFallVelocity * 0.013;	// punch z axis

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [eax+156]
	mulsd	xmm0, QWORD PTR __real@3f8a9fbe76c8b439
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 160				; 000000a0H
	movss	DWORD PTR tv220[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 2750 : 
; 2751 : 			if ( pmove->punchangle[ 0 ] > 8 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 160				; 000000a0H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	comiss	xmm0, DWORD PTR __real@41000000
	jbe	SHORT $LN12@PM_CheckFa

; 2752 : 			{
; 2753 : 				pmove->punchangle[ 0 ] = 8;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 160				; 000000a0H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [eax+ecx], xmm0
$LN12@PM_CheckFa:

; 2754 : 			}
; 2755 : 		}
; 2756 : 	}
; 2757 : 
; 2758 : 	if ( pmove->onground != -1 ) 

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+224], -1
	je	SHORT $LN13@PM_CheckFa

; 2759 : 	{		
; 2760 : 		pmove->flFallVelocity = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+156], xmm0
$LN13@PM_CheckFa:

; 2761 : 	}
; 2762 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CheckFalling@@YAXXZ ENDP				; PM_CheckFalling
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -500						; size = 68
$T2 = -432						; size = 68
$T3 = -364						; size = 68
$T4 = -296						; size = 68
$T5 = -228						; size = 12
$T6 = -216						; size = 12
$T7 = -204						; size = 12
$T8 = -192						; size = 12
$T9 = -180						; size = 12
$T10 = -168						; size = 12
$T11 = -156						; size = 12
_tr$ = -144						; size = 68
tv411 = -76						; size = 8
tv331 = -68						; size = 8
_curspeed$ = -60					; size = 4
_vecEnd$ = -56						; size = 12
_savehull$ = -44					; size = 4
tv218 = -40						; size = 4
_flatvelocity$ = -36					; size = 12
_vecStart$ = -24					; size = 12
_flatforward$ = -12					; size = 12
?PM_CheckWaterJump@@YAXXZ PROC				; PM_CheckWaterJump

; 2631 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	push	esi
	push	edi

; 2632 : 	Vector	vecStart, vecEnd;

	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2633 : 	Vector	flatforward;

	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2634 : 	Vector	flatvelocity;

	lea	ecx, DWORD PTR _flatvelocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2635 : 	float curspeed;
; 2636 : 	pmtrace_t tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 2637 : 	int		savehull;
; 2638 : 
; 2639 : 	// Already water jumping.
; 2640 : 	if ( pmove->waterjumptime )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PM_CheckWa

; 2641 : 		return;

	jmp	$LN1@PM_CheckWa
$LN2@PM_CheckWa:

; 2642 : 
; 2643 : 	// Don't hop out if we just jumped in
; 2644 : 	if ( pmove->velocity[2] < -180 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR [eax+ecx]
	jbe	SHORT $LN3@PM_CheckWa

; 2645 : 		return; // only hop out if we are moving up

	jmp	$LN1@PM_CheckWa
$LN3@PM_CheckWa:

; 2646 : 
; 2647 : 	// See if we are backing up
; 2648 : 	flatvelocity[0] = pmove->velocity[0];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edx, 4
	imul	edi, edx, 0
	lea	ecx, DWORD PTR _flatvelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 2649 : 	flatvelocity[1] = pmove->velocity[1];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _flatvelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 2650 : 	flatvelocity[2] = 0;

	lea	ecx, DWORD PTR _flatvelocity$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 2651 : 
; 2652 : 	// Must be moving
; 2653 : 	curspeed = flatvelocity.Length();

	lea	ecx, DWORD PTR _flatvelocity$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _curspeed$[ebp]

; 2654 : 	flatvelocity = flatvelocity.Normalize();

	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	lea	ecx, DWORD PTR _flatvelocity$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _flatvelocity$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _flatvelocity$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _flatvelocity$[ebp+8], eax

; 2655 : 	
; 2656 : 	// see if near an edge
; 2657 : 	flatforward[0] = pmove->forward[0];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, 4
	imul	edi, ecx, 0
	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 2658 : 	flatforward[1] = pmove->forward[1];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 2659 : 	flatforward[2] = 0;

	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 2660 : 	flatforward = flatforward.Normalize();

	lea	edx, DWORD PTR $T10[ebp]
	push	edx
	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _flatforward$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _flatforward$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _flatforward$[ebp+8], eax

; 2661 : 
; 2662 : 	// Are we backing into water from steps or something?  If so, don't pop forward
; 2663 : 	if ( curspeed != 0.0 && ( DotProduct( flatvelocity, flatforward ) < 0.0 ) )

	cvtss2sd xmm0, DWORD PTR _curspeed$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@PM_CheckWa
	lea	ecx, DWORD PTR _flatforward$[ebp]
	push	ecx
	lea	edx, DWORD PTR _flatvelocity$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	QWORD PTR tv331[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR tv331[ebp]
	jbe	SHORT $LN4@PM_CheckWa

; 2664 : 		return;

	jmp	$LN1@PM_CheckWa
$LN4@PM_CheckWa:

; 2665 : 
; 2666 : 	vecStart = pmove->origin;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecStart$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecStart$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecStart$[ebp+8], eax

; 2667 : 	vecStart.z += WJ_HEIGHT;

	movss	xmm0, DWORD PTR _vecStart$[ebp+8]
	addss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vecStart$[ebp+8], xmm0

; 2668 : 
; 2669 : 	vecEnd = vecStart + flatforward * 24;

	push	ecx
	movss	xmm0, DWORD PTR __real@41c00000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecEnd$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecEnd$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecEnd$[ebp+8], eax

; 2670 : 	
; 2671 : 	// Trace, this trace should use the point sized collision hull
; 2672 : 	savehull = pmove->usehull;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR _savehull$[ebp], edx

; 2673 : 	pmove->usehull = 2;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+188], 2

; 2674 : 	tr = pmove->PM_PlayerTrace( vecStart, vecEnd, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324992]
	call	eax
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T4[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T4[ebp]
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 2675 : 	if ( tr.fraction < 1.0 && fabs( tr.plane.normal[2] ) < 0.1f )  // Facing a near vertical wall?

	cvtss2sd xmm0, DWORD PTR _tr$[ebp+16]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	$LN6@PM_CheckWa
	lea	ecx, DWORD PTR _tr$[ebp+32]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv411[ebp]
	movsd	xmm0, QWORD PTR __real@3fb99999a0000000
	comisd	xmm0, QWORD PTR tv411[ebp]
	jbe	$LN6@PM_CheckWa

; 2676 : 	{
; 2677 : 		vecStart[2] += pmove->player_maxs[ savehull ][2] - WJ_HEIGHT;

	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	add	eax, edx
	mov	DWORD PTR tv218[ebp], eax
	imul	eax, DWORD PTR _savehull$[ebp], 12
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324900]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR __real@41000000
	mov	eax, DWORD PTR tv218[ebp]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv218[ebp]
	movss	DWORD PTR [ecx], xmm0

; 2678 : 		vecEnd = vecStart + flatforward * 24;

	push	ecx
	movss	xmm0, DWORD PTR __real@41c00000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	lea	ecx, DWORD PTR _flatforward$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecEnd$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecEnd$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecEnd$[ebp+8], eax

; 2679 : 		pmove->movedir = tr.plane.normal * -50;

	push	ecx
	movss	xmm0, DWORD PTR __real@c2480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tr$[ebp+32]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 104				; 00000068H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2680 : 
; 2681 : 		tr = pmove->PM_PlayerTrace( vecStart, vecEnd, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324992]
	call	eax
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T3[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T3[ebp]
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 2682 : 		if ( tr.fraction == 1.0 )

	cvtss2sd xmm0, DWORD PTR _tr$[ebp+16]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@PM_CheckWa

; 2683 : 		{
; 2684 : 			pmove->waterjumptime = 2000;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR [ecx+204], xmm0

; 2685 : 			pmove->velocity[2] = 225;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@43610000
	movss	DWORD PTR [eax+edx], xmm0

; 2686 : 			pmove->oldbuttons |= IN_JUMP;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+200]
	or	ecx, 2
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+200], ecx

; 2687 : 			pmove->flags |= FL_WATERJUMP;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	or	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+184], ecx
$LN6@PM_CheckWa:

; 2688 : 		}
; 2689 : 	}
; 2690 : 
; 2691 : 	// Reset the collision hull
; 2692 : 	pmove->usehull = savehull;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _savehull$[ebp]
	mov	DWORD PTR [eax+188], ecx
$LN1@PM_CheckWa:

; 2693 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CheckWaterJump@@YAXXZ ENDP				; PM_CheckWaterJump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv440 = -52						; size = 4
tv427 = -48						; size = 4
tv438 = -44						; size = 4
tv419 = -40						; size = 4
tv436 = -36						; size = 4
tv411 = -32						; size = 4
tv434 = -28						; size = 4
tv391 = -24						; size = 4
_cansuperjump$ = -20					; size = 4
tv157 = -16						; size = 4
_tfc$ = -12						; size = 4
_i$ = -8						; size = 4
tv217 = -2						; size = 1
tv77 = -1						; size = 1
?PM_Jump@@YAXXZ PROC					; PM_Jump

; 2488 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2489 : 	int i;
; 2490 : 	qboolean tfc = false;

	mov	DWORD PTR _tfc$[ebp], 0

; 2491 : 
; 2492 : 	qboolean cansuperjump = false;

	mov	DWORD PTR _cansuperjump$[ebp], 0

; 2493 : 
; 2494 : 	if (pmove->dead)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	je	SHORT $LN7@PM_Jump

; 2495 : 	{
; 2496 : 		pmove->oldbuttons |= IN_JUMP ;	// don't jump again until released

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+200]
	or	edx, 2
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+200], edx

; 2497 : 		return;

	jmp	$LN1@PM_Jump
$LN7@PM_Jump:

; 2498 : 	}
; 2499 : 
; 2500 : 	tfc = atoi( pmove->PM_Info_ValueForKey( pmove->physinfo, "tfc" ) ) == 1 ? true : false;

	push	OFFSET $SG15930
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 324592				; 0004f3f0H
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324948]
	call	eax
	add	esp, 8
	push	eax
	call	_atoi
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN31@PM_Jump
	mov	BYTE PTR tv77[ebp], 1
	jmp	SHORT $LN32@PM_Jump
$LN31@PM_Jump:
	mov	BYTE PTR tv77[ebp], 0
$LN32@PM_Jump:
	movzx	ecx, BYTE PTR tv77[ebp]
	mov	DWORD PTR _tfc$[ebp], ecx

; 2501 : 
; 2502 : 	// Spy that's feigning death cannot jump
; 2503 : 	if ( tfc && 

	cmp	DWORD PTR _tfc$[ebp], 0
	je	SHORT $LN8@PM_Jump
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+212], 5
	jne	SHORT $LN8@PM_Jump

; 2504 : 		( pmove->deadflag == ( DEAD_DISCARDBODY + 1 ) ) )
; 2505 : 	{
; 2506 : 		return;

	jmp	$LN1@PM_Jump
$LN8@PM_Jump:

; 2507 : 	}
; 2508 : 
; 2509 : 	// See if we are waterjumping.  If so, decrement count and return.
; 2510 : 	if ( pmove->waterjumptime )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@PM_Jump

; 2511 : 	{
; 2512 : 		pmove->waterjumptime -= pmove->cmd.msec;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, BYTE PTR [ecx+283738]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm1, DWORD PTR [eax+204]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [ecx+204], xmm1

; 2513 : 		if (pmove->waterjumptime < 0)

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [edx+204]
	jbe	SHORT $LN10@PM_Jump

; 2514 : 		{
; 2515 : 			pmove->waterjumptime = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+204], xmm0
$LN10@PM_Jump:

; 2516 : 		}
; 2517 : 		return;

	jmp	$LN1@PM_Jump
$LN9@PM_Jump:

; 2518 : 	}
; 2519 : 
; 2520 : 	// If we are in the water most of the way...
; 2521 : 	if (pmove->waterlevel >= 2 && pmove->watertype != CONTENTS_FOG)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 2
	jl	$LN11@PM_Jump
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+232], -19		; ffffffedH
	je	$LN11@PM_Jump

; 2522 : 	{	// swimming, not jumping
; 2523 : 		pmove->onground = -1;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+224], -1

; 2524 : 
; 2525 : 		if (pmove->watertype == CONTENTS_WATER)    // We move up a certain amount

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+232], -3			; fffffffdH
	jne	SHORT $LN12@PM_Jump

; 2526 : 			pmove->velocity[2] = 100;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [eax+edx], xmm0
	jmp	SHORT $LN15@PM_Jump
$LN12@PM_Jump:

; 2527 : 		else if (pmove->watertype == CONTENTS_SLIME)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+232], -4			; fffffffcH
	jne	SHORT $LN14@PM_Jump

; 2528 : 			pmove->velocity[2] = 80;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [eax+ecx], xmm0

; 2529 : 		else  // LAVA

	jmp	SHORT $LN15@PM_Jump
$LN14@PM_Jump:

; 2530 : 			pmove->velocity[2] = 50;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [eax+edx], xmm0
$LN15@PM_Jump:

; 2531 : 
; 2532 : 		// play swiming sound
; 2533 : 		if ( pmove->flSwimTime <= 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+172]
	jb	$LN2@PM_Jump

; 2534 : 		{
; 2535 : 			// Don't play sound again for 1 second
; 2536 : 			pmove->flSwimTime = 1000;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR [ecx+172], xmm0

; 2537 : 			switch ( pmove->RandomLong( 0, 3 ) )

	push	3
	push	0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325000]
	call	eax
	add	esp, 8
	mov	DWORD PTR tv157[ebp], eax
	cmp	DWORD PTR tv157[ebp], 3
	ja	$LN2@PM_Jump
	mov	ecx, DWORD PTR tv157[ebp]
	jmp	DWORD PTR $LN35@PM_Jump[ecx*4]
$LN17@PM_Jump:

; 2538 : 			{ 
; 2539 : 			case 0:
; 2540 : 				pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade1.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15941
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H

; 2541 : 				break;

	jmp	$LN2@PM_Jump
$LN18@PM_Jump:

; 2542 : 			case 1:
; 2543 : 				pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade2.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15943
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H

; 2544 : 				break;

	jmp	SHORT $LN2@PM_Jump
$LN19@PM_Jump:

; 2545 : 			case 2:
; 2546 : 				pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade3.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15945
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H

; 2547 : 				break;

	jmp	SHORT $LN2@PM_Jump
$LN20@PM_Jump:

; 2548 : 			case 3:
; 2549 : 				pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade4.wav", 1, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15947
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
$LN2@PM_Jump:

; 2550 : 				break;
; 2551 : 			}
; 2552 : 		}
; 2553 : 
; 2554 : 		return;

	jmp	$LN1@PM_Jump
$LN11@PM_Jump:

; 2555 : 	}
; 2556 : 
; 2557 : 	// No more effect
; 2558 :  	if ( pmove->onground == -1 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+224], -1
	jne	SHORT $LN21@PM_Jump

; 2559 : 	{
; 2560 : 		// Flag that we jumped.
; 2561 : 		// HACK HACK HACK
; 2562 : 		// Remove this when the game .dll no longer does physics code!!!!
; 2563 : 		pmove->oldbuttons |= IN_JUMP;	// don't jump again until released

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+200]
	or	eax, 2
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+200], eax

; 2564 : 		return;		// in air, so no effect

	jmp	$LN1@PM_Jump
$LN21@PM_Jump:

; 2565 : 	}
; 2566 : 
; 2567 : 	if ( pmove->oldbuttons & IN_JUMP )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+200]
	and	eax, 2
	je	SHORT $LN22@PM_Jump

; 2568 : 		return;		// don't pogo stick

	jmp	$LN1@PM_Jump
$LN22@PM_Jump:

; 2569 : 
; 2570 : 	// In the air now.
; 2571 : 	pmove->onground = -1;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+224], -1

; 2572 : 
; 2573 : 	PM_PreventMegaBunnyJumping();

	call	?PM_PreventMegaBunnyJumping@@YAXXZ	; PM_PreventMegaBunnyJumping

; 2574 : 
; 2575 : 	if ( tfc )

	cmp	DWORD PTR _tfc$[ebp], 0
	je	SHORT $LN23@PM_Jump

; 2576 : 	{
; 2577 : 		pmove->PM_PlaySound( CHAN_BODY, "player/plyrjmp8.wav", 0.5, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15952
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H

; 2578 : 	}
; 2579 : 	else

	jmp	SHORT $LN24@PM_Jump
$LN23@PM_Jump:

; 2580 : 	{
; 2581 : 		PM_PlayStepSound( PM_MapTextureTypeStepType( pmove->chtexturetype ), 1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, BYTE PTR [ecx+496]
	push	edx
	call	?PM_MapTextureTypeStepType@@YAHD@Z	; PM_MapTextureTypeStepType
	add	esp, 4
	push	eax
	call	?PM_PlayStepSound@@YAXHM@Z		; PM_PlayStepSound
	add	esp, 8
$LN24@PM_Jump:

; 2582 : 	}
; 2583 : 
; 2584 : 	// See if user can super long jump?
; 2585 : 	cansuperjump = atoi( pmove->PM_Info_ValueForKey( pmove->physinfo, "slj" ) ) == 1 ? true : false;

	push	OFFSET $SG15953
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 324592				; 0004f3f0H
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324948]
	call	edx
	add	esp, 8
	push	eax
	call	_atoi
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN33@PM_Jump
	mov	BYTE PTR tv217[ebp], 1
	jmp	SHORT $LN34@PM_Jump
$LN33@PM_Jump:
	mov	BYTE PTR tv217[ebp], 0
$LN34@PM_Jump:
	movzx	eax, BYTE PTR tv217[ebp]
	mov	DWORD PTR _cansuperjump$[ebp], eax

; 2586 : 
; 2587 : 	// Acclerate upward
; 2588 : 	// If we are ducking...
; 2589 : 	if ( ( pmove->bInDuck ) || ( pmove->flags & FL_DUCKING ) )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+144], 0
	jne	SHORT $LN27@PM_Jump
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	and	eax, 16384				; 00004000H
	je	$LN25@PM_Jump
$LN27@PM_Jump:

; 2590 : 	{
; 2591 : 		// Adjust for super long jump module
; 2592 : 		// UNDONE -- note this should be based on forward angles, not current velocity.
; 2593 : 		if ( cansuperjump &&
; 2594 : 			( pmove->cmd.buttons & IN_DUCK ) &&
; 2595 : 			( pmove->flDuckTime > 0 ) &&

	cmp	DWORD PTR _cansuperjump$[ebp], 0
	je	$LN28@PM_Jump
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, WORD PTR [ecx+283766]
	and	edx, 4
	je	$LN28@PM_Jump
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+140]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN28@PM_Jump
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR tv391[ebp]
	movss	xmm0, DWORD PTR tv391[ebp]
	comiss	xmm0, DWORD PTR __real@42480000
	jbe	$LN28@PM_Jump

; 2596 : 			pmove->velocity.Length() > 50 )
; 2597 : 		{
; 2598 : 			pmove->punchangle[0] = -5;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 160				; 000000a0H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@c0a00000
	movss	DWORD PTR [eax+edx], xmm0

; 2599 : 
; 2600 : 			for (i =0; i < 2; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@PM_Jump
$LN4@PM_Jump:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@PM_Jump:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN5@PM_Jump

; 2601 : 			{
; 2602 : 				pmove->velocity[i] = pmove->forward[i] * PLAYER_LONGJUMP_SPEED * 1.6;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+500]
	mulss	xmm0, DWORD PTR __real@3f8c28f6
	mov	edx, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx*4]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3ff999999999999a
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	movss	DWORD PTR tv434[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv434[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0

; 2603 : 			}

	jmp	SHORT $LN4@PM_Jump
$LN5@PM_Jump:

; 2604 : 		
; 2605 : 			pmove->velocity[2] = sqrt(2 * 800 * 56.0);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40f5e00000000000
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv411[ebp]
	fld	DWORD PTR tv411[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	fstp	DWORD PTR tv436[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	fld	DWORD PTR tv436[ebp]
	fstp	DWORD PTR [eax+edx]

; 2606 : 		}
; 2607 : 		else

	jmp	SHORT $LN29@PM_Jump
$LN28@PM_Jump:

; 2608 : 		{
; 2609 : 			pmove->velocity[2] = sqrt(2 * 800 * 45.0);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40f1940000000000
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv419[ebp]
	fld	DWORD PTR tv419[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	fstp	DWORD PTR tv438[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	fld	DWORD PTR tv438[ebp]
	fstp	DWORD PTR [eax+ecx]
$LN29@PM_Jump:

; 2610 : 		}
; 2611 : 	}
; 2612 : 	else

	jmp	SHORT $LN26@PM_Jump
$LN25@PM_Jump:

; 2613 : 	{
; 2614 : 		pmove->velocity[2] = sqrt(2 * 800 * 45.0);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40f1940000000000
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv427[ebp]
	fld	DWORD PTR tv427[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	fstp	DWORD PTR tv440[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	fld	DWORD PTR tv440[ebp]
	fstp	DWORD PTR [eax+edx]
$LN26@PM_Jump:

; 2615 : 	}
; 2616 : 
; 2617 : 	// Decay it for simulation
; 2618 : 	PM_FixupGravityVelocity();

	call	?PM_FixupGravityVelocity@@YAXXZ		; PM_FixupGravityVelocity

; 2619 : 
; 2620 : 	// Flag that we jumped.
; 2621 : 	pmove->oldbuttons |= IN_JUMP;	// don't jump again until released

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+200]
	or	ecx, 2
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+200], ecx
$LN1@PM_Jump:

; 2622 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN35@PM_Jump:
	DD	$LN17@PM_Jump
	DD	$LN18@PM_Jump
	DD	$LN19@PM_Jump
	DD	$LN20@PM_Jump
?PM_Jump@@YAXXZ ENDP					; PM_Jump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_fraction$ = -12					; size = 4
_spd$ = -8						; size = 4
_maxscaledspeed$ = -4					; size = 4
?PM_PreventMegaBunnyJumping@@YAXXZ PROC			; PM_PreventMegaBunnyJumping

; 2458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2459 : 	// Current player speed
; 2460 : 	float spd;
; 2461 : 	// If we have to crop, apply this cropping fraction to velocity
; 2462 : 	float fraction;
; 2463 : 	// Speed at which bunny jumping is limited
; 2464 : 	float maxscaledspeed;
; 2465 : 
; 2466 : 	maxscaledspeed = BUNNYJUMP_MAX_SPEED_FACTOR * pmove->maxspeed;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@3fd9999a
	mulss	xmm0, DWORD PTR [eax+500]
	movss	DWORD PTR _maxscaledspeed$[ebp], xmm0

; 2467 : 
; 2468 : 	// Don't divide by zero
; 2469 : 	if ( maxscaledspeed <= 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _maxscaledspeed$[ebp]
	jb	SHORT $LN2@PM_Prevent

; 2470 : 		return;

	jmp	SHORT $LN1@PM_Prevent
$LN2@PM_Prevent:

; 2471 : 
; 2472 : 	spd = pmove->velocity.Length();

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _spd$[ebp]

; 2473 : 
; 2474 : 	if ( spd <= maxscaledspeed )

	movss	xmm0, DWORD PTR _maxscaledspeed$[ebp]
	comiss	xmm0, DWORD PTR _spd$[ebp]
	jb	SHORT $LN3@PM_Prevent

; 2475 : 		return;

	jmp	SHORT $LN1@PM_Prevent
$LN3@PM_Prevent:

; 2476 : 
; 2477 : 	fraction = ( maxscaledspeed / spd ) * 0.65; //Returns the modifier for the velocity

	movss	xmm0, DWORD PTR _maxscaledspeed$[ebp]
	divss	xmm0, DWORD PTR _spd$[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe4cccccccccccd
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2478 : 	
; 2479 : 	pmove->velocity *= fraction; //Crop it down!.

	push	ecx
	movss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$LN1@PM_Prevent:

; 2480 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_PreventMegaBunnyJumping@@YAXXZ ENDP			; PM_PreventMegaBunnyJumping
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -96						; size = 12
$T2 = -84						; size = 12
$T3 = -72						; size = 12
$T4 = -60						; size = 12
$T5 = -48						; size = 12
$T6 = -36						; size = 12
_wishvel$ = -24						; size = 12
_fmove$ = -12						; size = 4
_smove$ = -8						; size = 4
tv134 = -4						; size = 4
?PM_NoClip@@YAXXZ PROC					; PM_NoClip

; 2424 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 2425 : 	Vector		wishvel;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2426 : 	float		fmove, smove;
; 2427 : //	float		currentspeed, addspeed, accelspeed;
; 2428 : 
; 2429 : 	// Copy movement amounts
; 2430 : 	fmove = pmove->cmd.forwardmove;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+283752]
	movss	DWORD PTR _fmove$[ebp], xmm0

; 2431 : 	smove = pmove->cmd.sidemove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+283756]
	movss	DWORD PTR _smove$[ebp], xmm0

; 2432 : 	
; 2433 : 	pmove->forward = pmove->forward.Normalize();

	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2434 : 	pmove->right = pmove->right.Normalize(); 

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 2435 : 
; 2436 : 	// Determine x and y parts of velocity
; 2437 : 	wishvel = pmove->forward * fmove + pmove->right * smove;

	push	ecx
	movss	xmm0, DWORD PTR _smove$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _fmove$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _wishvel$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _wishvel$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _wishvel$[ebp+8], eax

; 2438 : 
; 2439 : 	wishvel[2] += pmove->cmd.upmove;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv134[ebp], eax
	mov	edx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax+283760]
	mov	ecx, DWORD PTR tv134[ebp]
	movss	DWORD PTR [ecx], xmm0

; 2440 : 	pmove->origin += wishvel * pmove->frametime;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2441 : 	
; 2442 : 	// Zero out the velocity so that we don't accumulate a huge downward velocity from
; 2443 : 	//  gravity, etc.
; 2444 : 	pmove->velocity = g_vecZero;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx

; 2445 : 
; 2446 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_NoClip@@YAXXZ ENDP					; PM_NoClip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -396						; size = 68
$T2 = -328						; size = 68
$T3 = -260						; size = 68
$T4 = -192						; size = 68
$T5 = -124						; size = 12
$T6 = -112						; size = 12
_trace$ = -100						; size = 68
_base$7 = -32						; size = 12
_vel$8 = -20						; size = 4
_move$ = -16						; size = 12
_backoff$ = -4						; size = 4
?PM_Physics_Toss@@YAXXZ PROC				; PM_Physics_Toss

; 2317 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	esi
	push	edi

; 2318 : 	pmtrace_t trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 2319 : 	Vector	move;

	lea	ecx, DWORD PTR _move$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2320 : 	float	backoff;
; 2321 : 
; 2322 : 	PM_CheckWater();

	call	?PM_CheckWater@@YAHXZ			; PM_CheckWater

; 2323 : 
; 2324 : 	if (pmove->velocity[2] > 0)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@PM_Physics

; 2325 : 		pmove->onground = -1;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+224], -1
$LN2@PM_Physics:

; 2326 : 
; 2327 : 	// If on ground and not moving, return.
; 2328 : 	if ( pmove->onground != -1 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	je	SHORT $LN4@PM_Physics

; 2329 : 	{
; 2330 : 		if(( pmove->basevelocity == g_vecZero) && ( pmove->velocity == g_vecZero ))

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN4@PM_Physics
	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN4@PM_Physics

; 2331 : 			return;

	jmp	$LN1@PM_Physics
$LN4@PM_Physics:

; 2332 : 	}
; 2333 : 
; 2334 : 	PM_CheckVelocity ();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity

; 2335 : 
; 2336 : // add gravity
; 2337 : 	if ( pmove->movetype != MOVETYPE_FLY &&
; 2338 : 		 pmove->movetype != MOVETYPE_BOUNCEMISSILE &&

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+220], 5
	je	SHORT $LN5@PM_Physics
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+220], 11			; 0000000bH
	je	SHORT $LN5@PM_Physics
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+220], 9
	je	SHORT $LN5@PM_Physics

; 2339 : 		 pmove->movetype != MOVETYPE_FLYMISSILE )
; 2340 : 		PM_AddGravity ();

	call	?PM_AddGravity@@YAXXZ			; PM_AddGravity
$LN5@PM_Physics:

; 2341 : 
; 2342 : // move origin
; 2343 : 	// Base velocity is not properly accounted for since this entity will move again after the bounce without
; 2344 : 	// taking it into account
; 2345 : 	pmove->velocity += pmove->basevelocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2346 : 	
; 2347 : 	PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity

; 2348 : 
; 2349 : 	move = pmove->velocity * pmove->frametime;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _move$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _move$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _move$[ebp+8], eax

; 2350 : 	pmove->velocity -= pmove->basevelocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 2351 : 
; 2352 : 	trace = PM_PushEntity (move);	// Should this clear basevelocity

	lea	edx, DWORD PTR _move$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?PM_PushEntity@@YA?AUpmtrace_s@@ABVVector@@@Z ; PM_PushEntity
	add	esp, 8
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T4[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T4[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2353 : 
; 2354 : 	PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity

; 2355 : 
; 2356 : 	if (trace.allsolid)

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN6@PM_Physics

; 2357 : 	{	
; 2358 : 		// entity is trapped in another solid
; 2359 : 		pmove->onground = trace.ent;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [ecx+224], edx

; 2360 : 		pmove->velocity = g_vecZero;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [eax+8], ecx

; 2361 : 		return;

	jmp	$LN1@PM_Physics
$LN6@PM_Physics:

; 2362 : 	}
; 2363 : 	
; 2364 : 	if (trace.fraction == 1)

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@PM_Physics

; 2365 : 	{
; 2366 : 		PM_CheckWater();

	call	?PM_CheckWater@@YAHXZ			; PM_CheckWater

; 2367 : 		return;

	jmp	$LN1@PM_Physics
$LN7@PM_Physics:

; 2368 : 	}
; 2369 : 
; 2370 : 
; 2371 : 	if (pmove->movetype == MOVETYPE_BOUNCE)

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+220], 10			; 0000000aH
	jne	SHORT $LN8@PM_Physics

; 2372 : 		backoff = 2.0 - pmove->friction;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [eax+196]
	movsd	xmm1, QWORD PTR __real@4000000000000000
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _backoff$[ebp], xmm0
	jmp	SHORT $LN11@PM_Physics
$LN8@PM_Physics:

; 2373 : 	else if (pmove->movetype == MOVETYPE_BOUNCEMISSILE)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+220], 11			; 0000000bH
	jne	SHORT $LN10@PM_Physics

; 2374 : 		backoff = 2.0;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _backoff$[ebp], xmm0

; 2375 : 	else

	jmp	SHORT $LN11@PM_Physics
$LN10@PM_Physics:

; 2376 : 		backoff = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _backoff$[ebp], xmm0
$LN11@PM_Physics:

; 2377 : 
; 2378 : 	PM_ClipVelocity (pmove->velocity, trace.plane.normal, pmove->velocity, backoff);

	push	ecx
	movss	xmm0, DWORD PTR _backoff$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _trace$[ebp+32]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z	; PM_ClipVelocity
	add	esp, 32					; 00000020H

; 2379 : 
; 2380 : 	// stop if on ground
; 2381 : 	if (trace.plane.normal[2] > 0.7)

	lea	ecx, DWORD PTR _trace$[ebp+32]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	comisd	xmm0, QWORD PTR __real@3fe6666666666666
	jbe	$LN12@PM_Physics

; 2382 : 	{		
; 2383 : 		float vel;
; 2384 : 		Vector base;

	lea	ecx, DWORD PTR _base$7[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2385 : 
; 2386 : 		base = g_vecZero;

	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR _base$7[ebp], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR _base$7[ebp+4], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR _base$7[ebp+8], ecx

; 2387 : 
; 2388 : 		if( pmove->velocity[2] < pmove->movevars->gravity * pmove->frametime )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [ecx+324848]
	mov	esi, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [esi+16]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN13@PM_Physics

; 2389 : 		{
; 2390 : 			// we're rolling on the ground, add static friction.
; 2391 : 			pmove->onground = trace.ent;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [edx+224], eax

; 2392 : 			pmove->velocity[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0
$LN13@PM_Physics:

; 2393 : 		}
; 2394 : 
; 2395 : 		vel = DotProduct( pmove->velocity, pmove->velocity );

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _vel$8[ebp]

; 2396 : 
; 2397 : 		// Con_DPrintf("%f %f: %.0f %.0f %.0f\n", vel, trace.fraction, ent->velocity[0], ent->velocity[1], ent->velocity[2] );
; 2398 : 
; 2399 : 		if (vel < (30 * 30) || (pmove->movetype != MOVETYPE_BOUNCE && pmove->movetype != MOVETYPE_BOUNCEMISSILE))

	movss	xmm0, DWORD PTR __real@44610000
	comiss	xmm0, DWORD PTR _vel$8[ebp]
	ja	SHORT $LN16@PM_Physics
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+220], 10			; 0000000aH
	je	SHORT $LN14@PM_Physics
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+220], 11			; 0000000bH
	je	SHORT $LN14@PM_Physics
$LN16@PM_Physics:

; 2400 : 		{
; 2401 : 			pmove->onground = trace.ent;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+224], ecx

; 2402 : 			pmove->velocity = g_vecZero;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 2403 : 		}
; 2404 : 		else

	jmp	SHORT $LN15@PM_Physics
$LN14@PM_Physics:

; 2405 : 		{
; 2406 : 			move = pmove->velocity * (( 1.0f - trace.fraction ) * pmove->frametime * 0.9f );

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR __real@3f666666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _move$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _move$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _move$[ebp+8], eax

; 2407 : 			trace = PM_PushEntity (move);

	lea	ecx, DWORD PTR _move$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	?PM_PushEntity@@YA?AUpmtrace_s@@ABVVector@@@Z ; PM_PushEntity
	add	esp, 8
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T3[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T3[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd
$LN15@PM_Physics:

; 2408 : 		}
; 2409 : 
; 2410 : 		pmove->velocity -= base;

	lea	eax, DWORD PTR _base$7[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
$LN12@PM_Physics:

; 2411 : 	}
; 2412 : 	
; 2413 : // check for in water
; 2414 : 	PM_CheckWater();

	call	?PM_CheckWater@@YAHXZ			; PM_CheckWater
$LN1@PM_Physics:

; 2415 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_Physics_Toss@@YAXXZ ENDP				; PM_Physics_Toss
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -296						; size = 68
$T2 = -228						; size = 68
$T3 = -160						; size = 68
$T4 = -92						; size = 12
_trace$ = -80						; size = 68
_end$ = -12						; size = 12
$T5 = 8							; size = 4
_push$ = 12						; size = 4
?PM_PushEntity@@YA?AUpmtrace_s@@ABVVector@@@Z PROC	; PM_PushEntity

; 2289 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	push	esi
	push	edi

; 2290 : 	pmtrace_t	trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 2291 : 	Vector	end;

	lea	ecx, DWORD PTR _end$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2292 : 		
; 2293 : 	end = pmove->origin + push;

	mov	eax, DWORD PTR _push$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _end$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _end$[ebp+8], edx

; 2294 : 
; 2295 : 	trace = pmove->PM_PlayerTrace( pmove->origin, end, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324992]
	call	edx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T3[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T3[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 2296 : 	
; 2297 : 	pmove->origin = trace.endpos;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _trace$[ebp+20]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _trace$[ebp+24]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _trace$[ebp+28]
	mov	DWORD PTR [eax+8], ecx

; 2298 : 
; 2299 : 	// So we can run impact function afterwards.
; 2300 : 	if( trace.fraction < 1.0 && !trace.allsolid )

	cvtss2sd xmm0, DWORD PTR _trace$[ebp+16]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@PM_PushEnt
	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN2@PM_PushEnt

; 2301 : 	{
; 2302 : 		PM_AddToTouched( trace, pmove->velocity );

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 68					; 00000044H
	mov	ecx, esp
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	??0pmtrace_s@@QAE@ABU0@@Z
	call	?PM_AddToTouched@@YAHUpmtrace_s@@VVector@@@Z ; PM_AddToTouched
	add	esp, 80					; 00000050H
$LN2@PM_PushEnt:

; 2303 : 	}
; 2304 : 
; 2305 : 
; 2306 : 	return trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0pmtrace_s@@QAE@$$QAU0@@Z
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR $T5[ebp]
	rep movsd
	mov	eax, DWORD PTR $T5[ebp]

; 2307 : }	

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_PushEntity@@YA?AUpmtrace_s@@ABVVector@@@Z ENDP	; PM_PushEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv91 = -12						; size = 4
tv77 = -8						; size = 4
_ent_gravity$ = -4					; size = 4
?PM_AddGravity@@YAXXZ PROC				; PM_AddGravity

; 2267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2268 : 	float	ent_gravity;
; 2269 : 
; 2270 : 	if (pmove->gravity)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+192]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PM_AddGrav

; 2271 : 		ent_gravity = pmove->gravity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+192]
	movss	DWORD PTR _ent_gravity$[ebp], xmm0

; 2272 : 	else

	jmp	SHORT $LN3@PM_AddGrav
$LN2@PM_AddGrav:

; 2273 : 		ent_gravity = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
$LN3@PM_AddGrav:

; 2274 : 
; 2275 : 	// Add gravity incorrectly
; 2276 : 	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * pmove->frametime );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	add	eax, edx
	mov	DWORD PTR tv77[ebp], eax
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	movss	xmm0, DWORD PTR _ent_gravity$[ebp]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [edx+16]
	mov	eax, DWORD PTR tv77[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR tv77[ebp]
	movss	DWORD PTR [ecx], xmm1

; 2277 : 	pmove->velocity[2] += pmove->basevelocity[2] * pmove->frametime;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	add	eax, edx
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+16]
	mov	eax, DWORD PTR tv91[ebp]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv91[ebp]
	movss	DWORD PTR [ecx], xmm0

; 2278 : 	pmove->basevelocity[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 2279 : 	PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity

; 2280 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_AddGravity@@YAXXZ ENDP				; PM_AddGravity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
?PM_WaterJump@@YAXXZ PROC				; PM_WaterJump

; 2239 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2240 : 	if ( pmove->waterjumptime > 10000 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR __real@461c4000
	jbe	SHORT $LN2@PM_WaterJu

; 2241 : 	{
; 2242 : 		pmove->waterjumptime = 10000;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR [ecx+204], xmm0
$LN2@PM_WaterJu:

; 2243 : 	}
; 2244 : 
; 2245 : 	if ( !pmove->waterjumptime )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@PM_WaterJu

; 2246 : 		return;

	jmp	$LN1@PM_WaterJu
$LN3@PM_WaterJu:

; 2247 : 
; 2248 : 	pmove->waterjumptime -= pmove->cmd.msec;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, BYTE PTR [eax+283738]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm1, DWORD PTR [edx+204]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [eax+204], xmm1

; 2249 : 	if ( pmove->waterjumptime < 0 ||

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+204]
	ja	SHORT $LN5@PM_WaterJu
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+228], 0
	jne	SHORT $LN4@PM_WaterJu
$LN5@PM_WaterJu:

; 2250 : 		 !pmove->waterlevel )
; 2251 : 	{
; 2252 : 		pmove->waterjumptime = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+204], xmm0

; 2253 : 		pmove->flags &= ~FL_WATERJUMP;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, -2049				; fffff7ffH
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+184], edx
$LN4@PM_WaterJu:

; 2254 : 	}
; 2255 : 
; 2256 : 	pmove->velocity[0] = pmove->movedir[0];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 104				; 00000068H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, 4
	imul	edi, ecx, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx

; 2257 : 	pmove->velocity[1] = pmove->movedir[1];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 104				; 00000068H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+ecx], edx
$LN1@PM_WaterJu:

; 2258 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
?PM_WaterJump@@YAXXZ ENDP				; PM_WaterJump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -132						; size = 12
$T2 = -120						; size = 12
_offset$ = -108						; size = 12
_num$3 = -96						; size = 4
_test$ = -92						; size = 12
_hull$4 = -80						; size = 4
_i$5 = -76						; size = 4
_pe$ = -72						; size = 4
_entityToWorld$6 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?PM_Ladder@@YAPAUphysent_s@@XZ PROC			; PM_Ladder

; 2202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2203 : 	physent_t	*pe;
; 2204 : 	Vector	offset, test;

	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _test$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2205 : 
; 2206 : 	for( int i = 0; i < pmove->nummoveent; i++ )

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN4@PM_Ladder
$LN2@PM_Ladder:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN4@PM_Ladder:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR _i$5[ebp]
	cmp	edx, DWORD PTR [ecx+134992]
	jge	$LN3@PM_Ladder

; 2207 : 	{
; 2208 : 		pe = &pmove->moveents[i];

	imul	eax, DWORD PTR _i$5[ebp], 224
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	edx, DWORD PTR [ecx+eax+134996]
	mov	DWORD PTR _pe$[ebp], edx

; 2209 : 		
; 2210 : 		if( pe->model && (modtype_t)pmove->PM_GetModelType( pe->model ) == mod_brush && pe->skin == CONTENTS_LADDER )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN5@PM_Ladder
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325008]
	call	ecx
	add	esp, 4
	test	eax, eax
	jne	$LN5@PM_Ladder
	mov	edx, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [edx+100], -16		; fffffff0H
	jne	$LN5@PM_Ladder

; 2211 : 		{
; 2212 : 			hull_t *hull = (hull_t *)pmove->PM_HullForBsp( pe, offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325016]
	call	edx
	add	esp, 8
	mov	DWORD PTR _hull$4[ebp], eax

; 2213 : 			int num = hull->firstclipnode;

	mov	eax, DWORD PTR _hull$4[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _num$3[ebp], ecx

; 2214 : 
; 2215 : 			// Offset the test point appropriately for this hull.
; 2216 : 			test = pmove->origin - offset;

	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax

; 2217 : 
; 2218 : 			// support for rotational triggers
; 2219 : 			if(( pe->model->flags & 2 ) && pe->angles != g_vecZero )

	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+80]
	and	eax, 2
	je	SHORT $LN6@PM_Ladder
	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $LN6@PM_Ladder

; 2220 : 			{
; 2221 : 				// g-cont. can't acess to CBase->EntityToWorldTransform() :'-(
; 2222 : 				// so we build matrix from scratch
; 2223 : 				matrix4x4	entityToWorld( offset, pe->angles );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	lea	ecx, DWORD PTR _entityToWorld$6[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 2224 : 				test = entityToWorld.VectorITransform( pmove->origin );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _entityToWorld$6[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], edx
$LN6@PM_Ladder:

; 2225 : 			}
; 2226 : 
; 2227 : 			// Test the player's hull for intersection with this model
; 2228 : 			if( pmove->PM_HullPointContents( hull, num, test ) == CONTENTS_EMPTY )

	lea	ecx, DWORD PTR _test$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR _num$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$4[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324988]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN7@PM_Ladder

; 2229 : 				continue;

	jmp	$LN2@PM_Ladder
$LN7@PM_Ladder:

; 2230 : 			
; 2231 : 			return pe;

	mov	eax, DWORD PTR _pe$[ebp]
	jmp	SHORT $LN1@PM_Ladder
$LN5@PM_Ladder:

; 2232 : 		}
; 2233 : 	}

	jmp	$LN2@PM_Ladder
$LN3@PM_Ladder:

; 2234 : 
; 2235 : 	return NULL;

	xor	eax, eax
$LN1@PM_Ladder:

; 2236 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_Ladder@@YAPAUphysent_s@@XZ ENDP			; PM_Ladder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -376						; size = 12
$T2 = -364						; size = 12
$T3 = -352						; size = 12
$T4 = -340						; size = 12
$T5 = -328						; size = 12
$T6 = -316						; size = 12
$T7 = -304						; size = 12
$T8 = -292						; size = 12
$T9 = -280						; size = 12
$T10 = -268						; size = 12
$T11 = -256						; size = 12
$T12 = -244						; size = 12
$T13 = -232						; size = 12
$T14 = -220						; size = 12
_trace$ = -208						; size = 56
_v_right$15 = -152					; size = 12
_vpn$16 = -140						; size = 12
_modelmins$ = -128					; size = 12
_modelmaxs$ = -116					; size = 12
_lateral$17 = -104					; size = 12
_tmp$18 = -92						; size = 12
_cross$19 = -80						; size = 12
_ladderCenter$ = -68					; size = 12
_perp$20 = -56						; size = 12
_tr$ = -44						; size = 4
_velocity$21 = -40					; size = 12
_floor$ = -28						; size = 12
_onFloor$ = -16						; size = 4
_normal$22 = -12					; size = 4
_right$23 = -8						; size = 4
_forward$24 = -4					; size = 4
_pLadder$ = 8						; size = 4
?PM_LadderMove@@YAXPAUphysent_s@@@Z PROC		; PM_LadderMove

; 2099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H

; 2100 : 	Vector	ladderCenter;

	lea	ecx, DWORD PTR _ladderCenter$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2101 : 	trace_t	trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0trace_s@@QAE@XZ

; 2102 : 	qboolean	onFloor;
; 2103 : 	Vector	floor;

	lea	ecx, DWORD PTR _floor$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2104 : 	Vector	modelmins, modelmaxs;

	lea	ecx, DWORD PTR _modelmins$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _modelmaxs$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2105 : 	pmtrace_t	*tr;
; 2106 : 
; 2107 : 	if( pmove->movetype == MOVETYPE_NOCLIP )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+220], 8
	jne	SHORT $LN2@PM_LadderM

; 2108 : 		return;

	jmp	$LN1@PM_LadderM
$LN2@PM_LadderM:

; 2109 : 
; 2110 : 	pmove->PM_GetModelBounds( pLadder->model, modelmins, modelmaxs );

	lea	ecx, DWORD PTR _modelmaxs$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _modelmins$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _pLadder$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325012]
	call	ecx
	add	esp, 12					; 0000000cH

; 2111 : 	ladderCenter = pLadder->origin + ( modelmins + modelmaxs ) * 0.5f;

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T14[ebp]
	push	edx
	lea	eax, DWORD PTR _modelmaxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13[ebp]
	push	ecx
	lea	ecx, DWORD PTR _modelmins$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T12[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLadder$[ebp]
	add	ecx, 36					; 00000024H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ladderCenter$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ladderCenter$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _ladderCenter$[ebp+8], eax

; 2112 : 
; 2113 : 	pmove->movetype = MOVETYPE_FLY;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+220], 5

; 2114 : 
; 2115 : 	// On ladder, convert movement to be relative to the ladder
; 2116 : 	floor = pmove->origin;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _floor$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _floor$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _floor$[ebp+8], edx

; 2117 : 	floor.z += pmove->player_mins[pmove->usehull][2] - 1;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [edx+ecx+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _floor$[ebp+8]
	movss	DWORD PTR _floor$[ebp+8], xmm0

; 2118 : 
; 2119 : 	// g-cont. check bmodels ground too
; 2120 : 	tr = pmove->PM_TraceLine( floor, floor, PM_STUDIO_IGNORE, 2, -1 );

	push	-1
	push	2
	push	1
	lea	ecx, DWORD PTR _floor$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _floor$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324996]
	call	eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tr$[ebp], eax

; 2121 : 
; 2122 : 	if( /*pmove->PM_PointContents( floor, NULL ) == CONTENTS_SOLID || */ tr->ent != -1 )

	mov	ecx, DWORD PTR _tr$[ebp]
	cmp	DWORD PTR [ecx+48], -1
	je	SHORT $LN3@PM_LadderM

; 2123 : 		onFloor = true;

	mov	DWORD PTR _onFloor$[ebp], 1
	jmp	SHORT $LN4@PM_LadderM
$LN3@PM_LadderM:

; 2124 : 	else onFloor = false;

	mov	DWORD PTR _onFloor$[ebp], 0
$LN4@PM_LadderM:

; 2125 : 
; 2126 : 	pmove->gravity = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+192], xmm0

; 2127 : 	pLadder->solid = SOLID_BSP;	// HACKHACK: to allow rotating on ladder model

	mov	eax, DWORD PTR _pLadder$[ebp]
	mov	DWORD PTR [eax+96], 4

; 2128 : 	pmove->PM_TraceModel( pLadder, pmove->origin, ladderCenter, &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ladderCenter$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR _pLadder$[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325020]
	call	ecx
	fstp	ST(0)
	add	esp, 16					; 00000010H

; 2129 : 	pLadder->solid = SOLID_NOT;

	mov	edx, DWORD PTR _pLadder$[ebp]
	mov	DWORD PTR [edx+96], 0

; 2130 : 
; 2131 : 	if( trace.fraction != 1.0 )

	cvtss2sd xmm0, DWORD PTR _trace$[ebp+16]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN13@PM_LadderM

; 2132 : 	{
; 2133 : 		float forward = 0, right = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _forward$24[ebp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _right$23[ebp], xmm0

; 2134 : 		Vector vpn, v_right;

	lea	ecx, DWORD PTR _vpn$16[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _v_right$15[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2135 : 
; 2136 : 		AngleVectors( pmove->angles, vpn, v_right, NULL );

	push	0
	lea	ecx, DWORD PTR _v_right$15[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vpn$16[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	call	DWORD PTR ?gEngfuncs@@3Ucl_enginefuncs_s@@A+96
	add	esp, 16					; 00000010H

; 2137 : 		if ( pmove->cmd.buttons & IN_BACK )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, WORD PTR [eax+283766]
	and	ecx, 16					; 00000010H
	je	SHORT $LN6@PM_LadderM

; 2138 : 			forward -= MAX_CLIMB_SPEED;

	movss	xmm0, DWORD PTR _forward$24[ebp]
	subss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR _forward$24[ebp], xmm0
$LN6@PM_LadderM:

; 2139 : 		if ( pmove->cmd.buttons & IN_FORWARD )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	eax, WORD PTR [edx+283766]
	and	eax, 8
	je	SHORT $LN7@PM_LadderM

; 2140 : 			forward += MAX_CLIMB_SPEED;

	movss	xmm0, DWORD PTR _forward$24[ebp]
	addss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR _forward$24[ebp], xmm0
$LN7@PM_LadderM:

; 2141 : 		if ( pmove->cmd.buttons & IN_MOVELEFT )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, WORD PTR [ecx+283766]
	and	edx, 512				; 00000200H
	je	SHORT $LN8@PM_LadderM

; 2142 : 			right -= MAX_CLIMB_SPEED;

	movss	xmm0, DWORD PTR _right$23[ebp]
	subss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR _right$23[ebp], xmm0
$LN8@PM_LadderM:

; 2143 : 		if ( pmove->cmd.buttons & IN_MOVERIGHT )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, WORD PTR [eax+283766]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN9@PM_LadderM

; 2144 : 			right += MAX_CLIMB_SPEED;

	movss	xmm0, DWORD PTR _right$23[ebp]
	addss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR _right$23[ebp], xmm0
$LN9@PM_LadderM:

; 2145 : 
; 2146 : 		if ( pmove->cmd.buttons & IN_JUMP )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	eax, WORD PTR [edx+283766]
	and	eax, 2
	je	SHORT $LN10@PM_LadderM

; 2147 : 		{
; 2148 : 			pmove->movetype = MOVETYPE_WALK;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+220], 3

; 2149 : 			pmove->velocity = trace.plane.normal * 270;

	push	ecx
	movss	xmm0, DWORD PTR __real@43870000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	lea	ecx, DWORD PTR _trace$[ebp+32]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2150 : 		}
; 2151 : 		else

	jmp	$LN13@PM_LadderM
$LN10@PM_LadderM:

; 2152 : 		{
; 2153 : 			if ( forward != 0 || right != 0 )

	movss	xmm0, DWORD PTR _forward$24[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@PM_LadderM
	movss	xmm0, DWORD PTR _right$23[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN12@PM_LadderM
$LN14@PM_LadderM:

; 2154 : 			{
; 2155 : 				Vector velocity, cross, lateral, tmp;

	lea	ecx, DWORD PTR _velocity$21[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _cross$19[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _lateral$17[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _tmp$18[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2156 : 				float normal;
; 2157 : 
; 2158 : 				//ALERT(at_console, "pev %.2f %.2f %.2f - ",
; 2159 : 				//	pev->velocity.x, pev->velocity.y, pev->velocity.z);
; 2160 : 				// Calculate player's intended velocity
; 2161 : 				//Vector velocity = (forward * gpGlobals->v_forward) + (right * gpGlobals->v_right);
; 2162 : 				velocity = vpn * forward;

	push	ecx
	movss	xmm0, DWORD PTR _forward$24[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T10[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vpn$16[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _velocity$21[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _velocity$21[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _velocity$21[ebp+8], edx

; 2163 : 				velocity += v_right * right;

	push	ecx
	movss	xmm0, DWORD PTR _right$23[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_right$15[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _velocity$21[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2164 : 
; 2165 : 				
; 2166 : 				// Perpendicular in the ladder plane
; 2167 : 				Vector perp = CrossProduct( Vector(0,0,1), trace.plane.normal );

	lea	ecx, DWORD PTR _trace$[ebp+32]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR _perp$20[ebp]
	push	edx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH

; 2168 : 				perp = perp.Normalize();

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR _perp$20[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _perp$20[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _perp$20[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _perp$20[ebp+8], eax

; 2169 : 
; 2170 : 				// decompose velocity into ladder plane
; 2171 : 				normal = DotProduct( velocity, trace.plane.normal );

	lea	ecx, DWORD PTR _trace$[ebp+32]
	push	ecx
	lea	edx, DWORD PTR _velocity$21[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _normal$22[ebp]

; 2172 : 				// This is the velocity into the face of the ladder
; 2173 : 				cross = trace.plane.normal * normal;

	push	ecx
	movss	xmm0, DWORD PTR _normal$22[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _trace$[ebp+32]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cross$19[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _cross$19[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _cross$19[ebp+8], eax

; 2174 : 
; 2175 : 
; 2176 : 				// This is the player's additional velocity
; 2177 : 				lateral = velocity - cross;

	lea	ecx, DWORD PTR _cross$19[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	lea	ecx, DWORD PTR _velocity$21[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lateral$17[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _lateral$17[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _lateral$17[ebp+8], eax

; 2178 : 
; 2179 : 				// This turns the velocity into the face of the ladder into velocity that
; 2180 : 				// is roughly vertically perpendicular to the face of the ladder.
; 2181 : 				// NOTE: It IS possible to face up and move down or face down and move up
; 2182 : 				// because the velocity is a sum of the directional velocity and the converted
; 2183 : 				// velocity through the face of the ladder -- by design.
; 2184 : 				tmp = CrossProduct( trace.plane.normal, perp );

	lea	ecx, DWORD PTR _perp$20[ebp]
	push	ecx
	lea	edx, DWORD PTR _trace$[ebp+32]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$18[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$18[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _tmp$18[ebp+8], eax

; 2185 : 				pmove->velocity = lateral + tmp * -normal;

	movss	xmm0, DWORD PTR _normal$22[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmp$18[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _lateral$17[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2186 : 
; 2187 : 				if( onFloor && normal > 0 )	// On ground moving away from the ladder

	cmp	DWORD PTR _onFloor$[ebp], 0
	je	SHORT $LN15@PM_LadderM
	movss	xmm0, DWORD PTR _normal$22[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN15@PM_LadderM

; 2188 : 				{
; 2189 : 					pmove->velocity += trace.plane.normal * MAX_CLIMB_SPEED;

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _trace$[ebp+32]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$LN15@PM_LadderM:

; 2190 : 				}
; 2191 : 				//pev->velocity = lateral - (CrossProduct( trace.vecPlaneNormal, perp ) * normal);
; 2192 : 			}
; 2193 : 			else

	jmp	SHORT $LN13@PM_LadderM
$LN12@PM_LadderM:

; 2194 : 			{
; 2195 : 				pmove->velocity = g_vecZero;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax
$LN13@PM_LadderM:
$LN1@PM_LadderM:

; 2196 : 			}
; 2197 : 		}
; 2198 : 	}
; 2199 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_LadderMove@@YAXPAUphysent_s@@@Z ENDP		; PM_LadderMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv186 = -56						; size = 8
_duckpressed$ = -48					; size = 4
_duckchange$ = -44					; size = 4
tv333 = -40						; size = 4
_fMore$1 = -36						; size = 4
_time$ = -32						; size = 4
_duckFraction$ = -28					; size = 4
tv230 = -24						; size = 4
_nButtonPressed$ = -20					; size = 4
tv78 = -16						; size = 4
tv75 = -12						; size = 4
_buttonsChanged$ = -8					; size = 4
_i$ = -4						; size = 4
?PM_Duck@@YAXXZ PROC					; PM_Duck

; 1999 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi

; 2000 : 	int i;
; 2001 : 	float time;
; 2002 : 	float duckFraction;
; 2003 : 
; 2004 : 	int buttonsChanged	= ( pmove->oldbuttons ^ pmove->cmd.buttons );	// These buttons have changed this frame

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, WORD PTR [eax+283766]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xor	ecx, DWORD PTR [edx+200]
	mov	DWORD PTR _buttonsChanged$[ebp], ecx

; 2005 : 	int nButtonPressed	=  buttonsChanged & pmove->cmd.buttons;		// The changed ones still down are "pressed"

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, WORD PTR [eax+283766]
	and	ecx, DWORD PTR _buttonsChanged$[ebp]
	mov	DWORD PTR _nButtonPressed$[ebp], ecx

; 2006 : 
; 2007 : 	int duckchange		= buttonsChanged & IN_DUCK ? 1 : 0;

	mov	edx, DWORD PTR _buttonsChanged$[ebp]
	and	edx, 4
	je	SHORT $LN22@PM_Duck
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN23@PM_Duck
$LN22@PM_Duck:
	mov	DWORD PTR tv75[ebp], 0
$LN23@PM_Duck:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _duckchange$[ebp], eax

; 2008 : 	int duckpressed		= nButtonPressed & IN_DUCK ? 1 : 0;

	mov	ecx, DWORD PTR _nButtonPressed$[ebp]
	and	ecx, 4
	je	SHORT $LN24@PM_Duck
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN25@PM_Duck
$LN24@PM_Duck:
	mov	DWORD PTR tv78[ebp], 0
$LN25@PM_Duck:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _duckpressed$[ebp], edx

; 2009 : 
; 2010 : 	if ( pmove->cmd.buttons & IN_DUCK )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, WORD PTR [eax+283766]
	and	ecx, 4
	je	SHORT $LN5@PM_Duck

; 2011 : 	{
; 2012 : 		pmove->oldbuttons |= IN_DUCK;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+200]
	or	eax, 4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+200], eax

; 2013 : 	}
; 2014 : 	else

	jmp	SHORT $LN6@PM_Duck
$LN5@PM_Duck:

; 2015 : 	{
; 2016 : 		pmove->oldbuttons &= ~IN_DUCK;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+200]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+200], eax
$LN6@PM_Duck:

; 2017 : 	}
; 2018 : 
; 2019 : 	// Prevent ducking if the iuser3 variable is set
; 2020 : 	if ( pmove->iuser3 || pmove->dead )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+516], 0
	jne	SHORT $LN8@PM_Duck
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	je	SHORT $LN7@PM_Duck
$LN8@PM_Duck:

; 2021 : 	{
; 2022 : 		// Try to unduck
; 2023 : 		if ( pmove->flags & FL_DUCKING )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, 16384				; 00004000H
	je	SHORT $LN9@PM_Duck

; 2024 : 		{
; 2025 : 			PM_UnDuck();

	call	?PM_UnDuck@@YAXXZ			; PM_UnDuck
$LN9@PM_Duck:

; 2026 : 		}
; 2027 : 		return;

	jmp	$LN1@PM_Duck
$LN7@PM_Duck:

; 2028 : 	}
; 2029 : 
; 2030 : 	if ( pmove->flags & FL_DUCKING )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN10@PM_Duck

; 2031 : 	{
; 2032 : 		pmove->cmd.forwardmove *= 0.333;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [edx+283752]
	mulsd	xmm0, QWORD PTR __real@3fd54fdf3b645a1d
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [eax+283752], xmm0

; 2033 : 		pmove->cmd.sidemove    *= 0.333;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [ecx+283756]
	mulsd	xmm0, QWORD PTR __real@3fd54fdf3b645a1d
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [edx+283756], xmm0

; 2034 : 		pmove->cmd.upmove      *= 0.333;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [eax+283760]
	mulsd	xmm0, QWORD PTR __real@3fd54fdf3b645a1d
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [ecx+283760], xmm0
$LN10@PM_Duck:

; 2035 : 	}
; 2036 : 
; 2037 : 	if ( ( pmove->cmd.buttons & IN_DUCK ) || ( pmove->bInDuck ) || ( pmove->flags & FL_DUCKING ) )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	eax, WORD PTR [edx+283766]
	and	eax, 4
	jne	SHORT $LN12@PM_Duck
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+144], 0
	jne	SHORT $LN12@PM_Duck
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	and	eax, 16384				; 00004000H
	je	$LN14@PM_Duck
$LN12@PM_Duck:

; 2038 : 	{
; 2039 : 		if ( pmove->cmd.buttons & IN_DUCK )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	edx, WORD PTR [ecx+283766]
	and	edx, 4
	je	$LN13@PM_Duck

; 2040 : 		{
; 2041 : 			if ( (nButtonPressed & IN_DUCK ) && !( pmove->flags & FL_DUCKING ) )

	mov	eax, DWORD PTR _nButtonPressed$[ebp]
	and	eax, 4
	je	SHORT $LN15@PM_Duck
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, 16384				; 00004000H
	jne	SHORT $LN15@PM_Duck

; 2042 : 			{
; 2043 : 				// Use 1 second so super long jump will work
; 2044 : 				pmove->flDuckTime = 1000;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR [eax+140], xmm0

; 2045 : 				pmove->bInDuck    = true;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+144], 1
$LN15@PM_Duck:

; 2046 : 			}
; 2047 : 
; 2048 : 			time = max( 0.0, ( 1.0 - (float)pmove->flDuckTime / 1000.0 ) );

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [edx+140]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	jbe	SHORT $LN26@PM_Duck
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv186[ebp], xmm0
	jmp	SHORT $LN27@PM_Duck
$LN26@PM_Duck:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [eax+140]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	movsd	QWORD PTR tv186[ebp], xmm1
$LN27@PM_Duck:
	cvtsd2ss xmm0, QWORD PTR tv186[ebp]
	movss	DWORD PTR _time$[ebp], xmm0

; 2049 : 			
; 2050 : 			if ( pmove->bInDuck )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+144], 0
	je	$LN18@PM_Duck

; 2051 : 			{
; 2052 : #if 0
; 2053 : 				pmove->usehull = 1;
; 2054 : 				pmove->view_ofs[2] = VEC_DUCK_VIEW;
; 2055 : 				pmove->flags |= FL_DUCKING;
; 2056 : #endif
; 2057 : 				// Finish ducking immediately if duck time is over or not on ground
; 2058 : 				if ( ( (float)pmove->flDuckTime / 1000.0 <= ( 1.0 - TIME_TO_DUCK ) ) ||

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm0, DWORD PTR [edx+140]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	xmm1, QWORD PTR __real@3fe3333333333333
	comisd	xmm1, xmm0
	jae	SHORT $LN19@PM_Duck
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	jne	$LN17@PM_Duck
$LN19@PM_Duck:

; 2059 : 					 ( pmove->onground == -1 ) )
; 2060 : 				{
; 2061 : 					pmove->usehull = 1;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+188], 1

; 2062 : 					pmove->view_ofs[2] = VEC_DUCK_VIEW;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR [eax+edx], xmm0

; 2063 : 					pmove->flags |= FL_DUCKING;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+184], ecx

; 2064 : 					pmove->bInDuck = false;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+144], 0

; 2065 : 
; 2066 : 					// HACKHACK - Fudge for collision bug - no time to fix this properly
; 2067 : 					if ( pmove->onground != -1 )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+224], -1
	je	$LN20@PM_Duck

; 2068 : 					{
; 2069 : 						for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_Duck
$LN2@PM_Duck:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@PM_Duck:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@PM_Duck

; 2070 : 						{
; 2071 : 							pmove->origin[i] -= ( pmove->player_mins[1][i] - pmove->player_mins[0][i] );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv230[ebp], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [esi+edx*4]
	subss	xmm0, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR tv230[ebp]
	movss	xmm1, DWORD PTR [edx]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR tv230[ebp]
	movss	DWORD PTR [eax], xmm1

; 2072 : 						}

	jmp	SHORT $LN2@PM_Duck
$LN3@PM_Duck:

; 2073 : 						// See if we are stuck?
; 2074 : 						PM_FixPlayerCrouchStuck( STUCK_MOVEUP );

	push	1
	call	?PM_FixPlayerCrouchStuck@@YAXH@Z	; PM_FixPlayerCrouchStuck
	add	esp, 4

; 2075 : 
; 2076 : 						// Recatagorize position since ducking can change origin
; 2077 : 						PM_CatagorizePosition();

	call	?PM_CatagorizePosition@@YAXXZ		; PM_CatagorizePosition
$LN20@PM_Duck:

; 2078 : 					}
; 2079 : 				}
; 2080 : 				else

	jmp	$LN18@PM_Duck
$LN17@PM_Duck:

; 2081 : 				{
; 2082 : 					float fMore = (VEC_DUCK_HULL_MIN - VEC_HULL_MIN);

	movss	xmm0, DWORD PTR __real@41900000
	movss	DWORD PTR _fMore$1[ebp], xmm0

; 2083 : 
; 2084 : 					// Calc parametric time
; 2085 : 					duckFraction = PM_SplineFraction( time, (1.0/TIME_TO_DUCK) );

	push	ecx
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _time$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?PM_SplineFraction@@YAMMM@Z		; PM_SplineFraction
	add	esp, 8
	fstp	DWORD PTR _duckFraction$[ebp]

; 2086 : 					pmove->view_ofs[2] = ((VEC_DUCK_VIEW - fMore ) * duckFraction) + (VEC_VIEW * (1-duckFraction));

	movss	xmm0, DWORD PTR __real@41400000
	subss	xmm0, DWORD PTR _fMore$1[ebp]
	mulss	xmm0, DWORD PTR _duckFraction$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _duckFraction$[ebp]
	mulss	xmm1, DWORD PTR __real@41e00000
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 128				; 00000080H
	movss	DWORD PTR tv333[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv333[ebp]
	movss	DWORD PTR [eax+ecx], xmm0
$LN18@PM_Duck:

; 2087 : 				}
; 2088 : 			}
; 2089 : 		}
; 2090 : 		else

	jmp	SHORT $LN14@PM_Duck
$LN13@PM_Duck:

; 2091 : 		{
; 2092 : 			// Try to unduck
; 2093 : 			PM_UnDuck();

	call	?PM_UnDuck@@YAXXZ			; PM_UnDuck
$LN14@PM_Duck:
$LN1@PM_Duck:

; 2094 : 		}
; 2095 : 	}
; 2096 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_Duck@@YAXXZ ENDP					; PM_Duck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -360						; size = 68
$T2 = -292						; size = 68
$T3 = -224						; size = 68
$T4 = -156						; size = 68
_trace$ = -88						; size = 68
tv128 = -20						; size = 4
_newOrigin$ = -16					; size = 12
_i$ = -4						; size = 4
?PM_UnDuck@@YAXXZ PROC					; PM_UnDuck

; 1955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	esi
	push	edi

; 1956 : 	int i;
; 1957 : 	pmtrace_t trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 1958 : 	Vector newOrigin;

	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1959 : 
; 1960 : 	newOrigin = pmove->origin;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _newOrigin$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _newOrigin$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _newOrigin$[ebp+8], eax

; 1961 : 
; 1962 : 	if ( pmove->onground != -1 && pmove->flags & FL_DUCKING && pmove->bInDuck == false)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+224], -1
	je	$LN3@PM_UnDuck
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	and	eax, 16384				; 00004000H
	je	$LN3@PM_UnDuck
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+144], 0
	jne	SHORT $LN3@PM_UnDuck

; 1963 : 	{
; 1964 : 		for ( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_UnDuck
$LN2@PM_UnDuck:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@PM_UnDuck:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@PM_UnDuck

; 1965 : 		{
; 1966 : 			newOrigin[i] += ( pmove->player_mins[1][i] - pmove->player_mins[0][i] );

	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [esi+edx*4]
	subss	xmm0, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR tv128[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR tv128[ebp]
	movss	DWORD PTR [eax], xmm0

; 1967 : 		}

	jmp	SHORT $LN2@PM_UnDuck
$LN3@PM_UnDuck:

; 1968 : 	}
; 1969 : 	
; 1970 : 	trace = pmove->PM_PlayerTrace( newOrigin, newOrigin, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324992]
	call	eax
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T4[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T4[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1971 : 
; 1972 : 	if ( !trace.startsolid )

	cmp	DWORD PTR _trace$[ebp+4], 0
	jne	$LN6@PM_UnDuck

; 1973 : 	{
; 1974 : 		pmove->usehull = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+188], 0

; 1975 : 
; 1976 : 		// Oh, no, changing hulls stuck us into something, try unsticking downward first.
; 1977 : 		trace = pmove->PM_PlayerTrace( newOrigin, newOrigin, PM_NORMAL, -1  );

	push	-1
	push	0
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324992]
	call	ecx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T3[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T3[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1978 : 		if ( trace.startsolid )

	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN7@PM_UnDuck

; 1979 : 		{
; 1980 : 			// See if we are stuck?  If so, stay ducked with the duck hull until we have a clear spot
; 1981 : 			//Con_Printf( "unstick got stuck\n" );
; 1982 : 			pmove->usehull = 1;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+188], 1

; 1983 : 			return;

	jmp	$LN1@PM_UnDuck
$LN7@PM_UnDuck:

; 1984 : 		}
; 1985 : 
; 1986 : 		pmove->flags &= ~FL_DUCKING;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	and	ecx, -16385				; ffffbfffH
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+184], ecx

; 1987 : 		pmove->bInDuck  = false;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+144], 0

; 1988 : 		pmove->view_ofs[2] = VEC_VIEW;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@41e00000
	movss	DWORD PTR [eax+ecx], xmm0

; 1989 : 		pmove->flDuckTime = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+140], xmm0

; 1990 : 		
; 1991 : 		pmove->origin = newOrigin;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _newOrigin$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newOrigin$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newOrigin$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1992 : 
; 1993 : 		// Recatagorize position since ducking can change origin
; 1994 : 		PM_CatagorizePosition();

	call	?PM_CatagorizePosition@@YAXXZ		; PM_CatagorizePosition
$LN6@PM_UnDuck:
$LN1@PM_UnDuck:

; 1995 : 	}
; 1996 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_UnDuck@@YAXXZ ENDP					; PM_UnDuck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_test$ = -16						; size = 12
_i$1 = -4						; size = 4
_direction$ = 8						; size = 4
?PM_FixPlayerCrouchStuck@@YAXH@Z PROC			; PM_FixPlayerCrouchStuck

; 1937 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1938 : 	if( pmove->PM_TestPlayerPosition ( pmove->origin, NULL ) == -1 )

	push	0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324956]
	call	ecx
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@PM_FixPlay

; 1939 : 		return;

	jmp	$LN1@PM_FixPlay
$LN5@PM_FixPlay:

; 1940 : 	
; 1941 : 	Vector test = pmove->origin;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	push	edx
	lea	ecx, DWORD PTR _test$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1942 : 	
; 1943 : 	for( int i = 0; i < 36; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@PM_FixPlay
$LN2@PM_FixPlay:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@PM_FixPlay:
	cmp	DWORD PTR _i$1[ebp], 36			; 00000024H
	jge	SHORT $LN3@PM_FixPlay

; 1944 : 	{
; 1945 : 		pmove->origin.z += direction;

	cvtsi2ss xmm0, DWORD PTR _direction$[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	addss	xmm0, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	DWORD PTR [edx+64], xmm0

; 1946 : 
; 1947 : 		if( pmove->PM_TestPlayerPosition ( pmove->origin, NULL ) == -1 )

	push	0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324956]
	call	ecx
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN6@PM_FixPlay

; 1948 : 			return;

	jmp	SHORT $LN1@PM_FixPlay
$LN6@PM_FixPlay:

; 1949 : 	}

	jmp	SHORT $LN2@PM_FixPlay
$LN3@PM_FixPlay:

; 1950 : 
; 1951 : 	pmove->origin = test; // Failed

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _test$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _test$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _test$[ebp+8]
	mov	DWORD PTR [edx+8], eax
$LN1@PM_FixPlay:

; 1952 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_FixPlayerCrouchStuck@@YAXH@Z ENDP			; PM_FixPlayerCrouchStuck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv75 = -8						; size = 4
_valueSquared$ = -4					; size = 4
_value$ = 8						; size = 4
_scale$ = 12						; size = 4
?PM_SplineFraction@@YAMMM@Z PROC			; PM_SplineFraction

; 1926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1927 : 	float valueSquared;
; 1928 : 
; 1929 : 	value = scale * value;

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 1930 : 	valueSquared = value * value;

	movss	xmm0, DWORD PTR _value$[ebp]
	mulss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR _valueSquared$[ebp], xmm0

; 1931 : 
; 1932 : 	// Nice little ease-in, ease-out spline-like curve
; 1933 : 	return 3 * valueSquared - 2 * valueSquared * value;

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _valueSquared$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR _valueSquared$[ebp]
	mulss	xmm1, DWORD PTR _value$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR tv75[ebp], xmm0
	fld	DWORD PTR tv75[ebp]

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_SplineFraction@@YAMMM@Z ENDP			; PM_SplineFraction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -152						; size = 12
$T2 = -140						; size = 12
$T3 = -128						; size = 12
$T4 = -116						; size = 12
$T5 = -104						; size = 12
_currentspeed$ = -92					; size = 4
tv453 = -88						; size = 4
tv451 = -84						; size = 4
_smove$ = -80						; size = 4
_fmove$ = -76						; size = 4
_friction$ = -72					; size = 4
_control$ = -68						; size = 4
_wishvel$ = -64						; size = 12
tv167 = -52						; size = 4
tv83 = -48						; size = 4
_wishdir$ = -44						; size = 12
_accelspeed$ = -32					; size = 4
_addspeed$ = -28					; size = 4
_drop$ = -24						; size = 4
_wishspeed$ = -20					; size = 4
_newspeed$ = -16					; size = 4
_speed$ = -12						; size = 4
_i$ = -8						; size = 4
_target$6 = -4						; size = 4
?PM_SpectatorMove@@YAXXZ PROC				; PM_SpectatorMove

; 1807 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H

; 1808 : 	float	speed, drop, friction, control, newspeed;
; 1809 : 	//float   accel;
; 1810 : 	float	currentspeed, addspeed, accelspeed;
; 1811 : 	int			i;
; 1812 : 	Vector		wishvel;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1813 : 	float		fmove, smove;
; 1814 : 	Vector		wishdir;

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1815 : 	float		wishspeed;
; 1816 : 	// this routine keeps track of the spectators psoition
; 1817 : 	// there a two different main move types : track player or moce freely (OBS_ROAMING)
; 1818 : 	// doesn't need excate track position, only to generate PVS, so just copy
; 1819 : 	// targets position and real view position is calculated on client (saves server CPU)
; 1820 : 	
; 1821 : 	if ( pmove->iuser1 == OBS_ROAMING)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+508], 3
	jne	$LN8@PM_Spectat

; 1822 : 	{
; 1823 : 		// Move around in normal spectator method
; 1824 : 
; 1825 : 		speed = pmove->velocity.Length();

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _speed$[ebp]

; 1826 : 
; 1827 : 		if (speed < 1)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN10@PM_Spectat

; 1828 : 		{
; 1829 : 			pmove->velocity = g_vecZero;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx

; 1830 : 		}
; 1831 : 		else

	jmp	$LN11@PM_Spectat
$LN10@PM_Spectat:

; 1832 : 		{
; 1833 : 			drop = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _drop$[ebp], xmm0

; 1834 : 
; 1835 : 			friction = pmove->movevars->friction*1.5;	// extra friction

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	cvtss2sd xmm0, DWORD PTR [ecx+28]
	mulsd	xmm0, QWORD PTR __real@3ff8000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _friction$[ebp], xmm0

; 1836 : 			control = speed < pmove->movevars->stopspeed ? pmove->movevars->stopspeed : speed;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN20@PM_Spectat
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR tv83[ebp], xmm0
	jmp	SHORT $LN21@PM_Spectat
$LN20@PM_Spectat:
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv83[ebp], xmm0
$LN21@PM_Spectat:
	movss	xmm0, DWORD PTR tv83[ebp]
	movss	DWORD PTR _control$[ebp], xmm0

; 1837 : 			drop += control*friction*pmove->frametime;

	movss	xmm0, DWORD PTR _control$[ebp]
	mulss	xmm0, DWORD PTR _friction$[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm0, DWORD PTR _drop$[ebp]
	movss	DWORD PTR _drop$[ebp], xmm0

; 1838 : 
; 1839 : 			// scale the velocity
; 1840 : 			newspeed = speed - drop;

	movss	xmm0, DWORD PTR _speed$[ebp]
	subss	xmm0, DWORD PTR _drop$[ebp]
	movss	DWORD PTR _newspeed$[ebp], xmm0

; 1841 : 			if (newspeed < 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _newspeed$[ebp]
	jbe	SHORT $LN12@PM_Spectat

; 1842 : 				newspeed = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _newspeed$[ebp], xmm0
$LN12@PM_Spectat:

; 1843 : 			newspeed /= speed;

	movss	xmm0, DWORD PTR _newspeed$[ebp]
	divss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _newspeed$[ebp], xmm0

; 1844 : 
; 1845 : 			pmove->velocity *= newspeed;

	push	ecx
	movss	xmm0, DWORD PTR _newspeed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$LN11@PM_Spectat:

; 1846 : 		}
; 1847 : 
; 1848 : 		// accelerate
; 1849 : 		fmove = pmove->cmd.forwardmove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+283752]
	movss	DWORD PTR _fmove$[ebp], xmm0

; 1850 : 		smove = pmove->cmd.sidemove;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+283756]
	movss	DWORD PTR _smove$[ebp], xmm0

; 1851 : 		
; 1852 : 		pmove->forward = pmove->forward.Normalize();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1853 : 		pmove->right = pmove->right.Normalize();

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1854 : 
; 1855 : 		for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_Spectat
$LN2@PM_Spectat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@PM_Spectat:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@PM_Spectat

; 1856 : 		{
; 1857 : 			wishvel[i] = pmove->forward[i]*fmove + pmove->right[i]*smove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	mulss	xmm0, DWORD PTR _fmove$[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	movss	DWORD PTR tv451[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR _smove$[ebp]
	movss	xmm1, DWORD PTR tv451[ebp]
	addss	xmm1, xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	movss	DWORD PTR tv453[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv453[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0

; 1858 : 		}

	jmp	SHORT $LN2@PM_Spectat
$LN3@PM_Spectat:

; 1859 : 		wishvel[2] += pmove->cmd.upmove;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv167[ebp], eax
	mov	edx, DWORD PTR tv167[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax+283760]
	mov	ecx, DWORD PTR tv167[ebp]
	movss	DWORD PTR [ecx], xmm0

; 1860 : 
; 1861 : 		wishdir = wishvel;

	mov	edx, DWORD PTR _wishvel$[ebp]
	mov	DWORD PTR _wishdir$[ebp], edx
	mov	eax, DWORD PTR _wishvel$[ebp+4]
	mov	DWORD PTR _wishdir$[ebp+4], eax
	mov	ecx, DWORD PTR _wishvel$[ebp+8]
	mov	DWORD PTR _wishdir$[ebp+8], ecx

; 1862 : 		wishspeed = wishdir.Length();

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _wishspeed$[ebp]

; 1863 : 		wishdir = wishdir.Normalize();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _wishdir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _wishdir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _wishdir$[ebp+8], eax

; 1864 : 
; 1865 : 		//
; 1866 : 		// clamp to server defined max speed
; 1867 : 		//
; 1868 : 		if (wishspeed > pmove->movevars->spectatormaxspeed)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	comiss	xmm0, DWORD PTR [edx+12]
	jbe	SHORT $LN13@PM_Spectat

; 1869 : 		{
; 1870 : 			wishvel *= ( pmove->movevars->spectatormaxspeed / wishspeed );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	movss	xmm0, DWORD PTR [ecx+12]
	divss	xmm0, DWORD PTR _wishspeed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1871 : 			wishspeed = pmove->movevars->spectatormaxspeed;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _wishspeed$[ebp], xmm0
$LN13@PM_Spectat:

; 1872 : 		}
; 1873 : 
; 1874 : 		currentspeed = DotProduct(pmove->velocity, wishdir);

	lea	ecx, DWORD PTR _wishdir$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _currentspeed$[ebp]

; 1875 : 		addspeed = wishspeed - currentspeed;

	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	subss	xmm0, DWORD PTR _currentspeed$[ebp]
	movss	DWORD PTR _addspeed$[ebp], xmm0

; 1876 : 		if (addspeed <= 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jb	SHORT $LN14@PM_Spectat

; 1877 : 			return;

	jmp	$LN1@PM_Spectat
$LN14@PM_Spectat:

; 1878 : 
; 1879 : 		accelspeed = pmove->movevars->accelerate*pmove->frametime*wishspeed;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR _wishspeed$[ebp]
	movss	DWORD PTR _accelspeed$[ebp], xmm0

; 1880 : 		if (accelspeed > addspeed)

	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jbe	SHORT $LN15@PM_Spectat

; 1881 : 			accelspeed = addspeed;

	movss	xmm0, DWORD PTR _addspeed$[ebp]
	movss	DWORD PTR _accelspeed$[ebp], xmm0
$LN15@PM_Spectat:

; 1882 : 		
; 1883 : 		pmove->velocity += wishdir * accelspeed;	

	push	ecx
	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1884 : 
; 1885 : 		// move
; 1886 : 		pmove->origin += pmove->velocity * pmove->frametime;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	push	ecx
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1887 : 	}
; 1888 : 	else

	jmp	$LN9@PM_Spectat
$LN8@PM_Spectat:

; 1889 : 	{
; 1890 : 		// all other modes just track some kind of target, so spectator PVS = target PVS
; 1891 : 
; 1892 : 		int target;
; 1893 : 
; 1894 : 		// no valid target ?
; 1895 : 		if ( pmove->iuser2 <= 0)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+512], 0
	jg	SHORT $LN16@PM_Spectat

; 1896 : 			return;

	jmp	$LN1@PM_Spectat
$LN16@PM_Spectat:

; 1897 : 
; 1898 : 		// Find the client this player's targeting
; 1899 : 		for (target = 0; target < pmove->numphysent; target++)

	mov	DWORD PTR _target$6[ebp], 0
	jmp	SHORT $LN7@PM_Spectat
$LN5@PM_Spectat:
	mov	ecx, DWORD PTR _target$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _target$6[ebp], ecx
$LN7@PM_Spectat:
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR _target$6[ebp]
	cmp	eax, DWORD PTR [edx+588]
	jge	SHORT $LN6@PM_Spectat

; 1900 : 		{
; 1901 : 			if ( pmove->physents[target].info == pmove->iuser2 )

	imul	ecx, DWORD PTR _target$6[ebp], 224
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [edx+ecx+672]
	cmp	ecx, DWORD PTR [eax+512]
	jne	SHORT $LN17@PM_Spectat

; 1902 : 				break;

	jmp	SHORT $LN6@PM_Spectat
$LN17@PM_Spectat:

; 1903 : 		}

	jmp	SHORT $LN5@PM_Spectat
$LN6@PM_Spectat:

; 1904 : 
; 1905 : 		if (target == pmove->numphysent)

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR _target$6[ebp]
	cmp	eax, DWORD PTR [edx+588]
	jne	SHORT $LN18@PM_Spectat

; 1906 : 			return;

	jmp	SHORT $LN1@PM_Spectat
$LN18@PM_Spectat:

; 1907 : 
; 1908 : 		// use targets position as own origin for PVS
; 1909 : 		pmove->angles = pmove->physents[target].angles;

	imul	ecx, DWORD PTR _target$6[ebp], 224
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	eax, DWORD PTR [edx+ecx+676]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1910 : 		pmove->origin = pmove->physents[target].origin;

	imul	ecx, DWORD PTR _target$6[ebp], 224
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	eax, DWORD PTR [edx+ecx+628]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1911 : 
; 1912 : 		// no velocity
; 1913 : 		pmove->velocity = g_vecZero;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx
$LN9@PM_Spectat:
$LN1@PM_Spectat:

; 1914 : 	}
; 1915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_SpectatorMove@@YAXXZ ENDP				; PM_SpectatorMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_traceresult$ = -172					; size = 68
$T1 = -104						; size = 12
$T2 = -92						; size = 12
_i$ = -80						; size = 4
_i$3 = -76						; size = 4
_offset$ = -72						; size = 12
_base$ = -60						; size = 12
_fTime$ = -48						; size = 4
_idx$ = -44						; size = 4
tv165 = -40						; size = 4
tv90 = -36						; size = 4
_nReps$4 = -32						; size = 4
_z$5 = -28						; size = 4
_y$6 = -24						; size = 4
_x$7 = -20						; size = 4
_test$ = -16						; size = 12
_hitent$ = -4						; size = 4
?PM_CheckStuck@@YAHXZ PROC				; PM_CheckStuck

; 1703 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH

; 1704 : 	pmtrace_t traceresult;

	lea	ecx, DWORD PTR _traceresult$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 1705 : 
; 1706 : 	// If position is okay, exit
; 1707 : 	int hitent = pmove->PM_TestPlayerPosition( pmove->origin, &traceresult );

	lea	eax, DWORD PTR _traceresult$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324956]
	call	edx
	add	esp, 8
	mov	DWORD PTR _hitent$[ebp], eax

; 1708 : 
; 1709 : 	if( hitent == -1 )

	cmp	DWORD PTR _hitent$[ebp], -1
	jne	SHORT $LN14@PM_CheckSt

; 1710 : 	{
; 1711 : 		PM_ResetStuckOffsets( pmove->player_index, pmove->server );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?PM_ResetStuckOffsets@@YAXHH@Z		; PM_ResetStuckOffsets
	add	esp, 8

; 1712 : 		return 0;

	xor	eax, eax
	jmp	$LN1@PM_CheckSt
$LN14@PM_CheckSt:

; 1713 : 	}
; 1714 : 
; 1715 : 	Vector base = pmove->origin;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	push	ecx
	lea	ecx, DWORD PTR _base$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1716 : 	Vector offset, test;

	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _test$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1717 : 
; 1718 : 	// Deal with precision error in network or stuck with physics body
; 1719 : 	if( !pmove->server || pmove->physents[hitent].solid == SOLID_CUSTOM )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN16@PM_CheckSt
	imul	eax, DWORD PTR _hitent$[ebp], 224
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+eax+688], 5
	jne	$LN3@PM_CheckSt
$LN16@PM_CheckSt:

; 1720 : 	{
; 1721 : 		// world, BSP model or custom convex hull
; 1722 : 		if(( !hitent == 0 ) || pmove->physents[hitent].model || pmove->physents[hitent].solid == SOLID_CUSTOM )

	cmp	DWORD PTR _hitent$[ebp], 0
	jne	SHORT $LN25@PM_CheckSt
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN26@PM_CheckSt
$LN25@PM_CheckSt:
	mov	DWORD PTR tv90[ebp], 0
$LN26@PM_CheckSt:
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN18@PM_CheckSt
	imul	edx, DWORD PTR _hitent$[ebp], 224
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+edx+640], 0
	jne	SHORT $LN18@PM_CheckSt
	imul	ecx, DWORD PTR _hitent$[ebp], 224
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+ecx+688], 5
	jne	$LN3@PM_CheckSt
$LN18@PM_CheckSt:

; 1723 : 		{
; 1724 : 			int nReps = 0;

	mov	DWORD PTR _nReps$4[ebp], 0

; 1725 : 			PM_ResetStuckOffsets( pmove->player_index, pmove->server );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?PM_ResetStuckOffsets@@YAXHH@Z		; PM_ResetStuckOffsets
	add	esp, 8
$LN4@PM_CheckSt:

; 1726 : 
; 1727 : 			do 
; 1728 : 			{
; 1729 : 				int i = PM_GetRandomStuckOffsets( pmove->player_index, pmove->server, offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?PM_GetRandomStuckOffsets@@YAHHHAAVVector@@@Z ; PM_GetRandomStuckOffsets
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$3[ebp], eax

; 1730 : 				test = base + offset;

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _base$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], edx

; 1731 : 
; 1732 : 				if( pmove->PM_TestPlayerPosition( test, &traceresult ) == -1 )

	lea	eax, DWORD PTR _traceresult$[ebp]
	push	eax
	lea	ecx, DWORD PTR _test$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324956]
	call	edx
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN19@PM_CheckSt

; 1733 : 				{
; 1734 : 					PM_ResetStuckOffsets( pmove->player_index, pmove->server );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?PM_ResetStuckOffsets@@YAXHH@Z		; PM_ResetStuckOffsets
	add	esp, 8

; 1735 : //					pmove->Con_Printf( "Unstick by %i\n", i );
; 1736 : 					pmove->origin = test;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _test$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _test$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _test$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1737 : 
; 1738 : 					return 0;

	xor	eax, eax
	jmp	$LN1@PM_CheckSt
$LN19@PM_CheckSt:

; 1739 : 				}
; 1740 : 			} while( ++nReps < 54 );

	mov	eax, DWORD PTR _nReps$4[ebp]
	add	eax, 1
	mov	DWORD PTR _nReps$4[ebp], eax
	cmp	DWORD PTR _nReps$4[ebp], 54		; 00000036H
	jl	$LN4@PM_CheckSt
$LN3@PM_CheckSt:

; 1741 : 		}
; 1742 : 	}
; 1743 : 
; 1744 : 	// only an issue on the client.
; 1745 : 	int idx = (pmove->server) ? 0 : 1;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN27@PM_CheckSt
	mov	DWORD PTR tv165[ebp], 0
	jmp	SHORT $LN28@PM_CheckSt
$LN27@PM_CheckSt:
	mov	DWORD PTR tv165[ebp], 1
$LN28@PM_CheckSt:
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR _idx$[ebp], edx

; 1746 : 	float fTime = pmove->Sys_FloatTime();

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324972]
	call	ecx
	fstp	DWORD PTR _fTime$[ebp]

; 1747 : 
; 1748 : 	// too soon?
; 1749 : 	if( rgStuckCheckTime[pmove->player_index][idx] >= ( fTime - PM_CHECKSTUCK_MINTIME ))

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _idx$[ebp]
	shl	ecx, 2
	movss	xmm0, DWORD PTR _fTime$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR ?rgStuckCheckTime@@3PAY01MA[ecx+eax*8]
	comiss	xmm1, xmm0
	jb	SHORT $LN20@PM_CheckSt

; 1750 : 	{
; 1751 : 		// can't move we're stuck!
; 1752 : 		pmove->flags |= FL_STUCKED;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	or	eax, 134217728				; 08000000H
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+184], eax

; 1753 : 		return 1;

	mov	eax, 1
	jmp	$LN1@PM_CheckSt
$LN20@PM_CheckSt:

; 1754 : 	}
; 1755 : 
; 1756 : 	rgStuckCheckTime[pmove->player_index][idx] = fTime;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _idx$[ebp]
	shl	ecx, 2
	movss	xmm0, DWORD PTR _fTime$[ebp]
	movss	DWORD PTR ?rgStuckCheckTime@@3PAY01MA[ecx+eax*8], xmm0

; 1757 : 	pmove->PM_StuckTouch( hitent, &traceresult );

	lea	edx, DWORD PTR _traceresult$[ebp]
	push	edx
	mov	eax, DWORD PTR _hitent$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324976]
	call	edx
	add	esp, 8

; 1758 : 
; 1759 : 	int i = PM_GetRandomStuckOffsets( pmove->player_index, pmove->server, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?PM_GetRandomStuckOffsets@@YAHHHAAVVector@@@Z ; PM_GetRandomStuckOffsets
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$[ebp], eax

; 1760 : 	test = base + offset;

	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _base$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax

; 1761 : 
; 1762 : 	if(( hitent = pmove->PM_TestPlayerPosition( test, NULL )) == -1 )

	push	0
	lea	ecx, DWORD PTR _test$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324956]
	call	edx
	add	esp, 8
	mov	DWORD PTR _hitent$[ebp], eax
	cmp	DWORD PTR _hitent$[ebp], -1
	jne	SHORT $LN21@PM_CheckSt

; 1763 : 	{
; 1764 : 		PM_ResetStuckOffsets( pmove->player_index, pmove->server );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?PM_ResetStuckOffsets@@YAXHH@Z		; PM_ResetStuckOffsets
	add	esp, 8

; 1765 : 		pmove->origin = test;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _test$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _test$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _test$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1766 : 
; 1767 : 		return 0;

	xor	eax, eax
	jmp	$LN1@PM_CheckSt
$LN21@PM_CheckSt:

; 1768 : 	}
; 1769 : 
; 1770 : 	// If player is flailing while stuck in another player ( should never happen ), then see
; 1771 : 	// if we can't "unstick" them forceably.
; 1772 : 	if( pmove->cmd.buttons & ( IN_JUMP|IN_DUCK|IN_ATTACK ) && pmove->physents[hitent].player )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	ecx, WORD PTR [eax+283766]
	and	ecx, 7
	je	$LN6@PM_CheckSt
	imul	edx, DWORD PTR _hitent$[ebp], 224
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+edx+624], 0
	je	$LN6@PM_CheckSt

; 1773 : 	{
; 1774 : 		for( float z = 0; z <= (4 * pmove->movevars->stepsize); z += pmove->movevars->stepsize )

	xorps	xmm0, xmm0
	movss	DWORD PTR _z$5[ebp], xmm0
	jmp	SHORT $LN7@PM_CheckSt
$LN5@PM_CheckSt:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR _z$5[ebp]
	addss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR _z$5[ebp], xmm0
$LN7@PM_CheckSt:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	movss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR [ecx+48]
	comiss	xmm0, DWORD PTR _z$5[ebp]
	jb	$LN6@PM_CheckSt

; 1775 : 		{
; 1776 : 			for( float x = -8.0f; x <= 8.0f; x += 8.0f )

	movss	xmm0, DWORD PTR __real@c1000000
	movss	DWORD PTR _x$7[ebp], xmm0
	jmp	SHORT $LN10@PM_CheckSt
$LN8@PM_CheckSt:
	movss	xmm0, DWORD PTR _x$7[ebp]
	addss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _x$7[ebp], xmm0
$LN10@PM_CheckSt:
	movss	xmm0, DWORD PTR __real@41000000
	comiss	xmm0, DWORD PTR _x$7[ebp]
	jb	$LN9@PM_CheckSt

; 1777 : 			{
; 1778 : 				for( float y = -8.0f; y <= 8.0f; y += 8.0f )

	movss	xmm0, DWORD PTR __real@c1000000
	movss	DWORD PTR _y$6[ebp], xmm0
	jmp	SHORT $LN13@PM_CheckSt
$LN11@PM_CheckSt:
	movss	xmm0, DWORD PTR _y$6[ebp]
	addss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _y$6[ebp], xmm0
$LN13@PM_CheckSt:
	movss	xmm0, DWORD PTR __real@41000000
	comiss	xmm0, DWORD PTR _y$6[ebp]
	jb	$LN12@PM_CheckSt

; 1779 : 				{
; 1780 : 					test = base;

	mov	edx, DWORD PTR _base$[ebp]
	mov	DWORD PTR _test$[ebp], edx
	mov	eax, DWORD PTR _base$[ebp+4]
	mov	DWORD PTR _test$[ebp+4], eax
	mov	ecx, DWORD PTR _base$[ebp+8]
	mov	DWORD PTR _test$[ebp+8], ecx

; 1781 : 					test.x += x;

	movss	xmm0, DWORD PTR _test$[ebp]
	addss	xmm0, DWORD PTR _x$7[ebp]
	movss	DWORD PTR _test$[ebp], xmm0

; 1782 : 					test.y += y;

	movss	xmm0, DWORD PTR _test$[ebp+4]
	addss	xmm0, DWORD PTR _y$6[ebp]
	movss	DWORD PTR _test$[ebp+4], xmm0

; 1783 : 					test.z += z;

	movss	xmm0, DWORD PTR _test$[ebp+8]
	addss	xmm0, DWORD PTR _z$5[ebp]
	movss	DWORD PTR _test$[ebp+8], xmm0

; 1784 : 
; 1785 : 					if( pmove->PM_TestPlayerPosition( test, NULL ) == -1 )

	push	0
	lea	ecx, DWORD PTR _test$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324956]
	call	eax
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN23@PM_CheckSt

; 1786 : 					{
; 1787 : 						pmove->origin = test;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _test$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _test$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _test$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1788 : 						return 0;

	xor	eax, eax
	jmp	SHORT $LN1@PM_CheckSt
$LN23@PM_CheckSt:

; 1789 : 					}
; 1790 : 				}

	jmp	$LN11@PM_CheckSt
$LN12@PM_CheckSt:

; 1791 : 			}

	jmp	$LN8@PM_CheckSt
$LN9@PM_CheckSt:

; 1792 : 		}

	jmp	$LN5@PM_CheckSt
$LN6@PM_CheckSt:

; 1793 : 	}
; 1794 : 
; 1795 : 	// can't move we're stuck!
; 1796 : 	pmove->flags |= FL_STUCKED;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+184]
	or	ecx, 134217728				; 08000000H
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+184], ecx

; 1797 : 
; 1798 : 	return 1;

	mov	eax, 1
$LN1@PM_CheckSt:

; 1799 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CheckStuck@@YAHXZ ENDP				; PM_CheckStuck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_server$ = 12						; size = 4
?PM_ResetStuckOffsets@@YAXHH@Z PROC			; PM_ResetStuckOffsets

; 1689 : {

	push	ebp
	mov	ebp, esp

; 1690 : 	rgStuckLast[nIndex][server] = 0;

	mov	eax, DWORD PTR _server$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _nIndex$[ebp]
	mov	DWORD PTR ?rgStuckLast@@3PAY01HA[eax+ecx*8], 0

; 1691 : }

	pop	ebp
	ret	0
?PM_ResetStuckOffsets@@YAXHH@Z ENDP			; PM_ResetStuckOffsets
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_idx$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_server$ = 12						; size = 4
_offset$ = 16						; size = 4
?PM_GetRandomStuckOffsets@@YAHHHAAVVector@@@Z PROC	; PM_GetRandomStuckOffsets

; 1680 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1681 : 	// last time we did a full
; 1682 : 	int idx = rgStuckLast[nIndex][server]++;

	mov	eax, DWORD PTR _server$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _nIndex$[ebp]
	mov	edx, DWORD PTR ?rgStuckLast@@3PAY01HA[eax+ecx*8]
	mov	DWORD PTR _idx$[ebp], edx
	mov	eax, DWORD PTR _server$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _nIndex$[ebp]
	mov	edx, DWORD PTR ?rgStuckLast@@3PAY01HA[eax+ecx*8]
	add	edx, 1
	mov	eax, DWORD PTR _server$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _nIndex$[ebp]
	mov	DWORD PTR ?rgStuckLast@@3PAY01HA[eax+ecx*8], edx

; 1683 : 	offset = rgv3tStuckTable[idx % 54];

	mov	eax, DWORD PTR _idx$[ebp]
	cdq
	mov	ecx, 54					; 00000036H
	idiv	ecx
	imul	edx, edx, 12
	add	edx, OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	mov	eax, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1684 : 
; 1685 : 	return (idx % 54);

	mov	eax, DWORD PTR _idx$[ebp]
	cdq
	mov	ecx, 54					; 00000036H
	idiv	ecx
	mov	eax, edx

; 1686 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_GetRandomStuckOffsets@@YAHHHAAVVector@@@Z ENDP	; PM_GetRandomStuckOffsets
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -220						; size = 68
$T2 = -152						; size = 68
_tr$ = -84						; size = 68
_point$ = -16						; size = 12
tv243 = -4						; size = 4
?PM_CatagorizePosition@@YAXXZ PROC			; PM_CatagorizePosition

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	esi
	push	edi

; 1620 : 	Vector		point;

	lea	ecx, DWORD PTR _point$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1621 : 	pmtrace_t		tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 1622 : 
; 1623 : // if the player hull point one unit down is solid, the player
; 1624 : // is on ground
; 1625 : 
; 1626 : // see if standing on something solid	
; 1627 : 
; 1628 : 	// Doing this before we move may introduce a potential latency in water detection, but
; 1629 : 	// doing it after can get us stuck on the bottom in water if the amount we move up
; 1630 : 	// is less than the 1 pixel 'threshold' we're about to snap to.	Also, we'll call
; 1631 : 	// this several times per frame, so we really need to avoid sticking to the bottom of
; 1632 : 	// water on each call, and the converse case will correct itself if called twice.
; 1633 : 	PM_CheckWater();

	call	?PM_CheckWater@@YAHXZ			; PM_CheckWater

; 1634 : 
; 1635 : 	point[0] = pmove->origin[0];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 1636 : 	point[1] = pmove->origin[1];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 1637 : 	point[2] = pmove->origin[2] - 2;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR __real@40000000
	lea	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR tv243[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv243[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1638 : 
; 1639 : 	if (pmove->velocity[2] > 180)   // Shooting up really fast.  Definitely not on ground.

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+edx]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN2@PM_Catagor

; 1640 : 	{
; 1641 : 		pmove->onground = -1;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+224], -1

; 1642 : 	}
; 1643 : 	else

	jmp	$LN8@PM_Catagor
$LN2@PM_Catagor:

; 1644 : 	{
; 1645 : 		// Try and move down.
; 1646 : 		tr = pmove->PM_PlayerTrace (pmove->origin, point, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324992]
	call	eax
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T2[ebp]
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 1647 : 		// If we hit a steep plane, we are not on ground
; 1648 : 		if ( tr.plane.normal[2] < 0.7)

	lea	ecx, DWORD PTR _tr$[ebp+32]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	movsd	xmm1, QWORD PTR __real@3fe6666666666666
	comisd	xmm1, xmm0
	jbe	SHORT $LN4@PM_Catagor

; 1649 : 			pmove->onground = -1;	// too steep

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+224], -1

; 1650 : 		else

	jmp	SHORT $LN5@PM_Catagor
$LN4@PM_Catagor:

; 1651 : 			pmove->onground = tr.ent;  // Otherwise, point to index of ent under us.

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _tr$[ebp+48]
	mov	DWORD PTR [eax+224], ecx
$LN5@PM_Catagor:

; 1652 : 
; 1653 : 		// If we are on something...
; 1654 : 		if (pmove->onground != -1)

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+224], -1
	je	SHORT $LN7@PM_Catagor

; 1655 : 		{
; 1656 : 			// Then we are not in water jump sequence
; 1657 : 			pmove->waterjumptime = 0;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+204], xmm0

; 1658 : 			// If we could make the move, drop us down that 1 pixel
; 1659 : 			if (pmove->waterlevel < 2 && !tr.startsolid && !tr.allsolid)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 2
	jge	SHORT $LN7@PM_Catagor
	cmp	DWORD PTR _tr$[ebp+4], 0
	jne	SHORT $LN7@PM_Catagor
	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN7@PM_Catagor

; 1660 : 				pmove->origin = tr.endpos;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _tr$[ebp+20]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _tr$[ebp+24]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _tr$[ebp+28]
	mov	DWORD PTR [edx+8], eax
$LN7@PM_Catagor:

; 1661 : 		}
; 1662 : 
; 1663 : 		// Standing on an entity other than the world
; 1664 : 		if (tr.ent > 0)   // So signal that we are touching something.

	cmp	DWORD PTR _tr$[ebp+48], 0
	jle	SHORT $LN8@PM_Catagor

; 1665 : 		{
; 1666 : 			PM_AddToTouched(tr, pmove->velocity);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 68					; 00000044H
	mov	ecx, esp
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	??0pmtrace_s@@QAE@ABU0@@Z
	call	?PM_AddToTouched@@YAHUpmtrace_s@@VVector@@@Z ; PM_AddToTouched
	add	esp, 80					; 00000050H
$LN8@PM_Catagor:

; 1667 : 		}
; 1668 : 	}
; 1669 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CatagorizePosition@@YAXXZ ENDP			; PM_CatagorizePosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T2 = -104						; size = 12
$T3 = -92						; size = 12
_point$ = -80						; size = 12
tv461 = -68						; size = 8
tv457 = -60						; size = 8
tv469 = -52						; size = 4
tv467 = -48						; size = 4
_heightover2$ = -44					; size = 4
_height$ = -40						; size = 4
tv465 = -36						; size = 4
tv463 = -32						; size = 4
tv459 = -28						; size = 4
tv312 = -24						; size = 4
_truecont$ = -20					; size = 4
_cont$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?PM_CheckWater@@YAHXZ PROC				; PM_CheckWater

; 1544 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PM_CheckWater@@YAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1545 : 	Vector	point;

	lea	ecx, DWORD PTR _point$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1546 : 	int		cont;
; 1547 : 	int		truecont;
; 1548 : 	float     height;
; 1549 : 	float		heightover2;
; 1550 : 
; 1551 : 	// Pick a spot just above the players feet.
; 1552 : 	point[0] = pmove->origin[0] + (pmove->player_mins[pmove->usehull][0] + pmove->player_maxs[pmove->usehull][0]) * 0.5;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [edx+ecx+324852]
	movsd	QWORD PTR tv457[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [eax+edx+324900]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	addss	xmm0, DWORD PTR [eax+edx]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	xmm1, QWORD PTR tv457[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	lea	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR tv459[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv459[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1553 : 	point[1] = pmove->origin[1] + (pmove->player_mins[pmove->usehull][1] + pmove->player_maxs[pmove->usehull][1]) * 0.5;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	movsd	QWORD PTR tv461[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324900]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	addss	xmm0, DWORD PTR [eax+edx]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	xmm1, QWORD PTR tv461[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	lea	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR tv463[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv463[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1554 : 	point[2] = pmove->origin[2] + pmove->player_mins[pmove->usehull][2] + 1;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [esi+edi]
	addss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR __real@3f800000
	lea	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR tv465[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv465[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1555 : 	
; 1556 : 	// Assume that we are not in water at all.
; 1557 : 	pmove->waterlevel = 0;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [edx+228], 0

; 1558 : 	pmove->watertype = CONTENTS_EMPTY;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+232], -1

; 1559 : 
; 1560 : 	// Grab point contents.
; 1561 : 	cont = pmove->PM_PointContents (point, &truecont );

	lea	ecx, DWORD PTR _truecont$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324980]
	call	eax
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax

; 1562 : 	// Are we under water? (not solid and not empty?)
; 1563 : 	if ((cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT ) || (cont >= CONTENTS_FOG && cont <= CONTENTS_FLYFIELD))

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $LN5@PM_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jg	SHORT $LN4@PM_CheckWa
$LN5@PM_CheckWa:
	cmp	DWORD PTR _cont$[ebp], -19		; ffffffedH
	jl	$LN12@PM_CheckWa
	cmp	DWORD PTR _cont$[ebp], -17		; ffffffefH
	jg	$LN12@PM_CheckWa
$LN4@PM_CheckWa:

; 1564 : 	{
; 1565 : 		// Set water type
; 1566 : 		pmove->watertype = cont;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [ecx+232], edx

; 1567 : 
; 1568 : 		// We are at least at level one
; 1569 : 		pmove->waterlevel = 1;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+228], 1

; 1570 : 
; 1571 : 		height = (pmove->player_mins[pmove->usehull][2] + pmove->player_maxs[pmove->usehull][2]);

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [eax+edx+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [eax+edx+324900]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [esi+edi]
	addss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _height$[ebp], xmm0

; 1572 : 		heightover2 = height * 0.5;

	cvtss2sd xmm0, DWORD PTR _height$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _heightover2$[ebp], xmm0

; 1573 : 
; 1574 : 		// Now check a point that is at the player hull midpoint.
; 1575 : 		point[2] = pmove->origin[2] + heightover2;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _heightover2$[ebp]
	lea	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR tv467[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv467[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1576 : 		cont = pmove->PM_PointContents (point, NULL );

	push	0
	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324980]
	call	eax
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax

; 1577 : 		// If that point is also under water...
; 1578 : 		if ((cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT ) || (cont >= CONTENTS_FOG && cont <= CONTENTS_FLYFIELD))

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $LN8@PM_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jg	SHORT $LN7@PM_CheckWa
$LN8@PM_CheckWa:
	cmp	DWORD PTR _cont$[ebp], -19		; ffffffedH
	jl	$LN9@PM_CheckWa
	cmp	DWORD PTR _cont$[ebp], -17		; ffffffefH
	jg	$LN9@PM_CheckWa
$LN7@PM_CheckWa:

; 1579 : 		{
; 1580 : 			// Set a higher water level.
; 1581 : 			pmove->waterlevel = 2;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+228], 2

; 1582 : 
; 1583 : 			// Now check the eye position.  (view_ofs is relative to the origin)
; 1584 : 			point[2] = pmove->origin[2] + pmove->view_ofs[2];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 128				; 00000080H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [esi+edi]
	addss	xmm0, DWORD PTR [eax+edx]
	lea	ecx, DWORD PTR _point$[ebp]
	movss	DWORD PTR tv469[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv469[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1585 : 
; 1586 : 			cont = pmove->PM_PointContents (point, NULL );

	push	0
	lea	ecx, DWORD PTR _point$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324980]
	call	eax
	add	esp, 8
	mov	DWORD PTR _cont$[ebp], eax

; 1587 : 			if ((cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT ) || cont == CONTENTS_FOG) // Flyfields never cover the eyes

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $LN11@PM_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jg	SHORT $LN10@PM_CheckWa
$LN11@PM_CheckWa:
	cmp	DWORD PTR _cont$[ebp], -19		; ffffffedH
	jne	SHORT $LN9@PM_CheckWa
$LN10@PM_CheckWa:

; 1588 : 				pmove->waterlevel = 3;  // In over our eyes

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+228], 3
$LN9@PM_CheckWa:

; 1589 : 		}
; 1590 : 
; 1591 : 		// Adjust velocity based on water current, if any.
; 1592 : 		if ( ( truecont <= CONTENTS_CURRENT_0 ) &&

	cmp	DWORD PTR _truecont$[ebp], -9		; fffffff7H
	jg	$LN12@PM_CheckWa
	cmp	DWORD PTR _truecont$[ebp], -14		; fffffff2H
	jl	$LN12@PM_CheckWa

; 1593 : 			 ( truecont >= CONTENTS_CURRENT_DOWN ) )
; 1594 : 		{
; 1595 : 			// The deeper we are, the stronger the current.
; 1596 : 			static Vector current_table[] =

	mov	edx, DWORD PTR __tls_index
	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA
	cmp	edx, DWORD PTR __Init_thread_epoch[ecx]
	jle	$LN2@PM_CheckWa
	push	OFFSET ?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA, -1
	jne	$LN2@PM_CheckWa
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1597 : 			{
; 1598 : 			Vector( 1,  0,  0 ), 

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 1599 : 			Vector( 0,  1,  0 ), 

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A+12
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 1600 : 			Vector(-1,  0,  0 ),

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A+24
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 1601 : 			Vector( 0, -1,  0 ), 

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A+36
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 1602 : 			Vector( 0,  0,  1 ), 

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A+48
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 1603 : 			Vector( 0,  0, -1 )

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A+60
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	OFFSET ?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA
	call	__Init_thread_footer
	add	esp, 4
$LN2@PM_CheckWa:

; 1604 : 			};
; 1605 : 
; 1606 : 			pmove->basevelocity = pmove->basevelocity + current_table[CONTENTS_CURRENT_0 - truecont] * (pmove->waterlevel * 50.0f);

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtsi2ss xmm0, DWORD PTR [eax+228]
	mulss	xmm0, DWORD PTR __real@42480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, -9					; fffffff7H
	sub	edx, DWORD PTR _truecont$[ebp]
	imul	ecx, edx, 12
	add	ecx, OFFSET ?current_table@?N@??PM_CheckWater@@YAHXZ@4PAVVector@@A
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN12@PM_CheckWa:

; 1607 : 		}
; 1608 : 	}
; 1609 : 
; 1610 : 	return pmove->waterlevel > 1;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 1
	jle	SHORT $LN14@PM_CheckWa
	mov	DWORD PTR tv312[ebp], 1
	jmp	SHORT $LN15@PM_CheckWa
$LN14@PM_CheckWa:
	mov	DWORD PTR tv312[ebp], 0
$LN15@PM_CheckWa:
	mov	eax, DWORD PTR tv312[ebp]

; 1611 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PM_CheckWater@@YAHXZ$0:
	push	OFFSET ?$TSS0@?N@??PM_CheckWater@@YAHXZ@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?PM_CheckWater@@YAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PM_CheckWater@@YAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PM_CheckWater@@YAHXZ ENDP				; PM_CheckWater
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv68 = -4						; size = 4
?PM_InWater@@YAHXZ PROC					; PM_InWater

; 1532 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1533 : 	return ( pmove->waterlevel > 1 && pmove->watertype != CONTENT_FOG );

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+228], 1
	jle	SHORT $LN3@PM_InWater
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+232], -19		; ffffffedH
	je	SHORT $LN3@PM_InWater
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@PM_InWater
$LN3@PM_InWater:
	mov	DWORD PTR tv68[ebp], 0
$LN4@PM_InWater:
	mov	eax, DWORD PTR tv68[ebp]

; 1534 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_InWater@@YAHXZ ENDP					; PM_InWater
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 12
$T2 = -72						; size = 12
$T3 = -60						; size = 12
_wishvel$ = -48						; size = 12
_wishdir$ = -36						; size = 12
tv270 = -24						; size = 4
tv268 = -20						; size = 4
_smove$ = -16						; size = 4
_fmove$ = -12						; size = 4
_wishspeed$ = -8					; size = 4
_i$ = -4						; size = 4
?PM_AirMove@@YAXXZ PROC					; PM_AirMove

; 1484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 1485 : 	int			i;
; 1486 : 	Vector		wishvel;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1487 : 	float		fmove, smove;
; 1488 : 	Vector		wishdir;

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1489 : 	float		wishspeed;
; 1490 : 
; 1491 : 	// Copy movement amounts
; 1492 : 	fmove = pmove->cmd.forwardmove;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+283752]
	movss	DWORD PTR _fmove$[ebp], xmm0

; 1493 : 	smove = pmove->cmd.sidemove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+283756]
	movss	DWORD PTR _smove$[ebp], xmm0

; 1494 : 	
; 1495 : 	// Zero out z components of movement vectors
; 1496 : 	pmove->forward[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 1497 : 	pmove->right[2]   = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 1498 : 
; 1499 : 	// Renormalize
; 1500 : 	pmove->forward = pmove->forward.Normalize();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1501 : 	pmove->right = pmove->right.Normalize(); 

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1502 : 
; 1503 : 	// Determine x and y parts of velocity
; 1504 : 	for (i=0 ; i<2 ; i++)       

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_AirMove
$LN2@PM_AirMove:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@PM_AirMove:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@PM_AirMove

; 1505 : 	{
; 1506 : 		wishvel[i] = pmove->forward[i]*fmove + pmove->right[i]*smove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	mulss	xmm0, DWORD PTR _fmove$[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	movss	DWORD PTR tv268[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR _smove$[ebp]
	movss	xmm1, DWORD PTR tv268[ebp]
	addss	xmm1, xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	movss	DWORD PTR tv270[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv270[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0

; 1507 : 	}

	jmp	SHORT $LN2@PM_AirMove
$LN3@PM_AirMove:

; 1508 : 	// Zero out z part of velocity
; 1509 : 	wishvel[2] = 0;             

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 1510 : 
; 1511 : 	 // Determine maginitude of speed of move
; 1512 : 	wishdir = wishvel;		// determine maginitude of speed of move

	mov	edx, DWORD PTR _wishvel$[ebp]
	mov	DWORD PTR _wishdir$[ebp], edx
	mov	eax, DWORD PTR _wishvel$[ebp+4]
	mov	DWORD PTR _wishdir$[ebp+4], eax
	mov	ecx, DWORD PTR _wishvel$[ebp+8]
	mov	DWORD PTR _wishdir$[ebp+8], ecx

; 1513 : 	wishspeed = wishdir.Length();

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _wishspeed$[ebp]

; 1514 : 	wishdir = wishdir.Normalize();

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _wishdir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _wishdir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _wishdir$[ebp+8], eax

; 1515 : 
; 1516 : 	// Clamp to server defined max speed
; 1517 : 	if (wishspeed > pmove->maxspeed)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	comiss	xmm0, DWORD PTR [ecx+500]
	jbe	SHORT $LN5@PM_AirMove

; 1518 : 	{
; 1519 : 		wishvel *= ( pmove->maxspeed / wishspeed );

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+500]
	divss	xmm0, DWORD PTR _wishspeed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1520 : 		wishspeed = pmove->maxspeed;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+500]
	movss	DWORD PTR _wishspeed$[ebp], xmm0
$LN5@PM_AirMove:

; 1521 : 	}
; 1522 : 	
; 1523 : 	PM_AirAccelerate (wishdir, wishspeed, pmove->movevars->airaccelerate);

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _wishdir$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_AirAccelerate@@YAXVVector@@MM@Z	; PM_AirAccelerate
	add	esp, 20					; 00000014H

; 1524 : 
; 1525 : 	// Add in any base velocity to the current velocity.
; 1526 : 	pmove->velocity += pmove->basevelocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1527 : 
; 1528 : 	PM_FlyMove ();

	call	?PM_FlyMove@@YAHXZ			; PM_FlyMove

; 1529 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_AirMove@@YAXXZ ENDP					; PM_AirMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -360						; size = 68
$T2 = -292						; size = 68
$T3 = -224						; size = 12
$T4 = -212						; size = 12
$T5 = -200						; size = 12
$T6 = -188						; size = 12
_temp$ = -176						; size = 12
_trace$ = -164						; size = 68
_start$ = -96						; size = 12
tv452 = -84						; size = 4
tv450 = -80						; size = 4
_dest$ = -76						; size = 12
_wishdir$ = -64						; size = 12
tv237 = -52						; size = 4
tv216 = -48						; size = 4
tv148 = -44						; size = 4
tv140 = -40						; size = 4
_accelspeed$ = -36					; size = 4
_addspeed$ = -32					; size = 4
_wishvel$ = -28						; size = 12
_speed$ = -16						; size = 4
_newspeed$ = -12					; size = 4
_wishspeed$ = -8					; size = 4
_i$ = -4						; size = 4
?PM_WaterMove@@YAXXZ PROC				; PM_WaterMove

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	esi
	push	edi

; 1386 : 	int		i;
; 1387 : 	Vector	wishvel;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1388 : 	float	wishspeed;
; 1389 : 	Vector	wishdir;

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1390 : 	Vector	start, dest;

	lea	ecx, DWORD PTR _start$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _dest$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1391 : 	Vector  temp;

	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1392 : 	pmtrace_t	trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 1393 : 
; 1394 : 	float speed, newspeed, addspeed, accelspeed;
; 1395 : 
; 1396 : //
; 1397 : // user intentions
; 1398 : //
; 1399 : 	for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_WaterMo
$LN2@PM_WaterMo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_WaterMo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@PM_WaterMo

; 1400 : 		wishvel[i] = pmove->forward[i]*pmove->cmd.forwardmove + pmove->right[i]*pmove->cmd.sidemove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR [edx+283752]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	movss	DWORD PTR tv450[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR [edx+283756]
	movss	xmm1, DWORD PTR tv450[ebp]
	addss	xmm1, xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	movss	DWORD PTR tv452[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv452[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
	jmp	$LN2@PM_WaterMo
$LN3@PM_WaterMo:

; 1401 : 
; 1402 : 	// Sinking after no other movement occurs
; 1403 : 	if (!pmove->cmd.forwardmove && !pmove->cmd.sidemove && !pmove->cmd.upmove && pmove->watertype != CONTENT_FLYFIELD)

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+283752]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@PM_WaterMo
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+283756]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@PM_WaterMo
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+283760]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@PM_WaterMo
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+232], -17		; ffffffefH
	je	SHORT $LN8@PM_WaterMo

; 1404 : 		wishvel[2] -= 60;		// drift towards bottom

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv140[ebp], eax
	mov	edx, DWORD PTR tv140[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR __real@42700000
	mov	eax, DWORD PTR tv140[ebp]
	movss	DWORD PTR [eax], xmm0

; 1405 : 	else  // Go straight up by upmove amount.

	jmp	SHORT $LN9@PM_WaterMo
$LN8@PM_WaterMo:

; 1406 : 		wishvel[2] += pmove->cmd.upmove;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv148[ebp], eax
	mov	edx, DWORD PTR tv148[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax+283760]
	mov	ecx, DWORD PTR tv148[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN9@PM_WaterMo:

; 1407 : 
; 1408 : 	// Copy it over and determine speed
; 1409 : 	wishdir = wishvel;

	mov	edx, DWORD PTR _wishvel$[ebp]
	mov	DWORD PTR _wishdir$[ebp], edx
	mov	eax, DWORD PTR _wishvel$[ebp+4]
	mov	DWORD PTR _wishdir$[ebp+4], eax
	mov	ecx, DWORD PTR _wishvel$[ebp+8]
	mov	DWORD PTR _wishdir$[ebp+8], ecx

; 1410 : 	wishspeed = wishdir.Length();

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _wishspeed$[ebp]

; 1411 : 	wishdir = wishdir.Normalize();

	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _wishdir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _wishdir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _wishdir$[ebp+8], eax

; 1412 : 
; 1413 : 	// Cap speed.
; 1414 : 	if (wishspeed > pmove->maxspeed)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	comiss	xmm0, DWORD PTR [ecx+500]
	jbe	SHORT $LN10@PM_WaterMo

; 1415 : 	{
; 1416 : 		wishvel *= ( pmove->maxspeed / wishspeed );

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+500]
	divss	xmm0, DWORD PTR _wishspeed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1417 : 		wishspeed = pmove->maxspeed;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+500]
	movss	DWORD PTR _wishspeed$[ebp], xmm0
$LN10@PM_WaterMo:

; 1418 : 	}
; 1419 : 	// Slow us down a bit.
; 1420 : 	wishspeed *= 0.8;

	cvtss2sd xmm0, DWORD PTR _wishspeed$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _wishspeed$[ebp], xmm0

; 1421 : 
; 1422 : 	pmove->velocity += pmove->basevelocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1423 : 
; 1424 : 	// water friction
; 1425 : 	speed = pmove->velocity.Length();

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _speed$[ebp]

; 1426 : 
; 1427 : 	if (speed)

	movss	xmm0, DWORD PTR _speed$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@PM_WaterMo

; 1428 : 	{
; 1429 : 		newspeed = speed - pmove->frametime * speed * pmove->movevars->friction * pmove->friction;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	mulss	xmm0, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [edx+196]
	movss	xmm1, DWORD PTR _speed$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _newspeed$[ebp], xmm1

; 1430 : 
; 1431 : 		if( newspeed < 0 ) newspeed = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _newspeed$[ebp]
	jbe	SHORT $LN13@PM_WaterMo
	xorps	xmm0, xmm0
	movss	DWORD PTR _newspeed$[ebp], xmm0
$LN13@PM_WaterMo:

; 1432 : 		pmove->velocity *= ( newspeed / speed );

	movss	xmm0, DWORD PTR _newspeed$[ebp]
	divss	xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1433 : 	}
; 1434 : 	else

	jmp	SHORT $LN12@PM_WaterMo
$LN11@PM_WaterMo:

; 1435 : 		newspeed = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _newspeed$[ebp], xmm0
$LN12@PM_WaterMo:

; 1436 : 
; 1437 : //
; 1438 : // water acceleration
; 1439 : //
; 1440 : 	if ( wishspeed < 0.1f )

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _wishspeed$[ebp]
	jbe	SHORT $LN14@PM_WaterMo

; 1441 : 	{
; 1442 : 		return;

	jmp	$LN1@PM_WaterMo
$LN14@PM_WaterMo:

; 1443 : 	}
; 1444 : 
; 1445 : 	addspeed = wishspeed - newspeed;

	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	subss	xmm0, DWORD PTR _newspeed$[ebp]
	movss	DWORD PTR _addspeed$[ebp], xmm0

; 1446 : 	if (addspeed > 0)

	movss	xmm0, DWORD PTR _addspeed$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN6@PM_WaterMo

; 1447 : 	{
; 1448 : 
; 1449 : 		wishvel = wishvel.Normalize();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _wishvel$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _wishvel$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _wishvel$[ebp+8], eax

; 1450 : 		accelspeed = pmove->movevars->accelerate * wishspeed * pmove->frametime * pmove->friction;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR _wishspeed$[ebp]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [ecx+196]
	movss	DWORD PTR _accelspeed$[ebp], xmm0

; 1451 : 		if (accelspeed > addspeed)

	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jbe	SHORT $LN16@PM_WaterMo

; 1452 : 			accelspeed = addspeed;

	movss	xmm0, DWORD PTR _addspeed$[ebp]
	movss	DWORD PTR _accelspeed$[ebp], xmm0
$LN16@PM_WaterMo:

; 1453 : 
; 1454 : 		for (i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@PM_WaterMo
$LN5@PM_WaterMo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@PM_WaterMo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@PM_WaterMo

; 1455 : 			pmove->velocity[i] += accelspeed * wishvel[i];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv216[ebp], edx
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR tv216[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR tv216[ebp]
	movss	DWORD PTR [eax], xmm0
	jmp	SHORT $LN5@PM_WaterMo
$LN6@PM_WaterMo:

; 1456 : 	}
; 1457 : 
; 1458 : 	// Now move
; 1459 : 	// assume it is a stair or a slope, so press down from stepheight above
; 1460 : 	dest = pmove->origin + pmove->velocity * pmove->frametime;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	push	ecx
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dest$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp+8], eax

; 1461 : 	start = dest;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _start$[ebp], ecx
	mov	edx, DWORD PTR _dest$[ebp+4]
	mov	DWORD PTR _start$[ebp+4], edx
	mov	eax, DWORD PTR _dest$[ebp+8]
	mov	DWORD PTR _start$[ebp+8], eax

; 1462 : 	
; 1463 : 	start[2] += pmove->movevars->stepsize + 1;

	lea	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv237[ebp], eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR [eax+48]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR tv237[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv237[ebp]
	movss	DWORD PTR [edx], xmm0

; 1464 : 	trace = pmove->PM_PlayerTrace (start, dest, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _dest$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324992]
	call	edx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T2[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1465 : 	if( !trace.startsolid && !trace.allsolid )	// FIXME: check steep slope?

	cmp	DWORD PTR _trace$[ebp+4], 0
	jne	SHORT $LN17@PM_WaterMo
	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN17@PM_WaterMo

; 1466 : 	{	
; 1467 : 		// walked up the step, so just keep result and exit
; 1468 : 		pmove->origin = trace.endpos;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _trace$[ebp+20]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _trace$[ebp+24]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _trace$[ebp+28]
	mov	DWORD PTR [eax+8], ecx

; 1469 : 		return;

	jmp	SHORT $LN1@PM_WaterMo
$LN17@PM_WaterMo:

; 1470 : 	}
; 1471 : 	
; 1472 : 	// Try moving straight along out normal path.
; 1473 : 	PM_FlyMove ();

	call	?PM_FlyMove@@YAHXZ			; PM_FlyMove
$LN1@PM_WaterMo:

; 1474 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_WaterMove@@YAXXZ ENDP				; PM_WaterMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_currentspeed$ = -24					; size = 4
tv93 = -20						; size = 4
_accelspeed$ = -16					; size = 4
_addspeed$ = -12					; size = 4
_wishspd$ = -8						; size = 4
_i$ = -4						; size = 4
_wishdir$ = 8						; size = 12
_wishspeed$ = 20					; size = 4
_accel$ = 24						; size = 4
?PM_AirAccelerate@@YAXVVector@@MM@Z PROC		; PM_AirAccelerate

; 1344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1345 : 	int			i;
; 1346 : 	float		addspeed, accelspeed, currentspeed, wishspd = wishspeed;

	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	movss	DWORD PTR _wishspd$[ebp], xmm0

; 1347 : 		
; 1348 : 	if (pmove->dead)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	je	SHORT $LN5@PM_AirAcce

; 1349 : 		return;

	jmp	$LN1@PM_AirAcce
$LN5@PM_AirAcce:

; 1350 : 	if (pmove->waterjumptime)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@PM_AirAcce

; 1351 : 		return;

	jmp	$LN1@PM_AirAcce
$LN6@PM_AirAcce:

; 1352 : 
; 1353 : 	// Cap speed
; 1354 : 
; 1355 : 	if (wishspd > 30)

	movss	xmm0, DWORD PTR _wishspd$[ebp]
	comiss	xmm0, DWORD PTR __real@41f00000
	jbe	SHORT $LN7@PM_AirAcce

; 1356 : 		wishspd = 30;

	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR _wishspd$[ebp], xmm0
$LN7@PM_AirAcce:

; 1357 : 	// Determine veer amount
; 1358 : 	currentspeed = DotProduct (pmove->velocity, wishdir);

	lea	edx, DWORD PTR _wishdir$[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _currentspeed$[ebp]

; 1359 : 	// See how much to add
; 1360 : 	addspeed = wishspd - currentspeed;

	movss	xmm0, DWORD PTR _wishspd$[ebp]
	subss	xmm0, DWORD PTR _currentspeed$[ebp]
	movss	DWORD PTR _addspeed$[ebp], xmm0

; 1361 : 	// If not adding any, done.
; 1362 : 	if (addspeed <= 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jb	SHORT $LN8@PM_AirAcce

; 1363 : 		return;

	jmp	$LN1@PM_AirAcce
$LN8@PM_AirAcce:

; 1364 : 	// Determine acceleration speed after acceleration
; 1365 : 
; 1366 : 	accelspeed = accel * wishspeed * pmove->frametime * pmove->friction;

	movss	xmm0, DWORD PTR _accel$[ebp]
	mulss	xmm0, DWORD PTR _wishspeed$[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [edx+196]
	movss	DWORD PTR _accelspeed$[ebp], xmm0

; 1367 : 	// Cap it
; 1368 : 	if (accelspeed > addspeed)

	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jbe	SHORT $LN9@PM_AirAcce

; 1369 : 		accelspeed = addspeed;

	movss	xmm0, DWORD PTR _addspeed$[ebp]
	movss	DWORD PTR _accelspeed$[ebp], xmm0
$LN9@PM_AirAcce:

; 1370 : 	
; 1371 : 	// Adjust pmove vel.
; 1372 : 	for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_AirAcce
$LN2@PM_AirAcce:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_AirAcce:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@PM_AirAcce

; 1373 : 	{
; 1374 : 		pmove->velocity[i] += accelspeed*wishdir[i];	

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv93[ebp], edx
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR tv93[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR tv93[ebp]
	movss	DWORD PTR [eax], xmm0

; 1375 : 	}

	jmp	SHORT $LN2@PM_AirAcce
$LN3@PM_AirAcce:
$LN1@PM_AirAcce:

; 1376 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_AirAccelerate@@YAXVVector@@MM@Z ENDP		; PM_AirAccelerate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -280						; size = 68
$T2 = -212						; size = 68
_trace$3 = -144						; size = 68
_newvel$ = -76						; size = 12
_stop$4 = -64						; size = 12
_start$5 = -52						; size = 12
_control$ = -40						; size = 4
tv333 = -36						; size = 4
tv331 = -32						; size = 4
tv211 = -28						; size = 4
tv155 = -24						; size = 4
tv134 = -20						; size = 4
_drop$ = -16						; size = 4
_friction$ = -12					; size = 4
_newspeed$ = -8						; size = 4
_speed$ = -4						; size = 4
?PM_Friction@@YAXXZ PROC				; PM_Friction

; 1275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	esi
	push	edi

; 1276 : 	float	speed, newspeed, control;
; 1277 : 	float	friction;
; 1278 : 	float	drop;
; 1279 : 	Vector newvel;

	lea	ecx, DWORD PTR _newvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1280 : 	
; 1281 : 	// If we are in water jump cycle, don't apply friction
; 1282 : 	if (pmove->waterjumptime)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PM_Frictio

; 1283 : 		return;

	jmp	$LN1@PM_Frictio
$LN2@PM_Frictio:

; 1284 : 	
; 1285 : 	// Calculate speed
; 1286 : 	speed = sqrt( DotProduct( pmove->velocity, pmove->velocity ));

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _speed$[ebp]

; 1287 : 	
; 1288 : 	// If too slow, return
; 1289 : 	if (speed < 0.1f)

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN3@PM_Frictio

; 1290 : 	{
; 1291 : 		return;

	jmp	$LN1@PM_Frictio
$LN3@PM_Frictio:

; 1292 : 	}
; 1293 : 
; 1294 : 	drop = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _drop$[ebp], xmm0

; 1295 : 
; 1296 : // apply ground friction
; 1297 : 	if (pmove->onground != -1)  // On an entity that is the ground

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+224], -1
	je	$LN4@PM_Frictio

; 1298 : 	{
; 1299 : 		Vector start, stop;

	lea	ecx, DWORD PTR _start$5[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _stop$4[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1300 : 		pmtrace_t trace;

	lea	ecx, DWORD PTR _trace$3[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 1301 : 
; 1302 : 		start[0] = stop[0] = pmove->origin[0] + pmove->velocity[0] / speed * 16;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, 4
	imul	edi, ecx, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	divss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR [esi+edi]
	addss	xmm1, xmm0
	movss	DWORD PTR tv134[ebp], xmm1
	lea	ecx, DWORD PTR _stop$4[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR [eax+ecx], xmm0
	lea	ecx, DWORD PTR _start$5[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1303 : 		start[1] = stop[1] = pmove->origin[1] + pmove->velocity[1] / speed * 16;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	divss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@41800000
	movss	xmm1, DWORD PTR [esi+edi]
	addss	xmm1, xmm0
	movss	DWORD PTR tv155[ebp], xmm1
	lea	ecx, DWORD PTR _stop$4[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv155[ebp]
	movss	DWORD PTR [eax+ecx], xmm0
	lea	ecx, DWORD PTR _start$5[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv155[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1304 : 		start[2] = pmove->origin[2] + pmove->player_mins[pmove->usehull][2];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [edx+ecx+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [esi+edi]
	addss	xmm0, DWORD PTR [eax+ecx]
	lea	ecx, DWORD PTR _start$5[ebp]
	movss	DWORD PTR tv331[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv331[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1305 : 		stop[2] = start[2] - 34;

	lea	ecx, DWORD PTR _start$5[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	subss	xmm0, DWORD PTR __real@42080000
	lea	ecx, DWORD PTR _stop$4[ebp]
	movss	DWORD PTR tv333[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv333[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1306 : 
; 1307 : 		trace = pmove->PM_PlayerTrace (start, stop, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _stop$4[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _start$5[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324992]
	call	edx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T2[ebp]
	lea	edi, DWORD PTR _trace$3[ebp]
	rep movsd

; 1308 : 
; 1309 : 		if (trace.fraction == 1.0)

	cvtss2sd xmm0, DWORD PTR _trace$3[ebp+16]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PM_Frictio

; 1310 : 			friction = pmove->movevars->friction*pmove->movevars->edgefriction;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR _friction$[ebp], xmm0

; 1311 : 		else

	jmp	SHORT $LN6@PM_Frictio
$LN5@PM_Frictio:

; 1312 : 			friction = pmove->movevars->friction;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR _friction$[ebp], xmm0
$LN6@PM_Frictio:

; 1313 : 		
; 1314 : 		// Grab friction value.
; 1315 : 		//friction = pmove->movevars->friction;      
; 1316 : 
; 1317 : 		friction *= pmove->friction;  // player friction?

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _friction$[ebp]
	mulss	xmm0, DWORD PTR [eax+196]
	movss	DWORD PTR _friction$[ebp], xmm0

; 1318 : 
; 1319 : 		// Bleed off some speed, but if we have less than the bleed
; 1320 : 		//  threshhold, bleed the theshold amount.
; 1321 : 		control = (speed < pmove->movevars->stopspeed) ?

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN9@PM_Frictio
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR tv211[ebp], xmm0
	jmp	SHORT $LN10@PM_Frictio
$LN9@PM_Frictio:
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv211[ebp], xmm0
$LN10@PM_Frictio:
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR _control$[ebp], xmm0

; 1322 : 			pmove->movevars->stopspeed : speed;
; 1323 : 		// Add the amount to t'he drop amount.
; 1324 : 		drop += control*friction*pmove->frametime;

	movss	xmm0, DWORD PTR _control$[ebp]
	mulss	xmm0, DWORD PTR _friction$[ebp]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [edx+16]
	addss	xmm0, DWORD PTR _drop$[ebp]
	movss	DWORD PTR _drop$[ebp], xmm0
$LN4@PM_Frictio:

; 1325 : 	}
; 1326 : 
; 1327 : // apply water friction
; 1328 : //	if (pmove->waterlevel)
; 1329 : //		drop += speed * pmove->movevars->waterfriction * waterlevel * pmove->frametime;
; 1330 : 
; 1331 : // scale the velocity
; 1332 : 	newspeed = speed - drop;

	movss	xmm0, DWORD PTR _speed$[ebp]
	subss	xmm0, DWORD PTR _drop$[ebp]
	movss	DWORD PTR _newspeed$[ebp], xmm0

; 1333 : 	if (newspeed < 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _newspeed$[ebp]
	jbe	SHORT $LN7@PM_Frictio

; 1334 : 		newspeed = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _newspeed$[ebp], xmm0
$LN7@PM_Frictio:

; 1335 : 
; 1336 : 	// Determine proportion of old speed we are using.
; 1337 : 	newspeed /= speed;

	movss	xmm0, DWORD PTR _newspeed$[ebp]
	divss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _newspeed$[ebp], xmm0

; 1338 : 
; 1339 : 	// Adjust velocity according to proportion.
; 1340 : 	pmove->velocity *= newspeed;

	push	ecx
	movss	xmm0, DWORD PTR _newspeed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=
$LN1@PM_Frictio:

; 1341 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_Friction@@YAXXZ ENDP				; PM_Friction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -684						; size = 68
$T2 = -616						; size = 68
$T3 = -548						; size = 68
$T4 = -480						; size = 68
$T5 = -412						; size = 68
$T6 = -344						; size = 68
$T7 = -276						; size = 12
$T8 = -264						; size = 12
$T9 = -252						; size = 12
_trace$ = -240						; size = 68
_start$ = -172						; size = 12
tv868 = -160						; size = 4
tv866 = -156						; size = 4
_spd$ = -152						; size = 4
tv864 = -148						; size = 4
tv862 = -144						; size = 4
_smove$ = -140						; size = 4
_fmove$ = -136						; size = 4
_updist$ = -132						; size = 4
_downdist$ = -128					; size = 4
tv878 = -124						; size = 4
tv880 = -120						; size = 4
tv876 = -116						; size = 4
tv872 = -112						; size = 4
tv874 = -108						; size = 4
tv870 = -104						; size = 4
_clip$ = -100						; size = 4
_oldonground$ = -96					; size = 4
_originalvel$ = -92					; size = 12
_wishvel$ = -80						; size = 12
_downvel$ = -68						; size = 12
_wishdir$ = -56						; size = 12
_down$ = -44						; size = 12
_original$ = -32					; size = 12
_wishspeed$ = -20					; size = 4
_dest$ = -16						; size = 12
_i$ = -4						; size = 4
?PM_WalkMove@@YAXXZ PROC				; PM_WalkMove

; 1104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	push	esi
	push	edi

; 1105 : 	int			clip;
; 1106 : 	int			oldonground;
; 1107 : 	int i;
; 1108 : 
; 1109 : 	Vector		wishvel;

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1110 : 	float       spd;
; 1111 : 	float		fmove, smove;
; 1112 : 	Vector		wishdir;

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1113 : 	float		wishspeed;
; 1114 : 
; 1115 : 	Vector dest, start;

	lea	ecx, DWORD PTR _dest$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _start$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1116 : 	Vector original, originalvel;

	lea	ecx, DWORD PTR _original$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _originalvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1117 : 	Vector down, downvel;

	lea	ecx, DWORD PTR _down$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _downvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1118 : 	float downdist, updist;
; 1119 : 
; 1120 : 	pmtrace_t trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 1121 : 	
; 1122 : 	// Copy movement amounts
; 1123 : 	fmove = pmove->cmd.forwardmove;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+283752]
	movss	DWORD PTR _fmove$[ebp], xmm0

; 1124 : 	smove = pmove->cmd.sidemove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+283756]
	movss	DWORD PTR _smove$[ebp], xmm0

; 1125 : 	
; 1126 : 	// Zero out z components of movement vectors
; 1127 : 	pmove->forward[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 1128 : 	pmove->right[2]   = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 1129 : 	
; 1130 : 	pmove->forward = pmove->forward.Normalize();  // Normalize remainder of vectors.

	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1131 : 	pmove->right = pmove->right.Normalize();    // 

	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 32					; 00000020H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1132 : 
; 1133 : 	for (i=0 ; i<2 ; i++)       // Determine x and y parts of velocity

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_WalkMov
$LN2@PM_WalkMov:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@PM_WalkMov:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@PM_WalkMov

; 1134 : 		wishvel[i] = pmove->forward[i]*fmove + pmove->right[i]*smove;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 20					; 00000014H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	mulss	xmm0, DWORD PTR _fmove$[ebp]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 32					; 00000020H
	movss	DWORD PTR tv862[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR _smove$[ebp]
	movss	xmm1, DWORD PTR tv862[ebp]
	addss	xmm1, xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	movss	DWORD PTR tv864[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv864[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
	jmp	$LN2@PM_WalkMov
$LN3@PM_WalkMov:

; 1135 : 	
; 1136 : 	wishvel[2] = 0;             // Zero out z part of velocity

	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 1137 : 
; 1138 : 	wishdir = wishvel;		// determine maginitude of speed of move

	mov	edx, DWORD PTR _wishvel$[ebp]
	mov	DWORD PTR _wishdir$[ebp], edx
	mov	eax, DWORD PTR _wishvel$[ebp+4]
	mov	DWORD PTR _wishdir$[ebp+4], eax
	mov	ecx, DWORD PTR _wishvel$[ebp+8]
	mov	DWORD PTR _wishdir$[ebp+8], ecx

; 1139 : 	wishspeed = wishdir.Length();

	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _wishspeed$[ebp]

; 1140 : 	wishdir = wishdir.Normalize();

	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _wishdir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _wishdir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _wishdir$[ebp+8], eax

; 1141 : 
; 1142 : //
; 1143 : // Clamp to server defined max speed
; 1144 : //
; 1145 : 	if (wishspeed > pmove->maxspeed)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	comiss	xmm0, DWORD PTR [ecx+500]
	jbe	SHORT $LN5@PM_WalkMov

; 1146 : 	{
; 1147 : 		wishvel *= ( pmove->maxspeed / wishspeed );

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+500]
	divss	xmm0, DWORD PTR _wishspeed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _wishvel$[ebp]
	call	??XVector@@QAEAAV0@M@Z			; Vector::operator*=

; 1148 : 		wishspeed = pmove->maxspeed;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+500]
	movss	DWORD PTR _wishspeed$[ebp], xmm0
$LN5@PM_WalkMov:

; 1149 : 	}
; 1150 : 
; 1151 : 	// Set pmove velocity
; 1152 : 	pmove->velocity[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 1153 : 	PM_Accelerate (wishdir, wishspeed, pmove->movevars->accelerate);

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _wishdir$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_Accelerate@@YAXVVector@@MM@Z	; PM_Accelerate
	add	esp, 20					; 00000014H

; 1154 : 	pmove->velocity[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 1155 : 
; 1156 : 	// Add in any base velocity to the current velocity.
; 1157 : 	pmove->velocity += pmove->basevelocity;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1158 : 
; 1159 : 	spd = pmove->velocity.Length();

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _spd$[ebp]

; 1160 : 
; 1161 : 	if( spd < 1.0f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _spd$[ebp]
	jbe	SHORT $LN6@PM_WalkMov

; 1162 : 	{
; 1163 : 		pmove->velocity = g_vecZero;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [eax+8], ecx

; 1164 : 		return;

	jmp	$LN1@PM_WalkMov
$LN6@PM_WalkMov:

; 1165 : 	}
; 1166 : 
; 1167 : 	// If we are not moving, do nothing
; 1168 : 	//if (!pmove->velocity[0] && !pmove->velocity[1] && !pmove->velocity[2])
; 1169 : 	//	return;
; 1170 : 
; 1171 : 	oldonground = pmove->onground;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+224]
	mov	DWORD PTR _oldonground$[ebp], eax

; 1172 : 
; 1173 : 	// first try just moving to the destination	
; 1174 : 	dest[0] = pmove->origin[0] + pmove->velocity[0] * pmove->frametime;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, 4
	imul	edi, ecx, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+16]
	addss	xmm0, DWORD PTR [esi+edi]
	lea	ecx, DWORD PTR _dest$[ebp]
	movss	DWORD PTR tv866[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv866[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1175 : 	dest[1] = pmove->origin[1] + pmove->velocity[1] * pmove->frametime;	

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+16]
	addss	xmm0, DWORD PTR [esi+edi]
	lea	ecx, DWORD PTR _dest$[ebp]
	movss	DWORD PTR tv868[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv868[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1176 : 	dest[2] = pmove->origin[2];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	lea	ecx, DWORD PTR _dest$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR [eax+edx], ecx

; 1177 : 
; 1178 : 	// first try moving directly to the next spot
; 1179 : 	start = dest;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _start$[ebp], edx
	mov	eax, DWORD PTR _dest$[ebp+4]
	mov	DWORD PTR _start$[ebp+4], eax
	mov	ecx, DWORD PTR _dest$[ebp+8]
	mov	DWORD PTR _start$[ebp+8], ecx

; 1180 : 	trace = pmove->PM_PlayerTrace (pmove->origin, dest, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _dest$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324992]
	call	ecx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T6[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T6[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1181 : 	// If we made it all the way, then copy trace end
; 1182 : 	//  as new player position.
; 1183 : 	if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@PM_WalkMov

; 1184 : 	{
; 1185 : 		pmove->origin = trace.endpos;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _trace$[ebp+20]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _trace$[ebp+24]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _trace$[ebp+28]
	mov	DWORD PTR [edx+8], eax

; 1186 : 		return;

	jmp	$LN1@PM_WalkMov
$LN7@PM_WalkMov:

; 1187 : 	}
; 1188 : 
; 1189 : 	// Don't walk up stairs if not on ground.
; 1190 : 	if( oldonground == -1 && ( pmove->waterlevel == 0 || pmove->watertype == CONTENT_FOG ))

	cmp	DWORD PTR _oldonground$[ebp], -1
	jne	SHORT $LN8@PM_WalkMov
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+228], 0
	je	SHORT $LN9@PM_WalkMov
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+232], -19		; ffffffedH
	jne	SHORT $LN8@PM_WalkMov
$LN9@PM_WalkMov:

; 1191 : 		return;

	jmp	$LN1@PM_WalkMov
$LN8@PM_WalkMov:

; 1192 : 
; 1193 : 	if (pmove->waterjumptime)         // If we are jumping out of water, don't do anything more.

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@PM_WalkMov

; 1194 : 		return;

	jmp	$LN1@PM_WalkMov
$LN10@PM_WalkMov:

; 1195 : 
; 1196 : 	// Try sliding forward both on ground and up 16 pixels
; 1197 : 	//  take the move that goes farthest
; 1198 : 	original = pmove->origin;       // Save out original pos &

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _original$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _original$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _original$[ebp+8], ecx

; 1199 : 	originalvel = pmove->velocity;  //  velocity.

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _originalvel$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _originalvel$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _originalvel$[ebp+8], edx

; 1200 : 
; 1201 : 	// Slide move
; 1202 : 	clip = PM_FlyMove ();

	call	?PM_FlyMove@@YAHXZ			; PM_FlyMove
	mov	DWORD PTR _clip$[ebp], eax

; 1203 : 
; 1204 : 	// Copy the results out
; 1205 : 	down = pmove->origin;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _down$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _down$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _down$[ebp+8], eax

; 1206 : 	downvel = pmove->velocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _downvel$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _downvel$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _downvel$[ebp+8], ecx

; 1207 : 
; 1208 : 	// Reset original values.
; 1209 : 	pmove->origin = original;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR _original$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _original$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _original$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 1210 : 	pmove->velocity = originalvel;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR _originalvel$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _originalvel$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _originalvel$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1211 : 
; 1212 : 	// Start out up one stair height
; 1213 : 	dest = pmove->origin;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dest$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp+8], eax

; 1214 : 	dest.z += pmove->movevars->stepsize;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR _dest$[ebp+8]
	addss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR _dest$[ebp+8], xmm0

; 1215 : 	
; 1216 : 	trace = pmove->PM_PlayerTrace (pmove->origin, dest, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _dest$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324992]
	call	edx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T5[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T5[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1217 : 	// If we started okay and made it part of the way at least,
; 1218 : 	//  copy the results to the movement start position and then
; 1219 : 	//  run another move try.
; 1220 : 	if (!trace.startsolid && !trace.allsolid)

	cmp	DWORD PTR _trace$[ebp+4], 0
	jne	SHORT $LN11@PM_WalkMov
	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN11@PM_WalkMov

; 1221 : 	{
; 1222 : 		pmove->origin = trace.endpos;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _trace$[ebp+20]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _trace$[ebp+24]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _trace$[ebp+28]
	mov	DWORD PTR [eax+8], ecx
$LN11@PM_WalkMov:

; 1223 : 	}
; 1224 : 
; 1225 : // slide move the rest of the way.
; 1226 : 	clip = PM_FlyMove ();

	call	?PM_FlyMove@@YAHXZ			; PM_FlyMove
	mov	DWORD PTR _clip$[ebp], eax

; 1227 : 
; 1228 : // Now try going back down from the end point
; 1229 : //  press down the stepheight
; 1230 : 	dest = pmove->origin;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _dest$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _dest$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _dest$[ebp+8], edx

; 1231 : 	dest.z -= pmove->movevars->stepsize;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324848]
	movss	xmm0, DWORD PTR _dest$[ebp+8]
	subss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR _dest$[ebp+8], xmm0

; 1232 : 	
; 1233 : 	trace = pmove->PM_PlayerTrace (pmove->origin, dest, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _dest$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324992]
	call	ecx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T4[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T4[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1234 : 
; 1235 : 	// If we are not on the ground any more then
; 1236 : 	//  use the original movement attempt
; 1237 : 	if ( trace.plane.normal[2] < 0.7)

	lea	ecx, DWORD PTR _trace$[ebp+32]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	movsd	xmm1, QWORD PTR __real@3fe6666666666666
	comisd	xmm1, xmm0
	jbe	SHORT $LN12@PM_WalkMov

; 1238 : 		goto usedown;

	jmp	$LN13@PM_WalkMov
	jmp	$usedown$18
$LN12@PM_WalkMov:

; 1239 : 	// If the trace ended up in empty space, copy the end
; 1240 : 	//  over to the origin.
; 1241 : 	if (!trace.startsolid && !trace.allsolid)

	cmp	DWORD PTR _trace$[ebp+4], 0
	jne	SHORT $LN14@PM_WalkMov
	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN14@PM_WalkMov

; 1242 : 	{
; 1243 : 		pmove->origin = trace.endpos;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _trace$[ebp+20]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _trace$[ebp+24]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _trace$[ebp+28]
	mov	DWORD PTR [eax+8], ecx
$LN14@PM_WalkMov:

; 1244 : 	}
; 1245 : 
; 1246 : 	// Copy this origin to up.
; 1247 : 	pmove->up = pmove->origin;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 56					; 00000038H
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1248 : 
; 1249 : 	// decide which one went farther
; 1250 : 	downdist = (down[0] - original[0]) * (down[0] - original[0]) + (down[1] - original[1]) * (down[1] - original[1]);

	lea	ecx, DWORD PTR _down$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	lea	ecx, DWORD PTR _down$[ebp]
	movss	DWORD PTR tv870[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	xmm1, DWORD PTR tv870[ebp]
	mulss	xmm1, xmm0
	lea	ecx, DWORD PTR _down$[ebp]
	movss	DWORD PTR tv872[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+ecx]
	lea	ecx, DWORD PTR _down$[ebp]
	movss	DWORD PTR tv874[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	xmm1, DWORD PTR tv874[ebp]
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv872[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _downdist$[ebp], xmm0

; 1251 : 	updist = (pmove->up[0] - original[0]) * (pmove->up[0] - original[0]) + (pmove->up[1] - original[1]) * (pmove->up[1] - original[1]);

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 44					; 0000002cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 44					; 0000002cH
	movss	DWORD PTR tv876[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	eax, 4
	imul	edi, eax, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	xmm1, DWORD PTR tv876[ebp]
	mulss	xmm1, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 44					; 0000002cH
	movss	DWORD PTR tv878[ebp], xmm1
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 44					; 0000002cH
	movss	DWORD PTR tv880[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 0
	lea	ecx, DWORD PTR _original$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	xmm1, DWORD PTR tv880[ebp]
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv878[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _updist$[ebp], xmm0

; 1252 : 
; 1253 : 	if( downdist > updist )

	movss	xmm0, DWORD PTR _downdist$[ebp]
	comiss	xmm0, DWORD PTR _updist$[ebp]
	jbe	SHORT $LN15@PM_WalkMov
$LN13@PM_WalkMov:
$usedown$18:

; 1254 : 	{
; 1255 : usedown:
; 1256 : 		pmove->origin = down;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _down$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _down$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _down$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1257 : 		pmove->velocity = downvel;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR _downvel$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _downvel$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _downvel$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 1258 : 	}
; 1259 : 	else

	jmp	SHORT $LN16@PM_WalkMov
$LN15@PM_WalkMov:

; 1260 : 	{
; 1261 : 		// copy z value from slide move
; 1262 : 		pmove->velocity.z = downvel.z;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _downvel$[ebp+8]
	movss	DWORD PTR [ecx+100], xmm0
$LN16@PM_WalkMov:
$LN1@PM_WalkMov:

; 1263 : 	}
; 1264 : 
; 1265 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_WalkMove@@YAXXZ ENDP				; PM_WalkMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_currentspeed$ = -20					; size = 4
tv92 = -16						; size = 4
_accelspeed$ = -12					; size = 4
_addspeed$ = -8						; size = 4
_i$ = -4						; size = 4
_wishdir$ = 8						; size = 12
_wishspeed$ = 20					; size = 4
_accel$ = 24						; size = 4
?PM_Accelerate@@YAXVVector@@MM@Z PROC			; PM_Accelerate

; 1060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1061 : 	int			i;
; 1062 : 	float		addspeed, accelspeed, currentspeed;
; 1063 : 
; 1064 : 	// Dead player's don't accelerate
; 1065 : 	if (pmove->dead)

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+208], 0
	je	SHORT $LN5@PM_Acceler

; 1066 : 		return;

	jmp	$LN1@PM_Acceler
$LN5@PM_Acceler:

; 1067 : 
; 1068 : 	// If waterjumping, don't accelerate
; 1069 : 	if (pmove->waterjumptime)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@PM_Acceler

; 1070 : 		return;

	jmp	$LN1@PM_Acceler
$LN6@PM_Acceler:

; 1071 : 
; 1072 : 	// See if we are changing direction a bit
; 1073 : 	currentspeed = DotProduct (pmove->velocity, wishdir);

	lea	edx, DWORD PTR _wishdir$[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _currentspeed$[ebp]

; 1074 : 
; 1075 : 	// Reduce wishspeed by the amount of veer.
; 1076 : 	addspeed = wishspeed - currentspeed;

	movss	xmm0, DWORD PTR _wishspeed$[ebp]
	subss	xmm0, DWORD PTR _currentspeed$[ebp]
	movss	DWORD PTR _addspeed$[ebp], xmm0

; 1077 : 
; 1078 : 	// If not going to add any speed, done.
; 1079 : 	if (addspeed <= 0)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jb	SHORT $LN7@PM_Acceler

; 1080 : 		return;

	jmp	$LN1@PM_Acceler
$LN7@PM_Acceler:

; 1081 : 
; 1082 : 	// Determine amount of accleration.
; 1083 : 	accelspeed = accel * pmove->frametime * wishspeed * pmove->friction;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR _accel$[ebp]
	mulss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR _wishspeed$[ebp]
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [edx+196]
	movss	DWORD PTR _accelspeed$[ebp], xmm0

; 1084 : 	
; 1085 : 	// Cap at addspeed
; 1086 : 	if (accelspeed > addspeed)

	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	comiss	xmm0, DWORD PTR _addspeed$[ebp]
	jbe	SHORT $LN8@PM_Acceler

; 1087 : 		accelspeed = addspeed;

	movss	xmm0, DWORD PTR _addspeed$[ebp]
	movss	DWORD PTR _accelspeed$[ebp], xmm0
$LN8@PM_Acceler:

; 1088 : 	
; 1089 : 	// Adjust velocity.
; 1090 : 	for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_Acceler
$LN2@PM_Acceler:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_Acceler:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@PM_Acceler

; 1091 : 	{
; 1092 : 		pmove->velocity[i] += accelspeed * wishdir[i];	

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv92[ebp], edx
	lea	ecx, DWORD PTR _wishdir$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _accelspeed$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR tv92[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR tv92[ebp]
	movss	DWORD PTR [eax], xmm0

; 1093 : 	}

	jmp	SHORT $LN2@PM_Acceler
$LN3@PM_Acceler:
$LN1@PM_Acceler:

; 1094 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_Accelerate@@YAXVVector@@MM@Z ENDP			; PM_Accelerate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -400						; size = 68
$T2 = -332						; size = 68
$T3 = -264						; size = 12
$T4 = -252						; size = 12
_trace$ = -240						; size = 68
_end$ = -172						; size = 12
_dir$ = -160						; size = 12
tv595 = -148						; size = 4
_d$ = -144						; size = 4
tv546 = -140						; size = 4
tv620 = -136						; size = 4
_numbumps$ = -132					; size = 4
_primal_velocity$ = -128				; size = 12
_new_velocity$ = -116					; size = 12
_allFraction$ = -104					; size = 4
_bumpcount$5 = -100					; size = 4
_time_left$ = -96					; size = 4
_blocked$ = -92						; size = 4
_original_velocity$ = -88				; size = 12
_j$ = -76						; size = 4
_numplanes$ = -72					; size = 4
_i$ = -68						; size = 4
_planes$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
?PM_FlyMove@@YAHXZ PROC					; PM_FlyMove

; 869  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 870  : 	int		numbumps;
; 871  : 	Vector		dir;

	lea	ecx, DWORD PTR _dir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 872  : 	float		d;
; 873  : 	int			numplanes;
; 874  : 	Vector		planes[MAX_CLIP_PLANES];

	push	OFFSET ??0Vector@@QAE@XZ		; Vector::Vector
	push	5
	push	12					; 0000000cH
	lea	eax, DWORD PTR _planes$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 875  : 	Vector		primal_velocity, original_velocity;

	lea	ecx, DWORD PTR _primal_velocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _original_velocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 876  : 	Vector      new_velocity;

	lea	ecx, DWORD PTR _new_velocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 877  : 	int			i, j;
; 878  : 	pmtrace_t	trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0pmtrace_s@@QAE@XZ

; 879  : 	Vector		end;

	lea	ecx, DWORD PTR _end$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 880  : 	float		time_left, allFraction;
; 881  : 	int			blocked;
; 882  : 		
; 883  : 	numbumps  = 4;           // Bump up to four times

	mov	DWORD PTR _numbumps$[ebp], 4

; 884  : 	
; 885  : 	blocked   = 0;           // Assume not blocked

	mov	DWORD PTR _blocked$[ebp], 0

; 886  : 	numplanes = 0;           //  and not sliding along any planes

	mov	DWORD PTR _numplanes$[ebp], 0

; 887  : 	original_velocity = primal_velocity = pmove->velocity;  // Store original velocity

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _primal_velocity$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _primal_velocity$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _primal_velocity$[ebp+8], ecx
	mov	edx, DWORD PTR _primal_velocity$[ebp]
	mov	DWORD PTR _original_velocity$[ebp], edx
	mov	eax, DWORD PTR _primal_velocity$[ebp+4]
	mov	DWORD PTR _original_velocity$[ebp+4], eax
	mov	ecx, DWORD PTR _primal_velocity$[ebp+8]
	mov	DWORD PTR _original_velocity$[ebp+8], ecx

; 888  : 	
; 889  : 	allFraction = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _allFraction$[ebp], xmm0

; 890  : 	time_left = pmove->frametime;   // Total time for this movement operation.

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR _time_left$[ebp], xmm0

; 891  : 
; 892  : 	for( int bumpcount = 0; bumpcount < numbumps; bumpcount++ )

	mov	DWORD PTR _bumpcount$5[ebp], 0
	jmp	SHORT $LN4@PM_FlyMove
$LN2@PM_FlyMove:
	mov	eax, DWORD PTR _bumpcount$5[ebp]
	add	eax, 1
	mov	DWORD PTR _bumpcount$5[ebp], eax
$LN4@PM_FlyMove:
	mov	ecx, DWORD PTR _bumpcount$5[ebp]
	cmp	ecx, DWORD PTR _numbumps$[ebp]
	jge	$LN3@PM_FlyMove

; 893  : 	{
; 894  : 		if( pmove->velocity == g_vecZero )

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $LN17@PM_FlyMove

; 895  : 			break;

	jmp	$LN3@PM_FlyMove
$LN17@PM_FlyMove:

; 896  : 
; 897  : 		// Assume we can move all the way from the current origin to the
; 898  : 		//  end point.
; 899  : 		for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@PM_FlyMove
$LN5@PM_FlyMove:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@PM_FlyMove:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@PM_FlyMove

; 900  : 			end[i] = pmove->origin[i] + time_left * pmove->velocity[i];

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _time_left$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR [esi+edx*4]
	lea	ecx, DWORD PTR _end$[ebp]
	movss	DWORD PTR tv620[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv620[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
	jmp	SHORT $LN5@PM_FlyMove
$LN6@PM_FlyMove:

; 901  : 
; 902  : 		// See if we can make it from origin to end point.
; 903  : 		trace = pmove->PM_PlayerTrace (pmove->origin, end, PM_NORMAL, -1 );

	push	-1
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324992]
	call	ecx
	add	esp, 20					; 00000014H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR $T2[ebp]
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 904  : 
; 905  : 		allFraction += trace.fraction;

	movss	xmm0, DWORD PTR _allFraction$[ebp]
	addss	xmm0, DWORD PTR _trace$[ebp+16]
	movss	DWORD PTR _allFraction$[ebp], xmm0

; 906  : 
; 907  : 		// If we started in a solid object, or we were in solid space
; 908  : 		//  the whole way, zero out our velocity and return that we
; 909  : 		//  are blocked by floor and wall.
; 910  : 		if( trace.allsolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN18@PM_FlyMove

; 911  : 		{	
; 912  : 			// entity is trapped in another solid
; 913  : 			pmove->velocity = g_vecZero;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 914  : 			pmove->flags |= FL_STUCKED;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	or	edx, 134217728				; 08000000H
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+184], edx

; 915  : 			return 4;

	mov	eax, 4
	jmp	$LN1@PM_FlyMove
$LN18@PM_FlyMove:

; 916  : 		}
; 917  : 
; 918  : 		// If we moved some portion of the total distance, then
; 919  : 		//  copy the end position into the pmove->origin and 
; 920  : 		//  zero the plane counter.
; 921  : 		if( trace.fraction > 0 )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@PM_FlyMove

; 922  : 		{	
; 923  : 			// actually covered some distance
; 924  : 			pmove->origin = trace.endpos;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _trace$[ebp+20]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _trace$[ebp+24]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _trace$[ebp+28]
	mov	DWORD PTR [ecx+8], edx

; 925  : 			original_velocity = pmove->velocity;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _original_velocity$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _original_velocity$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _original_velocity$[ebp+8], eax

; 926  : 			numplanes = 0;

	mov	DWORD PTR _numplanes$[ebp], 0
$LN19@PM_FlyMove:

; 927  : 		}
; 928  : 
; 929  : 		// If we covered the entire distance, we are done
; 930  : 		//  and can return.
; 931  : 		if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@PM_FlyMove

; 932  : 			 break; // moved the entire distance

	jmp	$LN3@PM_FlyMove
$LN20@PM_FlyMove:

; 933  : 
; 934  : 		//if (!trace.ent)
; 935  : 		//	Sys_Error ("PM_PlayerTrace: !trace.ent");
; 936  : 
; 937  : 		// Save entity that blocked us (since fraction was < 1.0)
; 938  : 		//  for contact
; 939  : 		// Add it if it's not already in the list!!!
; 940  : 		PM_AddToTouched( trace, pmove->velocity );

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 68					; 00000044H
	mov	ecx, esp
	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	??0pmtrace_s@@QAE@ABU0@@Z
	call	?PM_AddToTouched@@YAHUpmtrace_s@@VVector@@@Z ; PM_AddToTouched
	add	esp, 80					; 00000050H

; 941  : 
; 942  : 		// If the plane we hit has a high z component in the normal, then
; 943  : 		//  it's probably a floor
; 944  : 		if( trace.plane.normal[2] > 0.7f )

	lea	ecx, DWORD PTR _trace$[ebp+32]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	comiss	xmm0, DWORD PTR __real@3f333333
	jbe	SHORT $LN21@PM_FlyMove

; 945  : 		{
; 946  : 			blocked |= 1;		// floor

	mov	edx, DWORD PTR _blocked$[ebp]
	or	edx, 1
	mov	DWORD PTR _blocked$[ebp], edx
$LN21@PM_FlyMove:

; 947  : 		}
; 948  : 		// If the plane has a zero z component in the normal, then it's a 
; 949  : 		//  step or wall
; 950  : 		if( !trace.plane.normal.z )

	movss	xmm0, DWORD PTR _trace$[ebp+40]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@PM_FlyMove

; 951  : 		{
; 952  : 			blocked |= 2; // step / wall

	mov	eax, DWORD PTR _blocked$[ebp]
	or	eax, 2
	mov	DWORD PTR _blocked$[ebp], eax
$LN22@PM_FlyMove:

; 953  : 			//Con_DPrintf("Blocked by %i\n", trace.ent);
; 954  : 		}
; 955  : 
; 956  : 		// Reduce amount of pmove->frametime left by total time left * fraction
; 957  : 		//  that we covered.
; 958  : 		time_left -= time_left * trace.fraction;

	movss	xmm0, DWORD PTR _time_left$[ebp]
	mulss	xmm0, DWORD PTR _trace$[ebp+16]
	movss	xmm1, DWORD PTR _time_left$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _time_left$[ebp], xmm1

; 959  : 		
; 960  : 		// Did we run out of planes to clip against?
; 961  : 		if( numplanes >= MAX_CLIP_PLANES )

	cmp	DWORD PTR _numplanes$[ebp], 5
	jl	SHORT $LN23@PM_FlyMove

; 962  : 		{	
; 963  : 			// this shouldn't really happen
; 964  : 			// Stop our movement if so.
; 965  : 			pmove->velocity = g_vecZero;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx

; 966  : //			pmove->Con_Printf( "Too many planes 4\n" );
; 967  : 			break;

	jmp	$LN3@PM_FlyMove
$LN23@PM_FlyMove:

; 968  : 		}
; 969  : 
; 970  : 		// Set up next clipping plane
; 971  : 		planes[numplanes] = trace.plane.normal;

	imul	eax, DWORD PTR _numplanes$[ebp], 12
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, DWORD PTR _trace$[ebp+32]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _trace$[ebp+36]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _trace$[ebp+40]
	mov	DWORD PTR [ecx+8], edx

; 972  : 		numplanes++;

	mov	eax, DWORD PTR _numplanes$[ebp]
	add	eax, 1
	mov	DWORD PTR _numplanes$[ebp], eax

; 973  : //
; 974  : 
; 975  : // modify original_velocity so it parallels all of the clip planes
; 976  : //
; 977  : 		if ( pmove->movetype == MOVETYPE_WALK && ((pmove->onground == -1) || (pmove->friction != 1)) )	// relfect player velocity

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+220], 3
	jne	$LN24@PM_FlyMove
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+224], -1
	je	SHORT $LN26@PM_FlyMove
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+196]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN24@PM_FlyMove
$LN26@PM_FlyMove:

; 978  : 		{
; 979  : 			for( i = 0; i < numplanes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@PM_FlyMove
$LN8@PM_FlyMove:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@PM_FlyMove:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numplanes$[ebp]
	jge	$LN9@PM_FlyMove

; 980  : 			{
; 981  : 				if ( planes[i][2] > 0.7  )

	imul	eax, DWORD PTR _i$[ebp], 12
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	comisd	xmm0, QWORD PTR __real@3fe6666666666666
	jbe	SHORT $LN27@PM_FlyMove

; 982  : 				{// floor or slope
; 983  : 					PM_ClipVelocity( original_velocity, planes[i], new_velocity, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _new_velocity$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	imul	eax, DWORD PTR _i$[ebp], 12
	lea	edx, DWORD PTR _planes$[ebp+eax]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _original_velocity$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z	; PM_ClipVelocity
	add	esp, 32					; 00000020H

; 984  : 					original_velocity = new_velocity;

	mov	ecx, DWORD PTR _new_velocity$[ebp]
	mov	DWORD PTR _original_velocity$[ebp], ecx
	mov	edx, DWORD PTR _new_velocity$[ebp+4]
	mov	DWORD PTR _original_velocity$[ebp+4], edx
	mov	eax, DWORD PTR _new_velocity$[ebp+8]
	mov	DWORD PTR _original_velocity$[ebp+8], eax

; 985  : 				}
; 986  : 				else															

	jmp	SHORT $LN28@PM_FlyMove
$LN27@PM_FlyMove:

; 987  : 					PM_ClipVelocity( original_velocity, planes[i], new_velocity, 1.0 + pmove->movevars->bounce * (1-pmove->friction) );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [eax+196]
	mulss	xmm0, DWORD PTR [edx+44]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _new_velocity$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	imul	edx, DWORD PTR _i$[ebp], 12
	lea	eax, DWORD PTR _planes$[ebp+edx]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _original_velocity$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z	; PM_ClipVelocity
	add	esp, 32					; 00000020H
$LN28@PM_FlyMove:

; 988  : 			}

	jmp	$LN8@PM_FlyMove
$LN9@PM_FlyMove:

; 989  : 
; 990  : 			pmove->velocity = original_velocity = new_velocity;

	mov	eax, DWORD PTR _new_velocity$[ebp]
	mov	DWORD PTR _original_velocity$[ebp], eax
	mov	ecx, DWORD PTR _new_velocity$[ebp+4]
	mov	DWORD PTR _original_velocity$[ebp+4], ecx
	mov	edx, DWORD PTR _new_velocity$[ebp+8]
	mov	DWORD PTR _original_velocity$[ebp+8], edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _original_velocity$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _original_velocity$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _original_velocity$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 991  : 		}
; 992  : 		else

	jmp	$LN35@PM_FlyMove
$LN24@PM_FlyMove:

; 993  : 		{
; 994  : 			for (i=0 ; i<numplanes ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@PM_FlyMove
$LN11@PM_FlyMove:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@PM_FlyMove:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jge	$LN12@PM_FlyMove

; 995  : 			{
; 996  : 				PM_ClipVelocity (

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	imul	edx, DWORD PTR _i$[ebp], 12
	lea	eax, DWORD PTR _planes$[ebp+edx]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _original_velocity$[ebp]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z	; PM_ClipVelocity
	add	esp, 32					; 00000020H

; 997  : 					original_velocity,
; 998  : 					planes[i],
; 999  : 					pmove->velocity,
; 1000 : 					1);
; 1001 : 				for (j=0 ; j<numplanes ; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@PM_FlyMove
$LN14@PM_FlyMove:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@PM_FlyMove:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _numplanes$[ebp]
	jge	SHORT $LN15@PM_FlyMove

; 1002 : 					if (j != i)

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _i$[ebp]
	je	SHORT $LN30@PM_FlyMove

; 1003 : 					{
; 1004 : 						// Are we now moving against this plane?
; 1005 : 						if (DotProduct (pmove->velocity, planes[j]) < 0)

	imul	eax, DWORD PTR _j$[ebp], 12
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR tv546[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR tv546[ebp]
	jbe	SHORT $LN30@PM_FlyMove

; 1006 : 							break;	// not ok

	jmp	SHORT $LN15@PM_FlyMove
$LN30@PM_FlyMove:

; 1007 : 					}

	jmp	SHORT $LN14@PM_FlyMove
$LN15@PM_FlyMove:

; 1008 : 				if (j == numplanes)  // Didn't have to clip, so we're ok

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jne	SHORT $LN31@PM_FlyMove

; 1009 : 					break;

	jmp	SHORT $LN12@PM_FlyMove
$LN31@PM_FlyMove:

; 1010 : 			}

	jmp	$LN11@PM_FlyMove
$LN12@PM_FlyMove:

; 1011 : 			
; 1012 : 			// Did we go all the way through plane set
; 1013 : 			if( i != numplanes )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numplanes$[ebp]
	je	SHORT $LN32@PM_FlyMove

; 1014 : 			{	
; 1015 : 				// go along this plane
; 1016 : 				// pmove->velocity is set in clipping call, no need to set again.
; 1017 : 				;  
; 1018 : 			}
; 1019 : 			else

	jmp	$LN33@PM_FlyMove
$LN32@PM_FlyMove:

; 1020 : 			{	// go along the crease
; 1021 : 				if( numplanes != 2 )

	cmp	DWORD PTR _numplanes$[ebp], 2
	je	SHORT $LN34@PM_FlyMove

; 1022 : 				{
; 1023 : 					//Con_Printf ("clip velocity, numplanes == %i\n",numplanes);
; 1024 : 					pmove->velocity = g_vecZero;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 1025 : 					//Con_DPrintf("Trapped 4\n");
; 1026 : 
; 1027 : 					break;

	jmp	$LN3@PM_FlyMove
$LN34@PM_FlyMove:

; 1028 : 				}
; 1029 : 				dir = CrossProduct (planes[0], planes[1]);

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	push	edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dir$[ebp+8], eax

; 1030 : 				d = DotProduct (dir, pmove->velocity);

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	push	ecx
	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _d$[ebp]

; 1031 : 				pmove->velocity = dir * d;

	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN33@PM_FlyMove:

; 1032 : 			}
; 1033 : 
; 1034 : 			// if original velocity is against the original velocity, stop dead
; 1035 : 			// to avoid tiny occilations in sloping corners
; 1036 : 			if( DotProduct( pmove->velocity, primal_velocity ) <= 0.0f )

	lea	ecx, DWORD PTR _primal_velocity$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR tv595[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR tv595[ebp]
	jb	SHORT $LN35@PM_FlyMove

; 1037 : 			{
; 1038 : 				//Con_DPrintf("Back\n");
; 1039 : 				pmove->velocity = g_vecZero;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [eax+8], ecx

; 1040 : 				break;

	jmp	SHORT $LN3@PM_FlyMove
$LN35@PM_FlyMove:

; 1041 : 			}
; 1042 : 		}
; 1043 : 	}

	jmp	$LN2@PM_FlyMove
$LN3@PM_FlyMove:

; 1044 : 
; 1045 : 	if( allFraction == 0.0f )

	movss	xmm0, DWORD PTR _allFraction$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@PM_FlyMove

; 1046 : 	{
; 1047 : 		pmove->velocity = g_vecZero;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax
$LN36@PM_FlyMove:

; 1048 : //		pmove->Con_Printf( "Don't stick\n" );
; 1049 : 	}
; 1050 : 
; 1051 : 	return blocked;

	mov	eax, DWORD PTR _blocked$[ebp]
$LN1@PM_FlyMove:

; 1052 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_FlyMove@@YAHXZ ENDP					; PM_FlyMove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv81 = -8						; size = 4
_ent_gravity$ = -4					; size = 4
?PM_FixupGravityVelocity@@YAXXZ PROC			; PM_FixupGravityVelocity

; 844  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 845  : 	float	ent_gravity;
; 846  : 
; 847  : 	if ( pmove->waterjumptime )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PM_FixupGr

; 848  : 		return;

	jmp	$LN1@PM_FixupGr
$LN2@PM_FixupGr:

; 849  : 
; 850  : 	if (pmove->gravity)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+192]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@PM_FixupGr

; 851  : 		ent_gravity = pmove->gravity;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+192]
	movss	DWORD PTR _ent_gravity$[ebp], xmm0

; 852  : 	else

	jmp	SHORT $LN4@PM_FixupGr
$LN3@PM_FixupGr:

; 853  : 		ent_gravity = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
$LN4@PM_FixupGr:

; 854  : 
; 855  : 	// Get the correct velocity for the end of the dt 
; 856  :   	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * pmove->frametime * 0.5 );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv81[ebp], eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR _ent_gravity$[ebp]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mulss	xmm0, DWORD PTR [ecx+16]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR tv81[ebp]
	cvtss2sd xmm1, DWORD PTR [edx]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	eax, DWORD PTR tv81[ebp]
	movss	DWORD PTR [eax], xmm0

; 857  : 
; 858  : 	PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity
$LN1@PM_FixupGr:

; 859  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_FixupGravityVelocity@@YAXXZ ENDP			; PM_FixupGravityVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv130 = -12						; size = 4
tv82 = -8						; size = 4
_ent_gravity$ = -4					; size = 4
?PM_AddCorrectGravity@@YAXXZ PROC			; PM_AddCorrectGravity

; 822  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 823  : 	float	ent_gravity;
; 824  : 
; 825  : 	if ( pmove->waterjumptime )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@PM_AddCorr

; 826  : 		return;

	jmp	$LN1@PM_AddCorr
$LN2@PM_AddCorr:

; 827  : 
; 828  : 	if (pmove->gravity)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [ecx+192]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@PM_AddCorr

; 829  : 		ent_gravity = pmove->gravity;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [edx+192]
	movss	DWORD PTR _ent_gravity$[ebp], xmm0

; 830  : 	else

	jmp	SHORT $LN4@PM_AddCorr
$LN3@PM_AddCorr:

; 831  : 		ent_gravity = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
$LN4@PM_AddCorr:

; 832  : 
; 833  : 	// Add gravity so they'll be in the correct position during movement
; 834  : 	// yes, this 0.5 looks wrong, but it's not.  
; 835  : 	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * 0.5 * pmove->frametime );

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv82[ebp], eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR _ent_gravity$[ebp]
	mulss	xmm0, DWORD PTR [eax]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtss2sd xmm1, DWORD PTR [ecx+16]
	mulsd	xmm0, xmm1
	mov	edx, DWORD PTR tv82[ebp]
	cvtss2sd xmm1, DWORD PTR [edx]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	mov	eax, DWORD PTR tv82[ebp]
	movss	DWORD PTR [eax], xmm0

; 836  : 	pmove->velocity[2] += pmove->basevelocity[2] * pmove->frametime;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR tv130[ebp]
	addss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR tv130[ebp]
	movss	DWORD PTR [eax], xmm0

; 837  : 	pmove->basevelocity[2] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 116				; 00000074H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 838  : 
; 839  : 	PM_CheckVelocity();

	call	?PM_CheckVelocity@@YAXXZ		; PM_CheckVelocity
$LN1@PM_AddCorr:

; 840  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_AddCorrectGravity@@YAXXZ ENDP			; PM_AddCorrectGravity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv173 = -28						; size = 4
_change$ = -24						; size = 4
_backoff$ = -20						; size = 4
tv152 = -16						; size = 4
_angle$ = -12						; size = 4
_blocked$ = -8						; size = 4
_i$ = -4						; size = 4
_in$ = 8						; size = 12
_normal$ = 20						; size = 12
_out$ = 32						; size = 4
_overbounce$ = 36					; size = 4
?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z PROC		; PM_ClipVelocity

; 790  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 791  : 	float	backoff;
; 792  : 	float	change;
; 793  : 	float angle;
; 794  : 	int		i, blocked;
; 795  : 	
; 796  : 	angle = normal[ 2 ];

	lea	ecx, DWORD PTR _normal$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _angle$[ebp], xmm0

; 797  : 
; 798  : 	blocked = 0x00;            // Assume unblocked.

	mov	DWORD PTR _blocked$[ebp], 0

; 799  : 	if (angle > 0)      // If the plane that is blocking us has a positive z component, then assume it's a floor.

	movss	xmm0, DWORD PTR _angle$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@PM_ClipVel

; 800  : 		blocked |= 0x01;		// 

	mov	edx, DWORD PTR _blocked$[ebp]
	or	edx, 1
	mov	DWORD PTR _blocked$[ebp], edx
$LN5@PM_ClipVel:

; 801  : 	if (!angle)         // If the plane has no Z, it is vertical (wall/step)

	movss	xmm0, DWORD PTR _angle$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@PM_ClipVel

; 802  : 		blocked |= 0x02;		// 

	mov	eax, DWORD PTR _blocked$[ebp]
	or	eax, 2
	mov	DWORD PTR _blocked$[ebp], eax
$LN6@PM_ClipVel:

; 803  : 	
; 804  : 	// Determine how far along plane to slide based on incoming direction.
; 805  : 	// Scale by overbounce factor.
; 806  : 	backoff = DotProduct (in, normal) * overbounce;

	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	lea	edx, DWORD PTR _in$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR tv152[ebp]
	movss	xmm0, DWORD PTR tv152[ebp]
	mulss	xmm0, DWORD PTR _overbounce$[ebp]
	movss	DWORD PTR _backoff$[ebp], xmm0

; 807  : 
; 808  : 	for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_ClipVel
$LN2@PM_ClipVel:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_ClipVel:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@PM_ClipVel

; 809  : 	{
; 810  : 		change = normal[i]*backoff;

	lea	ecx, DWORD PTR _normal$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR _backoff$[ebp]
	movss	DWORD PTR _change$[ebp], xmm0

; 811  : 		out[i] = in[i] - change;

	lea	ecx, DWORD PTR _in$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	subss	xmm0, DWORD PTR _change$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR tv173[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0

; 812  : 		// If out velocity is too small, zero it out.
; 813  : 		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)

	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jbe	SHORT $LN7@PM_ClipVel
	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN7@PM_ClipVel

; 814  : 			out[i] = 0;

	mov	ecx, DWORD PTR _out$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx*4], xmm0
$LN7@PM_ClipVel:

; 815  : 	}

	jmp	$LN2@PM_ClipVel
$LN3@PM_ClipVel:

; 816  : 	
; 817  : 	// Return blocking flags.
; 818  : 	return blocked;

	mov	eax, DWORD PTR _blocked$[ebp]

; 819  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_ClipVelocity@@YAHVVector@@0AAV1@M@Z ENDP		; PM_ClipVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv219 = -8						; size = 4
_i$ = -4						; size = 4
?PM_CheckVelocity@@YAXXZ PROC				; PM_CheckVelocity

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 746  : 	int		i;
; 747  : 
; 748  : //
; 749  : // bound velocity
; 750  : //
; 751  : 	for (i=0 ; i<3 ; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_CheckVe
$LN2@PM_CheckVe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_CheckVe:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@PM_CheckVe

; 752  : 	{
; 753  : 		// See if it's bogus.
; 754  : 		if (IS_NAN(pmove->velocity[i]))

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	and	edx, 2139095040				; 7f800000H
	cmp	edx, 2139095040				; 7f800000H
	jne	SHORT $LN5@PM_CheckVe

; 755  : 		{
; 756  : 			pmove->Con_Printf ("PM  Got a NaN velocity %i\n", i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG15288
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324968]
	call	edx
	add	esp, 8

; 757  : 			pmove->velocity[i] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx*4], xmm0
$LN5@PM_CheckVe:

; 758  : 		}
; 759  : 		if (IS_NAN(pmove->origin[i]))

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	and	eax, 2139095040				; 7f800000H
	cmp	eax, 2139095040				; 7f800000H
	jne	SHORT $LN6@PM_CheckVe

; 760  : 		{
; 761  : 			pmove->Con_Printf ("PM  Got a NaN origin on %i\n", i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET $SG15290
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324968]
	call	eax
	add	esp, 8

; 762  : 			pmove->origin[i] = 0;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx*4], xmm0
$LN6@PM_CheckVe:

; 763  : 		}
; 764  : 
; 765  : 		// Bound it.
; 766  : 		if (pmove->velocity[i] > pmove->movevars->maxvelocity) 

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [edx+324848]
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	comiss	xmm0, DWORD PTR [ecx+52]
	jbe	SHORT $LN7@PM_CheckVe

; 767  : 		{
; 768  : 			pmove->Con_DPrintf ("PM  Got a velocity too high on %i\n", i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG15293
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324964]
	call	edx
	add	esp, 8

; 769  : 			pmove->velocity[i] = pmove->movevars->maxvelocity;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	esi, DWORD PTR [eax+324848]
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4], edx
	jmp	$LN9@PM_CheckVe
$LN7@PM_CheckVe:

; 770  : 		}
; 771  : 		else if (pmove->velocity[i] < -pmove->movevars->maxvelocity)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324848]
	movss	xmm0, DWORD PTR [edx+52]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _i$[ebp]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN9@PM_CheckVe

; 772  : 		{
; 773  : 			pmove->Con_DPrintf ("PM  Got a velocity too low on %i\n", i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG15295
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324964]
	call	ecx
	add	esp, 8

; 774  : 			pmove->velocity[i] = -pmove->movevars->maxvelocity;

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	movss	xmm0, DWORD PTR [eax+52]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	movss	DWORD PTR tv219[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
$LN9@PM_CheckVe:

; 775  : 		}
; 776  : 	}

	jmp	$LN2@PM_CheckVe
$LN3@PM_CheckVe:

; 777  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CheckVelocity@@YAXXZ ENDP				; PM_CheckVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_pe$1 = -8						; size = 4
_i$ = -4						; size = 4
_tr$ = 8						; size = 68
_impactvelocity$ = 76					; size = 12
?PM_AddToTouched@@YAHUpmtrace_s@@VVector@@@Z PROC	; PM_AddToTouched

; 707  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi

; 708  : 	int i;
; 709  : 
; 710  : 	for (i = 0; i < pmove->numtouch; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_AddToTo
$LN2@PM_AddToTo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_AddToTo:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+283788]
	jge	SHORT $LN3@PM_AddToTo

; 711  : 	{
; 712  : 		if (pmove->touchindex[i].ent == tr.ent)

	imul	eax, DWORD PTR _i$[ebp], 68
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+eax+283840]
	cmp	edx, DWORD PTR _tr$[ebp+48]
	jne	SHORT $LN5@PM_AddToTo

; 713  : 			break;

	jmp	SHORT $LN3@PM_AddToTo
$LN5@PM_AddToTo:

; 714  : 	}

	jmp	SHORT $LN2@PM_AddToTo
$LN3@PM_AddToTo:

; 715  : 	if (i != pmove->numtouch)  // Already in list.

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+283788]
	je	SHORT $LN6@PM_AddToTo

; 716  : 		return false;

	xor	eax, eax
	jmp	$LN1@PM_AddToTo
$LN6@PM_AddToTo:

; 717  : 
; 718  : 	if( pmove->onground != -1 && tr.ent == pmove->onground )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+224], -1
	je	SHORT $LN7@PM_AddToTo
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR _tr$[ebp+48]
	cmp	ecx, DWORD PTR [eax+224]
	jne	SHORT $LN7@PM_AddToTo

; 719  : 	{
; 720  : 		physent_t *pe = &pmove->physents[pmove->onground];

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	eax, DWORD PTR [edx+224], 224
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$1[ebp], edx

; 721  : 
; 722  : 		// we're standing on pushable. Clear impulse
; 723  : 		if( pe->movetype == MOVETYPE_PUSHSTEP )

	mov	eax, DWORD PTR _pe$1[ebp]
	cmp	DWORD PTR [eax+124], 13			; 0000000dH
	jne	SHORT $LN7@PM_AddToTo

; 724  : 			impactvelocity = g_vecZero;

	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR _impactvelocity$[ebp], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR _impactvelocity$[ebp+4], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR _impactvelocity$[ebp+8], eax
$LN7@PM_AddToTo:

; 725  : 	}
; 726  : 
; 727  : 	tr.deltavelocity = impactvelocity;

	mov	ecx, DWORD PTR _impactvelocity$[ebp]
	mov	DWORD PTR _tr$[ebp+52], ecx
	mov	edx, DWORD PTR _impactvelocity$[ebp+4]
	mov	DWORD PTR _tr$[ebp+56], edx
	mov	eax, DWORD PTR _impactvelocity$[ebp+8]
	mov	DWORD PTR _tr$[ebp+60], eax

; 728  : 
; 729  : 	if (pmove->numtouch >= MAX_PHYSENTS)

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+283788], 600		; 00000258H
	jl	SHORT $LN9@PM_AddToTo

; 730  : 		pmove->Con_DPrintf("Too many entities were touched!\n");

	push	OFFSET $SG15278
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324964]
	call	eax
	add	esp, 4
$LN9@PM_AddToTo:

; 731  : 
; 732  : 	pmove->touchindex[pmove->numtouch++] = tr;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	edx, DWORD PTR [ecx+283788], 68
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	edi, DWORD PTR [eax+edx+283792]
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _tr$[ebp]
	rep movsd
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+283788]
	add	edx, 1
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+283788], edx

; 733  : 
; 734  : 	return true;

	mov	eax, 1
$LN1@PM_AddToTo:

; 735  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_AddToTouched@@YAHUpmtrace_s@@VVector@@@Z ENDP	; PM_AddToTouched
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv290 = -196						; size = 8
_center$ = -188						; size = 12
tv240 = -176						; size = 8
tv234 = -168						; size = 8
tv228 = -160						; size = 8
tv222 = -152						; size = 8
tv216 = -144						; size = 8
tv210 = -136						; size = 8
tv204 = -128						; size = 8
tv192 = -120						; size = 8
tv399 = -112						; size = 4
tv397 = -108						; size = 4
_feet$ = -104						; size = 12
_knee$ = -92						; size = 12
_flduck$ = -80						; size = 4
tv244 = -76						; size = 4
tv238 = -72						; size = 4
tv232 = -68						; size = 4
tv226 = -64						; size = 4
tv220 = -60						; size = 4
tv214 = -56						; size = 4
tv208 = -52						; size = 4
tv196 = -48						; size = 4
_height$ = -44						; size = 4
tv94 = -40						; size = 4
_speed$ = -36						; size = 4
_velrun$ = -32						; size = 4
_velwalk$ = -28						; size = 4
tv77 = -24						; size = 4
_fLadder$ = -20						; size = 4
_step$ = -16						; size = 4
tv202 = -12						; size = 4
_fvol$ = -8						; size = 4
_fWalking$ = -4						; size = 4
?PM_UpdateStepSound@@YAXXZ PROC				; PM_UpdateStepSound

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	esi
	push	edi

; 565  : 	int	fWalking;
; 566  : 	float fvol;
; 567  : 	Vector knee;

	lea	ecx, DWORD PTR _knee$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 568  : 	Vector feet;

	lea	ecx, DWORD PTR _feet$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 569  : 	Vector center;

	lea	ecx, DWORD PTR _center$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 570  : 	float height;
; 571  : 	float speed;
; 572  : 	float velrun;
; 573  : 	float velwalk;
; 574  : 	float flduck;
; 575  : 	int	fLadder;
; 576  : 	int step;
; 577  : 
; 578  : 	if ( pmove->flTimeStepSound > 0 )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+148], 0
	jle	SHORT $LN4@PM_UpdateS

; 579  : 		return;

	jmp	$LN1@PM_UpdateS
$LN4@PM_UpdateS:

; 580  : 
; 581  : 	if ( pmove->flags & FL_FROZEN )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+184]
	and	edx, 4096				; 00001000H
	je	SHORT $LN5@PM_UpdateS

; 582  : 		return;

	jmp	$LN1@PM_UpdateS
$LN5@PM_UpdateS:

; 583  : 
; 584  : 	PM_CatagorizeTextureType();

	call	?PM_CatagorizeTextureType@@YAXXZ	; PM_CatagorizeTextureType

; 585  : 
; 586  : 	speed = pmove->velocity.Length();

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _speed$[ebp]

; 587  : 
; 588  : 	// determine if we are on a ladder
; 589  : 	fLadder = ( pmove->movetype == MOVETYPE_FLY );// IsOnLadder();

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+220], 5
	jne	SHORT $LN27@PM_UpdateS
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN28@PM_UpdateS
$LN27@PM_UpdateS:
	mov	DWORD PTR tv77[ebp], 0
$LN28@PM_UpdateS:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _fLadder$[ebp], ecx

; 590  : 
; 591  : 	// UNDONE: need defined numbers for run, walk, crouch, crouch run velocities!!!!	
; 592  : 	if ( ( pmove->flags & FL_DUCKING) || fLadder )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	and	eax, 16384				; 00004000H
	jne	SHORT $LN8@PM_UpdateS
	cmp	DWORD PTR _fLadder$[ebp], 0
	je	SHORT $LN6@PM_UpdateS
$LN8@PM_UpdateS:

; 593  : 	{
; 594  : 		velwalk = 60;		// These constants should be based on cl_movespeedkey * cl_forwardspeed somehow

	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR _velwalk$[ebp], xmm0

; 595  : 		velrun = 80;		// UNDONE: Move walking to server

	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR _velrun$[ebp], xmm0

; 596  : 		flduck = 100;

	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _flduck$[ebp], xmm0

; 597  : 	}
; 598  : 	else

	jmp	SHORT $LN7@PM_UpdateS
$LN6@PM_UpdateS:

; 599  : 	{
; 600  : 		velwalk = 120;

	movss	xmm0, DWORD PTR __real@42f00000
	movss	DWORD PTR _velwalk$[ebp], xmm0

; 601  : 		velrun = 210;

	movss	xmm0, DWORD PTR __real@43520000
	movss	DWORD PTR _velrun$[ebp], xmm0

; 602  : 		flduck = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _flduck$[ebp], xmm0
$LN7@PM_UpdateS:

; 603  : 	}
; 604  : 
; 605  : 	// If we're on a ladder or on the ground, and we're moving fast enough,
; 606  : 	//  play step sound.  Also, if pmove->flTimeStepSound is zero, get the new
; 607  : 	//  sound right away - we just started moving in new level.
; 608  : 	if ( (fLadder || ( pmove->onground != -1 ) ) &&
; 609  : 		( pmove->velocity.Length() > 0.0 ) &&

	cmp	DWORD PTR _fLadder$[ebp], 0
	jne	SHORT $LN10@PM_UpdateS
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+224], -1
	je	$LN9@PM_UpdateS
$LN10@PM_UpdateS:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	QWORD PTR tv290[ebp]
	movsd	xmm0, QWORD PTR tv290[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN9@PM_UpdateS
	movss	xmm0, DWORD PTR _speed$[ebp]
	comiss	xmm0, DWORD PTR _velwalk$[ebp]
	jae	SHORT $LN11@PM_UpdateS
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [edx+148], 0
	jne	$LN9@PM_UpdateS
$LN11@PM_UpdateS:

; 610  : 		( speed >= velwalk || !pmove->flTimeStepSound ) )
; 611  : 	{
; 612  : 		fWalking = speed < velrun;		

	movss	xmm0, DWORD PTR _velrun$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN29@PM_UpdateS
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN30@PM_UpdateS
$LN29@PM_UpdateS:
	mov	DWORD PTR tv94[ebp], 0
$LN30@PM_UpdateS:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR _fWalking$[ebp], eax

; 613  : 
; 614  : 		center = knee = feet = pmove->origin;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _feet$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _feet$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _feet$[ebp+8], ecx
	mov	edx, DWORD PTR _feet$[ebp]
	mov	DWORD PTR _knee$[ebp], edx
	mov	eax, DWORD PTR _feet$[ebp+4]
	mov	DWORD PTR _knee$[ebp+4], eax
	mov	ecx, DWORD PTR _feet$[ebp+8]
	mov	DWORD PTR _knee$[ebp+8], ecx
	mov	edx, DWORD PTR _knee$[ebp]
	mov	DWORD PTR _center$[ebp], edx
	mov	eax, DWORD PTR _knee$[ebp+4]
	mov	DWORD PTR _center$[ebp+4], eax
	mov	ecx, DWORD PTR _knee$[ebp+8]
	mov	DWORD PTR _center$[ebp+8], ecx

; 615  : 
; 616  : 		height = pmove->player_maxs[ pmove->usehull ][ 2 ] - pmove->player_mins[ pmove->usehull ][ 2 ];

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324900]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esi, eax
	mov	edi, 4
	shl	edi, 1
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	lea	ecx, DWORD PTR [ecx+eax+324852]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [esi+edi]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _height$[ebp], xmm0

; 617  : 
; 618  : 		knee[2] = pmove->origin[2] - 0.3 * height;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _height$[ebp]
	mulsd	xmm1, QWORD PTR __real@3fd3333333333333
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	lea	ecx, DWORD PTR _knee$[ebp]
	movss	DWORD PTR tv397[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 619  : 		feet[2] = pmove->origin[2] - 0.5 * height;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 56					; 00000038H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _height$[ebp]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	lea	ecx, DWORD PTR _feet$[ebp]
	movss	DWORD PTR tv399[ebp], xmm0
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv399[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 620  : 
; 621  : 		// find out what we're stepping in or on...
; 622  : 		if (fLadder)

	cmp	DWORD PTR _fLadder$[ebp], 0
	je	SHORT $LN12@PM_UpdateS

; 623  : 		{
; 624  : 			step = STEP_LADDER;

	mov	DWORD PTR _step$[ebp], 8

; 625  : 			fvol = 0.35;

	movss	xmm0, DWORD PTR __real@3eb33333
	movss	DWORD PTR _fvol$[ebp], xmm0

; 626  : 			pmove->flTimeStepSound = 350;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+148], 350		; 0000015eH
	jmp	$LN2@PM_UpdateS
$LN12@PM_UpdateS:

; 627  : 		}
; 628  : 		else if ( pmove->PM_PointContents ( knee, NULL ) == CONTENTS_WATER )

	push	0
	lea	ecx, DWORD PTR _knee$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324980]
	call	edx
	add	esp, 8
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LN14@PM_UpdateS

; 629  : 		{
; 630  : 			step = STEP_WADE;

	mov	DWORD PTR _step$[ebp], 7

; 631  : 			fvol = 0.65;

	movss	xmm0, DWORD PTR __real@3f266666
	movss	DWORD PTR _fvol$[ebp], xmm0

; 632  : 			pmove->flTimeStepSound = 600;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [eax+148], 600		; 00000258H
	jmp	$LN2@PM_UpdateS
$LN14@PM_UpdateS:

; 633  : 		}
; 634  : 		else if ( pmove->PM_PointContents ( feet, NULL ) == CONTENTS_WATER )

	push	0
	lea	ecx, DWORD PTR _feet$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+324980]
	call	edx
	add	esp, 8
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LN16@PM_UpdateS

; 635  : 		{
; 636  : 			step = STEP_SLOSH;

	mov	DWORD PTR _step$[ebp], 6

; 637  : 			fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN31@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	movsd	QWORD PTR tv192[ebp], xmm0
	jmp	SHORT $LN32@PM_UpdateS
$LN31@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv192[ebp], xmm0
$LN32@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv192[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 638  : 			pmove->flTimeStepSound = fWalking ? 400 : 300;		

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN33@PM_UpdateS
	mov	DWORD PTR tv196[ebp], 400		; 00000190H
	jmp	SHORT $LN34@PM_UpdateS
$LN33@PM_UpdateS:
	mov	DWORD PTR tv196[ebp], 300		; 0000012cH
$LN34@PM_UpdateS:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR tv196[ebp]
	mov	DWORD PTR [eax+148], ecx

; 639  : 		}
; 640  : 		else

	jmp	$LN2@PM_UpdateS
$LN16@PM_UpdateS:

; 641  : 		{
; 642  : 			// find texture under player, if different from current texture, 
; 643  : 			// get material type
; 644  : 			step = PM_MapTextureTypeStepType( pmove->chtexturetype );

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movzx	eax, BYTE PTR [edx+496]
	push	eax
	call	?PM_MapTextureTypeStepType@@YAHD@Z	; PM_MapTextureTypeStepType
	add	esp, 4
	mov	DWORD PTR _step$[ebp], eax

; 645  : 
; 646  : 			switch ( pmove->chtexturetype )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	movsx	edx, BYTE PTR [ecx+496]
	mov	DWORD PTR tv202[ebp], edx
	mov	eax, DWORD PTR tv202[ebp]
	sub	eax, 68					; 00000044H
	mov	DWORD PTR tv202[ebp], eax
	cmp	DWORD PTR tv202[ebp], 18		; 00000012H
	ja	SHORT $LN18@PM_UpdateS
	mov	ecx, DWORD PTR tv202[ebp]
	movzx	edx, BYTE PTR $LN63@PM_UpdateS[ecx]
	jmp	DWORD PTR $LN64@PM_UpdateS[edx*4]
$LN18@PM_UpdateS:

; 647  : 			{
; 648  : 			default:
; 649  : 			case CHAR_TEX_CONCRETE:						
; 650  : 				fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN35@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	movsd	QWORD PTR tv204[ebp], xmm0
	jmp	SHORT $LN36@PM_UpdateS
$LN35@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv204[ebp], xmm0
$LN36@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv204[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 651  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN37@PM_UpdateS
	mov	DWORD PTR tv208[ebp], 400		; 00000190H
	jmp	SHORT $LN38@PM_UpdateS
$LN37@PM_UpdateS:
	mov	DWORD PTR tv208[ebp], 300		; 0000012cH
$LN38@PM_UpdateS:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR tv208[ebp]
	mov	DWORD PTR [eax+148], ecx

; 652  : 				break;

	jmp	$LN2@PM_UpdateS
$LN19@PM_UpdateS:

; 653  : 
; 654  : 			case CHAR_TEX_METAL:	
; 655  : 				fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN39@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	movsd	QWORD PTR tv210[ebp], xmm0
	jmp	SHORT $LN40@PM_UpdateS
$LN39@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv210[ebp], xmm0
$LN40@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv210[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 656  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN41@PM_UpdateS
	mov	DWORD PTR tv214[ebp], 400		; 00000190H
	jmp	SHORT $LN42@PM_UpdateS
$LN41@PM_UpdateS:
	mov	DWORD PTR tv214[ebp], 300		; 0000012cH
$LN42@PM_UpdateS:
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR tv214[ebp]
	mov	DWORD PTR [edx+148], eax

; 657  : 				break;

	jmp	$LN2@PM_UpdateS
$LN20@PM_UpdateS:

; 658  : 
; 659  : 			case CHAR_TEX_DIRT:	
; 660  : 				fvol = fWalking ? 0.25 : 0.55;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN43@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fd0000000000000
	movsd	QWORD PTR tv216[ebp], xmm0
	jmp	SHORT $LN44@PM_UpdateS
$LN43@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe199999999999a
	movsd	QWORD PTR tv216[ebp], xmm0
$LN44@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv216[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 661  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN45@PM_UpdateS
	mov	DWORD PTR tv220[ebp], 400		; 00000190H
	jmp	SHORT $LN46@PM_UpdateS
$LN45@PM_UpdateS:
	mov	DWORD PTR tv220[ebp], 300		; 0000012cH
$LN46@PM_UpdateS:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR tv220[ebp]
	mov	DWORD PTR [ecx+148], edx

; 662  : 				break;

	jmp	$LN2@PM_UpdateS
$LN21@PM_UpdateS:

; 663  : 
; 664  : 			case CHAR_TEX_VENT:	
; 665  : 				fvol = fWalking ? 0.4 : 0.7;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN47@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fd999999999999a
	movsd	QWORD PTR tv222[ebp], xmm0
	jmp	SHORT $LN48@PM_UpdateS
$LN47@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe6666666666666
	movsd	QWORD PTR tv222[ebp], xmm0
$LN48@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv222[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 666  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN49@PM_UpdateS
	mov	DWORD PTR tv226[ebp], 400		; 00000190H
	jmp	SHORT $LN50@PM_UpdateS
$LN49@PM_UpdateS:
	mov	DWORD PTR tv226[ebp], 300		; 0000012cH
$LN50@PM_UpdateS:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR tv226[ebp]
	mov	DWORD PTR [eax+148], ecx

; 667  : 				break;

	jmp	$LN2@PM_UpdateS
$LN22@PM_UpdateS:

; 668  : 
; 669  : 			case CHAR_TEX_GRATE:
; 670  : 				fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN51@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	movsd	QWORD PTR tv228[ebp], xmm0
	jmp	SHORT $LN52@PM_UpdateS
$LN51@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv228[ebp], xmm0
$LN52@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv228[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 671  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN53@PM_UpdateS
	mov	DWORD PTR tv232[ebp], 400		; 00000190H
	jmp	SHORT $LN54@PM_UpdateS
$LN53@PM_UpdateS:
	mov	DWORD PTR tv232[ebp], 300		; 0000012cH
$LN54@PM_UpdateS:
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR tv232[ebp]
	mov	DWORD PTR [edx+148], eax

; 672  : 				break;

	jmp	$LN2@PM_UpdateS
$LN23@PM_UpdateS:

; 673  : 
; 674  : 			case CHAR_TEX_TILE:	
; 675  : 				fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN55@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	movsd	QWORD PTR tv234[ebp], xmm0
	jmp	SHORT $LN56@PM_UpdateS
$LN55@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv234[ebp], xmm0
$LN56@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv234[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 676  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN57@PM_UpdateS
	mov	DWORD PTR tv238[ebp], 400		; 00000190H
	jmp	SHORT $LN58@PM_UpdateS
$LN57@PM_UpdateS:
	mov	DWORD PTR tv238[ebp], 300		; 0000012cH
$LN58@PM_UpdateS:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR tv238[ebp]
	mov	DWORD PTR [ecx+148], edx

; 677  : 				break;

	jmp	SHORT $LN2@PM_UpdateS
$LN24@PM_UpdateS:

; 678  : 
; 679  : 			case CHAR_TEX_SLOSH:
; 680  : 				fvol = fWalking ? 0.2 : 0.5;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN59@PM_UpdateS
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	movsd	QWORD PTR tv240[ebp], xmm0
	jmp	SHORT $LN60@PM_UpdateS
$LN59@PM_UpdateS:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv240[ebp], xmm0
$LN60@PM_UpdateS:
	cvtsd2ss xmm0, QWORD PTR tv240[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0

; 681  : 				pmove->flTimeStepSound = fWalking ? 400 : 300;

	cmp	DWORD PTR _fWalking$[ebp], 0
	je	SHORT $LN61@PM_UpdateS
	mov	DWORD PTR tv244[ebp], 400		; 00000190H
	jmp	SHORT $LN62@PM_UpdateS
$LN61@PM_UpdateS:
	mov	DWORD PTR tv244[ebp], 300		; 0000012cH
$LN62@PM_UpdateS:
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR tv244[ebp]
	mov	DWORD PTR [eax+148], ecx
$LN2@PM_UpdateS:

; 682  : 				break;
; 683  : 			}
; 684  : 		}
; 685  : 		
; 686  : 		pmove->flTimeStepSound += flduck; // slower step time if ducking

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cvtsi2ss xmm0, DWORD PTR [edx+148]
	addss	xmm0, DWORD PTR _flduck$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	DWORD PTR [ecx+148], eax

; 687  : 
; 688  : 		// play the sound
; 689  : 		// 35% volume if ducking
; 690  : 		if ( pmove->flags & FL_DUCKING )

	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+184]
	and	eax, 16384				; 00004000H
	je	SHORT $LN25@PM_UpdateS

; 691  : 		{
; 692  : 			fvol *= 0.35;

	cvtss2sd xmm0, DWORD PTR _fvol$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fd6666666666666
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fvol$[ebp], xmm0
$LN25@PM_UpdateS:

; 693  : 		}
; 694  : 
; 695  : 		PM_PlayStepSound( step, fvol );

	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _step$[ebp]
	push	ecx
	call	?PM_PlayStepSound@@YAXHM@Z		; PM_PlayStepSound
	add	esp, 8
$LN9@PM_UpdateS:
$LN1@PM_UpdateS:

; 696  : 	}
; 697  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN64@PM_UpdateS:
	DD	$LN20@PM_UpdateS
	DD	$LN22@PM_UpdateS
	DD	$LN19@PM_UpdateS
	DD	$LN24@PM_UpdateS
	DD	$LN23@PM_UpdateS
	DD	$LN21@PM_UpdateS
	DD	$LN18@PM_UpdateS
$LN63@PM_UpdateS:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	5
?PM_UpdateStepSound@@YAXXZ ENDP				; PM_UpdateStepSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_start$ = -32						; size = 12
_end$ = -20						; size = 12
tv72 = -8						; size = 4
_pTextureName$ = -4					; size = 4
?PM_CatagorizeTextureType@@YAXXZ PROC			; PM_CatagorizeTextureType

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 532  : 	Vector start, end;

	lea	ecx, DWORD PTR _start$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _end$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 533  : 	const char *pTextureName;
; 534  : 
; 535  : 	start = end = pmove->origin;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _end$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _end$[ebp+8], eax
	mov	ecx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _start$[ebp], ecx
	mov	edx, DWORD PTR _end$[ebp+4]
	mov	DWORD PTR _start$[ebp+4], edx
	mov	eax, DWORD PTR _end$[ebp+8]
	mov	DWORD PTR _start$[ebp+8], eax

; 536  : 
; 537  : 	// Straight down
; 538  : 	end[2] -= 64;

	lea	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	add	eax, ecx
	mov	DWORD PTR tv72[ebp], eax
	mov	edx, DWORD PTR tv72[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR __real@42800000
	mov	eax, DWORD PTR tv72[ebp]
	movss	DWORD PTR [eax], xmm0

; 539  : 
; 540  : 	// Fill in default values, just in case.
; 541  : 	pmove->sztexturename[0] = '\0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	BYTE PTR [eax+edx+240], 0

; 542  : 	pmove->chtexturetype = CHAR_TEX_CONCRETE;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	BYTE PTR [ecx+496], 67			; 00000043H

; 543  : 
; 544  : 	pTextureName = pmove->PM_TraceTexture( pmove->onground, start, end );

	lea	ecx, DWORD PTR _end$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+224]
	push	eax
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325048]
	call	edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTextureName$[ebp], eax

; 545  : 	if ( !pTextureName )

	cmp	DWORD PTR _pTextureName$[ebp], 0
	jne	SHORT $LN2@PM_Catagor

; 546  : 		return;

	jmp	$LN1@PM_Catagor
$LN2@PM_Catagor:

; 547  : 
; 548  : 	// strip leading '-0' or '+0~' or '{' or '!'
; 549  : 	if (*pTextureName == '-' || *pTextureName == '+')

	mov	eax, DWORD PTR _pTextureName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN4@PM_Catagor
	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN3@PM_Catagor
$LN4@PM_Catagor:

; 550  : 		pTextureName += 2;

	mov	ecx, DWORD PTR _pTextureName$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pTextureName$[ebp], ecx
$LN3@PM_Catagor:

; 551  : 
; 552  : 	if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')

	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN6@PM_Catagor
	mov	ecx, DWORD PTR _pTextureName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	je	SHORT $LN6@PM_Catagor
	mov	eax, DWORD PTR _pTextureName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 126				; 0000007eH
	je	SHORT $LN6@PM_Catagor
	mov	edx, DWORD PTR _pTextureName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN5@PM_Catagor
$LN6@PM_Catagor:

; 553  : 		pTextureName++;

	mov	ecx, DWORD PTR _pTextureName$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pTextureName$[ebp], ecx
$LN5@PM_Catagor:

; 554  : 	// '}}'
; 555  : 	
; 556  : 	strcpy( pmove->sztexturename, pTextureName);

	mov	edx, DWORD PTR _pTextureName$[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	eax, 240				; 000000f0H
	push	eax
	call	_strcpy
	add	esp, 8

; 557  : 	pmove->sztexturename[ CBTEXTURENAMEMAX - 1 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 12
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	BYTE PTR [eax+edx+240], 0

; 558  : 		
; 559  : 	// get texture type
; 560  : 	pmove->chtexturetype = PM_FindTextureType( pmove->sztexturename );	

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 240				; 000000f0H
	push	ecx
	call	?PM_FindTextureType@@YADPAD@Z		; PM_FindTextureType
	add	esp, 4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	BYTE PTR [edx+496], al
$LN1@PM_Catagor:

; 561  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_CatagorizeTextureType@@YAXXZ ENDP			; PM_CatagorizeTextureType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv65 = -4						; size = 4
_chTextureType$ = 8					; size = 1
?PM_MapTextureTypeStepType@@YAHD@Z PROC			; PM_MapTextureTypeStepType

; 509  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 510  : 	switch (chTextureType)

	movsx	eax, BYTE PTR _chTextureType$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 18			; 00000012H
	ja	SHORT $LN4@PM_MapText
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN12@PM_MapText[edx]
	jmp	DWORD PTR $LN13@PM_MapText[eax*4]
$LN4@PM_MapText:

; 511  : 	{
; 512  : 		default:
; 513  : 		case CHAR_TEX_CONCRETE:	return STEP_CONCRETE;	

	xor	eax, eax
	jmp	SHORT $LN1@PM_MapText
$LN5@PM_MapText:

; 514  : 		case CHAR_TEX_METAL: return STEP_METAL;	

	mov	eax, 1
	jmp	SHORT $LN1@PM_MapText
$LN6@PM_MapText:

; 515  : 		case CHAR_TEX_DIRT: return STEP_DIRT;	

	mov	eax, 2
	jmp	SHORT $LN1@PM_MapText
$LN7@PM_MapText:

; 516  : 		case CHAR_TEX_VENT: return STEP_VENT;	

	mov	eax, 3
	jmp	SHORT $LN1@PM_MapText
$LN8@PM_MapText:

; 517  : 		case CHAR_TEX_GRATE: return STEP_GRATE;	

	mov	eax, 4
	jmp	SHORT $LN1@PM_MapText
$LN9@PM_MapText:

; 518  : 		case CHAR_TEX_TILE: return STEP_TILE;

	mov	eax, 5
	jmp	SHORT $LN1@PM_MapText
$LN10@PM_MapText:

; 519  : 		case CHAR_TEX_SLOSH: return STEP_SLOSH;

	mov	eax, 6
$LN1@PM_MapText:

; 520  : 	}
; 521  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@PM_MapText:
	DD	$LN6@PM_MapText
	DD	$LN8@PM_MapText
	DD	$LN5@PM_MapText
	DD	$LN10@PM_MapText
	DD	$LN9@PM_MapText
	DD	$LN7@PM_MapText
	DD	$LN4@PM_MapText
$LN12@PM_MapText:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	5
?PM_MapTextureTypeStepType@@YAHD@Z ENDP			; PM_MapTextureTypeStepType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_hvel$ = -84						; size = 12
tv468 = -72						; size = 4
tv177 = -68						; size = 4
tv559 = -64						; size = 4
tv499 = -60						; size = 4
tv469 = -56						; size = 4
tv402 = -52						; size = 4
tv365 = -48						; size = 4
tv330 = -44						; size = 4
tv300 = -40						; size = 4
tv270 = -36						; size = 4
tv240 = -32						; size = 4
tv210 = -28						; size = 4
tv68 = -24						; size = 4
_iType$ = -20						; size = 4
tv95 = -16						; size = 4
tv209 = -12						; size = 4
_irand$ = -8						; size = 4
_szValue$ = -4						; size = 4
_step$ = 8						; size = 4
_fvol$ = 12						; size = 4
?PM_PlayStepSound@@YAXHM@Z PROC				; PM_PlayStepSound

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 314  : 	static int iSkipStep = 0;
; 315  : 	int irand;
; 316  : 	Vector hvel;

	lea	ecx, DWORD PTR _hvel$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 317  : 	const char* szValue;
; 318  : 	int iType;
; 319  : 
; 320  : 	pmove->iStepLeft = !pmove->iStepLeft;

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+152], 0
	jne	SHORT $LN90@PM_PlaySte
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN91@PM_PlaySte
$LN90@PM_PlaySte:
	mov	DWORD PTR tv68[ebp], 0
$LN91@PM_PlaySte:
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR [ecx+152], edx

; 321  : 
; 322  : 	if ( !pmove->runfuncs )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+325040], 0
	jne	SHORT $LN24@PM_PlaySte

; 323  : 	{
; 324  : 		return;

	jmp	$LN1@PM_PlaySte
$LN24@PM_PlaySte:

; 325  : 	}
; 326  : 	
; 327  : 	irand = pmove->RandomLong(0,1) + ( pmove->iStepLeft * 2 );

	push	1
	push	0
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325000]
	call	edx
	add	esp, 8
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+152]
	lea	eax, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _irand$[ebp], eax

; 328  : 
; 329  : 	// FIXME mp_footsteps needs to be a movevar
; 330  : 	if ( pmove->multiplayer && !pmove->movevars->footsteps )

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN25@PM_PlaySte
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324848]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN25@PM_PlaySte

; 331  : 		return;

	jmp	$LN1@PM_PlaySte
$LN25@PM_PlaySte:

; 332  : 
; 333  : 	hvel = pmove->velocity;

	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _hvel$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _hvel$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _hvel$[ebp+8], ecx

; 334  : 	hvel[2] = 0.0;

	lea	ecx, DWORD PTR _hvel$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 335  : 
; 336  : 	if ( pmove->multiplayer && ( !g_onladder && hvel.Length() <= 220 ) )

	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN26@PM_PlaySte
	cmp	DWORD PTR ?g_onladder@@3HA, 0		; g_onladder
	jne	SHORT $LN26@PM_PlaySte
	lea	ecx, DWORD PTR _hvel$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR tv559[ebp]
	movss	xmm0, DWORD PTR __real@435c0000
	comiss	xmm0, DWORD PTR tv559[ebp]
	jb	SHORT $LN26@PM_PlaySte

; 337  : 		return;

	jmp	$LN1@PM_PlaySte
$LN26@PM_PlaySte:

; 338  : 
; 339  : 	switch ( step )

	mov	ecx, DWORD PTR _step$[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	cmp	DWORD PTR tv95[ebp], 6
	je	$LN29@PM_PlaySte
	cmp	DWORD PTR tv95[ebp], 7
	je	$LN31@PM_PlaySte
	cmp	DWORD PTR tv95[ebp], 8
	je	SHORT $LN27@PM_PlaySte
	jmp	$LN35@PM_PlaySte
$LN27@PM_PlaySte:

; 340  : 	{
; 341  : 	case STEP_LADDER:
; 342  : 		szValue = pmove->PM_Info_ValueForKey( pmove->physinfo, "lsnd" );

	push	OFFSET $SG15099
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 324592				; 0004f3f0H
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324948]
	call	ecx
	add	esp, 8
	mov	DWORD PTR _szValue$[ebp], eax

; 343  : 		if (szValue[0] && szValue[1])

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN28@PM_PlaySte
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN28@PM_PlaySte

; 344  : 		{
; 345  : 			PM_PlayGroupSound( szValue, irand, fvol );

	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _irand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	call	?PM_PlayGroupSound@@YAXPBDHM@Z		; PM_PlayGroupSound
	add	esp, 12					; 0000000cH

; 346  : 			return;

	jmp	$LN1@PM_PlaySte
$LN28@PM_PlaySte:

; 347  : 		}
; 348  : 		break;

	jmp	$LN2@PM_PlaySte
$LN29@PM_PlaySte:

; 349  : 	case STEP_SLOSH:
; 350  : 		szValue = pmove->PM_Info_ValueForKey( pmove->physinfo, "psnd" );

	push	OFFSET $SG15102
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 324592				; 0004f3f0H
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324948]
	call	ecx
	add	esp, 8
	mov	DWORD PTR _szValue$[ebp], eax

; 351  : 		if (szValue[0] && szValue[1])

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN30@PM_PlaySte
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN30@PM_PlaySte

; 352  : 		{
; 353  : 			PM_PlayGroupSound( szValue, irand, fvol );

	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _irand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	call	?PM_PlayGroupSound@@YAXPBDHM@Z		; PM_PlayGroupSound
	add	esp, 12					; 0000000cH

; 354  : 			return;

	jmp	$LN1@PM_PlaySte
$LN30@PM_PlaySte:

; 355  : 		}
; 356  : 		break;

	jmp	$LN2@PM_PlaySte
$LN31@PM_PlaySte:

; 357  : 	case STEP_WADE:
; 358  : 		szValue = pmove->PM_Info_ValueForKey( pmove->physinfo, "wsnd" );

	push	OFFSET $SG15105
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 324592				; 0004f3f0H
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324948]
	call	ecx
	add	esp, 8
	mov	DWORD PTR _szValue$[ebp], eax

; 359  : 		if (szValue[0] && szValue[1])

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN32@PM_PlaySte
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN32@PM_PlaySte

; 360  : 		{
; 361  : 			if ( iSkipStep == 0 )

	cmp	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, 0
	jne	SHORT $LN33@PM_PlaySte

; 362  : 			{ iSkipStep++; return; }

	mov	eax, DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
	add	eax, 1
	mov	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, eax
	jmp	$LN1@PM_PlaySte
$LN33@PM_PlaySte:

; 363  : 
; 364  : 			if ( iSkipStep++ == 3 )

	mov	ecx, DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
	add	edx, 1
	mov	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, edx
	cmp	DWORD PTR tv177[ebp], 3
	jne	SHORT $LN34@PM_PlaySte

; 365  : 			{ iSkipStep = 0; }

	mov	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, 0
$LN34@PM_PlaySte:

; 366  : 
; 367  : 			PM_PlayGroupSound( szValue, irand, fvol );

	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _irand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	call	?PM_PlayGroupSound@@YAXPBDHM@Z		; PM_PlayGroupSound
	add	esp, 12					; 0000000cH

; 368  : 			return;

	jmp	$LN1@PM_PlaySte
$LN32@PM_PlaySte:

; 369  : 		}
; 370  : 		break;

	jmp	$LN2@PM_PlaySte
$LN35@PM_PlaySte:

; 371  : 	default:
; 372  : 		szValue = pmove->PM_Info_ValueForKey( pmove->physinfo, "ssnd" );

	push	OFFSET $SG15110
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 324592				; 0004f3f0H
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324948]
	call	ecx
	add	esp, 8
	mov	DWORD PTR _szValue$[ebp], eax

; 373  : 		if (szValue[0] && szValue[1])

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN36@PM_PlaySte
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN36@PM_PlaySte

; 374  : 		{
; 375  : 			PM_PlayGroupSound( szValue, irand, fvol );

	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _irand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	call	?PM_PlayGroupSound@@YAXPBDHM@Z		; PM_PlayGroupSound
	add	esp, 12					; 0000000cH

; 376  : 			return;

	jmp	$LN1@PM_PlaySte
$LN36@PM_PlaySte:

; 377  : 		}
; 378  : 		iType = atoi(pmove->PM_Info_ValueForKey( pmove->physinfo, "stype" ));

	push	OFFSET $SG15112
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	add	edx, 324592				; 0004f3f0H
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+324948]
	call	ecx
	add	esp, 8
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _iType$[ebp], eax

; 379  : 		if (iType == -1)

	cmp	DWORD PTR _iType$[ebp], -1
	jne	SHORT $LN37@PM_PlaySte

; 380  : 			step = STEP_CONCRETE;

	mov	DWORD PTR _step$[ebp], 0
	jmp	SHORT $LN39@PM_PlaySte
$LN37@PM_PlaySte:

; 381  : 		else if (iType)

	cmp	DWORD PTR _iType$[ebp], 0
	je	SHORT $LN39@PM_PlaySte

; 382  : 			step = iType;

	mov	edx, DWORD PTR _iType$[ebp]
	mov	DWORD PTR _step$[ebp], edx
$LN39@PM_PlaySte:
$LN2@PM_PlaySte:

; 383  : 	}
; 384  : 
; 385  : 	// irand - 0,1 for right foot, 2,3 for left foot
; 386  : 	// used to alternate left and right foot
; 387  : 	// FIXME, move to player state
; 388  : 
; 389  : 	switch (step)

	mov	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR tv209[ebp], eax
	mov	ecx, DWORD PTR tv209[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv209[ebp], ecx
	cmp	DWORD PTR tv209[ebp], 7
	ja	SHORT $LN40@PM_PlaySte
	mov	edx, DWORD PTR tv209[ebp]
	jmp	DWORD PTR $LN92@PM_PlaySte[edx*4]
$LN40@PM_PlaySte:

; 390  : 	{
; 391  : 	default:
; 392  : 	case STEP_CONCRETE:
; 393  : 		switch (irand)

	mov	eax, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv210[ebp], eax
	cmp	DWORD PTR tv210[ebp], 3
	ja	$LN6@PM_PlaySte
	mov	ecx, DWORD PTR tv210[ebp]
	jmp	DWORD PTR $LN93@PM_PlaySte[ecx*4]
$LN41@PM_PlaySte:

; 394  : 		{
; 395  : 		// right foot
; 396  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_step1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15118
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	$LN6@PM_PlaySte
$LN42@PM_PlaySte:

; 397  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_step3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15120
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN6@PM_PlaySte
$LN43@PM_PlaySte:

; 398  : 		// left foot
; 399  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_step2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15122
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN6@PM_PlaySte
$LN44@PM_PlaySte:

; 400  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_step4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15124
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
$LN6@PM_PlaySte:

; 401  : 		}
; 402  : 		break;

	jmp	$LN4@PM_PlaySte
$LN45@PM_PlaySte:

; 403  : 	case STEP_METAL:
; 404  : 		switch(irand)

	mov	ecx, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv240[ebp], ecx
	cmp	DWORD PTR tv240[ebp], 3
	ja	$LN8@PM_PlaySte
	mov	edx, DWORD PTR tv240[ebp]
	jmp	DWORD PTR $LN94@PM_PlaySte[edx*4]
$LN46@PM_PlaySte:

; 405  : 		{
; 406  : 		// right foot
; 407  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_metal1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15127
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	$LN8@PM_PlaySte
$LN47@PM_PlaySte:

; 408  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_metal3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15129
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@PM_PlaySte
$LN48@PM_PlaySte:

; 409  : 		// left foot
; 410  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_metal2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15131
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@PM_PlaySte
$LN49@PM_PlaySte:

; 411  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_metal4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15133
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
$LN8@PM_PlaySte:

; 412  : 		}
; 413  : 		break;

	jmp	$LN4@PM_PlaySte
$LN50@PM_PlaySte:

; 414  : 	case STEP_DIRT:
; 415  : 		switch(irand)

	mov	edx, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv270[ebp], edx
	cmp	DWORD PTR tv270[ebp], 3
	ja	$LN10@PM_PlaySte
	mov	eax, DWORD PTR tv270[ebp]
	jmp	DWORD PTR $LN95@PM_PlaySte[eax*4]
$LN51@PM_PlaySte:

; 416  : 		{
; 417  : 		// right foot
; 418  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_dirt1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15136
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	$LN10@PM_PlaySte
$LN52@PM_PlaySte:

; 419  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_dirt3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15138
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN10@PM_PlaySte
$LN53@PM_PlaySte:

; 420  : 		// left foot
; 421  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_dirt2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15140
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	SHORT $LN10@PM_PlaySte
$LN54@PM_PlaySte:

; 422  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_dirt4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15142
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
$LN10@PM_PlaySte:

; 423  : 		}
; 424  : 		break;

	jmp	$LN4@PM_PlaySte
$LN55@PM_PlaySte:

; 425  : 	case STEP_VENT:
; 426  : 		switch(irand)

	mov	eax, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv300[ebp], eax
	cmp	DWORD PTR tv300[ebp], 3
	ja	$LN12@PM_PlaySte
	mov	ecx, DWORD PTR tv300[ebp]
	jmp	DWORD PTR $LN96@PM_PlaySte[ecx*4]
$LN56@PM_PlaySte:

; 427  : 		{
; 428  : 		// right foot
; 429  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_duct1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15145
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	$LN12@PM_PlaySte
$LN57@PM_PlaySte:

; 430  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_duct3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15147
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN12@PM_PlaySte
$LN58@PM_PlaySte:

; 431  : 		// left foot
; 432  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_duct2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15149
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN12@PM_PlaySte
$LN59@PM_PlaySte:

; 433  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_duct4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15151
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
$LN12@PM_PlaySte:

; 434  : 		}
; 435  : 		break;

	jmp	$LN4@PM_PlaySte
$LN60@PM_PlaySte:

; 436  : 	case STEP_GRATE:
; 437  : 		switch(irand)

	mov	ecx, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv330[ebp], ecx
	cmp	DWORD PTR tv330[ebp], 3
	ja	$LN14@PM_PlaySte
	mov	edx, DWORD PTR tv330[ebp]
	jmp	DWORD PTR $LN97@PM_PlaySte[edx*4]
$LN61@PM_PlaySte:

; 438  : 		{
; 439  : 		// right foot
; 440  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_grate1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15154
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	$LN14@PM_PlaySte
$LN62@PM_PlaySte:

; 441  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_grate3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15156
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	SHORT $LN14@PM_PlaySte
$LN63@PM_PlaySte:

; 442  : 		// left foot
; 443  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_grate2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15158
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN14@PM_PlaySte
$LN64@PM_PlaySte:

; 444  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_grate4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15160
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
$LN14@PM_PlaySte:

; 445  : 		}
; 446  : 		break;

	jmp	$LN4@PM_PlaySte
$LN65@PM_PlaySte:

; 447  : 	case STEP_TILE:
; 448  : 		if ( !pmove->RandomLong(0,4) )

	push	4
	push	0
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325000]
	call	eax
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@PM_PlaySte

; 449  : 			irand = 4;

	mov	DWORD PTR _irand$[ebp], 4
$LN66@PM_PlaySte:

; 450  : 		switch(irand)

	mov	ecx, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv365[ebp], ecx
	cmp	DWORD PTR tv365[ebp], 4
	ja	$LN16@PM_PlaySte
	mov	edx, DWORD PTR tv365[ebp]
	jmp	DWORD PTR $LN98@PM_PlaySte[edx*4]
$LN67@PM_PlaySte:

; 451  : 		{
; 452  : 		// right foot
; 453  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_tile1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15164
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	$LN16@PM_PlaySte
$LN68@PM_PlaySte:

; 454  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_tile3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15166
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	$LN16@PM_PlaySte
$LN69@PM_PlaySte:

; 455  : 		// left foot
; 456  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_tile2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15168
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN16@PM_PlaySte
$LN70@PM_PlaySte:

; 457  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_tile4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15170
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN16@PM_PlaySte
$LN71@PM_PlaySte:

; 458  : 		case 4: pmove->PM_PlaySound( CHAN_BODY, "player/pl_tile5.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15172
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
$LN16@PM_PlaySte:

; 459  : 		}
; 460  : 		break;

	jmp	$LN4@PM_PlaySte
$LN72@PM_PlaySte:

; 461  : 	case STEP_SLOSH:
; 462  : 		switch(irand)

	mov	ecx, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv402[ebp], ecx
	cmp	DWORD PTR tv402[ebp], 3
	ja	$LN18@PM_PlaySte
	mov	edx, DWORD PTR tv402[ebp]
	jmp	DWORD PTR $LN99@PM_PlaySte[edx*4]
$LN73@PM_PlaySte:

; 463  : 		{
; 464  : 		// right foot
; 465  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_slosh1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15175
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	$LN18@PM_PlaySte
$LN74@PM_PlaySte:

; 466  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_slosh3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15177
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	SHORT $LN18@PM_PlaySte
$LN75@PM_PlaySte:

; 467  : 		// left foot
; 468  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_slosh2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15179
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN18@PM_PlaySte
$LN76@PM_PlaySte:

; 469  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_slosh4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15181
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
$LN18@PM_PlaySte:

; 470  : 		}
; 471  : 		break;

	jmp	$LN4@PM_PlaySte
$LN77@PM_PlaySte:

; 472  : 	case STEP_WADE:
; 473  : 		if ( iSkipStep == 0 )

	cmp	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, 0
	jne	SHORT $LN78@PM_PlaySte

; 474  : 		{
; 475  : 			iSkipStep++;

	mov	edx, DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
	add	edx, 1
	mov	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, edx

; 476  : 			break;

	jmp	$LN4@PM_PlaySte
$LN78@PM_PlaySte:

; 477  : 		}
; 478  : 
; 479  : 		if ( iSkipStep++ == 3 )

	mov	eax, DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
	mov	DWORD PTR tv468[ebp], eax
	mov	ecx, DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA
	add	ecx, 1
	mov	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, ecx
	cmp	DWORD PTR tv468[ebp], 3
	jne	SHORT $LN79@PM_PlaySte

; 480  : 		{
; 481  : 			iSkipStep = 0;

	mov	DWORD PTR ?iSkipStep@?1??PM_PlayStepSound@@YAXHM@Z@4HA, 0
$LN79@PM_PlaySte:

; 482  : 		}
; 483  : 
; 484  : 		switch (irand)

	mov	edx, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv469[ebp], edx
	cmp	DWORD PTR tv469[ebp], 3
	ja	$LN20@PM_PlaySte
	mov	eax, DWORD PTR tv469[ebp]
	jmp	DWORD PTR $LN100@PM_PlaySte[eax*4]
$LN80@PM_PlaySte:

; 485  : 		{
; 486  : 		// right foot
; 487  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15186
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	$LN20@PM_PlaySte
$LN81@PM_PlaySte:

; 488  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15188
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN20@PM_PlaySte
$LN82@PM_PlaySte:

; 489  : 		// left foot
; 490  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15190
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	SHORT $LN20@PM_PlaySte
$LN83@PM_PlaySte:

; 491  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_wade4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15192
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
$LN20@PM_PlaySte:

; 492  : 		}
; 493  : 		break;

	jmp	$LN4@PM_PlaySte
$LN84@PM_PlaySte:

; 494  : 	case STEP_LADDER:
; 495  : 		switch(irand)

	mov	eax, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv499[ebp], eax
	cmp	DWORD PTR tv499[ebp], 3
	ja	$LN22@PM_PlaySte
	mov	ecx, DWORD PTR tv499[ebp]
	jmp	DWORD PTR $LN101@PM_PlaySte[ecx*4]
$LN85@PM_PlaySte:

; 496  : 		{
; 497  : 		// right foot
; 498  : 		case 0:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_ladder1.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15195
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
	jmp	$LN22@PM_PlaySte
$LN86@PM_PlaySte:

; 499  : 		case 1:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_ladder3.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15197
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN22@PM_PlaySte
$LN87@PM_PlaySte:

; 500  : 		// left foot
; 501  : 		case 2:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_ladder2.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15199
	push	4
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325044]
	call	ecx
	add	esp, 24					; 00000018H
	jmp	SHORT $LN22@PM_PlaySte
$LN88@PM_PlaySte:

; 502  : 		case 3:	pmove->PM_PlaySound( CHAN_BODY, "player/pl_ladder4.wav", fvol, ATTN_NORM, 0, PITCH_NORM );	break;

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG15201
	push	4
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325044]
	call	eax
	add	esp, 24					; 00000018H
$LN22@PM_PlaySte:
$LN4@PM_PlaySte:
$LN1@PM_PlaySte:

; 503  : 		}
; 504  : 		break;
; 505  : 	}
; 506  : }	

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN92@PM_PlaySte:
	DD	$LN45@PM_PlaySte
	DD	$LN50@PM_PlaySte
	DD	$LN55@PM_PlaySte
	DD	$LN60@PM_PlaySte
	DD	$LN65@PM_PlaySte
	DD	$LN72@PM_PlaySte
	DD	$LN77@PM_PlaySte
	DD	$LN84@PM_PlaySte
$LN93@PM_PlaySte:
	DD	$LN41@PM_PlaySte
	DD	$LN42@PM_PlaySte
	DD	$LN43@PM_PlaySte
	DD	$LN44@PM_PlaySte
$LN94@PM_PlaySte:
	DD	$LN46@PM_PlaySte
	DD	$LN47@PM_PlaySte
	DD	$LN48@PM_PlaySte
	DD	$LN49@PM_PlaySte
$LN95@PM_PlaySte:
	DD	$LN51@PM_PlaySte
	DD	$LN52@PM_PlaySte
	DD	$LN53@PM_PlaySte
	DD	$LN54@PM_PlaySte
$LN96@PM_PlaySte:
	DD	$LN56@PM_PlaySte
	DD	$LN57@PM_PlaySte
	DD	$LN58@PM_PlaySte
	DD	$LN59@PM_PlaySte
$LN97@PM_PlaySte:
	DD	$LN61@PM_PlaySte
	DD	$LN62@PM_PlaySte
	DD	$LN63@PM_PlaySte
	DD	$LN64@PM_PlaySte
$LN98@PM_PlaySte:
	DD	$LN67@PM_PlaySte
	DD	$LN68@PM_PlaySte
	DD	$LN69@PM_PlaySte
	DD	$LN70@PM_PlaySte
	DD	$LN71@PM_PlaySte
$LN99@PM_PlaySte:
	DD	$LN73@PM_PlaySte
	DD	$LN74@PM_PlaySte
	DD	$LN75@PM_PlaySte
	DD	$LN76@PM_PlaySte
$LN100@PM_PlaySte:
	DD	$LN80@PM_PlaySte
	DD	$LN81@PM_PlaySte
	DD	$LN82@PM_PlaySte
	DD	$LN83@PM_PlaySte
$LN101@PM_PlaySte:
	DD	$LN85@PM_PlaySte
	DD	$LN86@PM_PlaySte
	DD	$LN87@PM_PlaySte
	DD	$LN88@PM_PlaySte
?PM_PlayStepSound@@YAXHM@Z ENDP				; PM_PlayStepSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv73 = -8						; size = 4
_i$ = -4						; size = 4
_szValue$ = 8						; size = 4
_irand$ = 12						; size = 4
_fvol$ = 16						; size = 4
?PM_PlayGroupSound@@YAXPBDHM@Z PROC			; PM_PlayGroupSound

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 288  : 	static char szBuf[128];
; 289  : 	int i;
; 290  : 	for (i = 0; szValue[i]; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_PlayGro
$LN2@PM_PlayGro:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_PlayGro:
	mov	ecx, DWORD PTR _szValue$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN3@PM_PlayGro

; 291  : 	{
; 292  : 		if (szValue[i] == '?')

	mov	eax, DWORD PTR _szValue$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	jne	$LN7@PM_PlayGro

; 293  : 		{
; 294  : 			strcpy(szBuf, szValue);

	mov	edx, DWORD PTR _szValue$[ebp]
	push	edx
	push	OFFSET ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA
	call	_strcpy
	add	esp, 8

; 295  : 			switch (irand)

	mov	eax, DWORD PTR _irand$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 3
	ja	SHORT $LN12@PM_PlayGro
	mov	ecx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN14@PM_PlayGro[ecx*4]
$LN8@PM_PlayGro:

; 296  : 			{
; 297  : 			// right foot
; 298  : 			case 0:	szBuf[i] = '1';	break;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA[edx], 49 ; 00000031H
	jmp	SHORT $LN5@PM_PlayGro
$LN9@PM_PlayGro:

; 299  : 			case 1:	szBuf[i] = '3';	break;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA[eax], 51 ; 00000033H
	jmp	SHORT $LN5@PM_PlayGro
$LN10@PM_PlayGro:

; 300  : 			// left foot
; 301  : 			case 2:	szBuf[i] = '2';	break;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA[ecx], 50 ; 00000032H
	jmp	SHORT $LN5@PM_PlayGro
$LN11@PM_PlayGro:

; 302  : 			case 3:	szBuf[i] = '4';	break;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA[edx], 52 ; 00000034H
	jmp	SHORT $LN5@PM_PlayGro
$LN12@PM_PlayGro:

; 303  : 			default: szBuf[i] = '#';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA[eax], 35 ; 00000023H
$LN5@PM_PlayGro:

; 304  : 			}
; 305  : 			pmove->PM_PlaySound( CHAN_BODY, szBuf, fvol, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?szBuf@?1??PM_PlayGroupSound@@YAXPBDHM@Z@4PADA
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H

; 306  : 			return;

	jmp	SHORT $LN1@PM_PlayGro
$LN7@PM_PlayGro:

; 307  : 		}
; 308  : 	}

	jmp	$LN2@PM_PlayGro
$LN3@PM_PlayGro:

; 309  : 	pmove->PM_PlaySound( CHAN_BODY, szValue, fvol, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	edx, DWORD PTR [ecx+325044]
	call	edx
	add	esp, 24					; 00000018H
$LN1@PM_PlayGro:

; 310  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@PM_PlayGro:
	DD	$LN8@PM_PlayGro
	DD	$LN9@PM_PlayGro
	DD	$LN10@PM_PlayGro
	DD	$LN11@PM_PlayGro
?PM_PlayGroupSound@@YAXPBDHM@Z ENDP			; PM_PlayGroupSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_right$ = -16						; size = 4
_val$ = -12						; size = 4
_left$ = -8						; size = 4
_pivot$ = -4						; size = 4
_name$ = 8						; size = 4
?PM_FindTextureType@@YADPAD@Z PROC			; PM_FindTextureType

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 256  : 	int left, right, pivot;
; 257  : 	int val;
; 258  : 
; 259  : 	assert( pm_shared_initialized );

	cmp	DWORD PTR ?pm_shared_initialized@@3HA, 0
	jne	SHORT $LN10@PM_FindTex
	push	259					; 00000103H
	push	OFFSET $SG14998
	push	OFFSET $SG14999
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@PM_FindTex:

; 260  : 
; 261  : 	left = 0;

	mov	DWORD PTR _left$[ebp], 0

; 262  : 	right = gcTextures - 1;

	mov	ecx, DWORD PTR ?gcTextures@@3HA
	sub	ecx, 1
	mov	DWORD PTR _right$[ebp], ecx
$LN2@PM_FindTex:

; 263  : 
; 264  : 	while ( left <= right )

	mov	edx, DWORD PTR _left$[ebp]
	cmp	edx, DWORD PTR _right$[ebp]
	jg	SHORT $LN3@PM_FindTex

; 265  : 	{
; 266  : 		pivot = ( left + right ) / 2;

	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pivot$[ebp], eax

; 267  : 
; 268  : 		val = strnicmp( name, grgszTextureName[ pivot ], CBTEXTURENAMEMAX-1 );

	push	12					; 0000000cH
	imul	eax, DWORD PTR _pivot$[ebp], 13
	add	eax, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_strnicmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$[ebp], eax

; 269  : 		if ( val == 0 )

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN4@PM_FindTex

; 270  : 		{
; 271  : 			return grgchTextureType[ pivot ];

	mov	edx, DWORD PTR _pivot$[ebp]
	mov	al, BYTE PTR ?grgchTextureType@@3PADA[edx]
	jmp	SHORT $LN1@PM_FindTex
	jmp	SHORT $LN5@PM_FindTex
$LN4@PM_FindTex:

; 272  : 		}
; 273  : 		else if ( val > 0 )

	cmp	DWORD PTR _val$[ebp], 0
	jle	SHORT $LN6@PM_FindTex

; 274  : 		{
; 275  : 			left = pivot + 1;

	mov	eax, DWORD PTR _pivot$[ebp]
	add	eax, 1
	mov	DWORD PTR _left$[ebp], eax
	jmp	SHORT $LN5@PM_FindTex
$LN6@PM_FindTex:

; 276  : 		}
; 277  : 		else if ( val < 0 )

	cmp	DWORD PTR _val$[ebp], 0
	jge	SHORT $LN5@PM_FindTex

; 278  : 		{
; 279  : 			right = pivot - 1;

	mov	ecx, DWORD PTR _pivot$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _right$[ebp], ecx
$LN5@PM_FindTex:

; 280  : 		}
; 281  : 	}

	jmp	SHORT $LN2@PM_FindTex
$LN3@PM_FindTex:

; 282  : 
; 283  : 	return CHAR_TEX_CONCRETE;

	mov	al, 67					; 00000043H
$LN1@PM_FindTex:

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_FindTextureType@@YADPAD@Z ENDP			; PM_FindTextureType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
tv208 = -552						; size = 4
tv160 = -548						; size = 4
_fileSize$ = -544					; size = 4
_filePos$ = -540					; size = 4
$T1 = -536						; size = 4
tv196 = -532						; size = 4
_pMemFile$ = -528					; size = 4
_j$ = -524						; size = 4
_i$ = -520						; size = 4
_buffer$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
?PM_InitTextureTypes@@YAXXZ PROC			; PM_InitTextureTypes

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 186  : 	char buffer[512];
; 187  : 	int i, j;
; 188  : 	byte *pMemFile;
; 189  : 	int fileSize, filePos;
; 190  : 	static qboolean bTextureTypeInit = false;
; 191  : 
; 192  : 	if ( bTextureTypeInit )

	cmp	DWORD PTR ?bTextureTypeInit@?1??PM_InitTextureTypes@@YAXXZ@4HA, 0
	je	SHORT $LN10@PM_InitTex

; 193  : 		return;

	jmp	$LN17@PM_InitTex
$LN10@PM_InitTex:

; 194  : 
; 195  : 	memset(&(grgszTextureName[0][0]), 0, CTEXTURESMAX * CBTEXTURENAMEMAX);

	push	6656					; 00001a00H
	push	0
	mov	eax, 13					; 0000000dH
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR ?grgszTextureName@@3PAY0N@DA[ecx+eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 196  : 	memset(grgchTextureType, 0, CTEXTURESMAX);

	push	512					; 00000200H
	push	0
	push	OFFSET ?grgchTextureType@@3PADA
	call	_memset
	add	esp, 12					; 0000000cH

; 197  : 
; 198  : 	gcTextures = 0;

	mov	DWORD PTR ?gcTextures@@3HA, 0

; 199  : 	memset(buffer, 0, 512);

	push	512					; 00000200H
	push	0
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 200  : 
; 201  : 	fileSize = pmove->COM_FileSize( "sound/materials.txt" );

	push	OFFSET $SG14979
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325024]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _fileSize$[ebp], eax

; 202  : 	pMemFile = pmove->COM_LoadFile( "sound/materials.txt", 5, NULL );

	push	0
	push	5
	push	OFFSET $SG14980
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325028]
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pMemFile$[ebp], eax

; 203  : 	if ( !pMemFile )

	cmp	DWORD PTR _pMemFile$[ebp], 0
	jne	SHORT $LN11@PM_InitTex

; 204  : 		return;

	jmp	$LN17@PM_InitTex
$LN11@PM_InitTex:

; 205  : 
; 206  : 	filePos = 0;

	mov	DWORD PTR _filePos$[ebp], 0
$LN2@PM_InitTex:

; 207  : 	// for each line in the file...
; 208  : 	while ( pmove->memfgets( pMemFile, fileSize, &filePos, buffer, 511 ) != NULL && (gcTextures < CTEXTURESMAX) )

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filePos$[ebp]
	push	edx
	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+325036]
	call	eax
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN3@PM_InitTex
	cmp	DWORD PTR ?gcTextures@@3HA, 512		; 00000200H
	jge	$LN3@PM_InitTex

; 209  : 	{
; 210  : 		// skip whitespace
; 211  : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN4@PM_InitTex:

; 212  : 		while(buffer[i] && isspace(buffer[i]))

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN5@PM_InitTex
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@PM_InitTex

; 213  : 			i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN4@PM_InitTex
$LN5@PM_InitTex:

; 214  : 		
; 215  : 		if (!buffer[i])

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN12@PM_InitTex

; 216  : 			continue;

	jmp	$LN2@PM_InitTex
$LN12@PM_InitTex:

; 217  : 
; 218  : 		// skip comment lines
; 219  : 		if (buffer[i] == '/' || !isalpha(buffer[i]))

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN14@PM_InitTex
	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	push	edx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@PM_InitTex
$LN14@PM_InitTex:

; 220  : 			continue;

	jmp	$LN2@PM_InitTex
$LN13@PM_InitTex:

; 221  : 
; 222  : 		// get texture type
; 223  : 		grgchTextureType[gcTextures] = toupper(buffer[i++]);

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	mov	DWORD PTR tv160[ebp], ecx
	mov	edx, DWORD PTR tv160[ebp]
	push	edx
	call	_toupper
	add	esp, 4
	mov	ecx, DWORD PTR ?gcTextures@@3HA
	mov	BYTE PTR ?grgchTextureType@@3PADA[ecx], al
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@PM_InitTex:

; 224  : 
; 225  : 		// skip whitespace
; 226  : 		while(buffer[i] && isspace(buffer[i]))

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN7@PM_InitTex
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@PM_InitTex

; 227  : 			i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN6@PM_InitTex
$LN7@PM_InitTex:

; 228  : 		
; 229  : 		if (!buffer[i])

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN15@PM_InitTex

; 230  : 			continue;

	jmp	$LN2@PM_InitTex
$LN15@PM_InitTex:

; 231  : 
; 232  : 		// get sentence name
; 233  : 		j = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], ecx
$LN8@PM_InitTex:

; 234  : 		while (buffer[j] && !isspace(buffer[j]))

	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	test	eax, eax
	je	SHORT $LN9@PM_InitTex
	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	push	edx
	call	_isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@PM_InitTex

; 235  : 			j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN8@PM_InitTex
$LN9@PM_InitTex:

; 236  : 
; 237  : 		if (!buffer[j])

	mov	ecx, DWORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN16@PM_InitTex

; 238  : 			continue;

	jmp	$LN2@PM_InitTex
$LN16@PM_InitTex:

; 239  : 
; 240  : 		// null-terminate name and save in sentences array
; 241  : 		j = min (j, CBTEXTURENAMEMAX-1+i);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR _j$[ebp], eax
	jge	SHORT $LN18@PM_InitTex
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv196[ebp], ecx
	jmp	SHORT $LN19@PM_InitTex
$LN18@PM_InitTex:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR tv196[ebp], edx
$LN19@PM_InitTex:
	mov	eax, DWORD PTR tv196[ebp]
	mov	DWORD PTR _j$[ebp], eax

; 242  : 		buffer[j] = 0;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 512			; 00000200H
	jae	SHORT $LN20@PM_InitTex
	jmp	SHORT $LN21@PM_InitTex
$LN20@PM_InitTex:
	call	___report_rangecheckfailure
$LN21@PM_InitTex:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _buffer$[ebp+edx], 0

; 243  : 		strcpy(&(grgszTextureName[gcTextures++][0]), &(buffer[i]));

	imul	eax, DWORD PTR ?gcTextures@@3HA, 13
	mov	ecx, 1
	imul	edx, ecx, 0
	lea	eax, DWORD PTR ?grgszTextureName@@3PAY0N@DA[eax+edx]
	mov	DWORD PTR tv208[ebp], eax
	mov	ecx, DWORD PTR ?gcTextures@@3HA
	add	ecx, 1
	mov	DWORD PTR ?gcTextures@@3HA, ecx
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR _buffer$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR tv208[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 244  : 	}

	jmp	$LN2@PM_InitTex
$LN3@PM_InitTex:

; 245  : 
; 246  : 	// Must use engine to free since we are in a .dll
; 247  : 	pmove->COM_FreeFile ( pMemFile );

	mov	edx, DWORD PTR _pMemFile$[ebp]
	push	edx
	mov	eax, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	ecx, DWORD PTR [eax+325032]
	call	ecx
	add	esp, 4

; 248  : 
; 249  : 	PM_SortTextures();

	call	?PM_SortTextures@@YAXXZ			; PM_SortTextures

; 250  : 
; 251  : 	bTextureTypeInit = true;

	mov	DWORD PTR ?bTextureTypeInit@?1??PM_InitTextureTypes@@YAXXZ@4HA, 1
$LN17@PM_InitTex:

; 252  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_InitTextureTypes@@YAXXZ ENDP			; PM_InitTextureTypes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
$T1 = -56						; size = 12
$T2 = -44						; size = 12
_curpos$3 = -32						; size = 12
_diff$ = -20						; size = 12
_len$ = -8						; size = 4
_curdist$ = -4						; size = 4
_start$ = 8						; size = 12
_end$ = 20						; size = 12
_pcolor$ = 32						; size = 4
?PM_ParticleLine@@YAXVVector@@0H@Z PROC			; PM_ParticleLine

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 168  : 	// determine distance;
; 169  : 	Vector diff = end - start;

	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR _diff$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _end$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 170  : 	float len = diff.Length();

	lea	ecx, DWORD PTR _diff$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _len$[ebp]

; 171  : 	diff = diff.Normalize();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _diff$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _diff$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _diff$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _diff$[ebp+8], eax

; 172  : 
; 173  : 	float curdist = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _curdist$[ebp], xmm0
$LN2@PM_Particl:

; 174  : 
; 175  : 	while( curdist <= len )

	movss	xmm0, DWORD PTR _len$[ebp]
	comiss	xmm0, DWORD PTR _curdist$[ebp]
	jb	SHORT $LN3@PM_Particl

; 176  : 	{
; 177  : 		Vector curpos = start + curdist * diff;

	lea	ecx, DWORD PTR _diff$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _curdist$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _curpos$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+

; 178  : 		pmove->PM_Particle( curpos, pcolor, 5, 0, 0 );

	push	0
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pcolor$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _curpos$3[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR ?pmove@@3PAUplayermove_s@@A ; pmove
	mov	eax, DWORD PTR [edx+324952]
	call	eax
	add	esp, 20					; 00000014H

; 179  : 		curdist += 0.5f;

	movss	xmm0, DWORD PTR _curdist$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _curdist$[ebp], xmm0

; 180  : 	}

	jmp	SHORT $LN2@PM_Particl
$LN3@PM_Particl:

; 181  : 
; 182  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_ParticleLine@@YAXVVector@@0H@Z ENDP			; PM_ParticleLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_j$1 = -8						; size = 4
_i$2 = -4						; size = 4
?PM_SortTextures@@YAXXZ PROC				; PM_SortTextures

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	// Bubble sort, yuck, but this only occurs at startup and it's only 512 elements...
; 147  : 	for( int i = 0; i < gcTextures; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@PM_SortTex
$LN2@PM_SortTex:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@PM_SortTex:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR ?gcTextures@@3HA
	jge	SHORT $LN1@PM_SortTex

; 148  : 	{
; 149  : 		for( int j = i + 1; j < gcTextures; j++ )

	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _j$1[ebp], edx
	jmp	SHORT $LN7@PM_SortTex
$LN5@PM_SortTex:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN7@PM_SortTex:
	mov	ecx, DWORD PTR _j$1[ebp]
	cmp	ecx, DWORD PTR ?gcTextures@@3HA
	jge	SHORT $LN6@PM_SortTex

; 150  : 		{
; 151  : 			if( Q_stricmp( grgszTextureName[i], grgszTextureName[j] ) > 0 )

	push	99999					; 0001869fH
	imul	edx, DWORD PTR _j$1[ebp], 13
	add	edx, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	edx
	imul	eax, DWORD PTR _i$2[ebp], 13
	add	eax, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN8@PM_SortTex

; 152  : 			{
; 153  : 				// Swap
; 154  : 				PM_SwapTextures( i, j );

	mov	ecx, DWORD PTR _j$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	call	?PM_SwapTextures@@YAXHH@Z		; PM_SwapTextures
	add	esp, 8
$LN8@PM_SortTex:

; 155  : 			}
; 156  : 		}

	jmp	SHORT $LN5@PM_SortTex
$LN6@PM_SortTex:

; 157  : 	}

	jmp	SHORT $LN2@PM_SortTex
$LN1@PM_SortTex:

; 158  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PM_SortTextures@@YAXXZ ENDP				; PM_SortTextures
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
_TEXT	SEGMENT
_chTemp$ = -21						; size = 1
_szTemp$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?PM_SwapTextures@@YAXHH@Z PROC				; PM_SwapTextures

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 131  : 	char chTemp;
; 132  : 	char szTemp[ CBTEXTURENAMEMAX ];
; 133  : 
; 134  : 	strcpy( szTemp, grgszTextureName[ i ] );

	imul	eax, DWORD PTR _i$[ebp], 13
	add	eax, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	eax
	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 135  : 	chTemp = grgchTextureType[ i ];

	mov	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR ?grgchTextureType@@3PADA[edx]
	mov	BYTE PTR _chTemp$[ebp], al

; 136  : 	
; 137  : 	strcpy( grgszTextureName[ i ], grgszTextureName[ j ] );

	imul	ecx, DWORD PTR _j$[ebp], 13
	add	ecx, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 13
	add	edx, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	edx
	call	_strcpy
	add	esp, 8

; 138  : 	grgchTextureType[ i ] = grgchTextureType[ j ];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR ?grgchTextureType@@3PADA[ecx]
	mov	BYTE PTR ?grgchTextureType@@3PADA[eax], dl

; 139  : 
; 140  : 	strcpy( grgszTextureName[ j ], szTemp );

	lea	eax, DWORD PTR _szTemp$[ebp]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 13
	add	ecx, OFFSET ?grgszTextureName@@3PAY0N@DA
	push	ecx
	call	_strcpy
	add	esp, 8

; 141  : 	grgchTextureType[ j ] = chTemp;

	mov	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR _chTemp$[ebp]
	mov	BYTE PTR ?grgchTextureType@@3PADA[edx], al

; 142  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?PM_SwapTextures@@YAXHH@Z ENDP				; PM_SwapTextures
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\playermove.cpp
;	COMDAT ??__Ergv3tStuckTable@@YAXXZ
text$di	SEGMENT
??__Ergv3tStuckTable@@YAXXZ PROC			; `dynamic initializer for 'rgv3tStuckTable'', COMDAT

; 118  : static Vector rgv3tStuckTable[54];

	push	ebp
	mov	ebp, esp
	push	OFFSET ??0Vector@@QAE@XZ		; Vector::Vector
	push	54					; 00000036H
	push	12					; 0000000cH
	push	OFFSET ?rgv3tStuckTable@@3PAVVector@@A
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	pop	ebp
	ret	0
??__Ergv3tStuckTable@@YAXXZ ENDP			; `dynamic initializer for 'rgv3tStuckTable''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0pmtrace_s@@QAE@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0pmtrace_s@@QAE@$$QAU0@@Z PROC			; pmtrace_s::pmtrace_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0pmplane_t@@QAE@$$QAU0@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0pmtrace_s@@QAE@$$QAU0@@Z ENDP			; pmtrace_s::pmtrace_s
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0pmtrace_s@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0pmtrace_s@@QAE@ABU0@@Z PROC				; pmtrace_s::pmtrace_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0pmplane_t@@QAE@ABU0@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0pmtrace_s@@QAE@ABU0@@Z ENDP				; pmtrace_s::pmtrace_s
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0pmtrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0pmtrace_s@@QAE@XZ PROC				; pmtrace_s::pmtrace_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0pmplane_t@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0pmtrace_s@@QAE@XZ ENDP				; pmtrace_s::pmtrace_s
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0pmplane_t@@QAE@$$QAU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0pmplane_t@@QAE@$$QAU0@@Z PROC			; pmplane_t::pmplane_t, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0pmplane_t@@QAE@$$QAU0@@Z ENDP			; pmplane_t::pmplane_t
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0pmplane_t@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0pmplane_t@@QAE@ABU0@@Z PROC				; pmplane_t::pmplane_t, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0pmplane_t@@QAE@ABU0@@Z ENDP				; pmplane_t::pmplane_t
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0pmplane_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0pmplane_t@@QAE@XZ PROC				; pmplane_t::pmplane_t, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0pmplane_t@@QAE@XZ ENDP				; pmplane_t::pmplane_t
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0trace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0trace_s@@QAE@XZ PROC					; trace_s::trace_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0plane_s@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0trace_s@@QAE@XZ ENDP					; trace_s::trace_s
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0plane_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0plane_s@@QAE@XZ PROC					; plane_s::plane_s, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0plane_s@@QAE@XZ ENDP					; plane_s::plane_s
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
tv1056 = -116						; size = 4
tv1054 = -112						; size = 4
tv1052 = -108						; size = 4
tv1050 = -104						; size = 4
tv1048 = -100						; size = 4
tv1046 = -96						; size = 4
tv1044 = -92						; size = 4
tv1042 = -88						; size = 4
tv1040 = -84						; size = 4
tv1038 = -80						; size = 4
tv1036 = -76						; size = 4
tv1034 = -72						; size = 4
tv1032 = -68						; size = 4
tv1030 = -64						; size = 4
tv1028 = -60						; size = 4
tv1026 = -56						; size = 4
tv1024 = -52						; size = 4
tv1022 = -48						; size = 4
tv1020 = -44						; size = 4
tv1018 = -40						; size = 4
tv1016 = -36						; size = 4
_cr$ = -32						; size = 4
_sr$ = -28						; size = 4
_cp$ = -24						; size = 4
_sp$ = -20						; size = 4
_angle$ = -16						; size = 4
_cy$ = -12						; size = 4
_sy$ = -8						; size = 4
_this$ = -4						; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
_scale$ = 16						; size = 4
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC			; matrix4x4::matrix4x4, COMDAT
; _this$ = ecx

; 690  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 691  : 	{
; 692  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 693  : 
; 694  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@matrix4x4

; 695  : 		{
; 696  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 697  : 			SinCos( angle, &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 698  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	imul	ecx, edx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 699  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 700  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 701  : 			SinCos( angle, &sr, &cr );

	lea	edx, DWORD PTR _cr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sr$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 702  : 
; 703  : 			mat[0][0] = (cp*cy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1016[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv1016[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 704  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sy$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR _cr$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1018[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv1018[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 705  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm2, DWORD PTR _sy$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1020[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR tv1020[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 706  : 			mat[3][0] = origin.x;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 707  : 			mat[0][1] = (cp*sy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 16					; 00000010H
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1022[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv1022[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 708  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR _cr$[ebp]
	mulss	xmm1, DWORD PTR _cy$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1024[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv1024[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 709  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	movss	xmm1, DWORD PTR _sr$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm1, DWORD PTR _cy$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1026[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv1026[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 710  : 			mat[3][1] = origin.y;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 711  : 			mat[0][2] = (-sp) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1028[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv1028[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 712  : 			mat[1][2] = (sr*cp) * scale;

	movss	xmm0, DWORD PTR _sr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1030[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv1030[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 713  : 			mat[2][2] = (cr*cp) * scale;

	movss	xmm0, DWORD PTR _cr$[ebp]
	mulss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1032[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv1032[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 714  : 			mat[3][2] = origin.z;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx

; 715  : 			mat[0][3] = 0;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 716  : 			mat[1][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 717  : 			mat[2][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 718  : 			mat[3][3] = 1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx], xmm0
	jmp	$LN7@matrix4x4
$LN2@matrix4x4:

; 719  : 		}
; 720  : 		else if( angles[PITCH] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@matrix4x4

; 721  : 		{
; 722  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 723  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 724  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 725  : 			SinCos( angle, &sp, &cp );

	lea	eax, DWORD PTR _cp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sp$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 726  : 
; 727  : 			mat[0][0] = (cp*cy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 16					; 00000010H
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1034[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv1034[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 728  : 			mat[1][0] = (-sy) * scale;

	movss	xmm0, DWORD PTR _sy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1036[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv1036[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 729  : 			mat[2][0] = (sp*cy) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1038[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv1038[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 730  : 			mat[3][0] = origin.x;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 731  : 			mat[0][1] = (cp*sy) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 16					; 00000010H
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1040[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv1040[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 732  : 			mat[1][1] = (cy) * scale;

	movss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1042[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv1042[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 733  : 			mat[2][1] = (sp*sy) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	mulss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1044[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv1044[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 734  : 			mat[3][1] = origin.y;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 735  : 			mat[0][2] = (-sp) * scale;

	movss	xmm0, DWORD PTR _sp$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1046[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv1046[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 736  : 			mat[1][2] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 737  : 			mat[2][2] = (cp) * scale;

	movss	xmm0, DWORD PTR _cp$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1048[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv1048[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 738  : 			mat[3][2] = origin.z;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx

; 739  : 			mat[0][3] = 0;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 740  : 			mat[1][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 741  : 			mat[2][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 742  : 			mat[3][3] = 1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx], xmm0
	jmp	$LN7@matrix4x4
$LN4@matrix4x4:

; 743  : 		}
; 744  : 		else if( angles[YAW] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@matrix4x4

; 745  : 		{
; 746  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	mulsd	xmm0, QWORD PTR __real@3f91df46a2529d39
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _angle$[ebp], xmm0

; 747  : 			SinCos( angle, &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 748  : 
; 749  : 			mat[0][0] = (cy) * scale;

	movss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 16					; 00000010H
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1050[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv1050[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 750  : 			mat[1][0] = (-sy) * scale;

	movss	xmm0, DWORD PTR _sy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1052[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv1052[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 751  : 			mat[2][0] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 752  : 			mat[3][0] = origin.x;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 753  : 			mat[0][1] = (sy) * scale;

	movss	xmm0, DWORD PTR _sy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 16					; 00000010H
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1054[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv1054[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 754  : 			mat[1][1] = (cy) * scale;

	movss	xmm0, DWORD PTR _cy$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv1056[ebp], xmm0
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv1056[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 755  : 			mat[2][1] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 756  : 			mat[3][1] = origin.y;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 757  : 			mat[0][2] = 0;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 758  : 			mat[1][2] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 759  : 			mat[2][2] = scale;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 760  : 			mat[3][2] = origin.z;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx

; 761  : 			mat[0][3] = 0;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 762  : 			mat[1][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 763  : 			mat[2][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 764  : 			mat[3][3] = 1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx], xmm0

; 765  : 		}
; 766  : 		else

	jmp	$LN7@matrix4x4
$LN6@matrix4x4:

; 767  : 		{
; 768  : 			mat[0][0] = scale;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 769  : 			mat[1][0] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 770  : 			mat[2][0] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 771  : 			mat[3][0] = origin.x;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx], ecx

; 772  : 			mat[0][1] = 0;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 773  : 			mat[1][1] = scale;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 774  : 			mat[2][1] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 775  : 			mat[3][1] = origin.y;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx], edx

; 776  : 			mat[0][2] = 0;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0

; 777  : 			mat[1][2] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 778  : 			mat[2][2] = scale;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 779  : 			mat[3][2] = origin.z;

	mov	edx, 16					; 00000010H
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx], edx

; 780  : 			mat[0][3] = 0;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 781  : 			mat[1][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 782  : 			mat[2][3] = 0;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 783  : 			mat[3][3] = 1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx], xmm0
$LN7@matrix4x4:

; 784  : 		}
; 785  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector4D@@QAEPAMXZ PROC				; Vector4D::operator float *, COMDAT
; _this$ = ecx

; 314  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector4D@@QAE@XZ PROC				; Vector4D::Vector4D, COMDAT
; _this$ = ecx

; 300  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC		; CrossProduct, COMDAT

; 280  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
tv86 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?DotProduct@@YAMABVVector@@0@Z PROC			; DotProduct, COMDAT

; 278  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR tv86[ebp], xmm0
	fld	DWORD PTR tv86[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AVVector@@MABV0@@Z PROC				; operator*, COMDAT

; 277  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fl$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flLen$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Normalize@Vector@@QBE?AV1@XZ PROC			; Vector::Normalize, COMDAT
; _this$ = ecx

; 229  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 231  : 
; 232  : 		if( flLen )

	movss	xmm0, DWORD PTR _flLen$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 233  : 		{
; 234  : 			flLen = 1.0f / flLen;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _flLen$[ebp]
	movss	DWORD PTR _flLen$[ebp], xmm0

; 235  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Normalize
$LN2@Normalize:

; 236  : 		}
; 237  : 
; 238  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Normalize:

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QBEPBMXZ PROC				; Vector::operator float const *, COMDAT
; _this$ = ecx

; 226  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
?Length@Vector@@QBEMXZ PROC				; Vector::Length, COMDAT
; _this$ = ecx

; 223  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv91[ebp]
	fld	DWORD PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??XVector@@QAEAAV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector@@QAEAAV0@M@Z PROC				; Vector::operator*=, COMDAT
; _this$ = ecx

; 171  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 		x *= s; y *= s; z *= s;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 173  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 174  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector@@QAEAAV0@M@Z ENDP				; Vector::operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??ZVector@@QAEAAV0@ABV0@@Z PROC				; Vector::operator-=, COMDAT
; _this$ = ecx

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 		x-=v.x; y-=v.y; z -= v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 163  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 164  : 	}		

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??YVector@@QAEAAV0@ABV0@@Z PROC				; Vector::operator+=, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 158  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 159  : 	}			

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
??DVector@@QBE?AV0@M@Z PROC				; Vector::operator*, COMDAT
; _this$ = ecx

; 150  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator+, COMDAT
; _this$ = ecx

; 146  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_v$ = 8							; size = 4
??9Vector@@QBEHABV0@@Z PROC				; Vector::operator!=, COMDAT
; _this$ = ecx

; 145  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv68[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??8Vector@@QBEHABV0@@Z PROC				; Vector::operator==, COMDAT
; _this$ = ecx

; 144  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, DWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	ucomiss	xmm0, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	ucomiss	xmm0, DWORD PTR [edx+8]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv73[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
_sine$ = 12						; size = 4
_cosine$ = 16						; size = 4
?SinCos@@YAXMPAM0@Z PROC				; SinCos, COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp

; 34   : 	__asm
; 35   : 	{
; 36   : 		push	ecx

	push	ecx

; 37   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 38   : 		fsincos

	fsincos

; 39   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 40   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 41   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 42   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 43   : 		pop	ecx

	pop	ecx

; 44   : 	}
; 45   : }

	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
