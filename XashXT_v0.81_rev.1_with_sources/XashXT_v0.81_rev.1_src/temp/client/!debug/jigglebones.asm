; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\game_shared\jigglebones.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG14398 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14399 DB	'n', 00H, 'G', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H
	ORG $+2
$SG14451 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14452 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG14456 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14457 DB	'I', 00H, 's', 00H, 'I', 00H, 'n', 00H, 'L', 00H, 'i', 00H
	DB	's', 00H, 't', 00H, '(', 00H, 'a', 00H, 'f', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, ')', 00H, 00H, 00H
$SG14475 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14476 DB	'm', 00H, '_', 00H, 'T', 00H, 'o', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'E', 00H, 'l', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '(', 00H
	DB	')', 00H, 00H, 00H
$SG14578 DB	'0', 00H, 00H, 00H
$SG14477 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14478 DB	'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, '(', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG14522 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14523 DB	'I', 00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '('
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG14574 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14575 DB	'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
$SG14577 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14583 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14584 DB	'0', 00H, 00H, 00H
$SG14588 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG14587 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14589 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H
	DB	'0', 00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e'
	DB	00H, 'v', 00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H
	DB	's', 00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0'
	DB	00H, '.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, '.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c'
	DB	00H, '\', 00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\'
	DB	00H, 'u', 00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG14590 DB	'm', 00H, '_', 00H, 'p', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@PBM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@QAM@Z				; Vector::Vector
PUBLIC	?Init@Vector@@QAEXMMM@Z				; Vector::Init
PUBLIC	??GVector@@QBE?AV0@XZ				; Vector::operator-
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??KVector@@QBE?AV0@M@Z				; Vector::operator/
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	??ZVector@@QAEAAV0@ABV0@@Z			; Vector::operator-=
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	?CrossProduct@@YA?AVVector@@ABV1@0@Z		; CrossProduct
PUBLIC	??0matrix3x4@@QAE@MMMMMMMMMMMM@Z		; matrix3x4::matrix3x4
PUBLIC	??Amatrix3x4@@QAEPAMH@Z				; matrix3x4::operator[]
PUBLIC	??Amatrix3x4@@QBEPBMH@Z				; matrix3x4::operator[]
PUBLIC	?SetForward@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetForward
PUBLIC	?SetRight@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetRight
PUBLIC	?SetUp@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetUp
PUBLIC	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z		; matrix3x4::SetOrigin
PUBLIC	?Transpose@matrix3x4@@QBE?AV1@XZ		; matrix3x4::Transpose
PUBLIC	??0matrix3x4@@QAE@ABV0@@Z			; matrix3x4::matrix3x4
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	?Init@JiggleData@@QAEXHMABVVector@@0@Z		; JiggleData::Init
PUBLIC	??0JiggleData@@QAE@XZ				; JiggleData::JiggleData
PUBLIC	??0JiggleData@@QAE@ABU0@@Z			; JiggleData::JiggleData
PUBLIC	?GetJiggleData@CJiggleBones@@QAEPAUJiggleData@@HMABVVector@@0@Z ; CJiggleBones::GetJiggleData
PUBLIC	?BuildJiggleTransformations@CJiggleBones@@QAEXHMPBUmstudiojigglebone_t@@ABVmatrix3x4@@AAV3@@Z ; CJiggleBones::BuildJiggleTransformations
PUBLIC	?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::Element
PUBLIC	??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::operator[]
PUBLIC	?InsertAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEGGABUJiggleData@@@Z ; CUtlLinkedList<JiggleData,unsigned short>::InsertAfter
PUBLIC	?AddToHead@?$CUtlLinkedList@UJiggleData@@G@@QAEGABUJiggleData@@@Z ; CUtlLinkedList<JiggleData,unsigned short>::AddToHead
PUBLIC	?LinkAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEXGG@Z ; CUtlLinkedList<JiggleData,unsigned short>::LinkAfter
PUBLIC	?Unlink@?$CUtlLinkedList@UJiggleData@@G@@QAEXG@Z ; CUtlLinkedList<JiggleData,unsigned short>::Unlink
PUBLIC	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
PUBLIC	?Head@?$CUtlLinkedList@UJiggleData@@G@@QBEGXZ	; CUtlLinkedList<JiggleData,unsigned short>::Head
PUBLIC	?Previous@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z ; CUtlLinkedList<JiggleData,unsigned short>::Previous
PUBLIC	?Next@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z	; CUtlLinkedList<JiggleData,unsigned short>::Next
PUBLIC	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
PUBLIC	?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsInList
PUBLIC	?AllocInternal@?$CUtlLinkedList@UJiggleData@@G@@IAEG_N@Z ; CUtlLinkedList<JiggleData,unsigned short>::AllocInternal
PUBLIC	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
PUBLIC	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
PUBLIC	?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
PUBLIC	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
PUBLIC	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
PUBLIC	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
PUBLIC	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Grow
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated
PUBLIC	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
PUBLIC	??$CopyConstruct@UJiggleData@@@@YAXPAUJiggleData@@ABU0@@Z ; CopyConstruct<JiggleData>
PUBLIC	??_C@_1NG@CGIDIBCB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ ; `string'
PUBLIC	??_C@_1CA@DONHBKAI@?$AAI?$AAs?$AAV?$AAa?$AAl?$AAi?$AAd?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$CI?$AAi?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ ; `string'
PUBLIC	??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3d086595
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fecccccc0000000
PUBLIC	__real@401921fb54442d18
PUBLIC	__real@40a00000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__wassert:PROC
EXTRN	_acos:PROC
EXTRN	_atan2:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	??0matrix3x4@@QAE@XZ:PROC			; matrix3x4::matrix3x4
EXTRN	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z:PROC	; matrix3x4::ConcatTransforms
EXTRN	?ConcatTransforms@matrix3x4@@QBE?AV1@V1@@Z:PROC	; matrix3x4::ConcatTransforms
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@401921fb54442d18
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT __real@3fecccccc0000000
CONST	SEGMENT
__real@3fecccccc0000000 DQ 03fecccccc0000000r	; 0.9
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d086595
CONST	SEGMENT
__real@3d086595 DD 03d086595r			; 0.0333
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@ DB '!'
	DB	00H, 'I', 00H, 's', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H
	DB	'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H, '(', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@ DB 'I'
	DB	00H, 's', 00H, 'I', 00H, 'd', 00H, 'x', 00H, 'V', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, '(', 00H, 'i', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
CONST	SEGMENT
??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's'
	DB	00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H
	DB	'.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v'
	DB	00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H, '.'
	DB	00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\'
	DB	00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'u'
	DB	00H, 't', 00H, 'l', 00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DONHBKAI@?$AAI?$AAs?$AAV?$AAa?$AAl?$AAi?$AAd?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$CI?$AAi?$AA?$CJ@
CONST	SEGMENT
??_C@_1CA@DONHBKAI@?$AAI?$AAs?$AAV?$AAa?$AAl?$AAi?$AAd?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$CI?$AAi?$AA?$CJ@ DB 'I'
	DB	00H, 's', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '(', 00H, 'i'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1NG@CGIDIBCB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
CONST	SEGMENT
??_C@_1NG@CGIDIBCB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's'
	DB	00H, 'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H
	DB	'.', 00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v'
	DB	00H, '.', 00H, '1', 00H, '_', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'h', 00H, '_', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'x', 00H, 'a', 00H, 's', 00H
	DB	'h', 00H, 'x', 00H, 't', 00H, '_', 00H, 'v', 00H, '0', 00H, '.'
	DB	00H, '8', 00H, '1', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'.', 00H, '1', 00H, '_', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\'
	DB	00H, 'g', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'u'
	DB	00H, 't', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H
	DB	'e', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??$CopyConstruct@UJiggleData@@@@YAXPAUJiggleData@@ABU0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pMemory$ = 8						; size = 4
_src$ = 12						; size = 4
??$CopyConstruct@UJiggleData@@@@YAXPAUJiggleData@@ABU0@@Z PROC ; CopyConstruct<JiggleData>, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	148					; 00000094H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0JiggleData@@QAE@ABU0@@Z

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$CopyConstruct@UJiggleData@@@@YAXPAUJiggleData@@ABU0@@Z ENDP ; CopyConstruct<JiggleData>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly, COMDAT
; _this$ = ecx

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	jne	SHORT $LN3@IsReadOnly
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsReadOnly
$LN3@IsReadOnly:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsReadOnly:
	mov	al, BYTE PTR tv66[ebp]

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jge	SHORT $LN3@IsExternal
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsExternal
$LN3@IsExternal:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsExternal:
	mov	al, BYTE PTR tv66[ebp]

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXH@Z
_TEXT	SEGMENT
_nAllocationRequested$ = -8				; size = 4
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXH@Z PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Grow, COMDAT
; _this$ = ecx

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $LN12@Grow
	push	561					; 00000231H
	push	OFFSET $SG14574
	push	OFFSET $SG14575
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@Grow:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsExternallyAllocated
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Grow

; 564  : 	{
; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	edx, edx
	jne	SHORT $LN13@Grow
	push	566					; 00000236H
	push	OFFSET $SG14577
	push	OFFSET $SG14578
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@Grow:

; 567  : 		return;

	jmp	$LN1@Grow
$LN4@Grow:

; 568  : 	}
; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], edx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	152					; 00000098H
	mov	eax, DWORD PTR _nAllocationRequested$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $LN5@Grow

; 578  : 	{
; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN6@Grow
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $LN6@Grow

; 580  : 		{
; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 582  : 		}
; 583  : 		else

	jmp	SHORT $LN5@Grow
$LN6@Grow:

; 584  : 		{
; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $LN2@Grow

; 586  : 			{
; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	eax, eax
	jne	SHORT $LN14@Grow
	push	588					; 0000024cH
	push	OFFSET $SG14583
	push	OFFSET $SG14584
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Grow:

; 589  : 				return;

	jmp	$LN1@Grow
$LN2@Grow:

; 590  : 			}
; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $LN5@Grow

; 592  : 			{
; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 594  : 			}

	jmp	SHORT $LN2@Grow
$LN5@Grow:

; 595  : 		}
; 596  : 	}
; 597  : 
; 598  : 	if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@Grow

; 599  : 	{
; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [ecx+4], 152
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 601  : 		assert( m_pMemory );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN15@Grow
	push	601					; 00000259H
	push	OFFSET $SG14587
	push	OFFSET $SG14588
	call	__wassert
	add	esp, 12					; 0000000cH
$LN15@Grow:

; 602  : 	}
; 603  : 	else

	jmp	SHORT $LN1@Grow
$LN9@Grow:

; 604  : 	{
; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+4], 152
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@Grow
	push	606					; 0000025eH
	push	OFFSET $SG14589
	push	OFFSET $SG14590
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@Grow:

; 607  : 	}
; 608  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXH@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEHXZ PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::NumAllocated, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEHXZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::NumAllocated
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base, COMDAT
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Base
	push	488					; 000001e8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Base:

; 489  : 	return m_pMemory;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 490  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_i$ = 8							; size = 4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid, COMDAT
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@IsIdxValid
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN3@IsIdxValid
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsIdxValid
$LN3@IsIdxValid:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsIdxValid:
	mov	al, BYTE PTR tv67[ebp]

; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[], COMDAT
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	push	432					; 000001b0H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 433  : 	return m_pMemory[i];

	imul	eax, DWORD PTR _i$[ebp], 152
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z PROC ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[], COMDAT
; _this$ = ecx

; 423  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsReadOnly
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	push	424					; 000001a8H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@PFNFCCHH@?$AA?$CB?$AAI?$AAs?$AAR?$AAe?$AAa?$AAd?$AAO?$AAn?$AAl?$AAy?$AA?$CI?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 425  : 	assert( IsIdxValid(i) );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBE_NH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::IsIdxValid
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	push	425					; 000001a9H
	push	OFFSET ??_C@_1MO@LCPOAHHB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1BM@CKILBAKK@?$AAI?$AAs?$AAI?$AAd?$AAx?$AAV?$AAa?$AAl?$AAi?$AAd?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@operator:

; 426  : 	return m_pMemory[i];

	imul	eax, DWORD PTR _i$[ebp], 152
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ENDP ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ PROC ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		m_pElements = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ENDP ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IBEABUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IBEABUListElem_t@1@G@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement, COMDAT
; _this$ = ecx

; 136  : 	ListElem_t const& InternalElement( I i ) const { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IBEABUListElem_t@1@G@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement, COMDAT
; _this$ = ecx

; 135  : 	ListElem_t& InternalElement( I i ) { return m_Memory[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?AllocInternal@?$CUtlLinkedList@UJiggleData@@G@@IAEG_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv156 = -6						; size = 2
_elem$ = -4						; size = 2
_multilist$ = 8						; size = 1
?AllocInternal@?$CUtlLinkedList@UJiggleData@@G@@IAEG_N@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::AllocInternal, COMDAT
; _this$ = ecx

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	I elem;
; 337  : 	if (m_FirstFree == InvalidIndex())

	mov	eax, DWORD PTR _this$[ebp]
	movzx	esi, WORD PTR [eax+16]
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	ecx, ax
	cmp	esi, ecx
	jne	$LN2@AllocInter

; 338  : 	{
; 339  : 		// Nothing in the free list; add.
; 340  : 		// Since nothing is in the free list, m_TotalElements == total # of elements
; 341  : 		// the list knows about.
; 342  : 		if (m_TotalElements == m_Memory.NumAllocated())

	mov	edx, DWORD PTR _this$[ebp]
	movzx	esi, WORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEHXZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::NumAllocated
	cmp	esi, eax
	jne	SHORT $LN4@AllocInter

; 343  : 			m_Memory.Grow();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEXH@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Grow
$LN4@AllocInter:

; 344  : 
; 345  : 		assert( m_TotalElements != InvalidIndex() );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	esi, WORD PTR [eax+20]
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	ecx, ax
	cmp	esi, ecx
	jne	SHORT $LN8@AllocInter
	push	345					; 00000159H
	push	OFFSET $SG14475
	push	OFFSET $SG14476
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@AllocInter:

; 346  : 
; 347  : 		elem = (I)m_TotalElements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+20]
	mov	WORD PTR _elem$[ebp], cx

; 348  : 		++m_TotalElements;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+20]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+20], ax

; 349  : 
; 350  : 		assert( elem != InvalidIndex() );

	movzx	esi, WORD PTR _elem$[ebp]
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	edx, ax
	cmp	esi, edx
	jne	SHORT $LN9@AllocInter
	push	350					; 0000015eH
	push	OFFSET $SG14477
	push	OFFSET $SG14478
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@AllocInter:

; 351  : 	} 
; 352  : 	else

	jmp	SHORT $LN3@AllocInter
$LN2@AllocInter:

; 353  : 	{
; 354  : 		elem = m_FirstFree;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR _elem$[ebp], dx

; 355  : 		m_FirstFree = InternalElement(m_FirstFree).m_Next;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+150]
	mov	WORD PTR [edx+16], ax
$LN3@AllocInter:

; 356  : 	}
; 357  : 	
; 358  : 	if (!multilist)

	movzx	ecx, BYTE PTR _multilist$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@AllocInter

; 359  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = elem;

	movzx	edx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+148], cx
	movzx	edx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+150], cx

; 360  : 	else

	jmp	SHORT $LN6@AllocInter
$LN5@AllocInter:

; 361  : 		InternalElement(elem).m_Next = InternalElement(elem).m_Previous = InvalidIndex();

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	mov	WORD PTR tv156[ebp], ax
	movzx	edx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	cx, WORD PTR tv156[ebp]
	mov	WORD PTR [eax+148], cx
	movzx	edx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	cx, WORD PTR tv156[ebp]
	mov	WORD PTR [eax+150], cx
$LN6@AllocInter:

; 362  : 
; 363  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlLinkedList@UJiggleData@@G@@IAEXXZ ; CUtlLinkedList<JiggleData,unsigned short>::ResetDbgInfo

; 364  : 
; 365  : 	return elem;

	mov	ax, WORD PTR _elem$[ebp]

; 366  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocInternal@?$CUtlLinkedList@UJiggleData@@G@@IAEG_N@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::AllocInternal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::IsInList, COMDAT
; _this$ = ecx

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	return (i < m_TotalElements) && (i >= 0) && (Previous(i) != i);

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $LN3@IsInList
	movzx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jl	SHORT $LN3@IsInList
	movzx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Previous@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z ; CUtlLinkedList<JiggleData,unsigned short>::Previous
	movzx	edx, ax
	movzx	eax, WORD PTR _i$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@IsInList
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@IsInList
$LN3@IsInList:
	mov	DWORD PTR tv76[ebp], 0
$LN4@IsInList:
	mov	al, BYTE PTR tv76[ebp]

; 286  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::IsInList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex, COMDAT
; _this$ = ecx

; 277  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return (i < m_TotalElements) && (i >= 0) &&

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+20]
	cmp	eax, edx
	jge	SHORT $LN3@IsValidInd
	movzx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jl	SHORT $LN3@IsValidInd
	movzx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	movzx	edx, WORD PTR [eax+148]
	movzx	eax, WORD PTR _i$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@IsValidInd
	movzx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QBEABUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]
	movzx	edx, WORD PTR [eax+150]
	movzx	eax, WORD PTR _i$[ebp]
	cmp	edx, eax
	jne	SHORT $LN3@IsValidInd
$LN4@IsValidInd:
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN5@IsValidInd
$LN3@IsValidInd:
	mov	DWORD PTR tv88[ebp], 0
$LN5@IsValidInd:
	mov	al, BYTE PTR tv88[ebp]

; 279  : 		((m_Memory[i].m_Previous != i) || (m_Memory[i].m_Next == i));
; 280  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?Next@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?Next@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z PROC	; CUtlLinkedList<JiggleData,unsigned short>::Next, COMDAT
; _this$ = ecx

; 265  : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	assert( IsValidIndex(i) ); 

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Next
	push	266					; 0000010aH
	push	OFFSET ??_C@_1NG@CGIDIBCB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1CA@DONHBKAI@?$AAI?$AAs?$AAV?$AAa?$AAl?$AAi?$AAd?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Next:

; 267  : 	return InternalElement(i).m_Next; 

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+150]

; 268  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Next@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z ENDP	; CUtlLinkedList<JiggleData,unsigned short>::Next
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?Previous@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?Previous@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z PROC	; CUtlLinkedList<JiggleData,unsigned short>::Previous, COMDAT
; _this$ = ecx

; 258  : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	assert( IsValidIndex(i) ); 

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Previous
	push	259					; 00000103H
	push	OFFSET ??_C@_1NG@CGIDIBCB@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAu?$AAs?$AAe?$AAr?$AA?2?$AAd@
	push	OFFSET ??_C@_1CA@DONHBKAI@?$AAI?$AAs?$AAV?$AAa?$AAl?$AAi?$AAd?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$CI?$AAi?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Previous:

; 260  : 	return InternalElement(i).m_Previous; 

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IBEABUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	ax, WORD PTR [eax+148]

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Previous@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z ENDP	; CUtlLinkedList<JiggleData,unsigned short>::Previous
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?Head@?$CUtlLinkedList@UJiggleData@@G@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Head@?$CUtlLinkedList@UJiggleData@@G@@QBEGXZ PROC	; CUtlLinkedList<JiggleData,unsigned short>::Head, COMDAT
; _this$ = ecx

; 246  : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	return m_Head; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+12]

; 248  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Head@?$CUtlLinkedList@UJiggleData@@G@@QBEGXZ ENDP	; CUtlLinkedList<JiggleData,unsigned short>::Head
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ
_TEXT	SEGMENT
?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ PROC ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex, COMDAT

; 100  : 	inline static I  InvalidIndex()  { return INVALID_LLIST_IDX; }

	push	ebp
	mov	ebp, esp
	mov	eax, 65535				; 0000ffffH
	pop	ebp
	ret	0
?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ENDP ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?Unlink@?$CUtlLinkedList@UJiggleData@@G@@QAEXG@Z
_TEXT	SEGMENT
_pBase$1 = -12						; size = 4
_this$ = -8						; size = 4
_pOldElem$2 = -4					; size = 4
_elem$ = 8						; size = 2
?Unlink@?$CUtlLinkedList@UJiggleData@@G@@QAEXG@Z PROC	; CUtlLinkedList<JiggleData,unsigned short>::Unlink, COMDAT
; _this$ = ecx

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 	assert( IsValidIndex(elem) );

	movzx	eax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@Unlink
	push	638					; 0000027eH
	push	OFFSET $SG14522
	push	OFFSET $SG14523
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@Unlink:

; 639  : 	if (IsInList(elem))

	movzx	eax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsInList
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@Unlink

; 640  : 	{
; 641  : 		ListElem_t *pBase = m_Memory.Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEPAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@XZ ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::Base
	mov	DWORD PTR _pBase$1[ebp], eax

; 642  : 		ListElem_t *pOldElem = &pBase[elem];

	movzx	edx, WORD PTR _elem$[ebp]
	imul	eax, edx, 152
	add	eax, DWORD PTR _pBase$1[ebp]
	mov	DWORD PTR _pOldElem$2[ebp], eax

; 643  : 		
; 644  : 		// If we're the first guy, reset the head
; 645  : 		// otherwise, make our previous node's next pointer = our next
; 646  : 		if ( pOldElem->m_Previous != INVALID_LLIST_IDX )

	mov	ecx, DWORD PTR _pOldElem$2[ebp]
	movzx	edx, WORD PTR [ecx+148]
	cmp	edx, 65535				; 0000ffffH
	je	SHORT $LN3@Unlink

; 647  : 		{
; 648  : 			pBase[pOldElem->m_Previous].m_Next = pOldElem->m_Next;

	mov	eax, DWORD PTR _pOldElem$2[ebp]
	movzx	ecx, WORD PTR [eax+148]
	imul	edx, ecx, 152
	mov	eax, DWORD PTR _pBase$1[ebp]
	mov	ecx, DWORD PTR _pOldElem$2[ebp]
	mov	cx, WORD PTR [ecx+150]
	mov	WORD PTR [eax+edx+150], cx

; 649  : 		}
; 650  : 		else

	jmp	SHORT $LN4@Unlink
$LN3@Unlink:

; 651  : 		{
; 652  : 			m_Head = pOldElem->m_Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pOldElem$2[ebp]
	mov	cx, WORD PTR [eax+150]
	mov	WORD PTR [edx+12], cx
$LN4@Unlink:

; 653  : 		}
; 654  : 		
; 655  : 		// If we're the last guy, reset the tail
; 656  : 		// otherwise, make our next node's prev pointer = our prev
; 657  : 		if ( pOldElem->m_Next != INVALID_LLIST_IDX )

	mov	edx, DWORD PTR _pOldElem$2[ebp]
	movzx	eax, WORD PTR [edx+150]
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $LN5@Unlink

; 658  : 		{
; 659  : 			pBase[pOldElem->m_Next].m_Previous = pOldElem->m_Previous;

	mov	ecx, DWORD PTR _pOldElem$2[ebp]
	movzx	edx, WORD PTR [ecx+150]
	imul	eax, edx, 152
	mov	ecx, DWORD PTR _pBase$1[ebp]
	mov	edx, DWORD PTR _pOldElem$2[ebp]
	mov	dx, WORD PTR [edx+148]
	mov	WORD PTR [ecx+eax+148], dx

; 660  : 		}
; 661  : 		else

	jmp	SHORT $LN6@Unlink
$LN5@Unlink:

; 662  : 		{
; 663  : 			m_Tail = pOldElem->m_Previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pOldElem$2[ebp]
	mov	dx, WORD PTR [ecx+148]
	mov	WORD PTR [eax+14], dx
$LN6@Unlink:

; 664  : 		}
; 665  : 		
; 666  : 		// This marks this node as not in the list, 
; 667  : 		// but not in the free list either
; 668  : 		pOldElem->m_Previous = pOldElem->m_Next = elem;

	mov	eax, DWORD PTR _pOldElem$2[ebp]
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+150], cx
	mov	edx, DWORD PTR _pOldElem$2[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+148], ax

; 669  : 		
; 670  : 		// One less puppy
; 671  : 		--m_ElementCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+18]
	sub	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], dx
$LN1@Unlink:

; 672  : 	}
; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Unlink@?$CUtlLinkedList@UJiggleData@@G@@QAEXG@Z ENDP	; CUtlLinkedList<JiggleData,unsigned short>::Unlink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?LinkAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEXGG@Z
_TEXT	SEGMENT
_afterElem$1 = -12					; size = 4
_newElem$ = -8						; size = 4
_this$ = -4						; size = 4
_after$ = 8						; size = 2
_elem$ = 12						; size = 2
?LinkAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEXGG@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::LinkAfter, COMDAT
; _this$ = ecx

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 	assert( IsValidIndex(elem) );

	movzx	eax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsValidIndex
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@LinkAfter
	push	599					; 00000257H
	push	OFFSET $SG14451
	push	OFFSET $SG14452
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@LinkAfter:

; 600  : 	
; 601  : 	// Unlink it if it's in the list at the moment
; 602  : 	if ( IsInList(elem) )

	movzx	eax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsInList
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@LinkAfter

; 603  : 		Unlink(elem);

	movzx	edx, WORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlink@?$CUtlLinkedList@UJiggleData@@G@@QAEXG@Z ; CUtlLinkedList<JiggleData,unsigned short>::Unlink
$LN2@LinkAfter:

; 604  : 	
; 605  : 	ListElem_t& newElem = InternalElement(elem);

	movzx	eax, WORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	DWORD PTR _newElem$[ebp], eax

; 606  : 	
; 607  : 	// The element *before* our newly linked one is the one we linked after
; 608  : 	newElem.m_Previous = after;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	dx, WORD PTR _after$[ebp]
	mov	WORD PTR [ecx+148], dx

; 609  : 	if (after == InvalidIndex())

	movzx	esi, WORD PTR _after$[ebp]
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	eax, ax
	cmp	esi, eax
	jne	SHORT $LN3@LinkAfter

; 610  : 	{
; 611  : 		// In this case, we're linking to the head of the list, reset the head
; 612  : 		newElem.m_Next = m_Head;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+12]
	mov	WORD PTR [ecx+150], ax

; 613  : 		m_Head = elem;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+12], dx

; 614  : 	}
; 615  : 	else

	jmp	SHORT $LN4@LinkAfter
$LN3@LinkAfter:

; 616  : 	{
; 617  : 		// Here, we're not linking to the end. Set the next pointer to point to
; 618  : 		// the element we're linking.
; 619  : 		assert( IsInList(after) );

	movzx	eax, WORD PTR _after$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsInList@?$CUtlLinkedList@UJiggleData@@G@@QBE_NG@Z ; CUtlLinkedList<JiggleData,unsigned short>::IsInList
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@LinkAfter
	push	619					; 0000026bH
	push	OFFSET $SG14456
	push	OFFSET $SG14457
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@LinkAfter:

; 620  : 		ListElem_t& afterElem = InternalElement(after);

	movzx	eax, WORD PTR _after$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	DWORD PTR _afterElem$1[ebp], eax

; 621  : 		newElem.m_Next = afterElem.m_Next;

	mov	ecx, DWORD PTR _newElem$[ebp]
	mov	edx, DWORD PTR _afterElem$1[ebp]
	mov	ax, WORD PTR [edx+150]
	mov	WORD PTR [ecx+150], ax

; 622  : 		afterElem.m_Next = elem;

	mov	ecx, DWORD PTR _afterElem$1[ebp]
	mov	dx, WORD PTR _elem$[ebp]
	mov	WORD PTR [ecx+150], dx
$LN4@LinkAfter:

; 623  : 	}
; 624  : 	
; 625  : 	// Reset the tail if we linked to the tail of the list
; 626  : 	if (newElem.m_Next == InvalidIndex())

	mov	eax, DWORD PTR _newElem$[ebp]
	movzx	esi, WORD PTR [eax+150]
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	ecx, ax
	cmp	esi, ecx
	jne	SHORT $LN5@LinkAfter

; 627  : 		m_Tail = elem;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _elem$[ebp]
	mov	WORD PTR [edx+14], ax

; 628  : 	else

	jmp	SHORT $LN6@LinkAfter
$LN5@LinkAfter:

; 629  : 		InternalElement(newElem.m_Next).m_Previous = elem;

	mov	ecx, DWORD PTR _newElem$[ebp]
	movzx	edx, WORD PTR [ecx+150]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalElement@?$CUtlLinkedList@UJiggleData@@G@@IAEAAUListElem_t@1@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::InternalElement
	mov	cx, WORD PTR _elem$[ebp]
	mov	WORD PTR [eax+148], cx
$LN6@LinkAfter:

; 630  : 	
; 631  : 	// one more element baby
; 632  : 	++m_ElementCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+18]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 633  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEXGG@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::LinkAfter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?AddToHead@?$CUtlLinkedList@UJiggleData@@G@@QAEGABUJiggleData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_src$ = 8						; size = 4
?AddToHead@?$CUtlLinkedList@UJiggleData@@G@@QAEGABUJiggleData@@@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::AddToHead, COMDAT
; _this$ = ecx

; 472  : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 473  : 	return InsertAfter( InvalidIndex(), src ); 

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	ecx, ax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEGGABUJiggleData@@@Z ; CUtlLinkedList<JiggleData,unsigned short>::InsertAfter

; 474  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddToHead@?$CUtlLinkedList@UJiggleData@@G@@QAEGABUJiggleData@@@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::AddToHead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?InsertAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEGGABUJiggleData@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_newNode$ = -4						; size = 2
_after$ = 8						; size = 2
_src$ = 12						; size = 4
?InsertAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEGGABUJiggleData@@@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::InsertAfter, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	// Make a new node
; 459  : 	I   newNode = AllocInternal();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocInternal@?$CUtlLinkedList@UJiggleData@@G@@IAEG_N@Z ; CUtlLinkedList<JiggleData,unsigned short>::AllocInternal
	mov	WORD PTR _newNode$[ebp], ax

; 460  : 	
; 461  : 	// Link it in
; 462  : 	LinkAfter( after, newNode );

	movzx	eax, WORD PTR _newNode$[ebp]
	push	eax
	movzx	ecx, WORD PTR _after$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEXGG@Z ; CUtlLinkedList<JiggleData,unsigned short>::LinkAfter

; 463  : 	
; 464  : 	// Construct the data
; 465  : 	CopyConstruct( &Element(newNode), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	movzx	eax, WORD PTR _newNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::Element
	push	eax
	call	??$CopyConstruct@UJiggleData@@@@YAXPAUJiggleData@@ABU0@@Z ; CopyConstruct<JiggleData>
	add	esp, 8

; 466  : 	
; 467  : 	return newNode;

	mov	ax, WORD PTR _newNode$[ebp]

; 468  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?InsertAfter@?$CUtlLinkedList@UJiggleData@@G@@QAEGGABUJiggleData@@@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::InsertAfter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::operator[], COMDAT
; _this$ = ecx

; 213  : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	return m_Memory[i].m_Element; 

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]

; 215  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utllinkedlist.h
;	COMDAT ?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z PROC ; CUtlLinkedList<JiggleData,unsigned short>::Element, COMDAT
; _this$ = ecx

; 201  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 	return m_Memory[i].m_Element; 

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@@QAEAAUListElem_t@?$CUtlLinkedList@UJiggleData@@G@@H@Z ; CUtlMemory<CUtlLinkedList<JiggleData,unsigned short>::ListElem_t,int>::operator[]

; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ENDP ; CUtlLinkedList<JiggleData,unsigned short>::Element
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\jigglebones.cpp
_TEXT	SEGMENT
$T1 = -2380						; size = 12
$T2 = -2368						; size = 12
$T3 = -2356						; size = 12
$T4 = -2344						; size = 12
$T5 = -2332						; size = 12
$T6 = -2320						; size = 12
$T7 = -2308						; size = 12
$T8 = -2296						; size = 12
$T9 = -2284						; size = 12
$T10 = -2272						; size = 12
$T11 = -2260						; size = 12
$T12 = -2248						; size = 12
$T13 = -2236						; size = 12
$T14 = -2224						; size = 12
$T15 = -2212						; size = 12
$T16 = -2200						; size = 12
$T17 = -2188						; size = 12
$T18 = -2176						; size = 12
$T19 = -2164						; size = 12
$T20 = -2152						; size = 12
$T21 = -2140						; size = 12
$T22 = -2128						; size = 12
$T23 = -2116						; size = 12
$T24 = -2104						; size = 12
$T25 = -2092						; size = 12
$T26 = -2080						; size = 12
$T27 = -2068						; size = 12
$T28 = -2056						; size = 12
$T29 = -2044						; size = 12
$T30 = -2032						; size = 12
$T31 = -2020						; size = 12
$T32 = -2008						; size = 12
$T33 = -1996						; size = 12
$T34 = -1984						; size = 12
$T35 = -1972						; size = 12
$T36 = -1960						; size = 12
$T37 = -1948						; size = 12
$T38 = -1936						; size = 12
$T39 = -1924						; size = 12
$T40 = -1912						; size = 12
$T41 = -1900						; size = 12
$T42 = -1888						; size = 12
$T43 = -1876						; size = 12
$T44 = -1864						; size = 12
$T45 = -1852						; size = 12
$T46 = -1840						; size = 12
$T47 = -1828						; size = 12
$T48 = -1816						; size = 12
$T49 = -1804						; size = 12
$T50 = -1792						; size = 12
$T51 = -1780						; size = 12
$T52 = -1768						; size = 12
$T53 = -1756						; size = 12
$T54 = -1744						; size = 12
$T55 = -1732						; size = 12
$T56 = -1720						; size = 12
$T57 = -1708						; size = 12
$T58 = -1696						; size = 12
$T59 = -1684						; size = 12
$T60 = -1672						; size = 12
$T61 = -1660						; size = 12
$T62 = -1648						; size = 12
$T63 = -1636						; size = 12
$T64 = -1624						; size = 12
$T65 = -1612						; size = 12
$T66 = -1600						; size = 12
$T67 = -1588						; size = 12
$T68 = -1576						; size = 12
$T69 = -1564						; size = 12
$T70 = -1552						; size = 12
$T71 = -1540						; size = 12
_error$72 = -1528					; size = 12
$T73 = -1516						; size = 12
$T74 = -1504						; size = 12
$T75 = -1492						; size = 12
$T76 = -1480						; size = 12
$T77 = -1468						; size = 12
$T78 = -1456						; size = 12
$T79 = -1444						; size = 12
$T80 = -1432						; size = 12
$T81 = -1420						; size = 12
$T82 = -1408						; size = 12
$T83 = -1396						; size = 12
$T84 = -1384						; size = 12
$T85 = -1372						; size = 12
$T86 = -1360						; size = 12
$T87 = -1348						; size = 12
$T88 = -1336						; size = 12
$T89 = -1324						; size = 12
$T90 = -1312						; size = 12
$T91 = -1300						; size = 12
$T92 = -1288						; size = 12
$T93 = -1276						; size = 12
$T94 = -1264						; size = 12
$T95 = -1252						; size = 12
$T96 = -1240						; size = 12
$T97 = -1228						; size = 12
$T98 = -1216						; size = 12
$T99 = -1204						; size = 12
$T100 = -1192						; size = 12
$T101 = -1180						; size = 12
$T102 = -1168						; size = 12
$T103 = -1156						; size = 12
$T104 = -1144						; size = 12
$T105 = -1132						; size = 12
_boingOtherSide$106 = -1120				; size = 12
_up$107 = -1108						; size = 12
_delta$108 = -1096					; size = 12
_limitLeft$109 = -1084					; size = 12
tv2449 = -1072						; size = 8
tv2624 = -1064						; size = 8
tv2504 = -1056						; size = 8
tv1996 = -1048						; size = 8
_limitAlong$110 = -1040					; size = 12
tv2622 = -1028						; size = 8
_minReBoingTime$111 = -1020				; size = 4
_thirtyHZ$ = -1016					; size = 4
_thousandHZ$ = -1012					; size = 4
tv2515 = -1008						; size = 8
_minSpeed$112 = -1000					; size = 4
_left$113 = -996					; size = 12
_limitAlong$114 = -984					; size = 12
_limitUp$115 = -972					; size = 12
_error$116 = -960					; size = 12
_limitLeft$117 = -948					; size = 12
_this$ = -936						; size = 4
_maxBetween$118 = -932					; size = 4
tv2456 = -928						; size = 4
_stretch$119 = -924					; size = 4
_limitForward$120 = -920				; size = 12
_limitUp$121 = -908					; size = 12
_limitForward$122 = -896				; size = 12
_alongAccel$123 = -884					; size = 4
_goalTip$ = -880					; size = 12
_localVel$124 = -868					; size = 12
_localVel$125 = -856					; size = 12
_localError$126 = -844					; size = 12
_error$127 = -832					; size = 12
_limitVel$128 = -820					; size = 12
_limitVel$129 = -808					; size = 12
_yawAccel$130 = -796					; size = 4
_pitchAccel$131 = -792					; size = 4
tv147 = -788						; size = 4
_boingSide$132 = -784					; size = 12
tv148 = -772						; size = 4
_squash$133 = -768					; size = 4
_flex$134 = -764					; size = 4
_dot$135 = -760						; size = 4
_sp$136 = -756						; size = 4
_cp$137 = -752						; size = 4
_pitchError$138 = -748					; size = 4
_sy$139 = -744						; size = 4
_cy$140 = -740						; size = 4
_yawError$141 = -736					; size = 4
_forward$142 = -732					; size = 12
_localAlong$143 = -720					; size = 12
_angleBetween$144 = -708				; size = 4
_pitch$145 = -704					; size = 4
_yaw$146 = -700						; size = 4
_vel$147 = -696						; size = 12
_along$148 = -684					; size = 12
_localVel$149 = -672					; size = 12
_goalLeft$ = -660					; size = 12
_goalUp$ = -648						; size = 12
_goalForward$ = -636					; size = 12
_localError$150 = -624					; size = 12
_goalBasePosition$ = -612				; size = 12
_speed$151 = -600					; size = 4
_deltaT$ = -596						; size = 4
_damping$152 = -592					; size = 4
_isAtLimit$153 = -586					; size = 1
_isAtLimit$154 = -585					; size = 1
_data$ = -584						; size = 4
$T155 = -580						; size = 48
$T156 = -532						; size = 48
$T157 = -484						; size = 48
$T158 = -436						; size = 48
_xfrmFromBoingCoordsMX$159 = -388			; size = 48
_limitMatrix$160 = -340					; size = 48
_limitMatrix$161 = -292					; size = 48
_xfrmMX$162 = -244					; size = 48
_pitchMatrix$163 = -196					; size = 48
_boingMX$164 = -148					; size = 48
_yawMatrix$165 = -100					; size = 48
_xfrmToBoingCoordsMX$166 = -52				; size = 48
__$ArrayPad$ = -4					; size = 4
_boneIndex$ = 8						; size = 4
_currenttime$ = 12					; size = 4
_jiggleInfo$ = 16					; size = 4
_goalMX$ = 20						; size = 4
_boneMX$ = 24						; size = 4
?BuildJiggleTransformations@CJiggleBones@@QAEXHMPBUmstudiojigglebone_t@@ABVmatrix3x4@@AAV3@@Z PROC ; CJiggleBones::BuildJiggleTransformations
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2380				; 0000094cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 	Vector goalBasePosition = goalMX[3];

	push	3
	mov	ecx, DWORD PTR _goalMX$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector

; 40   : 
; 41   : 	Vector goalForward = goalMX[2];

	push	2
	mov	ecx, DWORD PTR _goalMX$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _goalForward$[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector

; 42   : 	Vector goalUp = goalMX[1];

	push	1
	mov	ecx, DWORD PTR _goalMX$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector

; 43   : 	Vector goalLeft = goalMX[0];

	push	0
	mov	ecx, DWORD PTR _goalMX$[ebp]
	call	??Amatrix3x4@@QBEPBMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _goalLeft$[ebp]
	call	??0Vector@@QAE@PBM@Z			; Vector::Vector

; 44   : 
; 45   : 	// compute goal tip position
; 46   : 	Vector goalTip = goalBasePosition + jiggleInfo->length * goalForward;

	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T47[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _goalTip$[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+

; 47   : 
; 48   : 	JiggleData *data = GetJiggleData( boneIndex, currenttime, goalBasePosition, goalTip );

	lea	ecx, DWORD PTR _goalTip$[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalBasePosition$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _boneIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetJiggleData@CJiggleBones@@QAEPAUJiggleData@@HMABVVector@@0@Z ; CJiggleBones::GetJiggleData
	mov	DWORD PTR _data$[ebp], eax

; 49   : 	if( !data ) return;

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@BuildJiggl
	jmp	$LN1@BuildJiggl
$LN2@BuildJiggl:

; 50   : 
; 51   : 	if( currenttime - data->lastUpdate > 0.5f )

	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	subss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN3@BuildJiggl

; 52   : 	{
; 53   : 		data->Init( boneIndex, currenttime, goalBasePosition, goalTip );

	lea	edx, DWORD PTR _goalTip$[ebp]
	push	edx
	lea	eax, DWORD PTR _goalBasePosition$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _boneIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Init@JiggleData@@QAEXHMABVVector@@0@Z	; JiggleData::Init
$LN3@BuildJiggl:

; 54   : 	}
; 55   : 
; 56   : 	// limit maximum deltaT to avoid simulation blowups
; 57   : 	// if framerate gets very low, jiggle will run in slow motion
; 58   : 	const float thirtyHZ = 0.0333f;

	movss	xmm0, DWORD PTR __real@3d086595
	movss	DWORD PTR _thirtyHZ$[ebp], xmm0

; 59   : 	const float thousandHZ = 0.001f;

	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _thousandHZ$[ebp], xmm0

; 60   : 	float deltaT = bound( thousandHZ, currenttime - data->lastUpdate, thirtyHZ );

	mov	edx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	subss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR __real@3a83126f
	jb	SHORT $LN51@BuildJiggl
	mov	eax, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	subss	xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR __real@3d086595
	comiss	xmm1, xmm0
	jbe	SHORT $LN49@BuildJiggl
	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	subss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN50@BuildJiggl
$LN49@BuildJiggl:
	movss	xmm0, DWORD PTR __real@3d086595
	movss	DWORD PTR tv147[ebp], xmm0
$LN50@BuildJiggl:
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR tv148[ebp], xmm0
	jmp	SHORT $LN52@BuildJiggl
$LN51@BuildJiggl:
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR tv148[ebp], xmm0
$LN52@BuildJiggl:
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _deltaT$[ebp], xmm0

; 61   : 	data->lastUpdate = currenttime;

	mov	edx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 62   : 
; 63   : 	//
; 64   : 	// Bone tip flex
; 65   : 	//
; 66   : 	if (jiggleInfo->flags & (JIGGLE_IS_FLEXIBLE | JIGGLE_IS_RIGID))

	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 3
	je	$LN4@BuildJiggl

; 67   : 	{
; 68   : 		// apply gravity in global space
; 69   : 		data->tipAccel.z -= jiggleInfo->tipMass;

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+88]
	subss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _data$[ebp]
	movss	DWORD PTR [ecx+88], xmm0

; 70   : 
; 71   : 		if (jiggleInfo->flags & JIGGLE_IS_FLEXIBLE)

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1
	je	$LN7@BuildJiggl

; 72   : 		{
; 73   : 			// decompose into local coordinates
; 74   : 			Vector error = goalTip - data->tipPos;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	lea	edx, DWORD PTR _error$116[ebp]
	push	edx
	lea	ecx, DWORD PTR _goalTip$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 75   : 
; 76   : 			Vector localError;

	lea	ecx, DWORD PTR _localError$126[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 77   : 			localError.x = DotProduct( goalLeft, error );

	lea	eax, DWORD PTR _error$116[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalLeft$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localError$126[ebp]

; 78   : 			localError.y = DotProduct( goalUp, error );

	lea	edx, DWORD PTR _error$116[ebp]
	push	edx
	lea	eax, DWORD PTR _goalUp$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localError$126[ebp+4]

; 79   : 			localError.z = DotProduct( goalForward, error );

	lea	ecx, DWORD PTR _error$116[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalForward$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localError$126[ebp+8]

; 80   : 
; 81   : 			Vector localVel;

	lea	ecx, DWORD PTR _localVel$125[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 82   : 			localVel.x = DotProduct( goalLeft, data->tipVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _goalLeft$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$125[ebp]

; 83   : 			localVel.y = DotProduct( goalUp, data->tipVel );

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	lea	eax, DWORD PTR _goalUp$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$125[ebp+4]

; 84   : 
; 85   : 			// yaw spring
; 86   : 			float yawAccel = jiggleInfo->yawStiffness * localError.x - jiggleInfo->yawDamping * localVel.x;

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, DWORD PTR _localError$126[ebp]
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm1, DWORD PTR [edx+16]
	mulss	xmm1, DWORD PTR _localVel$125[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _yawAccel$130[ebp], xmm0

; 87   : 
; 88   : 			// pitch spring
; 89   : 			float pitchAccel = jiggleInfo->pitchStiffness * localError.y - jiggleInfo->pitchDamping * localVel.y;

	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR _localError$126[ebp+4]
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm1, DWORD PTR [ecx+24]
	mulss	xmm1, DWORD PTR _localVel$125[ebp+4]
	subss	xmm0, xmm1
	movss	DWORD PTR _pitchAccel$131[ebp], xmm0

; 90   : 
; 91   : 			if (jiggleInfo->flags & JIGGLE_HAS_LENGTH_CONSTRAINT)

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 32					; 00000020H
	je	SHORT $LN6@BuildJiggl

; 92   : 			{
; 93   : 				// drive tip towards goal tip position	
; 94   : 				data->tipAccel += yawAccel * goalLeft + pitchAccel * goalUp;

	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _pitchAccel$131[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T12[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalLeft$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _yawAccel$130[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T10[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 80					; 00000050H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 95   : 			}
; 96   : 			else

	jmp	$LN7@BuildJiggl
$LN6@BuildJiggl:

; 97   : 			{
; 98   : 				// allow flex along length of spring
; 99   : 				localVel.z = DotProduct( goalForward, data->tipVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _goalForward$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$125[ebp+8]

; 100  : 
; 101  : 				// along spring
; 102  : 				float alongAccel = jiggleInfo->alongStiffness * localError.z - jiggleInfo->alongDamping * localVel.z;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	mulss	xmm0, DWORD PTR _localError$126[ebp+8]
	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm1, DWORD PTR [eax+32]
	mulss	xmm1, DWORD PTR _localVel$125[ebp+8]
	subss	xmm0, xmm1
	movss	DWORD PTR _alongAccel$123[ebp], xmm0

; 103  : 
; 104  : 				// drive tip towards goal tip position	
; 105  : 				data->tipAccel += yawAccel * goalLeft + pitchAccel * goalUp + alongAccel * goalForward;

	lea	ecx, DWORD PTR _goalForward$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _alongAccel$123[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _pitchAccel$131[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalLeft$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _yawAccel$130[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 80					; 00000050H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$LN7@BuildJiggl:

; 106  : 			}
; 107  : 		}
; 108  : 
; 109  : 
; 110  : 		// simple euler integration		
; 111  : 		data->tipVel += data->tipAccel * deltaT;

	push	ecx
	movss	xmm0, DWORD PTR _deltaT$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 80					; 00000050H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 112  : 		data->tipPos += data->tipVel * deltaT;

	push	ecx
	movss	xmm0, DWORD PTR _deltaT$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 113  : 
; 114  : 		// clear this timestep's accumulated accelerations
; 115  : 		data->tipAccel = g_vecZero;		

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 80					; 00000050H
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 116  : 
; 117  : 		//
; 118  : 		// Apply optional constraints
; 119  : 		//
; 120  : 		if (jiggleInfo->flags & (JIGGLE_HAS_YAW_CONSTRAINT | JIGGLE_HAS_PITCH_CONSTRAINT))

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 12					; 0000000cH
	je	$LN18@BuildJiggl

; 121  : 		{
; 122  : 			// find components of spring vector in local coordinate system
; 123  : 			Vector along = data->tipPos - goalBasePosition;

	lea	eax, DWORD PTR _goalBasePosition$[ebp]
	push	eax
	lea	ecx, DWORD PTR _along$148[ebp]
	push	ecx
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 124  : 			Vector localAlong;

	lea	ecx, DWORD PTR _localAlong$143[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 125  : 			localAlong.x = DotProduct( goalLeft, along );

	lea	edx, DWORD PTR _along$148[ebp]
	push	edx
	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localAlong$143[ebp]

; 126  : 			localAlong.y = DotProduct( goalUp, along );

	lea	ecx, DWORD PTR _along$148[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalUp$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localAlong$143[ebp+4]

; 127  : 			localAlong.z = DotProduct( goalForward, along );

	lea	eax, DWORD PTR _along$148[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalForward$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localAlong$143[ebp+8]

; 128  : 
; 129  : 			Vector localVel;

	lea	ecx, DWORD PTR _localVel$124[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 130  : 			localVel.x = DotProduct( goalLeft, data->tipVel );

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$124[ebp]

; 131  : 			localVel.y = DotProduct( goalUp, data->tipVel );

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	lea	edx, DWORD PTR _goalUp$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$124[ebp+4]

; 132  : 			localVel.z = DotProduct( goalForward, data->tipVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _goalForward$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$124[ebp+8]

; 133  : 
; 134  : 			if (jiggleInfo->flags & JIGGLE_HAS_YAW_CONSTRAINT)

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 4
	je	$LN13@BuildJiggl

; 135  : 			{
; 136  : 				// enforce yaw constraints in local XZ plane
; 137  : 				float yawError = atan2( localAlong.x, localAlong.z );

	cvtss2sd xmm0, DWORD PTR _localAlong$143[ebp+8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _localAlong$143[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _yawError$141[ebp]

; 138  : 
; 139  : 				bool isAtLimit = false;

	mov	BYTE PTR _isAtLimit$154[ebp], 0

; 140  : 				float yaw = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _yaw$146[ebp], xmm0

; 141  : 
; 142  : 				if (yawError < jiggleInfo->minYaw)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR _yawError$141[ebp]
	jbe	SHORT $LN10@BuildJiggl

; 143  : 				{
; 144  : 					// at angular limit
; 145  : 					isAtLimit = true;

	mov	BYTE PTR _isAtLimit$154[ebp], 1

; 146  : 					yaw = jiggleInfo->minYaw;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _yaw$146[ebp], xmm0
	jmp	SHORT $LN12@BuildJiggl
$LN10@BuildJiggl:

; 147  : 				}
; 148  : 				else if (yawError > jiggleInfo->maxYaw)

	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR _yawError$141[ebp]
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	SHORT $LN12@BuildJiggl

; 149  : 				{
; 150  : 					// at angular limit
; 151  : 					isAtLimit = true;

	mov	BYTE PTR _isAtLimit$154[ebp], 1

; 152  : 					yaw = jiggleInfo->maxYaw;

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _yaw$146[ebp], xmm0
$LN12@BuildJiggl:

; 153  : 				}
; 154  : 
; 155  : 				if (isAtLimit)

	movzx	edx, BYTE PTR _isAtLimit$154[ebp]
	test	edx, edx
	je	$LN13@BuildJiggl

; 156  : 				{
; 157  : 					float sy, cy;
; 158  : 					SinCos( yaw, &sy, &cy );

	lea	eax, DWORD PTR _cy$140[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$139[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _yaw$146[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 159  : 
; 160  : 					// yaw matrix
; 161  : 					matrix3x4 yawMatrix;

	lea	ecx, DWORD PTR _yawMatrix$165[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 162  : 
; 163  : 					yawMatrix.SetForward( Vector( cy, 0, -sy ));

	movss	xmm0, DWORD PTR _sy$139[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cy$140[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _yawMatrix$165[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 164  : 					yawMatrix.SetRight( Vector( 0.0f, 1.0f, 0.0f ));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T105[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _yawMatrix$165[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 165  : 					yawMatrix.SetUp( Vector( sy, 0.0f, cy ));

	push	ecx
	movss	xmm0, DWORD PTR _cy$140[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sy$139[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T104[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _yawMatrix$165[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 166  : 					yawMatrix.SetOrigin( g_vecZero );

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _yawMatrix$165[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin

; 167  : 
; 168  : 					// global coordinates of limit
; 169  : 					matrix3x4 limitMatrix = goalMX.ConcatTransforms( yawMatrix );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _yawMatrix$165[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR _limitMatrix$160[ebp]
	push	eax
	mov	ecx, DWORD PTR _goalMX$[ebp]
	call	?ConcatTransforms@matrix3x4@@QBE?AV1@V1@@Z ; matrix3x4::ConcatTransforms

; 170  : 
; 171  : 					Vector limitLeft( limitMatrix[0] );

	push	0
	lea	ecx, DWORD PTR _limitMatrix$160[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _limitLeft$109[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 172  : 					Vector limitUp( limitMatrix[1] );

	push	1
	lea	ecx, DWORD PTR _limitMatrix$160[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _limitUp$121[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 173  : 					Vector limitForward( limitMatrix[2] );

	push	2
	lea	ecx, DWORD PTR _limitMatrix$160[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _limitForward$122[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 174  : 					Vector limitAlong( DotProduct( limitLeft, along ), DotProduct( limitUp, along ), DotProduct( limitForward, along ));

	lea	ecx, DWORD PTR _along$148[ebp]
	push	ecx
	lea	edx, DWORD PTR _limitForward$122[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _along$148[ebp]
	push	eax
	lea	ecx, DWORD PTR _limitUp$121[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _along$148[ebp]
	push	edx
	lea	eax, DWORD PTR _limitLeft$109[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _limitAlong$110[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 175  : 
; 176  : 					// clip to limit plane
; 177  : 					data->tipPos = goalBasePosition + limitAlong.y * limitUp + limitAlong.z * limitForward;

	lea	ecx, DWORD PTR _limitForward$122[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _limitAlong$110[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T103[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T102[ebp]
	push	eax
	lea	ecx, DWORD PTR _limitUp$121[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _limitAlong$110[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T101[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T100[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 178  : 
; 179  : 					// yaw friction - rubbing along limit plane
; 180  : 					Vector limitVel;

	lea	ecx, DWORD PTR _limitVel$129[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 181  : 					limitVel.y = DotProduct( limitUp, data->tipVel );

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	lea	edx, DWORD PTR _limitUp$121[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _limitVel$129[ebp+4]

; 182  : 					limitVel.z = DotProduct( limitForward, data->tipVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _limitForward$122[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _limitVel$129[ebp+8]

; 183  : 
; 184  : 					data->tipAccel -= jiggleInfo->yawFriction * (limitVel.y * limitUp + limitVel.z * limitForward);

	lea	edx, DWORD PTR _limitForward$122[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$129[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T99[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T98[ebp]
	push	ecx
	lea	edx, DWORD PTR _limitUp$121[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$129[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T97[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T96[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 80					; 00000050H
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 185  : 
; 186  : 					// update velocity reaction to hitting constraint
; 187  : 					data->tipVel = -jiggleInfo->yawBounce * limitVel.x * limitLeft + limitVel.y * limitUp + limitVel.z * limitForward;

	lea	eax, DWORD PTR _limitForward$122[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$129[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T95[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T94[ebp]
	push	edx
	lea	eax, DWORD PTR _limitUp$121[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$129[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T93[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T92[ebp]
	push	edx
	lea	eax, DWORD PTR _limitLeft$109[ebp]
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _limitVel$129[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T91[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 188  : 
; 189  : 					// update along vectors for use by pitch constraint
; 190  : 					along = data->tipPos - goalBasePosition;

	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90[ebp]
	push	edx
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _along$148[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _along$148[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _along$148[ebp+8], eax

; 191  : 					localAlong.x = DotProduct( goalLeft, along );

	lea	ecx, DWORD PTR _along$148[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalLeft$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localAlong$143[ebp]

; 192  : 					localAlong.y = DotProduct( goalUp, along );

	lea	eax, DWORD PTR _along$148[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localAlong$143[ebp+4]

; 193  : 					localAlong.z = DotProduct( goalForward, along );

	lea	edx, DWORD PTR _along$148[ebp]
	push	edx
	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localAlong$143[ebp+8]

; 194  : 
; 195  : 					localVel.x = DotProduct( goalLeft, data->tipVel );

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	lea	edx, DWORD PTR _goalLeft$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$124[ebp]

; 196  : 					localVel.y = DotProduct( goalUp, data->tipVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$124[ebp+4]

; 197  : 					localVel.z = DotProduct( goalForward, data->tipVel );

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$124[ebp+8]
$LN13@BuildJiggl:

; 198  : 				}
; 199  : 			}
; 200  : 
; 201  : 
; 202  : 			if (jiggleInfo->flags & JIGGLE_HAS_PITCH_CONSTRAINT)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 8
	je	$LN18@BuildJiggl

; 203  : 			{
; 204  : 				// enforce pitch constraints in local YZ plane
; 205  : 				float pitchError = atan2( localAlong.y, localAlong.z );

	cvtss2sd xmm0, DWORD PTR _localAlong$143[ebp+8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _localAlong$143[ebp+4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _pitchError$138[ebp]

; 206  : 
; 207  : 				bool isAtLimit = false;

	mov	BYTE PTR _isAtLimit$153[ebp], 0

; 208  : 				float pitch = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _pitch$145[ebp], xmm0

; 209  : 
; 210  : 				if (pitchError < jiggleInfo->minPitch)

	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	comiss	xmm0, DWORD PTR _pitchError$138[ebp]
	jbe	SHORT $LN15@BuildJiggl

; 211  : 				{
; 212  : 					// at angular limit
; 213  : 					isAtLimit = true;

	mov	BYTE PTR _isAtLimit$153[ebp], 1

; 214  : 					pitch = jiggleInfo->minPitch;

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR _pitch$145[ebp], xmm0
	jmp	SHORT $LN17@BuildJiggl
$LN15@BuildJiggl:

; 215  : 				}
; 216  : 				else if (pitchError > jiggleInfo->maxPitch)

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR _pitchError$138[ebp]
	comiss	xmm0, DWORD PTR [edx+60]
	jbe	SHORT $LN17@BuildJiggl

; 217  : 				{
; 218  : 					// at angular limit
; 219  : 					isAtLimit = true;

	mov	BYTE PTR _isAtLimit$153[ebp], 1

; 220  : 					pitch = jiggleInfo->maxPitch;

	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR _pitch$145[ebp], xmm0
$LN17@BuildJiggl:

; 221  : 				}
; 222  : 
; 223  : 				if (isAtLimit)

	movzx	ecx, BYTE PTR _isAtLimit$153[ebp]
	test	ecx, ecx
	je	$LN18@BuildJiggl

; 224  : 				{
; 225  : 					float sp, cp;
; 226  : 					SinCos( pitch, &sp, &cp );

	lea	edx, DWORD PTR _cp$137[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$136[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _pitch$145[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 227  : 
; 228  : 					// pitch matrix
; 229  : 					matrix3x4 pitchMatrix;

	lea	ecx, DWORD PTR _pitchMatrix$163[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 230  : 
; 231  : 					pitchMatrix.SetForward( Vector( 1.0f, 0.0, 0.0f ));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T89[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _pitchMatrix$163[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 232  : 					pitchMatrix.SetRight( Vector( 0, cp, -sp ));

	movss	xmm0, DWORD PTR _sp$136[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _cp$137[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T88[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _pitchMatrix$163[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 233  : 					pitchMatrix.SetUp( Vector( 0, sp, cp ));

	push	ecx
	movss	xmm0, DWORD PTR _cp$137[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sp$136[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T87[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _pitchMatrix$163[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 234  : 					pitchMatrix.SetOrigin( g_vecZero );

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _pitchMatrix$163[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin

; 235  : 
; 236  : 					// global coordinates of limit
; 237  : 					matrix3x4 limitMatrix = goalMX.ConcatTransforms( pitchMatrix );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _pitchMatrix$163[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR _limitMatrix$161[ebp]
	push	eax
	mov	ecx, DWORD PTR _goalMX$[ebp]
	call	?ConcatTransforms@matrix3x4@@QBE?AV1@V1@@Z ; matrix3x4::ConcatTransforms

; 238  : 
; 239  : 					Vector limitLeft( limitMatrix[0] );

	push	0
	lea	ecx, DWORD PTR _limitMatrix$161[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _limitLeft$117[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 240  : 					Vector limitUp( limitMatrix[1] );

	push	1
	lea	ecx, DWORD PTR _limitMatrix$161[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _limitUp$115[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 241  : 					Vector limitForward( limitMatrix[2] );

	push	2
	lea	ecx, DWORD PTR _limitMatrix$161[ebp]
	call	??Amatrix3x4@@QAEPAMH@Z			; matrix3x4::operator[]
	push	eax
	lea	ecx, DWORD PTR _limitForward$120[ebp]
	call	??0Vector@@QAE@QAM@Z			; Vector::Vector

; 242  : 
; 243  : 					Vector limitAlong( DotProduct( limitLeft, along ), DotProduct( limitUp, along ), DotProduct( limitForward, along ));

	lea	ecx, DWORD PTR _along$148[ebp]
	push	ecx
	lea	edx, DWORD PTR _limitForward$120[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _along$148[ebp]
	push	eax
	lea	ecx, DWORD PTR _limitUp$115[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _along$148[ebp]
	push	edx
	lea	eax, DWORD PTR _limitLeft$117[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _limitAlong$114[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 244  : 
; 245  : 					// clip to limit plane
; 246  : 					data->tipPos = goalBasePosition + limitAlong.x * limitLeft + limitAlong.z * limitForward;

	lea	ecx, DWORD PTR _limitForward$120[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _limitAlong$114[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T86[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T85[ebp]
	push	eax
	lea	ecx, DWORD PTR _limitLeft$117[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _limitAlong$114[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T84[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T83[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 247  : 
; 248  : 					// pitch friction - rubbing along limit plane
; 249  : 					Vector limitVel;

	lea	ecx, DWORD PTR _limitVel$128[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 250  : 					limitVel.y = DotProduct( limitUp, data->tipVel );

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	lea	edx, DWORD PTR _limitUp$115[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _limitVel$128[ebp+4]

; 251  : 					limitVel.z = DotProduct( limitForward, data->tipVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	lea	ecx, DWORD PTR _limitForward$120[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _limitVel$128[ebp+8]

; 252  : 
; 253  : 					data->tipAccel -= jiggleInfo->pitchFriction * (limitVel.x * limitLeft + limitVel.z * limitForward);

	lea	edx, DWORD PTR _limitForward$120[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$128[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T82[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T81[ebp]
	push	ecx
	lea	edx, DWORD PTR _limitLeft$117[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$128[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T80[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+64]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T79[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 80					; 00000050H
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=

; 254  : 
; 255  : 					// update velocity reaction to hitting constraint
; 256  : 					data->tipVel = limitVel.x * limitLeft - jiggleInfo->pitchBounce * limitVel.y * limitUp + limitVel.z * limitForward;

	lea	eax, DWORD PTR _limitForward$120[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$128[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T78[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T77[ebp]
	push	edx
	lea	eax, DWORD PTR _limitUp$115[ebp]
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+68]
	mulss	xmm0, DWORD PTR _limitVel$128[ebp+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T76[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T75[ebp]
	push	eax
	lea	ecx, DWORD PTR _limitLeft$117[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _limitVel$128[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T74[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN18@BuildJiggl:

; 257  : 				}
; 258  : 			}
; 259  : 		}
; 260  : 
; 261  : 		// needed for matrix assembly below
; 262  : 		Vector forward = (data->tipPos - goalBasePosition).Normalize();

	lea	ecx, DWORD PTR _forward$142[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalBasePosition$[ebp]
	push	edx
	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 263  : 
; 264  : 		if (jiggleInfo->flags & JIGGLE_HAS_ANGLE_CONSTRAINT)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 16					; 00000010H
	je	$LN21@BuildJiggl

; 265  : 		{
; 266  : 			// enforce max angular error
; 267  : 			Vector error = goalTip - data->tipPos;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	lea	ecx, DWORD PTR _error$72[ebp]
	push	ecx
	lea	ecx, DWORD PTR _goalTip$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 268  : 			float dot = DotProduct( forward, goalForward );

	lea	edx, DWORD PTR _goalForward$[ebp]
	push	edx
	lea	eax, DWORD PTR _forward$142[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _dot$135[ebp]

; 269  : 			float angleBetween = acos( dot );

	cvtss2sd xmm0, DWORD PTR _dot$135[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	DWORD PTR _angleBetween$144[ebp]

; 270  : 			if (dot < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dot$135[ebp]
	jbe	SHORT $LN20@BuildJiggl

; 271  : 			{
; 272  : 				angleBetween = 2.0f * M_PI - angleBetween;

	cvtss2sd xmm0, DWORD PTR _angleBetween$144[ebp]
	movsd	xmm1, QWORD PTR __real@401921fb54442d18
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _angleBetween$144[ebp], xmm0
$LN20@BuildJiggl:

; 273  : 			}
; 274  : 
; 275  : 			if (angleBetween > jiggleInfo->angleLimit)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR _angleBetween$144[ebp]
	comiss	xmm0, DWORD PTR [ecx+36]
	jbe	$LN21@BuildJiggl

; 276  : 			{
; 277  : 				// at angular limit
; 278  : 				float maxBetween = jiggleInfo->length * sin( jiggleInfo->angleLimit );

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv2622[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv1996[ebp]
	movsd	xmm0, QWORD PTR tv2622[ebp]
	mulsd	xmm0, QWORD PTR tv1996[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxBetween$118[ebp], xmm0

; 279  : 
; 280  : 				Vector delta = (goalTip - data->tipPos).Normalize();

	lea	ecx, DWORD PTR _delta$108[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalTip$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 281  : 
; 282  : 				data->tipPos = goalTip - maxBetween * delta;

	lea	ecx, DWORD PTR _delta$108[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _maxBetween$118[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T70[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T69[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalTip$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 283  : 
; 284  : 				forward = (data->tipPos - goalBasePosition).Normalize();

	lea	ecx, DWORD PTR $T68[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalBasePosition$[ebp]
	push	edx
	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _forward$142[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _forward$142[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _forward$142[ebp+8], eax
$LN21@BuildJiggl:

; 285  : 			}
; 286  : 		}
; 287  : 
; 288  : 		if (jiggleInfo->flags & JIGGLE_HAS_LENGTH_CONSTRAINT)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 32					; 00000020H
	je	$LN22@BuildJiggl

; 289  : 		{
; 290  : 			// enforce spring length
; 291  : 			data->tipPos = goalBasePosition + jiggleInfo->length * forward;

	lea	eax, DWORD PTR _forward$142[ebp]
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T66[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T65[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 292  : 
; 293  : 			// zero velocity along forward bone axis
; 294  : 			data->tipVel -= DotProduct( data->tipVel, forward ) * forward;

	lea	ecx, DWORD PTR _forward$142[ebp]
	push	ecx
	lea	edx, DWORD PTR _forward$142[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T64[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 68					; 00000044H
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
$LN22@BuildJiggl:

; 295  : 		}
; 296  : 
; 297  : 		//
; 298  : 		// Build bone matrix to align along current tip direction
; 299  : 		//
; 300  : 		Vector left = CrossProduct( goalUp, forward ).Normalize();

	lea	edx, DWORD PTR _left$113[ebp]
	push	edx
	lea	eax, DWORD PTR _forward$142[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T63[ebp]
	push	edx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize

; 301  : 
; 302  : 		Vector up = CrossProduct( forward, left );

	lea	eax, DWORD PTR _left$113[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$142[ebp]
	push	ecx
	lea	edx, DWORD PTR _up$107[ebp]
	push	edx
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH

; 303  : 
; 304  : 		boneMX.SetForward( left );

	lea	eax, DWORD PTR _left$113[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 305  : 		boneMX.SetRight( up );

	lea	ecx, DWORD PTR _up$107[ebp]
	push	ecx
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 306  : 		boneMX.SetUp( forward );

	lea	edx, DWORD PTR _forward$142[ebp]
	push	edx
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 307  : 		boneMX.SetOrigin( goalBasePosition );

	lea	eax, DWORD PTR _goalBasePosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin
$LN4@BuildJiggl:

; 308  : 	}
; 309  : 
; 310  : 	//
; 311  : 	// Bone base flex
; 312  : 	//
; 313  : 	if (jiggleInfo->flags & JIGGLE_HAS_BASE_SPRING)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 64					; 00000040H
	je	$LN23@BuildJiggl

; 314  : 	{
; 315  : 		// gravity
; 316  : 		data->baseAccel.z -= jiggleInfo->baseMass;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	subss	xmm0, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _data$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 317  : 
; 318  : 		// simple spring
; 319  : 		Vector error = goalBasePosition - data->basePos;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR _error$127[ebp]
	push	ecx
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 320  : 		data->baseAccel += jiggleInfo->baseStiffness * error - jiggleInfo->baseDamping * data->baseVel;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T62[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T61[ebp]
	push	edx
	lea	eax, DWORD PTR _error$127[ebp]
	push	eax
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+76]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T60[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 321  : 
; 322  : 		data->baseVel += data->baseAccel * deltaT;

	push	ecx
	movss	xmm0, DWORD PTR _deltaT$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T59[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 323  : 		data->basePos += data->baseVel * deltaT;

	push	ecx
	movss	xmm0, DWORD PTR _deltaT$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T58[ebp]
	push	ecx
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 324  : 
; 325  : 		// clear this timestep's accumulated accelerations
; 326  : 		data->baseAccel = g_vecZero;		

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 44					; 0000002cH
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 327  : 
; 328  : 		// constrain to limits
; 329  : 		error = data->basePos - goalBasePosition;

	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T57[ebp]
	push	edx
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _error$127[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _error$127[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _error$127[ebp+8], eax

; 330  : 		Vector localError;

	lea	ecx, DWORD PTR _localError$150[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 331  : 		localError.x = DotProduct( goalLeft, error );

	lea	ecx, DWORD PTR _error$127[ebp]
	push	ecx
	lea	edx, DWORD PTR _goalLeft$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localError$150[ebp]

; 332  : 		localError.y = DotProduct( goalUp, error );

	lea	eax, DWORD PTR _error$127[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localError$150[ebp+4]

; 333  : 		localError.z = DotProduct( goalForward, error );

	lea	edx, DWORD PTR _error$127[ebp]
	push	edx
	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localError$150[ebp+8]

; 334  : 
; 335  : 		Vector localVel;

	lea	ecx, DWORD PTR _localVel$149[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 336  : 		localVel.x = DotProduct( goalLeft, data->baseVel );

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	lea	edx, DWORD PTR _goalLeft$[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$149[ebp]

; 337  : 		localVel.y = DotProduct( goalUp, data->baseVel );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$149[ebp+4]

; 338  : 		localVel.z = DotProduct( goalForward, data->baseVel );

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _localVel$149[ebp+8]

; 339  : 
; 340  : 		// horizontal constraint
; 341  : 		if (localError.x < jiggleInfo->baseMinLeft)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+84]
	comiss	xmm0, DWORD PTR _localError$150[ebp]
	jbe	$LN25@BuildJiggl

; 342  : 		{
; 343  : 			localError.x = jiggleInfo->baseMinLeft;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+84]
	movss	DWORD PTR _localError$150[ebp], xmm0

; 344  : 
; 345  : 			// friction
; 346  : 			data->baseAccel -= jiggleInfo->baseLeftFriction * (localVel.y * goalUp + localVel.z * goalForward);

	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T56[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T55[ebp]
	push	edx
	lea	eax, DWORD PTR _goalUp$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T54[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+92]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T53[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
	jmp	$LN27@BuildJiggl
$LN25@BuildJiggl:

; 347  : 		}
; 348  : 		else if (localError.x > jiggleInfo->baseMaxLeft)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR _localError$150[ebp]
	comiss	xmm0, DWORD PTR [ecx+88]
	jbe	$LN27@BuildJiggl

; 349  : 		{
; 350  : 			localError.x = jiggleInfo->baseMaxLeft;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+88]
	movss	DWORD PTR _localError$150[ebp], xmm0

; 351  : 
; 352  : 			// friction
; 353  : 			data->baseAccel -= jiggleInfo->baseLeftFriction * (localVel.y * goalUp + localVel.z * goalForward);

	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T52[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T51[ebp]
	push	edx
	lea	eax, DWORD PTR _goalUp$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T50[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+92]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T49[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
$LN27@BuildJiggl:

; 354  : 		}
; 355  : 
; 356  : 		if (localError.y < jiggleInfo->baseMinUp)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+96]
	comiss	xmm0, DWORD PTR _localError$150[ebp+4]
	jbe	$LN28@BuildJiggl

; 357  : 		{
; 358  : 			localError.y = jiggleInfo->baseMinUp;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR _localError$150[ebp+4], xmm0

; 359  : 
; 360  : 			// friction
; 361  : 			data->baseAccel -= jiggleInfo->baseUpFriction * (localVel.x * goalLeft + localVel.z * goalForward);

	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T48[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T24[ebp]
	push	edx
	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T46[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T45[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
	jmp	$LN30@BuildJiggl
$LN28@BuildJiggl:

; 362  : 		}
; 363  : 		else if (localError.y > jiggleInfo->baseMaxUp)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR _localError$150[ebp+4]
	comiss	xmm0, DWORD PTR [ecx+100]
	jbe	$LN30@BuildJiggl

; 364  : 		{
; 365  : 			localError.y = jiggleInfo->baseMaxUp;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	movss	DWORD PTR _localError$150[ebp+4], xmm0

; 366  : 
; 367  : 			// friction
; 368  : 			data->baseAccel -= jiggleInfo->baseUpFriction * (localVel.x * goalLeft + localVel.z * goalForward);

	lea	eax, DWORD PTR _goalForward$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T44[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T43[ebp]
	push	edx
	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T42[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T41[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
$LN30@BuildJiggl:

; 369  : 		}
; 370  : 
; 371  : 		if (localError.z < jiggleInfo->baseMinForward)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [ecx+108]
	comiss	xmm0, DWORD PTR _localError$150[ebp+8]
	jbe	$LN31@BuildJiggl

; 372  : 		{
; 373  : 			localError.z = jiggleInfo->baseMinForward;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+108]
	movss	DWORD PTR _localError$150[ebp+8], xmm0

; 374  : 
; 375  : 			// friction
; 376  : 			data->baseAccel -= jiggleInfo->baseForwardFriction * (localVel.x * goalLeft + localVel.y * goalUp);

	lea	eax, DWORD PTR _goalUp$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T40[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T39[ebp]
	push	edx
	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T38[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
	jmp	$LN33@BuildJiggl
$LN31@BuildJiggl:

; 377  : 		}
; 378  : 		else if (localError.z > jiggleInfo->baseMaxForward)

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR _localError$150[ebp+8]
	comiss	xmm0, DWORD PTR [ecx+112]
	jbe	$LN33@BuildJiggl

; 379  : 		{
; 380  : 			localError.z = jiggleInfo->baseMaxForward;

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [edx+112]
	movss	DWORD PTR _localError$150[ebp+8], xmm0

; 381  : 
; 382  : 			// friction
; 383  : 			data->baseAccel -= jiggleInfo->baseForwardFriction * (localVel.x * goalLeft + localVel.y * goalUp);

	lea	eax, DWORD PTR _goalUp$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T36[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T35[ebp]
	push	edx
	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _localVel$149[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T34[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T33[ebp]
	push	eax
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 44					; 0000002cH
	call	??ZVector@@QAEAAV0@ABV0@@Z		; Vector::operator-=
$LN33@BuildJiggl:

; 384  : 		}
; 385  : 
; 386  : 		data->basePos = goalBasePosition + localError.x * goalLeft + localError.y * goalUp + localError.z * goalForward;

	lea	ecx, DWORD PTR _goalForward$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _localError$150[ebp+8]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T32[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _localError$150[ebp+4]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T30[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalLeft$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _localError$150[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T28[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 387  : 
; 388  : 
; 389  : 		// fix up velocity
; 390  : 		data->baseVel = (data->basePos - data->baseLastPos) / deltaT;

	push	ecx
	movss	xmm0, DWORD PTR _deltaT$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T26[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	lea	eax, DWORD PTR $T25[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??KVector@@QBE?AV0@M@Z			; Vector::operator/
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 391  : 		data->baseLastPos = data->basePos;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 392  : 
; 393  : 
; 394  : 		if (!(jiggleInfo->flags & (JIGGLE_IS_FLEXIBLE | JIGGLE_IS_RIGID)))

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 3
	jne	SHORT $LN34@BuildJiggl

; 395  : 		{
; 396  : 			// no tip flex - use bone's goal orientation
; 397  : 			boneMX = goalMX;							

	mov	ecx, 12					; 0000000cH
	mov	esi, DWORD PTR _goalMX$[ebp]
	mov	edi, DWORD PTR _boneMX$[ebp]
	rep movsd
$LN34@BuildJiggl:

; 398  : 		}
; 399  : 
; 400  : 		// update bone position
; 401  : 		boneMX.SetOrigin( data->basePos );

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin
	jmp	$LN47@BuildJiggl
$LN23@BuildJiggl:

; 402  : 	}
; 403  : 	else if ( jiggleInfo->flags & JIGGLE_IS_BOING )

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 128				; 00000080H
	je	$LN35@BuildJiggl

; 404  : 	{
; 405  : 		// estimate velocity
; 406  : 		Vector vel = goalBasePosition - data->lastBoingPos;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	lea	edx, DWORD PTR _vel$147[ebp]
	push	edx
	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-

; 407  : 
; 408  : 		data->lastBoingPos = goalBasePosition;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 104				; 00000068H
	mov	ecx, DWORD PTR _goalBasePosition$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _goalBasePosition$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _goalBasePosition$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 409  : 
; 410  : 		float speed = vel.Length();

	lea	ecx, DWORD PTR _vel$147[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _speed$151[ebp]

; 411  : 		vel = vel.Normalize();

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _vel$147[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vel$147[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vel$147[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vel$147[ebp+8], eax

; 412  : 
; 413  : 		if( speed < 0.00001f )

	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, DWORD PTR _speed$151[ebp]
	jbe	SHORT $LN37@BuildJiggl

; 414  : 		{
; 415  : 			vel = Vector( 0.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T23[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vel$147[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vel$147[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vel$147[ebp+8], eax

; 416  : 			speed = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _speed$151[ebp], xmm0

; 417  : 		}
; 418  : 		else

	jmp	SHORT $LN38@BuildJiggl
$LN37@BuildJiggl:

; 419  : 		{
; 420  : 			speed /= deltaT;

	movss	xmm0, DWORD PTR _speed$151[ebp]
	divss	xmm0, DWORD PTR _deltaT$[ebp]
	movss	DWORD PTR _speed$151[ebp], xmm0
$LN38@BuildJiggl:

; 421  : 		}
; 422  : 
; 423  : 		data->boingTime += deltaT;

	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+144]
	addss	xmm0, DWORD PTR _deltaT$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	movss	DWORD PTR [edx+144], xmm0

; 424  : 
; 425  : 		// if velocity changed a lot, we impacted and should *boing*
; 426  : 		const float minSpeed = 5.0f; // 15.0f;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _minSpeed$112[ebp], xmm0

; 427  : 		const float minReBoingTime = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _minReBoingTime$111[ebp], xmm0

; 428  : 
; 429  : 		if(( speed > minSpeed || data->boingSpeed > minSpeed ) && data->boingTime > minReBoingTime )

	movss	xmm0, DWORD PTR _speed$151[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	ja	SHORT $LN40@BuildJiggl
	mov	eax, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [eax+140]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	$LN41@BuildJiggl
$LN40@BuildJiggl:
	mov	ecx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+144]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN41@BuildJiggl

; 430  : 		{
; 431  : 			if( fabs( data->boingSpeed - speed ) > jiggleInfo->boingImpactSpeed || DotProduct( vel, data->boingVelDir ) < jiggleInfo->boingImpactAngle )

	mov	edx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [edx+140]
	subss	xmm0, DWORD PTR _speed$151[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv2449[ebp]
	movsd	xmm0, QWORD PTR tv2449[ebp]
	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+120]
	comisd	xmm0, xmm1
	ja	SHORT $LN42@BuildJiggl
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	lea	edx, DWORD PTR _vel$147[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR tv2456[ebp]
	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	movss	xmm0, DWORD PTR [eax+124]
	comiss	xmm0, DWORD PTR tv2456[ebp]
	jbe	SHORT $LN41@BuildJiggl
$LN42@BuildJiggl:

; 432  : 			{
; 433  : 				data->boingTime = 0.0f;

	mov	ecx, DWORD PTR _data$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+144], xmm0

; 434  : 				data->boingDir = -vel;

	lea	edx, DWORD PTR $T22[ebp]
	push	edx
	lea	ecx, DWORD PTR _vel$147[ebp]
	call	??GVector@@QBE?AV0@XZ			; Vector::operator-
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 116				; 00000074H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN41@BuildJiggl:

; 435  : 			}
; 436  : 		}
; 437  : 
; 438  : 		data->boingVelDir = vel;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _vel$147[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vel$147[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vel$147[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 439  : 		data->boingSpeed = speed;

	mov	eax, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR _speed$151[ebp]
	movss	DWORD PTR [eax+140], xmm0

; 440  : 
; 441  : 		float damping = 1.0f - ( jiggleInfo->boingDampingRate * data->boingTime );

	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+128]
	mulss	xmm0, DWORD PTR [edx+144]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _damping$152[ebp], xmm1

; 442  : 		if ( damping < 0.01f )

	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR _damping$152[ebp]
	jbe	SHORT $LN43@BuildJiggl

; 443  : 		{
; 444  : 			// boing has entirely damped out
; 445  : 			boneMX = goalMX;

	mov	ecx, 12					; 0000000cH
	mov	esi, DWORD PTR _goalMX$[ebp]
	mov	edi, DWORD PTR _boneMX$[ebp]
	rep movsd

; 446  : 		}
; 447  : 		else

	jmp	$LN44@BuildJiggl
$LN43@BuildJiggl:

; 448  : 		{
; 449  : 			damping *= damping;

	movss	xmm0, DWORD PTR _damping$152[ebp]
	mulss	xmm0, DWORD PTR _damping$152[ebp]
	movss	DWORD PTR _damping$152[ebp], xmm0

; 450  : 			damping *= damping;

	movss	xmm0, DWORD PTR _damping$152[ebp]
	mulss	xmm0, DWORD PTR _damping$152[ebp]
	movss	DWORD PTR _damping$152[ebp], xmm0

; 451  : 
; 452  : 			float flex = jiggleInfo->boingAmplitude * cos( jiggleInfo->boingFrequency * data->boingTime ) * damping;

	mov	eax, DWORD PTR _jiggleInfo$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+136]
	mov	ecx, DWORD PTR _jiggleInfo$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	movss	xmm1, DWORD PTR [ecx+132]
	mulss	xmm1, DWORD PTR [edx+144]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv2624[ebp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv2504[ebp]
	movsd	xmm0, QWORD PTR tv2624[ebp]
	mulsd	xmm0, QWORD PTR tv2504[ebp]
	cvtss2sd xmm1, DWORD PTR _damping$152[ebp]
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _flex$134[ebp], xmm0

; 453  :  			float squash = 1.0f + flex;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _flex$134[ebp]
	movss	DWORD PTR _squash$133[ebp], xmm0

; 454  :  			float stretch = 1.0f - flex;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _flex$134[ebp]
	movss	DWORD PTR _stretch$119[ebp], xmm0

; 455  : 
; 456  : 			boneMX.SetForward( goalLeft );

	lea	eax, DWORD PTR _goalLeft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 457  : 			boneMX.SetRight( goalUp );

	lea	ecx, DWORD PTR _goalUp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 458  : 			boneMX.SetUp( goalForward );

	lea	edx, DWORD PTR _goalForward$[ebp]
	push	edx
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 459  : 			boneMX.SetOrigin( g_vecZero );

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin

; 460  : 
; 461  : 			// build transform into "boing space", where Z is along primary boing axis
; 462  : 			Vector boingSide;

	lea	ecx, DWORD PTR _boingSide$132[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 463  : 			if( fabs( data->boingDir.x ) < 0.9f )

	mov	eax, DWORD PTR _data$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+116]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv2515[ebp]
	movsd	xmm0, QWORD PTR __real@3fecccccc0000000
	comisd	xmm0, QWORD PTR tv2515[ebp]
	jbe	SHORT $LN45@BuildJiggl

; 464  : 			{
; 465  : 				boingSide = CrossProduct( data->boingDir, Vector( 1.0f, 0.0f, 0.0f )).Normalize();

	lea	ecx, DWORD PTR $T21[ebp]
	push	ecx
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T20[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _boingSide$132[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _boingSide$132[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _boingSide$132[ebp+8], eax

; 466  : 			}
; 467  : 			else

	jmp	SHORT $LN46@BuildJiggl
$LN45@BuildJiggl:

; 468  : 			{
; 469  : 				boingSide = CrossProduct( data->boingDir, Vector( 0.0f, 0.0f, 1.0f )).Normalize();

	lea	ecx, DWORD PTR $T18[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T17[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _boingSide$132[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _boingSide$132[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _boingSide$132[ebp+8], eax
$LN46@BuildJiggl:

; 470  : 			}
; 471  : 
; 472  : 			Vector boingOtherSide = CrossProduct( data->boingDir, boingSide );

	lea	ecx, DWORD PTR _boingSide$132[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	lea	eax, DWORD PTR _boingOtherSide$106[ebp]
	push	eax
	call	?CrossProduct@@YA?AVVector@@ABV1@0@Z	; CrossProduct
	add	esp, 12					; 0000000cH

; 473  : 
; 474  : 			matrix3x4 xfrmToBoingCoordsMX, xfrmFromBoingCoordsMX;

	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4
	lea	ecx, DWORD PTR _xfrmFromBoingCoordsMX$159[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 475  : 
; 476  : 			xfrmToBoingCoordsMX.SetForward( boingSide );

	lea	ecx, DWORD PTR _boingSide$132[ebp]
	push	ecx
	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 477  : 			xfrmToBoingCoordsMX.SetRight( boingOtherSide );

	lea	edx, DWORD PTR _boingOtherSide$106[ebp]
	push	edx
	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 478  : 			xfrmToBoingCoordsMX.SetUp( data->boingDir );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 479  : 			xfrmToBoingCoordsMX.SetOrigin( g_vecZero );

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin

; 480  : 
; 481  : 			// transform back from boing space (inverse is transpose since orthogonal)
; 482  : 			xfrmFromBoingCoordsMX = xfrmToBoingCoordsMX;

	mov	ecx, 12					; 0000000cH
	lea	esi, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	lea	edi, DWORD PTR _xfrmFromBoingCoordsMX$159[ebp]
	rep movsd

; 483  : 			xfrmToBoingCoordsMX = xfrmToBoingCoordsMX.Transpose();

	lea	ecx, DWORD PTR $T156[ebp]
	push	ecx
	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	?Transpose@matrix3x4@@QBE?AV1@XZ	; matrix3x4::Transpose
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	rep movsd

; 484  : 
; 485  : 			// build squash and stretch transform in "boing space"
; 486  : 			matrix3x4 boingMX;

	lea	ecx, DWORD PTR _boingMX$164[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 487  : 
; 488  : 			boingMX.SetForward( Vector( squash, 0.0f, 0.0f ));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _squash$133[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T15[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _boingMX$164[ebp]
	call	?SetForward@matrix3x4@@QAEXABVVector@@@Z ; matrix3x4::SetForward

; 489  : 			boingMX.SetRight( Vector( 0.0f, squash, 0.0f ));

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _squash$133[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T14[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _boingMX$164[ebp]
	call	?SetRight@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetRight

; 490  : 			boingMX.SetUp( Vector( 0.0f, 0.0f, stretch ));

	push	ecx
	movss	xmm0, DWORD PTR _stretch$119[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR _boingMX$164[ebp]
	call	?SetUp@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetUp

; 491  : 			boingMX.SetOrigin( g_vecZero );

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _boingMX$164[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin

; 492  : 
; 493  : 			// put it all together
; 494  : 			matrix3x4 xfrmMX;

	lea	ecx, DWORD PTR _xfrmMX$162[ebp]
	call	??0matrix3x4@@QAE@XZ			; matrix3x4::matrix3x4

; 495  : 			xfrmMX = xfrmToBoingCoordsMX.ConcatTransforms( boingMX );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _boingMX$164[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T155[ebp]
	push	eax
	lea	ecx, DWORD PTR _xfrmToBoingCoordsMX$166[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _xfrmMX$162[ebp]
	rep movsd

; 496  : 			xfrmMX = xfrmMX.ConcatTransforms( xfrmFromBoingCoordsMX );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _xfrmFromBoingCoordsMX$159[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T158[ebp]
	push	eax
	lea	ecx, DWORD PTR _xfrmMX$162[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	lea	edi, DWORD PTR _xfrmMX$162[ebp]
	rep movsd

; 497  : 			boneMX = boneMX.ConcatTransforms( xfrmMX );

	sub	esp, 48					; 00000030H
	mov	ecx, esp
	lea	edx, DWORD PTR _xfrmMX$162[ebp]
	push	edx
	call	??0matrix3x4@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T157[ebp]
	push	eax
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?ConcatTransforms@matrix3x4@@QAE?AV1@V1@@Z ; matrix3x4::ConcatTransforms
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	mov	edi, DWORD PTR _boneMX$[ebp]
	rep movsd

; 498  : 			boneMX.SetOrigin( goalBasePosition );

	lea	ecx, DWORD PTR _goalBasePosition$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _boneMX$[ebp]
	call	?SetOrigin@matrix3x4@@QAEXABVVector@@@Z	; matrix3x4::SetOrigin
$LN44@BuildJiggl:

; 499  : 		}

	jmp	SHORT $LN47@BuildJiggl
$LN35@BuildJiggl:

; 500  : 	}
; 501  : 	else if (!(jiggleInfo->flags & (JIGGLE_IS_FLEXIBLE | JIGGLE_IS_RIGID)))

	mov	edx, DWORD PTR _jiggleInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 3
	jne	SHORT $LN47@BuildJiggl

; 502  : 	{
; 503  : 		// no flex at all - just use goal matrix
; 504  : 		boneMX = goalMX;

	mov	ecx, 12					; 0000000cH
	mov	esi, DWORD PTR _goalMX$[ebp]
	mov	edi, DWORD PTR _boneMX$[ebp]
	rep movsd
$LN47@BuildJiggl:
$LN1@BuildJiggl:

; 505  : 	}
; 506  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?BuildJiggleTransformations@CJiggleBones@@QAEXHMPBUmstudiojigglebone_t@@ABVmatrix3x4@@AAV3@@Z ENDP ; CJiggleBones::BuildJiggleTransformations
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\jigglebones.cpp
_TEXT	SEGMENT
_data$ = -160						; size = 148
_idx$ = -12						; size = 4
_it$1 = -8						; size = 4
_this$ = -4						; size = 4
_bone$ = 8						; size = 4
_currenttime$ = 12					; size = 4
_initBasePos$ = 16					; size = 4
_initTipPos$ = 20					; size = 4
?GetJiggleData@CJiggleBones@@QAEPAUJiggleData@@HMABVVector@@0@Z PROC ; CJiggleBones::GetJiggleData
; _this$ = ecx

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	DWORD PTR _this$[ebp], ecx

; 13   : 	FOR_EACH_LL( m_jiggleBoneState, it )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Head@?$CUtlLinkedList@UJiggleData@@G@@QBEGXZ ; CUtlLinkedList<JiggleData,unsigned short>::Head
	movzx	eax, ax
	mov	DWORD PTR _it$1[ebp], eax
	jmp	SHORT $LN4@GetJiggleD
$LN2@GetJiggleD:
	movzx	ecx, WORD PTR _it$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Next@?$CUtlLinkedList@UJiggleData@@G@@QBEGG@Z ; CUtlLinkedList<JiggleData,unsigned short>::Next
	movzx	edx, ax
	mov	DWORD PTR _it$1[ebp], edx
$LN4@GetJiggleD:
	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	eax, ax
	cmp	DWORD PTR _it$1[ebp], eax
	je	SHORT $LN3@GetJiggleD

; 14   : 	{
; 15   : 		if ( m_jiggleBoneState[it].bone == bone )

	movzx	ecx, WORD PTR _it$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _bone$[ebp]
	jne	SHORT $LN5@GetJiggleD

; 16   : 		{
; 17   : 			return &m_jiggleBoneState[it];

	movzx	eax, WORD PTR _it$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::operator[]
	jmp	SHORT $LN1@GetJiggleD
$LN5@GetJiggleD:

; 18   : 		}
; 19   : 	}

	jmp	SHORT $LN2@GetJiggleD
$LN3@GetJiggleD:

; 20   : 
; 21   : 	JiggleData data;

	lea	ecx, DWORD PTR _data$[ebp]
	call	??0JiggleData@@QAE@XZ

; 22   : 	data.Init( bone, currenttime, initBasePos, initTipPos );

	mov	ecx, DWORD PTR _initTipPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _initBasePos$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _bone$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	call	?Init@JiggleData@@QAEXHMABVVector@@0@Z	; JiggleData::Init

; 23   : 
; 24   : 	int idx = m_jiggleBoneState.AddToHead( data );

	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToHead@?$CUtlLinkedList@UJiggleData@@G@@QAEGABUJiggleData@@@Z ; CUtlLinkedList<JiggleData,unsigned short>::AddToHead
	movzx	edx, ax
	mov	DWORD PTR _idx$[ebp], edx

; 25   : 	if ( idx == m_jiggleBoneState.InvalidIndex() )

	call	?InvalidIndex@?$CUtlLinkedList@UJiggleData@@G@@SAGXZ ; CUtlLinkedList<JiggleData,unsigned short>::InvalidIndex
	movzx	eax, ax
	cmp	DWORD PTR _idx$[ebp], eax
	jne	SHORT $LN6@GetJiggleD

; 26   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@GetJiggleD
$LN6@GetJiggleD:

; 27   : 
; 28   : 	return &m_jiggleBoneState[idx];

	movzx	ecx, WORD PTR _idx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlLinkedList@UJiggleData@@G@@QAEAAUJiggleData@@G@Z ; CUtlLinkedList<JiggleData,unsigned short>::operator[]
$LN1@GetJiggleD:

; 29   : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetJiggleData@CJiggleBones@@QAEPAUJiggleData@@HMABVVector@@0@Z ENDP ; CJiggleBones::GetJiggleData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0JiggleData@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0JiggleData@@QAE@ABU0@@Z PROC				; JiggleData::JiggleData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 104				; 00000068H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR [edx+140], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR [edx+144], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0JiggleData@@QAE@ABU0@@Z ENDP				; JiggleData::JiggleData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0JiggleData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0JiggleData@@QAE@XZ PROC				; JiggleData::JiggleData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0JiggleData@@QAE@XZ ENDP				; JiggleData::JiggleData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\jigglebones.h
;	COMDAT ?Init@JiggleData@@QAEXHMABVVector@@0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 12
$T2 = -16						; size = 12
_this$ = -4						; size = 4
_initBone$ = 8						; size = 4
_currenttime$ = 12					; size = 4
_initBasePos$ = 16					; size = 4
_initTipPos$ = 20					; size = 4
?Init@JiggleData@@QAEXHMABVVector@@0@Z PROC		; JiggleData::Init, COMDAT
; _this$ = ecx

; 23   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 		bone = initBone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _initBone$[ebp]
	mov	DWORD PTR [eax], ecx

; 25   : 
; 26   : 		lastUpdate = currenttime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currenttime$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 27   : 
; 28   : 		basePos = initBasePos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _initBasePos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 29   : 		baseLastPos = basePos;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 30   : 		baseVel.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 31   : 		baseAccel.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 32   : 
; 33   : 		tipPos = initTipPos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _initTipPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 34   : 		tipVel.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 35   : 		tipAccel.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 36   : 
; 37   : 		lastLeft = Vector( 0, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 38   : 
; 39   : 		lastBoingPos = initBasePos;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	mov	edx, DWORD PTR _initBasePos$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 40   : 		boingDir = Vector( 0.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 41   : 		boingVelDir.Init();

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	call	?Init@Vector@@QAEXMMM@Z			; Vector::Init

; 42   : 		boingSpeed = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+140], xmm0

; 43   : 		boingTime = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+144], xmm0

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Init@JiggleData@@QAEXHMABVVector@@0@Z ENDP		; JiggleData::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\utlmemory.h
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8					; size = 4
_nGrowSize$ = 12					; size = 4
_nNewSize$ = 16						; size = 4
_nBytesItem$ = 20					; size = 4
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $LN4@UtlMemory_

; 530  : 	{ 
; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 532  : 	}
; 533  : 	else 

	jmp	SHORT $LN5@UtlMemory_
$LN4@UtlMemory_:

; 534  : 	{
; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $LN2@UtlMemory_

; 536  : 		{
; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$LN2@UtlMemory_:

; 539  : 		}
; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $LN5@UtlMemory_

; 542  : 		{
; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $LN2@UtlMemory_
$LN5@UtlMemory_:

; 553  : 	}
; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

	push	ebp
	mov	ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 188  :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0matrix3x4@@QAE@ABV0@@Z PROC				; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@ABV0@@Z		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??__G@YGXPAX0IIP6EPAX00@Z@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x4@@QAE@ABV0@@Z ENDP				; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?Transpose@matrix3x4@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Transpose@matrix3x4@@QBE?AV1@XZ PROC			; matrix3x4::Transpose, COMDAT
; _this$ = ecx

; 626  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 		return matrix3x4(  // transpose 3x3, position is unchanged

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	shl	edx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	imul	ecx, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, 4
	imul	ecx, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, 4
	imul	edx, ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix3x4@@QAE@MMMMMMMMMMMM@Z	; matrix3x4::matrix3x4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 628  : 			mat[0][0], mat[1][0], mat[2][0],
; 629  : 			mat[0][1], mat[1][1], mat[2][1],
; 630  : 			mat[0][2], mat[1][2], mat[2][2],
; 631  : 			mat[3][0], mat[3][1], mat[3][2] );
; 632  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Transpose@matrix3x4@@QBE?AV1@XZ ENDP			; matrix3x4::Transpose
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetOrigin@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vOrigin$ = 8						; size = 4
?SetOrigin@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetOrigin, COMDAT
; _this$ = ecx

; 519  : 	void	SetOrigin( const Vector &vOrigin ) { mat[3] = vOrigin; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vOrigin$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetOrigin@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetUp@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vUp$ = 8						; size = 4
?SetUp@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetUp, COMDAT
; _this$ = ecx

; 517  : 	void	SetUp( const Vector &vUp ) { mat[2] = vUp; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vUp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUp@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetRight@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vRight$ = 8						; size = 4
?SetRight@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetRight, COMDAT
; _this$ = ecx

; 516  : 	void	SetRight( const Vector &vRight ) { mat[1] = vRight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vRight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRight@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ?SetForward@matrix3x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vForward$ = 8						; size = 4
?SetForward@matrix3x4@@QAEXABVVector@@@Z PROC		; matrix3x4::SetForward, COMDAT
; _this$ = ecx

; 515  : 	void	SetForward( const Vector &vForward ) { mat[0] = vForward; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vForward$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetForward@matrix3x4@@QAEXABVVector@@@Z ENDP		; matrix3x4::SetForward
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??Amatrix3x4@@QBEPBMH@Z PROC				; matrix3x4::operator[], COMDAT
; _this$ = ecx

; 487  : 	float const* operator[]( int i ) const { return mat[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QBEPBMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??Amatrix3x4@@QAEPAMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??Amatrix3x4@@QAEPAMH@Z PROC				; matrix3x4::operator[], COMDAT
; _this$ = ecx

; 486  : 	float* operator[]( int i ) { return mat[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	esp, ebp
	pop	ebp
	ret	4
??Amatrix3x4@@QAEPAMH@Z ENDP				; matrix3x4::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\matrix.h
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m00$ = 8						; size = 4
_m01$ = 12						; size = 4
_m02$ = 16						; size = 4
_m10$ = 20						; size = 4
_m11$ = 24						; size = 4
_m12$ = 28						; size = 4
_m20$ = 32						; size = 4
_m21$ = 36						; size = 4
_m22$ = 40						; size = 4
_m30$ = 44						; size = 4
_m31$ = 48						; size = 4
_m32$ = 52						; size = 4
??0matrix3x4@@QAE@MMMMMMMMMMMM@Z PROC			; matrix3x4::matrix3x4, COMDAT
; _this$ = ecx

; 242  : 	matrix3x4( float m00, float m01, float m02,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIIP6EPAX0@Z@Z

; 243  : 		 float m10, float m11, float m12,
; 244  : 		 float m20, float m21, float m22,
; 245  : 		 float m30, float m31, float m32 )
; 246  : 	{
; 247  : 		mat[0][0] = m00;

	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR _m00$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 248  : 		mat[0][1] = m01;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _m01$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 249  : 		mat[0][2] = m02;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _m02$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 250  : 		mat[1][0] = m10;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR _m10$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 251  : 		mat[1][1] = m11;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _m11$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 252  : 		mat[1][2] = m12;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _m12$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 253  : 		mat[2][0] = m20;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR _m20$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 254  : 		mat[2][1] = m21;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _m21$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 255  : 		mat[2][2] = m22;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _m22$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 256  : 		mat[3][0] = m30;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _m30$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 257  : 		mat[3][1] = m31;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _m31$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 258  : 		mat[3][2] = m32;

	mov	edx, 12					; 0000000cH
	imul	ecx, edx, 3
	add	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _m32$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 259  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
??0matrix3x4@@QAE@MMMMMMMMMMMM@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?CrossProduct@@YA?AVVector@@ABV1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
?CrossProduct@@YA?AVVector@@ABV1@0@Z PROC		; CrossProduct, COMDAT

; 280  : inline Vector CrossProduct( const Vector& a, const Vector& b ) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
?CrossProduct@@YA?AVVector@@ABV1@0@Z ENDP		; CrossProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
tv86 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?DotProduct@@YAMABVVector@@0@Z PROC			; DotProduct, COMDAT

; 278  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR tv86[ebp], xmm0
	fld	DWORD PTR tv86[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AVVector@@MABV0@@Z PROC				; operator*, COMDAT

; 277  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fl$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_flLen$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Normalize@Vector@@QBE?AV1@XZ PROC			; Vector::Normalize, COMDAT
; _this$ = ecx

; 229  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 231  : 
; 232  : 		if( flLen )

	movss	xmm0, DWORD PTR _flLen$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 233  : 		{
; 234  : 			flLen = 1.0f / flLen;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _flLen$[ebp]
	movss	DWORD PTR _flLen$[ebp], xmm0

; 235  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _flLen$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@Normalize
$LN2@Normalize:

; 236  : 		}
; 237  : 
; 238  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Normalize:

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QBEPBMXZ PROC				; Vector::operator float const *, COMDAT
; _this$ = ecx

; 226  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
?Length@Vector@@QBEMXZ PROC				; Vector::Length, COMDAT
; _this$ = ecx

; 223  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv91[ebp]
	fld	DWORD PTR tv91[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??ZVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??ZVector@@QAEAAV0@ABV0@@Z PROC				; Vector::operator-=, COMDAT
; _this$ = ecx

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 		x-=v.x; y-=v.y; z -= v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 163  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 164  : 	}		

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??YVector@@QAEAAV0@ABV0@@Z PROC				; Vector::operator+=, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 158  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 159  : 	}			

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??KVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
??KVector@@QBE?AV0@M@Z PROC				; Vector::operator/, COMDAT
; _this$ = ecx

; 151  : 	inline Vector operator/(float fl) const		{ return Vector(x/fl, y/fl, z/fl);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	divss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	divss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	divss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??KVector@@QBE?AV0@M@Z ENDP				; Vector::operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fl$ = 12						; size = 4
??DVector@@QBE?AV0@M@Z PROC				; Vector::operator*, COMDAT
; _this$ = ecx

; 150  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 147  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HVector@@QBE?AV0@ABV0@@Z PROC				; Vector::operator+, COMDAT
; _this$ = ecx

; 146  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??GVector@@QBE?AV0@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector@@QBE?AV0@XZ PROC				; Vector::operator-, COMDAT
; _this$ = ecx

; 143  : 	inline Vector operator-(void) const		{ return Vector(-x,-y,-z);		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??GVector@@QBE?AV0@XZ ENDP				; Vector::operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?Init@Vector@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_iz$ = 16						; size = 4
?Init@Vector@@QAEXMMM@Z PROC				; Vector::Init, COMDAT
; _this$ = ecx

; 140  : 	void Init(float ix=0.0f, float iy=0.0f, float iz=0.0f){ x = ix; y = iy; z = iz; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ix$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _iz$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@Vector@@QAEXMMM@Z ENDP				; Vector::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@QAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rgfl$ = 8						; size = 4
??0Vector@@QAE@QAM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 135  : 	inline Vector(float rgfl[3])			{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgfl$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@QAM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@PBM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rgfl$ = 8						; size = 4
??0Vector@@QAE@PBM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 134  : 	inline Vector( const float *rgfl )		{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rgfl$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rgfl$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@PBM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 132  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _X$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Z$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 131  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
_sine$ = 12						; size = 4
_cosine$ = 16						; size = 4
?SinCos@@YAXMPAM0@Z PROC				; SinCos, COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp

; 34   : 	__asm
; 35   : 	{
; 36   : 		push	ecx

	push	ecx

; 37   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 38   : 		fsincos

	fsincos

; 39   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 40   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 41   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 42   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 43   : 		pop	ecx

	pop	ecx

; 44   : 	}
; 45   : }

	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
