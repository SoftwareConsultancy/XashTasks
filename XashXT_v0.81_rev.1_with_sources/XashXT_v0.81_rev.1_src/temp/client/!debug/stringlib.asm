; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27045.0 

	TITLE	C:\Users\USER\Downloads\XashXT_v0.81_rev.1_with_sources\XashXT_v0.81_rev.1_src\game_shared\stringlib.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG125411 DB	00H
	ORG $+3
$SG125781 DB	' Mb', 00H
$SG125784 DB	' Kb', 00H
$SG125785 DB	' bytes', 00H
	ORG $+1
$SG125788 DB	'%i%s', 00H
	ORG $+3
$SG125789 DB	'%%.%if%s', 00H
	ORG $+3
$SG125790 DB	'.', 00H
	ORG $+2
$SG125792 DB	' ', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??__G@YGXPAX0IIP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?UTIL_FileExtension@@YAPBDPBD@Z			; UTIL_FileExtension
PUBLIC	?Q_strnupr@@YAXPBDPADI@Z			; Q_strnupr
PUBLIC	?Q_strnlwr@@YAXPBDPADI@Z			; Q_strnlwr
PUBLIC	?Q_isdigit@@YA_NPBD@Z				; Q_isdigit
PUBLIC	?Q_strlen@@YAHPBD@Z				; Q_strlen
PUBLIC	?Q_toupper@@YADD@Z				; Q_toupper
PUBLIC	?Q_tolower@@YADD@Z				; Q_tolower
PUBLIC	?Q_strncat@@YAIPADPBDI@Z			; Q_strncat
PUBLIC	?Q_strncpy@@YAIPADPBDI@Z			; Q_strncpy
PUBLIC	?copystring@@YAPADPBD@Z				; copystring
PUBLIC	?Q_atoi@@YAHPBD@Z				; Q_atoi
PUBLIC	?Q_atof@@YAMPBD@Z				; Q_atof
PUBLIC	?Q_atov@@YA?AVVector@@PBD@Z			; Q_atov
PUBLIC	?Q_strchr@@YAPADPBDD@Z				; Q_strchr
PUBLIC	?Q_strrchr@@YAPADPBDD@Z				; Q_strrchr
PUBLIC	?Q_strnicmp@@YAHPBD0H@Z				; Q_strnicmp
PUBLIC	?Q_strncmp@@YAHPBD0H@Z				; Q_strncmp
PUBLIC	?Q_strstr@@YAPADPBD0@Z				; Q_strstr
PUBLIC	?Q_stristr@@YAPADPBD0@Z				; Q_stristr
PUBLIC	?Q_vsnprintf@@YAHPADIPBD0@Z			; Q_vsnprintf
PUBLIC	?Q_snprintf@@YAHPADIPBDZZ			; Q_snprintf
PUBLIC	?Q_sprintf@@YAHPADPBDZZ				; Q_sprintf
PUBLIC	?Q_pretifymem@@YAPADMH@Z			; Q_pretifymem
PUBLIC	?va@@YAPADPBDZZ					; va
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@00000000
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	__real@4024000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@4048000000000000
PUBLIC	__real@4050400000000000
PUBLIC	__real@4058400000000000
PUBLIC	__real@44800000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_isdigit:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_fabs:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?string@?1??va@@YAPADPBDZZ@4PAY0EAA@DA
_BSS	SEGMENT
?string@?1??va@@YAPADPBDZZ@4PAY0EAA@DA DB 010000H DUP (?) ; `va'::`2'::string
_BSS	ENDS
;	COMDAT ?s@?1??va@@YAPADPBDZZ@4PADA
_BSS	SEGMENT
?s@?1??va@@YAPADPBDZZ@4PADA DD 01H DUP (?)		; `va'::`2'::s
_BSS	ENDS
;	COMDAT ?stringindex@?1??va@@YAPADPBDZZ@4HA
_BSS	SEGMENT
?stringindex@?1??va@@YAPADPBDZZ@4HA DD 01H DUP (?)	; `va'::`2'::stringindex
_BSS	ENDS
;	COMDAT ?output@?1??Q_pretifymem@@YAPADMH@Z@4PAY0CA@DA
_BSS	SEGMENT
?output@?1??Q_pretifymem@@YAPADMH@Z@4PAY0CA@DA DB 0100H DUP (?) ; `Q_pretifymem'::`2'::output
_BSS	ENDS
;	COMDAT ?current@?1??Q_pretifymem@@YAPADMH@Z@4HA
_BSS	SEGMENT
?current@?1??Q_pretifymem@@YAPADMH@Z@4HA DD 01H DUP (?)	; `Q_pretifymem'::`2'::current
_BSS	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@4058400000000000
CONST	SEGMENT
__real@4058400000000000 DQ 04058400000000000r	; 97
CONST	ENDS
;	COMDAT __real@4050400000000000
CONST	SEGMENT
__real@4050400000000000 DQ 04050400000000000r	; 65
CONST	ENDS
;	COMDAT __real@4048000000000000
CONST	SEGMENT
__real@4048000000000000 DQ 04048000000000000r	; 48
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_argptr$ = -4						; size = 4
_format$ = 8						; size = 4
?va@@YAPADPBDZZ PROC					; va

; 497  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 498  : 	va_list		argptr;
; 499  : 	static char	string[64][1024], *s;
; 500  : 	static int	stringindex = 0;
; 501  : 
; 502  : 	s = string[stringindex];

	mov	eax, DWORD PTR ?stringindex@?1??va@@YAPADPBDZZ@4HA
	shl	eax, 10					; 0000000aH
	add	eax, OFFSET ?string@?1??va@@YAPADPBDZZ@4PAY0EAA@DA
	mov	DWORD PTR ?s@?1??va@@YAPADPBDZZ@4PADA, eax

; 503  : 	stringindex = (stringindex + 1) & 63;

	mov	ecx, DWORD PTR ?stringindex@?1??va@@YAPADPBDZZ@4HA
	add	ecx, 1
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR ?stringindex@?1??va@@YAPADPBDZZ@4HA, ecx

; 504  : 	va_start( argptr, format );

	lea	edx, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], edx

; 505  : 	Q_vsnprintf( s, sizeof( string[0] ), format, argptr );

	mov	eax, DWORD PTR _argptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	1024					; 00000400H
	mov	edx, DWORD PTR ?s@?1??va@@YAPADPBDZZ@4PADA
	push	edx
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H

; 506  : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 507  : 
; 508  : 	return s;

	mov	eax, DWORD PTR ?s@?1??va@@YAPADPBDZZ@4PADA

; 509  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?va@@YAPADPBDZZ ENDP					; va
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv170 = -116						; size = 8
tv80 = -108						; size = 4
_onemb$ = -104						; size = 4
_out$ = -100						; size = 4
_dot$ = -96						; size = 4
_onekb$ = -92						; size = 4
_pos$ = -88						; size = 4
_i$ = -84						; size = 4
_o$ = -80						; size = 4
_fmt$1 = -76						; size = 32
_val$ = -44						; size = 32
_suffix$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_digitsafterdecimal$ = 12				; size = 4
?Q_pretifymem@@YAPADMH@Z PROC				; Q_pretifymem

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 513  : 	static char	output[8][32];
; 514  : 	static int	current;
; 515  : 	float		onekb = 1024.0f;

	movss	xmm0, DWORD PTR __real@44800000
	movss	DWORD PTR _onekb$[ebp], xmm0

; 516  : 	float		onemb = onekb * onekb;

	movss	xmm0, DWORD PTR _onekb$[ebp]
	mulss	xmm0, DWORD PTR _onekb$[ebp]
	movss	DWORD PTR _onemb$[ebp], xmm0

; 517  : 	char		suffix[8];
; 518  : 	char		*out = output[current];

	mov	eax, DWORD PTR ?current@?1??Q_pretifymem@@YAPADMH@Z@4HA
	shl	eax, 5
	add	eax, OFFSET ?output@?1??Q_pretifymem@@YAPADMH@Z@4PAY0CA@DA
	mov	DWORD PTR _out$[ebp], eax

; 519  : 	char		val[32], *i, *o, *dot;
; 520  : 	int		pos;
; 521  : 
; 522  : 	current = ( current + 1 ) & ( 8 - 1 );

	mov	ecx, DWORD PTR ?current@?1??Q_pretifymem@@YAPADMH@Z@4HA
	add	ecx, 1
	and	ecx, 7
	mov	DWORD PTR ?current@?1??Q_pretifymem@@YAPADMH@Z@4HA, ecx

; 523  : 
; 524  : 	// first figure out which bin to use
; 525  : 	if( value > onemb )

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR _onemb$[ebp]
	jbe	SHORT $LN4@Q_pretifym

; 526  : 	{
; 527  : 		value /= onemb;

	movss	xmm0, DWORD PTR _value$[ebp]
	divss	xmm0, DWORD PTR _onemb$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 528  : 		Q_sprintf( suffix, " Mb" );

	push	OFFSET $SG125781
	lea	edx, DWORD PTR _suffix$[ebp]
	push	edx
	call	?Q_sprintf@@YAHPADPBDZZ			; Q_sprintf
	add	esp, 8
	jmp	SHORT $LN7@Q_pretifym
$LN4@Q_pretifym:

; 529  : 	}
; 530  : 	else if( value > onekb )

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR _onekb$[ebp]
	jbe	SHORT $LN6@Q_pretifym

; 531  : 	{
; 532  : 		value /= onekb;

	movss	xmm0, DWORD PTR _value$[ebp]
	divss	xmm0, DWORD PTR _onekb$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 533  : 		Q_sprintf( suffix, " Kb" );

	push	OFFSET $SG125784
	lea	eax, DWORD PTR _suffix$[ebp]
	push	eax
	call	?Q_sprintf@@YAHPADPBDZZ			; Q_sprintf
	add	esp, 8
	jmp	SHORT $LN7@Q_pretifym
$LN6@Q_pretifym:

; 534  : 	}
; 535  : 	else Q_sprintf( suffix, " bytes" );

	push	OFFSET $SG125785
	lea	ecx, DWORD PTR _suffix$[ebp]
	push	ecx
	call	?Q_sprintf@@YAHPADPBDZZ			; Q_sprintf
	add	esp, 8
$LN7@Q_pretifym:

; 536  : 
; 537  : 	// clamp to >= 0
; 538  : 	digitsafterdecimal = Q_max( digitsafterdecimal, 0 );

	cmp	DWORD PTR _digitsafterdecimal$[ebp], 0
	jle	SHORT $LN14@Q_pretifym
	mov	edx, DWORD PTR _digitsafterdecimal$[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN15@Q_pretifym
$LN14@Q_pretifym:
	mov	DWORD PTR tv80[ebp], 0
$LN15@Q_pretifym:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR _digitsafterdecimal$[ebp], eax

; 539  : 
; 540  : 	// if it's basically integral, don't do any decimals
; 541  : 	if( fabs( value - (int)value ) < 0.00001 )

	cvttss2si ecx, DWORD PTR _value$[ebp]
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _value$[ebp]
	subss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv170[ebp]
	movsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	comisd	xmm0, QWORD PTR tv170[ebp]
	jbe	SHORT $LN8@Q_pretifym

; 542  : 	{
; 543  : 		Q_sprintf( val, "%i%s", (int)value, suffix );

	lea	edx, DWORD PTR _suffix$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET $SG125788
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?Q_sprintf@@YAHPADPBDZZ			; Q_sprintf
	add	esp, 16					; 00000010H

; 544  : 	}
; 545  : 	else

	jmp	SHORT $LN9@Q_pretifym
$LN8@Q_pretifym:

; 546  : 	{
; 547  : 		char fmt[32];
; 548  : 
; 549  : 		// otherwise, create a format string for the decimals
; 550  : 		Q_sprintf( fmt, "%%.%if%s", digitsafterdecimal, suffix );

	lea	edx, DWORD PTR _suffix$[ebp]
	push	edx
	mov	eax, DWORD PTR _digitsafterdecimal$[ebp]
	push	eax
	push	OFFSET $SG125789
	lea	ecx, DWORD PTR _fmt$1[ebp]
	push	ecx
	call	?Q_sprintf@@YAHPADPBDZZ			; Q_sprintf
	add	esp, 16					; 00000010H

; 551  : 		Q_sprintf( val, fmt, value );

	cvtss2sd xmm0, DWORD PTR _value$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _fmt$1[ebp]
	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	call	?Q_sprintf@@YAHPADPBDZZ			; Q_sprintf
	add	esp, 16					; 00000010H
$LN9@Q_pretifym:

; 552  : 	}
; 553  : 
; 554  : 	// copy from in to out
; 555  : 	i = val;

	lea	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _i$[ebp], ecx

; 556  : 	o = out;

	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _o$[ebp], edx

; 557  : 
; 558  : 	// search for decimal or if it was integral, find the space after the raw number
; 559  : 	dot = Q_strstr( i, "." );

	push	OFFSET $SG125790
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?Q_strstr@@YAPADPBD0@Z			; Q_strstr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax

; 560  : 	if( !dot ) dot = Q_strstr( i, " " );

	cmp	DWORD PTR _dot$[ebp], 0
	jne	SHORT $LN10@Q_pretifym
	push	OFFSET $SG125792
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?Q_strstr@@YAPADPBD0@Z			; Q_strstr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax
$LN10@Q_pretifym:

; 561  : 
; 562  : 	pos = dot - i;	// compute position of dot

	mov	edx, DWORD PTR _dot$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _pos$[ebp], edx

; 563  : 	pos -= 3;		// don't put a comma if it's <= 3 long

	mov	eax, DWORD PTR _pos$[ebp]
	sub	eax, 3
	mov	DWORD PTR _pos$[ebp], eax
$LN2@Q_pretifym:

; 564  : 
; 565  : 	while( *i )

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Q_pretifym

; 566  : 	{
; 567  : 		// if pos is still valid then insert a comma every third digit, except if we would be
; 568  : 		// putting one in the first spot
; 569  : 		if( pos >= 0 && !( pos % 3 ))

	cmp	DWORD PTR _pos$[ebp], 0
	jl	SHORT $LN12@Q_pretifym
	mov	eax, DWORD PTR _pos$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN12@Q_pretifym

; 570  : 		{
; 571  : 			// never in first spot
; 572  : 			if( o != out ) *o++ = ',';

	mov	edx, DWORD PTR _o$[ebp]
	cmp	edx, DWORD PTR _out$[ebp]
	je	SHORT $LN12@Q_pretifym
	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 44			; 0000002cH
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
$LN12@Q_pretifym:

; 573  : 		}
; 574  : 
; 575  : 		pos--;		// count down comma position

	mov	edx, DWORD PTR _pos$[ebp]
	sub	edx, 1
	mov	DWORD PTR _pos$[ebp], edx

; 576  : 		*o++ = *i++;	// copy rest of data as normal

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 577  : 	}

	jmp	SHORT $LN2@Q_pretifym
$LN3@Q_pretifym:

; 578  : 	*o = 0; // terminate

	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx], 0

; 579  : 
; 580  : 	return out;

	mov	eax, DWORD PTR _out$[ebp]

; 581  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?Q_pretifymem@@YAPADMH@Z ENDP				; Q_pretifymem
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_result$ = -8						; size = 4
_args$ = -4						; size = 4
_buffer$ = 8						; size = 4
_format$ = 12						; size = 4
?Q_sprintf@@YAHPADPBDZZ PROC				; Q_sprintf

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 477  : 	va_list	args;
; 478  : 	int	result;
; 479  : 
; 480  : 	va_start( args, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 481  : 	result = Q_vsnprintf( buffer, 99999, format, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 482  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 483  : 
; 484  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 485  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_sprintf@@YAHPADPBDZZ ENDP				; Q_sprintf
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_result$ = -8						; size = 4
_args$ = -4						; size = 4
_buffer$ = 8						; size = 4
_buffersize$ = 12					; size = 4
_format$ = 16						; size = 4
?Q_snprintf@@YAHPADIPBDZZ PROC				; Q_snprintf

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 465  : 	va_list	args;
; 466  : 	int	result;
; 467  : 
; 468  : 	va_start( args, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 469  : 	result = Q_vsnprintf( buffer, buffersize, format, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffersize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?Q_vsnprintf@@YAHPADIPBD0@Z		; Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 470  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 471  : 
; 472  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 473  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_snprintf@@YAHPADIPBDZZ ENDP				; Q_snprintf
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_result$ = -4						; size = 4
_buffer$ = 8						; size = 4
_buffersize$ = 12					; size = 4
_format$ = 16						; size = 4
_args$ = 20						; size = 4
?Q_vsnprintf@@YAHPADIPBD0@Z PROC			; Q_vsnprintf

; 450  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 451  : 	size_t	result;
; 452  : 
; 453  : 	result = _vsnprintf( buffer, buffersize, format, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffersize$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 454  : 
; 455  : 	if( result < 0 || result >= buffersize )

	cmp	DWORD PTR _result$[ebp], 0
	jb	SHORT $LN3@Q_vsnprint
	mov	ecx, DWORD PTR _result$[ebp]
	cmp	ecx, DWORD PTR _buffersize$[ebp]
	jb	SHORT $LN2@Q_vsnprint
$LN3@Q_vsnprint:

; 456  : 	{
; 457  : 		buffer[buffersize - 1] = '\0';

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _buffersize$[ebp]
	mov	BYTE PTR [edx-1], 0

; 458  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@Q_vsnprint
$LN2@Q_vsnprint:

; 459  : 	}
; 460  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@Q_vsnprint:

; 461  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_vsnprintf@@YAHPADIPBD0@Z ENDP			; Q_vsnprintf
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_len$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_string2$ = 12						; size = 4
?Q_stristr@@YAPADPBD0@Z PROC				; Q_stristr

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 427  : 	int	c, len;
; 428  : 
; 429  : 	if( !string || !string2 ) return NULL;

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN8@Q_stristr
	cmp	DWORD PTR _string2$[ebp], 0
	jne	SHORT $LN7@Q_stristr
$LN8@Q_stristr:
	xor	eax, eax
	jmp	$LN1@Q_stristr
$LN7@Q_stristr:

; 430  : 
; 431  : 	c = Q_tolower( *string2 );

	mov	eax, DWORD PTR _string2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	?Q_tolower@@YADD@Z			; Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR _c$[ebp], edx

; 432  : 	len = Q_strlen( string2 );

	mov	eax, DWORD PTR _string2$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN2@Q_stristr:

; 433  : 
; 434  : 	while( string )

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@Q_stristr
	jmp	SHORT $LN6@Q_stristr
$LN4@Q_stristr:

; 435  : 	{
; 436  : 		for( ; *string && Q_tolower( *string ) != c; string++ );

	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, 1
	mov	DWORD PTR _string$[ebp], ecx
$LN6@Q_stristr:
	mov	edx, DWORD PTR _string$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@Q_stristr
	mov	ecx, DWORD PTR _string$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?Q_tolower@@YADD@Z			; Q_tolower
	add	esp, 4
	movsx	eax, al
	cmp	eax, DWORD PTR _c$[ebp]
	je	SHORT $LN5@Q_stristr
	jmp	SHORT $LN4@Q_stristr
$LN5@Q_stristr:

; 437  : 
; 438  : 		if( *string )

	mov	ecx, DWORD PTR _string$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@Q_stristr

; 439  : 		{
; 440  : 			if( !Q_strnicmp( string, string2, len ))

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Q_stristr

; 441  : 				break;

	jmp	SHORT $LN3@Q_stristr
$LN11@Q_stristr:

; 442  : 			string++;

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax
	jmp	SHORT $LN10@Q_stristr
$LN9@Q_stristr:

; 443  : 		}
; 444  : 		else return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Q_stristr
$LN10@Q_stristr:

; 445  : 	}

	jmp	SHORT $LN2@Q_stristr
$LN3@Q_stristr:

; 446  : 	return (char *)string;

	mov	eax, DWORD PTR _string$[ebp]
$LN1@Q_stristr:

; 447  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_stristr@@YAPADPBD0@Z ENDP				; Q_stristr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_len$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_string2$ = 12						; size = 4
?Q_strstr@@YAPADPBD0@Z PROC				; Q_strstr

; 402  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 403  : 	int	c, len;
; 404  : 
; 405  : 	if( !string || !string2 ) return NULL;

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN8@Q_strstr
	cmp	DWORD PTR _string2$[ebp], 0
	jne	SHORT $LN7@Q_strstr
$LN8@Q_strstr:
	xor	eax, eax
	jmp	SHORT $LN1@Q_strstr
$LN7@Q_strstr:

; 406  : 
; 407  : 	c = *string2;

	mov	eax, DWORD PTR _string2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx

; 408  : 	len = Q_strlen( string2 );

	mov	edx, DWORD PTR _string2$[ebp]
	push	edx
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN2@Q_strstr:

; 409  : 
; 410  : 	while( string )

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@Q_strstr
	jmp	SHORT $LN6@Q_strstr
$LN4@Q_strstr:

; 411  : 	{
; 412  : 		for( ; *string && *string != c; string++ );

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax
$LN6@Q_strstr:
	mov	ecx, DWORD PTR _string$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@Q_strstr
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _c$[ebp]
	je	SHORT $LN5@Q_strstr
	jmp	SHORT $LN4@Q_strstr
$LN5@Q_strstr:

; 413  : 
; 414  : 		if( *string )

	mov	edx, DWORD PTR _string$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN9@Q_strstr

; 415  : 		{
; 416  : 			if( !Q_strncmp( string, string2, len ))

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string2$[ebp]
	push	edx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Q_strstr

; 417  : 				break;

	jmp	SHORT $LN3@Q_strstr
$LN11@Q_strstr:

; 418  : 			string++;

	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, 1
	mov	DWORD PTR _string$[ebp], ecx
	jmp	SHORT $LN10@Q_strstr
$LN9@Q_strstr:

; 419  : 		}
; 420  : 		else return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Q_strstr
$LN10@Q_strstr:

; 421  : 	}

	jmp	SHORT $LN2@Q_strstr
$LN3@Q_strstr:

; 422  : 	return (char *)string;

	mov	eax, DWORD PTR _string$[ebp]
$LN1@Q_strstr:

; 423  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strstr@@YAPADPBD0@Z ENDP				; Q_strstr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv73 = -16						; size = 4
tv76 = -12						; size = 4
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
?Q_strncmp@@YAHPBD0H@Z PROC				; Q_strncmp

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 377  : 	int		c1, c2;
; 378  : 
; 379  : 	if( s1 == NULL )

	cmp	DWORD PTR _s1$[ebp], 0
	jne	SHORT $LN5@Q_strncmp

; 380  : 	{
; 381  : 		if( s2 == NULL ) return 0;

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN7@Q_strncmp
	xor	eax, eax
	jmp	$LN1@Q_strncmp
	jmp	SHORT $LN8@Q_strncmp
$LN7@Q_strncmp:

; 382  : 		else return -1;

	or	eax, -1
	jmp	SHORT $LN1@Q_strncmp
$LN8@Q_strncmp:
	jmp	SHORT $LN4@Q_strncmp
$LN5@Q_strncmp:

; 383  : 	}
; 384  : 	else if( s2 == NULL )

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN4@Q_strncmp

; 385  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Q_strncmp
$LN4@Q_strncmp:

; 386  : 	
; 387  : 	do {
; 388  : 		c1 = *s1++;

	mov	eax, DWORD PTR _s1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c1$[ebp], ecx
	mov	edx, DWORD PTR _s1$[ebp]
	add	edx, 1
	mov	DWORD PTR _s1$[ebp], edx

; 389  : 		c2 = *s2++;

	mov	eax, DWORD PTR _s2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c2$[ebp], ecx
	mov	edx, DWORD PTR _s2$[ebp]
	add	edx, 1
	mov	DWORD PTR _s2$[ebp], edx

; 390  : 
; 391  : 		// strings are equal until end point
; 392  : 		if( !n-- ) return 0;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 0
	jne	SHORT $LN10@Q_strncmp
	xor	eax, eax
	jmp	SHORT $LN1@Q_strncmp
$LN10@Q_strncmp:

; 393  : 		if( c1 != c2 ) return c1 < c2 ? -1 : 1;

	mov	edx, DWORD PTR _c1$[ebp]
	cmp	edx, DWORD PTR _c2$[ebp]
	je	SHORT $LN2@Q_strncmp
	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	jge	SHORT $LN13@Q_strncmp
	mov	DWORD PTR tv76[ebp], -1
	jmp	SHORT $LN14@Q_strncmp
$LN13@Q_strncmp:
	mov	DWORD PTR tv76[ebp], 1
$LN14@Q_strncmp:
	mov	eax, DWORD PTR tv76[ebp]
	jmp	SHORT $LN1@Q_strncmp
$LN2@Q_strncmp:

; 394  : 
; 395  : 	} while( c1 );

	cmp	DWORD PTR _c1$[ebp], 0
	jne	SHORT $LN4@Q_strncmp

; 396  : 	
; 397  : 	// strings are equal
; 398  : 	return 0;

	xor	eax, eax
$LN1@Q_strncmp:

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strncmp@@YAHPBD0H@Z ENDP				; Q_strncmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv73 = -16						; size = 4
tv83 = -12						; size = 4
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
?Q_strnicmp@@YAHPBD0H@Z PROC				; Q_strnicmp

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 347  : 	int	c1, c2;
; 348  : 
; 349  : 	if( s1 == NULL )

	cmp	DWORD PTR _s1$[ebp], 0
	jne	SHORT $LN5@Q_strnicmp

; 350  : 	{
; 351  : 		if( s2 == NULL ) return 0;

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN7@Q_strnicmp
	xor	eax, eax
	jmp	$LN1@Q_strnicmp
	jmp	SHORT $LN8@Q_strnicmp
$LN7@Q_strnicmp:

; 352  : 		else return -1;

	or	eax, -1
	jmp	$LN1@Q_strnicmp
$LN8@Q_strnicmp:
	jmp	SHORT $LN4@Q_strnicmp
$LN5@Q_strnicmp:

; 353  : 	}
; 354  : 	else if( s2 == NULL )

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN4@Q_strnicmp

; 355  : 		return 1;

	mov	eax, 1
	jmp	$LN1@Q_strnicmp
$LN4@Q_strnicmp:

; 356  : 
; 357  : 	do {
; 358  : 		c1 = *s1++;

	mov	eax, DWORD PTR _s1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c1$[ebp], ecx
	mov	edx, DWORD PTR _s1$[ebp]
	add	edx, 1
	mov	DWORD PTR _s1$[ebp], edx

; 359  : 		c2 = *s2++;

	mov	eax, DWORD PTR _s2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c2$[ebp], ecx
	mov	edx, DWORD PTR _s2$[ebp]
	add	edx, 1
	mov	DWORD PTR _s2$[ebp], edx

; 360  : 
; 361  : 		if( !n-- ) return 0; // strings are equal until end point

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 0
	jne	SHORT $LN10@Q_strnicmp
	xor	eax, eax
	jmp	SHORT $LN1@Q_strnicmp
$LN10@Q_strnicmp:

; 362  : 		
; 363  : 		if( c1 != c2 )

	mov	edx, DWORD PTR _c1$[ebp]
	cmp	edx, DWORD PTR _c2$[ebp]
	je	SHORT $LN2@Q_strnicmp

; 364  : 		{
; 365  : 			if( c1 >= 'a' && c1 <= 'z' ) c1 -= ('a' - 'A');

	cmp	DWORD PTR _c1$[ebp], 97			; 00000061H
	jl	SHORT $LN12@Q_strnicmp
	cmp	DWORD PTR _c1$[ebp], 122		; 0000007aH
	jg	SHORT $LN12@Q_strnicmp
	mov	eax, DWORD PTR _c1$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _c1$[ebp], eax
$LN12@Q_strnicmp:

; 366  : 			if( c2 >= 'a' && c2 <= 'z' ) c2 -= ('a' - 'A');

	cmp	DWORD PTR _c2$[ebp], 97			; 00000061H
	jl	SHORT $LN13@Q_strnicmp
	cmp	DWORD PTR _c2$[ebp], 122		; 0000007aH
	jg	SHORT $LN13@Q_strnicmp
	mov	ecx, DWORD PTR _c2$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR _c2$[ebp], ecx
$LN13@Q_strnicmp:

; 367  : 			if( c1 != c2 ) return c1 < c2 ? -1 : 1;

	mov	edx, DWORD PTR _c1$[ebp]
	cmp	edx, DWORD PTR _c2$[ebp]
	je	SHORT $LN2@Q_strnicmp
	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	jge	SHORT $LN16@Q_strnicmp
	mov	DWORD PTR tv83[ebp], -1
	jmp	SHORT $LN17@Q_strnicmp
$LN16@Q_strnicmp:
	mov	DWORD PTR tv83[ebp], 1
$LN17@Q_strnicmp:
	mov	eax, DWORD PTR tv83[ebp]
	jmp	SHORT $LN1@Q_strnicmp
$LN2@Q_strnicmp:

; 368  : 		}
; 369  : 	} while( c1 );

	cmp	DWORD PTR _c1$[ebp], 0
	jne	$LN4@Q_strnicmp

; 370  : 
; 371  : 	// strings are equal
; 372  : 	return 0;

	xor	eax, eax
$LN1@Q_strnicmp:

; 373  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strnicmp@@YAHPBD0H@Z ENDP				; Q_strnicmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv69 = -8						; size = 4
_len$ = -4						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 1
?Q_strrchr@@YAPADPBDD@Z PROC				; Q_strrchr

; 332  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 333  : 	int	len = Q_strlen( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 334  : 
; 335  : 	s += len;

	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _s$[ebp], ecx
$LN2@Q_strrchr:

; 336  : 
; 337  : 	while( len-- )

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@Q_strrchr

; 338  : 	{
; 339  : 		if( *--s == c )

	mov	ecx, DWORD PTR _s$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN4@Q_strrchr

; 340  : 			return (char *)s;

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN1@Q_strrchr
$LN4@Q_strrchr:

; 341  : 	}

	jmp	SHORT $LN2@Q_strrchr
$LN3@Q_strrchr:

; 342  : 	return 0;

	xor	eax, eax
$LN1@Q_strrchr:

; 343  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strrchr@@YAPADPBDD@Z ENDP				; Q_strrchr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv68 = -8						; size = 4
_len$ = -4						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 1
?Q_strchr@@YAPADPBDD@Z PROC				; Q_strchr

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 321  : 	int	len = Q_strlen( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN2@Q_strchr:

; 322  : 
; 323  : 	while( len-- )

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN3@Q_strchr

; 324  : 	{
; 325  : 		if( *++s == c )

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Q_strchr

; 326  : 			return (char *)s;

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN1@Q_strchr
$LN4@Q_strchr:

; 327  : 	}

	jmp	SHORT $LN2@Q_strchr
$LN3@Q_strchr:

; 328  : 	return 0;

	xor	eax, eax
$LN1@Q_strchr:

; 329  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strchr@@YAPADPBDD@Z ENDP				; Q_strchr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_vec$ = -288						; size = 12
tv137 = -276						; size = 4
_pfront$ = -272						; size = 4
_i$1 = -268						; size = 4
_pstr$ = -264						; size = 4
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?Q_atov@@YA?AVVector@@PBD@Z PROC			; Q_atov

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 297  : 	char	buffer[256];
; 298  : 	char	*pstr, *pfront;
; 299  : 	Vector	vec = g_vecZero;

	push	OFFSET ?g_vecZero@@3VVector@@B		; g_vecZero
	lea	ecx, DWORD PTR _vec$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 300  : 
; 301  : 	Q_strncpy( buffer, str, sizeof( buffer ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 302  : 	pstr = pfront = buffer;

	lea	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pfront$[ebp], edx
	mov	eax, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR _pstr$[ebp], eax

; 303  : 
; 304  : 	for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@Q_atov
$LN2@Q_atov:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@Q_atov:
	cmp	DWORD PTR _i$1[ebp], 3
	jge	$LN3@Q_atov

; 305  : 	{
; 306  : 		vec[i] = Q_atof( pfront );

	mov	edx, DWORD PTR _pfront$[ebp]
	push	edx
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	lea	ecx, DWORD PTR _vec$[ebp]
	fstp	DWORD PTR tv137[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _i$1[ebp]
	fld	DWORD PTR tv137[ebp]
	fstp	DWORD PTR [eax+ecx*4]
$LN5@Q_atov:

; 307  : 
; 308  : 		// valid separator is space
; 309  : 		while( *pstr && *pstr != ' ' )

	mov	edx, DWORD PTR _pstr$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@Q_atov
	mov	ecx, DWORD PTR _pstr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN6@Q_atov

; 310  : 			pstr++;

	mov	eax, DWORD PTR _pstr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstr$[ebp], eax
	jmp	SHORT $LN5@Q_atov
$LN6@Q_atov:

; 311  : 
; 312  : 		if( !*pstr ) break;

	mov	ecx, DWORD PTR _pstr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@Q_atov
	jmp	SHORT $LN3@Q_atov
$LN7@Q_atov:

; 313  : 		pstr++;

	mov	eax, DWORD PTR _pstr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstr$[ebp], eax

; 314  : 		pfront = pstr;

	mov	ecx, DWORD PTR _pstr$[ebp]
	mov	DWORD PTR _pfront$[ebp], ecx

; 315  : 	}

	jmp	$LN2@Q_atov
$LN3@Q_atov:

; 316  : 	return vec;

	lea	edx, DWORD PTR _vec$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 317  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?Q_atov@@YA?AVVector@@PBD@Z ENDP			; Q_atov
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_val$ = -44						; size = 8
tv225 = -36						; size = 4
tv218 = -32						; size = 4
tv207 = -28						; size = 4
tv206 = -24						; size = 4
tv198 = -20						; size = 4
_decimal$ = -16						; size = 4
_sign$ = -12						; size = 4
_total$ = -8						; size = 4
_c$ = -4						; size = 4
_str$ = 8						; size = 4
?Q_atof@@YAMPBD@Z PROC					; Q_atof

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 230  : 	double	val = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _val$[ebp], xmm0

; 231  : 	int	c, sign, decimal, total;
; 232  : 
; 233  : 	if( !str ) return 0.0f;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN10@Q_atof
	fldz
	jmp	$LN1@Q_atof
$LN10@Q_atof:

; 234  : 
; 235  : 	// check for empty charachters in string
; 236  : 	while( str && *str == ' ' )

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN3@Q_atof
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@Q_atof

; 237  : 		str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	jmp	SHORT $LN10@Q_atof
$LN3@Q_atof:

; 238  : 
; 239  : 	if( !str ) return 0.0f;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN11@Q_atof
	fldz
	jmp	$LN1@Q_atof
$LN11@Q_atof:

; 240  : 	
; 241  : 	if( *str == '-' )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN12@Q_atof

; 242  : 	{
; 243  : 		sign = -1;

	mov	DWORD PTR _sign$[ebp], -1

; 244  : 		str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	jmp	SHORT $LN13@Q_atof
$LN12@Q_atof:

; 245  : 	}
; 246  : 	else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN13@Q_atof:

; 247  : 		
; 248  : 	// check for hex
; 249  : 	if( str[0] == '0' && ( str[1] == 'x' || str[1] == 'X' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jne	$LN5@Q_atof
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN15@Q_atof
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 88					; 00000058H
	jne	$LN5@Q_atof
$LN15@Q_atof:

; 250  : 	{
; 251  : 		str += 2;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str$[ebp], ecx
$LN4@Q_atof:

; 252  : 		while( 1 )

	mov	edx, 1
	test	edx, edx
	je	$LN5@Q_atof

; 253  : 		{
; 254  : 			c = *str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 255  : 			if( c >= '0' && c <= '9' ) val = (val * 16) + c - '0';

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN16@Q_atof
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN16@Q_atof
	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4048000000000000
	movsd	QWORD PTR _val$[ebp], xmm0
	jmp	$LN21@Q_atof
$LN16@Q_atof:

; 256  : 			else if( c >= 'a' && c <= 'f' ) val = (val * 16) + c - 'a' + 10;

	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN18@Q_atof
	cmp	DWORD PTR _c$[ebp], 102			; 00000066H
	jg	SHORT $LN18@Q_atof
	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4058400000000000
	addsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _val$[ebp], xmm0
	jmp	SHORT $LN21@Q_atof
$LN18@Q_atof:

; 257  : 			else if( c >= 'A' && c <= 'F' ) val = (val * 16) + c - 'A' + 10;

	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN20@Q_atof
	cmp	DWORD PTR _c$[ebp], 70			; 00000046H
	jg	SHORT $LN20@Q_atof
	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4050400000000000
	addsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _val$[ebp], xmm0
	jmp	SHORT $LN21@Q_atof
$LN20@Q_atof:

; 258  : 			else return val * sign;

	cvtsi2sd xmm0, DWORD PTR _sign$[ebp]
	mulsd	xmm0, QWORD PTR _val$[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv198[ebp], xmm0
	fld	DWORD PTR tv198[ebp]
	jmp	$LN1@Q_atof
$LN21@Q_atof:

; 259  : 		}

	jmp	$LN4@Q_atof
$LN5@Q_atof:

; 260  : 	}
; 261  : 	
; 262  : 	// check for character
; 263  : 	if( str[0] == '\'' ) return sign * str[1];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN22@Q_atof
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	imul	eax, DWORD PTR _sign$[ebp]
	mov	DWORD PTR tv206[ebp], eax
	fild	DWORD PTR tv206[ebp]
	fstp	DWORD PTR tv207[ebp]
	fld	DWORD PTR tv207[ebp]
	jmp	$LN1@Q_atof
$LN22@Q_atof:

; 264  : 	
; 265  : 	// assume decimal
; 266  : 	decimal = -1;

	mov	DWORD PTR _decimal$[ebp], -1

; 267  : 	total = 0;

	mov	DWORD PTR _total$[ebp], 0
$LN28@Q_atof:

; 268  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@Q_atof

; 269  : 	{
; 270  : 		c = *str++;

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 271  : 		if( c == '.' )

	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	jne	SHORT $LN23@Q_atof

; 272  : 		{
; 273  : 			decimal = total;

	mov	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR _decimal$[ebp], edx

; 274  : 			continue;

	jmp	SHORT $LN28@Q_atof
$LN23@Q_atof:

; 275  : 		}
; 276  : 
; 277  : 		if( c < '0' || c > '9' )

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN25@Q_atof
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	SHORT $LN24@Q_atof
$LN25@Q_atof:

; 278  : 			break;

	jmp	SHORT $LN7@Q_atof
$LN24@Q_atof:

; 279  : 		val = val * 10 + c - '0';

	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4024000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4048000000000000
	movsd	QWORD PTR _val$[ebp], xmm0

; 280  : 		total++;

	mov	eax, DWORD PTR _total$[ebp]
	add	eax, 1
	mov	DWORD PTR _total$[ebp], eax

; 281  : 	}

	jmp	SHORT $LN28@Q_atof
$LN7@Q_atof:

; 282  : 
; 283  : 	if( decimal == -1 )

	cmp	DWORD PTR _decimal$[ebp], -1
	jne	SHORT $LN26@Q_atof

; 284  : 		return val * sign;

	cvtsi2sd xmm0, DWORD PTR _sign$[ebp]
	mulsd	xmm0, QWORD PTR _val$[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv218[ebp], xmm0
	fld	DWORD PTR tv218[ebp]
	jmp	SHORT $LN1@Q_atof
$LN26@Q_atof:

; 285  : 
; 286  : 	while( total > decimal )

	mov	ecx, DWORD PTR _total$[ebp]
	cmp	ecx, DWORD PTR _decimal$[ebp]
	jle	SHORT $LN9@Q_atof

; 287  : 	{
; 288  : 		val /= 10;

	movsd	xmm0, QWORD PTR _val$[ebp]
	divsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _val$[ebp], xmm0

; 289  : 		total--;

	mov	edx, DWORD PTR _total$[ebp]
	sub	edx, 1
	mov	DWORD PTR _total$[ebp], edx

; 290  : 	}

	jmp	SHORT $LN26@Q_atof
$LN9@Q_atof:

; 291  : 	
; 292  : 	return val * sign;

	cvtsi2sd xmm0, DWORD PTR _sign$[ebp]
	mulsd	xmm0, QWORD PTR _val$[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv225[ebp], xmm0
	fld	DWORD PTR tv225[ebp]
$LN1@Q_atof:

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_atof@@YAMPBD@Z ENDP					; Q_atof
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_sign$ = -12						; size = 4
_val$ = -8						; size = 4
_c$ = -4						; size = 4
_str$ = 8						; size = 4
?Q_atoi@@YAHPBD@Z PROC					; Q_atoi

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 181  : 	int       val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 182  : 	int	c, sign;
; 183  : 
; 184  : 	if( !str ) return 0;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@Q_atoi
	xor	eax, eax
	jmp	$LN1@Q_atoi
$LN2@Q_atoi:

; 185  : 
; 186  : 	// check for empty charachters in string
; 187  : 	while( str && *str == ' ' )

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN3@Q_atoi
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@Q_atoi

; 188  : 		str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	jmp	SHORT $LN2@Q_atoi
$LN3@Q_atoi:

; 189  : 
; 190  : 	if( !str ) return 0;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN9@Q_atoi
	xor	eax, eax
	jmp	$LN1@Q_atoi
$LN9@Q_atoi:

; 191  : 	
; 192  : 	if( *str == '-' )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN10@Q_atoi

; 193  : 	{
; 194  : 		sign = -1;

	mov	DWORD PTR _sign$[ebp], -1

; 195  : 		str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	jmp	SHORT $LN11@Q_atoi
$LN10@Q_atoi:

; 196  : 	}
; 197  : 	else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN11@Q_atoi:

; 198  : 		
; 199  : 	// check for hex
; 200  : 	if( str[0] == '0' && ( str[1] == 'x' || str[1] == 'X' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jne	$LN12@Q_atoi
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN13@Q_atoi
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 88					; 00000058H
	jne	$LN12@Q_atoi
$LN13@Q_atoi:

; 201  : 	{
; 202  : 		str += 2;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str$[ebp], ecx
$LN4@Q_atoi:

; 203  : 		while( 1 )

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN12@Q_atoi

; 204  : 		{
; 205  : 			c = *str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 206  : 			if( c >= '0' && c <= '9' ) val = (val<<4) + c - '0';

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN14@Q_atoi
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN14@Q_atoi
	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN15@Q_atoi
$LN14@Q_atoi:

; 207  : 			else if( c >= 'a' && c <= 'f' ) val = (val<<4) + c - 'a' + 10;

	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN16@Q_atoi
	cmp	DWORD PTR _c$[ebp], 102			; 00000066H
	jg	SHORT $LN16@Q_atoi
	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-87]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN15@Q_atoi
$LN16@Q_atoi:

; 208  : 			else if( c >= 'A' && c <= 'F' ) val = (val<<4) + c - 'A' + 10;

	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN18@Q_atoi
	cmp	DWORD PTR _c$[ebp], 70			; 00000046H
	jg	SHORT $LN18@Q_atoi
	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-55]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN15@Q_atoi
$LN18@Q_atoi:

; 209  : 			else return val * sign;

	mov	eax, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR _sign$[ebp]
	jmp	SHORT $LN1@Q_atoi
$LN15@Q_atoi:

; 210  : 		}

	jmp	SHORT $LN4@Q_atoi
$LN12@Q_atoi:

; 211  : 	}
; 212  : 	
; 213  : 	// check for character
; 214  : 	if( str[0] == '\'' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN6@Q_atoi

; 215  : 		return sign * str[1];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	imul	eax, DWORD PTR _sign$[ebp]
	jmp	SHORT $LN1@Q_atoi
$LN6@Q_atoi:

; 216  : 	
; 217  : 	// assume decimal
; 218  : 	while( 1 )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@Q_atoi

; 219  : 	{
; 220  : 		c = *str++;

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 221  : 		if( c < '0' || c > '9' )

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN22@Q_atoi
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	SHORT $LN21@Q_atoi
$LN22@Q_atoi:

; 222  : 			return val * sign;

	mov	eax, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR _sign$[ebp]
	jmp	SHORT $LN1@Q_atoi
$LN21@Q_atoi:

; 223  : 		val = val * 10 + c - '0';

	imul	edx, DWORD PTR _val$[ebp], 10
	mov	eax, DWORD PTR _c$[ebp]
	lea	ecx, DWORD PTR [edx+eax-48]
	mov	DWORD PTR _val$[ebp], ecx

; 224  : 	}

	jmp	SHORT $LN6@Q_atoi
$LN7@Q_atoi:

; 225  : 	return 0;

	xor	eax, eax
$LN1@Q_atoi:

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_atoi@@YAHPBD@Z ENDP					; Q_atoi
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_b$ = -4						; size = 4
_s$ = 8							; size = 4
?copystring@@YAPADPBD@Z PROC				; copystring

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 171  : 	if( !s ) return NULL;

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN2@copystring
	xor	eax, eax
	jmp	SHORT $LN1@copystring
$LN2@copystring:

; 172  : 
; 173  : 	char *b = new char[Q_strlen( s ) + 1];

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _b$[ebp], ecx

; 174  : 	Q_strcpy( b, s );

	push	99999					; 0001869fH
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 175  : 
; 176  : 	return b;

	mov	eax, DWORD PTR _b$[ebp]
$LN1@copystring:

; 177  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?copystring@@YAPADPBD@Z ENDP				; copystring
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv82 = -20						; size = 4
tv74 = -16						; size = 4
_d$ = -12						; size = 4
_s$ = -8						; size = 4
_n$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
?Q_strncpy@@YAIPADPBDI@Z PROC				; Q_strncpy

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 142  : 	if( !dst || !src || !size )

	cmp	DWORD PTR _dst$[ebp], 0
	je	SHORT $LN8@Q_strncpy
	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN8@Q_strncpy
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN7@Q_strncpy
$LN8@Q_strncpy:

; 143  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Q_strncpy
$LN7@Q_strncpy:

; 144  : 
; 145  : 	register char *d = dst;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 146  : 	register const char	*s = src;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	DWORD PTR _s$[ebp], ecx

; 147  : 	register size_t n = size;

	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _n$[ebp], edx

; 148  : 
; 149  : 	// copy as many bytes as will fit
; 150  : 	if( n != 0 && --n != 0 )

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN9@Q_strncpy
	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	je	SHORT $LN9@Q_strncpy
$LN4@Q_strncpy:

; 151  : 	{
; 152  : 		do
; 153  : 		{
; 154  : 			if(( *d++ = *s++ ) == 0 )

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _d$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv74[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 0
	jne	SHORT $LN2@Q_strncpy

; 155  : 				break;

	jmp	SHORT $LN9@Q_strncpy
$LN2@Q_strncpy:

; 156  : 		} while( --n != 0 );

	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, 1
	mov	DWORD PTR _n$[ebp], edx
	jne	SHORT $LN4@Q_strncpy
$LN9@Q_strncpy:

; 157  : 	}
; 158  : 
; 159  : 	// not enough room in dst, add NULL and traverse rest of src
; 160  : 	if( n == 0 )

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN11@Q_strncpy

; 161  : 	{
; 162  : 		if( size != 0 )

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN5@Q_strncpy

; 163  : 			*d = '\0'; // NULL-terminate dst

	mov	eax, DWORD PTR _d$[ebp]
	mov	BYTE PTR [eax], 0
$LN5@Q_strncpy:

; 164  : 		while( *s++ );

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN11@Q_strncpy
	jmp	SHORT $LN5@Q_strncpy
$LN11@Q_strncpy:

; 165  : 	}
; 166  : 	return ( s - src - 1 ); // count does not include NULL

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR _src$[ebp]
	sub	eax, 1
$LN1@Q_strncpy:

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strncpy@@YAIPADPBDI@Z ENDP				; Q_strncpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
tv69 = -20						; size = 4
_dlen$ = -16						; size = 4
_s$ = -12						; size = 4
_d$ = -8						; size = 4
_n$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
?Q_strncat@@YAIPADPBDI@Z PROC				; Q_strncat

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 111  : 	if( !dst || !src || !size )

	cmp	DWORD PTR _dst$[ebp], 0
	je	SHORT $LN7@Q_strncat
	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN7@Q_strncat
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN6@Q_strncat
$LN7@Q_strncat:

; 112  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Q_strncat
$LN6@Q_strncat:

; 113  : 
; 114  : 	register char *d = dst;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 115  : 	register const char	*s = src;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	DWORD PTR _s$[ebp], ecx

; 116  : 	register size_t n = size;

	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _n$[ebp], edx
$LN2@Q_strncat:

; 117  : 	size_t dlen;
; 118  : 
; 119  : 	// find the end of dst and adjust bytes left but don't go past end
; 120  : 	while( n-- != 0 && *d != '\0' ) d++;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@Q_strncat
	mov	edx, DWORD PTR _d$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@Q_strncat
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 1
	mov	DWORD PTR _d$[ebp], ecx
	jmp	SHORT $LN2@Q_strncat
$LN3@Q_strncat:

; 121  : 	dlen = d - dst;

	mov	edx, DWORD PTR _d$[ebp]
	sub	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _dlen$[ebp], edx

; 122  : 	n = size - dlen;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _dlen$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 123  : 
; 124  : 	if( n == 0 ) return( dlen + Q_strlen( s ));

	jne	SHORT $LN4@Q_strncat
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	add	eax, DWORD PTR _dlen$[ebp]
	jmp	SHORT $LN1@Q_strncat
$LN4@Q_strncat:

; 125  : 
; 126  : 	while( *s != '\0' )

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@Q_strncat

; 127  : 	{
; 128  : 		if( n != 1 )

	cmp	DWORD PTR _n$[ebp], 1
	je	SHORT $LN9@Q_strncat

; 129  : 		{
; 130  : 			*d++ = *s;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 1
	mov	DWORD PTR _d$[ebp], ecx

; 131  : 			n--;

	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, 1
	mov	DWORD PTR _n$[ebp], edx
$LN9@Q_strncat:

; 132  : 		}
; 133  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 134  : 	}

	jmp	SHORT $LN4@Q_strncat
$LN5@Q_strncat:

; 135  : 
; 136  : 	*d = '\0';

	mov	ecx, DWORD PTR _d$[ebp]
	mov	BYTE PTR [ecx], 0

; 137  : 	return( dlen + ( s - src )); // count does not include NULL

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR _src$[ebp]
	add	eax, DWORD PTR _dlen$[ebp]
$LN1@Q_strncat:

; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strncat@@YAIPADPBDI@Z ENDP				; Q_strncat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_out$ = -1						; size = 1
_in$ = 8						; size = 1
?Q_tolower@@YADD@Z PROC					; Q_tolower

; 99   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 100  : 	char	out;
; 101  : 
; 102  : 	if( in >= 'A' && in <= 'Z' )

	movsx	eax, BYTE PTR _in$[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN2@Q_tolower
	movsx	ecx, BYTE PTR _in$[ebp]
	cmp	ecx, 90					; 0000005aH
	jg	SHORT $LN2@Q_tolower

; 103  : 		out = in + 'a' - 'A';

	movsx	edx, BYTE PTR _in$[ebp]
	add	edx, 32					; 00000020H
	mov	BYTE PTR _out$[ebp], dl
	jmp	SHORT $LN3@Q_tolower
$LN2@Q_tolower:

; 104  : 	else out = in;

	mov	al, BYTE PTR _in$[ebp]
	mov	BYTE PTR _out$[ebp], al
$LN3@Q_tolower:

; 105  : 
; 106  : 	return out;

	mov	al, BYTE PTR _out$[ebp]

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_tolower@@YADD@Z ENDP					; Q_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_out$ = -1						; size = 1
_in$ = 8						; size = 1
?Q_toupper@@YADD@Z PROC					; Q_toupper

; 88   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 89   : 	char	out;
; 90   : 
; 91   : 	if( in >= 'a' && in <= 'z' )

	movsx	eax, BYTE PTR _in$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN2@Q_toupper
	movsx	ecx, BYTE PTR _in$[ebp]
	cmp	ecx, 122				; 0000007aH
	jg	SHORT $LN2@Q_toupper

; 92   : 		out = in + 'A' - 'a';

	movsx	edx, BYTE PTR _in$[ebp]
	sub	edx, 32					; 00000020H
	mov	BYTE PTR _out$[ebp], dl
	jmp	SHORT $LN3@Q_toupper
$LN2@Q_toupper:

; 93   : 	else out = in;

	mov	al, BYTE PTR _in$[ebp]
	mov	BYTE PTR _out$[ebp], al
$LN3@Q_toupper:

; 94   : 
; 95   : 	return out;

	mov	al, BYTE PTR _out$[ebp]

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_toupper@@YADD@Z ENDP					; Q_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_len$ = -8						; size = 4
_p$ = -4						; size = 4
_string$ = 8						; size = 4
?Q_strlen@@YAHPBD@Z PROC				; Q_strlen

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 75   : 	if( !string ) return 0;

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@Q_strlen
	xor	eax, eax
	jmp	SHORT $LN1@Q_strlen
$LN4@Q_strlen:

; 76   : 
; 77   : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 78   : 	const char *p = string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@Q_strlen:

; 79   : 	while( *p )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Q_strlen

; 80   : 	{
; 81   : 		p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 82   : 		len++;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 83   : 	}

	jmp	SHORT $LN2@Q_strlen
$LN3@Q_strlen:

; 84   : 	return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@Q_strlen:

; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Q_strlen@@YAHPBD@Z ENDP				; Q_strlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_str$ = 8						; size = 4
?Q_isdigit@@YA_NPBD@Z PROC				; Q_isdigit

; 64   : {

	push	ebp
	mov	ebp, esp

; 65   : 	if( str && *str )

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN4@Q_isdigit
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Q_isdigit
$LN2@Q_isdigit:

; 66   : 	{
; 67   : 		while( isdigit( *str )) str++;

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Q_isdigit
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx
	jmp	SHORT $LN2@Q_isdigit
$LN3@Q_isdigit:

; 68   : 		if( !*str ) return true;

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN4@Q_isdigit
	mov	al, 1
	jmp	SHORT $LN1@Q_isdigit
$LN4@Q_isdigit:

; 69   : 	}
; 70   : 	return false;

	xor	al, al
$LN1@Q_isdigit:

; 71   : }

	pop	ebp
	ret	0
?Q_isdigit@@YA_NPBD@Z ENDP				; Q_isdigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_size_out$ = 16						; size = 4
?Q_strnlwr@@YAXPBDPADI@Z PROC				; Q_strnlwr

; 50   : {

	push	ebp
	mov	ebp, esp

; 51   : 	if( size_out == 0 ) return;

	cmp	DWORD PTR _size_out$[ebp], 0
	jne	SHORT $LN2@Q_strnlwr
	jmp	SHORT $LN1@Q_strnlwr
$LN2@Q_strnlwr:

; 52   : 
; 53   : 	while( *in && size_out > 1 )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_strnlwr
	cmp	DWORD PTR _size_out$[ebp], 1
	jbe	SHORT $LN3@Q_strnlwr

; 54   : 	{
; 55   : 		if( *in >= 'A' && *in <= 'Z' )

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN5@Q_strnlwr
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jg	SHORT $LN5@Q_strnlwr

; 56   : 			*out++ = *in++ + 'a' - 'A';

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN6@Q_strnlwr
$LN5@Q_strnlwr:

; 57   : 		else *out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax
$LN6@Q_strnlwr:

; 58   : 		size_out--;

	mov	ecx, DWORD PTR _size_out$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _size_out$[ebp], ecx

; 59   : 	}

	jmp	SHORT $LN2@Q_strnlwr
$LN3@Q_strnlwr:

; 60   : 	*out = '\0';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 0
$LN1@Q_strnlwr:

; 61   : }

	pop	ebp
	ret	0
?Q_strnlwr@@YAXPBDPADI@Z ENDP				; Q_strnlwr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_size_out$ = 16						; size = 4
?Q_strnupr@@YAXPBDPADI@Z PROC				; Q_strnupr

; 36   : {

	push	ebp
	mov	ebp, esp

; 37   : 	if( size_out == 0 ) return;

	cmp	DWORD PTR _size_out$[ebp], 0
	jne	SHORT $LN2@Q_strnupr
	jmp	SHORT $LN1@Q_strnupr
$LN2@Q_strnupr:

; 38   : 
; 39   : 	while( *in && size_out > 1 )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_strnupr
	cmp	DWORD PTR _size_out$[ebp], 1
	jbe	SHORT $LN3@Q_strnupr

; 40   : 	{
; 41   : 		if( *in >= 'a' && *in <= 'z' )

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN5@Q_strnupr
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jg	SHORT $LN5@Q_strnupr

; 42   : 			*out++ = *in++ + 'A' - 'a';

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN6@Q_strnupr
$LN5@Q_strnupr:

; 43   : 		else *out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax
$LN6@Q_strnupr:

; 44   : 		size_out--;

	mov	ecx, DWORD PTR _size_out$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _size_out$[ebp], ecx

; 45   : 	}

	jmp	SHORT $LN2@Q_strnupr
$LN3@Q_strnupr:

; 46   : 	*out = '\0';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 0
$LN1@Q_strnupr:

; 47   : }

	pop	ebp
	ret	0
?Q_strnupr@@YAXPBDPADI@Z ENDP				; Q_strnupr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\stringlib.cpp
_TEXT	SEGMENT
_colon$ = -16						; size = 4
_backslash$ = -12					; size = 4
_dot$ = -8						; size = 4
_separator$ = -4					; size = 4
_in$ = 8						; size = 4
?UTIL_FileExtension@@YAPBDPBD@Z PROC			; UTIL_FileExtension

; 19   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 20   : 	const char *separator, *backslash, *colon, *dot;
; 21   : 
; 22   : 	separator = Q_strrchr( in, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _separator$[ebp], eax

; 23   : 	backslash = Q_strrchr( in, '\\' );

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 24   : 	if( !separator || separator < backslash )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN3@UTIL_FileE
	mov	edx, DWORD PTR _separator$[ebp]
	cmp	edx, DWORD PTR _backslash$[ebp]
	jae	SHORT $LN2@UTIL_FileE
$LN3@UTIL_FileE:

; 25   : 		separator = backslash;

	mov	eax, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN2@UTIL_FileE:

; 26   : 	colon = Q_strrchr( in, ':' );

	push	58					; 0000003aH
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 27   : 	if( !separator || separator < colon )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN5@UTIL_FileE
	mov	edx, DWORD PTR _separator$[ebp]
	cmp	edx, DWORD PTR _colon$[ebp]
	jae	SHORT $LN4@UTIL_FileE
$LN5@UTIL_FileE:

; 28   : 		separator = colon;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN4@UTIL_FileE:

; 29   : 	dot = Q_strrchr( in, '.' );

	push	46					; 0000002eH
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?Q_strrchr@@YAPADPBDD@Z			; Q_strrchr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax

; 30   : 	if( dot == NULL || (separator && ( dot < separator )))

	cmp	DWORD PTR _dot$[ebp], 0
	je	SHORT $LN7@UTIL_FileE
	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN6@UTIL_FileE
	mov	edx, DWORD PTR _dot$[ebp]
	cmp	edx, DWORD PTR _separator$[ebp]
	jae	SHORT $LN6@UTIL_FileE
$LN7@UTIL_FileE:

; 31   : 		return "";

	mov	eax, OFFSET $SG125411
	jmp	SHORT $LN1@UTIL_FileE
$LN6@UTIL_FileE:

; 32   : 	return dot + 1;

	mov	eax, DWORD PTR _dot$[ebp]
	add	eax, 1
$LN1@UTIL_FileE:

; 33   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_FileExtension@@YAPBDPBD@Z ENDP			; UTIL_FileExtension
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector@@QAEPAMXZ PROC				; Vector::operator float *, COMDAT
; _this$ = ecx

; 225  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\user\downloads\xashxt_v0.81_rev.1_with_sources\xashxt_v0.81_rev.1_src\game_shared\vector.h
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector@@QAE@ABV0@@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 133  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1409 :     {

	push	ebp
	mov	ebp, esp

; 1410 :         #pragma warning(push)
; 1411 :         #pragma warning(disable: 4996) // Deprecation
; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __BufferCount$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1413 :         #pragma warning(pop)
; 1414 :     }

	pop	ebp
	ret	0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1390 :         int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	___stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1395 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__G@YGXPAX0IIP6EPAX00@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IIP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	edx, DWORD PTR ___u$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	mov	ecx, DWORD PTR ___u$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IIP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR ___n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR ___n$[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	jmp	SHORT $LN2@vector
$LN1@vector:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
